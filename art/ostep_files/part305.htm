<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>29.4 Concurrent Hash Table</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part304.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part306.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">29.4 Concurrent Hash Table</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We end our discussion with a simple and widely applicable concurrent data structure, the hash table. We’ll focus on a simple hash table that does not resize; a little more work is required to handle resizing, which we leave as an exercise for the reader (sorry!).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This concurrent hash table is straightforward, is built using the con- current lists we developed earlier, and works incredibly well. The reason</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#define BUCKETS (101)</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">2</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;text-align: left;"><span class="s37">3  </span>typedef struct <span class="s75">&nbsp;</span>hash_t {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4    <span class="s38">list_t lists[BUCKETS];</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">} hash_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">6</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">7  </span>void Hash_Init(hash_t <span class="s39">*</span>H) {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">8    <span class="s38">int i;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">9     <span class="s38">for (i = 0; i &lt; BUCKETS; i++) {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10       <span class="s38">List_Init(&amp;H-&gt;lists[i]);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">13</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">14  </span>int Hash_Insert(hash_t <span class="s39">*</span>H, int key) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">15     <span class="s38">int bucket = key % BUCKETS;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16    <span class="s38">return List_Insert(&amp;H-&gt;lists[bucket], key);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">17  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">18</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">19  </span>int Hash_Lookup(hash_t <span class="s39">*</span>H, int key) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">20     <span class="s38">int bucket = key % BUCKETS;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">21    <span class="s38">return List_Lookup(&amp;H-&gt;lists[bucket], key);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">22  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 108pt;text-indent: 0pt;text-align: left;">Figure 29.9: <b>A Concurrent Hash Table</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">for its good performance is that instead of having a single lock for the en- tire structure, it uses a lock per hash bucket (each of which is represented by a list). Doing so enables many concurrent operations to take place.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Figure <span style=" color: #00AEEF;">29.10 </span>shows the performance of the hash table under concur- rent updates (from 10,000 to 50,000 concurrent updates from each of four threads, on the same iMac with four CPUs). Also shown, for the sake of comparison, is the performance of a linked list (with a single lock). As you can see from the graph, this simple concurrent hash table scales magnificently; the linked list, in contrast, does not.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="196" height="141" alt="image" src="Image_377.png"/></span></p><p class="s65" style="padding-top: 4pt;padding-left: 14pt;text-indent: 0pt;line-height: 90%;text-align: left;">Simple Concurrent List Concurrent Hash Table</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 110pt;text-indent: 0pt;text-align: left;">15</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 1pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Time (seconds)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 110pt;text-indent: 0pt;text-align: left;">10</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: left;">5</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 4pt;padding-left: 114pt;text-indent: 0pt;line-height: 8pt;text-align: left;">0</p><p class="s47" style="padding-left: 121pt;text-indent: 0pt;line-height: 8pt;text-align: left;">0   10   20   30   40</p><p class="s47" style="padding-top: 1pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">Inserts (Thousands)</p><p style="padding-left: 117pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Figure 29.10: <b>Scaling Hash Tables</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: A<span class="s7">VOID </span>P<span class="s7">REMATURE </span>O<span class="s7">PTIMIZATION </span>(K<span class="s7">NUTH</span>’<span class="s7">S </span>L<span class="s7">AW</span>)</p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">When building a concurrent data structure, start with the most basic ap- proach, which is to add a single big lock to provide synchronized access. By doing so, you are likely to build a <i>correct </i>lock; if you then find that it suffers from performance problems, you can refine it, thus only making it fast if need be. As <b>Knuth </b>famously stated, “Premature optimization is the root of all evil.”</p><p style="padding-top: 3pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Many operating systems added a single lock when transitioning to multi- processors, including Sun OS and Linux. In the latter, it even had a name, the <b>big kernel lock </b>(<b>BKL</b>), and was the source of performance problems for many years until it was finally removed in 2011. In SunOS (which was a BSD variant), the notion of removing the single lock protecting the kernel was so painful that the Sun engineers decided on a different route: building the entirely new Solaris operating system, which was multi-threaded from day one. Read the Linux and Solaris kernel books for more information [BC05, MM00].</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part304.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part306.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
