<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos343716" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_41"><span class="bold">6. Kernel Data Structures</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos343883"> </div>
<p class="calibre_2">This chapter introduces several built-in data structures for use in Linux kernel code. As with any large software project, the Linux kernel provides these generic data structures and primitives to encourage code reuse. Kernel developers should use these data structures whenever possible and not “roll your own” solutions. In the following sections, we cover the most useful of these generic data structures, which are the following:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <a href="#filepos345123">Linked lists</a></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <a href="#filepos379078">Queues</a></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <a href="#filepos391657">Maps</a></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <a href="#filepos403377">Binary trees</a></p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">We conclude the chapter with a discussion on algorithmic complexity, the ease with which algorithms and data structures scale to support ever larger inputs.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos345123"> </div>
<h3 class="calibre_21"><span class="bold">Linked Lists</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The linked list is the simplest and most common data structure in the Linux kernel. A <em class="calibre4">linked list</em> is a data structure that allows the storage and manipulation of a variable number of <em class="calibre4">elements</em>, called the <em class="calibre4">nodes</em> of the list. Unlike in a static array, the elements in a linked list are dynamically created and inserted into the list. This enables the management of a varying number of elements unknown at compile time. Because the elements are created at different times, they do not necessarily occupy contiguous regions in memory. Therefore, the elements need to be <em class="calibre4">linked</em> together; thus each element in the list contains a pointer to the <em class="calibre4">next</em> element. As elements are added to or removed from the list, the pointer to the next node is simply adjusted.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos346085"> </div>
<h4 class="calibre_27"><span class="calibre3">Singly and Doubly Linked Lists</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The simplest data structure representing such a linked list might look similar to the following:</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos346364"> </div>
<p class="calibre_31"><img alt="image" src="images/00045.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a href="#filepos346609">Figure 6.1</a> is a linked list.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos346609"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 6.1. A singly linked list.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00046.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">In some linked lists, each element also contains a pointer to the <em class="calibre4">previous</em> element. These lists are called <em class="calibre4">doubly linked lists</em> because they are linked both forward and backward. Linked lists, such as the list in <a href="#filepos346609">Figure 6.1</a>, that do not have a pointer to the previous element are called <em class="calibre4">singly linked lists</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">A data structure representing a doubly linked list would look similar to this:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00047.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a href="#filepos347633">Figure 6.2</a> is a doubly linked list.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos347633"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 6.2. A doubly linked list.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00048.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos347916"> </div>
<h4 class="calibre_27"><span class="calibre3">Circular Linked Lists</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Normally, because the last element in a linked list has no next element, it is set to point to a special value, such as <code class="calibre6"><span class="calibre7">NULL</span></code>, to indicate it is the last element in the list. In some linked lists, the last element does <em class="calibre4">not</em> point to a special value. Instead, it points back to the first value. This linked list is called a <em class="calibre4">circular linked list</em> because the list is cyclic. Circular linked lists can come in both doubly and singly linked versions. In a circular doubly linked list, <a id="filepos348570"></a>the first node’s “previous” pointer points at the last node. <a href="#filepos348832">Figures 6.3</a> and <a href="#filepos349124">6.4</a> are singly and doubly circular linked lists, respectively.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos348832"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 6.3. A circular singly linked list.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00049.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos349124"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 6.4. A circular doubly linked list.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00050.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Although the Linux kernel’s linked list implementation is unique, it is fundamentally a <em class="calibre4">circular doubly linked list</em>. Using this type of linked list provides the greatest flexibility.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos349664"> </div>
<h4 class="calibre_27"><span class="calibre3">Moving Through a Linked List</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Movement through a linked list occurs linearly. You visit one element, follow the next pointer, and visit the next element. Rinse and repeat. This is the easiest method of moving through a linked list, and the one for which linked lists are best suited. Linked lists are ill-suited for use cases where random access is an important operation. Instead, you use linked lists when iterating over the whole list is important and the dynamic addition and removal of elements is required.</p><div class="calibre_3"> </div>
<p class="calibre_2">In linked list implementations, the first element is often represented by a special pointer—called the <em class="calibre4">head</em>—that enables easy access to the “start” of the list. In a noncircular-linked list, the last element is delineated by its next pointer being <code class="calibre6"><span class="calibre7">NULL</span></code>. In a circular-linked list, the last element is delineated because it points to the head element. Traversing the list, therefore, occurs linearly through each element from the first to the last. In a doubly linked list, movement can also occur backward, linearly from the last element to the <a id="filepos350940"></a>first. Of course, given a specific element in the list, you can iterate backward and forward any number of elements, too. You need not traverse the whole list.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos351150"> </div>
<h4 class="calibre_27"><span class="calibre3">The Linux Kernel’s Implementation</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">In comparison to most linked list implementations—including the generic approach described in the previous sections—the Linux kernel’s implementation is unique. Recall from the earlier discussion that data (or a grouping of data, such as a <code class="calibre6"><span class="calibre7">struct</span></code>) is maintained in a linked list by adding a <em class="calibre4">next</em> (and perhaps a <em class="calibre4">previous</em>) node pointer to the data. For example, assume we had a <code class="calibre6"><span class="calibre7">fox</span></code> structure to describe that member of the <em class="calibre4">Canidae</em> family:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00051.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The common pattern for storing this structure in a linked list is to embed the list pointer in the structure. For example:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00052.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The Linux kernel approach is different. Instead of turning the structure into a linked list, the Linux approach is to <em class="calibre4">embed a linked list node in the structure</em>!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos352462"> </div>
<h5 class="calibre_29"><span class="calibre3">The Linked List Structure</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">In the old days, there were multiple implementations of linked lists in the kernel. A single, powerful linked list implementation was needed to remove duplicate code. During the 2.1 kernel development series, the official kernel linked-list implementation was introduced. All existing uses of linked lists now use the official implementation; do not reinvent the wheel!</p><div class="calibre_3"> </div>
<p class="calibre_2">The linked-list code is declared in the header file <code class="calibre6"><span class="calibre7">&lt;linux/list.h&gt;</span></code> and the data structure is simple:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct list_head {<br class="calibre1"/>        struct list_head *next<br class="calibre1"/>        struct list_head *prev;<br class="calibre1"/>};</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">next</span></code> pointer points to the next list node, and the <code class="calibre6"><span class="calibre7">prev</span></code> pointer points to the previous list node. Yet, seemingly, this is not particularly useful. What value is a giant linked list...of linked list nodes? The utility is in <em class="calibre4">how</em> the <code class="calibre6"><span class="calibre7">list_head</span></code> structure is used:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00053.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos353996"></a>With this, <code class="calibre6"><span class="calibre7">list.next</span></code> in <code class="calibre6"><span class="calibre7">fox</span></code> points to the next element, and <code class="calibre6"><span class="calibre7">list.prev</span></code> in <code class="calibre6"><span class="calibre7">fox</span></code> points to the previous. Now this is becoming useful, but it gets better. The kernel provides a family of routines to manipulate linked lists. For example, the <code class="calibre6"><span class="calibre7">list_add()</span></code> method adds a new node to an existing linked list. These methods, however, are generic: They accept only <code class="calibre6"><span class="calibre7">list_head</span></code> structures. Using the macro <code class="calibre6"><span class="calibre7">container_of()</span></code>, we can easily find the parent structure containing any given member variable. This is because in C, the offset of a given variable into a structure is fixed by the ABI at compile time.</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00054.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Using <code class="calibre6"><span class="calibre7">container_of()</span></code>, we can define a simple function to return the parent structure containing any <code class="calibre6"><span class="calibre7">list_head</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">#define list_entry(ptr, type, member) \<br class="calibre1"/>        container_of(ptr, type, member)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Armed with <code class="calibre6"><span class="calibre7">list_entry()</span></code>, the kernel provides routines to create, manipulate, and otherwise manage linked lists—all without knowing anything about the structures that the <code class="calibre6"><span class="calibre7">list_head</span></code> resides within.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos355749"> </div>
<h5 class="calibre_29"><span class="calibre3">Defining a Linked List</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">As shown, a <code class="calibre6"><span class="calibre7">list_head</span></code> by itself is worthless; it is normally embedded inside your own structure:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00055.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The list needs to be initialized before it can be used. Because most of the elements are created dynamically (probably why you need a linked list), the most common way of initializing the linked list is at runtime:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct fox *red_fox;<br class="calibre1"/>red_fox = kmalloc(sizeof(*red_fox), GFP_KERNEL);<br class="calibre1"/>red_fox-&gt;tail_length = 40;<br class="calibre1"/>red_fox-&gt;weight = 6;<br class="calibre1"/>red_fox-&gt;is_fantastic = false;<br class="calibre1"/>INIT_LIST_HEAD(&amp;red_fox-&gt;list);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos356727"></a>If the structure is statically created at compile time, and you have a direct reference to it, you can simply do this:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct fox red_fox = {<br class="calibre1"/>  .tail_length = 40,<br class="calibre1"/>  .weight = 6,<br class="calibre1"/>  .list  = LIST_HEAD_INIT(red_fox. list),<br class="calibre1"/>};</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos357158"> </div>
<h5 class="calibre_29"><span class="calibre3">List Heads</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The previous section shows how easy it is to take an existing structure—such as our <code class="calibre6"><span class="calibre7">struct fox</span></code> example—and turn it into a linked list. With simple code changes, our structure is now manageable by the kernel’s linked list routines. But before we can use those routines, we need a canonical pointer to refer to the list as a whole—a <em class="calibre4">head</em> pointer.</p><div class="calibre_3"> </div>
<p class="calibre_2">One nice aspect of the kernel’s linked list implementation is that our fox nodes are indistinguishable. Each contains a <code class="calibre6"><span class="calibre7">list_head</span></code>, and we can iterate from any one node to the next, until we have seen every node. This approach is elegant, but you will generally want a special pointer that refers to your linked list, without being a list node itself. Interestingly, this special node is in fact a normal <code class="calibre6"><span class="calibre7">list_head</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static LIST_HEAD(fox_list);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This defines and initializes a <code class="calibre6"><span class="calibre7">list_head</span></code> named <code class="calibre6"><span class="calibre7">fox_list</span></code>. The majority of the linked list routines accept one or two parameters: the head node or the head node plus an actual list node. Let’s look at those routines.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos358745"> </div>
<h4 class="calibre_27"><span class="calibre3">Manipulating Linked Lists</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The kernel provides a family of functions to manipulate linked lists. They all take pointers to one or more <code class="calibre6"><span class="calibre7">list_head</span></code> structures. The functions are implemented as inline functions in generic C and can be found in <code class="calibre6"><span class="calibre7">&lt;linux/list.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Interestingly, all these functions are <code class="calibre6"><span class="calibre7">O(1)</span></code>.<sup class="calibre8"><a id="filepos359311" href="#filepos359710">1</a></sup> This means they execute in <em class="calibre4">constant time</em>, regardless of the size of the list or any other inputs. For example, it takes the same amount of time to add or remove an entry to or from a list whether that list has 3 or 3,000 entries. This is perhaps not surprising, but still good to know.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos359710" href="#filepos359311">1</a></sup>
<em class="calibre4">See the section “<a href="#filepos416872">Algorithmic Complexity</a>,” later in this chapter, for a discussion on <code class="calibre6"><span class="calibre7">O(1)</span></code>.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos359987"> </div>
<h5 class="calibre_29"><span class="calibre3">Adding a Node to a Linked List</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">To add a node to a linked list:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_add(struct list_head *new, struct list_head *head)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos360359"></a>This function adds the <code class="calibre6"><span class="calibre7">new</span></code> node to the given list immediately <em class="calibre4">after</em> the <code class="calibre6"><span class="calibre7">head</span></code> node. Because the list is circular and generally has no concept of <em class="calibre4">first</em> or <em class="calibre4">last</em> nodes, you can pass any element for <code class="calibre6"><span class="calibre7">head</span></code>. If you do pass the “last” element, however, this function can be used to implement a stack.</p><div class="calibre_3"> </div>
<p class="calibre_2">Returning to our fox example, assume we had a new <code class="calibre6"><span class="calibre7">struct fox</span></code> that we wanted to add to the <code class="calibre6"><span class="calibre7">fox_list</span></code> list. We’d do this:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_add(&amp;f-&gt;list, &amp;fox_list);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">To add a node to the end of a linked list:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_add_tail(struct list_head *new, struct list_head *head)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function adds the <code class="calibre6"><span class="calibre7">new</span></code> node to the given list immediately <em class="calibre4">before</em> the <code class="calibre6"><span class="calibre7">head</span></code> node. As with <code class="calibre6"><span class="calibre7">list_add()</span></code>, because the lists are circular, you can generally pass any element for <code class="calibre6"><span class="calibre7">head</span></code>. This function can be used to implement a queue, however, if you pass the “first” element.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos361972"> </div>
<h5 class="calibre_29"><span class="calibre3">Deleting a Node from a Linked List</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">After adding a node to a linked list, deleting a node from a list is the next most important operation. To delete a node from a linked list, use <code class="calibre6"><span class="calibre7">list_del()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_del(struct list_head *entry)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function removes the element <code class="calibre6"><span class="calibre7">entry</span></code> from the list. Note that it does not free any memory belonging to <code class="calibre6"><span class="calibre7">entry</span></code> or the data structure in which it is embedded; this function merely removes the element from the list. After calling this, you would typically destroy your data structure and the <code class="calibre6"><span class="calibre7">list_head</span></code> inside it.</p><div class="calibre_3"> </div>
<p class="calibre_2">For example, to delete the <code class="calibre6"><span class="calibre7">fox</span></code> node we previous added to <code class="calibre6"><span class="calibre7">fox_list</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_del(&amp;f-&gt;list);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Note the function does not receive as input <code class="calibre6"><span class="calibre7">fox_list</span></code>. It simply receives a specific node and modifies the pointers of the previous and subsequent nodes such that the given node is no longer part of the list. The implementation is instructive:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00056.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos363685"></a>To delete a node from a linked list and reinitialize it, the kernel provides <code class="calibre6"><span class="calibre7">list_del_init()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_del_init(struct list_head *entry)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function behaves the same as <code class="calibre6"><span class="calibre7">list_del()</span></code>, except it also reinitializes the given <code class="calibre6"><span class="calibre7">list_head</span></code> with the rationale that you no longer want the entry in the list, but you can reuse the data structure itself.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos364331"> </div>
<h5 class="calibre_29"><span class="calibre3">Moving and Splicing Linked List Nodes</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">To move a node from one list to another</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_move(struct list_head *list, struct list_head *head)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function removes the <code class="calibre6"><span class="calibre7">list</span></code> entry from its linked list and adds it to the given list <em class="calibre4">after</em> the <code class="calibre6"><span class="calibre7">head</span></code> element.</p><div class="calibre_3"> </div>
<p class="calibre_2">To move a node from one list to the end of another</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_move_tail(struct list_head *list, struct list_head *head)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function does the same as <code class="calibre6"><span class="calibre7">list_move()</span></code>, but inserts the <code class="calibre6"><span class="calibre7">list</span></code> element <em class="calibre4">before</em> the <code class="calibre6"><span class="calibre7">head</span></code> entry.</p><div class="calibre_3"> </div>
<p class="calibre_2">To check whether a list is empty</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_empty(struct list_head *head)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This returns nonzero if the given list is empty; otherwise, it returns zero.</p><div class="calibre_3"> </div>
<p class="calibre_2">To splice two unconnected lists together</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_splice(struct list_head *list, struct list_head *head)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function splices together two lists by inserting the list pointed to by <code class="calibre6"><span class="calibre7">list</span></code> to the given list after the element <code class="calibre6"><span class="calibre7">head</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">To splice two unconnected lists together and reinitialize the old list</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_splice_init(struct list_head *list, struct list_head *head)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function works the same as <code class="calibre6"><span class="calibre7">list_splice()</span></code>, except that the emptied list pointed to by <code class="calibre6"><span class="calibre7">list</span></code> is reinitialized.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Saving a Couple Dereferences</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">If you happen to already have the <code class="calibre6"><span class="calibre7">next</span></code> and <code class="calibre6"><span class="calibre7">prev</span></code> pointers available, you can save a couple cycles (specifically, the dereferences to get the pointers) by calling the internal list functions directly. Every previously discussed function actually does nothing except find the <code class="calibre6"><span class="calibre7">next</span></code> and <code class="calibre6"><span class="calibre7">prev</span></code> pointers and then call the internal functions. The internal functions generally have the same name as their wrappers, except they are prefixed by double underscores. For example, rather than call <code class="calibre6"><span class="calibre7">list_del(list)</span></code>, you can call <code class="calibre6"><span class="calibre7">__list_del(prev, next)</span></code>. This is useful only if the next and previous pointers are <em class="calibre4">already</em> dereferenced. Otherwise, you are just writing ugly code. See the header <code class="calibre6"><span class="calibre7">&lt;linux/list.h&gt;</span></code> for the exact interfaces.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos368175"> </div>
<h4 class="calibre_27"><span class="calibre3">Traversing Linked Lists</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos368300"> </div>
<p class="calibre_2">Now you know how to declare, initialize, and manipulate a linked list in the kernel. This is all very well and good, but it is meaningless if you have no way to access your data! The linked lists are just containers that hold your important data; you need a way to use lists to move around and access the actual structures that contain the data. The kernel (thank goodness) provides a nice set of interfaces for traversing linked lists and referencing the data structures that include them.</p><div class="calibre_3"> </div>
<p class="calibre_2">Note that, unlike the list manipulation routines, iterating over a linked list in its entirety is clearly an <code class="calibre6"><span class="calibre7">O(n)</span></code> operation, for <em class="calibre4"><code class="calibre6"><span class="calibre7">n</span></code></em> entries in the list.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos369173"> </div>
<h5 class="calibre_29"><span class="calibre3">The Basic Approach</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The most basic way to iterate over a list is with the <code class="calibre6"><span class="calibre7">list_for_each()</span></code>macro. The macro takes two parameters, both <code class="calibre6"><span class="calibre7">list_head</span></code> structures. The first is a pointer used to point to the current entry; it is a temporary variable that you must provide. The second is the <code class="calibre6"><span class="calibre7">list_head</span></code> acting as the head node of the list you want to traverse (see the earlier section, “<a href="#filepos357158">List Heads</a>”). On each iteration of the loop, the first parameter points to the next entry in the list, until each entry has been visited. Usage is as follows:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00057.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Well, that is still worthless! A pointer to the list structure is usually no good; what we need is a pointer to the structure that contains the <code class="calibre6"><span class="calibre7">list_head</span></code>. For example, with the previous <code class="calibre6"><span class="calibre7">fox</span></code> structure example, we want a pointer to each <code class="calibre6"><span class="calibre7">fox</span></code>, not a pointer to the <code class="calibre6"><span class="calibre7">list</span></code> member in the structure. We can use the macro <code class="calibre6"><span class="calibre7">list_entry()</span></code>, which we discussed earlier, to retrieve the structure that contains a given <code class="calibre6"><span class="calibre7">list_head</span></code>. For example:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00058.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos370864"> </div>
<h5 class="calibre_29"><span class="calibre3">The Usable Approach</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The previous approach does not make for particularly intuitive or elegant code, although it does illustrate how <code class="calibre6"><span class="calibre7">list_head</span></code> nodes function. Consequently, most kernel code uses the <code class="calibre6"><span class="calibre7">list_for_each_entry()</span></code> macro to iterate over a linked list. This macro handles the work performed by <code class="calibre6"><span class="calibre7">list_entry()</span></code>, making list iteration simple:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_for_each_entry(pos, head, member)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos371603"></a>Here, <code class="calibre6"><span class="calibre7">pos</span></code> is a pointer to the object containing the <code class="calibre6"><span class="calibre7">list_head</span></code> nodes. Think of it as the return value from <code class="calibre6"><span class="calibre7">list_entry()</span></code>. <code class="calibre6"><span class="calibre7">head</span></code> is a pointer to the <code class="calibre6"><span class="calibre7">list_head</span></code> head node from which you want to start iterating—in our previous example, <code class="calibre6"><span class="calibre7">fox_list</span></code>. <code class="calibre6"><span class="calibre7">member</span></code> is the variable name of the <code class="calibre6"><span class="calibre7">list_head</span></code> structure in <code class="calibre6"><span class="calibre7">pos</span></code>—<code class="calibre6"><span class="calibre7">list</span></code> in our example. This sounds confusing, but it is easy to use. Here is how we would rewrite the previous <code class="calibre6"><span class="calibre7">list_for_each()</span></code> to iterate over every fox node:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00059.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Now let’s look at a real example, from <em class="calibre4">inotify</em>, the kernel’s filesystem notification system:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00060.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This function iterates over all the entries in the <code class="calibre6"><span class="calibre7">inode-&gt;inotify_watches</span></code> list. Each entry is of type <code class="calibre6"><span class="calibre7">struct inotify_watch</span></code> and the <code class="calibre6"><span class="calibre7">list_head</span></code> in that structure is named <code class="calibre6"><span class="calibre7">i_list</span></code>. With each iteration of the loop, <code class="calibre6"><span class="calibre7">watch</span></code> points at a new node in the list. The purpose of this simple function is to search the <code class="calibre6"><span class="calibre7">inotify_watches</span></code> list in the provided <code class="calibre6"><span class="calibre7">inode</span></code> structure to find an <code class="calibre6"><span class="calibre7">inotify_watch</span></code> entry whose <code class="calibre6"><span class="calibre7">inotify_handle</span></code> matches the provided handle.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos373652"> </div>
<h5 class="calibre_29"><span class="calibre3">Iterating Through a List Backward</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The macro <code class="calibre6"><span class="calibre7">list_for_each_entry_reverse()</span></code> works just like <code class="calibre6"><span class="calibre7">list_for_each_entry()</span></code>, except that it moves through the list in reverse. That is, instead of following the <code class="calibre6"><span class="calibre7">next</span></code> pointers <em class="calibre4">forward</em> through the list, it follows the <code class="calibre6"><span class="calibre7">prev</span></code> pointers <em class="calibre4">backward</em>. Usage is the same as with <code class="calibre6"><span class="calibre7">list_for_each_entry()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_for_each_entry_reverse(pos, head, member)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">There are only a handful of reasons to favor moving through a list in reverse. One is performance: If you know the item you are searching for is likely <em class="calibre4">behind</em> the node you are starting your search from, you can move backward in hopes of finding it sooner. A second reason is if ordering is important. For example, if you use a linked list as a stack, you can walk the list from the tail backward to achieve <em class="calibre4">last-in/first-out (LIFO)</em> ordering. If you do <a id="filepos374940"></a>not have an explicit reason to move through the list in reverse, don’t—just use <code class="calibre6"><span class="calibre7">list_for_each_entry()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos375140"> </div>
<h5 class="calibre_29"><span class="calibre3">Iterating While Removing</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The standard list iteration methods are not appropriate if you are removing entries from the list as you iterate. The standard methods rely on the fact that the list entries are not changing out from under them, and thus if the current entry is removed in the body of the loop, the subsequent iteration cannot advance to the next (or previous) pointer. This is a common pattern in loops, and programmers solve it by storing the next (or previous) pointer in a temporary variable <em class="calibre4">prior</em> to a potential removal operation. The Linux kernel provides a routine to handle this situation for you:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_for_each_entry_safe(pos, next, head, member)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">You use this version in the same manner as <code class="calibre6"><span class="calibre7">list_for_each_entry()</span></code>, except that you provide the <code class="calibre6"><span class="calibre7">next</span></code> pointer, which is of the same type as <code class="calibre6"><span class="calibre7">pos</span></code>. The next pointer is used by the <code class="calibre6"><span class="calibre7">list_for_each_entry_safe()</span></code> macro to store the next entry in the list, making it safe to remove the current entry. Let’s consider an example, again in inotify:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00061.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This function iterates over and removes all the entries in the <code class="calibre6"><span class="calibre7">inotify_watches</span></code> list. If the standard <code class="calibre6"><span class="calibre7">list_for_each_entry()</span></code> were used, this code would introduce a use-after-free bug, as moving to the next item in the list would require accessing <code class="calibre6"><span class="calibre7">watch</span></code>, which was destroyed.</p><div class="calibre_3"> </div>
<p class="calibre_2">If you need to iterate over a linked list in reverse and potentially remove elements, the kernel provides <code class="calibre6"><span class="calibre7">list_for_each_entry_safe_reverse()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_for_each_entry_safe_reverse(pos, n, head, member)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Usage is the same as with <code class="calibre6"><span class="calibre7">list_for_each_entry_safe()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos377634"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">You May Still Need Locking!</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">The “safe” variants of <code class="calibre6"><span class="calibre7">list_for_each_entry()</span></code> protect you <em class="calibre4">only</em> from removals from the list <em class="calibre4">within</em> the body of the loop. If there is a chance of concurrent removals from other code—or any other form of concurrent list manipulation—you need to properly lock access to the list.</p><div class="calibre_3"> </div>
<p class="calibre_2">See <a href="index_split_018.html#filepos575425">Chapters 9</a>, “An Introduction to Kernel Synchronization,” and <a href="index_split_019.html#filepos613760">Chapter 10</a>, “Kernel Synchronization Methods,” for a discussion on synchronization and locking.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos378672"> </div>
<h5 class="calibre_29"><span class="calibre3">Other Linked List Methods</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">Linux provides myriad other list methods, enabling seemingly every conceivable way to access and manipulate a linked list. All these methods are defined in the header file <code class="calibre6"><span class="calibre7">&lt;linux/list.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos379078"> </div>
<h3 class="calibre_21"><span class="bold">Queues</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">A common programming pattern in any operating system kernel is <em class="calibre4">producer and consumer</em>. In this pattern, a producer creates data—say, error messages to be read or networking packets to be processed—while a consumer, in turn, reads, processes, or otherwise <em class="calibre4">consumes</em> the data. Often the easiest way to implement this pattern is with a <em class="calibre4">queue</em>. The producer pushes data onto the queue and the consumer pulls data off the queue. The consumer retrieves the data in the order it was enqueued. That is, the first data on the queue is the first data off the queue. For this reason, queues are also called <em class="calibre4">FIFOs</em>, short for <em class="calibre4">first-in, first-out</em>. See <a href="#filepos380003">Figure 6.5</a> for an example of a standard queue.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos380003"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 6.5. A queue (FIFO).</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00062.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos380280"></a>The Linux kernel’s generic queue implementation is called <em class="calibre4">kfifo</em> and is implemented in <code class="calibre6"><span class="calibre7">kernel/kfifo.c</span></code> and declared in <code class="calibre6"><span class="calibre7">&lt;linux/kfifo.h&gt;</span></code>. This section discusses the API after an update in 2.6.33. Usage is slightly different in kernel versions prior to 2.6.33—double-check <code class="calibre6"><span class="calibre7">&lt;linux/kfifo.h&gt;</span></code> before writing code.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos380773"> </div>
<h4 class="calibre_27"><span class="calibre3">kfifo</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Linux’s kfifo works like most other queue abstractions, providing two primary operations: enqueue (unfortunately named <em class="calibre4">in</em>) and dequeue (<em class="calibre4">out</em>). The kfifo object maintains two offsets into the queue: an <em class="calibre4">in offset</em> and an <em class="calibre4">out offset</em>. The in offset is the location in the queue to which the next enqueue will occur. The out offset is the location in the queue from which the next dequeue will occur. The out offset is always less than or equal to the in offset. It wouldn’t make sense for it to be greater; otherwise, you could dequeue data that had not yet been enqueued.</p><div class="calibre_3"> </div>
<p class="calibre_2">The enqueue (in) operation copies data into the queue, starting at the in offset. When complete, the in offset is incremented by the amount of data enqueued. The dequeue (out) operation copies data out of the queue, starting from the out offset. When complete, the out offset is incremented by the amount of data enqueued. When the out offset is equal to the in offset, the queue is empty: No more data can be dequeued until more data is enqueued. When the in offset is equal to the length of the queue, no more data can be enqueued until the queue is reset.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos382154"> </div>
<h4 class="calibre_27"><span class="calibre3">Creating a Queue</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">To use a kfifo, you must first define and initialize it. As with most kernel objects, you can do this dynamically or statically. The most common method is dynamic:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int kfifo_alloc(struct kfifo *fifo, unsigned int size, gfp_t gfp_mask);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function creates and initializes a kfifo with a queue of <code class="calibre6"><span class="calibre7">size</span></code> bytes. The kernel uses the <em class="calibre4">gfp mask</em>
<code class="calibre6"><span class="calibre7">gfp_mask</span></code> to allocate the queue. (We discuss memory allocations in <a href="index_split_021.html#filepos778361">Chapter 12</a>, “Memory Management”). Upon success, <code class="calibre6"><span class="calibre7">kfifo_alloc()</span></code> returns zero; on error it returns a negative error code. Following is a simple example:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00063.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">If you want to allocate the buffer yourself, you can:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void kfifo_init(struct kfifo *fifo, void *buffer, unsigned int size);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos383546"></a>This function creates and initializes a kfifo that will use the <code class="calibre6"><span class="calibre7">size</span></code> bytes of memory pointed at by <code class="calibre6"><span class="calibre7">buffer</span></code> for its queue. With both <code class="calibre6"><span class="calibre7">kfifo_alloc()</span></code> and <code class="calibre6"><span class="calibre7">kfifo_init()</span></code>, <code class="calibre6"><span class="calibre7">size</span></code> must be a power of two.</p><div class="calibre_3"> </div>
<p class="calibre_2">Statically declaring a kfifo is simpler, but less common:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">DECLARE_KFIFO(name, size);<br class="calibre1"/>INIT_KFIFO(name);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This creates a static kfifo named <code class="calibre6"><span class="calibre7">name</span></code> with a queue of <code class="calibre6"><span class="calibre7">size</span></code> bytes. As before, <code class="calibre6"><span class="calibre7">size</span></code> must be a power of 2.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos384482"> </div>
<h4 class="calibre_27"><span class="calibre3">Enqueuing Data</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When your kfifo is created and initialized, enqueuing data into the queue is performed via the <code class="calibre6"><span class="calibre7">kfifo_in()</span></code> function:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">unsigned int kfifo_in(struct kfifo *fifo, const void *from, unsigned int len);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function copies the <code class="calibre6"><span class="calibre7">len</span></code> bytes starting at <code class="calibre6"><span class="calibre7">from</span></code> into the queue represented by <code class="calibre6"><span class="calibre7">fifo</span></code>. On success it returns the number of bytes enqueued. If less than <code class="calibre6"><span class="calibre7">len</span></code> bytes are free in the queue, the function copies only up to the amount of available bytes. Thus the return value can be less than <code class="calibre6"><span class="calibre7">len</span></code> or even zero, if nothing was copied.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos385533"> </div>
<h4 class="calibre_27"><span class="calibre3">Dequeuing Data</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When you add data to a queue with <code class="calibre6"><span class="calibre7">kfifo_in()</span></code>, you can remove it with <code class="calibre6"><span class="calibre7">kfifo_out()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">unsigned int kfifo_out(struct kfifo *fifo, void *to, unsigned int len);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function copies at most <code class="calibre6"><span class="calibre7">len</span></code> bytes from the queue pointed at by <code class="calibre6"><span class="calibre7">fifo</span></code> to the buffer pointed at by <code class="calibre6"><span class="calibre7">to</span></code>. On success the function returns the number of bytes copied. If less than <code class="calibre6"><span class="calibre7">len</span></code> bytes are in the queue, the function copies less than requested.</p><div class="calibre_3"> </div>
<p class="calibre_2">When dequeued, data is no longer accessible from the queue. This is the normal usage of a queue, but if you want to “peek” at data within the queue without removing it, you can use <code class="calibre6"><span class="calibre7">kfifo_out_peek()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">unsigned int kfifo_out_peek(struct kfifo *fifo, void *to, unsigned int len, unsigned offset);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This works the same as <code class="calibre6"><span class="calibre7">kfifo_out()</span></code>, except that the out offset is not incremented, and thus the dequeued data is available to read on a subsequent call to <code class="calibre6"><span class="calibre7">kfifo_out()</span></code>. The parameter <code class="calibre6"><span class="calibre7">offset</span></code> specifies an index into the queue; specify zero to read from the head of the queue, as <code class="calibre6"><span class="calibre7">kfifo_out()</span></code> does.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos387438"> </div>
<h4 class="calibre_27"><span class="calibre3">Obtaining the Size of a Queue</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">To obtain the total size in bytes of the buffer used to store a kfifo’s queue, call <code class="calibre6"><span class="calibre7">kfifo_size()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static inline unsigned int kfifo_size(struct kfifo *fifo);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos387919"></a>In another example of horrible kernel naming, use <code class="calibre6"><span class="calibre7">kfifo_len()</span></code> to obtain the number of bytes enqueued in a kfifo:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static inline unsigned int kfifo_len(struct kfifo *fifo);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">To find out the number of bytes available to write into a kfifo, call <code class="calibre6"><span class="calibre7">kfifo_avail()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static inline unsigned int kfifo_avail(struct kfifo *fifo);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Finally, <code class="calibre6"><span class="calibre7">kfifo_is_empty()</span></code> and <code class="calibre6"><span class="calibre7">kfifo_is_full()</span></code> return nonzero if the given kfifo is empty or full, respectively, and zero if not:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static inline int kfifo_is_empty(struct kfifo *fifo);<br class="calibre1"/>static inline int kfifo_is_full(struct kfifo *fifo);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos389071"> </div>
<h4 class="calibre_27"><span class="calibre3">Resetting and Destroying the Queue</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">To reset a kfifo, jettisoning all the contents of the queue, call <code class="calibre6"><span class="calibre7">kfifo_reset()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static inline void kfifo_reset(struct kfifo *fifo);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">To destroy a kfifo allocated with <code class="calibre6"><span class="calibre7">kfifo_alloc()</span></code>, call <code class="calibre6"><span class="calibre7">kfifo_free()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void kfifo_free(struct kfifo *fifo);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If you created your kfifo with <code class="calibre6"><span class="calibre7">kfifo_init()</span></code>, it is your responsibility to free the associated buffer. How you do so depends on how you created it. See <a href="index_split_021.html#filepos778361">Chapter 12</a> for a discussion on allocating and freeing dynamic memory.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos390187"> </div>
<h4 class="calibre_27"><span class="calibre3">Example Queue Usage</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">With these interfaces under our belt, let’s take a look at a simple example of using a kfifo. Assume we created a kfifo pointed at by <code class="calibre6"><span class="calibre7">fifo</span></code> with a queue size of 8KB. We can now enqueue data onto the queue. In this example, we enqueue simple integers. In your own code, you will likely enqueue more complicated, task-specific structures. Using integers in this example, let’s see exactly how the kfifo works:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00064.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The kfifo named <code class="calibre6"><span class="calibre7">fifo</span></code> now contains 0 through 31, inclusive. We can take a peek at the first item in the queue and verify it is 0:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00065.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos391202"></a>To dequeue and print all the items in the kfifo, we can use <code class="calibre6"><span class="calibre7">kfifo_out()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00066.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This prints 0 through 31, inclusive, and in that order. (If this code snippet printed the numbers backward, from 31 to 0, we would have a stack, not a queue.)</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos391657"> </div>
<h3 class="calibre_21"><span class="bold">Maps</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">A <em class="calibre4">map</em>, also known as an <em class="calibre4">associative array</em>, is a collection of unique keys, where each key is associated with a specific value. The relationship between a key and its value is called a <em class="calibre4">mapping</em>. Maps support at least three operations:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Add (key, value)</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Remove (key)</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• value = Lookup (key)</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Although a hash table is a type of map, not all maps are implemented via hashes. Instead of a hash table, maps can also use a self-balancing binary search tree to store their data. Although a hash offers better average-case asymptotic complexity (see the section “<a href="#filepos416872">Algorithmic Complexity</a>” later in this chapter), a binary search tree has better worst-case behavior (logarithmic versus linear). A binary search tree also enables <em class="calibre4">order preservation</em>, enabling users to efficiently iterate over the entire collection in a sorted order. Finally, a binary search tree does not require a hash function; instead, any key type is suitable so long as it can define the <code class="calibre6"><span class="calibre7">&lt;=</span></code> operator.</p><div class="calibre_3"> </div>
<p class="calibre_2">Although the general term for all collections mapping a key to a value, the name <em class="calibre4">maps</em> often refers specifically to an associated array implemented using a binary search tree as opposed to a hash table. For example, the C++ STL container <code class="calibre6"><span class="calibre7">std::map</span></code> is implemented using a self-balancing binary search tree (or similar data structure), because it provides the ability to in-order traverse the collection.</p><div class="calibre_3"> </div>
<p class="calibre_2">The Linux kernel provides a simple and efficient map data structure, but it is not a general-purpose map. Instead, it is designed for one specific use case: mapping a unique <a id="filepos393856"></a>identification number (UID) to a pointer. In addition to providing the three main map operations, Linux’s implementation also piggybacks an <em class="calibre4">allocate</em> operation on top of the <em class="calibre4">add</em> operation. This allocate operation not only adds a UID/value pair to the map but also generates the UID.</p><div class="calibre_3"> </div>
<p class="calibre_2">The idr data structure is used for mapping user-space UIDs, such as inotify watch descriptors or POSIX timer IDs, to their associated kernel data structure, such as the <code class="calibre6"><span class="calibre7">inotify_watch</span></code> or <code class="calibre6"><span class="calibre7">k_itimer</span></code> structures, respectively. Following the Linux kernel’s scheme of obfuscated, confusing names, this map is called <em class="calibre4">idr</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos394660"> </div>
<h4 class="calibre_27"><span class="calibre3">Initializing an idr</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Setting up an idr is easy. First you statically define or dynamically allocate an <code class="calibre6"><span class="calibre7">idr</span></code> structure. Then you call <code class="calibre6"><span class="calibre7">idr_init()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void idr_init(struct idr *idp);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">For example:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct idr id_huh;  /* statically define idr structure */<br class="calibre1"/>idr_init(&amp;id_huh);  /* initialize provided idr structure */</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos395469"> </div>
<h4 class="calibre_27"><span class="calibre3">Allocating a New UID</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Once you have an idr set up, you can allocate a new UID, which is a two-step process. First you tell the idr that you want to allocate a new UID, allowing it to resize the backing tree as necessary. Then, with a second call, you actually request the new UID. This complication exists to allow you to perform the initial resizing, which may require a memory allocation, without a lock. We discuss memory allocations in <a href="index_split_021.html#filepos778361">Chapter 12</a> and locking in <a href="index_split_018.html#filepos575425">Chapters 9</a> and <a href="index_split_019.html#filepos613760">10</a>. For now, let’s concentrate on using idr without concern to how we handle locking.</p><div class="calibre_3"> </div>
<p class="calibre_2">The first function, to resize the backing tree, is <code class="calibre6"><span class="calibre7">idr_pre_get()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int idr_pre_get(struct idr *idp, gfp_t gfp_mask);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function will, if needed to fulfill a new UID allocation, resize the idr pointed at by <code class="calibre6"><span class="calibre7">idp</span></code>. If a resize is needed, the memory allocation will use the <em class="calibre4">gfp flags</em>
<code class="calibre6"><span class="calibre7">gfp_mask</span></code> (gfp flags are discussed in <a href="index_split_021.html#filepos778361">Chapter 12</a>). You do not need to synchronize concurrent access to this call. Inverted from nearly every other function in the kernel, <code class="calibre6"><span class="calibre7">idr_pre_get()</span></code> returns one on success and zero on error—be careful!</p><div class="calibre_3"> </div>
<p class="calibre_2">The second function, to actually obtain a new UID and add it to the idr, is <code class="calibre6"><span class="calibre7">idr_get_new()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int idr_get_new(struct idr *idp, void *ptr, int *id);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function uses the idr pointed at by idp to allocate a new UID and associate it with the pointer <code class="calibre6"><span class="calibre7">ptr</span></code>. On success, the function returns zero and stores the new UID in <code class="calibre6"><span class="calibre7">id</span></code>. On error, it returns a nonzero error code: <code class="calibre6"><span class="calibre7">-EAGAIN</span></code> if you need to (again) call <code class="calibre6"><span class="calibre7">idr_pre_get()</span></code> and <code class="calibre6"><span class="calibre7">-ENOSPC</span></code> if the idr is full.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos398031"></a>Let’s look at a full example:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00067.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">If successful, this snippet obtains a new UID, which is stored in the integer <code class="calibre6"><span class="calibre7">id</span></code> and maps that UID to <code class="calibre6"><span class="calibre7">ptr</span></code> (which we don’t define in the snippet).</p><div class="calibre_3"> </div>
<p class="calibre_2">The function <code class="calibre6"><span class="calibre7">idr_get_new_above()</span></code> enables the caller to specify a minimum UID value to return:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This works the same as <code class="calibre6"><span class="calibre7">idr_get_new()</span></code>, except that the new UID is guaranteed to be equal to or greater than <code class="calibre6"><span class="calibre7">starting_id</span></code>. Using this variant of the function allows idr users to ensure that a UID is never reused, allowing the value to be unique not only among currently allocated IDs but across the entirety of a system’s uptime. This code snippet is the same as our previous example, except that we request strictly increasing UID values:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00068.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos399486"> </div>
<h4 class="calibre_27"><span class="calibre3">Looking Up a UID</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When we have allocated some number of UIDs in an idr, we can look them up: The caller provides the UID, and the idr returns the associated pointer. This is accomplished, in a much simpler manner than allocating a new UID, with the <code class="calibre6"><span class="calibre7">idr_find()</span></code> function:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void *idr_find(struct idr *idp, int id);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">A successful call to this function returns the pointer associated with the UID <code class="calibre6"><span class="calibre7">id</span></code> in the idr pointed at by <code class="calibre6"><span class="calibre7">idp</span></code>. On error, the function returns <code class="calibre6"><span class="calibre7">NULL</span></code>. Note if you mapped <code class="calibre6"><span class="calibre7">NULL</span></code> to a UID with <code class="calibre6"><span class="calibre7">idr_get_new()</span></code> or <code class="calibre6"><span class="calibre7">idr_get_new_above()</span></code>, this function successfully returns <code class="calibre6"><span class="calibre7">NULL</span></code>, giving you no way to distinguish success from failure. Consequently, you should not map UIDs to <code class="calibre6"><span class="calibre7">NULL</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos400782"></a>Usage is simple:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct my_struct *ptr = idr_find(&amp;idr_huh, id);<br class="calibre1"/>if (!ptr)<br class="calibre1"/>        return -EINVAL;  /* error */</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos401108"> </div>
<h4 class="calibre_27"><span class="calibre3">Removing a UID</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">To remove a UID from an idr, use <code class="calibre6"><span class="calibre7">idr_remove()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void idr_remove(struct idr *idp, int id);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">A successful call to <code class="calibre6"><span class="calibre7">idr_remove()</span></code> removes the UID <code class="calibre6"><span class="calibre7">id</span></code> from the idr pointed at by <code class="calibre6"><span class="calibre7">idp</span></code>. Unfortunately, <code class="calibre6"><span class="calibre7">idr_remove()</span></code> has no way to signify error (for example if <code class="calibre6"><span class="calibre7">id</span></code> is not in <code class="calibre6"><span class="calibre7">idp</span></code>).</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos401936"> </div>
<h4 class="calibre_27"><span class="calibre3">Destroying an idr</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Destroying an idr is a simple affair, accomplished with the <code class="calibre6"><span class="calibre7">idr_destroy()</span></code>function:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void idr_destroy(struct idr *idp);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">A successful call to <code class="calibre6"><span class="calibre7">idr_destroy()</span></code> deallocates only unused memory associated with the idr pointed at by <code class="calibre6"><span class="calibre7">idp</span></code>. It does not free any memory currently in use by allocated UIDs. Generally, kernel code wouldn’t destroy its idr facility until it was shutting down or unloading, and it wouldn’t unload until it had no more users (and thus no more UIDs), but to force the removal of all UIDs, you can call <code class="calibre6"><span class="calibre7">idr_remove_all()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void idr_remove_all(struct idr *idp);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">You would call <code class="calibre6"><span class="calibre7">idr_remove_all()</span></code> on the idr pointed at by <code class="calibre6"><span class="calibre7">idp</span></code>
<em class="calibre4">before</em> calling <code class="calibre6"><span class="calibre7">idr_destroy()</span></code>, ensuring that all idr memory was freed.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos403377"> </div>
<h3 class="calibre_21"><span class="bold">Binary Trees</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">A <em class="calibre4">tree</em> is a data structure that provides a hierarchical tree-like structure of data. Mathematically, it is an <em class="calibre4">acyclic, connected, directed graph</em> in which each vertex (called a <em class="calibre4">node</em>) has zero or more outgoing edges and zero or one incoming edges. A <em class="calibre4">binary tree</em> is a tree in which nodes have at most two outgoing edges—that is, a tree in which nodes have zero, one, or two children. See <a href="#filepos404084">Figure 6.6</a> for a sample binary tree.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos404033"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos404084"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 6.6. A binary tree.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00069.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos404360"> </div>
<h4 class="calibre_27"><span class="calibre3">Binary Search Trees</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">A <em class="calibre4">binary search tree</em> (often abbreviated <em class="calibre4">BST</em>) is a binary tree with a specific ordering imposed on its nodes. The ordering is often defined via the following induction:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The left subtree of the root contains only nodes with values less than the root.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The right subtree of the root contains only nodes with values greater than the root.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• All subtrees are also binary search trees.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">A binary search tree is thus a binary tree in which all nodes are <em class="calibre4">ordered</em> such that left children are less than their parent in value and right children are greater than their parent. Consequently, both searching for a given node and in-order traversal are efficient (logarithmic and linear, respectively). See <a href="#filepos405622">Figure 6.7</a> for a sample binary search tree.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos405622"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 6.7. A binary search tree (BST).</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00070.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos405911"> </div>
<h4 class="calibre_27"><span class="calibre3">Self-Balancing Binary Search Trees</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos406047"> </div>
<p class="calibre_2">The <em class="calibre4">depth</em> of a node is measured by how many parent nodes it is from the root. Nodes at the “bottom” of the tree—those with no children—are called <em class="calibre4">leaves</em>. The <em class="calibre4">height</em> of a tree is the depth of the deepest node in the tree. A <em class="calibre4">balanced binary search tree</em> is a binary search tree in which the depth of all leaves differs by at most one (see <a href="#filepos406729">Figure 6.8</a>). A <em class="calibre4">self-balancing binary search tree</em> is a binary search tree that attempts, as part of its normal operations, to remain (semi) balanced.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos406729"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 6.8. A balanced binary search tree.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00071.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos407021"> </div>
<h5 class="calibre_29"><span class="calibre3">Red-Black Trees</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">A <em class="calibre4">red-black tree</em> is a type of self-balancing binary search tree. Linux’s primary binary tree data structure is the red-black tree. Red-black trees have a special color attribute, which is either <em class="calibre4">red</em> or <em class="calibre4">black</em>. Red-black trees remain semi-balanced by enforcing that the following six properties remain true:</p><div class="calibre_3"> </div>
<ol class="calibre13">
<li value="1" class="calibre14">All nodes are either red or black.</li>
<li value="2" class="calibre14">Leaf nodes are black.</li>
<li value="3" class="calibre14">Leaf nodes do not contain data.</li>
<li value="4" class="calibre14">All non-leaf nodes have two children.</li>
<li value="5" class="calibre14">If a node is red, both of its children are black.</li>
<li value="6" class="calibre14">The path from a node to one of its leaves contains the same number of black nodes as the shortest path to any of its other leaves.</li>
</ol>
<p class="calibre_2">Taken together, these properties ensure that the deepest leaf has a depth of no more than double that of the shallowest leaf. Consequently, the tree is always semi-balanced. Why this is true is surprisingly simple. First, by property five, a red node cannot be the child or parent of another red node. By property six, all paths through the tree to its leaves have the same number of black nodes. The longest path through the tree alternates red and black nodes. Thus the shortest path, which must have the same number of black nodes, contains only black nodes. Therefore, the longest path from the root to a leaf is no more than double the shortest path from the root to any other leaf.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos408698"></a>If the insertion and removal operations enforce these six properties, the tree remains semi-balanced. Now, it might seem odd to require insert and remove to maintain <em class="calibre4">these</em> particular properties. Why not implement the operations such that they enforce other, simpler rules that result in a balanced tree? It turns out that these properties are relatively easy to enforce (although complex to implement), allowing insert and remove to guarantee a semi-balanced tree without burdensome extra overhead.</p><div class="calibre_3"> </div>
<p class="calibre_2">Describing <em class="calibre4">how</em> insert and remove enforce these rules is beyond the scope of this book. Although simple rules, the implementation is complex. Any good undergraduate-level data structures textbook ought to give a full treatment.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos409542"> </div>
<h5 class="calibre_29"><span class="calibre3">rbtrees</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The Linux implementation of red-black trees is called <em class="calibre4">rbtrees</em>. They are defined in <code class="calibre6"><span class="calibre7">lib/rbtree.c</span></code> and declared in <code class="calibre6"><span class="calibre7">&lt;linux/rbtree.h&gt;</span></code>. Aside from optimizations, Linux’s rbtrees resemble the “classic” red-black tree as described in the previous section. They remain balanced such that inserts are always logarithmic with respect to the number of nodes in the tree.</p><div class="calibre_3"> </div>
<p class="calibre_2">The root of an rbtree is represented by the <code class="calibre6"><span class="calibre7">rb_root</span></code> structure. To create a new tree, we allocate a new <code class="calibre6"><span class="calibre7">rb_root</span></code> and initialize it to the special value <code class="calibre6"><span class="calibre7">RB_ROOT</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct rb_root root = RB_ROOT;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Individual nodes in an rbtree are represented by the <code class="calibre6"><span class="calibre7">rb_node</span></code> structure. Given an <code class="calibre6"><span class="calibre7">rb_node</span></code>, we can move to its left or right child by following pointers off the node of the same name.</p><div class="calibre_3"> </div>
<p class="calibre_2">The rbtree implementation does not provide search and insert routines. Users of rbtrees are expected to define their own. This is because C does not make generic programming easy, and the Linux kernel developers believed the most efficient way to implement search and insert was to require each user to do so manually, using provided rbtree helper functions but their own comparison operators.</p><div class="calibre_3"> </div>
<p class="calibre_2">The best way to demonstrate search and insert is to show a real-world example. First, let’s look at search. The following function implements a search of Linux’s page cache for a chunk of a file (represented by an inode and offset pair). Each inode has its own rbtree, keyed off of page offsets into file. This function thus searches the given inode’s rbtree for a matching offset value:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00072.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">In this example, the while loop iterates over the rbtree, traversing as needed to the left or right child in the direction of the given offset. The <code class="calibre6"><span class="calibre7">if</span></code> and <code class="calibre6"><span class="calibre7">else</span></code> statements implement the rbtree’s comparison function, thus enforcing the tree’s ordering. If the loop finds a node with a matching offset, the search is complete, and the function returns the associated <code class="calibre6"><span class="calibre7">page</span></code> structure. If the loop reaches the end of the rbtree without finding a match, one does not exist in the tree, and the function returns <code class="calibre6"><span class="calibre7">NULL</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Insert is even more complicated because it implements both search and insertion logic. The following isn’t a trivial function, but if you need to implement your own insert routine, this is a good guide:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00073.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos412959"></a>As with our search function, the while loop is iterating over the tree, moving in the direction of the provided offset. Unlike with search, however, the function is hoping <em class="calibre4">not</em> to find a matching offset but, instead, reach the leaf node that is the correct insertion point for the new offset. When the insertion point is found, <code class="calibre6"><span class="calibre7">rb_link_node()</span></code> is called to insert the new node at the given spot. <code class="calibre6"><span class="calibre7">rb_insert_color()</span></code> is then called to perform the complicated rebalancing dance. The function returns <code class="calibre6"><span class="calibre7">NULL</span></code> if the page was added to the page cache and the address of an existing <code class="calibre6"><span class="calibre7">page</span></code> structure if the page is already in the cache.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos413780"> </div>
<h3 class="calibre_21"><span class="bold">What Data Structure to Use, When</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Thus far we’ve discussed four of Linux’s most important data structures: linked lists, queues, maps, and red-black trees. In this section, we cover some tips to help you decide which data structure to use in your own code.</p><div class="calibre_3"> </div>
<p class="calibre_2">If your primary access method is iterating over all your data, use a linked list. Intuitively, no data structure can provide better than linear complexity when visiting every element, so you should favor the simplest data structure for that simple job. Also consider linked lists when performance is not important, when you need to store a relatively small number of items, or when you need to interface with other kernel code that uses linked lists.</p><div class="calibre_3"> </div>
<p class="calibre_2">If your code follows the producer/consumer pattern, use a queue, particularly if you want (or can cope with) a fixed-size buffer. Queues make adding and removing items simple and efficient, and they provide first-in, first-out (FIFO) semantics, which is what most producer/consumer use cases demand. On the other hand, if you need to store an unknown, potentially large number of items, a linked list may make more sense, because you can dynamically add any number of items to the list.</p><div class="calibre_3"> </div>
<p class="calibre_2">If you need to map a UID to an object, use a map. Maps make such mappings easy and efficient, and they also maintain and allocate the UID for you. Linux’s map interface, being specific to UID-to-pointer mappings, isn’t good for much else, however. If you are dealing with descriptors handed out to user-space, consider this option.</p><div class="calibre_3"> </div>
<p class="calibre_2">If you need to store a large amount of data and look it up efficiently, consider a red-black tree. Red-black trees enable the searching in logarithmic time, while still providing an efficient linear time in-order traversal. Although more complicated to implement than the other data structures, their in-memory footprint isn’t significantly worse. If you are not performing many time-critical look-up operations, a red-black tree probably isn’t your best bet. In that case, favor a linked list.</p><div class="calibre_3"> </div>
<p class="calibre_2">None of these data structures fit your needs? The kernel implements other seldom-used data structures that might meet your needs, such as radix trees (a type of <em class="calibre4">trie</em>) and bitmaps. Only after exhausting all kernel-provided solutions should you consider “rolling your own” data structure. One common data structure often implemented in individual source files is the hash table. Because a hash table is little more than some buckets and a hash function, and the hash function is so specific to each use case, there is little value in providing a kernelwide solution in a nongeneric programming language such as C.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos416872"> </div>
<h3 class="calibre_21"><span class="bold">Algorithmic Complexity</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos416997"> </div>
<p class="calibre_2">Often, in computer science and related disciplines, it is useful to express the algorithmic complexity—or <em class="calibre4">scalability</em>—of algorithms quantitatively. Various methods exist for representing scalability. One common technique is to study the <em class="calibre4">asymptotic behavior</em> of the algorithm. This is the behavior of the algorithm because its inputs grow exceedingly large and approach infinity. Asymptotic behavior shows how well an algorithm scales as its input grows larger and larger. Studying an algorithm’s scalability—how it performs as the size of its input increases—enables us to model the algorithm against a benchmark and better understand its behavior.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos417794"> </div>
<h4 class="calibre_27"><span class="calibre3">Algorithms</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">An algorithm is a series of instructions, possibly one or more inputs, and ultimately a result or output. For example, the steps carried out to count the number of people in a room are an algorithm, with the people being the input and the count being the output. In the Linux kernel, both page eviction and the process scheduler are examples of algorithms. Mathematically, an algorithm is like a function. (Or at least, you can model it as one.) For example, if you call the people counting algorithm <code class="calibre6"><span class="calibre7">f</span></code> and the number of people to count <code class="calibre6"><span class="calibre7">x</span></code>, you can write</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">y = f(x)            people counting function</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">where <code class="calibre6"><span class="calibre7">y</span></code> is the time required to count the <code class="calibre6"><span class="calibre7">x</span></code> people.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos418959"> </div>
<h4 class="calibre_27"><span class="calibre3">Big-O Notation</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">One useful asymptotic notation is the upper bound, which is a function whose value, after an initial point, is always greater than the value of the function that you are studying. It is said that the upper bound grows as fast or faster than the function in question. A special notation, big-o (pronounced <em class="calibre4">big oh</em>) notation, is used to describe this growth. It is written <code class="calibre6"><span class="calibre7">f(x) is O(g(x))</span></code> and is read as <em class="calibre4">f is big-oh of g</em>. The formal mathematical definition is</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00074.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">In English, the time to complete <code class="calibre6"><span class="calibre7">f(x)</span></code> is always less than or equal to the time to complete <code class="calibre6"><span class="calibre7">g(x)</span></code> multiplied by some arbitrary constant, so long as the input <code class="calibre6"><span class="calibre7">x</span></code> is larger than some initial value <code class="calibre6"><span class="calibre7">x'</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Essentially, you are looking for a function whose behavior is as bad as or worse than the algorithm. You can then look at the result of large inputs to this function and obtain an understanding of the bound of your algorithm.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos420385"> </div>
<h4 class="calibre_27"><span class="calibre3">Big Theta Notation</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When most people talk about big-o notation, they are more accurately referring to what Donald Knuth describes as <em class="calibre4">big-theta notation</em>. Technically, big-o notation refers to an upper <a id="filepos420694"></a>bound. For example, 7 is an upper bound of 6; so are 9, 12, and 65. Subsequently, when most people discuss function growth, they talk about the <em class="calibre4">least upper bound</em>, or a function that models both the upper and lower bounds.<sup class="calibre8"><a id="filepos420929" href="#filepos421172">2</a></sup> Professor Knuth, the father of the field of algorithmic analysis, describes this as big-theta notation and gives the following definition:</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos421172" href="#filepos420929">2</a></sup>
<em class="calibre4">If you’re curious, the lower bound is modeled by big-omega notation. The definition is the same as big-o, except <code class="calibre6"><span class="calibre7">g(x)</span></code> is always less than or equal to <code class="calibre6"><span class="calibre7">f(x)</span></code>, not greater than or equal to. Big-omega notation is less useful than big-o because finding functions smaller than your function is rarely indicative of behavior.</em></p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">If f(x) is big-theta of g(x), then<br class="calibre1"/>g(x) is both an upper bound and a<br class="calibre1"/>lower bound for f(x).</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Then, you can say that <code class="calibre6"><span class="calibre7">f(x)</span></code> is of <em class="calibre4">order</em>
<code class="calibre6"><span class="calibre7">g(x)</span></code>. The order, or big-theta, of an algorithm is one of the most important mathematical tools for understanding algorithms in the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2">Consequently, when people refer to big-o notation, they are more often talking about the least such big-o, the big-theta. You really do not have to worry about this, unless you want to make Professor Knuth really happy.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos422457"> </div>
<h4 class="calibre_27"><span class="calibre3">Time Complexity</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Consider the original example of having to count the number of people in a room. Pretend you can count one person per second. Then, if there are 7 people in the room, it will take 7 seconds to count them. More generally, given <code class="calibre6"><span class="calibre7">n</span></code> people it will take <code class="calibre6"><span class="calibre7">n</span></code> seconds to count everyone. Thus, you can say this algorithm is <code class="calibre6"><span class="calibre7">O(n)</span></code>. What if the task was to dance in front of everyone in the room? Because it would take the same amount of time to dance whether there were 5 or 5,000 people in the room, this task is <code class="calibre6"><span class="calibre7">O(1)</span></code>. See <a href="#filepos423344">Table 6.1</a> for other common complexities.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos423344"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 6.1. Table of Common Time Complexity Values</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00075.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">What is the complexity of introducing everyone in the room to everyone else? What is a possible function that models this algorithm? If it took 30 seconds to introduce each person, how long would it take to introduce 10 people to each other? What about 100 people to each other? Understanding how an algorithm performs as it has ever more work to do is a crucial component in determining the best algorithm for a given job.</p><div class="calibre_3"> </div>
<p class="calibre_2">Of course, it is wise to avoid complexities such as <code class="calibre6"><span class="calibre7">O(n!)</span></code> or <code class="calibre6"><span class="calibre7">O(2<sup class="calibre17">n</sup>)</span></code>. Likewise, it is usually an improvement to replace an <code class="calibre6"><span class="calibre7">O(n)</span></code> algorithm with a functionally equivalent <code class="calibre6"><span class="calibre7">O(log n)</span></code> algorithm. This is not always the case, however, and a blind assumption should not be made based solely on big-o notation. Recall that, given <code class="calibre6"><span class="calibre7">O(g(x))</span></code>, there is a constant, <code class="calibre6"><span class="calibre7">c</span></code>, multiplied by <code class="calibre6"><span class="calibre7">g(x)</span></code>. Therefore, it is possible that an <code class="calibre6"><span class="calibre7">O(1)</span></code> algorithm takes 3 hours to complete. Sure, it is <em class="calibre4">always</em> 3 hours, regardless of how large the input, but that can still be a long time compared to an <code class="calibre6"><span class="calibre7">O(n)</span></code> algorithm with few inputs. The typical input size should always be taken into account when comparing algorithms.</p><div class="calibre_3"> </div>
<p class="calibre_2">Favor less complex algorithms, but keep in mind the overhead of the algorithm in relation to the typical input size. Do not blindly optimize to a level of scalability you will never need to support!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos425428"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">In this chapter, we discussed many of the generic data structures that Linux kernel developers use to implement everything from the process scheduler to device drivers. You will find these data structures useful as we continue our study of the Linux kernel. When writing your own kernel code, always reuse existing kernel infrastructure and don’t reinvent the wheel.</p><div class="calibre_3"> </div>
<p class="calibre_2">We also covered algorithmic complexity and tools for measuring and expressing it, the most notable being <em class="calibre4">big-o</em> notation. Throughout this book and the Linux kernel, big-o notation is an important notion of how well algorithms and kernel components scale in light of many users, processes, processors, network connections, and other ever-expanding inputs.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_42"></div>
</body></html>
