<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.13 A Simple Approach: Just Yield, Baby</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part291.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part293.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 33pt;text-indent: 0pt;text-align: left;">28.13 A Simple Approach: Just Yield, Baby</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Hardware support got us pretty far: working locks, and even (as with the case of the ticket lock) fairness in lock acquisition. However, we still have a problem: what to do when a context switch occurs in a critical section, and threads start to spin endlessly, waiting for the interrupt (lock- holding) thread to be run again?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Our first try is a simple and friendly approach: when you are going to spin, instead give up the CPU to another thread. Or, as Al Davis might say, “just yield, baby!” [D91]. Figure <span style=" color: #00AEEF;">28.7 </span>presents the approach.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this approach, we assume an operating system primitive <span class="s41">yield() </span>which a thread can call when it wants to give up the CPU and let an- other thread run. Because a thread can be in one of three states (running, ready, or blocked), you can think of this as an OS system call that moves the caller from the <b>running </b>state to the <b>ready </b>state, and thus promotes another thread to running.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Think about the example with two threads on one CPU; in this case, our yield-based approach works quite well. If a thread happens to call <span class="s41">lock() </span>and find a lock held, it will simply yield the CPU, and thus the other thread will run and finish its critical section. In this simple case, the yielding approach works well.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let us now consider the case where there are many threads (say 100) contending for a lock repeatedly. In this case, if one thread acquires the lock and is preempted before releasing it, the other 99 will each call</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">void init() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2    <span class="s38">flag = 0;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">4</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5  <span class="s38">void lock() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6    <span class="s38">while (TestAndSet(&amp;flag, 1) == 1)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7       <span class="s38">yield(); // give up the CPU</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">9</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10  <span class="s38">void unlock() {</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11    <span class="s38">flag = 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">12  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">Figure 28.7: <b>Lock With Test-and-set And Yield</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">lock()<span class="p">, find the lock held, and yield the CPU. Assuming some kind of round-robin scheduler, each of the 99 will execute this run-and-yield pattern before the thread holding the lock gets to run again. While better than our spinning approach (which would waste 99 time slices spinning), this approach is still costly; the cost of a context switch can be substantial, and there is thus plenty of waste.</span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Worse, we have not tackled the starvation problem at all. A thread may get caught in an endless yield loop while other threads repeatedly enter and exit the critical section. We clearly will need an approach that addresses this problem directly.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part291.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part293.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
