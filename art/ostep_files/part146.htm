<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>15.5 Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part145.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part147.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">15.5 Summary</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">In this chapter, we have extended the concept of limited direct exe- cution with a specific mechanism used in virtual memory, known as <b>ad- dress translation</b>. With address translation, the OS can control each and every memory access from a process, ensuring the accesses stay within the bounds of the address space. Key to the efficiency of this technique is hardware support, which performs the translation quickly for each ac- cess, turning virtual addresses (the process’s view of memory) into phys- ical ones (the actual view). All of this is performed in a way that is <i>trans- parent </i>to the process that has been relocated; the process has no idea its memory references are being translated, making for a wonderful illusion. We have also seen one particular form of virtualization, known as base and bounds or dynamic relocation. Base-and-bounds virtualization is quite <i>efficient</i>, as only a little more hardware logic is required to add a base register to the virtual address and check that the address generated by the process is in bounds. Base-and-bounds also offers <i>protection</i>; the OS and hardware combine to ensure no process can generate memory references outside its own address space. Protection is certainly one of the most important goals of the OS; without it, the OS could not control</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_145.png"/></span></p><p class="s11" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1<span class="s12">Is there anything other than “havoc” that can be “wreaked”?</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: right;">the machine (if processes were free to overwrite memory, they could eas- ily do nasty things like overwrite the trap table and take over the system).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Unfortunately, this simple technique of dynamic relocation does have its inefficiencies. For example, as you can see in Figure <span style=" color: #00AEEF;">15.2 </span>(back a few pages), the relocated process is using physical memory from 32 KB to 48 KB; however, because the process stack and heap are not too big, all of the space between the two is simply <i>wasted</i>. This type of waste is usually called <b>internal fragmentation</b>, as the space <i>inside </i>the allocated unit is not all used (i.e., is fragmented) and thus wasted. In our current approach, al- though there might be enough physical memory for more processes, we are currently restricted to placing an address space in a fixed-sized slot</p><p style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">and thus internal fragmentation can arise<span class="s35">2</span>. Thus, we are going to need more sophisticated machinery, to try to better utilize physical memory and avoid internal fragmentation. Our first attempt will be a slight gen- eralization of base and bounds known as <b>segmentation</b>, which we will discuss next.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_146.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: justify;">2<span class="s12">A different solution might instead place a fixed-sized stack within the address space, just below the code region, and a growing heap below that. However, this limits flexibility by making recursion and deeply-nested function calls challenging, and thus is something we hope to avoid.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part145.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part147.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
