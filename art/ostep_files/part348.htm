<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Deadlock Avoidance via Scheduling</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part347.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part349.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">Deadlock Avoidance via Scheduling</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: left;">Instead of deadlock prevention, in some scenarios deadlock <b>avoidance </b>is preferable. Avoidance requires some global knowledge of which locks various threads might grab during their execution, and subsequently sched- ules said threads in a way as to guarantee no deadlock can occur.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">For example, assume we have two processors and four threads which must be scheduled upon them. Assume further we know that Thread 1 (T1) grabs locks L1 and L2 (in some order, at some point during its execution), T2 grabs L1 and L2 as well, T3 grabs just L2, and T4 grabs no</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_497.png"/></span></p><p class="s12" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: justify;"><span class="s11">1</span>The astute reader might be asking why we grabbed the lock so late, instead of right when entering the <span class="s38">insert() </span>routine; can you, astute reader, figure out why that is likely OK?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: left;">locks at all. We can show these lock acquisition demands of the threads in tabular form:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:118.02pt" cellspacing="0"><tr style="height:8pt"><td style="width:19pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:25pt"><p class="s42" style="padding-right: 4pt;text-indent: 0pt;line-height: 6pt;text-align: right;">T1</p></td><td style="width:21pt"><p class="s42" style="padding-left: 7pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">T2</p></td><td style="width:23pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 6pt;text-align: right;">T3</p></td><td style="width:18pt"><p class="s42" style="padding-left: 5pt;padding-right: 1pt;text-indent: 0pt;line-height: 6pt;text-align: center;">T4</p></td></tr><tr style="height:8pt"><td style="width:19pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">L1</p></td><td style="width:25pt"><p class="s42" style="padding-right: 4pt;text-indent: 0pt;line-height: 7pt;text-align: right;">yes</p></td><td style="width:21pt"><p class="s42" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 7pt;text-align: center;">yes</p></td><td style="width:23pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 7pt;text-align: right;">no</p></td><td style="width:18pt"><p class="s42" style="padding-left: 5pt;padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: center;">no</p></td></tr><tr style="height:8pt"><td style="width:19pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">L2</p></td><td style="width:25pt"><p class="s42" style="padding-right: 4pt;text-indent: 0pt;line-height: 6pt;text-align: right;">yes</p></td><td style="width:21pt"><p class="s42" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">yes</p></td><td style="width:23pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 6pt;text-align: right;">yes</p></td><td style="width:18pt"><p class="s42" style="padding-left: 5pt;padding-right: 1pt;text-indent: 0pt;line-height: 6pt;text-align: center;">no</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A smart scheduler could thus compute that as long as T1 and T2 are not run at the same time, no deadlock could ever arise. Here is one such schedule:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-top: 4pt;padding-left: 10pt;text-indent: 0pt;text-align: center;">T2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 17pt;text-indent: 0pt;text-align: center;">T1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 13pt;text-indent: 0pt;text-align: center;">T4</p><p style="text-indent: 0pt;text-align: left;"/><p class="s153" style="padding-top: 4pt;padding-left: 10pt;text-indent: 0pt;text-align: center;">T3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 120pt;text-indent: 0pt;text-align: left;">CPU 1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 120pt;text-indent: 0pt;text-align: left;">CPU 2</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Note that it is OK for (T3 and T1) or (T3 and T2) to overlap. Even though T3 grabs lock L2, it can never cause a deadlock by running con- currently with other threads because it only grabs one lock.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let’s look at one more example. In this one, there is more contention for the same resources (again, locks L1 and L2), as indicated by the fol- lowing contention table:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:118.02pt" cellspacing="0"><tr style="height:8pt"><td style="width:19pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:25pt"><p class="s42" style="padding-right: 4pt;text-indent: 0pt;line-height: 7pt;text-align: right;">T1</p></td><td style="width:21pt"><p class="s42" style="padding-left: 7pt;padding-right: 3pt;text-indent: 0pt;line-height: 7pt;text-align: center;">T2</p></td><td style="width:23pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 7pt;text-align: right;">T3</p></td><td style="width:18pt"><p class="s42" style="padding-left: 5pt;padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: center;">T4</p></td></tr><tr style="height:8pt"><td style="width:19pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">L1</p></td><td style="width:25pt"><p class="s42" style="padding-right: 4pt;text-indent: 0pt;line-height: 7pt;text-align: right;">yes</p></td><td style="width:21pt"><p class="s42" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 7pt;text-align: center;">yes</p></td><td style="width:23pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 7pt;text-align: right;">yes</p></td><td style="width:18pt"><p class="s42" style="padding-left: 5pt;padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: center;">no</p></td></tr><tr style="height:8pt"><td style="width:19pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">L2</p></td><td style="width:25pt"><p class="s42" style="padding-right: 4pt;text-indent: 0pt;line-height: 6pt;text-align: right;">yes</p></td><td style="width:21pt"><p class="s42" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">yes</p></td><td style="width:23pt"><p class="s42" style="padding-right: 6pt;text-indent: 0pt;line-height: 6pt;text-align: right;">yes</p></td><td style="width:18pt"><p class="s42" style="padding-left: 5pt;padding-right: 1pt;text-indent: 0pt;line-height: 6pt;text-align: center;">no</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In particular, threads T1, T2, and T3 all need to grab both locks L1 and L2 at some point during their execution. Here is a possible schedule that guarantees that no deadlock could ever occur:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 4pt;padding-left: 10pt;text-indent: 0pt;text-align: center;">T3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 10pt;text-indent: 0pt;text-align: center;">T2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 17pt;text-indent: 0pt;text-align: center;">T1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 13pt;text-indent: 0pt;text-align: center;">T4</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 120pt;text-indent: 0pt;text-align: left;">CPU 1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 120pt;text-indent: 0pt;text-align: left;">CPU 2</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As you can see, static scheduling leads to a conservative approach where T1, T2, and T3 are all run on the same processor, and thus the total time to complete the jobs is lengthened considerably. Though it may have been possible to run these tasks concurrently, the fear of deadlock prevents us from doing so, and the cost is performance.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One famous example of an approach like this is Dijkstra’s Banker’s Al- gorithm [D64], and many similar approaches have been described in the literature. Unfortunately, they are only useful in very limited environ- ments, for example, in an embedded system where one has full knowl- edge of the entire set of tasks that must be run and the locks that they need. Further, such approaches can limit concurrency, as we saw in the second example above. Thus, avoidance of deadlock via scheduling is not a widely-used general-purpose solution.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: D<span class="s7">ON</span>’<span class="s7">T </span>A<span class="s7">LWAYS </span>D<span class="s7">O </span>I<span class="s7">T </span>P<span class="s7">ERFECTLY </span>(T<span class="s7">OM </span>W<span class="s7">EST</span>’<span class="s7">S </span>L<span class="s7">AW</span>)</p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Tom West, famous as the subject of the classic computer-industry book “Soul of a New Machine” [K81], says famously: “Not everything worth doing is worth doing well”, which is a terrific engineering maxim. If a bad thing happens rarely, certainly one should not spend a great deal of effort to prevent it, particularly if the cost of the bad thing occurring is small.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part347.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part349.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
