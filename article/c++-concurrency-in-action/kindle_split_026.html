<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mbp="Kindle">
  <head>
    <title>C++ Concurrency in Action, Second Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h5 class="notetitle" id="app04lev3sec77"><a id="app04lev3sec77__title" class="calibre4"></a>std::atomic_flag initialization with ATOMIC_FLAG_INIT
      </h5>
      
      <p class="noind">An instance of <kbd class="calibre17">std::atomic_flag</kbd> may be initialized using the <kbd class="calibre17">ATOMIC_FLAG_INIT</kbd> macro, in which case itâ€™s initialized into the <i class="calibre6">clear</i> state. For objects of static storage duration, initialization shall be static initialization.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">#define ATOMIC_FLAG_INIT <i class="calibre6">unspecified</i></pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Usage</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::atomic_flag flag=ATOMIC_FLAG_INIT;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::atomic_flag</kbd> object in the clear state.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec78"><a id="app04lev3sec78__title" class="calibre4"></a>std::atomic_flag::test_and_set member function
      </h5>
      
      <p class="noind">Atomically sets the flag and checks whether or not it was set.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool test_and_set(memory_order order = memory_order_seq_cst) volatile
     noexcept;
bool test_and_set(memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically sets the flag.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1991" class="calibre4"></a><a id="iddle1995" class="calibre4"></a><a id="iddle1996" class="calibre4"></a><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the flag was set at the point of the call, <kbd class="calibre17">false</kbd> if the flag was clear.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note14">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec79"><a id="app04lev3sec79__title" class="calibre4"></a>std::atomic_flag_test_and_set nonmember function
      </h5>
      
      <p class="noind">Atomically sets the flag and checks whether or not it was set.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool atomic_flag_test_and_set(volatile atomic_flag* flag) noexcept;
bool atomic_flag_test_and_set(atomic_flag* flag) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return flag-&gt;test_and_set();</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec80"><a id="app04lev3sec80__title" class="calibre4"></a>std::atomic_flag_test_and_set_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically sets the flag and checks whether or not it was set.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool atomic_flag_test_and_set_explicit(
    volatile atomic_flag* flag, memory_order order) noexcept;
bool atomic_flag_test_and_set_explicit(
    atomic_flag* flag, memory_order order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return flag-&gt;test_and_set(order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec81"><a id="app04lev3sec81__title" class="calibre4"></a>std::atomic_flag::clear member function
      </h5>
      
      <p class="noind">Atomically clears the flag.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void clear(memory_order order = memory_order_seq_cst) volatile noexcept;
void clear(memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The supplied <kbd class="calibre17">order</kbd> must be one of <kbd class="calibre17">std::memory_order_relaxed</kbd>, <kbd class="calibre17">std::memory_order_release</kbd>, or <kbd class="calibre17">std::memory_order_seq_cst</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically clears the flag.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note15">Note</h5>
      
      
      <p class="noindclose">This is an atomic store operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec82"><a id="app04lev3sec82__title" class="calibre4"></a>std::atomic_flag_clear nonmember function
      </h5>
      
      <p class="noind"><a id="iddle1048" class="calibre4"></a><a id="iddle1949" class="calibre4"></a><a id="iddle1993" class="calibre4"></a><a id="iddle1994" class="calibre4"></a>Atomically clears the flag.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void atomic_flag_clear(volatile atomic_flag* flag) noexcept;
void atomic_flag_clear(atomic_flag* flag) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">flag-&gt;clear();</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec83"><a id="app04lev3sec83__title" class="calibre4"></a>std::atomic_flag_clear_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically clears the flag.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void atomic_flag_clear_explicit(
    volatile atomic_flag* flag, memory_order order) noexcept;
void atomic_flag_clear_explicit(
    atomic_flag* flag, memory_order order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return flag-&gt;clear(order);</pre>
            </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec15" class="calibre23">D.3.8. <a id="app04lev2sec15__title" class="calibre4"></a>std::atomic class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::atomic</kbd> class provides a wrapper with atomic operations for any type that satisfies the following requirements.
      </p>
      
      <p class="noind">The template parameter <kbd class="calibre17">BaseType</kbd> must
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">Have a trivial default constructor</li>
         
         <li class="calibre22">Have a trivial copy-assignment operator</li>
         
         <li class="calibre22">Have a trivial destructor</li>
         
         <li class="calibre22">Be bitwise-equality comparable</li>
         
      </ul>
      
      <p class="noind">This means that <kbd class="calibre17">std::atomic&lt;some-built-in-type&gt;</kbd> is fine, as is <kbd class="calibre17">std::atomic&lt;some-simple-struct&gt;</kbd>, but things like <kbd class="calibre17">std::atomic&lt;std::string&gt;</kbd> are not.
      </p>
      
      <p class="noind">In addition to the primary template, there are specializations for the built-in integral types and pointers to provide additional
         operations, such as <kbd class="calibre17">x++</kbd>.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::atomic</kbd> are not <kbd class="calibre17">CopyConstructible</kbd> or <kbd class="calibre17">CopyAssignable</kbd>, because these operations canâ€™t be performed as a single atomic operation.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
struct atomic
{
    using value_type = T;
    static constexpr bool is_always_lock_free = implementation-defined ;
    atomic() noexcept = default;
    constexpr atomic(BaseType) noexcept;
    BaseType operator=(BaseType) volatile noexcept;
    BaseType operator=(BaseType) noexcept;

    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;

    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(BaseType,memory_order = memory_order_seq_cst)
        volatile noexcept;
    void store(BaseType,memory_order = memory_order_seq_cst) noexcept;
    BaseType load(memory_order = memory_order_seq_cst)
        const volatile noexcept;
    BaseType load(memory_order = memory_order_seq_cst) const noexcept;
    BaseType exchange(BaseType,memory_order = memory_order_seq_cst)
        volatile noexcept;
    BaseType exchange(BaseType,memory_order = memory_order_seq_cst)
        noexcept;

    bool compare_exchange_strong(
        BaseType &amp; old_value, BaseType new_value,
        memory_order order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(
        BaseType &amp; old_value, BaseType new_value,
        memory_order order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(
        BaseType &amp; old_value, BaseType new_value,
        memory_order success_order,
        memory_order failure_order) volatile noexcept;
    bool compare_exchange_strong(
        BaseType &amp; old_value, BaseType new_value,
        memory_order success_order,
        memory_order failure_order) noexcept;
    bool compare_exchange_weak(
        BaseType &amp; old_value, BaseType new_value,
        memory_order order = memory_order_seq_cst)
        volatile noexcept;
    bool compare_exchange_weak(
        BaseType &amp; old_value, BaseType new_value,
        memory_order order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(
        BaseType &amp; old_value, BaseType new_value,
        memory_order success_order,
        memory_order failure_order) volatile noexcept;
    bool compare_exchange_weak(
        BaseType &amp; old_value, BaseType new_value,
        memory_order success_order,
        memory_order failure_order) noexcept;

    operator BaseType () const volatile noexcept;
    operator BaseType () const noexcept;
};

template&lt;typename BaseType&gt;
bool atomic_is_lock_free(volatile const atomic&lt;BaseType&gt;*) noexcept;
template&lt;typename BaseType&gt;
bool atomic_is_lock_free(const atomic&lt;BaseType&gt;*) noexcept;
template&lt;typename BaseType&gt;
void atomic_init(volatile atomic&lt;BaseType&gt;*, void*) noexcept;
template&lt;typename BaseType&gt;
void atomic_init(atomic&lt;BaseType&gt;*, void*) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange(volatile atomic&lt;BaseType&gt;*, memory_order)
    noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange(atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange_explicit(
    volatile atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange_explicit(
    atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
void atomic_store(volatile atomic&lt;BaseType&gt;*, BaseType) noexcept;
template&lt;typename BaseType&gt;
void atomic_store(atomic&lt;BaseType&gt;*, BaseType) noexcept;
template&lt;typename BaseType&gt;
void atomic_store_explicit(
    volatile atomic&lt;BaseType&gt;*, BaseType, memory_order) noexcept;
template&lt;typename BaseType&gt;
void atomic_store_explicit(
    atomic&lt;BaseType&gt;*, BaseType, memory_order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load(volatile const atomic&lt;BaseType&gt;*) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load(const atomic&lt;BaseType&gt;*) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load_explicit(
    volatile const atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load_explicit(
    const atomic&lt;BaseType&gt;*, memory_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong(
    volatile atomic&lt;BaseType&gt;*,BaseType * old_value,
    BaseType new_value) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong(
    atomic&lt;BaseType&gt;*,BaseType * old_value,
    BaseType new_value) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong_explicit(
    volatile atomic&lt;BaseType&gt;*,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong_explicit(
    atomic&lt;BaseType&gt;*,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak(
    volatile atomic&lt;BaseType&gt;*,BaseType * old_value,BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak(
    atomic&lt;BaseType&gt;*,BaseType * old_value,BaseType new_value) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak_explicit(
    volatile atomic&lt;BaseType&gt;*,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak_explicit(
    atomic&lt;BaseType&gt;*,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;</pre>
            </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note16">Note</h5>
      
      
      <p class="noindclose"><a id="iddle1952" class="calibre4"></a><a id="iddle1997" class="calibre4"></a>Although the nonmember functions are specified as templates, they may be provided as an overloaded set of functions, and explicit
         specification of the template arguments shouldnâ€™t be used.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      <h5 class="notetitle" id="app04lev3sec84"><a id="app04lev3sec84__title" class="calibre4"></a>std::atomic default constructor
      </h5>
      
      <p class="noind">Constructs an instance of <kbd class="calibre17">std::atomic</kbd> with a default-initialized value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">atomic() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::atomic</kbd> object with a default-initialized value. For objects with static storage duration, this is static initialization.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note17">Note</h5>
      
      
      <p class="noindclose">Instances of <kbd class="calibre17">std::atomic</kbd> with nonstatic storage duration initialized with the default constructor canâ€™t be relied on to have a predictable value.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec85"><a id="app04lev3sec85__title" class="calibre4"></a>std::atomic_init nonmember function
      </h5>
      
      <p class="noind">Nonatomically stores the supplied value in an instance of <kbd class="calibre17">std::atomic&lt;BaseType&gt;</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
void atomic_init(atomic&lt;BaseType&gt; volatile* p, BaseType v) noexcept;
template&lt;typename BaseType&gt;
void atomic_init(atomic&lt;BaseType&gt;* p, BaseType v) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Nonatomically stores the value of <kbd class="calibre17">v</kbd> in <kbd class="calibre17">*p</kbd>. Invoking <kbd class="calibre17">atomic_init()</kbd> on an instance of <kbd class="calibre17">atomic&lt;BaseType&gt;</kbd> that hasnâ€™t been default constructed, or that has had any operations performed on it since construction, is undefined behavior.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note18">Note</h5>
      
      
      <p class="noindclose">Because this store is nonatomic, any concurrent access to the object pointed to by <kbd class="calibre17">p</kbd> from another thread (even with atomic operations) constitutes a data race.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec86"><a id="app04lev3sec86__title" class="calibre4"></a>std::atomic conversion constructor
      </h5>
      
      <p class="noind"><a id="iddle1950" class="calibre4"></a><a id="iddle1951" class="calibre4"></a><a id="iddle1959" class="calibre4"></a><a id="iddle1960" class="calibre4"></a><a id="iddle2013" class="calibre4"></a>Constructs an instance of <kbd class="calibre17">std::atomic</kbd> with the supplied <kbd class="calibre17">BaseType</kbd> value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr atomic(BaseType b) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::atomic</kbd> object with a value of <kbd class="calibre17">b</kbd>. For objects with static storage duration, this is static initialization.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec87"><a id="app04lev3sec87__title" class="calibre4"></a>std::atomic conversion assignment operator
      </h5>
      
      <p class="noind">Stores a new value in <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">BaseType operator=(BaseType b) volatile noexcept;
BaseType operator=(BaseType b) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;store(b);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec88"><a id="app04lev3sec88__title" class="calibre4"></a>std::atomic::is_lock_free member function
      </h5>
      
      <p class="noind">Determines if operations on <kbd class="calibre17">*this</kbd> are lock-free.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if operations on <kbd class="calibre17">*this</kbd> are lock-free, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec89"><a id="app04lev3sec89__title" class="calibre4"></a>std::atomic_is_lock_free nonmember function
      </h5>
      
      <p class="noind">Determines if operations on <kbd class="calibre17">*this</kbd> are lock-free.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
bool atomic_is_lock_free(volatile const atomic&lt;BaseType&gt;* p) noexcept;
template&lt;typename BaseType&gt;
bool atomic_is_lock_free(const atomic&lt;BaseType&gt;* p) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;is_lock_free();</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec90"><a id="app04lev3sec90__title" class="calibre4"></a>std::atomic::is_always_lock_free static data member
      </h5>
      
      <p class="noind">Determines if operations on all objects of this type are always lock-free.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">static constexpr bool is_always_lock_free() = <i class="calibre6">implementation-defined</i>;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Value</i>
            <kbd class="calibre17">true</kbd> if operations on all objects of this type are always lock-free, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec91"><a id="app04lev3sec91__title" class="calibre4"></a>std::atomic::load member function
      </h5>
      
      <p class="noind"><a id="iddle1961" class="calibre4"></a><a id="iddle1962" class="calibre4"></a><a id="iddle2014" class="calibre4"></a><a id="iddle2015" class="calibre4"></a>Atomically loads the current value of the <kbd class="calibre17">std::atomic</kbd> instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">BaseType load(memory_order order = memory_order_seq_cst)
    const volatile noexcept;
BaseType load(memory_order order = memory_order_seq_cst) const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The supplied <kbd class="calibre17">order</kbd> must be one of <kbd class="calibre17">std::memory_order_relaxed</kbd>, <kbd class="calibre17">std::memory_order_acquire</kbd>, <kbd class="calibre17">std::memory_order_consume</kbd>, or <kbd class="calibre17">std::memory_order_seq_cst</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically loads the value stored in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The value stored in <kbd class="calibre17">*this</kbd> at the point of the call.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note19">Note</h5>
      
      
      <p class="noindclose">This is an atomic load operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec92"><a id="app04lev3sec92__title" class="calibre4"></a>std::atomic_load nonmember function
      </h5>
      
      <p class="noind">Atomically loads the current value of the <kbd class="calibre17">std::atomic</kbd> instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
BaseType atomic_load(volatile const atomic&lt;BaseType&gt;* p) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load(const atomic&lt;BaseType&gt;* p) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;load();</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec93"><a id="app04lev3sec93__title" class="calibre4"></a>std::atomic_load_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically loads the current value of the <kbd class="calibre17">std::atomic</kbd> instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
BaseType atomic_load_explicit(
    volatile const atomic&lt;BaseType&gt;* p, memory_order order) noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_load_explicit(
    const atomic&lt;BaseType&gt;* p, memory_order order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;load(order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec94"><a id="app04lev3sec94__title" class="calibre4"></a>std::atomic::operator BaseType conversion operator
      </h5>
      
      <p class="noind">Loads the value stored in <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">operator BaseType() const volatile noexcept;
operator BaseType() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1963" class="calibre4"></a><a id="iddle2017" class="calibre4"></a><a id="iddle2018" class="calibre4"></a><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;load();</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec95"><a id="app04lev3sec95__title" class="calibre4"></a>std::atomic::store member function
      </h5>
      
      <p class="noind">Atomically stores a new value in an <kbd class="calibre17">atomic&lt;BaseType&gt;</kbd> instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void store(BaseType new_value,memory_order order = memory_order_seq_cst)
    volatile noexcept;
void store(BaseType new_value,memory_order order = memory_order_seq_cst)
    noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The supplied <kbd class="calibre17">order</kbd> must be one of <kbd class="calibre17">std::memory_order_relaxed</kbd>, <kbd class="calibre17">std::memory_order_release</kbd>, or <kbd class="calibre17">std::memory_order_seq_cst</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically stores <kbd class="calibre17">new_value</kbd> in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note20">Note</h5>
      
      
      <p class="noindclose">This is an atomic store operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec96"><a id="app04lev3sec96__title" class="calibre4"></a>std::atomic_store nonmember function
      </h5>
      
      <p class="noind">Atomically stores a new value in an <kbd class="calibre17">atomic&lt;BaseType&gt;</kbd> instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
void atomic_store(volatile atomic&lt;BaseType&gt;* p, BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
void atomic_store(atomic&lt;BaseType&gt;* p, BaseType new_value) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">p-&gt;store(new_value);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec97"><a id="app04lev3sec97__title" class="calibre4"></a>std::atomic_store_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically stores a new value in an <kbd class="calibre17">atomic&lt;BaseType&gt;</kbd> instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
void atomic_store_explicit(
    volatile atomic&lt;BaseType&gt;* p, BaseType new_value, memory_order order)
    noexcept;
template&lt;typename BaseType&gt;
void atomic_store_explicit(
    atomic&lt;BaseType&gt;* p, BaseType new_value, memory_order order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">p-&gt;store(new_value,order);</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec98"><a id="app04lev3sec98__title" class="calibre4"></a>std::atomic::exchange member function
      </h5>
      
      <p class="noind"><a id="iddle1958" class="calibre4"></a><a id="iddle1969" class="calibre4"></a><a id="iddle1970" class="calibre4"></a>Atomically stores a new value and reads the old one.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">BaseType exchange(
    BaseType new_value,
    memory_order order = memory_order_seq_cst)
    volatile noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically stores <kbd class="calibre17">new_value</kbd> in <kbd class="calibre17">*this</kbd> and retrieves the existing value of <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The value of <kbd class="calibre17">*this</kbd> immediately prior to the store.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note21">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec99"><a id="app04lev3sec99__title" class="calibre4"></a>std::atomic_exchange nonmember function
      </h5>
      
      <p class="noind">Atomically stores a new value in an <kbd class="calibre17">atomic&lt;BaseType&gt;</kbd> instance and reads the prior value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
BaseType atomic_exchange(volatile atomic&lt;BaseType&gt;* p, BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange(atomic&lt;BaseType&gt;* p, BaseType new_value) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;exchange(new_value);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec100"><a id="app04lev3sec100__title" class="calibre4"></a>std::atomic_exchange_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically stores a new value in an <kbd class="calibre17">atomic&lt;BaseType&gt;</kbd> instance and reads the prior value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
BaseType atomic_exchange_explicit(
    volatile atomic&lt;BaseType&gt;* p, BaseType new_value, memory_order order)
    noexcept;
template&lt;typename BaseType&gt;
BaseType atomic_exchange_explicit(
    atomic&lt;BaseType&gt;* p, BaseType new_value, memory_order order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;exchange(new_value,order);</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec101"><a id="app04lev3sec101__title" class="calibre4"></a>std::atomic::compare_exchange_strong member function
      </h5>
      
      <p class="noind"><a id="iddle1956" class="calibre4"></a><a id="iddle1965" class="calibre4"></a>Atomically compares the value to an expected value and stores a new value if the values are equal. If the values arenâ€™t equal,
         updates the expected value with the value read.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool compare_exchange_strong(
    BaseType&amp; expected,BaseType new_value,
    memory_order order = std::memory_order_seq_cst) volatile noexcept;
bool compare_exchange_strong(
    BaseType&amp; expected,BaseType new_value,
    memory_order order = std::memory_order_seq_cst) noexcept;
bool compare_exchange_strong(
    BaseType&amp; expected,BaseType new_value,
    memory_order success_order,memory_order failure_order)
    volatile noexcept;
bool compare_exchange_strong(
    BaseType&amp; expected,BaseType new_value,
    memory_order success_order,memory_order failure_order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">failure_order</kbd> shall not be <kbd class="calibre17">std::memory_order_release</kbd> or <kbd class="calibre17">std::memory_order_acq_rel</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically compares <kbd class="calibre17">expected</kbd> to the value stored in <kbd class="calibre17">*this</kbd> using bitwise comparison and stores <kbd class="calibre17">new_value</kbd> in <kbd class="calibre17">*this</kbd> if equal; otherwise updates <kbd class="calibre17">expected</kbd> to the value read.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the existing value of <kbd class="calibre17">*this</kbd> was equal to <kbd class="calibre17">expected</kbd>, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note22">Note</h5>
      
      
      <p class="noindclose">The three-parameter overload is equivalent to the four-parameter overload with <kbd class="calibre17">success_order==order</kbd> and <kbd class="calibre17">failure_order==order</kbd>, except that if <kbd class="calibre17">order</kbd> is <kbd class="calibre17">std::memory_order_acq_rel</kbd>, then <kbd class="calibre17">failure_order</kbd> is <kbd class="calibre17">std:: memory_order_acquire</kbd>, and if <kbd class="calibre17">order</kbd> is <kbd class="calibre17">std::memory_order_release</kbd>, then <kbd class="calibre17">failure_order</kbd> is <kbd class="calibre17">std::memory_order_relaxed</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note23">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd> if the result is <kbd class="calibre17">true</kbd>, with memory ordering <kbd class="calibre17">success_order</kbd>; otherwise, itâ€™s an atomic load operation for the memory location comprising <kbd class="calibre17">*this</kbd> with memory ordering <kbd class="calibre17">failure_order</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec102"><a id="app04lev3sec102__title" class="calibre4"></a>std::atomic_compare_exchange_strong nonmember function
      </h5>
      
      <p class="noind">Atomically compares the value to an expected value and stores a new value if the values are equal. If the values arenâ€™t equal,
         updates the expected value with the value read.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong(
    volatile atomic&lt;BaseType&gt;* p,BaseType * old_value,BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong(
    atomic&lt;BaseType&gt;* p,BaseType * old_value,BaseType new_value) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1957" class="calibre4"></a><a id="iddle1966" class="calibre4"></a><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;compare_exchange_strong(*old_value,new_value);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec103"><a id="app04lev3sec103__title" class="calibre4"></a>std::atomic_compare_exchange_strong_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically compares the value to an expected value and stores a new value if the values are equal. If the values arenâ€™t equal,
         updates the expected value with the value read.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong_explicit(
    volatile atomic&lt;BaseType&gt;* p,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_strong_explicit(
    atomic&lt;BaseType&gt;* p,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;compare_exchange_strong(
    *old_value,new_value,success_order,failure_order) noexcept;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec104"><a id="app04lev3sec104__title" class="calibre4"></a>std::atomic::compare_exchange_weak member function
      </h5>
      
      <p class="noind">Atomically compares the value to an expected value and stores a new value if the values are equal and the update can be done
         atomically. If the values arenâ€™t equal or the update canâ€™t be done atomically, updates the expected value with the value read.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool compare_exchange_weak(
    BaseType&amp; expected,BaseType new_value,
    memory_order order = std::memory_order_seq_cst) volatile noexcept;
bool compare_exchange_weak(
    BaseType&amp; expected,BaseType new_value,
    memory_order order = std::memory_order_seq_cst) noexcept;
bool compare_exchange_weak(
    BaseType&amp; expected,BaseType new_value,
    memory_order success_order,memory_order failure_order)
    volatile noexcept;
bool compare_exchange_weak(
    BaseType&amp; expected,BaseType new_value,
    memory_order success_order,memory_order failure_order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">failure_order</kbd> shall not be <kbd class="calibre17">std::memory_order_release</kbd> or <kbd class="calibre17">std::memory_order_acq_rel</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1967" class="calibre4"></a><a id="iddle1968" class="calibre4"></a><i class="calibre6">Effects</i>
            Atomically compares <kbd class="calibre17">expected</kbd> to the value stored in <kbd class="calibre17">*this</kbd> using bitwise comparison and stores <kbd class="calibre17">new_value</kbd> in <kbd class="calibre17">*this</kbd> if equal. If the values arenâ€™t equal or the update canâ€™t be done atomically, updates <kbd class="calibre17">expected</kbd> to the value read.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the existing value of <kbd class="calibre17">*this</kbd> was equal to <kbd class="calibre17">expected</kbd> and <kbd class="calibre17">new_value</kbd> was successfully stored in <kbd class="calibre17">*this</kbd>, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note24">Note</h5>
      
      
      <p class="noindclose">The three-parameter overload is equivalent to the four-parameter overload with <kbd class="calibre17">success_order==order</kbd> and <kbd class="calibre17">failure_order==order</kbd>, except that if <kbd class="calibre17">order</kbd> is <kbd class="calibre17">std::memory_order_acq_rel</kbd>, then <kbd class="calibre17">failure_order</kbd> is <kbd class="calibre17">std:: memory_order_acquire</kbd>, and if <kbd class="calibre17">order</kbd> is <kbd class="calibre17">std::memory_order_release</kbd>, then <kbd class="calibre17">failure_order</kbd> is <kbd class="calibre17">std::memory_order_relaxed</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note25">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd> if the result is <kbd class="calibre17">true</kbd>, with memory ordering <kbd class="calibre17">success_order</kbd>; otherwise, itâ€™s an atomic load operation for the memory location comprising <kbd class="calibre17">*this</kbd> with memory ordering <kbd class="calibre17">failure_order</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec105"><a id="app04lev3sec105__title" class="calibre4"></a>std::atomic_compare_exchange_weak nonmember function
      </h5>
      
      <p class="noind">Atomically compares the value to an expected value and stores a new value if the values are equal and the update can be done
         atomically. If the values arenâ€™t equal or the update canâ€™t be done atomically, updates the expected value with the value read.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak(
    volatile atomic&lt;BaseType&gt;* p,BaseType * old_value,BaseType new_value)
    noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak(
    atomic&lt;BaseType&gt;* p,BaseType * old_value,BaseType new_value) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;compare_exchange_weak(*old_value,new_value);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec106"><a id="app04lev3sec106__title" class="calibre4"></a>std::atomic_compare_exchange_weak_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically compares the value to an expected value and stores a new value if the values are equal and the update can be done
         atomically. If the values arenâ€™t equal or the update canâ€™t be done atomically, updates the expected value with the value read.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak_explicit(
    volatile atomic&lt;BaseType&gt;* p,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;
template&lt;typename BaseType&gt;
bool atomic_compare_exchange_weak_explicit(
    atomic&lt;BaseType&gt;* p,BaseType * old_value,
    BaseType new_value, memory_order success_order,
    memory_order failure_order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1047" class="calibre4"></a><a id="iddle1049" class="calibre4"></a><a id="iddle1953" class="calibre4"></a><a id="iddle1955" class="calibre4"></a><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;compare_exchange_weak(
    *old_value,new_value,success_order,failure_order);</pre>
            </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec16" class="calibre23">D.3.9. <a id="app04lev2sec16__title" class="calibre4"></a>Specializations of the std::atomic template
      </h4>
      
      <p class="noind">Specializations of the <kbd class="calibre17">std::atomic</kbd> class template are provided for the integral types and pointer types. For the integral types, these specializations provide
         atomic addition, subtraction, and bitwise operations in addition to the operations provided by the primary template. For pointer
         types, the specializations provide atomic pointer arithmetic in addition to the operations provided by the primary template.
      </p>
      
      <p class="noind">Specializations are provided for the following integral types:</p>
      
      <pre id="PLd0e52817" class="calibre5">std::atomic&lt;bool&gt;
std::atomic&lt;char&gt;
std::atomic&lt;signed char&gt;
std::atomic&lt;unsigned char&gt;
std::atomic&lt;short&gt;
std::atomic&lt;unsigned short&gt;
std::atomic&lt;int&gt;
std::atomic&lt;unsigned&gt;
std::atomic&lt;long&gt;
std::atomic&lt;unsigned long&gt;
std::atomic&lt;long long&gt;
std::atomic&lt;unsigned long long&gt;
std::atomic&lt;wchar_t&gt;
std::atomic&lt;char16_t&gt;
std::atomic&lt;char32_t&gt;</pre>
      
      <p class="noind">and <kbd class="calibre17">std::atomic&lt;T*&gt;</kbd> for all types <kbd class="calibre17">T</kbd>.
      </p>
      
      
      
      <h4 id="app04lev2sec17" class="calibre23">D.3.10. <a id="app04lev2sec17__title" class="calibre4"></a>std::atomic&lt;integral-type&gt; specializations
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::atomic&lt;integral-type&gt;</kbd> specializations of the <kbd class="calibre17">std::atomic</kbd> class template provide an atomic integral data type for each fundamental integer type, with a comprehensive set of operations.
      </p>
      
      <p class="noind">The following description applies to these specializations of the <kbd class="calibre17">std::atomic&lt;&gt;</kbd> class template:
      </p>
      
      <pre id="PLd0e52853" class="calibre5">std::atomic&lt;char&gt;
std::atomic&lt;signed char&gt;
std::atomic&lt;unsigned char&gt;
std::atomic&lt;short&gt;
std::atomic&lt;unsigned short&gt;
std::atomic&lt;int&gt;
std::atomic&lt;unsigned&gt;
std::atomic&lt;long&gt;
std::atomic&lt;unsigned long&gt;
std::atomic&lt;long long&gt;
std::atomic&lt;unsigned long long&gt;
std::atomic&lt;wchar_t&gt;
std::atomic&lt;char16_t&gt;
std::atomic&lt;char32_t&gt;</pre>
      
      <p class="noind">Instances of these specializations are not <kbd class="calibre17">CopyConstructible</kbd> or <kbd class="calibre17">CopyAssignable</kbd>, because these operations canâ€™t be performed as a single atomic operation.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;&gt;
struct atomic&lt;<i class="calibre6">integral-type</i>&gt;
{
    atomic() noexcept = default;
    constexpr atomic(<i class="calibre6">integral-type</i>) noexcept;
    bool operator=(<i class="calibre6">integral-type</i>) volatile noexcept;

    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;

    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;

    void store(<i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst)
        volatile noexcept;
    void store(<i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst) noexcept;
    <i class="calibre6">integral-type</i> load(memory_order = memory_order_seq_cst)
        const volatile noexcept;
    <i class="calibre6">integral-type</i> load(memory_order = memory_order_seq_cst) const noexcept;
    <i class="calibre6">integral-type</i> exchange(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst)
        volatile noexcept;
    <i class="calibre6">integral-type</i> exchange(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst) noexcept;

    bool compare_exchange_strong(
        <i class="calibre6">integral-type</i> &amp; old_value,<i class="calibre6">integral-type</i> new_value,
         memory_order order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(
        <i class="calibre6">integral-type</i> &amp; old_value,<i class="calibre6">integral-type</i> new_value,
         memory_order order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(
        <i class="calibre6">integral-type</i> &amp; old_value,<i class="calibre6">integral-type</i> new_value,
        memory_order success_order,memory_order failure_order)
        volatile noexcept;
    bool compare_exchange_strong(
        <i class="calibre6">integral-type</i> &amp; old_value,<i class="calibre6">integral-type</i> new_value,
        memory_order success_order,memory_order failure_order) noexcept;
    bool compare_exchange_weak(
        <i class="calibre6">integral-type</i> &amp; old_value,<i class="calibre6">integral-type</i> new_value,
         memory_order order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(
        <i class="calibre6">integral-type</i> &amp; old_value,<i class="calibre6">integral-type</i> new_value,
         memory_order order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(
        <i class="calibre6">integral-type</i> &amp; old_value,<i class="calibre6">integral-type</i> new_value,
        memory_order success_order,memory_order failure_order)
        volatile noexcept;
    bool compare_exchange_weak(
        <i class="calibre6">integral-type</i> &amp; old_value,<i class="calibre6">integral-type</i> new_value,
        memory_order success_order,memory_order failure_order) noexcept;

    operator <i class="calibre6">integral-type</i>() const volatile noexcept;
    operator <i class="calibre6">integral-type</i>() const noexcept;

    <i class="calibre6">integral-type</i> fetch_add(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst)
        volatile noexcept;
    <i class="calibre6">integral-type</i> fetch_add(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst) noexcept;
    <i class="calibre6">integral-type</i> fetch_sub(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst)
        volatile noexcept;
    <i class="calibre6">integral-type</i> fetch_sub(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst) noexcept;
    <i class="calibre6">integral-type</i> fetch_and(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst)
        volatile noexcept;
    <i class="calibre6">integral-type</i> fetch_and(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst) noexcept;
    <i class="calibre6">integral-type</i> fetch_or(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst)
        volatile noexcept;
    <i class="calibre6">integral-type</i> fetch_or(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst) noexcept;
    <i class="calibre6">integral-type</i> fetch_xor(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst)
        volatile noexcept;
    <i class="calibre6">integral-type</i> fetch_xor(
        <i class="calibre6">integral-type</i>,memory_order = memory_order_seq_cst) noexcept;

    <i class="calibre6">integral-type</i> operator++() volatile noexcept;
    <i class="calibre6">integral-type</i> operator++() noexcept;
    <i class="calibre6">integral-type</i> operator++(int) volatile noexcept;
    <i class="calibre6">integral-type</i> operator++(int) noexcept;
    <i class="calibre6">integral-type</i> operator--() volatile noexcept;
    <i class="calibre6">integral-type</i> operator--() noexcept;
    <i class="calibre6">integral-type</i> operator--(int) volatile noexcept;
    <i class="calibre6">integral-type</i> operator--(int) noexcept;

    <i class="calibre6">integral-type</i> operator+=(<i class="calibre6">integral-type</i>) volatile noexcept;
    <i class="calibre6">integral-type</i> operator+=(<i class="calibre6">integral-type</i>) noexcept;
    <i class="calibre6">integral-type</i> operator-=(<i class="calibre6">integral-type</i>) volatile noexcept;
    <i class="calibre6">integral-type</i> operator-=(<i class="calibre6">integral-type</i>) noexcept;
    <i class="calibre6">integral-type</i> operator&amp;=(<i class="calibre6">integral-type</i>) volatile noexcept;
    <i class="calibre6">integral-type</i> operator&amp;=(<i class="calibre6">integral-type</i>) noexcept;
    <i class="calibre6">integral-type</i> operator|=(<i class="calibre6">integral-type</i>) volatile noexcept;
    <i class="calibre6">integral-type</i> operator|=(<i class="calibre6">integral-type</i>) noexcept;
    <i class="calibre6">integral-type</i> operator^=(<i class="calibre6">integral-type</i>) volatile noexcept;
    <i class="calibre6">integral-type</i> operator^=(<i class="calibre6">integral-type</i>) noexcept;
};

bool atomic_is_lock_free(volatile const atomic&lt;<i class="calibre6">integral-type</i>&gt;*) noexcept;
bool atomic_is_lock_free(const atomic&lt;<i class="calibre6">integral-type</i>&gt;*) noexcept;
void atomic_init(volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
void atomic_init(atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_exchange(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_exchange(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_exchange_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_exchange_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
void atomic_store(volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
void atomic_store(atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
void atomic_store_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
void atomic_store_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_load(volatile const atomic&lt;<i class="calibre6">integral-type</i>&gt;*) noexcept;
<i class="calibre6">integral-type</i> atomic_load(const atomic&lt;<i class="calibre6">integral-type</i>&gt;*) noexcept;
<i class="calibre6">integral-type</i> atomic_load_explicit(
    volatile const atomic&lt;<i class="calibre6">integral-type</i>&gt;*,memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_load_explicit(
    const atomic&lt;<i class="calibre6">integral-type</i>&gt;*,memory_order) noexcept;
bool atomic_compare_exchange_strong(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,
    <i class="calibre6">integral-type</i> * old_value,<i class="calibre6">integral-type</i> new_value) noexcept;
bool atomic_compare_exchange_strong(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,
    <i class="calibre6">integral-type</i> * old_value,<i class="calibre6">integral-type</i> new_value) noexcept;
bool atomic_compare_exchange_strong_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,
    <i class="calibre6">integral-type</i> * old_value,<i class="calibre6">integral-type</i> new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_strong_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,
    <i class="calibre6">integral-type</i> * old_value,<i class="calibre6">integral-type</i> new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_weak(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,
    <i class="calibre6">integral-type</i> * old_value,<i class="calibre6">integral-type</i> new_value) noexcept;
bool atomic_compare_exchange_weak(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,
    <i class="calibre6">integral-type</i> * old_value,<i class="calibre6">integral-type</i> new_value) noexcept;
bool atomic_compare_exchange_weak_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,
    <i class="calibre6">integral-type</i> * old_value,<i class="calibre6">integral-type</i> new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_weak_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,
    <i class="calibre6">integral-type</i> * old_value,<i class="calibre6">integral-type</i> new_value,
    memory_order success_order,memory_order failure_order) noexcept;

<i class="calibre6">integral-type</i> atomic_fetch_add(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_add(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_add_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_add_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_sub(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_sub(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_sub_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_sub_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_and(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_and(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_and_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_and_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_or(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_or(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_or_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_or_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_xor(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_xor(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_xor_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_xor_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;*,<i class="calibre6">integral-type</i>, memory_order) noexcept;</pre>
            
            <a id="iddle1999" class="calibre4"></a>Those operations that are also provided by the primary template (see D.3.8) have the same semantics.
         </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec107"><a id="app04lev3sec107__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::fetch_add member function
      </h5>
      
      <p class="noind">Atomically loads a value and replaces it with the sum of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> fetch_add(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
<i class="calibre6">integral-type</i> fetch_add(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1971" class="calibre4"></a><a id="iddle1973" class="calibre4"></a><a id="iddle2002" class="calibre4"></a><i class="calibre6">Effects</i>
            Atomically retrieves the existing value of <kbd class="calibre17">*this</kbd> and stores <i class="calibre6">old-value</i> <kbd class="calibre17">+ i</kbd> in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The value of <kbd class="calibre17">*this</kbd> immediately prior to the store.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note26">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec108"><a id="app04lev3sec108__title" class="calibre4"></a>std::atomic_fetch_add nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;</kbd><i class="calibre6"><kbd class="calibre17">integral-type</kbd></i><kbd class="calibre17">&gt;</kbd> instance and replaces it with that value plus the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_add(
    volatile atomic&lt;integral-type&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_add(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_add(i);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec109"><a id="app04lev3sec109__title" class="calibre4"></a>std::atomic_fetch_add_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;</kbd><i class="calibre6"><kbd class="calibre17">integral-type</kbd></i><kbd class="calibre17">&gt;</kbd> instance and replaces it with that value plus the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_add_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i,
    memory_order order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_add_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i, memory_order order)
    noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_add(i,order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec110"><a id="app04lev3sec110__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::fetch_sub member function
      </h5>
      
      <p class="noind">Atomically loads a value and replaces it with the sum of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> fetch_sub(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
<i class="calibre6">integral-type</i> fetch_sub(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically retrieves the existing value of <kbd class="calibre17">*this</kbd> and stores <i class="calibre6">old-value</i> <kbd class="calibre17">- i</kbd> in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1979" class="calibre4"></a><a id="iddle1981" class="calibre4"></a><a id="iddle2000" class="calibre4"></a><i class="calibre6">Returns</i>
            The value of <kbd class="calibre17">*this</kbd> immediately prior to the store.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note27">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec111"><a id="app04lev3sec111__title" class="calibre4"></a>std::atomic_fetch_sub nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;integral-type&gt;</kbd> instance and replaces it with that value minus the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_sub(
    volatile atomic&lt;integral-type&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_sub(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_sub(i);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec112"><a id="app04lev3sec112__title" class="calibre4"></a>std::atomic_fetch_sub_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;integral-type&gt;</kbd> instance and replaces it with that value minus the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_sub_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i,
    memory_order order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_sub_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i, memory_order order)
    noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_sub(i,order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec113"><a id="app04lev3sec113__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::fetch_and member function
      </h5>
      
      <p class="noind">Atomically loads a value and replaces it with the bitwise-and of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> fetch_and(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
<i class="calibre6">integral-type</i> fetch_and(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically retrieves the existing value of <kbd class="calibre17">*this</kbd> and stores <i class="calibre6">old-value</i> <kbd class="calibre17">&amp; i</kbd> in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The value of <kbd class="calibre17">*this</kbd> immediately prior to the store.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1975" class="calibre4"></a><a id="iddle1976" class="calibre4"></a><a id="iddle2001" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note28">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec114"><a id="app04lev3sec114__title" class="calibre4"></a>std::atomic_fetch_and nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;integral-type&gt;</kbd> instance and replaces it with the bitwise-and of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_and(
    volatile atomic&lt;integral-type&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_and(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_and(i);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec115"><a id="app04lev3sec115__title" class="calibre4"></a>std::atomic_fetch_and_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;integral-type&gt;</kbd> instance and replaces it with the bitwise-and of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_and_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i,
    memory_order order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_and_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i, memory_order order)
    noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_and(i,order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec116"><a id="app04lev3sec116__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::fetch_or member function
      </h5>
      
      <p class="noind">Atomically loads a value and replaces it with the bitwise-or of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> fetch_or(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
<i class="calibre6">integral-type</i> fetch_or(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically retrieves the existing value of <kbd class="calibre17">*this</kbd> and stores <i class="calibre6">old-value</i> <kbd class="calibre17">| i</kbd> in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The value of <kbd class="calibre17">*this</kbd> immediately prior to the store.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1977" class="calibre4"></a><a id="iddle1978" class="calibre4"></a><a id="iddle2003" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note29">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec117"><a id="app04lev3sec117__title" class="calibre4"></a>std::atomic_fetch_or nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;integral-type&gt;</kbd> instance and replaces it with the bitwise-or of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_or(
    volatile atomic&lt;integral-type&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_or(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_or(i);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec118"><a id="app04lev3sec118__title" class="calibre4"></a>std::atomic_fetch_or_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;integral-type&gt;</kbd> instance and replaces it with the bitwise-or of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_or_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i,
    memory_order order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_or_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i, memory_order order)
    noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_or(i,order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec119"><a id="app04lev3sec119__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::fetch_xor member function
      </h5>
      
      <p class="noind">Atomically loads a value and replaces it with the bitwise-xor of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> fetch_xor(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
<i class="calibre6">integral-type</i> fetch_xor(
    <i class="calibre6">integral-type</i> i,memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically retrieves the existing value of <kbd class="calibre17">*this</kbd> and stores <i class="calibre6">old-value</i> <kbd class="calibre17">^ i</kbd> in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The value of <kbd class="calibre17">*this</kbd> immediately prior to the store.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note30">Note</h5>
      
      
      
      <p class="noindclose"><a id="iddle1983" class="calibre4"></a><a id="iddle1984" class="calibre4"></a><a id="iddle2007" class="calibre4"></a><a id="iddle2008" class="calibre4"></a>This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec120"><a id="app04lev3sec120__title" class="calibre4"></a>std::atomic_fetch_xor nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;integral-type&gt;</kbd> instance and replaces it with the bitwise-xor of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_xor(
    volatile atomic&lt;integral-type&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_xor(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_xor(i);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec121"><a id="app04lev3sec121__title" class="calibre4"></a>std::atomic_fetch_xor_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;integral-type&gt;</kbd> instance and replaces it with the bitwise-xor of that value and the supplied value <kbd class="calibre17">i</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> atomic_fetch_xor_explicit(
    volatile atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i,
    memory_order order) noexcept;
<i class="calibre6">integral-type</i> atomic_fetch_xor_explicit(
    atomic&lt;<i class="calibre6">integral-type</i>&gt;* p, <i class="calibre6">integral-type</i> i, memory_order order)
    noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_xor(i,order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec122"><a id="app04lev3sec122__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator++ preincrement operator
      </h5>
      
      <p class="noind">Atomically increments the value stored in <kbd class="calibre17">*this</kbd> and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator++() volatile noexcept;
<i class="calibre6">integral-type</i> operator++() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_add(1) + 1;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec123"><a id="app04lev3sec123__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator++ postincrement operator
      </h5>
      
      <p class="noind">Atomically increments the value stored in <kbd class="calibre17">*this</kbd> and returns the old value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator++(int) volatile noexcept;
<i class="calibre6">integral-type</i> operator++(int) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_add(1);</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec124"><a id="app04lev3sec124__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator-- predecrement operator
      </h5>
      
      <p class="noind"><a id="iddle2004" class="calibre4"></a><a id="iddle2005" class="calibre4"></a><a id="iddle2006" class="calibre4"></a><a id="iddle2009" class="calibre4"></a><a id="iddle2010" class="calibre4"></a>Atomically decrements the value stored in <kbd class="calibre17">*this</kbd> and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator--() volatile noexcept;
<i class="calibre6">integral-type</i> operator--() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_sub(1) â€“ 1;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec125"><a id="app04lev3sec125__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator-- postdecrement operator
      </h5>
      
      <p class="noind">Atomically decrements the value stored in <kbd class="calibre17">*this</kbd> and returns the old value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator--(int) volatile noexcept;
<i class="calibre6">integral-type</i> operator--(int) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_sub(1);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec126"><a id="app04lev3sec126__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator+= compound assignment operator
      </h5>
      
      <p class="noind">Atomically adds the supplied value to the value stored in <kbd class="calibre17">*this</kbd> and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator+=(<i class="calibre6">integral-type</i> i) volatile noexcept;
<i class="calibre6">integral-type</i> operator+=(<i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_add(i) + i;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec127"><a id="app04lev3sec127__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator-= compound assignment operator
      </h5>
      
      <p class="noind">Atomically subtracts the supplied value from the value stored in <kbd class="calibre17">*this</kbd> and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator-=(<i class="calibre6">integral-type</i> i) volatile noexcept;
<i class="calibre6">integral-type</i> operator-=(<i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_sub(i,std::memory_order_seq_cst) â€“ i;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec128"><a id="app04lev3sec128__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator&amp;= compound assignment operator
      </h5>
      
      <p class="noind">Atomically replaces the value stored in <kbd class="calibre17">*this</kbd> with the bitwise-and of the supplied value and the value stored in <kbd class="calibre17">*this</kbd> and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator&amp;=(<i class="calibre6">integral-type</i> i) volatile noexcept;
<i class="calibre6">integral-type</i> operator&amp;=(<i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_and(i) &amp; i;</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec129"><a id="app04lev3sec129__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator|= compound assignment operator
      </h5>
      
      <p class="noind"><a id="iddle2011" class="calibre4"></a><a id="iddle2012" class="calibre4"></a><a id="iddle2020" class="calibre4"></a>Atomically replaces the value stored in <kbd class="calibre17">*this</kbd> with the bitwise-or of the supplied value and the value stored in <kbd class="calibre17">*this</kbd> and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator|=(<i class="calibre6">integral-type</i> i) volatile noexcept;
<i class="calibre6">integral-type</i> operator|=(<i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_or(i,std::memory_order_seq_cst) | i;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec130"><a id="app04lev3sec130__title" class="calibre4"></a>std::atomic&lt;integral-type&gt;::operator^= compound assignment operator
      </h5>
      
      <p class="noind">Atomically replaces the value stored in <kbd class="calibre17">*this</kbd> with the bitwise-xor of the supplied value and the value stored in <kbd class="calibre17">*this</kbd> and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5"><i class="calibre6">integral-type</i> operator^=(<i class="calibre6">integral-type</i> i) volatile noexcept;
<i class="calibre6">integral-type</i> operator^=(<i class="calibre6">integral-type</i> i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_xor(i,std::memory_order_seq_cst) ^ i;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec131"><a id="app04lev3sec131__title" class="calibre4"></a>std::atomic&lt;T*&gt; partial specialization
      </h5>
      
      <p class="noind">The <kbd class="calibre17">std::atomic&lt;T*&gt;</kbd> partial specialization of the <kbd class="calibre17">std::atomic</kbd> class template provides an atomic data type for each pointer type, with a comprehensive set of operations.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::atomic&lt;T*&gt;</kbd> are not <kbd class="calibre17">CopyConstructible</kbd> or <kbd class="calibre17">CopyAssignable</kbd>, because these operations canâ€™t be performed as a single atomic operation.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename T&gt;
struct atomic&lt;T*&gt;
{
    atomic() noexcept = default;
    constexpr atomic(T*) noexcept;
    bool operator=(T*) volatile;
    bool operator=(T*);

    atomic(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) = delete;
    atomic&amp; operator=(const atomic&amp;) volatile = delete;

    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;
    void store(T*,memory_order = memory_order_seq_cst) volatile noexcept;
    void store(T*,memory_order = memory_order_seq_cst) noexcept;
    T* load(memory_order = memory_order_seq_cst) const volatile noexcept;
    T* load(memory_order = memory_order_seq_cst) const noexcept;
    T* exchange(T*,memory_order = memory_order_seq_cst) volatile noexcept;
    T* exchange(T*,memory_order = memory_order_seq_cst) noexcept;

    bool compare_exchange_strong(
        T* &amp; old_value, T* new_value,
        memory_order order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(
        T* &amp; old_value, T* new_value,
        memory_order order = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(
        T* &amp; old_value, T* new_value,
        memory_order success_order,memory_order failure_order)
        volatile noexcept;
    bool compare_exchange_strong(
        T* &amp; old_value, T* new_value,
        memory_order success_order,memory_order failure_order) noexcept;
    bool compare_exchange_weak(
        T* &amp; old_value, T* new_value,
        memory_order order = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(
        T* &amp; old_value, T* new_value,
        memory_order order = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(
        T* &amp; old_value, T* new_value,
        memory_order success_order,memory_order failure_order)
        volatile noexcept;
    bool compare_exchange_weak(
        T* &amp; old_value, T* new_value,
        memory_order success_order,memory_order failure_order) noexcept;

    operator T*() const volatile noexcept;
    operator T*() const noexcept;

    T* fetch_add(
        ptrdiff_t,memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_add(
        ptrdiff_t,memory_order = memory_order_seq_cst) noexcept;
    T* fetch_sub(
        ptrdiff_t,memory_order = memory_order_seq_cst) volatile noexcept;
    T* fetch_sub(
        ptrdiff_t,memory_order = memory_order_seq_cst) noexcept;

    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;

    T* operator+=(ptrdiff_t) volatile noexcept;
    T* operator+=(ptrdiff_t) noexcept;
    T* operator-=(ptrdiff_t) volatile noexcept;
    T* operator-=(ptrdiff_t) noexcept;
};

bool atomic_is_lock_free(volatile const atomic&lt;T*&gt;*) noexcept;
bool atomic_is_lock_free(const atomic&lt;T*&gt;*) noexcept;
void atomic_init(volatile atomic&lt;T*&gt;*, T*) noexcept;
void atomic_init(atomic&lt;T*&gt;*, T*) noexcept;
T* atomic_exchange(volatile atomic&lt;T*&gt;*, T*) noexcept;
T* atomic_exchange(atomic&lt;T*&gt;*, T*) noexcept;
T* atomic_exchange_explicit(volatile atomic&lt;T*&gt;*, T*, memory_order)
    noexcept;
T* atomic_exchange_explicit(atomic&lt;T*&gt;*, T*, memory_order) noexcept;
void atomic_store(volatile atomic&lt;T*&gt;*, T*) noexcept;
void atomic_store(atomic&lt;T*&gt;*, T*) noexcept;
void atomic_store_explicit(volatile atomic&lt;T*&gt;*, T*, memory_order)
    noexcept;
void atomic_store_explicit(atomic&lt;T*&gt;*, T*, memory_order) noexcept;
T* atomic_load(volatile const atomic&lt;T*&gt;*) noexcept;
T* atomic_load(const atomic&lt;T*&gt;*) noexcept;
T* atomic_load_explicit(volatile const atomic&lt;T*&gt;*, memory_order) noexcept;
T* atomic_load_explicit(const atomic&lt;T*&gt;*, memory_order) noexcept;
bool atomic_compare_exchange_strong(
    volatile atomic&lt;T*&gt;*,T* * old_value,T* new_value) noexcept;
bool atomic_compare_exchange_strong(
    volatile atomic&lt;T*&gt;*,T* * old_value,T* new_value) noexcept;
bool atomic_compare_exchange_strong_explicit(
    atomic&lt;T*&gt;*,T* * old_value,T* new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_strong_explicit(
    atomic&lt;T*&gt;*,T* * old_value,T* new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_weak(
    volatile atomic&lt;T*&gt;*,T* * old_value,T* new_value) noexcept;
bool atomic_compare_exchange_weak(
    atomic&lt;T*&gt;*,T* * old_value,T* new_value) noexcept;
bool atomic_compare_exchange_weak_explicit(
    volatile atomic&lt;T*&gt;*,T* * old_value, T* new_value,
    memory_order success_order,memory_order failure_order) noexcept;
bool atomic_compare_exchange_weak_explicit(
    atomic&lt;T*&gt;*,T* * old_value, T* new_value,
    memory_order success_order,memory_order failure_order) noexcept;

T* atomic_fetch_add(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
T* atomic_fetch_add(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
T* atomic_fetch_add_explicit(
    volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
T* atomic_fetch_add_explicit(
    atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
T* atomic_fetch_sub(volatile atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
T* atomic_fetch_sub(atomic&lt;T*&gt;*, ptrdiff_t) noexcept;
T* atomic_fetch_sub_explicit(
    volatile atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;
T* atomic_fetch_sub_explicit(
    atomic&lt;T*&gt;*, ptrdiff_t, memory_order) noexcept;</pre>
            
            <a id="iddle2021" class="calibre4"></a>Those operations that are also provided by the primary template (see 11.3.8) have the same semantics.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec132"><a id="app04lev3sec132__title" class="calibre4"></a>std::atomic&lt;T*&gt;::fetch_add member function
      </h5>
      
      <p class="noind">Atomically loads a value and replaces it with the sum of that value and the supplied value <kbd class="calibre17">i</kbd> using standard pointer arithmetic rules, and returns the old value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* fetch_add(
    ptrdiff_t i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
T* fetch_add(
    ptrdiff_t i,memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1972" class="calibre4"></a><a id="iddle1974" class="calibre4"></a><a id="iddle2022" class="calibre4"></a><i class="calibre6">Effects</i>
            Atomically retrieves the existing value of <kbd class="calibre17">*this</kbd> and stores <i class="calibre6">old-value</i> <kbd class="calibre17">+ i</kbd> in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The value of <kbd class="calibre17">*this</kbd> immediately prior to the store.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note31">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec133"><a id="app04lev3sec133__title" class="calibre4"></a>std::atomic_fetch_add nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;T*&gt;</kbd> instance and replaces it with that value plus the supplied value <kbd class="calibre17">i</kbd> using standard pointer arithmetic rules.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* atomic_fetch_add(volatile atomic&lt;T*&gt;* p, ptrdiff_t i) noexcept;
T* atomic_fetch_add(atomic&lt;T*&gt;* p, ptrdiff_t i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_add(i);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec134"><a id="app04lev3sec134__title" class="calibre4"></a>std::atomic_fetch_add_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;T*&gt;</kbd> instance and replaces it with that value plus the supplied value <kbd class="calibre17">i</kbd> using standard pointer arithmetic rules.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* atomic_fetch_add_explicit(
    volatile atomic&lt;T*&gt;* p, ptrdiff_t i,memory_order order) noexcept;
T* atomic_fetch_add_explicit(
    atomic&lt;T*&gt;* p, ptrdiff_t i, memory_order order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_add(i,order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec135"><a id="app04lev3sec135__title" class="calibre4"></a>std::atomic&lt;T*&gt;::fetch_sub member function
      </h5>
      
      <p class="noind">Atomically loads a value and replaces it with that value minus the supplied value <kbd class="calibre17">i</kbd> using standard pointer arithmetic rules, and returns the old value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* fetch_sub(
    ptrdiff_t i,memory_order order = memory_order_seq_cst)
    volatile noexcept;
T* fetch_sub(
    ptrdiff_t i,memory_order order = memory_order_seq_cst) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Atomically retrieves the existing value of <kbd class="calibre17">*this</kbd> and stores <i class="calibre6">old-value</i> <kbd class="calibre17">- i</kbd> in <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1980" class="calibre4"></a><a id="iddle1982" class="calibre4"></a><a id="iddle2025" class="calibre4"></a><a id="iddle2026" class="calibre4"></a><i class="calibre6">Returns</i>
            The value of <kbd class="calibre17">*this</kbd> immediately prior to the store.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note32">Note</h5>
      
      
      <p class="noindclose">This is an atomic read-modify-write operation for the memory location comprising <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec136"><a id="app04lev3sec136__title" class="calibre4"></a>std::atomic_fetch_sub nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;T*&gt;</kbd> instance and replaces it with that value minus the supplied value <kbd class="calibre17">i</kbd> using standard pointer arithmetic rules.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* atomic_fetch_sub(volatile atomic&lt;T*&gt;* p, ptrdiff_t i) noexcept;
T* atomic_fetch_sub(atomic&lt;T*&gt;* p, ptrdiff_t i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_sub(i);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec137"><a id="app04lev3sec137__title" class="calibre4"></a>std::atomic_fetch_sub_explicit nonmember function
      </h5>
      
      <p class="noind">Atomically reads the value from an <kbd class="calibre17">atomic&lt;T*&gt;</kbd> instance and replaces it with that value minus the supplied value <kbd class="calibre17">i</kbd> using standard pointer arithmetic rules.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* atomic_fetch_sub_explicit(
    volatile atomic&lt;T*&gt;* p, ptrdiff_t i,memory_order order) noexcept;
T* atomic_fetch_sub_explicit(
    atomic&lt;T*&gt;* p, ptrdiff_t i, memory_order order) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return p-&gt;fetch_sub(i,order);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec138"><a id="app04lev3sec138__title" class="calibre4"></a>std::atomic&lt;T*&gt;::operator++ preincrement operator
      </h5>
      
      <p class="noind">Atomically increments the value stored in <kbd class="calibre17">*this</kbd> using standard pointer arithmetic rules and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* operator++() volatile noexcept;
T* operator++() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_add(1) + 1;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec139"><a id="app04lev3sec139__title" class="calibre4"></a>std::atomic&lt;T*&gt;::operator++ postincrement operator
      </h5>
      
      <p class="noind">Atomically increments the value stored in <kbd class="calibre17">*this</kbd> and returns the old value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* operator++(int) volatile noexcept;
T* operator++(int) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_add(1);</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec140"><a id="app04lev3sec140__title" class="calibre4"></a>std::atomic&lt;T*&gt;::operator-- predecrement operator
      </h5>
      
      <p class="noind"><a id="iddle1091" class="calibre4"></a><a id="iddle1404" class="calibre4"></a><a id="iddle1998" class="calibre4"></a><a id="iddle2023" class="calibre4"></a><a id="iddle2024" class="calibre4"></a><a id="iddle2027" class="calibre4"></a><a id="iddle2028" class="calibre4"></a>Atomically decrements the value stored in <kbd class="calibre17">*this</kbd> using standard pointer arithmetic rules and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* operator--() volatile noexcept;
T* operator--() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_sub(1) - 1;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec141"><a id="app04lev3sec141__title" class="calibre4"></a>std::atomic&lt;T*&gt;::operator-- postdecrement operator
      </h5>
      
      <p class="noind">Atomically decrements the value stored in <kbd class="calibre17">*this</kbd> using standard pointer arithmetic rules and returns the old value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* operator--(int) volatile noexcept;
T* operator--(int) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_sub(1);</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec142"><a id="app04lev3sec142__title" class="calibre4"></a>std::atomic&lt;T*&gt;::operator+= compound assignment operator
      </h5>
      
      <p class="noind">Atomically adds the supplied value to the value stored in <kbd class="calibre17">*this</kbd> using standard pointer arithmetic rules and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* operator+=(ptrdiff_t i) volatile noexcept;
T* operator+=(ptrdiff_t i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_add(i) + i;</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec143"><a id="app04lev3sec143__title" class="calibre4"></a>std::atomic&lt;T*&gt;::operator-= compound assignment operator
      </h5>
      
      <p class="noind">Atomically subtracts the supplied value from the value stored in <kbd class="calibre17">*this</kbd> using standard pointer arithmetic rules and returns the new value.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">T* operator-=(ptrdiff_t i) volatile noexcept;
T* operator-=(ptrdiff_t i) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">return this-&gt;fetch_sub(i) - i;</pre>
            </li>
         
      </ul>
      
      
      
      
      
      <h3 id="app04lev1sec4" class="chapter"><a id="app04lev1sec4__title" class="calibre3"></a>D.4. &lt;future&gt; header
      </h3>
      
      <p class="noind">The <kbd class="calibre17">&lt;future&gt;</kbd> header provides facilities for handling asynchronous results from operations that may be performed on another thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Header contents</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">namespace std
{
    enum class future_status {
        ready, timeout, deferred };

    enum class future_errc
    {

        broken_promise,
        future_already_retrieved,
        promise_already_satisfied,
        no_state
    };

    class future_error;

    const error_category&amp; future_category();
    error_code make_error_code(future_errc e);
    error_condition make_error_condition(future_errc e);

    template&lt;typename ResultType&gt;
    class future;

    template&lt;typename ResultType&gt;
    class shared_future;

    template&lt;typename ResultType&gt;
    class promise;

    template&lt;typename FunctionSignature&gt;
    class packaged_task; // no definition provided

    template&lt;typename ResultType,typename ... Args&gt;
    class packaged_task&lt;ResultType (Args...)&gt;;

    enum class launch {
        async, deferred
    };

    template&lt;typename FunctionType,typename ... Args&gt;
    future&lt;result_of&lt;FunctionType(Args...)&gt;::type&gt;
    async(FunctionType&amp;&amp; func,Args&amp;&amp; ... args);

    template&lt;typename FunctionType,typename ... Args&gt;
    future&lt;result_of&lt;FunctionType(Args...)&gt;::type&gt;
    async(std::launch policy,FunctionType&amp;&amp; func,Args&amp;&amp; ... args);

}</pre>
            </li>
         
      </ul>
      
      
      <h4 id="app04lev2sec18" class="calibre23">D.4.1. <a id="app04lev2sec18__title" class="calibre4"></a>std::future class template
      </h4>
      
      <p class="noind"><a id="iddle1406" class="calibre4"></a><a id="iddle2145" class="calibre4"></a>The <kbd class="calibre17">std::future</kbd> class template provides a means of waiting for an asynchronous result from another thread, in conjunction with the <kbd class="calibre17">std::promise</kbd> and <kbd class="calibre17">std:: packaged_task</kbd> class templates and the <kbd class="calibre17">std::async</kbd> function template, which can be used to provide that asynchronous result. Only one <kbd class="calibre17">std::future</kbd> instance references any given asynchronous result at any time.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::future</kbd> are <kbd class="calibre17">MoveConstructible</kbd> and <kbd class="calibre17">MoveAssignable</kbd> but not <kbd class="calibre17">CopyConstructible</kbd> or <kbd class="calibre17">CopyAssignable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename ResultType&gt;
class future
{
public:
    future() noexcept;
    future(future&amp;&amp;) noexcept;
    future&amp; operator=(future&amp;&amp;) noexcept;
    ~future();

    future(future const&amp;) = delete;
    future&amp; operator=(future const&amp;) = delete;

    shared_future&lt;ResultType&gt; share();

    bool valid() const noexcept;

    <i class="calibre6">see description</i> get();

    void wait();

    template&lt;typename Rep,typename Period&gt;
    future_status wait_for(
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);

    template&lt;typename Clock,typename Duration&gt;
    future_status wait_until(
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec144"><a id="app04lev3sec144__title" class="calibre4"></a>std::future default constructor
      </h5>
      
      <p class="noind"><a id="iddle2146" class="calibre4"></a><a id="iddle2149" class="calibre4"></a>Constructs an <kbd class="calibre17">std::future</kbd> object without an associated asynchronous result.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">future() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::future</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">valid()</kbd> returns <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec145"><a id="app04lev3sec145__title" class="calibre4"></a>std::future move constructor
      </h5>
      
      <p class="noind">Constructs one <kbd class="calibre17">std::future</kbd> object from another, transferring ownership of the asynchronous result associated with the other <kbd class="calibre17">std::future</kbd> object to the newly constructed instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">future(future&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Move-constructs a new <kbd class="calibre17">std::future</kbd> instance from <kbd class="calibre17">other</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">other</kbd> prior to the invocation of the constructor is associated with the newly constructed <kbd class="calibre17">std::future</kbd> object. <kbd class="calibre17">other</kbd> has no associated asynchronous result. <kbd class="calibre17">this-&gt;valid()</kbd> returns the same value that <kbd class="calibre17">other.valid()</kbd> returned before the invocation of this constructor. <kbd class="calibre17">other.valid()</kbd> returns <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2147" class="calibre4"></a><a id="iddle2148" class="calibre4"></a><a id="iddle2152" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec146"><a id="app04lev3sec146__title" class="calibre4"></a>std::future move assignment operator
      </h5>
      
      <p class="noind">Transfers ownership of the asynchronous result associated with the one <kbd class="calibre17">std::future</kbd> object to another.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">future(future&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Transfers ownership of an asynchronous state between <kbd class="calibre17">std::future</kbd> instances.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">other</kbd> prior to the invocation of the constructor is associated with <kbd class="calibre17">*this</kbd>. <kbd class="calibre17">other</kbd> has no associated asynchronous result. The ownership of the asynchronous state (if any) associated with <kbd class="calibre17">*this</kbd> prior to the call is released, and the state destroyed if this is the last reference. <kbd class="calibre17">this-&gt;valid()</kbd> returns the same value that <kbd class="calibre17">other.valid()</kbd> returned before the invocation of this constructor. <kbd class="calibre17">other.valid()</kbd> returns <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec147"><a id="app04lev3sec147__title" class="calibre4"></a>std::future destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::future</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~future();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>. If this is the last reference to the asynchronous result associated with <kbd class="calibre17">*this</kbd> (if any), then destroy that asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec148"><a id="app04lev3sec148__title" class="calibre4"></a>std::future::share member function
      </h5>
      
      <p class="noind">Constructs a new <kbd class="calibre17">std::shared_future</kbd> instance and transfers ownership of the asynchronous result associated with <kbd class="calibre17">*this</kbd> to this newly constructed <kbd class="calibre17">std::shared_future</kbd> instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_future&lt;ResultType&gt; share();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if <kbd class="calibre17">shared_future&lt;ResultType&gt;(std::move(*this))</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">*this</kbd> prior to the invocation of <kbd class="calibre17">share()</kbd> (if any) is associated with the newly constructed <kbd class="calibre17">std::shared_future</kbd> instance. <kbd class="calibre17">this-&gt;valid()</kbd> returns <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2153" class="calibre4"></a><a id="iddle2154" class="calibre4"></a><a id="iddle2155" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec149"><a id="app04lev3sec149__title" class="calibre4"></a>std::future::valid member function
      </h5>
      
      <p class="noind">Checks if an <kbd class="calibre17">std::future</kbd> instance is associated with an asynchronous result.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool valid() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if <kbd class="calibre17">*this</kbd> has an associated asynchronous result, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec150"><a id="app04lev3sec150__title" class="calibre4"></a>std::future::wait member function
      </h5>
      
      <p class="noind">If the state associated with <kbd class="calibre17">*this</kbd> contains a deferred function, invokes the deferred function. Otherwise, waits until the asynchronous result associated with
         an instance of <kbd class="calibre17">std::future</kbd> is ready.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void wait();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;valid()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If the associated state contains a deferred function, invokes the deferred function and stores the returned value or thrown
            exception as the asynchronous result. Otherwise, blocks until the asynchronous result associated with <kbd class="calibre17">*this</kbd> is <i class="calibre6">ready</i>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec151"><a id="app04lev3sec151__title" class="calibre4"></a>std::future::wait_for member function
      </h5>
      
      <p class="noind">Waits until the asynchronous result associated with an instance of <kbd class="calibre17">std::future</kbd> is ready or until a specified time period has elapsed.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
future_status wait_for(
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;valid()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If the asynchronous result associated with <kbd class="calibre17">*this</kbd> contains a deferred function arising from a call to <kbd class="calibre17">std::async</kbd> that hasnâ€™t yet <a id="iddle2151" class="calibre4"></a><a id="iddle2156" class="calibre4"></a>started execution, returns immediately without blocking. Otherwise blocks until the asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">std::future_status::deferred</kbd> if the asynchronous result associated with <kbd class="calibre17">*this</kbd> contains a deferred function arising from a call to <kbd class="calibre17">std::async</kbd> that hasnâ€™t yet started execution, <kbd class="calibre17">std::future_status::ready</kbd> if the asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready, <kbd class="calibre17">std::future_status::timeout</kbd> if the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note33">Note</h5>
      
      
      <p class="noindclose">The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined by a steady
         clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec152"><a id="app04lev3sec152__title" class="calibre4"></a>std::future::wait_until member function
      </h5>
      
      <p class="noind">Waits until the asynchronous result associated with an instance of <kbd class="calibre17">std::future</kbd> is ready or until a specified time period has elapsed.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
future_status wait_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;valid()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If the asynchronous result associated with <kbd class="calibre17">*this</kbd> contains a deferred function arising from a call to <kbd class="calibre17">std::async</kbd> that hasnâ€™t yet started execution, returns immediately without blocking. Otherwise blocks until the asynchronous result associated
            with <kbd class="calibre17">*this</kbd> is <i class="calibre6">ready</i> or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">std::future_status::deferred</kbd> if the asynchronous result associated with <kbd class="calibre17">*this</kbd> contains a deferred function arising from a call to <kbd class="calibre17">std::async</kbd> that hasnâ€™t yet started execution, <kbd class="calibre17">std::future_status::ready</kbd> if the asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready, <kbd class="calibre17">std::future_status::timeout</kbd> if <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note34">Note</h5>
      
      
      <p class="noindclose">Thereâ€™s no guarantee as to how long the calling thread will be blocked, only that if the function returns <kbd class="calibre17">std::future_status::timeout</kbd>, then <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec153"><a id="app04lev3sec153__title" class="calibre4"></a>std::future::get member function
      </h5>
      
      <p class="noind">If the associated state contains a deferred function from a call to <kbd class="calibre17">std::async</kbd>, invokes that function and returns the result; otherwise, waits until the asynchronous result associated with an instance
         of <kbd class="calibre17">std::future</kbd> is ready, and then returns the stored value or throws the stored exception.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1409" class="calibre4"></a><a id="iddle2273" class="calibre4"></a><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void future&lt;void&gt;::get();
R&amp; future&lt;R&amp;&gt;::get();
R future&lt;R&gt;::get();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;valid()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If the state associated with <kbd class="calibre17">*this</kbd> contains a deferred function, invokes the deferred function and returns the result or propagates any thrown exception.
            Otherwise, blocks until the asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready. If the result is a stored exception, throws that exception. Otherwise, returns the stored value.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            If the associated state contains a deferred function, the result of the function invocation is returned. Otherwise, if <kbd class="calibre17">ResultType</kbd> is <kbd class="calibre17">void</kbd>, the call returns normally. If <kbd class="calibre17">ResultType</kbd> is <kbd class="calibre17">R&amp;</kbd> for some type <kbd class="calibre17">R</kbd>, the stored reference is returned. Otherwise, the stored value is returned.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            The exception thrown by the deferred exception or stored in the asynchronous result, if any.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postcondition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;valid()==false</pre>
            </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec19" class="calibre23">D.4.2. <a id="app04lev2sec19__title" class="calibre4"></a>std::shared_future class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::shared_future</kbd> class template provides a means of waiting for an asynchronous result from another thread, in conjunction with the <kbd class="calibre17">std::promise</kbd> and <kbd class="calibre17">std:: packaged_task</kbd> class templates and the <kbd class="calibre17">std::async</kbd> function template, which can be used to provide that asynchronous result. Multiple <kbd class="calibre17">std::shared_future</kbd> instances can reference the same asynchronous result.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::shared_future</kbd> are <kbd class="calibre17">CopyConstructible</kbd> and <kbd class="calibre17">CopyAssignable</kbd>. You can also move-construct a <kbd class="calibre17">std::shared_future</kbd> from a <kbd class="calibre17">std::future</kbd> with the same <kbd class="calibre17">ResultType</kbd>.
      </p>
      
      <p class="noind">Accesses to a given instance of <kbd class="calibre17">std::shared_future</kbd> arenâ€™t synchronized. Itâ€™s therefore not safe for multiple threads to access the same <kbd class="calibre17">std::shared_future</kbd> instance without external synchronization. But accesses to the associated state are synchronized, so it <i class="calibre6">is</i> safe for multiple threads to each access separate instances of <kbd class="calibre17">std:: shared_future</kbd> that share the same associated state without external synchronization.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename ResultType&gt;
class shared_future
{
public:
    shared_future() noexcept;
    shared_future(future&lt;ResultType&gt;&amp;&amp;) noexcept;

    shared_future(shared_future&amp;&amp;) noexcept;
    shared_future(shared_future const&amp;);
    shared_future&amp; operator=(shared_future const&amp;);
    shared_future&amp; operator=(shared_future&amp;&amp;) noexcept;
    ~shared_future();

    bool valid() const noexcept;

    <i class="calibre6">see description</i> get() const;

    void wait() const;

    template&lt;typename Rep,typename Period&gt;
    future_status wait_for(
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time) const;

    template&lt;typename Clock,typename Duration&gt;
    future_status wait_until(
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time) const;
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec154"><a id="app04lev3sec154__title" class="calibre4"></a>std::shared_future default constructor
      </h5>
      
      <p class="noind"><a id="iddle2275" class="calibre4"></a><a id="iddle2277" class="calibre4"></a>Constructs an <kbd class="calibre17">std::shared_future</kbd> object without an associated asynchronous result.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_future() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::shared_future</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">valid()</kbd> returns <kbd class="calibre17">false</kbd> for the newly constructed instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec155"><a id="app04lev3sec155__title" class="calibre4"></a>std::shared_future move constructor
      </h5>
      
      <p class="noind">Constructs one <kbd class="calibre17">std::shared_future</kbd> object from another, transferring ownership of the asynchronous result associated with the other <kbd class="calibre17">std::shared_future</kbd> object to the newly constructed instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_future(shared_future&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::shared_future</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">other</kbd> prior to the invocation of the constructor is associated with the newly constructed <kbd class="calibre17">std::shared_future</kbd> object. <kbd class="calibre17">other</kbd> has no associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec156"><a id="app04lev3sec156__title" class="calibre4"></a>std::shared_future move-from-std::future constructor
      </h5>
      
      <p class="noind"><a id="iddle1631" class="calibre4"></a><a id="iddle2274" class="calibre4"></a><a id="iddle2276" class="calibre4"></a><a id="iddle2278" class="calibre4"></a>Constructs an <kbd class="calibre17">std::shared_future</kbd> object from a<kbd class="calibre17">std::future</kbd>, transferring ownership of the asynchronous result associated with the <kbd class="calibre17">std::future</kbd> object to the newly constructed <kbd class="calibre17">std::shared_future</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_future(std::future&lt;ResultType&gt;&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::shared_future</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">other</kbd> prior to the invocation of the constructor is associated with the newly constructed <kbd class="calibre17">std::shared_future</kbd> object. <kbd class="calibre17">other</kbd> has no associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec157"><a id="app04lev3sec157__title" class="calibre4"></a>std::shared_future copy constructor
      </h5>
      
      <p class="noind">Constructs one <kbd class="calibre17">std::shared_future</kbd> object from another, so that both the source and the copy refer to the asynchronous result associated with the source <kbd class="calibre17">std::shared_future</kbd> object, if any.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_future(shared_future const&amp; other);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::shared_future</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">other</kbd> prior to the invocation of the constructor is associated with the newly constructed <kbd class="calibre17">std::shared_future</kbd> object and <kbd class="calibre17">other</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec158"><a id="app04lev3sec158__title" class="calibre4"></a>std::shared_future destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::shared_future</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~shared_future();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>. If thereâ€™s no longer an <kbd class="calibre17">std::promise</kbd> or <kbd class="calibre17">std::packaged_task</kbd> instance associated with the asynchronous result associated with <kbd class="calibre17">*this</kbd>, and this is the last <kbd class="calibre17">std::shared_future</kbd> instance associated with that asynchronous result, destroys that asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      </body></html>
