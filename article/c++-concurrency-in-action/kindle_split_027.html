<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mbp="Kindle">
  <head>
    <title>C++ Concurrency in Action, Second Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h5 class="notetitle" id="app04lev3sec159"><a id="app04lev3sec159__title" class="calibre4"></a>std::shared_future::valid member function
      </h5>
      
      <p class="noind"><a id="iddle2282" class="calibre4"></a><a id="iddle2283" class="calibre4"></a><a id="iddle2284" class="calibre4"></a>Checks if an <kbd class="calibre17">std::shared_future</kbd> instance is associated with an asynchronous result.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool valid() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if <kbd class="calibre17">*this</kbd> has an associated asynchronous result, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec160"><a id="app04lev3sec160__title" class="calibre4"></a>std::shared_future::wait member function
      </h5>
      
      <p class="noind">If the state associated with <kbd class="calibre17">*this</kbd> contains a deferred function, invokes the deferred function. Otherwise, waits until the asynchronous result associated with
         an instance of <kbd class="calibre17">std::shared_future</kbd> is ready.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void wait() const;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;valid()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls to <kbd class="calibre17">get()</kbd> and <kbd class="calibre17">wait()</kbd> from multiple threads on <kbd class="calibre17">std::shared_future</kbd> instances that share the same associated state are serialized. If the associated state contains a deferred function, the
            first call to <kbd class="calibre17">get()</kbd> or <kbd class="calibre17">wait()</kbd> invokes the deferred function and stores the returned value or thrown exception as the asynchronous result.
            Blocks until the asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec161"><a id="app04lev3sec161__title" class="calibre4"></a>std::shared_future::wait_for member function
      </h5>
      
      <p class="noind">Waits until the asynchronous result associated with an instance of <kbd class="calibre17">std::shared_future</kbd> is ready or until a specified time period has elapsed.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
future_status wait_for(
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time) const;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;valid()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If the asynchronous result associated with <kbd class="calibre17">*this</kbd> contains a deferred function arising from a call to <kbd class="calibre17">std::async</kbd> that has not yet started execution, returns immediately without blocking. Otherwise, blocks until the asynchronous result
            associated with <kbd class="calibre17">*this</kbd> is ready or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">std::future_status::deferred</kbd> if the asynchronous result associated with <kbd class="calibre17">*this</kbd> contains a deferred function arising from a call to <kbd class="calibre17">std::async</kbd> that hasn’t yet <a id="iddle2281" class="calibre4"></a><a id="iddle2285" class="calibre4"></a>started execution, <kbd class="calibre17">std::future_status::ready</kbd> if the asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready, <kbd class="calibre17">std::future_status::timeout</kbd> if the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note35">Note</h5>
      
      
      <p class="noindclose">The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined by a steady
         clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec162"><a id="app04lev3sec162__title" class="calibre4"></a>std::shared_future::wait_until member function
      </h5>
      
      <p class="noind">Waits until the asynchronous result associated with an instance of <kbd class="calibre17">std::shared_future</kbd> is ready or until a specified time period has elapsed.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
bool wait_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time) const;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;valid()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If the asynchronous result associated with <kbd class="calibre17">*this</kbd> contains a deferred function arising from a call to <kbd class="calibre17">std::async</kbd> that hasn’t yet started execution, returns immediately without blocking. Otherwise, blocks until the asynchronous result
            associated with <kbd class="calibre17">*this</kbd> is <i class="calibre6">ready</i> or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">std::future_status::deferred</kbd> if the asynchronous result associated with <kbd class="calibre17">*this</kbd> contains a deferred function arising from a call to <kbd class="calibre17">std::async</kbd> that hasn’t yet started execution, <kbd class="calibre17">std::future_status::ready</kbd> if the asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready, <kbd class="calibre17">std::future_status::timeout</kbd> if <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note36">Note</h5>
      
      
      <p class="noindclose">There’s no guarantee as to how long the calling thread will be blocked, only that if the function returns <kbd class="calibre17">std::future_status::timeout</kbd>, then <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec163"><a id="app04lev3sec163__title" class="calibre4"></a>std::shared_future::get member function
      </h5>
      
      <p class="noind">If the associated state contains a deferred function from a call to <kbd class="calibre17">std::async</kbd>, invokes that function and return the result. Otherwise, waits until the asynchronous result associated with an instance
         of <kbd class="calibre17">std::shared_future</kbd> is ready, and then returns the stored value or throws the stored exception.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1407" class="calibre4"></a><a id="iddle2204" class="calibre4"></a><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void shared_future&lt;void&gt;::get() const;
R&amp; shared_future&lt;R&amp;&gt;::get() const;
R const&amp; shared_future&lt;R&gt;::get() const;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;valid()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls to <kbd class="calibre17">get()</kbd> and <kbd class="calibre17">wait()</kbd> from multiple threads on <kbd class="calibre17">std::shared_future</kbd> instances that share the same associated state are serialized. If the associated state contains a deferred function, the
            first call to <kbd class="calibre17">get()</kbd> or <kbd class="calibre17">wait()</kbd> invokes the deferred function and stores the returned value or thrown exception as the asynchronous result.
            Blocks until the asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready. If the asynchronous result is a stored exception, throws that exception. Otherwise, returns the stored value.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            If <kbd class="calibre17">ResultType</kbd> is <kbd class="calibre17">void</kbd>, returns normally. If <kbd class="calibre17">ResultType</kbd> is <kbd class="calibre17">R&amp;</kbd> for some type <kbd class="calibre17">R</kbd>, returns the stored reference. Otherwise, returns a <kbd class="calibre17">const</kbd> reference to the stored value.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            The stored exception, if any.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec20" class="calibre23">D.4.3. <a id="app04lev2sec20__title" class="calibre4"></a>std::packaged_task class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::packaged_task</kbd> class template packages a function or other callable object so that when the function is invoked through the <kbd class="calibre17">std::packaged_task</kbd> instance, the result is stored as an asynchronous result for retrieval through an instance of <kbd class="calibre17">std::future</kbd>.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::packaged_task</kbd> are <kbd class="calibre17">MoveConstructible</kbd> and <kbd class="calibre17">MoveAssignable</kbd> but not <kbd class="calibre17">CopyConstructible</kbd> or <kbd class="calibre17">CopyAssignable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename FunctionType&gt;
class packaged_task; // undefined

template&lt;typename ResultType,typename... ArgTypes&gt;
class packaged_task&lt;ResultType(ArgTypes...)&gt;
{
public:

    packaged_task() noexcept;
    packaged_task(packaged_task&amp;&amp;) noexcept;
    ~packaged_task();

    packaged_task&amp; operator=(packaged_task&amp;&amp;) noexcept;

    packaged_task(packaged_task const&amp;) = delete;
    packaged_task&amp; operator=(packaged_task const&amp;) = delete;

    void swap(packaged_task&amp;) noexcept;

    template&lt;typename Callable&gt;
    explicit packaged_task(Callable&amp;&amp; func);

    template&lt;typename Callable,typename Allocator&gt;
    packaged_task(std::allocator_arg_t, const Allocator&amp;,Callable&amp;&amp;);

    bool valid() const noexcept;
    std::future&lt;ResultType&gt; get_future();
    void operator()(ArgTypes...);
    void make_ready_at_thread_exit(ArgTypes...);
    void reset();
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec164"><a id="app04lev3sec164__title" class="calibre4"></a>std::packaged_task default constructor
      </h5>
      
      <p class="noind"><a id="iddle1017" class="calibre4"></a><a id="iddle1097" class="calibre4"></a><a id="iddle1704" class="calibre4"></a><a id="iddle2205" class="calibre4"></a><a id="iddle2206" class="calibre4"></a><a id="iddle2207" class="calibre4"></a>Constructs an <kbd class="calibre17">std::packaged_task</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">packaged_task() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::packaged_task</kbd> instance with no associated task or asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec165"><a id="app04lev3sec165__title" class="calibre4"></a>std::packaged_task construction from a callable object
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::packaged_task</kbd> object with an associated task and asynchronous result.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Callable&gt;
packaged_task(Callable&amp;&amp; func);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">func(args...)</kbd> shall be valid, where each element <kbd class="calibre17">args</kbd>-<kbd class="calibre17">i</kbd> in <kbd class="calibre17">args...</kbd> shall be a value of the corresponding type <kbd class="calibre17">ArgTypes</kbd>-<kbd class="calibre17">i</kbd> in <kbd class="calibre17">ArgTypes...</kbd>. The return value shall be convertible to <kbd class="calibre17">ResultType</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::packaged_task</kbd> instance with an associated asynchronous result of type <kbd class="calibre17">ResultType</kbd> that isn’t ready and an associated task of type <kbd class="calibre17">Callable</kbd> that’s a copy of <kbd class="calibre17">func</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::bad_alloc</kbd> if the constructor is unable to allocate memory for the asynchronous result. Any exception thrown by the copy or move constructor
            of <kbd class="calibre17">Callable</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec166"><a id="app04lev3sec166__title" class="calibre4"></a>std::packaged_task construction from a callable object with an allocator
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::packaged_task</kbd> object with an associated task and asynchronous result, using the supplied allocator to allocate memory for the associated
         asynchronous result and task.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2209" class="calibre4"></a><a id="iddle2210" class="calibre4"></a><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Allocator,typename Callable&gt;
packaged_task(
    std::allocator_arg_t, Allocator const&amp; alloc,Callable&amp;&amp; func);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">func(args...)</kbd> shall be valid, where each element <kbd class="calibre17">args</kbd>-<kbd class="calibre17">i</kbd> in <kbd class="calibre17">args...</kbd> shall be a value of the corresponding type <kbd class="calibre17">ArgTypes</kbd>-<kbd class="calibre17">i</kbd> in <kbd class="calibre17">ArgTypes...</kbd>. The return value shall be convertible to <kbd class="calibre17">ResultType</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::packaged_task</kbd> instance with an associated asynchronous result of type <kbd class="calibre17">ResultType</kbd> that isn’t ready and an associated task of type <kbd class="calibre17">Callable</kbd> that’s a copy of <kbd class="calibre17">func</kbd>. The memory for the asynchronous result and task is allocated through the allocator <kbd class="calibre17">alloc</kbd> or a copy thereof.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exception thrown by the allocator when trying to allocate memory for the asynchronous result or task. Any exception thrown
            by the copy or move constructor of <kbd class="calibre17">Callable</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec167"><a id="app04lev3sec167__title" class="calibre4"></a>std::packaged_task move constructor
      </h5>
      
      <p class="noind">Constructs one <kbd class="calibre17">std::packaged_task</kbd> object from another, transferring ownership of the asynchronous result and task associated with the other <kbd class="calibre17">std::packaged_task</kbd> object to the newly constructed instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">packaged_task(packaged_task&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::packaged_task</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result and task associated with <kbd class="calibre17">other</kbd> prior to the invocation of the constructor is associated with the newly constructed <kbd class="calibre17">std::packaged_task</kbd> object. <kbd class="calibre17">other</kbd> has no associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec168"><a id="app04lev3sec168__title" class="calibre4"></a>std::packaged_task move-assignment operator
      </h5>
      
      <p class="noind">Transfers ownership of the asynchronous result associated with one <kbd class="calibre17">std::packaged_task</kbd> object to another.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">packaged_task&amp; operator=(packaged_task&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Transfers ownership of the asynchronous result and task associated with <kbd class="calibre17">other</kbd> to <kbd class="calibre17">*this</kbd>, and discards any prior asynchronous result, as-if <kbd class="calibre17">std::packaged_task(other).swap(*this)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2208" class="calibre4"></a><a id="iddle2214" class="calibre4"></a><a id="iddle2218" class="calibre4"></a><i class="calibre6">Postconditions</i>
            The asynchronous result and task associated with <kbd class="calibre17">other</kbd> prior to the invocation of the move-assignment operator is associated with <kbd class="calibre17">*this</kbd>. <kbd class="calibre17">other</kbd> has no associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec169"><a id="app04lev3sec169__title" class="calibre4"></a>std::packaged_task::swap member function
      </h5>
      
      <p class="noind">Exchanges ownership of the asynchronous results associated with two <kbd class="calibre17">std::packaged_task</kbd> objects.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void swap(packaged_task&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Exchanges ownership of the asynchronous results and tasks associated with <kbd class="calibre17">other</kbd> and <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result and task associated with <kbd class="calibre17">other</kbd> prior to the invocation of <kbd class="calibre17">swap</kbd> (if any) is associated with <kbd class="calibre17">*this</kbd>. The asynchronous result and task associated with <kbd class="calibre17">*this</kbd> prior to the invocation of <kbd class="calibre17">swap</kbd> (if any) is associated with <kbd class="calibre17">other</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec170"><a id="app04lev3sec170__title" class="calibre4"></a>std::packaged_task destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::packaged_task</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~packaged_task();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>. If <kbd class="calibre17">*this</kbd> has an associated asynchronous result, and that result doesn’t have a stored task or exception, then that result becomes
            ready with an <kbd class="calibre17">std::future_error</kbd> exception with an error code of <kbd class="calibre17">std::future_errc::broken_promise</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec171"><a id="app04lev3sec171__title" class="calibre4"></a>std::packaged_task::get_future member function
      </h5>
      
      <p class="noind">Retrieves an <kbd class="calibre17">std::future</kbd> instance for the asynchronous result associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::future&lt;ResultType&gt; get_future();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2216" class="calibre4"></a><a id="iddle2217" class="calibre4"></a><a id="iddle2219" class="calibre4"></a><i class="calibre6">Returns</i>
            An <kbd class="calibre17">std::future</kbd> instance for the asynchronous result associated with <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc::future_already_retrieved</kbd> if a <kbd class="calibre17">std::future</kbd> has already been obtained for this asynchronous result through a prior call to <kbd class="calibre17">get_future()</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec172"><a id="app04lev3sec172__title" class="calibre4"></a>std::packaged_task::reset member function
      </h5>
      
      <p class="noind">Associates an <kbd class="calibre17">std::packaged_task</kbd> instance with a new asynchronous result for the same task.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void reset();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated asynchronous task.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            As-if <kbd class="calibre17">*this=packaged_task(std::move(f))</kbd>, where <kbd class="calibre17">f</kbd> is the stored task associated with <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::bad_alloc</kbd> if memory couldn’t be allocated for the new asynchronous result.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec173"><a id="app04lev3sec173__title" class="calibre4"></a>std::packaged_task::valid member function
      </h5>
      
      <p class="noind">Checks whether <kbd class="calibre17">*this</kbd> has an associated task and asynchronous result.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool valid() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if <kbd class="calibre17">*this</kbd> has an associated task and asynchronous result, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec174"><a id="app04lev3sec174__title" class="calibre4"></a>std::packaged_task::operator() function call operator
      </h5>
      
      <p class="noind">Invokes the task associated with an <kbd class="calibre17">std::packaged_task</kbd> instance, and stores the return value or exception in the associated asynchronous result.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void operator()(ArgTypes... args);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated task.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Invokes the associated task <kbd class="calibre17">func</kbd> as-if <kbd class="calibre17">INVOKE(func,args...)</kbd>. If the invocation returns normally, stores the return value in the asynchronous result associated with <kbd class="calibre17">*this</kbd>. If the invocation returns with an exception, stores the exception in the asynchronous result associated with <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2215" class="calibre4"></a><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready with a stored value or exception. Any threads blocked waiting for the asynchronous result are unblocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc:: promise_already_satisfied</kbd> if the asynchronous result already has a stored value or exception.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            A successful call to the function call operator synchronizes-with a call to <kbd class="calibre17">std:: future&lt;ResultType&gt;::get()</kbd> or <kbd class="calibre17">std::shared_future&lt;ResultType&gt;::get()</kbd>, which retrieves the value or exception stored.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec175"><a id="app04lev3sec175__title" class="calibre4"></a>std::packaged_task::make_ready_at_thread_exit member function
      </h5>
      
      <p class="noind">Invokes the task associated with an <kbd class="calibre17">std::packaged_task</kbd> instance, and stores the return value or exception in the associated asynchronous result without making the associated asynchronous
         result ready until thread exit.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void make_ready_at_thread_exit(ArgTypes... args);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated task.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Invokes the associated task <kbd class="calibre17">func</kbd> as-if <kbd class="calibre17">INVOKE(func,args...)</kbd>. If the invocation returns normally, stores the return value in the asynchronous result associated with <kbd class="calibre17">*this</kbd>. If the invocation returns with an exception, stores the exception in the asynchronous result associated with <kbd class="calibre17">*this</kbd>. Schedules the associated asynchronous state to be made ready when the current thread exits.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">*this</kbd> has a stored value or exception but isn’t ready until the current thread exits. Threads blocked waiting for the asynchronous
            result will be unblocked when the current thread exits.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc::promise_already_satisfied</kbd> if the asynchronous result already has a stored value or exception. An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc::no_state</kbd> if <kbd class="calibre17">*this</kbd> has no associated asynchronous state.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            The completion of the thread that made a successful call to <kbd class="calibre17">make_ready_at_thread_exit()</kbd> synchronizes-with a call to <kbd class="calibre17">std::future&lt;ResultType&gt;::get()</kbd> or <kbd class="calibre17">std::shared_future&lt;ResultType&gt;::get()</kbd>, which retrieves the value or exception stored.
         </li>
         
      </ul>
      
      
      
      
      
      <h4 id="app04lev2sec21" class="calibre23">D.4.4. <a id="app04lev2sec21__title" class="calibre4"></a>std::promise class template
      </h4>
      
      <p class="noind"><a id="iddle1408" class="calibre4"></a><a id="iddle2223" class="calibre4"></a><a id="iddle2224" class="calibre4"></a><a id="iddle2225" class="calibre4"></a>The <kbd class="calibre17">std::promise</kbd> class template provides a means of setting an asynchronous result, which may be retrieved from another thread through an
         instance of <kbd class="calibre17">std::future</kbd>.
      </p>
      
      <p class="noind">The <kbd class="calibre17">ResultType</kbd> template parameter is the type of the value that can be stored in the asynchronous result.
      </p>
      
      <p class="noind">A <kbd class="calibre17">std::future</kbd> associated with the asynchronous result of a particular <kbd class="calibre17">std::promise</kbd> instance can be obtained by calling the <kbd class="calibre17">get_future()</kbd> member function. The asynchronous result is set either to a value of type <kbd class="calibre17">ResultType</kbd> with the <kbd class="calibre17">set_value()</kbd> member function or to an exception with the <kbd class="calibre17">set_exception()</kbd> member function.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::promise</kbd> are <kbd class="calibre17">MoveConstructible</kbd> and <kbd class="calibre17">MoveAssignable</kbd> but not <kbd class="calibre17">CopyConstructible</kbd> or <kbd class="calibre17">CopyAssignable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename ResultType&gt;
class promise
{
public:
    promise();
    promise(promise&amp;&amp;) noexcept;
    ~promise();
    promise&amp; operator=(promise&amp;&amp;) noexcept;

    template&lt;typename Allocator&gt;
    promise(std::allocator_arg_t, Allocator const&amp;);

    promise(promise const&amp;) = delete;
    promise&amp; operator=(promise const&amp;) = delete;

    void swap(promise&amp; ) noexcept;

    std::future&lt;ResultType&gt; get_future();

    void set_value(<i class="calibre6">see description</i>);
    void set_exception(std::exception_ptr p);
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec176"><a id="app04lev3sec176__title" class="calibre4"></a>std::promise default constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::promise</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">promise();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::promise</kbd> instance with an associated asynchronous result of type <kbd class="calibre17">ResultType</kbd> that’s not ready.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::bad_alloc</kbd> if the constructor is unable to allocate memory for the asynchronous result.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec177"><a id="app04lev3sec177__title" class="calibre4"></a>std::promise allocator constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::promise</kbd> object, using the supplied allocator to allocate memory for the associated asynchronous result.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2227" class="calibre4"></a><a id="iddle2228" class="calibre4"></a><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Allocator&gt;
promise(std::allocator_arg_t, Allocator const&amp; alloc);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::promise</kbd> instance with an associated asynchronous result of type <kbd class="calibre17">ResultType</kbd> that isn’t ready. The memory for the asynchronous result is allocated through the allocator <kbd class="calibre17">alloc</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exception thrown by the allocator when attempting to allocate memory for the asynchronous result.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec178"><a id="app04lev3sec178__title" class="calibre4"></a>std::promise move constructor
      </h5>
      
      <p class="noind">Constructs one <kbd class="calibre17">std::promise</kbd> object from another, transferring ownership of the asynchronous result associated with the other <kbd class="calibre17">std::promise</kbd> object to the newly constructed instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">promise(promise&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::promise</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">other</kbd> prior to the invocation of the constructor is associated with the newly constructed <kbd class="calibre17">std::promise</kbd> object. <kbd class="calibre17">other</kbd> has no associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec179"><a id="app04lev3sec179__title" class="calibre4"></a>std::promise move-assignment operator
      </h5>
      
      <p class="noind">Transfers ownership of the asynchronous result associated with one <kbd class="calibre17">std::promise</kbd> object to another.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">promise&amp; operator=(promise&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Transfers ownership of the asynchronous result associated with <kbd class="calibre17">other</kbd> to <kbd class="calibre17">*this</kbd>. If <kbd class="calibre17">*this</kbd> already had an associated asynchronous result, that asynchronous result is made ready with an exception of type <kbd class="calibre17">std::future_error</kbd> and an error code of <kbd class="calibre17">std::future_errc::broken_promise</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">other</kbd> prior to the invocation of the move-assignment operator is associated with <kbd class="calibre17">*this</kbd>. <kbd class="calibre17">other</kbd> has no associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">*this</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2226" class="calibre4"></a><a id="iddle2229" class="calibre4"></a><a id="iddle2234" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec180"><a id="app04lev3sec180__title" class="calibre4"></a>std::promise::swap member function
      </h5>
      
      <p class="noind">Exchanges ownership of the asynchronous results associated with two <kbd class="calibre17">std::promise</kbd> objects.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void swap(promise&amp; other);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Exchanges ownership of the asynchronous results associated with <kbd class="calibre17">other</kbd> and <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">other</kbd> prior to the invocation of <kbd class="calibre17">swap</kbd> (if any) is associated with <kbd class="calibre17">*this</kbd>. The asynchronous result associated with <kbd class="calibre17">*this</kbd> prior to the invocation of <kbd class="calibre17">swap</kbd> (if any) is associated with <kbd class="calibre17">other</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec181"><a id="app04lev3sec181__title" class="calibre4"></a>std::promise destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::promise</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~promise();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>. If <kbd class="calibre17">*this</kbd> has an associated asynchronous result, and that result doesn’t have a stored value or exception, that result becomes ready
            with an <kbd class="calibre17">std::future_error</kbd> exception with an error code of <kbd class="calibre17">std::future_errc::broken_promise</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec182"><a id="app04lev3sec182__title" class="calibre4"></a>std::promise::get_future member function
      </h5>
      
      <p class="noind">Retrieves an <kbd class="calibre17">std::future</kbd> instance for the asynchronous result associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::future&lt;ResultType&gt; get_future();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            An <kbd class="calibre17">std::future</kbd> instance for the asynchronous result associated with <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc::future_already_retrieved</kbd> if a <kbd class="calibre17">std::future</kbd> has already been obtained for this asynchronous result through a prior call to <kbd class="calibre17">get_future()</kbd>.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec183"><a id="app04lev3sec183__title" class="calibre4"></a>std::promise::set_value member function
      </h5>
      
      <p class="noind"><a id="iddle2232" class="calibre4"></a><a id="iddle2233" class="calibre4"></a>Stores a value in the asynchronous result associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void promise&lt;void&gt;::set_value();
void promise&lt;R&amp;&gt;::set_value(R&amp; r);
void promise&lt;R&gt;::set_value(R const&amp; r);
void promise&lt;R&gt;::set_value(R&amp;&amp; r);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Stores <kbd class="calibre17">r</kbd> in the asynchronous result associated with <kbd class="calibre17">*this</kbd> if <kbd class="calibre17">ResultType</kbd> isn’t <kbd class="calibre17">void</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready with a stored value. Any threads blocked waiting for the asynchronous result are unblocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc::promise_already_satisfied</kbd> if the asynchronous result already has a stored value or exception. Any exceptions thrown by the copy-constructor or move-constructor
            of <kbd class="calibre17">r</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Multiple concurrent calls to <kbd class="calibre17">set_value()</kbd>, <kbd class="calibre17">set_value_at_thread_exit()</kbd>, <kbd class="calibre17">set_exception()</kbd>, and <kbd class="calibre17">set_exception_at_thread_exit()</kbd> are serialized. A successful call to <kbd class="calibre17">set_value()</kbd> happens-before a call to <kbd class="calibre17">std::future&lt;ResultType&gt;::get()</kbd> or <kbd class="calibre17">std::shared_future&lt;ResultType&gt;::get()</kbd>, which retrieves the value stored.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec184"><a id="app04lev3sec184__title" class="calibre4"></a>std::promise::set_value_at_thread_exit member function
      </h5>
      
      <p class="noind">Stores a value in the asynchronous result associated with <kbd class="calibre17">*this</kbd> without making that result ready until the current thread exits.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void promise&lt;void&gt;::set_value_at_thread_exit();
void promise&lt;R&amp;&gt;::set_value_at_thread_exit(R&amp; r);
void promise&lt;R&gt;::set_value_at_thread_exit(R const&amp; r);
void promise&lt;R&gt;::set_value_at_thread_exit(R&amp;&amp; r);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated asynchronous result.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Stores <kbd class="calibre17">r</kbd> in the asynchronous result associated with <kbd class="calibre17">*this</kbd> if <kbd class="calibre17">ResultType</kbd> isn’t <kbd class="calibre17">void</kbd>. Marks the asynchronous result as having a stored value. Schedules the associated asynchronous result to be made ready when
            the current thread exits.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">*this</kbd> has a stored value but isn’t ready until the current thread exits. Threads blocked waiting for the asynchronous result will
            be unblocked when the current thread exits.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2230" class="calibre4"></a><a id="iddle2231" class="calibre4"></a><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc::promise_already_satisfied</kbd> if the asynchronous result already has a stored value or exception. Any exceptions thrown by the copy-constructor or move-constructor
            of <kbd class="calibre17">r</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Multiple concurrent calls to <kbd class="calibre17">set_value()</kbd>, <kbd class="calibre17">set_value_at_thread_exit()</kbd>, <kbd class="calibre17">set_exception()</kbd>, and <kbd class="calibre17">set_exception_at_thread_exit()</kbd> are serialized. The completion of the thread that made a successful call to <kbd class="calibre17">set_value_at_thread_exit()</kbd> happens-before a call to <kbd class="calibre17">std::future&lt;ResultType&gt;::get()</kbd> or <kbd class="calibre17">std::shared_future &lt;ResultType&gt;::get()</kbd>, which retrieves the stored exception.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec185"><a id="app04lev3sec185__title" class="calibre4"></a>std::promise::set_exception member function
      </h5>
      
      <p class="noind">Stores an exception in the asynchronous result associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void set_exception(std::exception_ptr e);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated asynchronous result. <kbd class="calibre17">(bool)e</kbd> is <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Stores <kbd class="calibre17">e</kbd> in the asynchronous result associated with <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">*this</kbd> is ready with a stored exception. Any threads blocked waiting for the asynchronous result are unblocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc::promise_already_satisfied</kbd> if the asynchronous result already has a stored value or exception.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Multiple concurrent calls to <kbd class="calibre17">set_value()</kbd> and <kbd class="calibre17">set_exception()</kbd> are serialized. A successful call to <kbd class="calibre17">set_exception()</kbd> happens-before a call to <kbd class="calibre17">std::future&lt;ResultType&gt;::get()</kbd> or <kbd class="calibre17">std::shared_future&lt;ResultType&gt;::get()</kbd>, which retrieves the stored exception.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec186"><a id="app04lev3sec186__title" class="calibre4"></a>std::promise::set_exception_at_thread_exit member function
      </h5>
      
      <p class="noind">Stores an exception in the asynchronous result associated with <kbd class="calibre17">*this</kbd> without making that result ready until the current thread exits.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void set_exception_at_thread_exit(std::exception_ptr e);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1405" class="calibre4"></a><a id="iddle1943" class="calibre4"></a><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> has an associated asynchronous result. <kbd class="calibre17">(bool)e</kbd> is <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Stores <kbd class="calibre17">e</kbd> in the asynchronous result associated with <kbd class="calibre17">*this</kbd>. Schedules the associated asynchronous result to be made <i class="calibre6">ready</i> when the current thread exits.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The asynchronous result associated with <kbd class="calibre17">*this</kbd> has a stored exception but isn’t ready until the current thread exits. Threads blocked waiting for the asynchronous result
            will be unblocked when the current thread exits.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::future_error</kbd> with an error code of <kbd class="calibre17">std::future_errc::promise_already_satisfied</kbd> if the asynchronous result already has a stored value or exception.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            Multiple concurrent calls to <kbd class="calibre17">set_value()</kbd>, <kbd class="calibre17">set_value_at_thread_exit()</kbd>, <kbd class="calibre17">set_exception()</kbd>, and <kbd class="calibre17">set_exception_at_thread_exit()</kbd> are serialized. The completion of the thread that made a successful call to <kbd class="calibre17">set_exception_at_thread_exit()</kbd> happens-before a call to <kbd class="calibre17">std::future&lt;ResultType&gt;::get()</kbd> or <kbd class="calibre17">std::shared_future&lt;ResultType&gt;::get()</kbd>, which retrieves the exception stored.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec22" class="calibre23">D.4.5. <a id="app04lev2sec22__title" class="calibre4"></a>std::async function template
      </h4>
      
      <p class="noind"><kbd class="calibre17">std::async</kbd> is a simple way of running self-contained asynchronous tasks to make use of the available hardware concurrency. A call to
         <kbd class="calibre17">std::async</kbd> returns a <kbd class="calibre17">std::future</kbd> that will contain the result of the task. Depending on the launch policy, the task is either run asynchronously on its own
         thread or synchronously on whichever thread calls the <kbd class="calibre17">wait()</kbd> or <kbd class="calibre17">get()</kbd> member functions on that future.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">enum class launch
{
    async,deferred
};

template&lt;typename Callable,typename ... Args&gt;
future&lt;result_of&lt;Callable(Args...)&gt;::type&gt;
async(Callable&amp;&amp; func,Args&amp;&amp; ... args);

template&lt;typename Callable,typename ... Args&gt;
future&lt;result_of&lt;Callable(Args...)&gt;::type&gt;
async(launch policy,Callable&amp;&amp; func,Args&amp;&amp; ... args);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">INVOKE(func,args)</kbd> is valid for the supplied values of <kbd class="calibre17">func</kbd> and <kbd class="calibre17">args</kbd>. <kbd class="calibre17">Callable</kbd> and every member of <kbd class="calibre17">Args</kbd> are <kbd class="calibre17">MoveConstructible</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs copies of <kbd class="calibre17">func</kbd> and <kbd class="calibre17">args...</kbd> in internal storage (denoted by <kbd class="calibre17">fff</kbd> and <kbd class="calibre17">xyz...</kbd>, respectively).
            If <kbd class="calibre17">policy</kbd> is <kbd class="calibre17">std::launch::async</kbd>, runs <kbd class="calibre17">INVOKE(fff,xyz...)</kbd> on its own thread. The returned <kbd class="calibre17">std::future</kbd> will become ready when this thread is complete and will hold either the return value or the exception thrown by the function
            invocation. The destructor of the last future object associated with the asynchronous state of the returned <kbd class="calibre17">std::future</kbd> blocks until the future is ready.
            <a id="iddle1092" class="calibre4"></a><a id="iddle1647" class="calibre4"></a>If <kbd class="calibre17">policy</kbd> is <kbd class="calibre17">std::launch::deferred</kbd>, <kbd class="calibre17">fff</kbd> and <kbd class="calibre17">xyz...</kbd> are stored in the returned <kbd class="calibre17">std::future</kbd> as a deferred function call. The first call to the <kbd class="calibre17">wait()</kbd> or <kbd class="calibre17">get()</kbd> member functions on a future that shares the same associated state will execute <kbd class="calibre17">INVOKE (fff,xyz...)</kbd> synchronously on the thread that called <kbd class="calibre17">wait()</kbd> or <kbd class="calibre17">get()</kbd>.
            The value returned or exception thrown by the execution of <kbd class="calibre17">INVOKE(fff, xyz...)</kbd> will be returned from a call to <kbd class="calibre17">get()</kbd> on that <kbd class="calibre17">std::future</kbd>.
            If <kbd class="calibre17">policy</kbd> is <kbd class="calibre17">std::launch::async | std::launch::deferred</kbd> or the <kbd class="calibre17">policy</kbd> argument is omitted, the behavior is as-if either <kbd class="calibre17">std::launch::async</kbd> or <kbd class="calibre17">std:: launch::deferred</kbd> had been specified. The implementation will choose the behavior on a call-by-call basis in order to take advantage of the
            available hardware concurrency without excessive oversubscription.
            In all cases, the <kbd class="calibre17">std::async</kbd> call returns immediately.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            The completion of the function invocation happens-before a successful return from a call to <kbd class="calibre17">wait()</kbd>, <kbd class="calibre17">get()</kbd>, <kbd class="calibre17">wait_for()</kbd>, or <kbd class="calibre17">wait_until()</kbd> on any <kbd class="calibre17">std::future</kbd> or <kbd class="calibre17">std::shared_future</kbd> instance that references the same associated state as the <kbd class="calibre17">std:: future</kbd> object returned from the <kbd class="calibre17">std::async</kbd> call. In the case of a <kbd class="calibre17">policy</kbd> of <kbd class="calibre17">std::launch::async</kbd>, the completion of the thread on which the function invocation occurs also happens-before the successful return from these
            calls.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::bad_alloc</kbd> if the required internal storage can’t be allocated, otherwise <kbd class="calibre17">std::future_error</kbd> when the effects can’t be achieved, or any exception thrown during the construction of <kbd class="calibre17">fff</kbd> or <kbd class="calibre17">xyz...</kbd>.
         </li>
         
      </ul>
      
      
      
      
      <h3 id="app04lev1sec5" class="chapter"><a id="app04lev1sec5__title" class="calibre3"></a>D.5. &lt;mutex&gt; header
      </h3>
      
      <p class="noind">The <kbd class="calibre17">&lt;mutex&gt;</kbd> header provides facilities for ensuring mutual exclusion: mutex types, lock types and functions, and a mechanism for ensuring
         an operation is performed exactly once.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Header contents</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">namespace std
{
    class mutex;
    class recursive_mutex;
    class timed_mutex;
    class recursive_timed_mutex;
    class shared_mutex;
    class shared_timed_mutex;

    struct adopt_lock_t;
    struct defer_lock_t;
    struct try_to_lock_t;

    constexpr adopt_lock_t adopt_lock{};
    constexpr defer_lock_t defer_lock{};
    constexpr try_to_lock_t try_to_lock{};

    template&lt;typename LockableType&gt;
    class lock_guard;

    template&lt;typename LockableType&gt;
    class unique_lock;

    template&lt;typename LockableType&gt;
    class shared_lock;

    template&lt;typename ... LockableTypes&gt;
    class scoped_lock;

    template&lt;typename LockableType1,typename... LockableType2&gt;
    void lock(LockableType1&amp; m1,LockableType2&amp; m2...);

    template&lt;typename LockableType1,typename... LockableType2&gt;
    int try_lock(LockableType1&amp; m1,LockableType2&amp; m2...);

    struct once_flag;

    template&lt;typename Callable,typename... Args&gt;
    void call_once(once_flag&amp; flag,Callable func,Args args...);
}</pre>
            </li>
         
      </ul>
      
      
      <h4 id="app04lev2sec23" class="calibre23">D.5.1. <a id="app04lev2sec23__title" class="calibre4"></a>std::mutex class
      </h4>
      
      <p class="noind"><a id="iddle1651" class="calibre4"></a><a id="iddle2194" class="calibre4"></a><a id="iddle2195" class="calibre4"></a>The <kbd class="calibre17">std::mutex</kbd> class provides a basic mutual exclusion and synchronization facility for threads that can be used to protect shared data.
         Prior to accessing the data protected by the mutex, the mutex must be <i class="calibre6">locked</i> by calling <kbd class="calibre17">lock()</kbd> or <kbd class="calibre17">try_lock()</kbd>. Only one thread may hold the lock at a time, so if another thread also tries to lock the mutex, it will fail (<kbd class="calibre17">try_lock()</kbd>) or block (<kbd class="calibre17">lock()</kbd>) as appropriate. Once a thread is done accessing the shared data, it then must call <kbd class="calibre17">unlock()</kbd> to release the lock and allow other threads to acquire it.
      </p>
      
      <p class="noind"><kbd class="calibre17">std::mutex</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class mutex
{
public:
    mutex(mutex const&amp;)=delete;
    mutex&amp; operator=(mutex const&amp;)=delete;

    constexpr mutex() noexcept;
    ~mutex();

    void lock();
    void unlock();
    bool try_lock();
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec187"><a id="app04lev3sec187__title" class="calibre4"></a>std::mutex default constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr mutex() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::mutex</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2196" class="calibre4"></a><a id="iddle2197" class="calibre4"></a><a id="iddle2198" class="calibre4"></a><i class="calibre6">Postconditions</i>
            The newly constructed <kbd class="calibre17">std::mutex</kbd> object is initially unlocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec188"><a id="app04lev3sec188__title" class="calibre4"></a>std::mutex destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~mutex();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> must not be locked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec189"><a id="app04lev3sec189__title" class="calibre4"></a>std::mutex::lock member function
      </h5>
      
      <p class="noind">Acquires a lock on an <kbd class="calibre17">std::mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until a lock on <kbd class="calibre17">*this</kbd> can be obtained.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec190"><a id="app04lev3sec190__title" class="calibre4"></a>std::mutex::try_lock member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on an <kbd class="calibre17">std::mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a lock on <kbd class="calibre17">*this</kbd> for the calling thread without blocking.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1653" class="calibre4"></a><a id="iddle2199" class="calibre4"></a><a id="iddle2247" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note37">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec191"><a id="app04lev3sec191__title" class="calibre4"></a>std::mutex::unlock member function
      </h5>
      
      <p class="noind">Releases a lock on an <kbd class="calibre17">std::mutex</kbd> object held by the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Releases the lock on <kbd class="calibre17">*this</kbd> held by the current thread. If any threads are blocked waiting to acquire a lock on <kbd class="calibre17">*this</kbd>, unblocks one of them.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is not locked by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec24" class="calibre23">D.5.2. <a id="app04lev2sec24__title" class="calibre4"></a>std::recursive_mutex class
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::recursive_mutex</kbd> class provides a basic mutual exclusion and synchronization facility for threads that can be used to protect shared data.
         Prior to accessing the data protected by the mutex, the mutex must be locked by calling <kbd class="calibre17">lock()</kbd> or <kbd class="calibre17">try_lock()</kbd>. Only one thread may hold the lock at a time, so if another thread also tries to lock the <kbd class="calibre17">recursive_mutex</kbd>, it will fail (<kbd class="calibre17">try_lock</kbd>) or block (<kbd class="calibre17">lock</kbd>) as appropriate. Once a thread is done accessing the shared data, it then must call <kbd class="calibre17">unlock()</kbd> to release the lock and allow other threads to acquire it.
      </p>
      
      <p class="noind">This mutex is <i class="calibre6">recursive</i> so a thread that holds a lock on a particular <kbd class="calibre17">std::recursive_mutex</kbd> instance may make further calls to <kbd class="calibre17">lock()</kbd> or <kbd class="calibre17">try_lock()</kbd> to increase the lock count. The mutex can’t be locked by another thread until the thread that acquired the locks has called
         <kbd class="calibre17">unlock</kbd> once for each successful call to <kbd class="calibre17">lock()</kbd> or <kbd class="calibre17">try_lock()</kbd>.
      </p>
      
      <p class="noind"><kbd class="calibre17">std::recursive_mutex</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class recursive_mutex
{
public:
    recursive_mutex(recursive_mutex const&amp;)=delete;
    recursive_mutex&amp; operator=(recursive_mutex const&amp;)=delete;

    recursive_mutex() noexcept;
    ~recursive_mutex();

    void lock();
    void unlock();
    bool try_lock() noexcept;
};</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec192"><a id="app04lev3sec192__title" class="calibre4"></a>std::recursive_mutex default constructor
      </h5>
      
      <p class="noind"><a id="iddle2248" class="calibre4"></a><a id="iddle2249" class="calibre4"></a><a id="iddle2252" class="calibre4"></a><a id="iddle2253" class="calibre4"></a>Constructs an <kbd class="calibre17">std::recursive_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">recursive_mutex() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::recursive_mutex</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The newly constructed <kbd class="calibre17">std::recursive_mutex</kbd> object is initially unlocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if unable to create a new <kbd class="calibre17">std::recursive_mutex</kbd> instance.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec193"><a id="app04lev3sec193__title" class="calibre4"></a>std::recursive_mutex destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::recursive_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~recursive_mutex();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> must not be locked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec194"><a id="app04lev3sec194__title" class="calibre4"></a>std::recursive_mutex::lock member function
      </h5>
      
      <p class="noind">Acquires a lock on an <kbd class="calibre17">std::recursive_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until a lock on <kbd class="calibre17">*this</kbd> can be obtained.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread. If the calling thread already held a lock on <kbd class="calibre17">*this</kbd>, the lock count is increased by one.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec195"><a id="app04lev3sec195__title" class="calibre4"></a>std::recursive_mutex::try_lock member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on an <kbd class="calibre17">std::recursive_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a lock on <kbd class="calibre17">*this</kbd> for the calling thread without blocking.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1659" class="calibre4"></a><a id="iddle2254" class="calibre4"></a><a id="iddle2375" class="calibre4"></a><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            A new lock on <kbd class="calibre17">*this</kbd> has been obtained for the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note38">Note</h5>
      
      
      <p class="noindclose">If the calling thread already holds the lock on <kbd class="calibre17">*this</kbd>, the function returns <kbd class="calibre17">true</kbd> and the count of locks on <kbd class="calibre17">*this</kbd> held by the calling thread is increased by one. If the current thread doesn’t already hold a lock on <kbd class="calibre17">*this</kbd>, the function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec196"><a id="app04lev3sec196__title" class="calibre4"></a>std::recursive_mutex::unlock member function
      </h5>
      
      <p class="noind">Releases a lock on an <kbd class="calibre17">std::recursive_mutex</kbd> object held by the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Releases a lock on <kbd class="calibre17">*this</kbd> held by the current thread. If this is the last lock on <kbd class="calibre17">*this</kbd> held by the calling thread, any threads are blocked waiting to acquire a lock on <kbd class="calibre17">*this</kbd>. Unblocks one of them.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The number of locks on <kbd class="calibre17">*this</kbd> held by the calling thread is reduced by one.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec25" class="calibre23">D.5.3. <a id="app04lev2sec25__title" class="calibre4"></a>std::timed_mutex class
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::timed_mutex</kbd> class provides support for locks with timeouts on top of the basic mutual exclusion and synchronization facility provided
         by <kbd class="calibre17">std::mutex</kbd>. Prior to accessing the data protected by the mutex, the mutex must be locked by calling <kbd class="calibre17">lock()</kbd>, <kbd class="calibre17">try_lock()</kbd>, <kbd class="calibre17">try_lock_for()</kbd>, or <kbd class="calibre17">try_lock_until()</kbd>. If a lock is already held by another thread, an attempt to acquire the lock will fail (<kbd class="calibre17">try_lock()</kbd>), block until the lock can be acquired (<kbd class="calibre17">lock()</kbd>), or block until the lock can be acquired or the lock attempt times out (<kbd class="calibre17">try_lock_for()</kbd> or <kbd class="calibre17">try_lock_until()</kbd>). Once a lock has been acquired (whichever function was used to acquire it), it must be released, by calling <kbd class="calibre17">unlock()</kbd>, before another thread can acquire the lock on the mutex.
      </p>
      
      <p class="noind"><kbd class="calibre17">std::timed_mutex</kbd> meets the <kbd class="calibre17">TimedLockable</kbd> requirements.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class timed_mutex
{
public:
    timed_mutex(timed_mutex const&amp;)=delete;
    timed_mutex&amp; operator=(timed_mutex const&amp;)=delete;

    timed_mutex();
    ~timed_mutex();

    void lock();
    void unlock();
    bool try_lock();

    template&lt;typename Rep,typename Period&gt;
    bool try_lock_for(
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);

    template&lt;typename Clock,typename Duration&gt;
    bool try_lock_until(
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec197"><a id="app04lev3sec197__title" class="calibre4"></a>std::timed_mutex default constructor
      </h5>
      
      <p class="noind"><a id="iddle2376" class="calibre4"></a><a id="iddle2377" class="calibre4"></a><a id="iddle2378" class="calibre4"></a>Constructs an <kbd class="calibre17">std::timed_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">timed_mutex();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::timed_mutex</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The newly constructed <kbd class="calibre17">std::timed_mutex</kbd> object is initially unlocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if unable to create a new <kbd class="calibre17">std::timed_mutex</kbd> instance.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec198"><a id="app04lev3sec198__title" class="calibre4"></a>std::timed_mutex destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::timed_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~timed_mutex();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> must not be locked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec199"><a id="app04lev3sec199__title" class="calibre4"></a>std::timed_mutex::lock member function
      </h5>
      
      <p class="noind">Acquires a lock on an <kbd class="calibre17">std::timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2379" class="calibre4"></a><a id="iddle2380" class="calibre4"></a><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until a lock on <kbd class="calibre17">*this</kbd> can be obtained.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec200"><a id="app04lev3sec200__title" class="calibre4"></a>std::timed_mutex::try_lock member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on an <kbd class="calibre17">std::timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a lock on <kbd class="calibre17">*this</kbd> for the calling thread without blocking.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note39">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec201"><a id="app04lev3sec201__title" class="calibre4"></a>std::timed_mutex::try_lock_for member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on an <kbd class="calibre17">std::timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
bool try_lock_for(
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a lock on <kbd class="calibre17">*this</kbd> for the calling thread within the time specified by <kbd class="calibre17">relative_time</kbd>. If <kbd class="calibre17">relative_time.count()</kbd> is zero or negative, the call will return immediately, as if it was a call to <kbd class="calibre17">try_lock()</kbd>. Otherwise, the call blocks until either the lock has been acquired or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2381" class="calibre4"></a><a id="iddle2382" class="calibre4"></a><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note40">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>. The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined by a steady
         clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec202"><a id="app04lev3sec202__title" class="calibre4"></a>std::timed_mutex::try_lock_until member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on an <kbd class="calibre17">std::timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
bool try_lock_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a lock on <kbd class="calibre17">*this</kbd> for the calling thread before the time specified by <kbd class="calibre17">absolute_time</kbd>. If <kbd class="calibre17">absolute_time&lt;=Clock::now()</kbd> on entry, the call will return immediately, as if it was a call to <kbd class="calibre17">try_lock()</kbd>. Otherwise, the call blocks until either the lock has been acquired or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note41">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>. There’s no guarantee as to how long the calling thread will be blocked, only that if the function returns <kbd class="calibre17">false</kbd>, then <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec203"><a id="app04lev3sec203__title" class="calibre4"></a>std::timed_mutex::unlock member function
      </h5>
      
      <p class="noind">Releases a lock on an <kbd class="calibre17">std::timed_mutex</kbd> object held by the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1654" class="calibre4"></a><a id="iddle2255" class="calibre4"></a><i class="calibre6">Effects</i>
            Releases the lock on <kbd class="calibre17">*this</kbd> held by the current thread. If any threads are blocked waiting to acquire a lock on <kbd class="calibre17">*this</kbd>, unblocks one of them.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is not locked by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec26" class="calibre23">D.5.4. <a id="app04lev2sec26__title" class="calibre4"></a>std::recursive_timed_mutex class
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::recursive_timed_mutex</kbd> class provides support for locks with timeouts on top of the mutual exclusion and synchronization facility provided by <kbd class="calibre17">std::recursive_mutex</kbd>. Prior to accessing the data protected by the mutex, the mutex must be <i class="calibre6">locked</i> by calling <kbd class="calibre17">lock()</kbd>, <kbd class="calibre17">try_lock()</kbd>, <kbd class="calibre17">try_lock_for()</kbd>, or <kbd class="calibre17">try_lock_until()</kbd>. If a lock is already held by another thread, an attempt to acquire the lock will fail (<kbd class="calibre17">try_lock()</kbd>), block until the lock can be acquired (<kbd class="calibre17">lock()</kbd>), or block until the lock can be acquired or the lock attempt times out (<kbd class="calibre17">try_lock_for()</kbd> or <kbd class="calibre17">try_lock_until()</kbd>). Once a lock has been acquired (whichever function was used to acquire it), it must be released by calling <kbd class="calibre17">unlock()</kbd> before another thread can acquire the lock on the mutex.
      </p>
      
      <p class="noind">This mutex is recursive, so a thread that holds a lock on a particular instance of <kbd class="calibre17">std::recursive_timed_mutex</kbd> may acquire additional locks on that instance through any of the lock functions. All of these locks must be released by a
         corresponding call to <kbd class="calibre17">unlock()</kbd> before another thread can acquire a lock on that instance.
      </p>
      
      <p class="noind"><kbd class="calibre17">std::recursive_timed_mutex</kbd> meets the <kbd class="calibre17">TimedLockable</kbd> requirements.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class recursive_timed_mutex
{
public:
    recursive_timed_mutex(recursive_timed_mutex const&amp;)=delete;
    recursive_timed_mutex&amp; operator=(recursive_timed_mutex const&amp;)=delete;

    recursive_timed_mutex();
    ~recursive_timed_mutex();

    void lock();
    void unlock();
    bool try_lock() noexcept;

    template&lt;typename Rep,typename Period&gt;
    bool try_lock_for(
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);

    template&lt;typename Clock,typename Duration&gt;
    bool try_lock_until(
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);
};</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec204"><a id="app04lev3sec204__title" class="calibre4"></a>std::recursive_timed_mutex default constructor
      </h5>
      
      <p class="noind"><a id="iddle2256" class="calibre4"></a><a id="iddle2257" class="calibre4"></a><a id="iddle2260" class="calibre4"></a><a id="iddle2261" class="calibre4"></a>Constructs an <kbd class="calibre17">std::recursive_timed_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">recursive_timed_mutex();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::recursive_timed_mutex</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The newly constructed <kbd class="calibre17">std::recursive_timed_mutex</kbd> object is initially unlocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if unable to create a new <kbd class="calibre17">std::recursive_timed_mutex</kbd> instance.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec205"><a id="app04lev3sec205__title" class="calibre4"></a>std::recursive_timed_mutex destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::recursive_timed_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~recursive_timed_mutex();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> must not be locked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec206"><a id="app04lev3sec206__title" class="calibre4"></a>std::recursive_timed_mutex::lock member function
      </h5>
      
      <p class="noind">Acquires a lock on an <kbd class="calibre17">std::recursive_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until a lock on <kbd class="calibre17">*this</kbd> can be obtained.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread. If the calling thread already held a lock on <kbd class="calibre17">*this</kbd>, the lock count is increased by one.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec207"><a id="app04lev3sec207__title" class="calibre4"></a>std::recursive_timed_mutex::try_lock member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on an <kbd class="calibre17">std::recursive_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2262" class="calibre4"></a><i class="calibre6">Effects</i>
            Attempts to acquire a lock on <kbd class="calibre17">*this</kbd> for the calling thread without blocking.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note42">Note</h5>
      
      
      <p class="noindclose">If the calling thread already holds the lock on <kbd class="calibre17">*this</kbd>, the function returns <kbd class="calibre17">true</kbd> and the count of locks on <kbd class="calibre17">*this</kbd> held by the calling thread is increased by one. If the current thread doesn’t already hold a lock on <kbd class="calibre17">*this</kbd>, the function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec208"><a id="app04lev3sec208__title" class="calibre4"></a>std::recursive_timed_mutex::try_lock_for member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on an <kbd class="calibre17">std::recursive_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
bool try_lock_for(
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a lock on <kbd class="calibre17">*this</kbd> for the calling thread within the time specified by <kbd class="calibre17">relative_time</kbd>. If <kbd class="calibre17">relative_time.count()</kbd> is zero or negative, the call will return immediately, as if it was a call to <kbd class="calibre17">try_lock()</kbd>. Otherwise, the call blocks until either the lock has been acquired or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note43">Note</h5>
      
      
      <p class="noindclose">If the calling thread already holds the lock on <kbd class="calibre17">*this</kbd>, the function returns <kbd class="calibre17">true</kbd> and the count of locks on <kbd class="calibre17">*this</kbd> held by the calling thread is increased by one. If the current thread doesn’t already hold a lock on <kbd class="calibre17">*this</kbd>, the function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>. The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined by a steady
         clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec209"><a id="app04lev3sec209__title" class="calibre4"></a>std::recursive_timed_mutex::try_lock_until member function
      </h5>
      
      <p class="noind"><a id="iddle2263" class="calibre4"></a><a id="iddle2264" class="calibre4"></a>Attempts to acquire a lock on an <kbd class="calibre17">std::recursive_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
bool try_lock_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a lock on <kbd class="calibre17">*this</kbd> for the calling thread before the time specified by <kbd class="calibre17">absolute_time</kbd>. If <kbd class="calibre17">absolute_time&lt;=Clock::now()</kbd> on entry, the call will return immediately, as if it was a call to <kbd class="calibre17">try_lock()</kbd>. Otherwise, the call blocks until either the lock has been acquired or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note44">Note</h5>
      
      
      <p class="noindclose">If the calling thread already holds the lock on <kbd class="calibre17">*this</kbd>, the function returns <kbd class="calibre17">true</kbd> and the count of locks on <kbd class="calibre17">*this</kbd> held by the calling thread is increased by one. If the current thread doesn’t already hold a lock on <kbd class="calibre17">*this</kbd>, the function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>. There’s no guarantee as to how long the calling thread will be blocked, only that if the function returns <kbd class="calibre17">false</kbd>, then <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec210"><a id="app04lev3sec210__title" class="calibre4"></a>std::recursive_timed_mutex::unlock member function
      </h5>
      
      <p class="noind">Releases a lock on an <kbd class="calibre17">std::recursive_timed_mutex</kbd> object held by the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Releases a lock on <kbd class="calibre17">*this</kbd> held by the current thread. If this is the last lock on <kbd class="calibre17">*this</kbd> held by the calling thread, any threads are blocked waiting to acquire a lock on <kbd class="calibre17">*this</kbd>. Unblocks one of them.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The number of locks on <kbd class="calibre17">*this</kbd> held by the calling thread is reduced by one.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      
      <h4 id="app04lev2sec27" class="calibre23">D.5.5. <a id="app04lev2sec27__title" class="calibre4"></a>std::shared_mutex class
      </h4>
      
      <p class="noind"><a id="iddle1657" class="calibre4"></a><a id="iddle2307" class="calibre4"></a><a id="iddle2308" class="calibre4"></a>The <kbd class="calibre17">std::shared_mutex</kbd> class provides a mutual exclusion and synchronization facility for threads that can be used to protect shared data that is
         frequently read and rarely modified. It allows one thread to hold an exclusive lock, or one or more threads to hold a shared
         lock. Prior to modifying the data protected by the mutex, the mutex must be locked with an exclusive lock by calling <kbd class="calibre17">lock()</kbd> or <kbd class="calibre17">try_lock()</kbd>. Only one thread may hold an exclusive lock at a time, so if another thread also tries to lock the mutex, it will fail (<kbd class="calibre17">try_lock()</kbd>) or block (<kbd class="calibre17">lock()</kbd>) as appropriate. Once a thread is done modifying the shared data, it then must call <kbd class="calibre17">unlock()</kbd> to release the lock and allow other threads to acquire it. Threads that only want to read the protected data may obtain a
         shared lock by calling <kbd class="calibre17">lock_shared()</kbd> or <kbd class="calibre17">try_lock_shared()</kbd>. Multiple threads may hold a shared lock at a time, so if one thread holds a shared lock, then another thread may also acquire
         a shared lock. If a thread tries to acquire an exclusive lock, that thread will wait. Once a thread that has acquired a shared
         lock is done accessing the protected data, it must call <kbd class="calibre17">unlock_shared()</kbd> to release the shared lock.
      </p>
      
      <p class="noind"><kbd class="calibre17">std::shared_mutex</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class shared_mutex
{
public:
    shared_mutex(shared_mutex const&amp;)=delete;
    shared_mutex&amp; operator=(shared_mutex const&amp;)=delete;

    shared_mutex() noexcept;
    ~shared_mutex();

    void lock();
    void unlock();
    bool try_lock();

    void lock_shared();
    void unlock_shared();
    bool try_lock_shared();
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec211"><a id="app04lev3sec211__title" class="calibre4"></a>std::shared_mutex default constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::shared_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_mutex() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_mutex</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The newly constructed <kbd class="calibre17">std::shared_mutex</kbd> object is initially unlocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec212"><a id="app04lev3sec212__title" class="calibre4"></a>std::shared_mutex destructor
      </h5>
      
      <p class="noind"><a id="iddle2309" class="calibre4"></a><a id="iddle2314" class="calibre4"></a><a id="iddle2316" class="calibre4"></a>Destroys an <kbd class="calibre17">std::shared_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~shared_mutex();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> must not be locked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec213"><a id="app04lev3sec213__title" class="calibre4"></a>std::shared_mutex::lock member function
      </h5>
      
      <p class="noind">Acquires an exclusive lock on an <kbd class="calibre17">std::shared_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until an exclusive lock on <kbd class="calibre17">*this</kbd> can be obtained.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread with an exclusive lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception ofif an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec214"><a id="app04lev3sec214__title" class="calibre4"></a>std::shared_mutex::try_lock member function
      </h5>
      
      <p class="noind">Attempts to acquire an exclusive lock on an <kbd class="calibre17">std::shared_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire an exclusive lock on <kbd class="calibre17">*this</kbd> for the calling thread without blocking.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread with an exclusive lock if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2315" class="calibre4"></a><a id="iddle2317" class="calibre4"></a><a id="iddle2318" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note45">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec215"><a id="app04lev3sec215__title" class="calibre4"></a>std::shared_mutex::unlock member function
      </h5>
      
      <p class="noind">Releases an exclusive lock on an <kbd class="calibre17">std::shared_mutex</kbd> object held by the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must hold an exclusive lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Releases the exclusive lock on <kbd class="calibre17">*this</kbd> held by the current thread. If any threads are blocked waiting to acquire a lock on <kbd class="calibre17">*this</kbd>, unblocks one thread waiting for an exclusive lock or some number of threads waiting for a shared lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is not locked by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec216"><a id="app04lev3sec216__title" class="calibre4"></a>std::shared_mutex::lock_shared member function
      </h5>
      
      <p class="noind">Acquires a shared lock on an <kbd class="calibre17">std::shared_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock_shared();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until a shared lock on <kbd class="calibre17">*this</kbd> can be obtained.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread with a shared lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception ofif an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec217"><a id="app04lev3sec217__title" class="calibre4"></a>std::shared_mutex::try_lock_shared member function
      </h5>
      
      <p class="noind">Attempts to acquire a shared lock on an <kbd class="calibre17">std::shared_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock_shared();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1658" class="calibre4"></a><a id="iddle2319" class="calibre4"></a><a id="iddle2321" class="calibre4"></a><i class="calibre6">Effects</i>
            Attempts to acquire a shared lock on <kbd class="calibre17">*this</kbd> for the calling thread without blocking.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread with a shared lock if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note46">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec218"><a id="app04lev3sec218__title" class="calibre4"></a>std::shared_mutex::unlock_shared member function
      </h5>
      
      <p class="noind">Releases a shared lock on an <kbd class="calibre17">std::shared_mutex</kbd> object held by the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock_shared();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must hold a shared lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Releases the shared lock on <kbd class="calibre17">*this</kbd> held by the current thread. If this is the last shared lock on <kbd class="calibre17">*this</kbd>, and any threads are blocked waiting to acquire a lock on <kbd class="calibre17">*this</kbd>, unblocks one thread waiting for an exclusive lock or some number of threads waiting for a shared lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is not locked by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec28" class="calibre23">D.5.6. <a id="app04lev2sec28__title" class="calibre4"></a>std::shared_timed_mutex class
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::shared_timed_mutex</kbd> class provides a mutual exclusion and synchronization facility for threads that can be used to protect shared data that is
         frequently read and rarely modified. It allows one thread to hold an exclusive lock, or one or more threads to hold a shared
         lock. Prior to modifying the data protected by the mutex, the mutex must be locked with an exclusive lock by calling <kbd class="calibre17">lock()</kbd> or <kbd class="calibre17">try_lock()</kbd>. Only one thread may hold an exclusive lock at a time, so if another thread also tries to lock the mutex, it will fail (<kbd class="calibre17">try_lock()</kbd>) or block (<kbd class="calibre17">lock()</kbd>) as appropriate. Once a thread is done modifying the shared data, it then must call <kbd class="calibre17">unlock()</kbd> to release the lock and allow other threads to acquire it. Threads that only want to read the protected data may obtain a
         shared lock by calling <kbd class="calibre17">lock_shared()</kbd> or <kbd class="calibre17">try_lock_shared()</kbd>. Multiple threads may hold a shared lock at a time, so if one thread holds a shared lock, then another thread may also acquire
         a shared lock. If a thread tries to acquire an exclusive <a id="iddle2322" class="calibre4"></a>lock, that thread will wait. Once a thread that has acquired a shared lock is done accessing the protected data, it must call
         <kbd class="calibre17">unlock_shared()</kbd> to release the shared lock.
      </p>
      
      <p class="noind"><kbd class="calibre17">std::shared_timed_mutex</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class shared_timed_mutex
{
public:
    shared_timed_mutex(shared_timed_mutex const&amp;)=delete;
    shared_timed_mutex&amp; operator=(shared_timed_mutex const&amp;)=delete;

    shared_timed_mutex() noexcept;
    ~shared_timed_mutex();

    void lock();
    void unlock();
    bool try_lock();

    template&lt;typename Rep,typename Period&gt;
    bool try_lock_for(
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);

    template&lt;typename Clock,typename Duration&gt;
    bool try_lock_until(
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);

    void lock_shared();
    void unlock_shared();
    bool try_lock_shared();

    template&lt;typename Rep,typename Period&gt;
    bool try_lock_shared_for(
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);

    template&lt;typename Clock,typename Duration&gt;
    bool try_lock_shared_until(
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec219"><a id="app04lev3sec219__title" class="calibre4"></a>std::shared_timed_mutex default constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::shared_timed_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_timed_mutex() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_timed_mutex</kbd> instance.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The newly constructed <kbd class="calibre17">std::shared_timed_mutex</kbd> object is initially unlocked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec220"><a id="app04lev3sec220__title" class="calibre4"></a>std::shared_timed_mutex destructor
      </h5>
      
      <p class="noind"><a id="iddle2323" class="calibre4"></a><a id="iddle2325" class="calibre4"></a><a id="iddle2327" class="calibre4"></a>Destroys an <kbd class="calibre17">std::shared_timed_mutex</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~shared_timed_mutex();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">*this</kbd> must not be locked.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec221"><a id="app04lev3sec221__title" class="calibre4"></a>std::shared_timed_mutex::lock member function
      </h5>
      
      <p class="noind">Acquires an exclusive lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until an exclusive lock on <kbd class="calibre17">*this</kbd> can be obtained.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread with an exclusive lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec222"><a id="app04lev3sec222__title" class="calibre4"></a>std::shared_timed_mutex::try_lock member function
      </h5>
      
      <p class="noind">Attempts to acquire an exclusive lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire an exclusive lock on <kbd class="calibre17">*this</kbd> for the calling thread without blocking.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread with an exclusive lock if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note47">Note</h5>
      
      
      
      <p class="noindclose"><a id="iddle2328" class="calibre4"></a><a id="iddle2331" class="calibre4"></a>The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec223"><a id="app04lev3sec223__title" class="calibre4"></a>std::shared_timed_mutex::try_lock_for member function
      </h5>
      
      <p class="noind">Attempts to acquire an exclusive lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
bool try_lock_for(
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire an exclusive lock on <kbd class="calibre17">*this</kbd> for the calling thread within the time specified by <kbd class="calibre17">relative_time</kbd>. If <kbd class="calibre17">relative_time.count()</kbd> is zero or negative, the call will return immediately, as if it was a call to <kbd class="calibre17">try_lock()</kbd>. Otherwise, the call <a id="iddle2326" class="calibre4"></a><a id="iddle2333" class="calibre4"></a>blocks until either the lock has been acquired or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note48">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>. The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined by a steady
         clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec224"><a id="app04lev3sec224__title" class="calibre4"></a>std::shared_timed_mutex::try_lock_until member function
      </h5>
      
      <p class="noind">Attempts to acquire an exclusive lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
bool try_lock_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire an exclusive lock on <kbd class="calibre17">*this</kbd> for the calling thread before the time specified by <kbd class="calibre17">absolute_time</kbd>. If <kbd class="calibre17">absolute_time&lt;=Clock::now()</kbd> on entry, the call will return immediately, as if it was a call to <kbd class="calibre17">try_lock()</kbd>. Otherwise, the call blocks until either the lock has been acquired or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note49">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>. There’s no guarantee as to how long the calling thread will be blocked, only that if the function returns <kbd class="calibre17">false</kbd>, then <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec225"><a id="app04lev3sec225__title" class="calibre4"></a>std::shared_timed_mutex::unlock member function
      </h5>
      
      <p class="noind">Releases an exclusive lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object held by the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must hold an exclusive lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Releases the exclusive lock on <kbd class="calibre17">*this</kbd> held by the current thread. If any threads are blocked waiting to acquire a lock on <kbd class="calibre17">*this</kbd>, unblocks one thread waiting for an exclusive lock or some number of threads waiting for a shared lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is not locked by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec226"><a id="app04lev3sec226__title" class="calibre4"></a>std::shared_timed_mutex::lock_shared member function
      </h5>
      
      <p class="noind">Acquires a shared lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock_shared();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until a shared lock on <kbd class="calibre17">*this</kbd> can be obtained.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread with a shared lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if an error occurs.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec227"><a id="app04lev3sec227__title" class="calibre4"></a>std::shared_timed_mutex::try_lock_shared member function
      </h5>
      
      <p class="noind"><a id="iddle2329" class="calibre4"></a><a id="iddle2330" class="calibre4"></a>Attempts to acquire a shared lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock_shared();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a shared lock on <kbd class="calibre17">*this</kbd> for the calling thread without blocking.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread with a shared lock if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note50">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec228"><a id="app04lev3sec228__title" class="calibre4"></a>std::shared_timed_mutex::try_lock_shared_for member function
      </h5>
      
      <p class="noind">Attempts to acquire a shared lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
bool try_lock_for(
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a shared lock on <kbd class="calibre17">*this</kbd> for the calling thread within the time specified by <kbd class="calibre17">relative_time</kbd>. If <kbd class="calibre17">relative_time.count()</kbd> is zero or negative, the call will return immediately, as if it was a call to <kbd class="calibre17">try_lock()</kbd>. Otherwise, the call blocks until either the lock has been acquired or the time period specified by <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note51">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>. The thread may be blocked for longer <a id="iddle2332" class="calibre4"></a><a id="iddle2334" class="calibre4"></a>than the specified duration. Where possible, the elapsed time is determined by a steady clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec229"><a id="app04lev3sec229__title" class="calibre4"></a>std::shared_timed_mutex::try_lock_until member function
      </h5>
      
      <p class="noind">Attempts to acquire a shared lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object for the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
bool try_lock_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must not hold a lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Attempts to acquire a shared lock on <kbd class="calibre17">*this</kbd> for the calling thread before the time specified by <kbd class="calibre17">absolute_time</kbd>. If <kbd class="calibre17">absolute_time&lt;=Clock::now()</kbd> on entry, the call will return immediately, as if it was a call to <kbd class="calibre17">try_lock()</kbd>. Otherwise, the call blocks until either the lock has been acquired or <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if a lock was obtained for the calling thread, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is locked by the calling thread if the function returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note52">Note</h5>
      
      
      <p class="noindclose">The function may fail to acquire the lock (and return <kbd class="calibre17">false</kbd>) even if no other thread holds a lock on <kbd class="calibre17">*this</kbd>. There’s no guarantee as to how long the calling thread will be blocked, only that if the function returns <kbd class="calibre17">false</kbd>, then <kbd class="calibre17">Clock::now()</kbd> returns a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec230"><a id="app04lev3sec230__title" class="calibre4"></a>std::shared_timed_mutex::unlock_shared member function
      </h5>
      
      <p class="noind">Releases a shared lock on an <kbd class="calibre17">std::shared_timed_mutex</kbd> object held by the current thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock_shared();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must hold a shared lock on <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Releases the shared lock on <kbd class="calibre17">*this</kbd> held by the current thread. If this is the last shared lock on <kbd class="calibre17">*this</kbd>, and any threads are blocked waiting to acquire a lock on <kbd class="calibre17">*this</kbd>, unblocks one thread waiting for an exclusive lock or some number of threads waiting for a shared lock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1650" class="calibre4"></a><a id="iddle2174" class="calibre4"></a><a id="iddle2176" class="calibre4"></a><a id="iddle2177" class="calibre4"></a><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> is not locked by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec29" class="calibre23">D.5.7. <a id="app04lev2sec29__title" class="calibre4"></a>std::lock_guard class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::lock_guard</kbd> class template provides a basic lock ownership wrapper. The type of mutex being locked is specified by template parameter
         <kbd class="calibre17">Mutex</kbd> and must meet the <kbd class="calibre17">Lockable</kbd> requirements. The specified mutex is locked in the constructor and unlocked in the destructor. This provides a simple means
         of locking a mutex for a block of code and ensuring that the mutex is unlocked when the block is left, whether that’s by running
         off the end, by the use of a control flow statement such as <kbd class="calibre17">break</kbd> or <kbd class="calibre17">return</kbd>, or by throwing an exception.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::lock_guard</kbd> are not <kbd class="calibre17">MoveConstructible</kbd>, <kbd class="calibre17">CopyConstructible</kbd>, or <kbd class="calibre17">CopyAssignable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Mutex&gt;
class lock_guard
{
public:
    typedef Mutex mutex_type;

    explicit lock_guard(mutex_type&amp; m);
    lock_guard(mutex_type&amp; m, adopt_lock_t);
    ~lock_guard();

    lock_guard(lock_guard const&amp; ) = delete;
    lock_guard&amp; operator=(lock_guard const&amp; ) = delete;
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec231"><a id="app04lev3sec231__title" class="calibre4"></a>std::lock_guard locking constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::lock_guard</kbd> instance that locks the supplied mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">explicit lock_guard(mutex_type&amp; m);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::lock_guard</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.lock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">m.lock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> owns a lock on <kbd class="calibre17">m</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec232"><a id="app04lev3sec232__title" class="calibre4"></a>std::lock_guard lock-adopting constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::lock_guard</kbd> instance that owns the lock on the supplied mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">lock_guard(mutex_type&amp; m,std::adopt_lock_t);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1655" class="calibre4"></a><a id="iddle2175" class="calibre4"></a><a id="iddle2266" class="calibre4"></a><a id="iddle2269" class="calibre4"></a><i class="calibre6">Preconditions</i>
            The calling thread must own a lock on <kbd class="calibre17">m</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::lock_guard</kbd> instance that references the supplied mutex and takes ownership of the lock on <kbd class="calibre17">m</kbd> held by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> owns the lock on <kbd class="calibre17">m</kbd> held by the calling thread.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec233"><a id="app04lev3sec233__title" class="calibre4"></a>std::lock_guard destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::lock_guard</kbd> instance and unlocks the corresponding mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~lock_guard();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">m.unlock()</kbd> for the mutex instance, <kbd class="calibre17">m</kbd>, supplied when <kbd class="calibre17">*this</kbd> was constructed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec30" class="calibre23">D.5.8. <a id="app04lev2sec30__title" class="calibre4"></a>std::scoped_lock class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::scoped_lock</kbd> class template provides a basic lock ownership wrapper for multiple mutexes at once. The type of mutex being locked is specified
         by the template parameter pack <kbd class="calibre17">Mutexes</kbd> and each must meet the <kbd class="calibre17">Lockable</kbd> requirements. The specified mutexes are locked in the constructor and unlocked in the destructor. This provides a simple
         means of locking a set of mutexes for a block of code and ensuring that the mutexes are unlocked when the block is left, whether
         that’s by running off the end, by the use of a control flow statement such as <kbd class="calibre17">break</kbd> or <kbd class="calibre17">return</kbd>, or by throwing an exception.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::scoped_lock</kbd> are not <kbd class="calibre17">MoveConstructible</kbd>, <kbd class="calibre17">CopyConstructible</kbd>, or <kbd class="calibre17">CopyAssignable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class ... Mutexes&gt;
class scoped_lock
{
public:

    explicit scoped_lock(Mutexes&amp; ... m);
    scoped_lock(Mutexes&amp; ... m, adopt_lock_t);
    ~scoped_lock();

    scoped_lock(scoped_lock const&amp; ) = delete;
    scoped_lock&amp; operator=(scoped_lock const&amp; ) = delete;
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec234"><a id="app04lev3sec234__title" class="calibre4"></a>std::scoped_lock locking constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::scoped_lock</kbd> instance that locks the supplied mutexes.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1661" class="calibre4"></a><a id="iddle2267" class="calibre4"></a><a id="iddle2268" class="calibre4"></a><a id="iddle2384" class="calibre4"></a><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">explicit scoped_lock(Mutexes&amp; ... m);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::scoped_lock</kbd> instance that references the supplied mutexes. Uses a combination of calls to <kbd class="calibre17">m.lock()</kbd>, <kbd class="calibre17">m.try_lock()</kbd>, and <kbd class="calibre17">m.unlock()</kbd> on each of the mutexes, in order to avoid deadlock, using the same algorithm as the <kbd class="calibre17">std::lock()</kbd> free function.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by the <kbd class="calibre17">m.lock()</kbd> and <kbd class="calibre17">m.try_lock()</kbd> calls.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> owns a lock on the supplied mutexes.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec235"><a id="app04lev3sec235__title" class="calibre4"></a>std::scoped_lock lock-adopting constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::scoped_lock</kbd> instance that owns the lock on the supplied mutexes; they must already be locked by the calling thread.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">scoped_lock(Mutexes&amp; ... m,std::adopt_lock_t);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must own a lock on the mutexes in <kbd class="calibre17">m</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::scoped_lock</kbd> instance that references the supplied mutexes and takes ownership of the lock on the mutexes in <kbd class="calibre17">m</kbd> held by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">*this</kbd> owns the lock on the supplied mutexes held by the calling thread.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec236"><a id="app04lev3sec236__title" class="calibre4"></a>std::scoped_lock destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::scoped_lock</kbd> instance and unlocks the corresponding mutexes.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~scoped_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">m.unlock()</kbd> for each of the mutex instances <kbd class="calibre17">m</kbd> supplied when <kbd class="calibre17">*this</kbd> was constructed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec31" class="calibre23">D.5.9. <a id="app04lev2sec31__title" class="calibre4"></a>std::unique_lock class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::unique_lock</kbd> class template provides a more general lock ownership wrapper than <kbd class="calibre17">std::lock_guard</kbd>. The type of mutex being locked is specified by the template parameter <kbd class="calibre17">Mutex</kbd>, which must meet the <kbd class="calibre17">BasicLockable</kbd> requirements. In general, the specified mutex is locked in the constructor and unlocked in the destructor, although additional
         constructors and member functions are provided to allow other possibilities. This provides a means of locking a mutex for
         a block of code and ensuring that the mutex is unlocked when the block is left, whether that’s by running off the end, by
         the use of a control flow statement such as <kbd class="calibre17">break</kbd> or <kbd class="calibre17">return</kbd>, or by throwing an exception. The wait functions of <kbd class="calibre17">std::condition_variable</kbd> require an instance of <kbd class="calibre17">std:: unique_lock&lt;std::mutex&gt;</kbd>, and all instantiations of <kbd class="calibre17">std::unique_lock</kbd> are suitable for use with the <kbd class="calibre17">Lockable</kbd> parameter for the <kbd class="calibre17">std::condition_variable_any</kbd> wait functions.
      </p>
      
      <p class="noind">If the supplied <kbd class="calibre17">Mutex</kbd> type meets the <kbd class="calibre17">Lockable</kbd> requirements, then <kbd class="calibre17">std::unique_lock&lt;Mutex&gt;</kbd> also meets the <kbd class="calibre17">Lockable</kbd> requirements. If, in addition, the supplied <kbd class="calibre17">Mutex</kbd> type meets the <kbd class="calibre17">TimedLockable</kbd> requirements, then <kbd class="calibre17">std::unique_lock&lt;Mutex&gt;</kbd> also meets the <kbd class="calibre17">TimedLockable</kbd> requirements.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::unique_lock</kbd> are <kbd class="calibre17">MoveConstructible</kbd> and <kbd class="calibre17">MoveAssignable</kbd> but not <kbd class="calibre17">CopyConstructible</kbd> or <kbd class="calibre17">CopyAssignable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Mutex&gt;
class unique_lock
{
public:
    typedef Mutex mutex_type;

    unique_lock() noexcept;
    explicit unique_lock(mutex_type&amp; m);
    unique_lock(mutex_type&amp; m, adopt_lock_t);
    unique_lock(mutex_type&amp; m, defer_lock_t) noexcept;
    unique_lock(mutex_type&amp; m, try_to_lock_t);

    template&lt;typename Clock,typename Duration&gt;
    unique_lock(
        mutex_type&amp; m,
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);

    template&lt;typename Rep,typename Period&gt;
    unique_lock(
        mutex_type&amp; m,
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);

    ~unique_lock();

    unique_lock(unique_lock const&amp; ) = delete;
    unique_lock&amp; operator=(unique_lock const&amp; ) = delete;

    unique_lock(unique_lock&amp;&amp; );
    unique_lock&amp; operator=(unique_lock&amp;&amp; );

    void swap(unique_lock&amp; other) noexcept;

    void lock();
    bool try_lock();
    template&lt;typename Rep, typename Period&gt;
    bool try_lock_for(
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);
    template&lt;typename Clock, typename Duration&gt;
    bool try_lock_until(
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);
    void unlock();

    explicit operator bool() const noexcept;
    bool owns_lock() const noexcept;
    Mutex* mutex() const noexcept;
    Mutex* release() noexcept;
};</pre>
            </li>
         
      </ul>
      
      
      </body></html>
