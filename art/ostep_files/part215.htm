<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Beyond Physical Memory: Mechanisms</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part214.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part216.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Beyond Physical Memory: Mechanisms</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Thus far, we’ve assumed that an address space is unrealistically small and fits into physical memory. In fact, we’ve been assuming that <i>every </i>address space of every running process fits into memory. We will now relax these big assumptions, and assume that we wish to support many concurrently-running large address spaces.</p><p style="padding-bottom: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To do so, we require an additional level in the <b>memory hierarchy</b>. Thus far, we have assumed that all pages reside in physical memory. However, to support large address spaces, the OS will need a place to stash away portions of address spaces that currently aren’t in great de- mand. In general, the characteristics of such a location are that it should have more capacity than memory; as a result, it is generally slower (if it were faster, we would just use it as memory, no?). In modern systems, this role is usually served by a <b>hard disk drive</b>. Thus, in our memory hierarchy, big and slow hard drives sit at the bottom, with memory just above. And thus we arrive at the crux of the problem:</p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>G<span class="s7">O </span>B<span class="s7">EYOND </span>P<span class="s7">HYSICAL </span>M<span class="s7">EMORY</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: left;">How can the OS make use of a larger, slower device to transparently pro- vide the illusion of a large virtual address space?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One question you might have: why do we want to support a single large address space for a process? Once again, the answer is convenience and ease of use. With a large address space, you don’t have to worry about if there is room enough in memory for your program’s data struc- tures; rather, you just write the program naturally, allocating memory as needed. It is a powerful illusion that the OS provides, and makes your life vastly simpler. You’re welcome! A contrast is found in older systems that used <b>memory overlays</b>, which required programmers to manually move pieces of code or data in and out of memory as they were needed [D97]. Try imagining what this would be like: before calling a function or accessing some data, you need to first arrange for the code or data to be in memory; yuck!</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">217</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 83pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A<span class="s7">SIDE</span>: <b>S</b><span class="s45">TORAGE </span><b>T</b><span class="s45">ECHNOLOGIES</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">We’ll delve much more deeply into how I/O devices actually work later (see the chapter on I/O devices). So be patient! And of course the slower device need not be a hard disk, but could be something more modern such as a Flash-based SSD. We’ll talk about those things too. For now, just assume we have a big and relatively-slow device which we can use to help us build the illusion of a very large virtual memory, even bigger than physical memory itself.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">Beyond just a single process, the addition of swap space allows the OS to support the illusion of a large virtual memory for multiple concurrently- running processes. The invention of multiprogramming (running multi- ple programs “at once”, to better utilize the machine) almost demanded the ability to swap out some pages, as early machines clearly could not hold all the pages needed by all processes at once. Thus, the combina- tion of multiprogramming and ease-of-use leads us to want to support using more memory than is physically available. It is something that all modern VM systems do; it is now something we will learn more about.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part216.htm">21.1 Swap Space</a><a class="toc0" href="part217.htm">21.2 The Present Bit</a><a class="toc0" href="part218.htm">21.3 The Page Fault</a><a class="toc0" href="part219.htm">21.4 What If Memory Is Full?</a><a class="toc0" href="part220.htm">21.5 Page Fault Control Flow</a><a class="toc0" href="part221.htm">21.6 When Replacements Really Occur</a><a class="toc0" href="part222.htm">21.7 Summary</a><a class="toc0" href="part223.htm">References</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part214.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part216.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
