<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>23.5 Other Neat VM Tricks</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part254.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part256.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">23.5 Other Neat VM Tricks</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">VMS had two other now-standard tricks: demand zeroing and copy- on-write. We now describe these <b>lazy </b>optimizations.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One form of laziness in VMS (and most modern systems) is <b>demand zeroing </b>of pages. To understand this better, let’s consider the example of adding a page to your address space, say in your heap. In a naive implementation, the OS responds to a request to add a page to your heap by finding a page in physical memory, zeroing it (required for security; otherwise you’d be able to see what was on the page from when some other process used it!), and then mapping it into your address space (i.e., setting up the page table to refer to that physical page as desired). But the naive implementation can be costly, particularly if the page does not get used by the process.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">With demand zeroing, the OS instead does very little work when the page is added to your address space; it puts an entry in the page table that marks the page inaccessible. If the process then reads or writes the page, a trap into the OS takes place. When handling the trap, the OS no- tices (usually through some bits marked in the “reserved for OS” portion of the page table entry) that this is actually a demand-zero page; at this point, the OS then does the needed work of finding a physical page, ze- roing it, and mapping it into the process’s address space. If the process never accesses the page, all of this work is avoided, and thus the virtue of demand zeroing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: B<span class="s7">E </span>L<span class="s7">AZY</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Being lazy can be a virtue in both life as well as in operating systems. Laziness can put off work until later, which is beneficial within an OS for a number of reasons. First, putting off work might reduce the latency of the current operation, thus improving responsiveness; for example, op- erating systems often report that writes to a file succeeded immediately, and only write them to disk later in the background. Second, and more importantly, laziness sometimes obviates the need to do the work at all; for example, delaying a write until the file is deleted removes the need to do the write at all. Laziness is also good in life: for example, by putting off your OS project, you may find that the project specification bugs are worked out by your fellow classmates; however, the class project is un- likely to get canceled, so being too lazy may be problematic, leading to a late project, bad grade, and a sad professor. Don’t make professors sad!</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Another cool optimization found in VMS (and again, in virtually every modern OS) is <b>copy-on-write </b>(<b>COW </b>for short). The idea, which goes at least back to the TENEX operating system [BB+72], is simple: when the OS needs to copy a page from one address space to another, instead of copying it, it can map it into the target address space and mark it read- only in both address spaces. If both address spaces only read the page, no further action is taken, and thus the OS has affected a fast copy without actually moving any data.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">If, however, one of the address spaces does indeed try to write to the page, it will trap into the OS. The OS will then notice that the page is a COW page, and thus (lazily) allocate a new page, fill it with the data, and map this new page into the address space of the faulting process. The process then continues and now has its own private copy of the page.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">COW is useful for a number of reasons. Certainly any sort of shared library can be mapped copy-on-write into the address spaces of many processes, saving valuable memory space. In U<span class="s7">NIX </span>systems, COW is even more critical, due to the semantics of <span class="s41">fork() </span>and <span class="s41">exec()</span>. As you might recall, <span class="s41">fork() </span>creates an exact copy of the address space of the caller; with a large address space, making such a copy is slow and data intensive. Even worse, most of the address space is immediately over-written by a subsequent call to <span class="s41">exec()</span>, which overlays the calling process’s address space with that of the soon-to-be-exec’d program. By instead performing a copy-on-write <span class="s41">fork()</span>, the OS avoids much of the needless copying and thus retains the correct semantics while improving performance.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part254.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part256.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
