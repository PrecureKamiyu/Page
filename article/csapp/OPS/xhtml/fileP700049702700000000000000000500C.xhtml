<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.14 Identifying and Eliminating Performance Bottlenecks</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P700049702700000000000000000500C" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P70004970270000000000000000437B6" data-uri="chapter05.xhtml#P70004970270000000000000000437B6" epub:type="title"><span class="pcalibre label pcalibre1">5.14 </span>Identifying and Eliminating Performance Bottlenecks</h1></header>
<p id="P70004970270000000000000000437B7" data-uri="chapter05.xhtml#P70004970270000000000000000437B7" class="pcalibre1 pcalibre calibre2">Up to this point, we have only considered optimizing small programs, where there is some clear place in the program that limits its performance and therefore should be the focus of our optimization efforts. When working with large programs, even knowing where to focus our optimization efforts can be difficult. In this section, we describe how to use <i class="calibre5 pcalibre pcalibre1">code profilers</i>, analysis tools that collect performance data about a program as it executes. We also discuss some general principles of code optimization, including the implications of Amdahl's law, introduced in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000204"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">1.9.1</span></a>.</p>
<section id="P700049702700000000000000000500F" data-uri="chapter05.xhtml#P700049702700000000000000000500F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000437B8" data-uri="chapter05.xhtml#P70004970270000000000000000437B8" epub:type="title"><span class="pcalibre label pcalibre1">5.14.1 </span>Program Profiling</h1></header>
<p id="P70004970270000000000000000437B9" data-uri="chapter05.xhtml#P70004970270000000000000000437B9" class="pcalibre1 pcalibre calibre2">Program <i class="calibre5 pcalibre pcalibre1">profiling</i> involves running a version of a program in which instrumentation code has been incorporated to determine how much time the different parts of the program require. It can be very useful for identifying the parts of a program we should focus on in our optimization efforts. One strength of profiling is that it can be performed while running the actual program on realistic benchmark data.</p>
<p id="P70004970270000000000000000437BA" data-uri="chapter05.xhtml#P70004970270000000000000000437BA" class="pcalibre1 pcalibre calibre2">Unix systems provide the profiling program <span class="smallcaps pcalibre pcalibre1">gprof</span>. This program generates two forms of information. First, it determines how much CPU time was spent for each of the functions in the program. Second, it computes a count of how many times each function gets called, categorized by which function performs the call. Both forms of information can be quite useful. The timings give a sense of <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005013" title="563" data-uri="chapter05.xhtml#P7000497027000000000000000005013" epub:type="pagebreak"></span>the relative importance of the different functions in determining the overall run time. The calling information allows us to understand the dynamic behavior of the program.</p>
<p id="P70004970270000000000000000437BB" data-uri="chapter05.xhtml#P70004970270000000000000000437BB" class="pcalibre1 pcalibre calibre2">Profiling with <span class="smallcaps pcalibre pcalibre1">gprof </span>requires three steps, as shown for a C program <code id="P70004970270000000000000000437BC" data-uri="chapter05.xhtml#P70004970270000000000000000437BC" class="pcalibre1 calibre8 pcalibre">prog.c</code>, which runs with command-line argument <code id="P70004970270000000000000000437BD" data-uri="chapter05.xhtml#P70004970270000000000000000437BD" class="pcalibre1 calibre8 pcalibre">file.txt</code>:</p>
<ol id="P70004970270000000000000000437BE" data-uri="chapter05.xhtml#P70004970270000000000000000437BE" class="calibre72 pcalibre pcalibre1">
<li id="P70004970270000000000000000437BF" data-uri="chapter05.xhtml#P70004970270000000000000000437BF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437C0" data-uri="chapter05.xhtml#P70004970270000000000000000437C0" class="pcalibre calibre3 pcalibre1">The program must be compiled and linked for profiling. With <span class="smallcaps pcalibre pcalibre1">gcc </span>(and other C compilers), this involves simply including the run-time flag <code id="P70004970270000000000000000437C1" data-uri="chapter05.xhtml#P70004970270000000000000000437C1" class="pcalibre1 calibre8 pcalibre">−pg</code> on the command line. It is important to ensure that the compiler does not attempt to perform any optimizations via inline substitution, or else the calls to functions may not be tabulated accurately. We use optimization flag <code id="P70004970270000000000000000437C2" data-uri="chapter05.xhtml#P70004970270000000000000000437C2" class="pcalibre1 calibre8 pcalibre">−Og</code>, guaranteeing that function calls will be tracked properly.</p>
<pre id="P70004970270000000000000000437C3" data-uri="chapter05.xhtml#P70004970270000000000000000437C3" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000437C4" data-uri="chapter05.xhtml#P70004970270000000000000000437C4" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Og -pg prog.c -o prog</i></code></pre></li>
<li id="P70004970270000000000000000437C5" data-uri="chapter05.xhtml#P70004970270000000000000000437C5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437C6" data-uri="chapter05.xhtml#P70004970270000000000000000437C6" class="pcalibre calibre3 pcalibre1">The program is then executed as usual:</p>
<pre id="P70004970270000000000000000437C7" data-uri="chapter05.xhtml#P70004970270000000000000000437C7" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000437C8" data-uri="chapter05.xhtml#P70004970270000000000000000437C8" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">./prog file.txt</i></code></pre>
<p id="P70004970270000000000000000437C9" data-uri="chapter05.xhtml#P70004970270000000000000000437C9" class="pcalibre calibre3 pcalibre1">It runs slightly (around a factor of 2) slower than normal, but otherwise the only difference is that it generates a file <code id="P70004970270000000000000000437CA" data-uri="chapter05.xhtml#P70004970270000000000000000437CA" class="pcalibre1 calibre8 pcalibre">gmon.out</code>.</p></li>
<li id="P70004970270000000000000000437CB" data-uri="chapter05.xhtml#P70004970270000000000000000437CB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437CC" data-uri="chapter05.xhtml#P70004970270000000000000000437CC" class="pcalibre calibre3 pcalibre1"><span class="smallcaps pcalibre pcalibre1">gprof </span>is invoked to analyze the data in <code id="P70004970270000000000000000437CD" data-uri="chapter05.xhtml#P70004970270000000000000000437CD" class="pcalibre1 calibre8 pcalibre">gmon.out</code>:</p>
<pre id="P70004970270000000000000000437CE" data-uri="chapter05.xhtml#P70004970270000000000000000437CE" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000437CF" data-uri="chapter05.xhtml#P70004970270000000000000000437CF" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gprof prog</i></code></pre></li>
</ol>
<p id="P70004970270000000000000000437D0" data-uri="chapter05.xhtml#P70004970270000000000000000437D0" class="pcalibre1 pcalibre calibre2">The first part of the profile report lists the times spent executing the different functions, sorted in descending order. As an example, the following listing shows this part of the report for the three most time-consuming functions in a program:</p>
<pre id="P70004970270000000000000000437D1" data-uri="chapter05.xhtml#P70004970270000000000000000437D1" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000437D2" data-uri="chapter05.xhtml#P70004970270000000000000000437D2" class="calibre10 pcalibre pcalibre1">
%	 cumulative	self		self	total	
time	seconds		seconds	calls	s/call	s/call	name
97.58	 203.66		 203.66     1	203.66	 203.66 sort_words
2.32	 208.50		   4.85 965027	  0.00	   0.00	find_ele_rec
0.14	 208.81		   0.30	12511031  0.00	   0.00	Strien
</code></pre>
<p id="P70004970270000000000000000437D3" data-uri="chapter05.xhtml#P70004970270000000000000000437D3" class="pcalibre1 pcalibre calibre2">Each row represents the time spent for all calls to some function. The first column indicates the percentage of the overall time spent on the function. The second shows the cumulative time spent by the functions up to and including the one on this row. The third shows the time spent on this particular function, and the fourth shows how many times it was called (not counting recursive calls). In our example, the function <code id="P70004970270000000000000000437D4" data-uri="chapter05.xhtml#P70004970270000000000000000437D4" class="pcalibre1 calibre8 pcalibre">sort_words</code> was called only once, but this single call required 203.66 seconds, while the function <code id="P70004970270000000000000000437D5" data-uri="chapter05.xhtml#P70004970270000000000000000437D5" class="pcalibre1 calibre8 pcalibre">find_ele_rec</code> was called 965,027 times (not including recursive calls), requiring a total of 4.85 seconds. Function <code id="P70004970270000000000000000437D6" data-uri="chapter05.xhtml#P70004970270000000000000000437D6" class="pcalibre1 calibre8 pcalibre">Strlen</code> computes the length of a string by calling the library function <code id="P70004970270000000000000000437D7" data-uri="chapter05.xhtml#P70004970270000000000000000437D7" class="pcalibre1 calibre8 pcalibre">strlen</code>. Library function calls are normally not shown in the results by <span class="smallcaps pcalibre pcalibre1">gprof</span>. Their times are usually reported as part of the function calling them. By creating the "wrapper function" <code id="P70004970270000000000000000437D8" data-uri="chapter05.xhtml#P70004970270000000000000000437D8" class="pcalibre1 calibre8 pcalibre">Strlen</code>, we can reliably track the calls to <code id="P70004970270000000000000000437D9" data-uri="chapter05.xhtml#P70004970270000000000000000437D9" class="pcalibre1 calibre8 pcalibre">strlen</code>, showing that it was called 12,511,031 times but only requiring a total of 0.30 seconds.</p>
<p id="P70004970270000000000000000437DA" data-uri="chapter05.xhtml#P70004970270000000000000000437DA" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005034" title="564" data-uri="chapter05.xhtml#P7000497027000000000000000005034" epub:type="pagebreak"></span>The second part of the profile report shows the calling history of the functions. The following is the history for a recursive function <code id="P70004970270000000000000000437DB" data-uri="chapter05.xhtml#P70004970270000000000000000437DB" class="pcalibre1 calibre8 pcalibre">find_ele_rec</code>:</p>
<pre id="P70004970270000000000000000437DC" data-uri="chapter05.xhtml#P70004970270000000000000000437DC" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000437DD" data-uri="chapter05.xhtml#P70004970270000000000000000437DD" class="calibre10 pcalibre pcalibre1">
				158655725	find_ele_rec [5]
		4.85	0.10	965027/965027	insert_string [4]
[5]	2.4	4.85	0.10	965027+158655725	find_ele_rec [5]
		0.08	0.01	363039/363039	save_string [8]
		0.00	0.01	363039/363039	new_ele [12]
				158655725	find_ele_rec [5]
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000437DE" data-uri="chapter05.xhtml#P70004970270000000000000000437DE">This history shows both the functions that called <code id="P70004970270000000000000000437DF" data-uri="chapter05.xhtml#P70004970270000000000000000437DF" class="pcalibre1 calibre8 pcalibre">find_ele_rec</code>, as well as the functions that it called. The first two lines show the calls to the function: 158,655,725 calls by itself recursively, and 965,027 calls by function <code id="P70004970270000000000000000437E0" data-uri="chapter05.xhtml#P70004970270000000000000000437E0" class="pcalibre1 calibre8 pcalibre">insert_string</code> (which is itself called 965,027 times). Function <code id="P70004970270000000000000000437E1" data-uri="chapter05.xhtml#P70004970270000000000000000437E1" class="pcalibre1 calibre8 pcalibre">find_ele_rec</code>, in turn, called two other functions, <code id="P70004970270000000000000000437E2" data-uri="chapter05.xhtml#P70004970270000000000000000437E2" class="pcalibre1 calibre8 pcalibre">save_string</code> and <code id="P70004970270000000000000000437E3" data-uri="chapter05.xhtml#P70004970270000000000000000437E3" class="pcalibre1 calibre8 pcalibre">new_ele</code>, each a total of 363,039 times.</p>
<p id="P70004970270000000000000000437E4" data-uri="chapter05.xhtml#P70004970270000000000000000437E4" class="pcalibre1 pcalibre calibre2">From these call data, we can often infer useful information about the program behavior. For example, the function <code id="P70004970270000000000000000437E5" data-uri="chapter05.xhtml#P70004970270000000000000000437E5" class="pcalibre1 calibre8 pcalibre">find_ele_rec</code> is a recursive procedure that scans the linked list for a hash bucket looking for a particular string. For this function, comparing the number of recursive calls with the number of top-level calls provides statistical information about the lengths of the traversals through these lists. Given that their ratio is 164.4:1, we can infer that the program scanned an average of around 164 elements each time.</p>
<p id="P70004970270000000000000000437E6" data-uri="chapter05.xhtml#P70004970270000000000000000437E6" class="pcalibre1 pcalibre calibre2">Some properties of <span class="smallcaps pcalibre pcalibre1">gprof </span>are worth noting:</p>
<ul id="P70004970270000000000000000437E7" data-uri="chapter05.xhtml#P70004970270000000000000000437E7" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000437E8" data-uri="chapter05.xhtml#P70004970270000000000000000437E8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437E9" data-uri="chapter05.xhtml#P70004970270000000000000000437E9" class="pcalibre calibre3 pcalibre1">The timing is not very precise. It is based on a simple <i class="calibre5 pcalibre pcalibre1">interval counting</i> scheme in which the compiled program maintains a counter for each function recording the time spent executing that function. The operating system causes the program to be interrupted at some regular time interval <i class="calibre5 pcalibre pcalibre1">δ</i>. Typical values of <i class="calibre5 pcalibre pcalibre1">δ</i> range between 1.0 and 10.0 milliseconds. It then determines what function the program was executing when the interrupt occurred and increments the counter for that function by <i class="calibre5 pcalibre pcalibre1">δ</i>. Of course, it may happen that this function just started executing and will shortly be completed, but it is assigned the full cost of the execution since the previous interrupt. Some other function may run between two interrupts and therefore not be charged any time at all.</p>
<p id="P70004970270000000000000000437EA" data-uri="chapter05.xhtml#P70004970270000000000000000437EA" class="pcalibre1 calibre32 pcalibre">Over a long duration, this scheme works reasonably well. Statistically, every function should be charged according to the relative time spent executing it. For programs that run for less than around 1 second, however, the numbers should be viewed as only rough estimates.</p></li>
<li id="P70004970270000000000000000437EB" data-uri="chapter05.xhtml#P70004970270000000000000000437EB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437EC" data-uri="chapter05.xhtml#P70004970270000000000000000437EC" class="pcalibre calibre3 pcalibre1">The calling information is quite reliable, assuming no inline substitutions have been performed. The compiled program maintains a counter for each combination of caller and callee. The appropriate counter is incremented every time a procedure is called.</p></li>
<li id="P70004970270000000000000000437ED" data-uri="chapter05.xhtml#P70004970270000000000000000437ED" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437EE" data-uri="chapter05.xhtml#P70004970270000000000000000437EE" class="pcalibre calibre3 pcalibre1">By default, the timings for library functions are not shown. Instead, these times are incorporated into the times for the calling functions.</p></li>
</ul>
</section>
<section id="P7000497027000000000000000005049" data-uri="chapter05.xhtml#P7000497027000000000000000005049" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000437EF" data-uri="chapter05.xhtml#P70004970270000000000000000437EF" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000504B" title="565" data-uri="chapter05.xhtml#P700049702700000000000000000504B" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">5.14.2 </span>Using a Profiler to Guide Optimization</h1></header>
<p id="P70004970270000000000000000437F0" data-uri="chapter05.xhtml#P70004970270000000000000000437F0" class="pcalibre1 pcalibre calibre2">As an example of using a profiler to guide program optimization, we created an application that involves several different tasks and data structures. This application analyzes the <i class="calibre5 pcalibre pcalibre1">n-gram</i> statistics of a text document, where an <var class="calibre5 pcalibre pcalibre1">n</var>-gram is a sequence of <var class="calibre5 pcalibre pcalibre1">n</var> words occurring in a document. For <var class="calibre5 pcalibre pcalibre1">n</var> = 1, we collect statistics on individual words, for <var class="calibre5 pcalibre pcalibre1">n</var> = 2 on pairs of words, and so on. For a given value of <var class="calibre5 pcalibre pcalibre1">n</var>, our program reads a text file, creates a table of unique <var class="calibre5 pcalibre pcalibre1">n</var>-grams and how many times each one occurs, then sorts the <var class="calibre5 pcalibre pcalibre1">n</var>-grams in descending order of occurrence.</p>
<p id="P70004970270000000000000000437F1" data-uri="chapter05.xhtml#P70004970270000000000000000437F1" class="pcalibre1 pcalibre calibre2">As a benchmark, we ran it on a file consisting of the complete works of William Shakespeare, totaling 965,028 words, of which 23,706 are unique. We found that for <var class="calibre5 pcalibre pcalibre1">n</var> = 1, even a poorly written analysis program can readily process the entire file in under 1 second, and so we set <var class="calibre5 pcalibre pcalibre1">n</var> = 2 to make things more challenging. For the case of <var class="calibre5 pcalibre pcalibre1">n</var> = 2, <var class="calibre5 pcalibre pcalibre1">n</var>-grams are referred to as <i class="calibre5 pcalibre pcalibre1">bigrams</i> (pronounced "bye-grams"). We determined that Shakespeare's works contain 363,039 unique bigrams. The most common is "I am," occurring 1,892 times. Perhaps his most famous bigram, "to be," occurs 1,020 times. Fully 266,018 of the bigrams occur only once.</p>
<p id="P70004970270000000000000000437F2" data-uri="chapter05.xhtml#P70004970270000000000000000437F2" class="pcalibre1 pcalibre calibre2">Our program consists of the following parts. We created multiple versions, starting with simple algorithms for the different parts and then replacing them with more sophisticated ones:</p>
<ol id="P70004970270000000000000000437F3" data-uri="chapter05.xhtml#P70004970270000000000000000437F3" class="calibre72 pcalibre pcalibre1">
<li id="P70004970270000000000000000437F4" data-uri="chapter05.xhtml#P70004970270000000000000000437F4" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437F5" data-uri="chapter05.xhtml#P70004970270000000000000000437F5" class="pcalibre calibre3 pcalibre1">Each word is read from the file and converted to lowercase. Our initial version used the function <code id="P70004970270000000000000000437F6" data-uri="chapter05.xhtml#P70004970270000000000000000437F6" class="pcalibre1 calibre8 pcalibre">lower1</code> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000049CE.xhtml#P7000497027000000000000000004A11"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.7</span></a>), which we know to have quadratic run time due to repeated calls to <code id="P70004970270000000000000000437F7" data-uri="chapter05.xhtml#P70004970270000000000000000437F7" class="pcalibre1 calibre8 pcalibre">strlen</code>.</p></li>
<li id="P70004970270000000000000000437F8" data-uri="chapter05.xhtml#P70004970270000000000000000437F8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437F9" data-uri="chapter05.xhtml#P70004970270000000000000000437F9" class="pcalibre calibre3 pcalibre1">A hash function is applied to the string to create a number between 0 and <var class="calibre5 pcalibre pcalibre1">s</var> − 1, for a hash table with <var class="calibre5 pcalibre pcalibre1">s</var> buckets. Our initial function simply summed the ASCII codes for the characters modulo <i class="calibre5 pcalibre pcalibre1">s.</i></p></li>
<li id="P70004970270000000000000000437FA" data-uri="chapter05.xhtml#P70004970270000000000000000437FA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437FB" data-uri="chapter05.xhtml#P70004970270000000000000000437FB" class="pcalibre calibre3 pcalibre1">Each hash bucket is organized as a linked list. The program scans down this list looking for a matching entry. If one is found, the frequency for this <var class="calibre5 pcalibre pcalibre1">n</var>-gram is incremented. Otherwise, a new list element is created. Our initial version performed this operation recursively, inserting new elements at the end of the list.</p></li>
<li id="P70004970270000000000000000437FC" data-uri="chapter05.xhtml#P70004970270000000000000000437FC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000437FD" data-uri="chapter05.xhtml#P70004970270000000000000000437FD" class="pcalibre calibre3 pcalibre1">Once the table has been generated, we sort all of the elements according to the frequencies. Our initial version used insertion sort.</p></li>
</ol>
<p id="P70004970270000000000000000437FE" data-uri="chapter05.xhtml#P70004970270000000000000000437FE" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005064"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.38</span></a> shows the profile results for six different versions of our <var class="calibre5 pcalibre pcalibre1">n</var>-gram-frequency analysis program. For each version, we divide the time into the following categories:</p>
<ul class="pcalibre ul_none pcalibre1" id="P70004970270000000000000000437FF" data-uri="chapter05.xhtml#P70004970270000000000000000437FF">
<li id="P7000497027000000000000000043800" data-uri="chapter05.xhtml#P7000497027000000000000000043800" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043801" data-uri="chapter05.xhtml#P7000497027000000000000000043801" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Sort. </span>Sorting <var class="calibre5 pcalibre pcalibre1">n</var>-grams by frequency</p></li>
<li id="P7000497027000000000000000043802" data-uri="chapter05.xhtml#P7000497027000000000000000043802" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043803" data-uri="chapter05.xhtml#P7000497027000000000000000043803" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">List. </span>Scanning the linked list for a matching <var class="calibre5 pcalibre pcalibre1">n</var>-gram, inserting a new element if necessary</p></li>
<li id="P7000497027000000000000000043804" data-uri="chapter05.xhtml#P7000497027000000000000000043804" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043805" data-uri="chapter05.xhtml#P7000497027000000000000000043805" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Lower. </span>Converting strings to lowercase</p></li>
<li id="P7000497027000000000000000043806" data-uri="chapter05.xhtml#P7000497027000000000000000043806" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043807" data-uri="chapter05.xhtml#P7000497027000000000000000043807" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Strlen. </span>Computing string lengths</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000005064" data-uri="chapter05.xhtml#P7000497027000000000000000005064">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005065" title="566" data-uri="chapter05.xhtml#P7000497027000000000000000005065" epub:type="pagebreak"></span>
<img alt="Two graphs depict profile results." id="P7000497027000000000000000043808" data-uri="P700049702700000000000000000B727" src="../images/p566-1.png" class="calibre191 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000043809" data-uri="chapter05.xhtml#P7000497027000000000000000043809" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004380A" data-uri="chapter05.xhtml#P700049702700000000000000004380A" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.38 </span>Profile results for different versions of bigram-frequency counting program.</h1></header>
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000004380B" data-uri="chapter05.xhtml#P700049702700000000000000004380B"><p id="P700049702700000000000000004380C" data-uri="chapter05.xhtml#P700049702700000000000000004380C" class="pcalibre calibre3 pcalibre1">Time is divided according to the different major operations in the program.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000023AFC" data-uri="chapter05.xhtml#P7000497027000000000000000023AFC">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P700049702700000000000000004380D" data-uri="chapter05.xhtml#P700049702700000000000000004380D" class="calibre13 pcalibre pcalibre1">Two graphs each have bars for Initial, Quicksort, Iter first, Iter last, Big table, Better hash, and Linear lower, rising to various CPU seconds. Each bar is divided into sort, list, lower, strlen, hash, and reset. The data are summarized below.</p>
<ol class="pcalibre1 pcalibre ol_lower-alpha1" id="P700049702700000000000000004380E" data-uri="chapter05.xhtml#P700049702700000000000000004380E">
<li id="P700049702700000000000000004380F" data-uri="chapter05.xhtml#P700049702700000000000000004380F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043810" data-uri="chapter05.xhtml#P7000497027000000000000000043810" class="calibre13 pcalibre pcalibre1">All versions: a bar for initial rises to about 210 CPU seconds, with about 200 CPU seconds as sort and about 10 as list. The other bars are all less than 20 CPU seconds.</p></li>
<li id="P7000497027000000000000000043811" data-uri="chapter05.xhtml#P7000497027000000000000000043811" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043812" data-uri="chapter05.xhtml#P7000497027000000000000000043812" class="calibre13 pcalibre pcalibre1">All but the slowest version: bars are divided approximately as summarized below.</p>
<ul id="P7000497027000000000000000043813" data-uri="chapter05.xhtml#P7000497027000000000000000043813" class="pcalibre calibre39 pcalibre1">
<li id="P7000497027000000000000000043814" data-uri="chapter05.xhtml#P7000497027000000000000000043814" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043815" data-uri="chapter05.xhtml#P7000497027000000000000000043815" class="calibre13 pcalibre pcalibre1">Quicksort: 5.5 seconds, with 5 seconds as list and 0.4 as strlen</p></li>
<li id="P7000497027000000000000000043816" data-uri="chapter05.xhtml#P7000497027000000000000000043816" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043817" data-uri="chapter05.xhtml#P7000497027000000000000000043817" class="calibre13 pcalibre pcalibre1">Iter first: 6 seconds, with 5.5 as list and 0.3 as strlen</p></li>
<li id="P7000497027000000000000000043818" data-uri="chapter05.xhtml#P7000497027000000000000000043818" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043819" data-uri="chapter05.xhtml#P7000497027000000000000000043819" class="calibre13 pcalibre pcalibre1">Iter last: 5.3 seconds, with 5 as list and 0.2 as strlen</p></li>
<li id="P700049702700000000000000004381A" data-uri="chapter05.xhtml#P700049702700000000000000004381A" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004381B" data-uri="chapter05.xhtml#P700049702700000000000000004381B" class="calibre13 pcalibre pcalibre1">Big table: 5.1 seconds, with 4.5 as list and 0.2 as strlen</p></li>
<li id="P700049702700000000000000004381C" data-uri="chapter05.xhtml#P700049702700000000000000004381C" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004381D" data-uri="chapter05.xhtml#P700049702700000000000000004381D" class="calibre13 pcalibre pcalibre1">Better hash: 0.7 seconds, with 0.4 as strlen</p></li>
<li id="P700049702700000000000000004381E" data-uri="chapter05.xhtml#P700049702700000000000000004381E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004381F" data-uri="chapter05.xhtml#P700049702700000000000000004381F" class="calibre13 pcalibre pcalibre1">Linear lower: 0.2 seconds</p></li>
</ul></li>
</ol>
</details>
</figcaption></figure></li>
<li id="P7000497027000000000000000043820" data-uri="chapter05.xhtml#P7000497027000000000000000043820" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043821" data-uri="chapter05.xhtml#P7000497027000000000000000043821" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Hash. </span>Computing the hash function</p></li>
<li id="P7000497027000000000000000043822" data-uri="chapter05.xhtml#P7000497027000000000000000043822" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043823" data-uri="chapter05.xhtml#P7000497027000000000000000043823" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Rest. </span>The sum of all other functions</p></li>
</ul>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043824" data-uri="chapter05.xhtml#P7000497027000000000000000043824">As part (a) of the figure shows, our initial version required 3.5 minutes, with most of the time spent sorting. This is not surprising, since insertion sort has quadratic run time and the program sorted 363,039 values.</p>
<p id="P7000497027000000000000000043825" data-uri="chapter05.xhtml#P7000497027000000000000000043825" class="pcalibre1 pcalibre calibre2">In our next version, we performed sorting using the library function <code id="P7000497027000000000000000043826" data-uri="chapter05.xhtml#P7000497027000000000000000043826" class="pcalibre1 calibre8 pcalibre">qsort</code>, which is based on the quicksort algorithm [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B468">98</a>]. It has an expected run time of <var class="calibre5 pcalibre pcalibre1">O</var>(<var class="calibre5 pcalibre pcalibre1">n</var> log <var class="calibre5 pcalibre pcalibre1">n</var>). This version is labeled "Quicksort" in the figure. The more efficient sorting algorithm reduces the time spent sorting to become negligible, and the overall run time to around 5.4 seconds. Part (b) of the figure shows the times for the remaining version on a scale where we can see them more clearly.</p>
<p id="P7000497027000000000000000043827" data-uri="chapter05.xhtml#P7000497027000000000000000043827" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005073" title="567" data-uri="chapter05.xhtml#P7000497027000000000000000005073" epub:type="pagebreak"></span>With improved sorting, we now find that list scanning becomes the bottleneck. Thinking that the inefficiency is due to the recursive structure of the function, we replaced it by an iterative one, shown as "Iter first." Surprisingly, the run time increases to around 7.5 seconds. On closer study, we find a subtle difference between the two list functions. The recursive version inserted new elements at the end of the list, while the iterative one inserted them at the front. To maximize performance, we want the most frequent <var class="calibre5 pcalibre pcalibre1">n</var>-grams to occur near the beginning of the lists. That way, the function will quickly locate the common cases. Assuming that <var class="calibre5 pcalibre pcalibre1">n</var>-grams are spread uniformly throughout the document, we would expect the first occurrence of a frequent one to come before that of a less frequent one. By inserting new <var class="calibre5 pcalibre pcalibre1">n</var>-grams at the end, the first function tended to order <var class="calibre5 pcalibre pcalibre1">n</var>-grams in descending order of frequency, while the second function tended to do just the opposite. We therefore created a third list-scanning function that uses iteration but inserts new elements at the end of this list. With this version, shown as "Iter last," the time dropped to around 5.3 seconds, slightly better than with the recursive version. These measurements demonstrate the importance of running experiments on a program as part of an optimization effort. We initially assumed that converting recursive code to iterative code would improve its performance and did not consider the distinction between adding to the end or to the beginning of a list.</p>
<p id="P7000497027000000000000000043828" data-uri="chapter05.xhtml#P7000497027000000000000000043828" class="pcalibre1 pcalibre calibre2">Next, we consider the hash table structure. The initial version had only 1,021 buckets (typically, the number of buckets is chosen to be a prime number to enhance the ability of the hash function to distribute keys uniformly among the buckets). For a table with 363,039 entries, this would imply an average <i class="calibre5 pcalibre pcalibre1">load</i> of 363,039/1,021 = 355.6. That explains why so much of the time is spent performing list operations—the searches involve testing a significant number of candidate <var class="calibre5 pcalibre pcalibre1">n</var>-grams. It also explains why the performance is so sensitive to the list ordering. We then increased the number of buckets to 199,999, reducing the average load to 1.8. Oddly enough, however, our overall run time only drops to 5.1 seconds, a difference of only 0.2 seconds.</p>
<p id="P7000497027000000000000000043829" data-uri="chapter05.xhtml#P7000497027000000000000000043829" class="pcalibre1 pcalibre calibre2">On further inspection, we can see that the minimal performance gain with a larger table was due to a poor choice of hash function. Simply summing the character codes for a string does not produce a very wide range of values. In particular, the maximum code value for a letter is 122, and so a string of <var class="calibre5 pcalibre pcalibre1">n</var> characters will generate a sum of at most 122<var class="calibre5 pcalibre pcalibre1">n</var>. The longest bigram in our document, "honorificabilitudinitatibus*** thou" sums to just 3,371, and so most of the buckets in our hash table will go unused. In addition, a commutative hash function, such as addition, does not differentiate among the different possible orderings of characters with a string. For example, the words "rat" and "tar" will generate the same sums.</p>
<p id="P700049702700000000000000004382A" data-uri="chapter05.xhtml#P700049702700000000000000004382A" class="pcalibre1 pcalibre calibre2">We switched to a hash function that uses shift and <span class="smallcaps pcalibre pcalibre1">exclusive-or </span>operations. With this version, shown as "Better hash," the time drops to 0.6 seconds. A more systematic approach would be to study the distribution of keys among the buckets more carefully, making sure that it comes close to what one would expect if the hash function had a uniform output distribution.</p>
<p id="P700049702700000000000000004382B" data-uri="chapter05.xhtml#P700049702700000000000000004382B" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005078" title="568" data-uri="chapter05.xhtml#P7000497027000000000000000005078" epub:type="pagebreak"></span>Finally, we have reduced the run time to the point where most of the time is spent in <code id="P700049702700000000000000004382C" data-uri="chapter05.xhtml#P700049702700000000000000004382C" class="pcalibre1 calibre8 pcalibre">strlen</code>, and most of the calls to <code id="P700049702700000000000000004382D" data-uri="chapter05.xhtml#P700049702700000000000000004382D" class="pcalibre1 calibre8 pcalibre">strlen</code> occur as part of the lowercase conversion. We have already seen that function <code id="P700049702700000000000000004382E" data-uri="chapter05.xhtml#P700049702700000000000000004382E" class="pcalibre1 calibre8 pcalibre">lower1</code> has quadratic performance, especially for long strings. The words in this document are short enough to avoid the disastrous consequences of quadratic performance; the longest bigram is just 32 characters. Still, switching to <code id="P700049702700000000000000004382F" data-uri="chapter05.xhtml#P700049702700000000000000004382F" class="pcalibre1 calibre8 pcalibre">lower2</code>, shown as "Linear lower," yields a significant improvement, with the overall time dropping to around 0.2 seconds.</p>
<p id="P7000497027000000000000000043830" data-uri="chapter05.xhtml#P7000497027000000000000000043830" class="pcalibre1 pcalibre calibre2">With this exercise, we have shown that code profiling can help drop the time required for a simple application from 3.5 minutes down to 0.2 seconds, yielding a performance gain of around 1,000×. The profiler helps us focus our attention on the most time-consuming parts of the program and also provides useful information about the procedure call structure. Some of the bottlenecks in our code, such as using a quadratic sort routine, are easy to anticipate, while others, such as whether to append to the beginning or end of a list, emerge only through a careful analysis.</p>
<p id="P7000497027000000000000000043831" data-uri="chapter05.xhtml#P7000497027000000000000000043831" class="pcalibre1 pcalibre calibre2">We can see that profiling is a useful tool to have in the toolbox, but it should not be the only one. The timing measurements are imperfect, especially for shorter (less than 1 second) run times. More significantly, the results apply only to the particular data tested. For example, if we had run the original function on data consisting of a smaller number of longer strings, we would have found that the lowercase conversion routine was the major performance bottleneck. Even worse, if it only profiled documents with short words, we might never detect hidden bottlenecks such as the quadratic performance of <code id="P7000497027000000000000000043832" data-uri="chapter05.xhtml#P7000497027000000000000000043832" class="pcalibre1 calibre8 pcalibre">lower1</code>. In general, profiling can help us optimize for <i class="calibre5 pcalibre pcalibre1">typical</i> cases, assuming we run the program on representative data, but we should also make sure the program will have respectable performance for all possible cases. This mainly involves avoiding algorithms (such as insertion sort) and bad programming practices (such as <code id="P7000497027000000000000000043833" data-uri="chapter05.xhtml#P7000497027000000000000000043833" class="pcalibre1 calibre8 pcalibre">lower1</code>) that yield poor asymptotic performance.</p>
<p id="P7000497027000000000000000043834" data-uri="chapter05.xhtml#P7000497027000000000000000043834" class="pcalibre1 pcalibre calibre2">Amdahl's law, described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000204"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">1.9.1</span></a>, provides some additional insights into the performance gains that can be obtained by targeted optimizations. For our <var class="calibre5 pcalibre pcalibre1">n</var>-gram code, we saw the total execution time drop from 209.0 to 5.4 seconds when we replaced insertion sort by quicksort. The initial version spent 203.7 of its 209.0 seconds performing insertion sort, giving <i class="calibre5 pcalibre pcalibre1">α</i> = 0.974, the fraction of time subject to speedup. With quicksort, the time spent sorting becomes negligible, giving a predicted speedup of 209/<i class="calibre5 pcalibre pcalibre1">α</i> = 39.0, close to the measured speedup of 38.5. We were able to gain a large speedup because sorting constituted a very large fraction of the overall execution time. However, when one bottleneck is eliminated, a new one arises, and so gaining additional speedup required focusing on other parts of the program.</p>
</section>
</section></body></html>
