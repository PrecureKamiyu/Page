<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>15.4 OS Issues</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part144.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part146.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">15.4 OS Issues</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">There are a number of new OS issues that arise when using base and bounds to implement a simple virtual memory. Specifically, there are three critical junctures where the OS must take action to implement this base-and-bounds approach to virtualizing memory.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">First, The OS must take action when a process is created, finding space for its address space in memory. Fortunately, given our assumptions that each address space is (a) smaller than the size of physical memory and</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">(b) the same size, this is quite easy for the OS; it can simply view physical memory as an array of slots, and track whether each one is free or in use. When a new process is created, the OS will have to search a data structure (often called a <b>free list</b>) to find room for the new address space and then mark it used.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">An example of what physical memory might look like can be found in Figure <span style=" color: #00AEEF;">15.2</span>. In the figure, you can see the OS using the first slot of physical memory for itself, and that it has relocated the process from the example above into the slot starting at physical memory address 32 KB. The other two slots are free (16 KB-32 KB and 48 KB-64 KB); thus, the <b>free list </b>should consist of these two entries.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Second, the OS must take action when a process is terminated, reclaim- ing all of its memory for use in other processes or the OS. Upon termina- tion of a process, the OS thus puts its memory back on the free list, and cleans up any associated data structures as need be.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Third, the OS must also take action when a context switch occurs. There is only one base and bounds register on each CPU, after all, and their values differ for each running program, as each program is loaded at a different physical address in memory. Thus, the OS must <i>save and restore </i>the base-and-bounds pair when it switches between processes. Specifi- cally, when the OS decides to stop running a process, it must save the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">values of the base and bounds registers to memory, in some per-process structure such as the <b>process structure </b>or <b>process control block </b>(PCB). Similarly, when the OS resumes a running process (or runs it the first time), it must set the values of the base and bounds on the CPU to the correct values for this process.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We should note that when a process is stopped (i.e., not running), it is possible for the OS to move an address space from one location in mem- ory to another rather easily. To move a process’s address space, the OS first deschedules the process; then, the OS copies the address space from the current location to the new location; finally, the OS updates the saved base register (in the process structure) to point to the new location. When the process is resumed, its (new) base register is restored, and it begins running again, oblivious that its instructions and data are now in a com- pletely new spot in memory!</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We should also note that access to the base and bounds registers is ob- viously <b>privileged</b>. Special hardware instructions are required to access base-and-bounds registers; if a process, running in user mode, attempts to do so, the CPU will raise an exception and the OS will likely termi- nate the process. Only in kernel (or privileged) mode can such registers</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">be modified. Imagine the havoc a user process could wreak<span class="s35">1</span> if it could arbitrarily change the base register while running. Imagine it! And then quickly flush such dark thoughts from your mind, as they are the ghastly stuff of which nightmares are made.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part144.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part146.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
