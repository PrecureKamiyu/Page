<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Practice Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part358.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part360.htm">下一个 &gt;</a></p><p class="s45" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Practice Exercises</p><p class="s46" style="padding-top: 12pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;">19.1  <span class="p">Explain why log records for transactions on the undo-list must be processed in reverse order, whereas redo is performed in a forward direction.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;">19.2 <span class="p">Explain the purpose of the checkpoint mechanism. How often should check- points be performed? How does the frequency of checkpoints aﬀect:</span></p><p class="s39" style="padding-top: 5pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">• <span class="s40">System performance when no failure occurs?</span></p><p class="s39" style="padding-top: 3pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">• <span class="s40">The time it takes to recover from a system crash?</span></p><p class="s39" style="padding-top: 3pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">• <span class="s40">The time it takes to recover from a media (disk) failure?</span></p><p style="padding-top: 7pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;"><b>19.3 </b>Some database systems allow the administrator to choose between two forms of logging: <i>normal logging</i>, used to recover from system crashes, and <i>archival logging</i>, used to recover from media (disk) failure. When can a log record be deleted, in each of these cases, using the recovery algorithm of Section 19.4?</p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;">19.4 <span class="p">Describe how to modify the recovery algorithm of Section 19.4 to implement savepoints and to perform rollback to a savepoint. (Savepoints are described in Section 19.9.3.)</span></p><p class="s46" style="padding-top: 6pt;padding-left: 93pt;text-indent: 0pt;text-align: justify;">19.5  <span class="p">Suppose the deferred modiﬁcation technique is used in a database.</span></p><p style="padding-top: 7pt;padding-left: 150pt;text-indent: -18pt;text-align: left;">a.  Is the old value part of an update log record required any more? Why or why not?</p><p class="s64" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Practice Exercises  <span class="s164">953</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 181pt;text-indent: -19pt;text-align: justify;">b.  If old values are not stored in update log records, transaction undo is clearly not feasible. How would the redo phase of recovery have to be modiﬁed as a result?</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">c.  Deferred modiﬁcation can be implemented by keeping updated data items in local memory of transactions and reading data items that have not been updated directly from the database buﬀer. Suggest how to eﬃ- ciently implement a data item read, ensuring that a transaction sees its own updates.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: justify;">d.  What problem would arise with the above technique if transactions per- form a large number of updates?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 156pt;text-indent: -30pt;text-align: justify;"><b>19.6  </b>The shadow-paging scheme requires the page table to be copied. Suppose the page table is represented as a B<span class="s181">+</span>-tree.</p><p style="padding-top: 12pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">a.  Suggest how to share as many nodes as possible between the new copy and the shadow copy of the B<span class="s181">+</span>-tree, assuming that updates are made only to leaf entries, with no insertions or deletions.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: justify;">b.  Even with the above optimization, logging is much cheaper than a shadow copy scheme, for transactions that perform small updates. Ex- plain why.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 156pt;text-indent: -30pt;text-align: justify;">19.7 <span class="p">Suppose we (incorrectly) modify the recovery algorithm of Section 19.4 to note log actions taken during transaction rollback. When recovering from a system crash, transactions that were rolled back earlier would then be included in undo-list and rolled back again. Give an example to show how actions taken during the undo phase of recovery could result in an incorrect database state. (Hint: Consider a data item updated by an aborted transaction and then up- dated by a transaction that commits.)</span></p><p style="padding-top: 6pt;padding-left: 156pt;text-indent: -30pt;text-align: justify;"><b>19.8  </b>Disk space allocated to a ﬁle as a result of a transaction should not be released even if the transaction is rolled back. Explain why, and explain how <span class="s44">ARIES </span>ensures that such actions are not rolled back.</p><p class="s46" style="padding-top: 6pt;padding-left: 156pt;text-indent: -30pt;text-align: justify;">19.9  <span class="p">Suppose a transaction deletes a record, and the free space generated thus is allocated to a record inserted by another transaction, even before the ﬁrst trans- action commits.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 163pt;text-indent: 0pt;text-align: left;">a.  What problem can occur if the ﬁrst transaction needs to be rolled back?</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: left;">b. Would this problem be an issue if page-level locking is used instead of tuple-level locking?</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: left;">c. Suggest how to solve this problem while supporting tuple-level locking, by logging post-commit actions in special log records, and executing</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 150pt;text-indent: 0pt;text-align: left;">them after commit. Make sure your scheme ensures that such actions are performed exactly once.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 124pt;text-indent: -35pt;text-align: justify;">19.10 <span class="p">Explain the reasons why recovery of interactive transactions is more diﬃcult to deal with than is recovery of batch transactions. Is there a simple way to deal with this diﬃculty? (Hint: Consider an automatic teller machine transaction in which cash is withdrawn.)</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;">19.11 <span class="p">Sometimes a transaction has to be undone after it has committed because it was erroneously executed — for example, because of erroneous input by a bank teller.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 150pt;text-indent: -18pt;text-align: justify;">a.  Give an example to show that using the normal transaction undo mech- anism to undo such a transaction could lead to an inconsistent state.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -19pt;text-align: justify;">b.  One way to handle this situation is to bring the whole database to a state prior to the commit of the erroneous transaction (called <i>point-in-time </i>re- covery). Transactions that committed later have their eﬀects rolled back with this scheme.</p><p style="padding-left: 150pt;text-indent: 13pt;text-align: justify;">Suggest a modiﬁcation to the recovery algorithm of Section 19.4 to implement point-in-time recovery using database dumps.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -18pt;text-align: justify;">c. Later nonerroneous transactions can be reexecuted logically, if the up- dates are available in the form of <span class="s44">SQL </span>but cannot be reexecuted using their log records. Why?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 124pt;text-indent: -35pt;text-align: justify;">19.12  <span class="p">The recovery techniques that we described assume that blocks are written atomically to disk. However, a block may be partially written when power fails, with some sectors written, and others not yet written.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 131pt;text-indent: 0pt;text-align: left;">a. What problems can partial block writes cause?</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -19pt;text-align: left;">b. Partial block writes can be detected using techniques similar to those used to validate sector reads. Explain how.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -18pt;text-align: left;">c.  Explain how <span class="s44">RAID </span>1 can be used to recover from a partially written block, restoring the block to either its old value or to its new value.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 124pt;text-indent: -35pt;text-align: justify;"><b>19.13  </b>The Oracle database system uses undo log records to provide a snapshot view of the database under snapshot isolation. The snapshot view seen by transac- tion <i>T</i><span class="s97">i </span>reﬂects updates of all transactions that had committed when <i>T</i><span class="s97">i </span>started</p><p style="padding-left: 124pt;text-indent: 0pt;line-height: 79%;text-align: justify;">and the updates of <i>T</i><span class="s97">i</span>; updates of all other transactions are not visible to <i>T</i><span class="s97">i</span>.</p><p style="padding-left: 140pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">Describe a scheme for buﬀer handling whereby transactions are given a</p><p style="padding-left: 124pt;text-indent: 0pt;text-align: justify;">snapshot view of pages in the buﬀer. Include details of how to use the log to generate the snapshot view. You can assume that operations as well as their undo actions aﬀect only one page.</p><p class="s64" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Exercises  <span class="s164">955</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part358.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part360.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
