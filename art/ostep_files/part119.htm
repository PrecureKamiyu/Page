<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>13.3 The Address Space</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part118.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part120.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">13.3 The Address Space</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">However, we have to keep those pesky users in mind, and doing so requires the OS to create an <b>easy to use </b>abstraction of physical memory. We call this abstraction the <b>address space</b>, and it is the running program’s view of memory in the system. Understanding this fundamental OS ab- straction of memory is key to understanding how memory is virtualized. The address space of a process contains all of the memory state of the running program. For example, the <b>code </b>of the program (the instruc- tions) have to live in memory somewhere, and thus they are in the ad- dress space. The program, while it is running, uses a <b>stack </b>to keep track of where it is in the function call chain as well as to allocate local variables and pass parameters and return values to and from routines. Finally, the <b>heap </b>is used for dynamically-allocated, user-managed memory, such as that you might receive from a call to <span class="s41">malloc() </span>in C or <span class="s41">new </span>in an object- oriented language such as C++ or Java. Of course, there are other things in there too (e.g., statically-initialized variables), but for now let us just</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">assume those three components: code, stack, and heap.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;text-align: justify;">In the example in Figure <span style=" color: #00AEEF;">13.3</span>, we have a tiny address space (only 16 KB)<span class="s35">1</span>. The program code lives at the top of the address space (starting at 0 in this example, and is packed into the first 1K of the address space).</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Code is static (and thus easy to place in memory), so we can place it at the top of the address space and know that it won’t need any more space as the program runs.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Next, we have the two regions of the address space that may grow (and shrink) while the program runs. Those are the heap (at the top) and the stack (at the bottom). We place them like this because each wishes to be able to grow, and by putting them at opposite ends of the address space, we can allow such growth: they just have to grow in opposite directions. The heap thus starts just after the code (at 1KB) and grows downward (say when a user requests more memory via <span class="s41">malloc()</span>); the stack starts at 16KB and grows upward (say when a user makes a proce- dure call). However, this placement of stack and heap is just a convention; you could arrange the address space in a different way if you’d like (as we’ll see later, when multiple <b>threads </b>co-exist in an address space, no nice way to divide the address space like this works anymore, alas).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Of course, when we describe the address space, what we are describ- ing is the <b>abstraction </b>that the OS is providing to the running program. The program really isn’t in memory at physical addresses 0 through 16KB; rather it is loaded at some arbitrary physical address(es). Examine pro- cesses A, B, and C in Figure <span style=" color: #00AEEF;">13.2</span>; there you can see how each process is loaded into memory at a different address. And hence the problem:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 65pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>V<span class="s7">IRTUALIZE </span>M<span class="s7">EMORY</span></p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: justify;">How can the OS build this abstraction of a private, potentially large address space for multiple running processes (all sharing memory) on top of a single, physical memory?</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">When the OS does this, we say the OS is <b>virtualizing memory</b>, because the running program thinks it is loaded into memory at a particular ad- dress (say 0) and has a potentially very large address space (say 32-bits or 64-bits); the reality is quite different.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">When, for example, process A in Figure <span style=" color: #00AEEF;">13.2 </span>tries to perform a load at address 0 (which we will call a <b>virtual address</b>), somehow the OS, in tandem with some hardware support, will have to make sure the load doesn’t actually go to physical address 0 but rather to physical address 320KB (where A is loaded into memory). This is the key to virtualization of memory, which underlies every modern computer system in the world.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_130.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: left;">1<span class="s12">We will often use small examples like this because it is a pain to represent a 32-bit address space and the numbers start to become hard to handle.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 82pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: T<span class="s7">HE </span>P<span class="s7">RINCIPLE OF </span>I<span class="s7">SOLATION</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Isolation is a key principle in building reliable systems. If two entities are properly isolated from one another, this implies that one can fail with- out affecting the other. Operating systems strive to isolate processes from each other and in this way prevent one from harming the other. By using memory isolation, the OS further ensures that running programs cannot affect the operation of the underlying OS. Some modern OS’s take iso- lation even further, by walling off pieces of the OS from other pieces of the OS. Such <b>microkernels </b>[BH70, R+89, S+03] thus may provide greater reliability than typical monolithic kernel designs.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part118.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part120.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
