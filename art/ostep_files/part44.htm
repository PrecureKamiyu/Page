<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>5.1 The fork() System Call</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part43.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part45.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 3pt;padding-left: 16pt;text-indent: 0pt;text-align: justify;">5.1 The <span class="s51">fork() </span>System Call</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 11pt;text-align: justify;">The <span class="s41">fork() </span>system call is used to create a new process [C63]. How- ever, be forewarned: it is certainly the strangest routine you will ever call<span class="s35">1</span>. More specifically, you have a running program whose code looks</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">like what you see in Figure <span style=" color: #00AEEF;">5.1</span>; examine the code, or better yet, type it in and run it yourself!</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_028.png"/></span></p><p class="s12" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 91%;text-align: justify;"><span class="s11">1</span>Well, OK, we admit that we don’t know that for sure; who knows what routines you call when no one is looking? But <span class="s38">fork() </span>is pretty odd, no matter how unusual your routine- calling patterns are.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 21pt;text-indent: 0pt;text-align: center;">35</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#include &lt;stdio.h&gt;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2  <span class="s38">#include &lt;stdlib.h&gt;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">#include &lt;unistd.h&gt;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">4</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5  <span class="s38">int</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">6  </span>main(int argc, char <span class="s39">*</span>argv[])</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">7  <span class="s38">{</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8    <span class="s38">printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9    <span class="s38">int rc = fork();</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10     <span class="s38">if (rc &lt; 0) {    // fork failed; exit</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11       <span class="s38">fprintf(stderr, &quot;fork failed\n&quot;);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">12       <span class="s38">exit(1);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">13     <span class="s38">} else if (rc == 0) { // child (new process)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">14       <span class="s38">printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">15     <span class="s38">} else {      // parent goes down this path (main)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">16       <span class="s38">printf(&quot;hello, I am parent of %d (pid:%d)\n&quot;,</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">17             <span class="s38">rc, (int) getpid());</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">18    <span class="s38">}</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">19    <span class="s38">return 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">20  <span class="s38">}</span></p><p class="s52" style="padding-left: 54pt;text-indent: 0pt;line-height: 10pt;text-align: center;"><span class="p">Figure 5.1: </span>p1.c<span class="s27">: Calling </span>fork()</p><p style="padding-top: 6pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">When you run this program (called <span class="s41">p1.c</span>), you’ll see the following:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; ./p1</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">hello world (pid:29146)</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">hello, I am parent of 29147 (pid:29146) hello, I am child (pid:29147)</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let us understand what happened in more detail in <span class="s41">p1.c</span>. When it first started running, the process prints out a hello world message; in- cluded in that message is its <b>process identifier</b>, also known as a <b>PID</b>. The process has a PID of 29146; in U<span class="s7">NIX </span>systems, the PID is used to name the process if one wants to do something with the process, such as (for example) stop it from running. So far, so good.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Now the interesting part begins. The process calls the <span class="s41">fork() </span>system call, which the OS provides as a way to create a new process. The odd part: the process that is created is an (almost) <i>exact copy of the calling pro- cess</i>. That means that to the OS, it now looks like there are two copies of the program <span class="s41">p1 </span>running, and both are about to return from the <span class="s41">fork() </span>system call. The newly-created process (called the <b>child</b>, in contrast to the creating <b>parent</b>) doesn’t start running at <span class="s41">main()</span>, like you might expect (note, the “hello, world” message only got printed out once); rather, it just comes into life as if it had called <span class="s41">fork() </span>itself.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">You might have noticed: the child isn’t an <i>exact </i>copy. Specifically, al- though it now has its own copy of the address space (i.e., its own private memory), its own registers, its own PC, and so forth, the value it returns to the caller of <b>fork() </b>is different. Specifically, while the parent receives the PID of the newly-created child, the child is simply returned a 0. This differentiation is useful, because it is simple then to write the code that handles the two different cases (as above).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#include &lt;stdio.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">#include &lt;stdlib.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3  <span class="s38">#include &lt;unistd.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4  <span class="s38">#include &lt;sys/wait.h&gt;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">5</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6  <span class="s38">int</span></p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">7  </span>main(int argc, char <span class="s39">*</span>argv[])</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">8  <span class="s38">{</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">9    <span class="s38">printf(&quot;hello world (pid:%d)\n&quot;, (int) getpid());</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10    <span class="s38">int rc = fork();</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11     <span class="s38">if (rc &lt; 0) {    // fork failed; exit</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12       <span class="s38">fprintf(stderr, &quot;fork failed\n&quot;);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">13       <span class="s38">exit(1);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14     <span class="s38">} else if (rc == 0) { // child (new process)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15       <span class="s38">printf(&quot;hello, I am child (pid:%d)\n&quot;, (int) getpid());</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16     <span class="s38">} else {      // parent goes down this path (main)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">17       <span class="s38">int wc = wait(NULL);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">18       <span class="s38">printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;,</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19             <span class="s38">rc, wc, (int) getpid());</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">20    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">21    <span class="s38">return 0;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">22  <span class="s38">}</span></p><p class="s52" style="padding-left: 89pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="p">Figure 5.2: </span>p2.c<span class="s27">: Calling </span>fork() <span class="s27">And </span>wait()</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">You might also have noticed: the output is not <b>deterministic</b>. When the child process is created, there are now two active processes in the sys- tem that we care about: the parent and the child. Assuming we are run- ning on a system with a single CPU (for simplicity), then either the child or the parent might run at that point. In our example (above), the parent did and thus printed out its message first. In other cases, the opposite might happen, as we show in this output trace:</p><p class="s38" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">prompt&gt; ./p1</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">hello world (pid:29146) hello, I am child (pid:29147)</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">hello, I am parent of 29147 (pid:29146) prompt&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The CPU <b>scheduler</b>, a topic we’ll discuss in great detail soon, deter- mines which process runs at a given moment in time; because the sched- uler is complex, we cannot usually make strong assumptions about what it will choose to do, and hence which process will run first. This <b>non- determinism</b>, as it turns out, leads to some interesting problems, par- ticularly in <b>multi-threaded programs</b>; hence, we’ll see a lot more non- determinism when we study <b>concurrency </b>in the second part of the book.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part43.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part45.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
