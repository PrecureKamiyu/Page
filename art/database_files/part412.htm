<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part411.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part413.htm">下一个 &gt;</a></p><p class="s45" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">Exercises</p><p class="s169" style="padding-top: 10pt;padding-left: 120pt;text-indent: 0pt;text-align: left;"><span class="s46">22.12 </span><span class="p">Can partitioned join be used for </span><span class="s13">r </span><span class="s86">⋈</span>r<span class="s170">.</span>A<span class="s170">&lt;</span>s<span class="s170">.</span>A<span class="s171">∧</span>r<span class="s170">.</span>B<span class="s171">=</span>s<span class="s170">.</span>B <span class="s168">s</span><span class="p">? Explain your answer.</span></p><p class="s46" style="padding-left: 120pt;text-indent: 0pt;text-align: left;">22.13  <span class="p">Describe a good way to parallelize each of the following:</span></p><p style="padding-top: 9pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">a. The diﬀerence operation</p><p style="padding-top: 6pt;padding-left: 162pt;text-indent: 0pt;text-align: left;">b. Aggregation by the <b>count </b>operation</p><p style="padding-top: 6pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">c. Aggregation by the <b>count distinct </b>operation</p><p style="padding-top: 6pt;padding-left: 162pt;text-indent: 0pt;text-align: left;">d. Aggregation by the <b>avg </b>operation</p><p style="padding-top: 6pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">e.  Left outer join, if the join condition involves only equality</p><p style="padding-top: 6pt;padding-left: 182pt;text-indent: -17pt;text-align: left;">f. Left outer join, if the join condition involves comparisons other than equality</p><p style="padding-top: 6pt;padding-left: 182pt;text-indent: -18pt;text-align: left;">g. Full outer join, if the join condition involves comparisons other than equality</p><p class="s46" style="padding-top: 9pt;padding-left: 156pt;text-indent: -35pt;text-align: justify;">22.14  <span class="p">Suppose you wish to handle a workload consisting of a large number of small transactions by using shared-nothing parallelism.</span></p><p style="padding-top: 9pt;padding-left: 182pt;text-indent: -18pt;text-align: justify;">a. Is intraquery parallelism required in such a situation? If not, why, and what form of parallelism is appropriate?</p><p style="padding-top: 6pt;padding-left: 162pt;text-indent: 0pt;text-align: justify;">b.  What form of skew would be of signiﬁcance with such a workload?</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3254.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3255.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3256.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3257.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3258.png"/></span></p><p style="padding-top: 6pt;padding-left: 182pt;text-indent: -18pt;text-align: justify;">c. Suppose most transactions accessed one <i>account </i>record, which includes an <i>account type </i>attribute, and an associated <i>account type master </i>record, which provides information about the account type. How would you par- tition and/or replicate data to speed up transactions? You may assume that the <i>account type master </i>relation is rarely updated.</p><p class="s46" style="padding-top: 9pt;padding-left: 156pt;text-indent: -35pt;text-align: justify;">22.15 <span class="p">What is the motivation for work-stealing with virtual nodes in a shared-memory setting? Why might work-stealing not be as eﬃcient in a shared-nothing set- ting?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 156pt;text-indent: -35pt;text-align: justify;">22.16  <span class="p">The attribute on which a relation is partitioned can have a signiﬁcant impact on the cost of a query.</span></p><p style="padding-top: 9pt;padding-left: 182pt;text-indent: -18pt;text-align: justify;">a. Given a workload of <span class="s44">SQL </span>queries on a single relation, what attributes would be candidates for partitioning?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 150pt;text-indent: -19pt;text-align: left;">b.  How would you choose between the alternative partitioning techniques, based on the workload?</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -18pt;text-align: left;">c.  Is it possible to partition a relation on more than one attribute? Explain your answer.</p><p style="padding-top: 7pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;"><b>22.17  </b>Consider system that is processing a stream of tuples for a relation <i>r </i>with attributes (<i>A</i>, <i>B</i>, <i>C</i>, <i>timestamp</i>) Suppose the goal of a parallel stream processing system is to compute the number of tuples for each <i>A </i>value in each 5 minute window (based on the timestamp of the tuple). What would be the topic and the topic partitions? Explain why.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part411.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part413.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
