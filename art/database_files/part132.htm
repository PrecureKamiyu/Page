<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>6.1   Overview of the Design Process</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part131.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part133.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">6.1   <span style=" color: #00AEEF;">Overview of the Design Process</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The task of creating a database application is a complex one, involving design of the database schema, design of the programs that access and update the data, and design of a security scheme to control access to data. The needs of the users play a central role in the design process. In this chapter, we focus on the design of the database schema, although we brieﬂy outline some of the other design tasks later in the chapter.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">6.1.1 Design Phases</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">For small applications, it may be feasible for a database designer who understands the application requirements to decide directly on the relations to be created, their attributes, and constraints on the relations. However, such a direct design process is diﬃcult for real-world applications, since they are often highly complex. Often no one person understands the complete data needs of an application. The database designer must interact with users of the application to understand the needs of the applica- tion, represent them in a high-level fashion that can be understood by the users, and</p><p class="s20" style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">241</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">then translate the requirements into lower levels of the design. A high-level data model serves the database designer by providing a conceptual framework in which to specify, in a systematic fashion, the data requirements of the database users, and a database structure that fulﬁlls these requirements.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The initial phase of database design is to characterize fully the data needs of the prospective database users. The database designer needs to interact extensively with domain experts and users to carry out this task. The outcome of this phase is a speciﬁcation of user requirements. While there are techniques for diagrammati- cally representing user requirements, in this chapter we restrict ourselves to textual descriptions of user requirements.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Next, the designer chooses a data model and, by applying the concepts of the cho- sen data model, translates these requirements into a conceptual schema of the database. The schema developed at this </span><span class="s63">conceptual-design </span><span class="p">phase provides a de- tailed overview of the enterprise. The entity-relationship model, which we study in the rest of this chapter, is typically used to represent the conceptual design. Stated in terms of the entity-relationship model, the conceptual schema speciﬁes the enti- ties that are represented in the database, the attributes of the entities, the relation- ships among the entities, and constraints on the entities and relationships. Typi- cally, the conceptual-design phase results in the creation of an entity-relationship diagram that provides a graphic representation of the schema.</span></p><p style="padding-left: 107pt;text-indent: 16pt;text-align: justify;">The designer reviews the schema to conﬁrm that all data requirements are indeed satisﬁed and are not in conﬂict with one another. She can also examine the design to remove any redundant features. Her focus at this point is on describing the data and their relationships, rather than on specifying physical storage details.</p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">A fully developed conceptual schema also indicates the functional requirements of the enterprise. In a </span><span class="s63">specification of functional requirements</span><span class="p">, users describe the kinds of operations (or transactions) that will be performed on the data. Example operations include modifying or updating data, searching for and retrieving spe- ciﬁc data, and deleting data. At this stage of conceptual design, the designer can review the schema to ensure that it meets functional requirements.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The process of moving from an abstract data model to the implementation of the database proceeds in two ﬁnal design phases.</span></p><p class="s50" style="padding-top: 9pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: justify;">° <span class="s51">In the </span><span class="s63">logical-design phase</span><span class="p">, the designer maps the high-level conceptual schema onto the implementation data model of the database system that will be used.</span></p><p style="padding-left: 122pt;text-indent: 0pt;text-align: justify;">The implementation data model is typically the relational data model, and this step typically consists of mapping the conceptual schema deﬁned using the entity-relationship model into a relation schema.</p><p class="s50" style="padding-top: 8pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: justify;">° <span class="s51">Finally, the designer uses the resulting system-speciﬁc database schema in the subsequent </span><span class="s63">physical-design phase</span><span class="p">, in which the physical features of the database</span></p><p class="s66" style="padding-top: 3pt;padding-left: 316pt;text-indent: 0pt;text-align: left;">6.1 <span style=" color: #00AEEF;">Overview of the Design Process  </span><span class="s164">243</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 153pt;text-indent: 0pt;text-align: left;">are speciﬁed. These features include the form of ﬁle organization and choice of index structures, discussed in Chapter 13 and Chapter 14.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The physical schema of a database can be changed relatively easily after an applica- tion has been built. However, changes to the logical schema are usually harder to carry out, since they may aﬀect a number of queries and updates scattered across application code. It is therefore important to carry out the database design phase with care, before building the rest of the database application.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">6.1.2 Design Alternatives</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">A major part of the database design process is deciding how to represent in the design the various types of “things” such as people, places, products, and the like. We use the term <i>entity </i>to refer to any such distinctly identiﬁable item. In a university database, examples of entities would include instructors, students, departments, courses, and course oﬀerings. We assume that a course may have run in multiple semesters, as well as multiple times in a semester; we refer to each such oﬀering of a course as a section. The various entities are related to each other in a variety of ways, all of which need to be captured in the database design. For example, a student takes a course oﬀering, while an instructor teaches a course oﬀering; teaches and takes are examples of relationships between entities.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">In designing a database schema, we must ensure that we avoid two major pitfalls:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span style=" color: #231F20;">Redundancy: </span><span class="p">A bad design may repeat information. For example, if we store the course identiﬁer and title of a course with each course oﬀering, the title would be stored redundantly (i.e., multiple times, unnecessarily) with each course oﬀering. It would suﬃce to store only the course identiﬁer with each course oﬀering, and to associate the title with the course identiﬁer only once, in a course entity.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1362.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1363.png"/></span></p><p style="padding-left: 145pt;text-indent: 14pt;text-align: justify;">Redundancy can also occur in a relational schema. In the university example we have used so far, we have a relation with section information and a separate relation with course information. Suppose that instead we have a single relation where we repeat all of the course information (course id, title, dept name, credits) once for each section (oﬀering) of the course. Information about courses would then be stored redundantly.</p><p style="padding-left: 145pt;text-indent: 13pt;text-align: justify;">The biggest problem with such redundant representation of information is that the copies of a piece of information can become inconsistent if the information is updated without taking precautions to update all copies of the information. For example, diﬀerent oﬀerings of a course may have the same course identiﬁer, but may have diﬀerent titles. It would then become unclear what the correct title of the course is. Ideally, information should appear in exactly one place.</p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span style=" color: #231F20;">Incompleteness: </span><span class="p">A bad design may make certain aspects of the enterprise diﬃ- cult or impossible to model. For example, suppose that, as in case (1) above, we only had entities corresponding to course oﬀering, without having an entity</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 113pt;text-indent: 0pt;text-align: justify;"><a name="bookmark120">corresponding to courses. Equivalently, in terms of relations, suppose we have a single relation where we repeat all of the course information once for each section that the course is oﬀered. It would then be impossible to represent infor- mation about a new course, unless that course is oﬀered. We might try to make do with the problematic design by storing null values for the section information. Such a work-around is not only unattractive but may be prevented by primary-key constraints.</a><a name="bookmark149">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Avoiding bad designs is not enough. There may be a large number of good designs from which we must choose. As a simple example, consider a customer who buys a product. Is the sale of this product a relationship between the customer and the prod- uct? Alternatively, is the sale itself an entity that is related both to the customer and to the product? This choice, though simple, may make an important diﬀerence in what aspects of the enterprise can be modeled well. Considering the need to make choices such as this for the large number of entities and relationships in a real-world enterprise, it is not hard to see that database design can be a challenging problem. Indeed we shall see that it requires a combination of both science and “good taste.”</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part131.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part133.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
