<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.4 A Memory Trace</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part184.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part186.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">18.4 A Memory Trace</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Before closing, we now trace through a simple memory access exam- ple to demonstrate all of the resulting memory accesses that occur when using paging. The code snippet (in C, in a file called <span class="s41">array.c</span>) that are interested in is as follows:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">int array[1000];</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">...</p><p class="s38" style="padding-left: 85pt;text-indent: -16pt;text-align: left;">for (i = 0; i &lt; 1000; i++) array[i] = 0;</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We could then compile <span class="s41">array.c </span>and run it with the following com- mands:</p><p class="s38" style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; gcc -o array array.c -Wall -O prompt&gt; ./array</p><p style="padding-top: 6pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Of course, to truly understand what memory accesses this code snip- pet (which simply initializes an array) will make, we’ll have to know (or assume) a few more things. First, we’ll have to <b>disassemble </b>the result- ing binary (using <span class="s41">objdump </span>on Linux, or <span class="s41">otool </span>on a Mac) to see what assembly instructions are used to initialize the array in a loop. Here it the resulting assembly code:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">0x1024 movl $0x0,(%edi,%eax,4) 0x1028 incl %eax</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">0x102c cmpl $0x03e8,%eax 0x1030 jne 0x1024</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">The code, if you know a little <b>x86</b>, is actually quite easy to understand. The first instruction moves the value zero (shown as <span class="s41">$0x0</span>) into the vir- tual memory address of the location of the array; this address is computed by taking the contents of <span class="s41">%edi </span>and adding <span class="s41">%eax </span>multiplied by four to it. Thus, <span class="s41">%edi </span>holds the base address of the array, whereas <span class="s41">%eax </span>holds the array index (<span class="s41">i</span>); we multiply by four because the array is an array of inte- gers, each size four bytes (note we are cheating a little bit here, assuming each instruction is four bytes in size for simplicity; in actuality, x86 in- structions are variable-sized).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">The second instruction increments the array index held in <span class="s41">%eax</span>, and the third instruction compares the contents of that register to the hex value <span class="s41">0x03e8</span>, or decimal 1000. If the comparison shows that that two values are not yet equal (which is what the <span class="s41">jne </span>instruction tests), the fourth instruction jumps back to the top of the loop.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">To understand which memory accesses this instruction sequence makes (at both the virtual and physical levels), we’ll have assume something about where in virtual memory the code snippet and array are found, as well as the contents and location of the page table.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">For this example, we assume a virtual address space of size 64 KB (unrealistically small). We also assume a page size of 1 KB.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">All we need to know now are the contents of the page table, and its location in physical memory. Let’s assume we have a linear (array-based) page table and that it is located at physical address 1 KB (1024).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As for its contents, there are just a few virtual pages we need to worry about having mapped for this example. First, there is the virtual page the code lives on. Because the page size is 1 KB, virtual address 1024 resides on the the second page of the virtual address space (VPN=1, as VPN=0 is the first page). Let’s assume this virtual page maps to physical frame 4 (VPN 1 <span class="s4">→ </span>PFN 4).</p><p class="s105" style="padding-left: 41pt;text-indent: 11pt;line-height: 91%;text-align: justify;"><span class="p">Next, there is the array itself. Its size is 4000 bytes (1000 integers), and it lives at virtual addresses 40000 through 44000 (not including the last byte). The virtual pages for this decimal range is VPN=39 ... VPN=42. Thus, we need mappings for these pages. Let’s assume these virtual-to- physical mappings for the example: </span><span class="s104">(VPN 39 </span>→ <span class="s5">PFN 7), (VPN 40 </span>→ <span class="s5">PFN 8), (VPN 41 </span>→ <span class="s5">PFN 9), (VPN 42 </span>→ <span class="s5">PFN 10).</span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We are now ready to trace the memory references of the program. When it runs, each instruction fetch will generate two memory references: one to the page table to find the physical frame that the instruction resides within, and one to the instruction itself to fetch it to the CPU for process- ing. In addition, there is one explicit memory reference in the form of the <span class="s41">mov </span>instruction; this adds another page table access first (to translate the array virtual address to the correct physical one) and then the array access itself.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">PageTable[39]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="6" alt="image" src="Image_245.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="6" alt="image" src="Image_246.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="6" alt="image" src="Image_247.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="279" height="104" alt="image" src="Image_248.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="6" alt="image" src="Image_249.png"/></span></p><p class="s65" style="text-indent: 0pt;line-height: 6pt;text-align: left;">PageTable[1]</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">1224</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Page Table (PA)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">1174</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">1124</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">1074</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Array (VA)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">40100</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">40050</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">40000</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Code (VA)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">1124</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">1074</p><p class="s47" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">1024</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="257" height="51" alt="image" src="Image_250.png"/></span></p><p class="s91" style="padding-left: 1pt;text-indent: 0pt;line-height: 7pt;text-align: left;">mov</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Array (PA)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">7132</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">7282</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">7232</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="257" height="52" alt="image" src="Image_251.png"/></span></p><p class="s91" style="padding-left: 1pt;text-indent: 0pt;line-height: 7pt;text-align: left;">mov</p><p style="text-indent: 0pt;text-align: left;"/><p class="s91" style="padding-left: 1pt;text-indent: 3pt;text-align: justify;">inc cmp jne</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Code (PA)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">4196</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">4146</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 4pt;padding-left: 98pt;text-indent: 0pt;line-height: 8pt;text-align: left;">1024</p><p class="s47" style="padding-left: 117pt;text-indent: 0pt;line-height: 8pt;text-align: left;">0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">10    20    30</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">40    50</p><p class="s47" style="padding-top: 4pt;text-indent: 0pt;text-align: left;">4096</p><p class="s47" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Memory Access</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 107pt;text-indent: 0pt;text-align: left;">Figure 18.7: <b>A Virtual (And Physical) Memory Trace</b></p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The entire process, for the first five loop iterations, is depicted in Fig- ure <span style=" color: #00AEEF;">18.7</span>. The bottom most graph shows the instruction memory refer- ences on the y-axis in black (with virtual addresses on the left, and the actual physical addresses on the right); the middle graph shows array accesses in dark gray (again with virtual on left and physical on right); fi- nally, the topmost graph shows page table memory accesses in light gray (just physical, as the page table in this example resides in physical mem- ory). The x-axis, for the entire trace, shows memory accesses across the first five iterations of the loop (there are 10 memory accesses per loop, which includes four instruction fetches, one explicit update of memory, and five page table accesses to translate those four fetches and one explicit update).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">See if you can make sense of the patterns that show up in this visu- alization. In particular, what will change as the loop continues to run beyond these first five iterations? Which new memory locations will be accessed? Can you figure it out?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This has just been the simplest of examples (only a few lines of C code), and yet you might already be able to sense the complexity of understand- ing the actual memory behavior of real applications. Don’t worry: it defi- nitely gets worse, because the mechanisms we are about to introduce only complicate this already complex machinery. Sorry!</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part184.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part186.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
