<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Beyond Libraries: Protection</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part27.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part29.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">Beyond Libraries: Protection</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In moving beyond being a simple library of commonly-used services, op- erating systems took on a more central role in managing machines. One important aspect of this was the realization that code run on behalf of the OS was special; it had control of devices and thus should be treated dif-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">ferently than normal application code. Why is this? Well, imagine if you allowed any application to read from anywhere on the disk; the notion of privacy goes out the window, as any program could read any file. Thus, implementing a <b>file system </b>(to manage your files) as a library makes little sense. Instead, something else was needed.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus, the idea of a <b>system call </b>was invented, pioneered by the Atlas computing system [K+61,L78]. Instead of providing OS routines as a li- brary (where you just make a <b>procedure call </b>to access them), the idea here was to add a special pair of hardware instructions and hardware state to make the transition into the OS a more formal, controlled process.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The key difference between a system call and a procedure call is that a system call transfers control (i.e., jumps) into the OS while simultane- ously raising the <b>hardware privilege level</b>. User applications run in what is referred to as <b>user mode </b>which means the hardware restricts what ap- plications can do; for example, an application running in user mode can’t typically initiate an I/O request to the disk, access any physical memory page, or send a packet on the network. When a system call is initiated (usually through a special hardware instruction called a <b>trap</b>), the hard- ware transfers control to a pre-specified <b>trap handler </b>(that the OS set up previously) and simultaneously raises the privilege level to <b>kernel mode</b>. In kernel mode, the OS has full access to the hardware of the system and thus can do things like initiate an I/O request or make more memory available to a program. When the OS is done servicing the request, it passes control back to the user via a special <b>return-from-trap </b>instruction, which reverts to user mode while simultaneously passing control back to where the application left off.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part27.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part29.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
