<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>The Era of Multiprogramming</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part28.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part30.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">The Era of Multiprogramming</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Where operating systems really took off was in the era of computing be- yond the mainframe, that of the <b>minicomputer</b>. Classic machines like the PDP family from Digital Equipment made computers hugely more affordable; thus, instead of having one mainframe per large organization, now a smaller collection of people within an organization could likely have their own computer. Not surprisingly, one of the major impacts of this drop in cost was an increase in developer activity; more smart people got their hands on computers and thus made computer systems do more interesting and beautiful things.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">In particular, <b>multiprogramming </b>became commonplace due to the de- sire to make better use of machine resources. Instead of just running one job at a time, the OS would load a number of jobs into memory and switch rapidly between them, thus improving CPU utilization. This switching was particularly important because I/O devices were slow; having a pro- gram wait on the CPU while its I/O was being serviced was a waste of CPU time. Instead, why not switch to another job and run it for a while?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">The desire to support multiprogramming and overlap in the presence of I/O and interrupts forced innovation in the conceptual development of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">operating systems along a number of directions. Issues such as <b>memory protection </b>became important; we wouldn’t want one program to be able to access the memory of another program. Understanding how to deal with the <b>concurrency </b>issues introduced by multiprogramming was also critical; making sure the OS was behaving correctly despite the presence of interrupts is a great challenge. We will study these issues and related topics later in the book.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One of the major practical advances of the time was the introduction of the U<span class="s7">NIX </span>operating system, primarily thanks to Ken Thompson (and Dennis Ritchie) at Bell Labs (yes, the phone company). U<span class="s7">NIX </span>took many good ideas from different operating systems (particularly from Multics [O72], and some from systems like TENEX [B+72] and the Berkeley Time- Sharing System [S+68]), but made them simpler and easier to use. Soon this team was shipping tapes containing U<span class="s7">NIX </span>source code to people around the world, many of whom then got involved and added to the</p><p style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">system themselves; see the <b>Aside </b>(next page) for more detail<span class="s35">10</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part28.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part30.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
