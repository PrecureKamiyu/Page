<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>15</title>
    
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <div class="tocheadb">
    <h1 class="tochead" id="heading_id_2"><a id="pgfId-998817"></a><a id="pgfId-998829"></a>15 Graph embeddings and planarity: <a id="id_Hlk34483691"></a>Drawing graphs with minimal edge intersections</h1>
  </div>

  <p class="co-summary-head"><a id="pgfId-1013946"></a>This chapter covers</p>

  <ul class="calibre19">
    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1013982"></a>Embedding graphs on a 2-D plane</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1013983"></a>Defining graph planarity</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1013984"></a>Introducing complete and bipartite complete graphs</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1013985"></a>Discussing algorithms to find out if a graph is planar</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1013986"></a>Defining minimum crossing number for non-planar graphs</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1013971"></a>Implementing algorithms to detect crossing edges</li>
  </ul>

  <p class="body"><a id="pgfId-998939"></a>Now that we have introduced graphs properly in chapter 14, we are ready to take the next step: drawing a graph. So far we’ve talked about graphs in abstract terms, yet we had to visualize them in a certain way to describe how shortest path algorithms work. In chapter 14 we did it manually and took it for granted, but what about an automated approach to embed these data structures in a Euclidean space, and in particular in the 2-D plane?</p>

  <p class="body"><a id="pgfId-998956"></a>This is not always needed for all graph applications, nor it is always possible; there are, however, many applications where the way we lay a graph’s vertices and edges on a surface is crucial. Take, for instance, <i class="calibre17">printed circuits board</i><a id="marker-1006991"></a> (<i class="calibre17">PCB</i>) design, shown in figure 15.1. The way electronic components (vertices) and conductive tracks (edges) are positioned on the board is crucial not just to the good functioning of the circuit, but also to optimizing the manufacturing process and reducing the amount of copper used, as well as the overall costs.</p>

  <p class="body"><a id="pgfId-998981"></a>In this chapter, we are going to gradually introduce the main concepts about graph embeddings, focusing on 2-D planes, planar graphs, and how to minimize the intersections of the edges when a graph is not planar.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F1.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028007"></a>Figure 15.1 An example of an electronic circuit, and a graph embedding from which the circuit’s layout may have been derived. Looking at the graph, all electronic components have a vertex dual (with different shaded colors by type), and the joints have been modeled with vertices on the graph (to cope with the fact that we need to restrict to horizontal and vertical segments for conductive tracks).</p>

  <p class="body"><a id="pgfId-999015"></a>While we explain these concepts, we’ll also lay the groundwork to build an application that takes a graph and displays it nicely on the screen (or, equivalently, on paper).</p>

  <h2 class="fm-head" id="heading_id_3"><a id="pgfId-999026"></a>15.1 Graph embeddings</h2>

  <p class="body"><a id="pgfId-999040"></a>Graphs <a id="marker-1006995"></a><a id="marker-1006999"></a>are an amazing data structure. In chapter 14 we just scratched the surface, talking about Dijkstra’s<a id="marker-1007003"></a><a id="marker-1007007"></a> and A*, and there are many other cool applications for graphs. You must have heard of knowledge graphs,<a href="#pgfId-1007520"><sup class="footnotenumber">1</sup></a> or graph databases<a href="#pgfId-1007534"><sup class="footnotenumber">2</sup></a> such as Neo4J, just to name a few that are hyped these days.</p>

  <p class="body"><a id="pgfId-999077"></a>But graphs are also used to model more tangible applications; for example, a printed circuit board can be represented as a graph, where electronic components are the vertices, and conductive tracks on the board (usually made out of copper) are the edges.<a href="#pgfId-1007556"><sup class="footnotenumber">3</sup></a></p>

  <p class="body"><a id="pgfId-999088"></a>Besides that, we as humans often need to visualize a graph for better comprehension. Consider, for instance, a flow chart (which, not surprisingly, is a graph), like the one shown in figure 15.2.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F2.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028057"></a>Figure 15.2 A flow chart (in this example, one for the algorithm computing the greatest common divisor<a id="marker-1028058"></a> (GCD) of two numbers) is a special type of graph.</p>

  <p class="body"><a id="pgfId-999125"></a>When we can visualize it, it’s easy both to follow the flow and to get a high-level idea of its overall structure. Check out its formal definition, in terms of graph’s vertices and edges:</p>
  <pre class="programlisting">G = (
V = [Start, A, B, A==B, A&lt;B, swap(A,B), A=A-B, Output: B, End],   
E = [Start -&gt; A, A -&gt; B, A==B -[Yes]-&gt; Output: B, A==B -[No]-&gt; Output: B, 
<span class="fm-code-continuation-arrow">➥</span> A&lt;B -[Yes]-&gt; swap(A,B), A&lt;B -[No]-&gt; A=A-B, swap(A,B) -&gt; A=A-B, A=A-B -&gt; 
<span class="fm-code-continuation-arrow">➥</span> A==B, Output: B -&gt; End]
)</pre>

  <p class="body"><a id="pgfId-999171"></a>Was it as easy to understand as looking at its drawing?</p>

  <p class="body"><a id="pgfId-999180"></a>I think that we can agree there is fundamental value in drawing graphs, at least when we are supposed to understand and manually process them. Although this is not always the case,<a href="#pgfId-1007571"><sup class="footnotenumber">4</sup></a> there are many examples where we do want to visualize graphs, for instance in flow charts, UML diagrams, PERT charts, and so on.</p>

  <p class="body"><a id="pgfId-999197"></a>The next thing we need to agree (or not) upon is that not all visualizations are equally useful. Look at figure 15.3 and compare it to figure 15.2. I don’t know about you, but rather than using the diagram in figure 15.3, I might as well look at the definition of the graph: that’s how confusing it feels.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F3.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028100"></a>Figure 15.3 The same flow chart as in figure 15.2, but with a different layout. Can you still make sense of it?</p>

  <p class="body"><a id="pgfId-999234"></a>The key difference between the two layouts is that in figure 15.3, edges cross each other multiple times, making it difficult to follow them. In figure 15.2, no edges were crossing—this is a <i class="calibre17">planar embedding</i><a id="marker-1007015"></a> for a <i class="calibre17">planar graph</i><a id="marker-1007019"></a>! Don’t worry, we’ll define those in a minute. Before that, there is one further consideration: the drawing could get even worse, if you think about it—at least in figure 15.3, edges don’t overlap with vertices.</p>

  <h3 class="fm-head2" id="heading_id_4"><a id="pgfId-999261"></a>15.1.1 Some basic definitions</h3>

  <p class="body"><a id="pgfId-999277"></a>In <a id="marker-1007023"></a><a id="marker-1007027"></a>the previous section, we saw how drawing a graph without intersections between its edges makes the visualization a lot clearer. But is it always possible to do so to avoid these intersections?</p>

  <p class="body"><a id="pgfId-999289"></a>Hold on to this question; we’ll come back to it. Meanwhile, we can look at a couple of definitions that we’ll use during this and later chapters.</p>

  <p class="body"><a id="pgfId-999302"></a>Drawing a graph on a plane can be thought of as placing vertices on a 2-D Euclidean space. Informally, we can imagine each vertex as a point in <span class="cambria"><span class="cambria">ℝ</span><sup class="superscript">2</sup></span> (the set of all pairs of real numbers), and each edge as an arc (or a polyline) between two vertices.</p>

  <p class="body"><a id="pgfId-999315"></a>More formally, we can define a planar embedding as an isomorphism (a 1:1 mapping) between an abstract graph <code class="fm-code-in-text">G</code> and a plane graph <code class="fm-code-in-text">G’</code>.</p>

  <p class="body"><a id="pgfId-999328"></a>A plane graph, in turn, is defined as a pair of finite sets <code class="fm-code-in-text">(V, E)</code>, denoted as vertices and edges respectively, such that</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999339"></a><code class="fm-code-in-text">V</code> is a subset of <span class="cambria">ℝ</span><code class="fm-code-in-text"><sup class="superscript1">2</sup></code>.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999355"></a>Every edge <code class="fm-code-in-text">e</code> <span class="cambria">ϵ</span> <code class="fm-code-in-text">E</code> is a section of a <i class="calibre15">Jordan curve</i><a class="calibre14" id="marker-1007031"></a> passing through two vertices.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999375"></a>No two edges have the same pair of endpoints.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999387"></a>No edge intersects a vertex (other than its endpoints) or any other edge.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999399"></a>We still owe you a definition: a Jordan curve is a planar, simple and closed curve, a non-self-intersecting continuous loop in the plane. See figure 15.4 for a few examples.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F4.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028142"></a>Figure 15.4 Examples of Jordan and non-Jordan curves. A Jordan curve is a closed curve whose border doesn’t have intersection points (it’s not “twisted” like the last two examples). Notice how a rectangle (or any polygon’s perimeter) is a valid Jordan curve. For graphs’ edges we’ll use sections of Jordan curves, so the only restriction will be that it must not self-intersect in any point.</p>

  <p class="body"><a id="pgfId-999432"></a>A planar graph is thus defined as an abstract graph <code class="fm-code-in-text">G</code> for which there exists a planar embedding.</p>

  <p class="body"><a id="pgfId-999443"></a>Now back to our question, which we can reformulate using our definitions: Are all graphs planar?</p>

  <p class="body"><a id="pgfId-999454"></a>The answer is, unfortunately, no, not all graphs are planar. The first algorithm to check whether a graph is planar was given by the Polish mathematician <a id="id_Hlk56683062"></a>Kazimierz Kuratowski; his theorem characterizes planarity in terms of <i class="calibre17">forbidden graphs</i><a id="marker-1007035"></a>. It states, in fact, that for a graph to be planar, it can’t contain two specific non-planar graphs as its subgraphs.</p>

  <p class="body"><a id="pgfId-999474"></a>These two graphs are the simplest non-planar graphs: the complete graph <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> and the complete bipartite graph <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code>; Kuratowski’s theorem states that “a graph is planar if and only if it doesn’t contain as a subgraph neither <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> nor <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code>, nor any <i class="calibre17">subdivision</i> of those two graphs.”</p>

  <p class="body"><a id="pgfId-999500"></a>This was an amazing result, but to appreciate it better, we should first consider a few more <a id="marker-1007039"></a><a id="marker-1007043"></a>definitions.</p>

  <h3 class="fm-head2" id="heading_id_5"><a id="pgfId-999512"></a>15.1.2 Complete and bipartite graphs</h3>

  <p class="body"><a id="pgfId-999528"></a>A <a id="marker-1007047"></a><a id="marker-1007051"></a><a id="marker-1007055"></a><a id="marker-1007059"></a><i class="calibre17">complete graph</i> is a graph where each vertex is connected by an edge to each other vertex in the graph. In these graphs, the number of edges is maximal for simple graphs, being quadratic with respect to the number of vertices: <code class="fm-code-in-text">|E| = O(|V|<sup class="superscript1">2</sup>)</code>.</p>

  <p class="body"><a id="pgfId-999551"></a>Notice, however, that a complete graph doesn’t contain loops; therefore, the exact number of edges of a complete graph with <code class="fm-code-in-text">n</code> vertices is <code class="fm-code-in-text">n * (n-1) / 2</code>, where <code class="fm-code-in-text">|V| == n</code>.</p>

  <p class="body"><a id="pgfId-999566"></a>Complete graphs are denoted with the letter <code class="fm-code-in-text">K</code>, from Kuratowski’s initials, and a subscript that indicates the number of vertices in the graph; therefore, <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> (figure 15.5) denotes the complete graph with 5 vertices, and in general, <code class="fm-code-in-text">K<sub class="subscript1">n</sub></code> is the complete graph with <code class="fm-code-in-text">n</code> vertices.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F5.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028184"></a>Figure 15.5 An embedding of a complete graph with 5 vertices. Is this the best way to draw it?</p>

  <p class="body"><a id="pgfId-999612"></a>A <i class="calibre17">bipartite graph</i> is a connected graph where vertices can be partitioned into two groups, let’s call them <code class="fm-code-in-text">A</code> and <code class="fm-code-in-text">B</code>, such that vertices in group <code class="fm-code-in-text">A</code> are only connected to vertices in group <code class="fm-code-in-text">B</code> (in other words, each vertex in group <code class="fm-code-in-text">A</code> can’t have any edge to another vertex within group <code class="fm-code-in-text">A</code>, and likewise for group <code class="fm-code-in-text">B</code>).</p>

  <p class="body"><a id="pgfId-999637"></a>A <i class="calibre17">complete bipartite graph</i> just has all the possible edges between the two groups of vertices—again, loops are not allowed.</p>

  <p class="body"><a id="pgfId-999650"></a><code class="fm-code-in-text">K<sub class="subscript1">n,m</sub></code> is the generic complete bipartite graph with two partitions of <code class="fm-code-in-text">n</code> and <code class="fm-code-in-text">m</code> vertices each, and <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code> (figure 15.6) is the complete bipartite graph with two partitions having 3 vertices each.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F6.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028224"></a>Figure 15.6 An embedding of <code class="fm-code-in-text">K3,3</code>. Again, do you think there could be a more convenient embedding for this graph?</p>

  <p class="body"><a id="pgfId-999693"></a>A complete bipartite graph whose partitions have size <code class="fm-code-in-text">n</code> and <code class="fm-code-in-text">m</code> has exactly <code class="fm-code-in-text">n * m</code> edges.</p>

  <p class="body"><a id="pgfId-999711"></a>The generic <i class="calibre17">embedding</i> (not necessarily planar) is defined similarly to what we did in the previous section; it’s an isomorphism <code class="fm-code-in-text">Γ</code> between a graph <code class="fm-code-in-text">G</code> and a subset <code class="fm-code-in-text">G’=(V,E)</code> of <span class="cambria">ℝ</span><code class="fm-code-in-text"><sup class="superscript1">2</sup></code>, such that:</p>

  <ol class="calibre18">
    <li class="fm-list-numbered">
      <p class="list"><a class="calibre14" id="pgfId-999738"></a><code class="fm-code-in-text">V</code> is a subset of <span class="cambria">ℝ</span><code class="fm-code-in-text"><sup class="superscript1">2</sup></code></p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999753"></a>Every edge <code class="fm-code-in-text">e</code> <span class="cambria">ϵ</span> <code class="fm-code-in-text">E</code> is a section of a Jordan curve<a class="calibre14" id="marker-1007063"></a><a class="calibre14" href="#pgfId-1007593"><sup class="footnotenumber">5</sup></a> between two vertices.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999774"></a>No two edges have the same pair of endpoints.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999787"></a>No edge intersects a vertex (other than its endpoints).</p>
    </li>
  </ol>

  <p class="body"><a id="pgfId-999800"></a>Basically, with respect to the definition of a plane graph and planar embedding given in section 15.1.1, we only waive the requirement that no edges can <a id="marker-1007067"></a><a id="marker-1007071"></a><a id="marker-1007075"></a><a id="marker-1007079"></a>ever <a id="marker-1007083"></a><a id="marker-1007087"></a>cross.</p>

  <h2 class="fm-head" id="heading_id_6"><a id="pgfId-999817"></a>15.2 Planar graphs</h2>

  <p class="body"><a id="pgfId-999831"></a>Kuratowski’s <a id="marker-1007091"></a><a id="marker-1007095"></a>theorem might seem counterintuitive, defining a planar graph in terms of what it can’t contain. It was, however, an important tool to</p>

  <ol class="calibre18">
    <li class="fm-list-numbered">
      <p class="list"><a class="calibre14" id="pgfId-999844"></a>Recognize that two categories of graphs (complete and complete bipartite) are non-planar (except for their smallest specimens), and there’s no need to try to find ways to avoid intersections when drawing them.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999859"></a>Mathematically prove when a graph isn’t planar.</p>
    </li>
  </ol>

  <p class="body"><a id="pgfId-999871"></a>Although it was a great tool for mathematical proofs, using it for an algorithm that automatically checks if a graph is planar was another story.</p>

  <p class="body"><a id="pgfId-999880"></a>We’ll see how to implement a planarity testing algorithm later in this section. First, let’s finish our discussion of Kuratowski’s graphs.</p>

  <p class="body"><a id="pgfId-999895"></a>If we look at figure 15.5, that embedding of <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> has 5 points where edges cross; for each abstract graph <code class="fm-code-in-text">G</code>, however, there are infinitely many possible embeddings. As you can imagine, there are infinitely many ways you can draw <code class="fm-code-in-text">G</code>, moving each vertex a little bit (or a large bit) in any direction, and even using a different curve for the edges (for instance, infinitely many curves instead of segments).</p>

  <p class="body"><a id="pgfId-999915"></a>This holds true for <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> as well, obviously. Now the point is, are all these embeddings equivalent, with respect to the way edges cross each other?</p>

  <p class="body"><a id="pgfId-999931"></a>Well, we already know a way to draw <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> so that 5 pairs of edges cross, so if we can find another way where its edges cross more, or less, we have evidence that not all embeddings are the same.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F7.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028283"></a>Figure 15.7 A better embedding for <code class="fm-code-in-text">K5</code>. In this case we have only one crossing point, indicated by the fat arrow. Notice that there are still infinitely many embeddings equivalent to this one.</p>

  <p class="body"><a id="pgfId-999943"></a>Long story short, figure 15.7 shows an embedding for <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> with just a single cross-point between two edges.</p>

  <p class="body"><a id="pgfId-999980"></a>Therefore, we can say that the answer to this question is no, they aren’t all equivalent. As a matter of fact, working to find the “best”<a href="#pgfId-1007615"><sup class="footnotenumber">6</sup></a> possible embedding for graphs will be our quest for the rest of this book.<a href="#pgfId-1007629"><sup class="footnotenumber">7</sup></a></p>

  <h3 class="fm-head2" id="heading_id_7"><a id="pgfId-999997"></a>15.2.1 Using Kuratowski’s theorem in practice</h3>

  <p class="body"><a id="pgfId-1000015"></a>Kuratowski’s <a id="marker-1007099"></a><a id="marker-1007103"></a><a id="marker-1007107"></a>theorem states that <code class="fm-code-in-text">K</code><a id="id_Hlk56667077"></a><code class="fm-code-in-text"><sub class="subscript1">5</sub></code> and <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code> are the “simplest” graphs that don’t have a planar embedding. What did he mean by “simplest”? Well, in this case it means that that there isn’t any smaller graph (meaning with fewer vertices or edges) that isn’t planar, and so every sub-graph of either K<code class="fm-code-in-text"><sub class="subscript1">5</sub></code> or K<code class="fm-code-in-text"><sub class="subscript1">3,3</sub></code> has a planar embedding.</p>

  <p class="body"><a id="pgfId-1000043"></a>I’ve always found it curious that there are two base cases. It wasn’t possible to find a single base graph because these two are fundamentally anisomorphic, but at the same time, it’s quite remarkable that any other non-planar graph can be reconducted just to these two.</p>

  <p class="body"><a id="pgfId-1000059"></a>You might wonder how we know both that there is no way to draw these graphs without intersections, and that there isn’t any simpler graph that’s not planar. Well, Kuratowski proved it, so we can trust his theorem.</p>

  <p class="body"><a id="pgfId-1000079"></a>But in case you still have doubts, you can also try to scramble the vertices in figure 15.7 and see if you can find a planar embedding; make yourself comfortable, because it might take a while, until you realize it’s not possible!</p>

  <p class="body"><a id="pgfId-1000092"></a>The other half of the claim, that there isn’t any smaller non-planar graph, is easier to show. Let’s focus on <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> and first look at a graph with fewer vertices, in particular <code class="fm-code-in-text">K<sub class="subscript1">4</sub></code>, shown in figure 15.8.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F8.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028328"></a>Figure 15.8 Two embeddings for <code class="fm-code-in-text">K4</code>. Although it would seem like a good candidate for non-planarity, it’s enough to move one vertex around to find a planar embedding, as shown on the right.</p>

  <p class="body"><a id="pgfId-1000134"></a>At first sight, if we draw this graph naively, it seems like it has a pair of crossing edges. It’s easy, however, to move one of the vertices past the crossing point to obtain a planar embedding.</p>

  <p class="body"><a id="pgfId-1000147"></a>The other possibility to rule out is that there is a non-planar graph with fewer edges than <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code>; however, if we look at figure 15.7, it’s immediately obvious that if we remove either edge 1-&gt;5 or edge 2-&gt;3, then we also get rid of the one intersection in the drawing, as shown in figure 15.9. Since a complete graph is symmetrical and relabeling-invariant,<a href="#pgfId-1007643"><sup class="footnotenumber">8</sup></a> we can obtain an equivalent embedding (ignoring the labels) regardless of which edge we remove from <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code>.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F9.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028377"></a>Figure 15.9 Any graph obtained by removing an edge from <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> can be embedded in the plane without any intersection.</p>

  <p class="body"><a id="pgfId-1000169"></a>In conclusion, the largest sub-graphs of <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> are planar, and hence any other graph with 5 or less vertices and less than 9 edges is planar.</p>

  <p class="body"><a id="pgfId-1000205"></a>The same thing can be shown for <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code>; investigating its sub-graphs can be a good exercise to gain a better understanding of bipartite graphs and <a id="marker-1007111"></a><a id="marker-1007115"></a><a id="marker-1007119"></a>embeddings.</p>

  <h3 class="fm-head2" id="heading_id_8"><a id="pgfId-1000221"></a>15.2.2 Planarity testing</h3>

  <p class="body"><a id="pgfId-1000235"></a>Checking to see <a id="marker-1007123"></a><a id="marker-1007127"></a><a id="marker-1007131"></a>if a graph is planar is trickier than you might think. Even checking whether an embedding is planar isn’t that easy: that’s one of the tasks our brain performs easily, but it’s not that simple to replicate with an algorithm. If we want to avoid resorting to computer vision (and we usually do, for this kind of task<a href="#pgfId-1007658"><sup class="footnotenumber">9</sup></a>) we need to restrict the way we draw edges, for instance, limiting to straight-line segments or Bézier curves, so that we can use math formulas to compute if they intersect. Still, the computational effort needed to check the number of intersections on a large graph remains considerable.</p>

  <p class="body"><a id="pgfId-1000257"></a>And this is just for a single embedding. Determining if a graph is non-planar means proving that for any possible embedding we can come up with, there is at least an intersection.</p>

  <p class="body"><a id="pgfId-1000272"></a>We already introduced Kuratowski’s work on planar graphs, providing the first method to determine if a graph is planar.</p>

  <p class="body"><a id="pgfId-1000283"></a>Planarity, however, had already been studied for a long time, and in fact Euler, in the 18<code class="fm-code-in-text"><sup class="superscript1">th</sup></code> century, came up with an invariant (proved only in 1811 by Cauchy) providing necessary conditions for a graph to be planar.</p>

  <p class="body"><a id="pgfId-1000298"></a>Although these conditions are not sufficient, so they can’t be used to prove planarity, they are cheap to compute and, when violated, they rule out planarity.</p>

  <p class="body"><a id="pgfId-1000311"></a>The two conditions we can more easily implement in our tests are</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1000320"></a>Given a simple, connected graph <code class="fm-code-in-text">G=(V,E)</code> with at least 3 vertices, <code class="fm-code-in-text">G</code> is planar only if <code class="fm-code-in-text">|E|</code> <span class="cambria">≤</span> <code class="fm-code-in-text">3|V| - 6</code>.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1000342"></a>If <code class="fm-code-in-text">|V| &gt; 3</code> and <code class="fm-code-in-text">G</code> doesn’t have any cycle with length 3, then <code class="fm-code-in-text">G</code> is planar only if <code class="fm-code-in-text">|E|</code> <span class="cambria">≤</span> <code class="fm-code-in-text">2|V| - 4</code>.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1000364"></a>So, as a first step in a planarity test algorithm, we can check, in linear time <code class="fm-code-in-text">O(V+E)</code>, both conditions:<a href="#pgfId-1007680"><sup class="footnotenumber">10</sup></a> if either doesn’t hold, we already know that the answer is “non-planar”.</p>

  <p class="body"><a id="pgfId-1000377"></a>There are several algorithms to test for planarity. While none of them is particularly easy to implement, many are also inefficient: the first efficient algorithm, running in worst-case linear time, was derived only in 1974 by Hopcroft and Tarjan.</p>

  <p class="body"><a id="pgfId-1000392"></a>The inefficient algorithms that had been developed before would take up to <code class="fm-code-in-text">O(|V|<sup class="superscript1">3</sup>)</code>, or even worse, as we’ll see.</p>

  <p class="body"><a id="pgfId-1000408"></a>One way to try to improve the situation is by using the divide-and-conquer strategy to break down the original graphs into smaller subgraphs that can be tested separately.</p>

  <p class="body"><a id="pgfId-1000417"></a>This is possible thanks to the following two lemmas:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1000426"></a>A graph is planar if and only if all its connected components are planar.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1000439"></a>A graph is planar if and only if all its biconnected components are planar.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1000451"></a>In chapter 14 we have already given the definition of <i class="calibre17">connected graph</i><a id="marker-1007135"></a>: <code class="fm-code-in-text">G</code> is connected when from any vertex <code class="fm-code-in-text">v</code> <span class="cambria">ϵ</span> <code class="fm-code-in-text">G</code> it is possible to find a path to any other vertex <code class="fm-code-in-text">u</code> <span class="cambria">ϵ</span> <code class="fm-code-in-text">G</code>. If a graph is not connected, we can define its connected components as the maximal disjoint subgraphs of <code class="fm-code-in-text">G</code> that are connected.</p>

  <p class="body"><a id="pgfId-1000475"></a>A <i class="calibre17">biconnected graph</i><a id="id_Hlk56684492"></a><a id="marker-1007139"></a> is a connected graph with the additional property that there is not a single vertex <code class="fm-code-in-text">v</code> <span class="cambria">ϵ</span> <code class="fm-code-in-text">G</code> such that removing <code class="fm-code-in-text">v</code> from <code class="fm-code-in-text">G</code> will disconnect the graph. An equivalent definition of a biconnected graph can be given: <code class="fm-code-in-text">G</code> is biconnected if for any pair of vertices <code class="fm-code-in-text">u, v</code> <span class="cambria">ϵ</span> <code class="fm-code-in-text">G</code> there exist two disjoint paths between them. These two paths, therefore, can’t have any edge in common or any vertex except for <code class="fm-code-in-text">u</code> and <code class="fm-code-in-text">v</code>.</p>

  <p class="body"><a id="pgfId-1000513"></a>The proof of the first lemma is trivial. For a disconnected graph, because there are no edges between its connected components, it’s sufficient to draw each component such that it won’t overlap with the others.</p>

  <p class="body"><a id="pgfId-1000528"></a>As a consequence of the two lemmas, we can split any graph <code class="fm-code-in-text">G</code> into its biconnected components and apply the planarity testing of choice to each of them separately.</p>

  <h3 class="fm-head2" id="heading_id_9"><a id="pgfId-1000539"></a>15.2.3 A naïve algorithm for planarity testing</h3>

  <p class="body"><a id="pgfId-1000559"></a>Since we have mentioned more than once that there is an (inefficient) algorithm based on Kuratowski’s theorem that is fairly straightforward to implement, let’s actually start from there. Listing 15.1 shows a template method that wraps any planarity testing algorithm, making sure we break down a graph into its connected (or, even better, biconnected) components and running the testing on each of them.</p>

  <p class="body"><a id="pgfId-1000570"></a>In chapter 14 we have seen how we can find the connected components of a graph using DFS; finding biconnected components is slightly more complicated, but it can still be done using a modified version of DFS.<a href="#pgfId-1007694"><sup class="footnotenumber">11</sup></a></p>

  <p class="fm-code-listing-caption"><a id="pgfId-1014411"></a>Listing 15.1 Planarity testing template algorithm</p>
  <pre class="programlisting"><b class="strong">function</b> planarityTesting(graph, isPlanar)      <span class="fm-combinumeral">❶</span>
  components ← biconnectedComponents(graph)     <span class="fm-combinumeral">❷</span>
  <b class="strong">for</b> G <b class="strong">in</b> components <b class="strong">do</b>                        <span class="fm-combinumeral">❸</span>
    <b class="strong">if</b> <b class="strong">not</b> isPlanar(G) <b class="strong">then</b>                     <span class="fm-combinumeral">❹</span>
      <b class="strong">return</b> <b class="strong">false</b>
  <b class="strong">return true</b>                                   <span class="fm-combinumeral">❺</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1026628"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">planarityTesting</code><a id="marker-1026632"></a> is a template meta-function taking a graph and a planarity testing algorithm, and applying the algorithm passed to all the biconnected components of the graph. If any fails the planarity testing, the graph is non-planar.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026660"></a><span class="fm-combinumeral">❷</span> Breaks down the graph into its biconnected components (you could use connected components to keep it simple)</p>

  <p class="fm-code-annotation"><a id="pgfId-1026677"></a><span class="fm-combinumeral">❸</span> Cycles through the graph’s components</p>

  <p class="fm-code-annotation"><a id="pgfId-1026694"></a><span class="fm-combinumeral">❹</span> If any component isn’t planar, the whole graph is non-planar.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026711"></a><span class="fm-combinumeral">❺</span> If all components are planar, we can return <code class="fm-code-in-text2">true</code><a id="marker-1026715"></a>.</p>

  <p class="body"><a id="pgfId-1000747"></a>Now we need to define the actual method performing planarity testing on each biconnected (or connected) component. Listing 15.2 shows the method based on Kuratowski’s theorem.</p>

  <p class="body"><a id="pgfId-1000762"></a>The algorithm leverages the inductive definition of a graph. While trees can be defined by induction on the number of vertices (we construct larger trees by adding children to a root), given a graph <code class="fm-code-in-text">G=(V,E),</code> it can be inductively grown in two different ways.</p>

  <p class="body"><a id="pgfId-1000780"></a>As we have seen in chapter 14, in fact, it could be</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1000789"></a><code class="fm-code-in-text">G’=(V+{v}, E)</code>: we add a new vertex to <code class="fm-code-in-text">G</code>.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1000804"></a><code class="fm-code-in-text">G’=(V, E+{(u,v)}) | u, v</code> <span class="cambria">ϵ</span> <code class="fm-code-in-text">V</code>: we add a new edge to <code class="fm-code-in-text">G</code>.</p>
    </li>
  </ul>

  <p class="fm-code-listing-caption"><a id="pgfId-1015141"></a>Listing 15.2 Planarity testing based on KK’s theorem</p>
  <pre class="programlisting"><b class="strong">function</b> isPlanar(graph)
  <b class="strong">if</b> |graph.vertices| &lt; 5 <b class="strong">then</b> <b class="strong">return true</b>                 <span class="fm-combinumeral">❶</span>
  <b class="strong">if</b> violatesEulerConstraints(graph) <b class="strong">then</b> <b class="strong">return false</b>     <span class="fm-combinumeral">❷</span>
  <b class="strong">if</b> isK5(graph) <b class="strong">or</b> isK3_3(graph) <b class="strong">then return false</b>        <span class="fm-combinumeral">❸</span>
  <b class="strong">for</b> v <b class="strong">in</b> graph.vertices <b class="strong">do</b>                               <span class="fm-combinumeral">❹</span>
    subG ← graph.remove(v)                                 <span class="fm-combinumeral">❺</span>
    <b class="strong">if</b> <b class="strong">not</b> isPlanar(subG) <b class="strong">then return false</b>                <span class="fm-combinumeral">❻</span>
  <b class="strong">for</b> e <b class="strong">in</b> graph.edges <b class="strong">do</b>                                  <span class="fm-combinumeral">❼</span>
    subG ← graph.remove(e)                                 <span class="fm-combinumeral">❽</span>
    <b class="strong">if</b> <b class="strong">not</b> isPlanar(subG) <b class="strong">return false</b>                     <span class="fm-combinumeral">❾</span>
  <b class="strong">return true</b>                                              <span class="fm-combinumeral">❿</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1025957"></a><span class="fm-combinumeral">❶</span> Since this algorithm leverages the inductive nature of graphs, we start with the base case. Graphs with fewer than 5 vertices are definitely planar.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025981"></a><span class="fm-combinumeral">❷</span> Checks if the number of edges and vertices violates Euler’s constraints for planar graphs. If so, this can’t be planar.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025998"></a><span class="fm-combinumeral">❸</span> Finally, if this graph is (isomorphic to) either <code class="fm-code-in-text2">K<sub class="calibre25">5</sub></code> or <code class="fm-code-in-text2">K<sub class="calibre25">3,3</sub></code>, then it definitely can’t be planar.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026015"></a><span class="fm-combinumeral">❹</span> Cycles through the graph’s vertices</p>

  <p class="fm-code-annotation"><a id="pgfId-1026032"></a><span class="fm-combinumeral">❺</span> Creates a sub-graph by removing <code class="fm-code-in-text2">v</code> and all the edges adjacent to <code class="fm-code-in-text2">v</code></p>

  <p class="fm-code-annotation"><a id="pgfId-1026049"></a><span class="fm-combinumeral">❻</span> If the sub-graph so created is not planar, neither is <code class="fm-code-in-text2">graph</code>.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026066"></a><span class="fm-combinumeral">❼</span> Cycles through all edges in <code class="fm-code-in-text2">graph</code></p>

  <p class="fm-code-annotation"><a id="pgfId-1026083"></a><span class="fm-combinumeral">❽</span> This time creates a sub-graph by just removing the current edge.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026107"></a><span class="fm-combinumeral">❾</span> If the resulting sub-graph isn’t planar, neither is <code class="fm-code-in-text2">graph</code>.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026124"></a><span class="fm-combinumeral">❿</span> If we made it all the way to this line, then the <code class="fm-code-in-text2">graph</code> is planar.</p>

  <p class="body"><a id="pgfId-1001128"></a>When it comes to decomposing <code class="fm-code-in-text">G</code>, therefore, we need to consider two sets of subgraphs:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1001139"></a><i class="calibre15">Induced subgraphs</i>—All the graphs that could be obtained by individually removing each vertex of <code class="fm-code-in-text">G</code> (induction rule 1), and all the edges in turn touching the vertex removed.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1001156"></a><i class="calibre15">Spanning subgraphs</i>—All the graphs that could be obtained by individually removing each edge of <code class="fm-code-in-text">G</code> (induction rule 2).</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1001172"></a>These two sets of graphs are recursively checked at lines #5–7 and #8–10, respectively. Since the algorithm is recursive, we need a base case: we could use the empty graph, trivially, but since we know that all graphs with 4 or fewer vertices are planar, we can stop our recursion earlier (see line #2) and save computational resources.</p>

  <p class="body"><a id="pgfId-1001191"></a>The only thing remaining is checking if the current input is a non-planar graph. Normally we would just use another base case (actually, 2), at line #4, where we check to see if recursion brought us either <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> or <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code> (for Kuratowski’s theorem, we know that this means non-planar). In this case, though, we added another check at line #3, using Euler’s inequalities to our advantage: as we saw in section 15.2.2, if the graph we are examining has too many edges for its vertices, it must be non-planar.</p>

  <p class="body"><a id="pgfId-1001216"></a>To see how the utility methods performing these checks work, let’s take a look at listings 15.3, 15.4, and 15.5.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015184"></a>Listing 15.3 Planarity testing utility methods: Euler’s invariants</p>
  <pre class="programlisting"><b class="strong">function</b> violatesEulerConstraints(graph)                     <span class="fm-combinumeral">❶</span>
  (n,m) ← (|graph.vertices|, |graph.edges|)                  <span class="fm-combinumeral">❷</span>
  <b class="strong">if</b> m &gt; 3 * n - 6 <b class="strong">then</b>                                      <span class="fm-combinumeral">❸</span>
    <b class="strong">return true</b>    
  <b class="strong">if</b> <b class="strong">not</b> hasCycleOfLength3(graph) <b class="strong">and</b> m &gt; 2 * n - 4 <b class="strong">then</b>     <span class="fm-combinumeral">❹</span>
    <b class="strong">return true</b>
  <b class="strong">return false</b></pre>

  <p class="fm-code-annotation"><a id="pgfId-1025665"></a><span class="fm-combinumeral">❶</span> Checks Euler’s invariants on a graph</p>

  <p class="fm-code-annotation"><a id="pgfId-1025686"></a><span class="fm-combinumeral">❷</span> Temporary variables for number of vertices and edges in graph</p>

  <p class="fm-code-annotation"><a id="pgfId-1025703"></a><span class="fm-combinumeral">❸</span> First constraint: If a graph is planar then <code class="fm-code-in-text2">|</code>E<code class="fm-code-in-text2">|</code> <span class="cambria">≤</span> 3|V| - 6.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025727"></a><span class="fm-combinumeral">❹</span> Second (stricter) constraint: If a graph is planar and doesn’t have any cycle of length 3, then <code class="fm-code-in-text2">|</code>E<code class="fm-code-in-text2">|</code> <span class="cambria">≤</span> 2|V| - 4.</p>

  <p class="body"><a id="pgfId-1001382"></a>The method to check Euler’s constraints, shown in listing 15.3, is directly derived from the formulas in section 15.2.2. The hardest part is verifying that a graph doesn’t have any cycle of length 3: this can be done using a modified version of DFS that returns all cycles, and runs in linear <code class="fm-code-in-text">O(V+E)</code> time. Since this is quite expensive and requires a non-trivial effort to write and maintain the code, the benefit of including this second check is debatable and—especially on your first try—it might not be worth it: you can start with checking the first constraint only, and remove the <code class="fm-code-in-text">if</code> at line #5.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015218"></a>Listing 15.4 Planarity testing utility methods: K5 testing</p>
  <pre class="programlisting"><b class="strong">function</b> isK5(graph)                                             <span class="fm-combinumeral">❶</span>
  <b class="strong">if</b> |graph.vertices| == 5 and |graph.simpleEdges| == 10 <b class="strong">then</b>    <span class="fm-combinumeral">❷</span>
    <b class="strong">return true</b>    
  <b class="strong">return false</b></pre>

  <p class="fm-code-annotation"><a id="pgfId-1025509"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">isK5</code><a id="marker-1025513"></a> takes a graph and checks if it is the complete graph with 5 vertices.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025531"></a><span class="fm-combinumeral">❷</span> Graph <code class="fm-code-in-text2">K5</code> has 5 vertices and exactly 10 edges (not counting loops). Here we assume that <code class="fm-code-in-text2">graph.simpleEdges</code><a id="marker-1025536"></a> returns all edges in a graph except for possible loops.</p>

  <p class="body"><a id="pgfId-1001507"></a>Listing 15.4 shows the method to check if a graph is (isomorphic to) <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code>. Obviously it needs to have 5 vertices (!), but we also know how many edges it should have, exactly 10. Notice that here we are talking about simple edges, where source and destination are distinct (so, no loops).</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015252"></a>Listing 15.5 Planarity testing utility methods: K3,3 testing</p>
  <pre class="programlisting"><b class="strong">function</b> isK3_3(graph)                                               <span class="fm-combinumeral">❶</span>
  (n,m) ← (|graph.vertices|, |graph.simpleEdges|)                    <span class="fm-combinumeral">❷</span>
  <b class="strong">if</b> n == 6 and m == 9  <b class="strong">then</b>                                         <span class="fm-combinumeral">❸</span>
    <b class="strong">if</b> isBipartite(graph) <b class="strong">and</b> partitionsSize(graph) == (3,3) <b class="strong">then</b>    <span class="fm-combinumeral">❹</span>
      <b class="strong">return true</b>    
  <b class="strong">return false</b></pre>

  <p class="fm-code-annotation"><a id="pgfId-1025222"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">isK3_3</code><a id="marker-1025226"></a> takes a graph and checks if it is the complete bipartite graph with two partitions of three vertices each.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025244"></a><span class="fm-combinumeral">❷</span> Temporary variables for number of vertices and edges in graph</p>

  <p class="fm-code-annotation"><a id="pgfId-1025261"></a><span class="fm-combinumeral">❸</span> Graph <code class="fm-code-in-text2">K3,3</code> has 6 vertices and exactly 9 edges (not counting loops): here we assume that <code class="fm-code-in-text2">graph.simpleEdges</code><a id="marker-1025266"></a> returns all edges in a graph excluding loops.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025279"></a><span class="fm-combinumeral">❹</span> That’s not enough, though. We also need to check that the graph is bipartite and the two partitions have the right size.</p>

  <p class="body"><a id="pgfId-1001682"></a>Listing 15.5 shows the method to check if a graph is (isomorphic to) <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code>. This is a bit more complicated because it’s not enough to check that the count of vertices (6) and edges (9) is right. We also need to check that the graph is bipartite and that both partitions have size 3.</p>

  <p class="body"><a id="pgfId-1001701"></a>This brings us to the last step we need to implement: finding out if a graph is bipartite, and retrieving the two partitions.</p>

  <p class="body"><a id="pgfId-1001712"></a>To do so, we exploit a property of bipartite graphs: a graph is bipartite if and only if it’s possible to color its vertices with exactly two different colors, such that there isn’t any pair of adjacent vertices with the same color. Figure 15.10 shows a few examples to clarify this definition.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F10.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028422"></a>Figure 15.10 Bipartite graphs and coloring. All graphs are colored with the minimum possible number of colors. On the left, two examples of bipartite graphs; on the right, non-bipartite graphs. As you can see, two colors are not enough for these graphs (we also use different shapes, along with shading, for the vertices to help with visualizing the difference).</p>

  <p class="body"><a id="pgfId-1001744"></a>We can perform graph coloring easily by modifying the <code class="fm-code-in-text">BFS</code> algorithm<a id="marker-1007167"></a>:</p>

  <ol class="calibre18">
    <li class="fm-list-numbered">
      <p class="list"><a class="calibre14" id="pgfId-1001758"></a>We represent the source vertex as a red hexagon.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1001773"></a>Once we extract a vertex from the queue, we color all its neighbors with the opposite color: for example, blue squares (as shown in figure 15.10) if the current vertex is a red hexagon, and vice versa.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1001799"></a>If any of the adjacent vertices is already colored with the same color as the current vertex, then the graph is not bipartite.</p>
    </li>
  </ol>

  <p class="body"><a id="pgfId-1001811"></a>Listing 15.6 shows the pseudo-code for a method returning the two partitions while it checks if the graph is bipartite. You can also take a look at a Java implementation on the book’s repo on GitHub<a href="#pgfId-1007709"><sup class="footnotenumber">12</sup></a> or a JavaScript implementation provided by JsGraph, the JavaScript library that has been used to draw most of the examples of embeddings in this <a id="marker-1007171"></a><a id="marker-1007175"></a><a id="marker-1007179"></a>chapter.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015286"></a>Listing 15.6 Checking if a connected graph is bipartite</p>
  <pre class="programlisting"><b class="strong">function</b> isBipartite(graph)                                       <span class="fm-combinumeral">❶</span>
  queue ← <b class="strong">new</b> Queue()                                             <span class="fm-combinumeral">❷</span>
  queue.insert(chooseRandomVertex(graph))                         <span class="fm-combinumeral">❸</span>
  colors ← <b class="calibre21">new</b> HashTable()                                        <span class="fm-combinumeral">❹</span>
  colors[queue.peak()] ← red                                      <span class="fm-combinumeral">❺</span>
  <b class="strong">while</b> <b class="strong">not</b> queue.empty() <b class="strong">do</b>                                      <span class="fm-combinumeral">❻</span>
    v ← queue.dequeue()                                           <span class="fm-combinumeral">❼</span>
    <b class="strong">for</b> e <b class="strong">in</b> graph.adjacencyList[v] <b class="strong">do</b>                            <span class="fm-combinumeral">❽</span>
      u ← e.dest
      <b class="strong">if</b> colors[u] == colors[v] <b class="strong">then</b>                              <span class="fm-combinumeral">❾</span>
        <b class="strong">return</b> (<b class="strong">false</b>, <b class="strong">null</b>, <b class="strong">null</b>)
      <b class="strong">if</b> u <b class="strong">not</b> <b class="strong">in</b> colors <b class="strong">then</b>                                     <span class="fm-combinumeral">❿</span>
        colors[u] = (blue <b class="strong">if</b> colors[v] == red <b class="strong">else</b> red)
        queue.enqueue(u)
   <b class="strong">return</b> (<b class="strong">true</b>, {v | colors[v] == red}, {v | colors[v] == blue}) <span class="fm-combinumeral">⓫</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1024436"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">isBipartite</code><a id="marker-1024440"></a> takes a graph, and returns <code class="fm-code-in-text2">true</code><a id="marker-1024442"></a> if it is bipartite, together with the two partitions. The argument must be a connected, non-empty graph.</p>

  <p class="fm-code-annotation"><a id="pgfId-1024462"></a><span class="fm-combinumeral">❷</span> Initializes a simple FIFO queue</p>

  <p class="fm-code-annotation"><a id="pgfId-1024479"></a><span class="fm-combinumeral">❸</span> Adds a random vertex of the graph to the queue, so that it will be extracted on the first iteration</p>

  <p class="fm-code-annotation"><a id="pgfId-1024496"></a><span class="fm-combinumeral">❹</span> Creates a new hash table to keep track of the color of each vertex</p>

  <p class="fm-code-annotation"><a id="pgfId-1024513"></a><span class="fm-combinumeral">❺</span> We (arbitrarily) pick the color red for the starting point (currently at the top of the queue).</p>

  <p class="fm-code-annotation"><a id="pgfId-1024530"></a><span class="fm-combinumeral">❻</span> Starts a loop, running until the queue is empty. It will run at least once, because of line #3.</p>

  <p class="fm-code-annotation"><a id="pgfId-1024547"></a><span class="fm-combinumeral">❼</span> Dequeues the head of the queue. This will become the current vertex.</p>

  <p class="fm-code-annotation"><a id="pgfId-1024564"></a><span class="fm-combinumeral">❽</span> Iterates over the outgoing edges for the current vertex</p>

  <p class="fm-code-annotation"><a id="pgfId-1024581"></a><span class="fm-combinumeral">❾</span> If the neighbor has already been colored with the same color as <code class="fm-code-in-text2">v</code>, the graph is not bipartite.</p>

  <p class="fm-code-annotation"><a id="pgfId-1024598"></a><span class="fm-combinumeral">❿</span> If, instead, <code class="fm-code-in-text2">u</code> hasn’t been colored yet, we can assign it a different color and add it to the queue.</p>

  <p class="fm-code-annotation"><a id="pgfId-1024615"></a><span class="fm-combinumeral">⓫</span> At this point, we know the graph is bipartite, so we can easily partition the vertices based on their color.</p>

  <h3 class="fm-head2" id="heading_id_10"><a id="pgfId-1002211"></a>15.2.4 Improving performance</h3>

  <p class="body"><a id="pgfId-1002223"></a>This <a id="marker-1007191"></a><a id="marker-1007195"></a>is the bulk of the simplest algorithm we have to test graph planarity. We know it’s inefficient, but exactly how inefficient?</p>

  <p class="body"><a id="pgfId-1002241"></a>It’s a recursive algorithm, where from each call to the method can stem several recursive calls; the depth of the recursion is already linear in the size of the original graph <code class="fm-code-in-text">G=(V,E)</code>, because we remove one vertex or one edge at a time.</p>

  <p class="body"><a id="pgfId-1002255"></a>The breadth of the recursion tree (the number of recursive calls) is also linear, although in the size of the graph that is currently run on, let’s call it <code class="fm-code-in-text">G’=(V’, E’)</code>. This is because the two <code class="fm-code-in-text">for</code> loops cycle through all vertices and all edges in <code class="fm-code-in-text">G’</code>.</p>

  <p class="body"><a id="pgfId-1002270"></a>We can write a formula for the running time. If <code class="fm-code-in-text">|V’|=n, |E’|=m</code>, then</p>
  <pre class="programlisting">T(n,m) = n * T(n-1, m) + m * T(n, m-1)
T(0,0) = 1
T(0,*)=1
T(*,0)=1</pre>

  <p class="body"><a id="pgfId-1002322"></a>For a recurrence relation<a href="#pgfId-1007724"><sup class="footnotenumber">13</sup></a> of the form <code class="fm-code-in-text">T(n) = n * T(n-1),</code> the solution depends on the value of the base term. If as in this case, <code class="fm-code-in-text">T(0) = 1</code>, then <code class="fm-code-in-text">T(n) = n!</code> – this, at least, when we have a single variable. Our specific case, where we have two variables, grows even faster.</p>

  <p class="body"><a id="pgfId-1002352"></a>The last thing we want in a formula for an algorithm’s running time is a factorial—a function that grows faster than the exponential function. This means that the algorithm, as presented in listing 15.2, can only be used for small graphs.</p>

  <p class="body"><a id="pgfId-1002363"></a>When you see a factorial pop up in your calculations, it will likely mean that you are computing the same thing over and over again, multiple times.</p>

  <p class="body"><a id="pgfId-1002372"></a>This is the case for our algorithm as well; let’s see an example, with a small graph with just three vertices. Let <code class="fm-code-in-text">G=({1,2,3}, E)</code> be our initial graph. For the sake of our example, we won’t bother with its edges, but focus on the recursion on vertices.</p>

  <p class="body"><a id="pgfId-1002395"></a>The <code class="fm-code-in-text">for</code> loop at line #4 of listing 15.2 will issue three calls<a href="#pgfId-1007742"><sup class="footnotenumber">14</sup></a> for the following graphs:<a href="#pgfId-1007756"><sup class="footnotenumber">15</sup></a></p>
  <pre class="programlisting">(V’,E’)=({2,3}, E-{1}), ({1,3}, E-{2}), ({1,2}, E-{3})</pre>

  <p class="body"><a id="pgfId-1002419"></a>Each of those graphs will in turn produce two calls:</p>
  <pre class="programlisting">({3}, E-{1,2}), ({2}, E-{1,3}),
({3}, E-{1,2}), ({1}, E-{2,3}),
({2}, E-{1,3}), ({1}, E-{2,3})</pre>

  <p class="body"><a id="pgfId-1002455"></a>As you can see, in the second round of calls, each graph appears twice. If we also consider the recursion on the edges, it gets much worse.</p>

  <p class="body"><a id="pgfId-1002464"></a>Usually this kind of expansion ends up in a memory crash long before the recursion gets closer to the base cases.</p>

  <p class="body"><a id="pgfId-1002474"></a>The most common strategy for coping with this is to avoid the duplicates by one of the following:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1002485"></a>Define a better recursion that avoids the duplicates (not always possible).</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1002498"></a>Prune the search tree avoiding duplicated work (<i class="calibre15">branch</i><a class="calibre14" id="marker-1007199"></a> <i class="calibre15">and bound</i> algorithms<a class="calibre14" id="marker-1007203"></a>).</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1002517"></a>Compute and store the results for the smaller cases and read them when needed while computing larger problems (<i class="calibre15">dynamic programming</i> algorithms<a class="calibre14" id="marker-1007207"></a>).</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1002533"></a>For this problem, we can reasonably go for the third option and use <i class="calibre17">memoization</i><a id="marker-1007211"></a> <a href="#pgfId-1007774"><sup class="footnotenumber">16</sup></a> to provide a sort of cache of the results of the algorithm for smaller problems.</p>

  <p class="body"><a id="pgfId-1002546"></a>This will give us some improvement, but as we’ll see, the most efficient algorithms developed for planarity testing, instead, order the edges to be added or removed at each step in such a way to guarantee a linear number of steps (therefore using the first of the strategies in the list).</p>

  <p class="body"><a id="pgfId-1002559"></a>By avoiding computing things twice, we guarantee that we will examine each distinct subgraph at most once, so that the number of steps becomes bounded by the number of possible subgraphs. For a graph with <code class="fm-code-in-text">n</code> vertices and <code class="fm-code-in-text">m</code> edges, there are <code class="fm-code-in-text">2<sup class="superscript1">n</sup></code> <i class="calibre17">induced subgraphs</i><a id="marker-1007215"></a> (because there are <code class="fm-code-in-text">2<sup class="superscript1">n</sup></code> subset of vertices) and <code class="fm-code-in-text">2<sup class="superscript1">m</sup></code> spanning subgraphs (considering the subset of edges). The total number of possible subgraphs is thus bounded by <code class="fm-code-in-text">2<sup class="superscript1">n+m</sup></code>, which is better than factorial, but still too large to consider the algorithm usable for graphs with more than ~20 vertices.</p>

  <p class="body"><a id="pgfId-1002595"></a>There are other small improvements that we can add; although not as impactful as avoiding duplicates, they all contribute to speeding up the algorithm. For instance, we can improve our halting condition. We don’t need to wait until we get down to <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> or <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code>; any complete graph with 5 or more vertices, or any complete bipartite graph with both partitions having 3 or more vertices, is certainly non-planar.</p>

  <p class="body"><a id="pgfId-1002616"></a>Most of these cases, however, are already caught by Euler’s invariants.</p>

  <p class="body"><a id="pgfId-1002626"></a>Listing 15.7 shows the pseudo-code for the improved method; you can find a Java implementation on the book’s repo<span class="fm-hyperlink"><a href="#pgfId-1007790"><sup class="footnotenumber">17</sup></a></span> or a JavaScript implementation provided <a id="marker-1007219"></a><a id="marker-1007223"></a>by JsGraph.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015439"></a>Listing 15.7 Planarity testing with cache</p>
  <pre class="programlisting"><b class="strong">function</b> isPlanar(graph, cache={})
  <b class="strong">if</b> graph <b class="strong">in</b> cache <b class="strong">then return</b> (cache[graph], cache)                <span class="fm-combinumeral">❶</span>
  <b class="strong">if</b> |graph.vertices| &lt; 5 <b class="strong">then</b> <b class="strong">return</b> (<b class="strong">true</b>, cache)
  <b class="strong">if</b> violatesEulerConstraints(graph) <b class="strong">then</b>                            <span class="fm-combinumeral">❷</span>
 
    cache[graph] ← <b class="strong">false</b>
    <b class="strong">return</b> (<b class="strong">false</b>, cache)
  <b class="strong">if</b> isComplete(graph) <b class="strong">or</b> isNonPlanarCompleteBipartite(graph) <b class="strong">then</b>   <span class="fm-combinumeral">❸</span>
    cache[graph] ← <b class="strong">false</b>     
    <b class="strong">return</b> (<b class="strong">false</b>, cache)
  <b class="strong">for</b> v <b class="strong">in</b> graph.vertices <b class="strong">do</b>                                         <span class="fm-combinumeral">❹</span>
    subG ← graph.remove(v)                            
    (planar, cache) ← isPlanar(subG, cache)                          <span class="fm-combinumeral">❺</span>
    <b class="strong">if</b> <b class="strong">not</b> planar <b class="strong">then</b>
      cache[graph] ← <b class="strong">false</b>
      <b class="strong">return</b> (<b class="strong">false</b>, cache)
  <b class="strong">for</b> e <b class="strong">in</b> graph.edges <b class="strong">do</b>                                            <span class="fm-combinumeral">❻</span>
    subG ← graph.remove(e)
    (planar, cache) ← isPlanar(subG, cache)
    <b class="strong">if</b> <b class="strong">not</b> planar <b class="strong">then</b>
      cache[graph] ← <b class="strong">false</b>
      <b class="strong">return</b> (<b class="strong">false</b>, cache)
  cache[graph] ← <b class="strong">true</b>                                                <span class="fm-combinumeral">❼</span>
  <b class="strong">return</b> (<b class="strong">true</b>, cache)</pre>

  <p class="fm-code-annotation"><a id="pgfId-1023929"></a><span class="fm-combinumeral">❶</span> First, we check if the graph is in our cache. The cache can be as simple as a dictionary, as long as graphs are serializable.</p>

  <p class="fm-code-annotation"><a id="pgfId-1023950"></a><span class="fm-combinumeral">❷</span> If the number of edges and vertices violates Euler’s constraints for planar graphs, we know the graph is not planar. Before returning, we need to update the cache so this graph won’t be checked again in another branch of the computation.</p>

  <p class="fm-code-annotation"><a id="pgfId-1023967"></a><span class="fm-combinumeral">❸</span> Instead of looking for <code class="fm-code-in-text2">K<sub class="calibre25">5</sub></code> or <code class="fm-code-in-text2">K<sub class="calibre25">3,3</sub></code> only, we check whether it is complete (since the graph has at least 5 vertices, it’s definitely non-planar) or complete bipartite (in this case, we also need to check that the smallest of the two partitions has size 3).</p>

  <p class="fm-code-annotation"><a id="pgfId-1023984"></a><span class="fm-combinumeral">❹</span> Cycles through the graph’s vertices</p>

  <p class="fm-code-annotation"><a id="pgfId-1024001"></a><span class="fm-combinumeral">❺</span> When we perform a recursive call, we need to update the cache as well. Besides the cache, the algorithm stays the same.</p>

  <p class="fm-code-annotation"><a id="pgfId-1024018"></a><span class="fm-combinumeral">❻</span> Cycles through all edges in graph. Follows the same pattern as for vertices.</p>

  <p class="fm-code-annotation"><a id="pgfId-1024035"></a><span class="fm-combinumeral">❼</span> If we made it all the way to this line, then the graph is planar; we need to update the cache and return <code class="fm-code-in-text2">true</code><a id="marker-1024040"></a>.</p>

  <h3 class="fm-head2" id="heading_id_11"><a id="pgfId-1003046"></a>15.2.5 Efficient algorithms</h3>

  <p class="body"><a id="pgfId-1003060"></a>The <a id="marker-1007231"></a><a id="marker-1007235"></a>algorithm presented in listing 15.7 is still too slow to be affordable on large graphs. Still, it can be a feasible, low-cost<a href="#pgfId-1007805"><sup class="footnotenumber">18</sup></a> option that can work on small graphs.</p>

  <p class="body"><a id="pgfId-1003080"></a>There are far better algorithms that have been developed for planarity testing. While they take different approaches to provide an answer (and a planar embedding) in linear time, they all have something in common: they are fairly complicated.</p>

  <p class="body"><a id="pgfId-1003093"></a>As in, “research papers spanning dozens of pages” complicated. Describing them in detail goes beyond the scope of this chapter, but we’ll briefly describe a few prominent ones and provide pointers for the interested readers.<a href="#pgfId-1007819"><sup class="footnotenumber">19</sup></a></p>

  <p class="body"><a id="pgfId-1003104"></a>Be aware that the effort to implement these algorithms might be consistent. Also keep in mind that if your constraints can be relaxed, and you can accept an algorithm that provides a reasonable embedding, even without guarantees that it will be planar, you can use simpler heuristics to generate embeddings (more on this later).</p>

  <p class="body"><a id="pgfId-1003117"></a>As we mentioned, the first linear-time algorithm for planarity testing was developed in 1974 by Hopcroft and Tarjan,<a href="#pgfId-1007839"><sup class="footnotenumber">20</sup></a> improving a previously-developed<a href="#pgfId-1007860"><sup class="footnotenumber">21</sup></a> <code class="fm-code-in-text">O(|V|<sup class="superscript1">2</sup>)</code> variant. Their idea is based on vertex addition, so the algorithm starts bottom-up, keeping the possible planar embeddings for each incrementally-built induced subgraph <a id="marker-1007239"></a><a href="#pgfId-1007875"><sup class="footnotenumber">22</sup></a> of the original one.</p>

  <p class="body"><a id="pgfId-1003145"></a>As we previously mentioned, this strategy defines a different approach to recursion: bottom-up rather than top-down, incremental and not divide-and-conquer, but above all, by carefully reconstructing the original graph one vertex at the time, it avoids analyzing all sub-graphs, and only performs a linear number of steps.</p>

  <p class="body"><a id="pgfId-1003154"></a>The key is that while adding vertices, the algorithm keeps track of the possible embeddings of the sub-graph.</p>

  <p class="body"><a id="pgfId-1003163"></a>Fast-forward to 2004, when a brand-new approach<a href="#pgfId-1007889"><sup class="footnotenumber">23</sup></a> was developed by Boyer and Myrvold: it’s an edge-addition method, so it incrementally adds edges instead of vertices. It’s still linear, <code class="fm-code-in-text">O(|V|+|E|)</code>, but it has the great advantage of avoiding any requirement for specific data structures to store the candidate embeddings. This algorithm is currently one of the state-of-the-art solutions to find planar embeddings for planar graphs; the best part is that you can find an open source implementation online on boost.org: <span class="fm-hyperlink"><a href="http://mng.bz/5jj7">http://mng.bz/5jj7</a></span>.</p>

  <p class="body"><a id="pgfId-1003195"></a>The last algorithm we are going to mention is the planarity testing algorithm<a href="#pgfId-1007909"><sup class="footnotenumber">24</sup></a> by Fraysseix, de Mendes, and Rosenstiehl, which is the other state-of-the-art algorithm in this area. It characterizes planar graphs in terms of a left-right ordering of the edges in a depth-first search tree, and its implementation is DFS-based, although obviously the DFS method needs to be modified accordingly, and it uses <i class="calibre17">Trémaux trees</i><a id="marker-1007243"></a>, special spanning trees produced by a DFS visit of <a id="marker-1007247"></a><a id="marker-1007251"></a>a <a id="marker-1007255"></a><a id="marker-1007259"></a>graph.</p>

  <h2 class="fm-head" id="heading_id_12"><a id="pgfId-1003227"></a>15.3 Non-planar graphs</h2>

  <p class="body"><a id="pgfId-1003243"></a>Now <a id="marker-1007263"></a><a id="marker-1007267"></a>that we have at least one planarity testing algorithm in our tool belt, we can look at our task, visualizing graphs nicely on screen, with more confidence. Some of the planarity testing algorithms also output a planar embedding, and that gives us a good starting point.</p>

  <p class="body"><a id="pgfId-1003257"></a>And yet, we have a long way to go.</p>

  <p class="body"><a id="pgfId-1003266"></a>Let’s start with two considerations:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1003275"></a>Is reducing the number of crossing edges the only criterion we should follow?</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1003287"></a>We know not all graphs are planar . . . should we just give up on non-planar graphs?</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1003301"></a>Let’s focus on the first question. What do you think? Take a minute to imagine what other characteristics make a good visualization and, vice versa, what could go wrong with this.</p>

  <p class="body"><a id="pgfId-1003312"></a>Then take a look at figure 15.11 to corroborate your thoughts.</p>

  <p class="body"><a id="pgfId-1003321"></a>Looking at it, we can see that there are at least three different aspects that contribute to the poor look and comprehensibility of the visualization:</p>

  <ol class="calibre18">
    <li class="fm-list-numbered">
      <p class="list"><a class="calibre14" id="pgfId-1003330"></a>The most evident effect is that it’s impossible to read any text. This is because elements are unnecessarily far from each other, and we need to zoom out to see the whole chart.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1003347"></a>Some edges are all twisted and windy, making it harder to follow them.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1003360"></a>Compared to figure 15.1, the relative position of the elements fails to suggest the direction of flow. Adjacent nodes are far from each other, with nodes modeling other unrelated steps in between.</p>
    </li>
  </ol>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F11.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028467"></a>Figure 15.11 Another embedding gone berserk for the flow chart in figure 15.1</p>

  <p class="body"><a id="pgfId-1003398"></a>OK, this is what’s wrong with the chart in figure 15.11. Can we transform these considerations into requirements to have a better visualization? Let’s try this:</p>

  <ol class="calibre18">
    <li class="fm-list-numbered">
      <p class="list"><a class="calibre14" id="pgfId-1003407"></a>Adjacent vertices (aka vertices connected by an edge) must be placed as close as possible in the plane. Of course, we need some sort of a compromise because we don’t want vertices to get too close (otherwise they would overlap with each other or hide the edge between them), and also if a vertex <code class="fm-code-in-text">v</code> is adjacent to many others, we can’t afford too many of these vertices to cluster around <code class="fm-code-in-text">v</code>.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1003423"></a>Draw edges in the simplest possible way: either segments or arcs of ellipses should work.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1003437"></a>Reduce the number of edges crossing. Aim for no intersections if a graph is planar or as few as possible for non-planar ones.</p>
    </li>
  </ol>

  <p class="body"><a id="pgfId-1003451"></a>In the next chapters, we will see how these requirements can be translated into mathematical expressions to model a <i class="calibre17">cost function</i> that can reflect how good a graph is.</p>

  <p class="body"><a id="pgfId-1003462"></a>We’ll use the rest of this chapter to talk in more depth about the third point.</p>

  <p class="body"><a id="pgfId-1003471"></a>As we have seen, there are graphs for which it’s not possible to find an embedding without any edge crossing.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title">Edge intersections in higher dimensional spaces</p>

    <p class="fm-sidebar-text">Interestingly enough, if we move from the plane to 3-D space, it becomes trivial to find an embedding to <span class="cambria">ℝ</span><code class="fm-code-in-text2"><sup class="superscript">3</sup></code> such that no edges cross. If we consider the following Jordan curve <code class="fm-code-in-text2">C(t)</code>, a surface defined as</p>

    <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ1.png"/></p>

    <p class="fm-sidebar-text">then we can map each vertex to a distinct point on the curve and draw edges as segments between the vertices. It can then be proven that there is no way to choose a set of four points from <code class="fm-code-in-text2">C(t)</code> such that they all lie on the same plane, and therefore the segments between pairs of points can’t cross each other.</p>
  </div>

  <p class="body"><a id="pgfId-1003555"></a>For non-planar graphs <code class="fm-code-in-text">G</code>, however, we can define a value, called a <i class="calibre17">crossing number</i><a id="marker-1007271"></a>, that is the smallest possible number of edge crossings of all the possible embeddings of <code class="fm-code-in-text">G</code> to <span class="cambria">ℝ</span><code class="fm-code-in-text"><sup class="superscript1">2</sup></code>.</p>

  <p class="body"><a id="pgfId-1003574"></a>Planar graphs, obviously, have a crossing number equal to 0; both non-planar graphs we saw earlier in the chapter, <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> and <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code>, have a crossing number equal to 1.</p>

  <h3 class="fm-head2" id="heading_id_13"><a id="pgfId-1003589"></a>15.3.1 Finding the crossing number</h3>

  <p class="body"><a id="pgfId-1003605"></a>Kuratowski’s <a id="marker-1007275"></a><a id="marker-1007279"></a><a id="marker-1007283"></a>theorem tells us the necessary and sufficient condition for a graph to be planar, but it doesn’t help much with computing the minimum crossing number of non-planar graphs. The problem of finding the crossing number for a non-planar graph has been investigated far less than planarity testing/embedding. While there are several efficient algorithms that provide planar embeddings for planar graphs, to date there isn’t an efficient algorithm that can find the minimum crossing number for generic graphs.</p>

  <p class="body"><a id="pgfId-1003623"></a>As a matter of fact, it has been proven that determining the crossing number of a generic graphs is an <i class="calibre17">NP-complete</i><a id="marker-1007287"></a> problem.</p>

  <p class="body"><a id="pgfId-1003635"></a>There are, however, notable exceptions<a href="#pgfId-1007936"><sup class="footnotenumber">25</sup></a> if we narrow the field; for example, it has been recently proven<a href="#pgfId-1007958"><sup class="footnotenumber">26</sup></a> that there is a simple algorithm to check if a non-planar graph has crossing number 1.</p>

  <p class="body"><a id="pgfId-1003649"></a>Assuming that <code class="fm-code-in-text">G</code> is a non-planar graph (and hence it has at least 5 vertices, as a consequence of Kuratowski’s theorem), for each pair of non-adjacent<a href="#pgfId-1007977"><sup class="footnotenumber">27</sup></a> edges <code class="fm-code-in-text">a</code><span class="cambria">→</span><code class="fm-code-in-text">b</code>, <code class="fm-code-in-text">c</code><span class="cambria">→</span><code class="fm-code-in-text">d</code>, we remove both edges, and add a new vertex <code class="fm-code-in-text">v</code>, and 4 new edges <code class="fm-code-in-text">a</code><span class="cambria">→</span><code class="fm-code-in-text">v</code>, <code class="fm-code-in-text">v</code><span class="cambria">→</span><code class="fm-code-in-text">b</code>, <code class="fm-code-in-text">c</code><span class="cambria">→</span><code class="fm-code-in-text">v</code>, <code class="fm-code-in-text">v</code><span class="cambria">→</span><code class="fm-code-in-text">d</code>. If the new graph obtained is planar, then the crossing number of the original graph is exactly 1.</p>

  <p class="body"><a id="pgfId-1003676"></a>Some of the most interesting results in this area focus on complete and complete bipartite graphs. Guy’s and Zarankiewicz’ conjectures postulate a formula for the crossing number of these graphs, but they haven’t been proven so far.</p>

  <p class="body"><a id="pgfId-1003687"></a>Guy’s conjecture hypothesizes that the minimum crossing number of the generic complete graph with <code class="fm-code-in-text">n</code> vertices is given by</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ2.png"/></p>

  <p class="body"><a id="pgfId-1003707"></a>Zarankiewicz’ conjecture, however, provides an estimate for complete bipartite graphs with two partitions having <code class="fm-code-in-text">n</code> and <code class="fm-code-in-text">m</code> vertices, respectively:</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ3.png"/></p>

  <p class="body"><a id="pgfId-1003732"></a>As of today, both formulas have been proven to hold as upper bounds, meaning that the crossing number for these graphs is not larger than the value computed using the formulas, and they have not yet been disproved as lower bounds.</p>

  <p class="body"><a id="pgfId-1003741"></a>If we try to apply these results to the two graphs we have already introduced, we get</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ4.png"/></p>

  <p class="body"><a id="pgfId-1003768"></a>So, for <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> and <code class="fm-code-in-text">K<sub class="subscript1">3,3</sub></code> the expectation is consistent with what we have mentioned and with our experience. As a matter of fact, Guy’s conjecture has been proven to hold true as an exact value for <code class="fm-code-in-text">n</code> <span class="cambria">≤</span> <code class="fm-code-in-text">12</code>, while Zarankiewicz’ for <code class="fm-code-in-text">n,m</code> <span class="cambria">≤</span> <code class="fm-code-in-text">7</code>.</p>

  <p class="body"><a id="pgfId-1003794"></a>If we consider, for instance, graph <code class="fm-code-in-text">K<sub class="subscript1">6</sub></code>, shown in figure 15.12, the expected (and proven) crossing number is 3.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F12.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028509"></a>Figure 15.12 A naïve embedding for <code class="fm-code-in-text">K<sub class="subscript1">6</sub></code>: there are 15 crossing pairs of edges with this layout.</p>

  <p class="body"><a id="pgfId-1003831"></a>And yet, it’s significantly harder to obtain an embedding with minimal crossings between edges. An example embedding is shown in <a id="marker-1007291"></a><a id="marker-1007295"></a><a id="marker-1007299"></a>figure 15.13.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F13.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028549"></a>Figure 15.13 A minimum crossing embedding for <code class="fm-code-in-text">K<sub class="subscript1">6</sub></code>, with just 3 intersections.</p>

  <h3 class="fm-head2" id="heading_id_14"><a id="pgfId-1003880"></a>15.3.2 Rectilinear crossing number</h3>

  <p class="body"><a id="pgfId-1003896"></a>Have <a id="marker-1007303"></a><a id="marker-1007307"></a><a id="marker-1007311"></a>you noticed that so far, we’ve only drawn graphs using segments? While this has served our purpose well, and we’ve always been able to draw graphs with the minimum number of intersections, this is not always true.</p>

  <p class="body"><a id="pgfId-1003911"></a>In fact, we need to introduce a new definition: the <i class="calibre17">rectilinear crossing number</i><a id="marker-1007315"></a> of a graph <code class="fm-code-in-text">G</code> is the minimum number of edges crossing in a straight-line drawing of <code class="fm-code-in-text">G</code>; that is, an embedding on the plane for <code class="fm-code-in-text">G</code> where edges are drawn as straight-line segments.</p>

  <p class="body"><a id="pgfId-1003931"></a>When we restrict to straight-line segments for the edges, we are using a fraction of the possible embeddings. It shouldn’t be surprising, therefore, that the rectilinear crossing number of a graph is never smaller than its crossing number.</p>

  <p class="body"><a id="pgfId-1003944"></a>Now, can it be larger? It has been proven that for any graph <code class="fm-code-in-text">G</code> with a crossing number smaller than or equal to 3, it’s possible to come up with a straight-line drawing with minimal crossings: in other words, whenever the crossing number <code class="fm-code-in-text">cr(G)</code> is 3 or less, it matches the rectilinear crossing number, <code class="fm-code-in-text">rcr(G)</code>.</p>

  <p class="body"><a id="pgfId-1003961"></a>Although this is great, because it means that planar graphs can indifferently be drawn as straight-line or curve-line drawings, the result can’t be generalized. There exist, in fact, graphs for which <code class="fm-code-in-text">cr(G) = 4 &lt; rcr(G)</code>. Figure 15.14 shows the original example used for the proof in a paper<a href="#pgfId-1007996"><sup class="footnotenumber">28</sup></a> from 1993. In the left half of the figure, you can see a straight-line drawing of the graph, with 12 edge intersections. This is also the rectilinear crossing number of the graphs, and no matter how much you move vertices around, you can’t get fewer intersections, as long as you only draw edges with straight line segments.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F14.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028603"></a>Figure 15.14 The simplest graph for which the rectilinear crossing number is larger than the crossing number. Intersections are highlighted by the little arrows.</p>

  <p class="body"><a id="pgfId-1004011"></a>On the other hand, the right half of figure 15.14 shows that by using cubic <a id="id_Hlk56688184"></a>Bézier curves and moving a few edges to the external face of the first embedding, we can reduce the number of intersections to just 4; this is also the crossing number for this graph.</p>

  <p class="body"><a id="pgfId-1004023"></a>The interesting part is that by using this graph as a starting point, it is possible to construct graphs with a crossing number equal to 4, but with a rectilinear crossing number arbitrarily large (potentially up to infinity). For the proof and the construction rules, please refer to the original article.</p>

  <p class="body"><a id="pgfId-1004032"></a>For complete graphs, it’s known that for <code class="fm-code-in-text">n</code><span class="cambria">≥</span><code class="fm-code-in-text">10, rcr(Kn)&gt;cr(Kn)</code>; unfortunately, we can’t do any better for our examples for <code class="fm-code-in-text">K<sub class="subscript1">5</sub></code> and <code class="fm-code-in-text">K<sub class="subscript1">6</sub></code>: even using generic Jordan curves, the best embedding we can get for <code class="fm-code-in-text">K<sub class="subscript1">6</sub></code> is the one shown in figure 15.15, which still has three intersections.</p>

  <p class="body"><a id="pgfId-1004067"></a>Nevertheless, using arcs allows us to choose a simpler and more regular layout for the vertices.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F15.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028650"></a>Figure 15.15 An alternative minimum crossing embedding for <code class="fm-code-in-text">K<sub class="subscript1">6</sub></code>: using curves for the edges allows us to keep a more regular layout for the vertices.</p>

  <p class="body"><a id="pgfId-1004100"></a>So, long story short, if we draw large graphs using only straight-line segments, chances are that we have to accept a larger number of edge intersections than is actually possible, because the rectilinear crossing number is larger than the crossing number for many graphs. Does that mean we have to dismiss this way of drawing graphs? Not at all!</p>

  <p class="body"><a id="pgfId-1004111"></a>First, as we have seen, for all planar graphs and all graphs whose crossing number is smaller than 4, we can use the straight-line drawing without any loss; not all the other graphs with <code class="fm-code-in-text">cr(G)</code> <span class="cambria">≥</span> <code class="fm-code-in-text">4</code>, moreover, have a worse <code class="fm-code-in-text">rcr(G)</code> than their <code class="fm-code-in-text">cr(G)</code>.</p>

  <p class="body"><a id="pgfId-1004131"></a>It turns out that for practical purposes, we are often more interested in drawing planar or almost-planar graphs, because flow-charts, PERT diagrams, workflows, and so on are usually fairly sparse graphs, which in turn are less likely to have a high crossing number. After all, from Euler’s invariants we know that planar graphs must be sparse (because the number of edges is linear in the number of vertices).</p>

  <p class="body"><a id="pgfId-1004150"></a>Second, even if curve-line embeddings can lead to fewer crossing points, it doesn’t mean that it’s easy to find one. As a matter of fact, these drawings are much harder to find with an algorithm because we have to optimize many more parameters. Besides the position of the vertices, we also have to find the ideal curves that reduce the number of intersections. This will add at least one or two parameters per edge, if Bézier’s quadratic or cubic curves are used, making the search space much larger and harder to search. The number of parameters, in fact, goes from <code class="fm-code-in-text">O(V)</code> to <code class="fm-code-in-text">O(V+E)</code>, which in turn is <code class="fm-code-in-text">O(V<sup class="superscript1">2</sup>)</code> in the worst case.</p>

  <p class="body"><a id="pgfId-1004181"></a>Third, using curves requires a larger computational power. The algorithm to check if two segments intersect is significantly easier than checking if two curves do (and it can be made even easier with some restrictions on the position of the vertices). This means that even computing the number of intersections in a candidate solution is more expensive with curve-line drawings.</p>

  <p class="body"><a id="pgfId-1004195"></a>In the next chapters, we will focus on straight-line drawings, but we’ll also show how to extend them to <a id="marker-1007319"></a><a id="marker-1007323"></a><a id="marker-1007327"></a>curve-line <a id="marker-1007331"></a><a id="marker-1007335"></a>graphs.</p>

  <h2 class="fm-head" id="heading_id_15"><a id="pgfId-1004211"></a>15.4 Edge intersections</h2>

  <p class="body"><a id="pgfId-1004225"></a>The last bit of code we need to make our initial fully randomized algorithm for minimal-crossing embeddi<a id="marker-1007339"></a><a id="marker-1007343"></a>ngs is the method that checks if two edges intersect.</p>

  <p class="body"><a id="pgfId-1004239"></a>In this section we’ll start discussing the variant for straight-line drawings; since edges are drawn as segments, it’s easier to check if they intersect.</p>

  <p class="body"><a id="pgfId-1004250"></a>Then we’ll move to Bézier curves, briefly explaining how they work, the subset of curves we’ll allow, and how to check for intersections for elements of this subset.</p>

  <h3 class="fm-head2" id="heading_id_16"><a id="pgfId-1004261"></a>15.4.1 Straight-line segments</h3>

  <p class="body"><a id="pgfId-1004275"></a>Let’s <a id="marker-1007347"></a><a id="marker-1007351"></a><a id="marker-1007355"></a>start with the intersection between two segments. After all, we have also said that we decided to focus on straight-line drawings, so we’ll devote more space to discussing this case.</p>

  <p class="body"><a id="pgfId-1004290"></a>An initial strategy to cheaply screen pairs that are not intersecting is shown in figure 15.16. If we draw a box, parallel to the axes, around each of the two segments, then obviously the two segments can’t cross if the boxes do not intersect. In turn, the two boxes can’t intersect if the projections of the two segments over the Cartesian axes don’t intersect on both the <code class="fm-code-in-text">x</code> and <code class="fm-code-in-text">y</code> axes.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F16.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028692"></a>Figure 15.16 Examples of non-intersecting segments: the bounding-box check can only rule out an intersection, but cannot confirm it.</p>

  <p class="body"><a id="pgfId-1004331"></a>This condition, having the projected segments not intersecting, is sufficient, but not necessary for establishing that two segments do not cross. Figure 15.16 (B) shows how there can be segments whose boxes intersect, but that don’t cross.</p>

  <p class="body"><a id="pgfId-1004342"></a>So, we have an asymmetric situation:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1004351"></a>If we find out that the projections of the segments do not intersect over one of the two axes, we can conclude that the segments do not intersect.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1004363"></a>Otherwise, we can’t make any assumptions, and we need to further investigate.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1004375"></a>We can do that in many ways, for instance, by verifying that the extremes of a segment fall on the opposite sides of the line passing through the other segment, as shown in figure 15.17.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F17.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028734"></a>Figure 15.17 Segment intersection: if bounding boxes have a non-null intersection, the discriminant becomes whether or not the vertices of segment <code class="fm-code-in-text">CD</code> (or <code class="fm-code-in-text">HG</code>) are on opposite sides of the line passing through the segment <code class="fm-code-in-text">AB</code> (<code class="fm-code-in-text">EF</code>), and vice versa.</p>

  <p class="body"><a id="pgfId-1004411"></a>This, however, requires a bit too much fiddling with edge cases (for instance, parallel segments), so I prefer a different, more elegant, method I recently discovered.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F18.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028776"></a>Figure 15.18 Checking whether the point of intersection of the two lines falls within both segments</p>

  <p class="body"><a id="pgfId-1004422"></a>The gist of it is shown in figure 15.18. It doesn’t involve bounding boxes; rather, we want to find the intersection point of the lines passing through the segments and then check that it lies within both segments. There are, actually, three possible cases:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1004435"></a>The intersection of the two lines, point <code class="fm-code-in-text">P</code>, lie outside of both segments.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1004450"></a><code class="fm-code-in-text">P</code> lies inside one of the two segments, but not both.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1004464"></a><code class="fm-code-in-text">P</code> lies within both segments.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1004477"></a>The third case is the only one where we have an intersection.</p>

  <p class="body"><a id="pgfId-1004505"></a>How do we find <code class="fm-code-in-text">P</code>? Well, first, more precisely, we will use vectors and semi-lines rather than just lines.</p>

  <p class="body"><a id="pgfId-1004516"></a>We define vectors <code class="fm-code-in-text">v=BA=(B<sub class="subscript1">x</sub>-A<sub class="subscript1">x</sub>,B<sub class="subscript1">y</sub>-A<sub class="subscript1">y</sub>)</code> and <code class="fm-code-in-text">w=DC=(D<sub class="subscript1">x</sub>-C<sub class="subscript1">x</sub>,D<sub class="subscript1">y</sub>-C<sub class="subscript1">y</sub>)</code>. These vectors start from the second point in the segment and end at the first one. Now, remember that vectors can be translated seamlessly, so, for instance, we can move the <code class="fm-code-in-text">v</code> so that it starts where <code class="fm-code-in-text">w</code> ends, or vice versa, and compute their sum or product. For instance, considering the vector <code class="fm-code-in-text">u</code> that is shown in figure 15.19 (A) (and that we’ll define in a few lines), we show it sharing point <code class="fm-code-in-text">A</code> with <code class="fm-code-in-text">v</code> out of convenience, so that it’s apparent how the two vectors are orthogonal.</p>

  <p class="body"><a id="pgfId-1004566"></a>Assuming that vectors <code class="fm-code-in-text">v</code> and <code class="fm-code-in-text">w</code> aren’t parallel (which we can easily check by taking their cross product), the lines passing through them will cross at one point <code class="fm-code-in-text">P</code>, that might or might not lie inside the segments. Either way, there must be two real numbers, <code class="fm-code-in-text">h</code> and <code class="fm-code-in-text">g</code>, such that the scaled vectors <code class="fm-code-in-text">h*v</code> and <code class="fm-code-in-text">g*w</code>, when their start point is set to <code class="fm-code-in-text">B</code> and <code class="fm-code-in-text">D</code> respectively, both end exactly at point <code class="fm-code-in-text">P</code>, as shown in figure 15.19 (B).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F19.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028821"></a>Figure 15.19 A vector approach to check whether the point of intersection of the two lines falls within both segments</p>

  <p class="body"><a id="pgfId-1004620"></a>In other words, the coordinates of point <code class="fm-code-in-text">P</code> can be expressed in terms of both vectors, and the following equation must hold:</p>
  <pre class="programlisting">B + h*v = D + g*w                                               (1)</pre>

  <p class="body"><a id="pgfId-1004647"></a>Notice that <code class="fm-code-in-text">B</code> and <code class="fm-code-in-text">D</code> can also be considered vectors: in particular, the vectors that go from the origin to those two points.</p>

  <p class="body"><a id="pgfId-1004660"></a>We had mentioned we would define a new vector <code class="fm-code-in-text">u</code>. Well, now is the time to consider it:</p>
  <pre class="programlisting"><b class="calibre21">u</b> = (-v<code class="fm-code-in-text2"><sub class="subscript">y</sub></code>,v<code class="fm-code-in-text2"><sub class="subscript">x</sub></code>) = (A<code class="fm-code-in-text2"><sub class="subscript">y</sub></code>-B<code class="fm-code-in-text2"><sub class="subscript">y</sub></code>,B<code class="fm-code-in-text2"><sub class="subscript">x</sub></code>-A<code class="fm-code-in-text2"><sub class="subscript">x</sub></code>)</pre>

  <p class="body"><a id="pgfId-1004700"></a>This vector has a special property; its dot product with vector <code class="fm-code-in-text">v</code> is zero:</p>
  <pre class="programlisting"><b class="calibre21">u</b><span class="cambria">·</span><b class="calibre21">v</b> = <b class="calibre21">v</b><span class="cambria">·</span><b class="calibre21">u</b> = v<code class="fm-code-in-text2"><sub class="subscript">x</sub></code>v<code class="fm-code-in-text2"><sub class="subscript">y</sub></code> - v<code class="fm-code-in-text2"><sub class="subscript">y</sub></code>v<code class="fm-code-in-text2"><sub class="subscript">x</sub></code> = 0</pre>

  <p class="body"><a id="pgfId-1004739"></a>Going back to equation (1), we can multiply both sides by <code class="fm-code-in-text">u</code>, which is not <code class="fm-code-in-text">null</code> (as long as <code class="fm-code-in-text">A</code> and <code class="fm-code-in-text">B</code> are distinct points, which we assume as a hypothesis, because distinct vertices can’t be assigned to the same point). Doing so we get</p>
  <pre class="programlisting">B<b class="calibre21">·u</b> + h*<b class="calibre21">v·u</b> = D·<b class="calibre21">u</b> + g*w·<b class="calibre21">u</b> <span class="cambria">⇒</span> B·<b class="calibre21">u</b> = D·<b class="calibre21">u</b> + g*w·u</pre>

  <p class="body"><a id="pgfId-1004797"></a>As such we eliminate the unknown <code class="fm-code-in-text">h</code> and solve the equation for <code class="fm-code-in-text">g</code>:</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ5.png"/></p>

  <p class="body"><a id="pgfId-1004819"></a>Similarly, we can define vector <code class="fm-code-in-text">z = (-w<sub class="subscript1">y</sub>,w<sub class="subscript1">x</sub>)</code>, such that <code class="fm-code-in-text">z·w = 0</code>, and derive a formula for <code class="fm-code-in-text">h</code>:</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ6.png"/></p>

  <p class="body"><a id="pgfId-1004855"></a>All that’s left is reasoning about the meaning of these two solutions. Looking at figure 15.19, can you tell which one, between <code class="fm-code-in-text">h</code> and <code class="fm-code-in-text">g</code> is, for this example, larger than 1?</p>

  <p class="body"><a id="pgfId-1004874"></a>If you notice, in this particular example vector, <code class="fm-code-in-text">BP</code> is smaller than vector <code class="fm-code-in-text">BA</code>, and as such, <code class="fm-code-in-text">h</code> must have a value between 0 and 1. The scalar <code class="fm-code-in-text">g</code> must be larger than 1, because vector <code class="fm-code-in-text">DP</code> is longer than <code class="fm-code-in-text">DC</code>.</p>

  <p class="body"><a id="pgfId-1004901"></a>For the former situation, clearly <code class="fm-code-in-text">P</code> is within the segment <code class="fm-code-in-text">BA</code>, while for the latter, it’s clearly outside <code class="fm-code-in-text">DC</code>.</p>

  <p class="body"><a id="pgfId-1004916"></a>When either value is 0 or 1, it means that <code class="fm-code-in-text">P</code> coincides with one of the segment’s endpoints. If both <code class="fm-code-in-text">h</code> and <code class="fm-code-in-text">g</code> are equal to either 0 or 1, then we have an edge case where the two segments have a vertex in common. These two edge cases are shown in figure 15.20.</p>

  <p class="body"><a id="pgfId-1004935"></a>In conclusion, if we assume that all 4 vertices are distinct, then the two segments intersect if and only if both <code class="fm-code-in-text">0</code><span class="cambria">≤</span><code class="fm-code-in-text">h</code><span class="cambria">≤</span><code class="fm-code-in-text">1</code> and <code class="fm-code-in-text">0</code><span class="cambria">≤</span><code class="fm-code-in-text">g</code><span class="cambria">≤</span><code class="fm-code-in-text">1</code> (but only at most one of them is either 0 or 1).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F20.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028863"></a>Figure 15.20 Two edge cases for the vectorial method. In the first case, segments <code class="fm-code-in-text">AB</code> and <code class="fm-code-in-text">CD</code>, we have <code class="fm-code-in-text">0</code><span class="cambria">≤</span><code class="fm-code-in-text">h</code><span class="cambria">≤</span><code class="fm-code-in-text">1</code> and <code class="fm-code-in-text">g==1</code>. Therefore, vertex <code class="fm-code-in-text">C</code> lies on the segment <code class="fm-code-in-text">AB</code>. The second example, segments <code class="fm-code-in-text">A’B’</code> and <code class="fm-code-in-text">C’D’</code>, has <code class="fm-code-in-text">h==0</code> and <code class="fm-code-in-text">g==1</code>. In this case, two of the endpoints must be the same, and in fact <code class="fm-code-in-text">B’==C’</code>.</p>

  <p class="body"><a id="pgfId-1005011"></a> Listing 15.8 shows the code to compute the scaling coefficient (either of <code class="fm-code-in-text">h</code> or <code class="fm-code-in-text">g</code>; which one depends on the order of the points we pass) for one segment with respect to the <a id="marker-1007359"></a><a id="marker-1007363"></a><a id="marker-1007367"></a>other.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015896"></a>Listing 15.8 Method <code class="fm-code-in-text">vectorScalingFactor</code></p>
  <pre class="programlisting"><b class="strong">function</b> vectorScalingFactor(A, B, C, D)    <span class="fm-combinumeral">❶</span>
  v = (B.x-A.x, B.y-A.y)
  w = (D.x-C.x, D.y-C.y)
  u = (-v.y, v.x)
  <b class="calibre21">return</b> ((B.x-D.x) * u.x + (B.y-D.y) * u.y) / (w.x * u.x + w.y * u.y) </pre>

  <p class="fm-code-annotation"><a id="pgfId-1023852"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">vectorScalingFactor</code><a id="marker-1023885"></a> takes four points, assuming they are the endpoints of segments <code class="fm-code-in-text2">AB</code> and <code class="fm-code-in-text2">CD</code>, and returns the scaling factor that needs to be applied to vector <code class="fm-code-in-text2">CD</code> in order to end exactly on segment <code class="fm-code-in-text2">AB</code>.</p>

  <p class="body"><a id="pgfId-1005119"></a>We reuse this coefficient in listing 15.9, where we check the intersection between two graph edges.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015943"></a>Listing 15.9 Method <code class="fm-code-in-text">edgesIntersection</code></p>
  <pre class="programlisting"><b class="strong">function</b> edgesIntersection(e1, e2)                                     <span class="fm-combinumeral">❶</span>
  h = vectorScalingFactor(
      e1.source, e1.destination, e2.source, e2.destination)            <span class="fm-combinumeral">❷</span>
  g = vectorScalingFactor(
      e2.source, e2.destination, e1.source, e1.destination)
  <b class="strong">return</b> 0 <span class="cambria">≤</span> h <span class="cambria">≤</span> 1 <b class="strong">and</b> 0 <span class="cambria">≤</span> g <span class="cambria">≤</span> 1 <b class="strong">and not</b> (h <b class="strong">in</b> {0,1} <b class="strong">and</b> g <b class="strong">in</b> {0,1}) <span class="fm-combinumeral">❸</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1023621"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">edgesIntersection</code><a id="marker-1023699"></a> takes two edges and returns <code class="fm-code-in-text2">true</code><a id="marker-1023700"></a> if and only if the segment representations of the edges intersect.</p>

  <p class="fm-code-annotation"><a id="pgfId-1023640"></a><span class="fm-combinumeral">❷</span> We assume, for the sake of space, that the edge’s properties <code class="fm-code-in-text2">source</code> and <code class="fm-code-in-text2">destination</code> return points, which in turn have <code class="fm-code-in-text2">x</code> and <code class="fm-code-in-text2">y</code> fields for their coordinates.</p>

  <p class="fm-code-annotation"><a id="pgfId-1023657"></a><span class="fm-combinumeral">❸</span> As we have seen, there is an intersection if both <code class="fm-code-in-text2">h</code> and <code class="fm-code-in-text2">g</code> are between <code class="fm-code-in-text2">0</code> and <code class="fm-code-in-text2">1</code>, but if both are exactly <code class="fm-code-in-text2">0</code> or <code class="fm-code-in-text2">1</code>, then the edges are just adjacent.</p>

  <h3 class="fm-head2" id="heading_id_17"><a id="pgfId-1005293"></a>15.4.2 Polylines</h3>

  <p class="body"><a id="pgfId-1005305"></a>In <a id="marker-1007383"></a><a id="marker-1007387"></a><a id="marker-1007391"></a>our examples in chapter 15 we have drawn a few flowcharts by using polylines for edges, and specifically a subset of all polylines where the only segments allowed are parallel to the Cartesian axes. In this configuration, checking for intersections becomes somewhat easier, because while it’s true that for each edge we need to consider the segments composing it, checking the intersections of two segments that can either be vertical or horizontal becomes much easier and boils down to checking their endings’ coordinates.</p>

  <p class="body"><a id="pgfId-1005322"></a>One important difference with this representation is that the number of intersections between two edges is not just <code class="fm-code-in-text">0</code> or <code class="fm-code-in-text">1</code> anymore; they can intersect multiple times—one more reason to prefer other styles over <a id="marker-1007395"></a><a id="marker-1007399"></a><a id="marker-1007403"></a>polylines.</p>

  <h3 class="fm-head2" id="heading_id_18"><a id="pgfId-1005351"></a>15.4.3 Bézier curves</h3>

  <p class="body"><a id="pgfId-1005366"></a>An <a id="marker-1007407"></a><a id="marker-1007411"></a><a id="marker-1007415"></a>interesting and flexible alternative to polylines is provided by Bézier curves. These curves are a valuable solution because they can be drawn with a variable degree of precision, depending on the computational resources available. Bézier curves have a beautiful mathematical formula and are both flexible and precise. Going into the details of how they work is beyond the scope of this book, but we’ll try to give a quick introduction that should be enough to get you started. To the interested reader that would like to delve into this topic, we have two freely available online resources:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1005389"></a>Sederberg, Thomas W. “Computer aided geometric design” (2012).</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1005406"></a>“A Primer on Bézier Curves”, <span class="fm-hyperlink1"><a class="calibre14" href="https://pomax.github.io/bezierinfo/">https://pomax.github.io/bezierinfo/</a></span>.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1005422"></a>Let’s start building our intuition with the geometric definition of Bézier curves, shown in figure 15.21 for a quadratic curve.</p>

  <p class="body"><a id="pgfId-1005433"></a>A quadratic curve requires three points: two endpoints (<code class="fm-code-in-text">S</code> and <code class="fm-code-in-text">E</code> in figure 15.21) and a control point (<code class="fm-code-in-text">C<sub class="subscript1">1</sub></code>). First, we have to draw the two segments between the endpoints and <code class="fm-code-in-text">C<sub class="subscript1">1</sub></code>. Then we need to choose two points on those segments, under the constraint that if the point on <code class="fm-code-in-text">SC<sub class="subscript1">1</sub></code> (call it <code class="fm-code-in-text">A</code>) is such that <code class="fm-code-in-text">SA/SC=t</code>, then <code class="fm-code-in-text">B</code>, the endpoint on <code class="fm-code-in-text">EC<sub class="subscript1">1</sub></code>, must satisfy <code class="fm-code-in-text">EB/EC<sub class="subscript1">1</sub>=(1-t)</code>. These two points, <code class="fm-code-in-text">A</code> and <code class="fm-code-in-text">B</code>, will be the endpoints of another segment, <code class="fm-code-in-text">AB</code>, on which we choose a point <code class="fm-code-in-text">P<sub class="subscript1">t</sub></code> such that <code class="fm-code-in-text">AP<sub class="subscript1">t</sub>/AB=t</code>.</p>

  <p class="body"><a id="pgfId-1005490"></a>If <code class="fm-code-in-text">t==0</code>, then <code class="fm-code-in-text">P<sub class="subscript1">t</sub>==A</code>, while when <code class="fm-code-in-text">t==1</code> then <code class="fm-code-in-text">P<sub class="subscript1">t</sub>==B</code>. The collection of all these points <code class="fm-code-in-text">P<sub class="subscript1">t</sub></code>, for all values of <code class="fm-code-in-text">t</code> between <code class="fm-code-in-text">0</code> and <code class="fm-code-in-text">1</code>, makes a quadratic Bézier curve between <code class="fm-code-in-text">A</code> and <code class="fm-code-in-text">B</code>.</p>

  <p class="body"><a id="pgfId-1005527"></a>Notice how the segment <code class="fm-code-in-text">A<sub class="subscript1">t</sub>B<sub class="subscript1">t</sub></code> is always tangent to the curve.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F21.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028905"></a>Figure 15.21 How a quadratic Bézier curve is drawn. A quadratic curve requires three points: two endpoints (<code class="fm-code-in-text">S</code>, <code class="fm-code-in-text">E</code>) and a control point (<code class="fm-code-in-text">C<sub class="subscript1">1</sub></code>, or just <code class="fm-code-in-text">C</code> for the sake of clarity here henceforth). First we have to draw the two segments between the endpoints and <code class="fm-code-in-text">C</code>. Then, we can draw segments whose endpoints are on <code class="fm-code-in-text">S<sub class="subscript1">C</sub></code> and <code class="fm-code-in-text">EC</code>, under the constraint that if the endpoint on the former, call it <code class="fm-code-in-text">A</code>, is such that <code class="fm-code-in-text">SA/SC=t</code>, then <code class="fm-code-in-text">B</code>, the remaining endpoint, must satisfy <code class="fm-code-in-text">EB/EC=(1-t)</code>. Finally, on segment <code class="fm-code-in-text">AB</code>, we choose a point <code class="fm-code-in-text">P</code> such that <code class="fm-code-in-text">AP/AB=t</code>.</p>

  <p class="body"><a id="pgfId-1005604"></a>For cubic Bézier curves the procedure becomes a bit more involved, as shown in figure 15.22. There are two control points, <code class="fm-code-in-text">C<sub class="subscript1">1</sub></code> and <code class="fm-code-in-text">C<sub class="subscript1">2</sub></code>, and we first have to draw the segments <code class="fm-code-in-text">C<sub class="subscript1">1</sub>C<sub class="subscript1">2</sub></code> and select a point <code class="fm-code-in-text">C<sub class="subscript1">t</sub></code> on this segment. We’ll have to note the ratio between the two subsegments created by this point, <code class="fm-code-in-text">t=C<sub class="subscript1">1</sub>C<sub class="subscript1">t</sub>/C<sub class="subscript1">1</sub>C<sub class="subscript1">2</sub></code>.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F22.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028947"></a>Figure 15.22 Drawing a cubic Bézier curve. You can appreciate the increased complexity compared to quadratic curves.</p>

  <p class="body"><a id="pgfId-1005646"></a>Then we select two points <code class="fm-code-in-text">A<sub class="subscript1">t</sub></code> and <code class="fm-code-in-text">B<sub class="subscript1">t</sub></code> on the segments between the endpoints and the closest control point, such that <code class="fm-code-in-text">SA<sub class="subscript1">t</sub>/SC<sub class="subscript1">1</sub>=t and C<sub class="subscript1">2</sub>B<sub class="subscript1">t</sub>/C<sub class="subscript1">2</sub>E=t</code>.</p>

  <p class="body"><a id="pgfId-1005673"></a>Finally, for the three points <code class="fm-code-in-text">A<sub class="subscript1">t</sub></code>, <code class="fm-code-in-text">B<sub class="subscript1">t</sub></code> and <code class="fm-code-in-text">C<sub class="subscript1">t</sub></code>, we need to go through the same steps we performed for a quadratic curve, and select a point <code class="fm-code-in-text">P<sub class="subscript1">t</sub></code>.</p>

  <p class="body"><a id="pgfId-1005716"></a>Technically a Bézier curve is an iterative linear interpolation. When we select points <code class="fm-code-in-text">A<sub class="subscript1">t</sub></code>, <code class="fm-code-in-text">B<sub class="subscript1">t,</sub></code> (and <code class="fm-code-in-text">C<sub class="subscript1">t</sub></code>) we apply linear interpolation (varying the ratio <code class="fm-code-in-text">t</code>), and likewise we can do this for the segments between the generated points.</p>

  <p class="body"><a id="pgfId-1005743"></a>So, if we start with two segments (quadratic curve), we can apply linear interpolation twice to find the curve’s points. With three initial segments (cubic curve), we pick three points, which in turn define two new segments, and so on; we thus apply linear interpolation three times.</p>

  <p class="body"><a id="pgfId-1005758"></a>Following this definition, even a straight-line segment can be expressed as a Bézier curve. It has no control points and just 1 segment, so we apply linear interpolation once.</p>

  <p class="body"><a id="pgfId-1005773"></a>In this edge case, it’s easy to see that the generic point <code class="fm-code-in-text">P<sub class="subscript1">t</sub></code> is given by the vectorial equation:</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ7.png"/></p>

  <p class="body"><a id="pgfId-1005794"></a>We won’t derive it for a quadratic curve, but here is how it will look:</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ8.png"/></p>

  <p class="body"><a id="pgfId-1005812"></a>In general, for a Bézier curve with <code class="fm-code-in-text">n-2</code> control points, we can express its generic point as</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ9.png"/></p>

  <p class="body"><a id="pgfId-1005834"></a>using the conventions: <a id="marker-1007419"></a><a id="marker-1007423"></a><code class="fm-code-in-text">S=Q<sub class="subscript1">0</sub></code>, <code class="fm-code-in-text">E=Q<sub class="subscript1">n</sub></code> and <code class="fm-code-in-text">C<sub class="subscript1">i</sub>=Q<sub class="subscript1">i</sub></code> <span class="cambria">∀</span> <code class="fm-code-in-text">i=1,..,n-1</code>.</p>

  <h3 class="fm-head2" id="heading_id_19"><a id="pgfId-1005865"></a>15.4.4 Intersections between quadratic Bézier curves</h3>

  <p class="body"><a id="pgfId-1005885"></a>In <a id="marker-1007427"></a><a id="marker-1007431"></a>our examples, we are only going to use a subset of the set of Bézier curves—<i class="calibre17">symmetric quadratic Bézier curves</i><a id="marker-1007435"></a> where the control point lies at exactly the same distance between the two endpoints. This way, we can simplify the way we reason about the curve and the way we look for intersections.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F23.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1028992"></a>Figure 15.23 A quadratic Bézier curve where the control point lies at the same distance from the endpoints. The tangent to the curve parallel to the segment <code class="fm-code-in-text">s<sub class="calibre33">E</sub></code> is at a distance of <code class="fm-code-in-text">d/2</code> from that segment, where <code class="fm-code-in-text">d</code> is the distance of point <code class="fm-code-in-text">C</code> from segment <code class="fm-code-in-text">s<sub class="calibre33">E</sub></code>.</p>

  <p class="body"><a id="pgfId-1005906"></a>Looking at figure 15.23, we can see a few interesting facts:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1005915"></a>The curve is always going to be a section of a parabola.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1005928"></a>We can store point <code class="fm-code-in-text">C</code> by using a single real value (the distance from the line passing through the endpoints).</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1005943"></a>The tangent to the curve that’s parallel to segment <code class="fm-code-in-text">s<sub class="calibre33">E</sub></code> is exactly halfway between the same segment and point <code class="fm-code-in-text">C</code>.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1005990"></a>We’ll see later why the third point is especially important for us.</p>

  <p class="body"><a id="pgfId-1006001"></a>First, we need to give a brief overview of the methods that can be used to check intersections between Bézier curves:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1006013"></a><i class="calibre15">Bézier subdivision</i> is a method based on <i class="calibre15">convex hull</i><a class="calibre14" id="marker-1007439"></a> <a class="calibre14" href="#pgfId-1008015"><sup class="footnotenumber">29</sup></a>—For a Bézier curve with <code class="fm-code-in-text">n-2</code> control points, its convex hull is the polygon with <code class="fm-code-in-text">n</code> sides whose vertices are the endpoints and control points. Figure 15.24 illustrates how it’s possible to compute the intersection of two curves by comparing their convex hulls. If they do not overlap, the curves do not intersect; otherwise, the curves are each split in half and the two halves of one curve are checked for overlap against the two halves of the other curve. This step can be iterated until either there is no overlap between any pair of sections, or the curves are split into sections so small that they can be approximated with segments (within a certain acceptable error). Then, we can just use the algorithm in section 15.4.1 to check that no pairs of segments intersect.</p>

      <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F24.png"/></p>

      <p class="fm-figure-caption"><a id="pgfId-1029040"></a>Figure 15.24 The Bézier subdivision method in action (first iteration). The points shown are the actual control points of cubic curves. This method can obviously also be applied to quadratic, quartic, or generic curves.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006065"></a><i class="calibre15">Bézier clipping</i>—For generic Bézier curves, this is the most efficient method, but also the most complicated. We won’t get into the details for this one.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1022268"></a><i class="calibre15">Interval subdivision—</i>This is similar to Bézier clipping, but it adapts better to our stricter requirements. The difference is that in this case, we first find the vertical and horizontal tangents to the curve. By splitting the curve, making sure that the points where its tangent is parallel to one of the axes are at the extremes of each segment, we guarantee that in each segment the curve is monotone (because a function can change its trend only in such points), and that for each value point on the <code class="fm-code-in-text">x</code> axes, there is only one point belonging to the curve in each one of these sections. Figure 15.25 illustrates how it works for a generic Bézier curve. In turn, we can use these properties to further split the curve by halving each segment along the <code class="fm-code-in-text">x</code> axis and computing the exact point on the curve. This point will be one of the corners of each section’s bounding box, and we can easily compare the bounding boxes of two curves. They will all be parallel to the Cartesian axis, so we just need to check a few inequalities to find out if they intersect.</p>

      <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F25.png"/></p>

      <p class="fm-figure-caption"><a id="pgfId-1029085"></a>Figure 15.25 The interval subdivision method in action on a generic Bézier curve</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1006127"></a>Applying the interval subdivision method to symmetric quadratic Bézier curves is even simpler, because these curves have at most two points where its tangent is parallel to one of the axes. Moreover, we can easily compute an initial, coarse-grained bounding box for each of these curves. As shown in figure 15.26, they all lie within the rectangle delimited by the line passing through its endpoints, the parallel to the former tangent to the apex of the curve (at distance <code class="fm-code-in-text">d/2</code> from segment <code class="fm-code-in-text">s<sub class="calibre33">E</sub></code>, as we have previously mentioned), and the perpendicular lines to <code class="fm-code-in-text">s<sub class="calibre33">E</sub></code> passing to those endpoints.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F26.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1029127"></a>Figure 15.26 The interval subdivision method used to check intersections between two symmetric, quadratic Bézier curves (A). (B) Compute the bounding boxes using what we know about the curve’s tangents at apex. Here, they overlap. (C) We thus need to move forward, computing the tangents to the curve parallel to the axes, and use them as pivot points at which we can split the curves. Each section is now monotonic and can be interpolated with a segment. Each pair of sections from the two curves will at most cross in one point. (D) For each section in curve C1, compute the intersections using only the overlapping sections in curve C2 (then sum the results for each of the three cases). (E) We can split each section further by halving it. Only some sub-sections will still overlap, and we can iterate steps (D-E) until they become small enough that the error in approximating a curve with a segment is within a given threshold.</p>

  <p class="body"><a id="pgfId-1006174"></a>Therefore, we can informally define the algorithm to check for intersection of two symmetric quadratic Bézier curves as the following steps:</p>

  <ol class="calibre18">
    <li class="fm-list-numbered">
      <p class="list"><a class="calibre14" id="pgfId-1006185"></a>Compute the bounding boxes of the two curves, as shown in figure 15.26 (A).</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006198"></a>If the bounding boxes do not intersect, return 0; if they do, continue.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006211"></a>Compute the vertical and horizontal tangents to each curve, and use them to split the curve into two or three sections (depending on if they have both tangents or just one).</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006226"></a>Recursively</p>

      <ol class="calibre35">
        <li class="fm-list-numbered1">
          <p class="list"><a class="calibre14" id="pgfId-1006238"></a>For each of the sections of curve <code class="fm-code-in-text">C<sub class="subscript1">1</sub></code>, check which sections in curve <code class="fm-code-in-text">C<sub class="subscript1">2</sub></code> it overlaps.</p>
        </li>

        <li class="fm-list-numbered1">
          <p class="list"><a class="calibre14" id="pgfId-1006256"></a>If no two sections overlap, return 0.</p>
        </li>

        <li class="fm-list-numbered1">
          <p class="list"><a class="calibre14" id="pgfId-1006269"></a>Otherwise, return the sum<a class="calibre14" href="#pgfId-1008030"><sup class="footnotenumber">30</sup></a> of the intersections for the remote calls among the overlapping pairs:</p>

          <ol class="calibre36">
            <li class="fm-list-bullet1">
              <p class="list"><a class="calibre14" id="pgfId-1006283"></a>For each pair of overlapping sections.</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list"><a class="calibre14" id="pgfId-1006296"></a>Split each of the overlapping sections in half.</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list"><a class="calibre14" id="pgfId-1006309"></a>If the sections are small enough to be approximated with segments, compute the segments’ intersection.</p>
            </li>

            <li class="fm-list-bullet1">
              <p class="list"><a class="calibre14" id="pgfId-1006324"></a>Otherwise, recursively check the four sections resulting from the split.</p>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <p class="body"><a id="pgfId-1006338"></a>If we compare this algorithm to the one in section 15.4.1 for segment intersection, the main difference that stands out is that this algorithm is recursive (or equivalently iterative), while for segments we only need to perform a constant number of operations.</p>

  <p class="body"><a id="pgfId-1006347"></a>This means that if we use curves instead of segments, computing the edge crossing at each iteration of an optimization algorithm is going to be much more expensive.</p>

  <p class="body"><a id="pgfId-1006356"></a>Moreover, with quadratic curves we already have four possible intersections for each pair of edges, and for cubic curves it’s obviously even worse: we have more parameters to optimize, and each change can make a greater difference.</p>

  <p class="body"><a id="pgfId-1006367"></a>That’s why we are focusing on straight-line drawings. One should really double-check the requirements and discuss the benefits and costs, before deciding to embark on the more challenging enterprise of curve-line <a id="marker-1007443"></a><a id="marker-1007447"></a><a id="marker-1007451"></a>embeddings.</p>

  <h3 class="fm-head2" id="heading_id_20"><a id="pgfId-1006386"></a>15.4.5 Vertex-vertex and edge-vertex intersections</h3>

  <p class="body"><a id="pgfId-1006406"></a>So <a id="marker-1007455"></a><a id="marker-1007459"></a><a id="marker-1007463"></a>far, we have delayed the discussion about validating an embedding by checking that no pair of vertices share the same position, and that no edge crosses a vertex.</p>

  <p class="body"><a id="pgfId-1006419"></a>There are many ways to draw edges, as we have seen, but there are also many ways to draw vertices: they can be punctiform, they can be drawn as circles, but they can also be drawn as squares, octagons, or any kind of polygon, really. Depending on these choices, we’ll need a different algorithm.</p>

  <p class="body"><a id="pgfId-1006428"></a>Here, we’ll assume that vertices are drawn with circles (punctiform vertices being an edge-case, a circle with a radius close to zero), and edges are drawn with segments. This will give you the tools to handle the simplest solution and a basis to build more complex ones, if needed.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F27.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1029172"></a>Figure 15.27 Vertex intersection with another vertex. For two circles to overlap, the distance <code class="fm-code-in-text">d</code> between their centers must be smaller than the sum of the circles’ radii. If <code class="fm-code-in-text">d&gt;r<sub class="subscript1">v</sub>+r<sub class="subscript1">u</sub></code>, as in (A), we are clear; when <code class="fm-code-in-text">d</code><span class="cambria">≤</span><code class="fm-code-in-text">r<sub class="subscript1">v</sub>+r<sub class="subscript1">u</sub></code>, as in (B), the two circles overlap.</p>

  <p class="body"><a id="pgfId-1006441"></a>For vertices, in particular, if you choose to use squares or regular polygons, you can always consider the <i class="calibre17">circumscribed circle</i><a id="marker-1007467"></a><a href="#pgfId-1008045"><sup class="footnotenumber">31</sup></a> or <i class="calibre17">minimum bounding circle</i><a id="marker-1007471"></a><a href="#pgfId-1008061"><sup class="footnotenumber">32</sup></a> of the polygon and change the constraints considering these circles instead of the actual shape of the vertices.</p>

  <p class="body"><a id="pgfId-1006458"></a>Using circles makes our lives a lot easier; it allows us to just check the distance between two vertices (between their centers) or between a vertex and an edge.</p>

  <p class="body"><a id="pgfId-1006473"></a>For two vertices, the algorithm is trivial: we just need to check that the distance between their centers is larger than the sum of their radii. Figure 15.27 shows why.</p>

  <p class="body"><a id="pgfId-1006516"></a>To make sure an edge doesn’t overlap with a vertex (which is not an endpoint for the edge), we need to make sure that the distance between the edge and the vertex is larger than the vertex’s radius.</p>

  <p class="body"><a id="pgfId-1006525"></a>In turn, when edges are drawn with straight-line segments, this forces us to check three distances. If the distances between the two segment’s endpoints (<code class="fm-code-in-text">S</code>, <code class="fm-code-in-text">E</code> in figure 15.28) and the vertex’s center (let’s call it <code class="fm-code-in-text">C</code>) are smaller than the vertex radius, then we certainly have an intersection. Even if these distances are larger, though, the vertex could intersect the edge somewhere in the middle, so we need to check the distance between the line passing through the segment and the vertex’s center, and that the point of minimum distance between the vertex and the line falls inside the segment.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F28.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1029217"></a>Figure 15.28 Vertex intersection with a segment. When considering the distance between a segment and a vertex, there are cases (<code class="fm-code-in-text">v</code> in the figure) where we need to use the line-point distance, and others where the distance to an extreme is what matters.</p>

  <p class="body"><a id="pgfId-1006572"></a>To find the point-to-segment distance, we can use the following formula (which we won’t derive here):</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch15_F_EQ10.png"/></p>

  <p class="body"><a id="pgfId-1006590"></a>And finally, to check if the intersection between the line passing through the segment and the line of minimum distance to a vertex (a line perpendicular to the segment passing through a vertex) falls within or outside a segment, we can use the same algorithm we developed for segment intersection, using points <code class="fm-code-in-text">S</code> and <code class="fm-code-in-text">E</code> on one side, and <code class="fm-code-in-text">v</code> and <code class="fm-code-in-text">P<sub class="subscript1">v</sub></code> (or <code class="fm-code-in-text">u</code> and <code class="fm-code-in-text">P<sub class="subscript1">u</sub></code>) on the other side. We just need to check that the multiplicator factor is between 0 <a id="marker-1007475"></a><a id="marker-1007479"></a><a id="marker-1007483"></a>and <a id="marker-1007487"></a><a id="marker-1007491"></a>1.</p>

  <h2 class="fm-head" id="heading_id_21"><a id="pgfId-1006624"></a>Summary</h2>

  <ul class="calibre19">
    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006636"></a>Graphs are abstract algebraic structures; to visualize them, it’s possible to embed a graph to a geometrical space.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006650"></a>An embedding is a mapping between vertices and points in a Euclidean space, and between edges and (Jordan) curves in the same space.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006665"></a>If an embedding maps a graph to the plane, and none of the edges intersect another edge or a vertex (besides its endpoints), then the embedding is called a planar embedding.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006678"></a>While it’s possible to embed all graphs in the 3-D Euclidean space without edge intersections, not all graphs are planar.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006694"></a>If we restrict the shape of the edges to straight-line segments, instead of generic Jordan curves, for some graphs it’s not possible to find a straight-line drawing<a class="calibre14" id="marker-1007495"></a> with the minimum possible number of intersections.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006709"></a>Computing if and how edges cross is not easy. In straight-line drawings it’s less expensive because checking two segments only requires a constant number of operations on vectors. When moving to curves, recursive algorithms (or their iterative counterparts) are <a class="calibre14" id="marker-1007499"></a>needed.</p>
    </li>
  </ul>
  <hr class="calibre22"/>

  <p class="fm-footnote"><sup class="footnotenumber">1.</sup> <a id="pgfId-1007520"></a>A knowledge graph is an extremely advanced data structure that organizes data in the form of a graph providing in a single DS the data itself and a way to understand it. Google’s knowledge graph, for example, is used to refine searches through semantics.</p>

  <p class="fm-footnote"><sup class="footnotenumber">2.</sup> <a id="pgfId-1007534"></a>Graph databases leverage the fact that modern data is highly interconnected, to allow organizing and querying information in a semantic way, using the graph’s edges to model dynamic relations between pieces of data (the graph’s vertices). This can be thought of as taking a relational DB, like a classical SQL DB, and making it more flexible and even more powerful. Take a look, for instance, at Neo4J in action, or Fullstack GraphQL.</p>

  <p class="fm-footnote"><sup class="footnotenumber">3.</sup> <a id="pgfId-1007556"></a>In this case, for PCBs, the edges are limited to polylines made of perpendicular segments.</p>

  <p class="fm-footnote"><sup class="footnotenumber">4.</sup> <a id="pgfId-1007571"></a>For instance, nobody would be expected to understand Google’s knowledge graph by taking a glance at it (especially considering that it has a humongous number of vertices and edges): that graph, or graph databases, is not meant to be processed by the human mind, but through algorithms.</p>

  <p class="fm-footnote"><sup class="footnotenumber">5.</sup> <a id="pgfId-1007593"></a>A Jordan curve is a planar, simple and closed curve, a non-self-intersecting continuous loop in the plane.</p>

  <p class="fm-footnote"><sup class="footnotenumber">6.</sup> <a id="pgfId-1007615"></a>We’ll also have to discuss what makes an embedding the best or at least better: “having fewer intersections” is a good starting point, though.</p>

  <p class="fm-footnote"><sup class="footnotenumber">7.</sup> <a id="pgfId-1007629"></a>While we present ways to solve this problem, we’ll introduce new algorithms and techniques that can also be applied to other areas besides graphs.</p>

  <p class="fm-footnote"><sup class="footnotenumber">8.</sup> <a id="pgfId-1007643"></a>It doesn’t matter how we label the vertices, because vertices are isomorphic: equivalent one to another, and each adjacent to all the other vertices.</p>

  <p class="fm-footnote"><sup class="footnotenumber">9.</sup> <a id="pgfId-1007658"></a>Besides being computationally heavy, state-of-the-art computer vision needs a large dataset and a long time to train, and obviously it doesn’t provide a deterministic algorithm.</p>

  <p class="fm-footnote"><sup class="footnotenumber">10.</sup> <a id="pgfId-1007680"></a>The first condition can be checked in constant time if we have the information about the size of the graph.</p>

  <p class="fm-footnote"><sup class="footnotenumber">11.</sup> <a id="pgfId-1007694"></a>We won’t have the space here to describe this algorithm, but you can find a description online at <span class="fm-hyperlink"><a href="https://en.wikipedia.org/wiki/Biconnected_component">https:// en.wikipedia.org/wiki/Biconnected_component</a></span>.</p>

  <p class="fm-footnote"><sup class="footnotenumber">12.</sup> <a id="pgfId-1007709"></a>See <span class="fm-hyperlink"><a href="https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction#graph">https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction#graph</a></span></p>

  <p class="fm-footnote"><sup class="footnotenumber">13.</sup> <a id="pgfId-1007724"></a>A recurrence relation is an equation that recursively defines a sequence of values, where each term of the sequence is defined as a function of the preceding terms. Check out appendix B for more on how to solve recurrence relations.</p>

  <p class="fm-footnote"><sup class="footnotenumber">14.</sup> <a id="pgfId-1007742"></a>Imagine, for the sake of providing a simple example, that at line #2 we are using the empty graph as a base to halt the recursion.</p>

  <p class="fm-footnote"><sup class="footnotenumber">15.</sup> <a id="pgfId-1007756"></a>We write E-{1} as a shortened notation for E-{(1,v) | v<span class="cambria">ϵ</span>{2,3}, (1,v) <span class="cambria">ϵ</span>E}, and similarly for the other vertices.</p>

  <p class="fm-footnote"><sup class="footnotenumber">16.</sup> <a id="pgfId-1007774"></a>See appendix E on recursion and the use of memoization to prevent stack overflow.</p>

  <p class="fm-footnote"><sup class="footnotenumber">17.</sup> <a id="pgfId-1007790"></a>See <span class="fm-hyperlink"><a href="https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction#graph">https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction#graph</a></span></p>

  <p class="fm-footnote"><sup class="footnotenumber">18.</sup> <a id="pgfId-1007805"></a>In terms of effort to write and maintain the code.</p>

  <p class="fm-footnote"><sup class="footnotenumber">19.</sup> <a id="pgfId-1007819"></a>For a comprehensive summary, check out Patrignani, Maurizio. “<i class="calibre17">Planarity Testing and Embedding</i>,” in <i class="calibre17">Handbook of Graph Drawing and Visualization</i>, (Chapman and Hall/CRC, 2013), 1–42.</p>

  <p class="fm-footnote"><sup class="footnotenumber">20.</sup> <a id="pgfId-1007839"></a>Hopcroft, John; Tarjan, Robert E. (1974), “Efficient planarity testing,” <i class="calibre17">Journal of the Association for Computing Machinery</i>, 21 (4): 549–568</p>

  <p class="fm-footnote"><sup class="footnotenumber">21.</sup> <a id="pgfId-1007860"></a>Tarjan, R. E. “Implementation of an efficient algorithm for planarity testing of graphs.” unpublished implementation, Dec (1969).</p>

  <p class="fm-footnote"><sup class="footnotenumber">22.</sup> <a id="pgfId-1007875"></a>As we have already seen, an induced subgraph is obtained by removing one or more vertices from the original graph.</p>

  <p class="fm-footnote"><sup class="footnotenumber">23.</sup> <a id="pgfId-1007889"></a>Boyer, John M.; Myrvold, Wendy J. (2004), “On the cutting edge: simplified O(n) planarity by edge addition” (PDF), <i class="calibre17">Journal of Graph Algorithms and Applications</i>, 8 (3): 241–273</p>

  <p class="fm-footnote"><sup class="footnotenumber">24.</sup> <a id="pgfId-1007909"></a>de Fraysseix, Hubert; Ossona de Mendez, Patrice; Rosenstiehl, Pierre (2006), “Trémaux trees and planarity,” <i class="calibre17">International Journal of Foundations of Computer Science</i>, 17 (5): 1017–1029.</p>

  <p class="fm-footnote"><sup class="footnotenumber">25.</sup> <a id="pgfId-1007936"></a>Clancy, Kieran, Michael Haythorpe, and Alex Newcombe. “A survey of graphs with known or bounded crossing numbers.” arXiv preprint arXiv:1901.05155 (2019).</p>

  <p class="fm-footnote"><sup class="footnotenumber">26.</sup> <a id="pgfId-1007958"></a>Haythorpe, M. “QuickCross--Crossing Number Problem”.</p>

  <p class="fm-footnote"><sup class="footnotenumber">27.</sup> <a id="pgfId-1007977"></a>Two edges are adjacent if they have at least one vertex in common; in a pair of non-adjacent edges, therefore, all the four vertices are distinct.</p>

  <p class="fm-footnote"><sup class="footnotenumber">28.</sup> <a id="pgfId-1007996"></a>Bienstock, Daniel, and Nathaniel Dean. “Bounds for rectilinear crossing numbers.” <i class="calibre17">Journal of Graph Theor</i>y 17.3 (1993): 333-348.</p>

  <p class="fm-footnote"><sup class="footnotenumber">29.</sup> <a id="pgfId-1008015"></a>The convex hull of a shape is the smallest convex set that contains it.</p>

  <p class="fm-footnote"><sup class="footnotenumber">30.</sup> <a id="pgfId-1008030"></a>Remember that while two segments only cross at most in one point, two parabolas can cross in up to four points. Once we split both curves along the tangent points, each section can only cross another section at most once.</p>

  <p class="fm-footnote"><sup class="footnotenumber">31.</sup> <a id="pgfId-1008045"></a>The circumscribed circle is a circle passing through all vertices of a polygon.</p>

  <p class="fm-footnote"><sup class="footnotenumber">32.</sup> <a id="pgfId-1008061"></a>The minimum bounding circle is the smallest circle covering all points in a set.</p>
</body>
</html>
