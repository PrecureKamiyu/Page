<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3.4   Additional Basic Operations</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part87.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part89.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">3.4   <span style=" color: #00AEEF;">Additional Basic Operations</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">A number of additional basic operations are supported in <span class="s44">SQL</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">3.4.1 The Rename Operation</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">Consider again the query that we used earlier:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_338.png"/></span></p><p class="s13" style="padding-left: 239pt;text-indent: 0pt;text-align: left;"><b>select </b>name<span class="p">, </span>course id</p><p class="s13" style="padding-left: 239pt;text-indent: 0pt;text-align: left;"><b>from </b>instructor<span class="p">, </span>teaches</p><p style="padding-left: 239pt;text-indent: 0pt;text-align: left;"><b>where </b><i>instructor</i>.<span class="s69">ID</span><span class="s15">= </span><i>teaches</i>.<span class="s69">ID</span>;</p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">The result of this query is a relation with the following attributes:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_339.png"/></span></p><p class="s13" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">name<span class="p">, </span>course id</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">The names of the attributes in the result are derived from the names of the attributes in the relations in the <b>from </b>clause.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We cannot, however, always derive names in this way, for several reasons: First, two relations in the <b>from </b>clause may have attributes with the same name, in which case an attribute name is duplicated in the result. Second, if we use an arithmetic expression in the <b>select </b>clause, the resultant attribute does not have a name. Third, even if an attribute name can be derived from the base relations as in the preceding example, we may want to change the attribute name in the result. Hence, <span class="s44">SQL </span>provides a way of renaming the attributes of a result relation. It uses the <span class="s63">as clause</span>, taking the form:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-left: 59pt;text-indent: 0pt;text-align: center;">Note 3.1 <span class="s146">SQL AND MULTISET RELATIONAL ALGEBRA - PART 1</span></p><p style="padding-top: 9pt;padding-left: 97pt;text-indent: 0pt;text-align: justify;">There is a close connection between relational algebra operations and <span class="s44">SQL </span>op- erations. One key diﬀerence is that, unlike the relational algebra, <span class="s44">SQL </span>allows du- plicates. The <span class="s44">SQL </span>standard deﬁnes how many copies of each tuple are there in the output of a query, which depends, in turn, on how many copies of tuples are present in the input relations.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">To model this behavior of <span class="s44">SQL</span>, a version of relational algebra, called the <span class="s63">mul- tiset relational algebra</span>, is deﬁned to work on multisets: sets that may contain dupli- cates. The basic operations in the multiset relational algebra are deﬁned as follows:</p><p class="s13" style="padding-top: 10pt;padding-left: 123pt;text-indent: -16pt;line-height: 86%;text-align: left;"><span class="s63">1. </span><span class="p">If there are </span>c<span class="s130">1 </span><span class="s94">copies of tuple </span>t<span class="s130">1 </span><span class="s94">in </span>r<span class="s130">1</span><span class="s94">, and </span>t<span class="s130">1 </span><span class="s94">satisﬁes selection </span><span class="s15">σ</span><span class="s137">θ</span><span class="p">, then there are </span>c<span class="s130">1 </span><span class="s94">copies of </span>t<span class="s130">1 </span><span class="s94">in </span><span class="s15">σ</span><span class="s137">θ</span><span class="p">(</span>r<span class="s130">1</span><span class="s94">).</span></p><p class="s13" style="padding-top: 5pt;padding-left: 123pt;text-indent: -17pt;line-height: 89%;text-align: left;"><span class="s63">2. </span><span class="p">For each copy of tuple </span>t<span class="s93">1 </span><span class="s94">in </span>r<span class="s93">1</span><span class="s94">, there is a copy of tuple </span><span class="s15">Π</span><span class="s123">A</span><span class="p">(</span>t<span class="s93">1</span><span class="s94">) in </span><span class="s15">Π</span><span class="s123">A</span><span class="p">(</span>r<span class="s93">1</span><span class="s94">), where </span><span class="s15">Π</span><span class="s123">A</span><span class="p">(</span>t<span class="s93">1</span><span class="s94">) denotes the projection of the single tuple </span>t<span class="s93">1</span><span class="s94">.</span></p><p class="s13" style="padding-top: 6pt;padding-left: 123pt;text-indent: -17pt;line-height: 73%;text-align: left;"><span class="s63">3. </span><span class="p">If there are </span>c<span class="s130">1 </span><span class="s94">copies of tuple </span>t<span class="s130">1 </span><span class="s94">in </span>r<span class="s130">1 </span><span class="s94">and </span>c<span class="s130">2 </span><span class="s94">copies of tuple </span>t<span class="s130">2 </span><span class="s94">in </span>r<span class="s130">2</span><span class="s94">, there are </span>c<span class="s130">1 </span><span class="s15">∗ </span>c<span class="s130">2 </span><span class="s94">copies of the tuple </span>t<span class="s130">1</span><span class="s83">.</span>t<span class="s130">2 </span><span class="s94">in </span>r<span class="s130">1 </span><span class="s15">× </span>r<span class="s130">2</span><span class="s94">.</span></p><p style="padding-top: 5pt;padding-left: 87pt;text-indent: 0pt;text-align: right;">For example, suppose that relations <i>r</i><span class="s98">1</span> with schema (<i>A</i>, <i>B</i>) and <i>r</i><span class="s98">2</span> with schema</p><p style="padding-left: 87pt;text-indent: 0pt;text-align: right;">(<i>C</i>) are the following multisets: <i>r</i><span class="s98">1</span> <span class="s15">= {</span>(1, <i>a</i>), (2, <i>a</i>)<span class="s15">} </span>and <i>r</i><span class="s98">2</span> <span class="s15">= {</span>(2), (3), (3)<span class="s15">}</span>. Then</p><p style="padding-left: 97pt;text-indent: 0pt;text-align: justify;"><span class="s15">Π</span><i>B</i>(<i>r</i><span class="s130">1</span><span class="s94">) would be </span><span class="s15">{</span>(<i>a</i>), (<i>a</i>)<span class="s15">}</span>, whereas <span class="s15">Π</span><i>B</i>(<i>r</i><span class="s130">1</span><span class="s94">) </span><span class="s15">× </span><i>r</i><span class="s130">2 </span><span class="s94">would be:</span></p><p style="padding-top: 6pt;padding-left: 62pt;text-indent: 0pt;text-align: center;"><span class="s15">{</span>(<i>a</i>, 2), (<i>a</i>, 2), (<i>a</i>, 3), (<i>a</i>, 3), (<i>a</i>, 3), (<i>a</i>, 3)<span class="s15">}</span></p><p style="padding-top: 9pt;padding-left: 115pt;text-indent: 0pt;text-align: left;">Now consider a basic <span class="s44">SQL </span>query of the form:</p><p class="s13" style="padding-top: 7pt;padding-left: 232pt;text-indent: 0pt;line-height: 86%;text-align: left;"><b>select </b>A<span class="s98">1</span><span class="p">, </span>A<span class="s98">2</span><span class="p">, </span><span class="s15">… </span><span class="p">, </span>A<span class="s97">n </span><b>from </b>r<span class="s130">1</span><span class="s94">, </span>r<span class="s130">2</span><span class="s94">, </span><span class="s15">… </span><span class="p">, </span>r<span class="s97">m </span><b>where </b>P</p><p style="padding-top: 6pt;padding-left: 97pt;text-indent: 0pt;line-height: 94%;text-align: justify;">Each <i>A</i><span class="s97">i </span>represents an attribute, and each <i>r</i><span class="s97">i </span>a relation. <i>P </i>is a predicate. If the <b>where </b>clause is omitted, the predicate <i>P </i>is <b>true</b>. The query is equivalent to the multiset relational-algebra expression:</p><p class="s15" style="padding-top: 7pt;padding-left: 64pt;text-indent: 0pt;text-align: center;">Π<span class="s123">A</span><span class="s158">1 </span><span class="s159">, </span><span class="s149">A</span><span class="s158">2 </span><span class="s159">,</span><span class="s136">…</span><span class="s130">,</span><span class="s149">A</span><span class="s160">n </span><span class="p">(</span>σ<span class="s123">P</span><span class="s13"> </span><span class="p">(</span><span class="s13">r</span><span class="s130">1 </span>× <span class="s13">r</span><span class="s130">2 </span>× <span class="s86">⋯ </span>× <span class="s13">r</span><span class="s97">m</span><span class="p">))</span></p><p style="padding-top: 6pt;padding-left: 97pt;text-indent: 17pt;text-align: justify;">The relational algebra <i>select </i>operation corresponds to the <span class="s44">SQL </span><b>where </b>clause, not to the <span class="s44">SQL </span><b>select </b>clause; the diﬀerence in meaning is an unfortunate historical fact. We discuss the representation of more complex <span class="s44">SQL </span>queries in Note 3.2 on page 97.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">The relational-algebra representation of <span class="s44">SQL </span>queries helps to formally deﬁne the meaning of the <span class="s44">SQL </span>program. Further, database systems typically translate <span class="s44">SQL </span>queries into a lower-level representation based on relational algebra, and they perform query optimization and query evaluation using this representation.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="493" height="745" alt="image" src="Image_340.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 259pt;text-indent: 0pt;text-align: left;">old-name <b>as </b>new-name</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 19pt;text-indent: 0pt;text-align: center;">The <b>as </b>clause can appear in both the <b>select </b>and <b>from </b>clauses.<span class="s76">3</span></p><p style="padding-left: 107pt;text-indent: 0pt;text-align: center;">For example, if we want the attribute name <i>name </i>to be replaced with the name</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_341.png"/></span></p><p class="s13" style="padding-left: 78pt;text-indent: 0pt;text-align: center;">instructor name<span class="p">, we can rewrite the preceding query as:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_342.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_343.png"/></span></p><p class="s13" style="padding-left: 220pt;text-indent: 0pt;text-align: left;"><b>select </b>name <b>as </b>instructor name<span class="p">, </span>course id</p><p class="s13" style="padding-left: 220pt;text-indent: 0pt;text-align: left;"><b>from </b>instructor<span class="p">, </span>teaches</p><p style="padding-left: 220pt;text-indent: 0pt;text-align: left;"><b>where </b><i>instructor</i>.<span class="s69">ID</span><span class="s15">= </span><i>teaches</i>.<span class="s69">ID</span>;</p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <b>as </b>clause is particularly useful in renaming relations. One reason to rename a relation is to replace a long relation name with a shortened version that is more convenient to use elsewhere in the query. To illustrate, we rewrite the query “For all instructors in the university who have taught some course, ﬁnd their names and the course <span class="s44">ID </span>of all courses they taught.”</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_344.png"/></span></p><p class="s13" style="padding-left: 236pt;text-indent: 0pt;text-align: left;"><b>select </b>T <span class="p">.</span>name<span class="p">, </span>S<span class="p">.</span>course id</p><p class="s13" style="padding-left: 236pt;text-indent: 0pt;text-align: left;"><b>from </b>instructor <b>as </b>T <span class="p">, </span>teaches <b>as </b>S</p><p style="padding-left: 236pt;text-indent: 0pt;text-align: left;"><b>where </b><i>T </i>.<span class="s69">ID</span><span class="s15">= </span><i>S</i>.<span class="s69">ID</span>;</p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Another reason to rename a relation is a case where we wish to compare tuples in the same relation. We then need to take the Cartesian product of a relation with itself and, without renaming, it becomes impossible to distinguish one tuple from the other. Suppose that we want to write the query “Find the names of all instructors whose salary is greater than at least one instructor in the Biology department.” We can write the <span class="s44">SQL </span>expression:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 190pt;text-indent: 0pt;text-align: left;"><b>select distinct </b>T <span class="p">.</span>name</p><p class="s13" style="padding-left: 190pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><b>from </b>instructor <b>as </b>T <span class="p">, </span>instructor <b>as </b>S</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_345.png"/></span></p><p class="s13" style="padding-left: 190pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><b>where </b>T.salary <span class="s83">&gt; </span>S.salary <b>and </b>S.dept name <span class="s15">= </span><span class="p">&#39;Biology&#39;;</span></p><p style="padding-top: 5pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Observe that we could not use the notation <i>instructor.salary</i>, since it would not be clear which reference to <i>instructor </i>is intended.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In the above query, <i>T </i>and <i>S </i>can be thought of as copies of the relation <i>instructor</i>, but more precisely, they are declared as aliases, that is, as alternative names, for the relation <i>instructor</i>. An identiﬁer, such as <i>T </i>and <i>S</i>, that is used to rename a relation is referred to as a <span class="s63">correlation name </span>in the <span class="s44">SQL </span>standard, but it is also commonly referred to as a <span class="s63">table alias</span>, or a <span class="s63">correlation variable</span>, or a <span class="s63">tuple variable</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_346.png"/></span></p><p class="s80" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s77">3</span><span class="s78">Early versions of </span><span class="s153">SQL </span><span class="s78">did not include the keyword </span><b>as</b>. As a result, some implementations of <span class="s161">SQL</span>, notably Oracle, do not permit the keyword <b>as </b>in the <span class="s162">from </span>clause. In Oracle, “<i>old-name </i><b>as </b><i>new-name</i>” is written instead as “<i>old-name new-name</i>” in the <b>from </b>clause. The keyword <b>as </b>is permitted for renaming attributes in the <b>select </b>clause, but it is optional and may be omitted in Oracle.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Note that a better way to phrase the previous query in English would be “Find the names of all instructors who earn more than the lowest paid instructor in the Biology department.” Our original wording ﬁts more closely with the <span class="s44">SQL </span>that we wrote, but the latter wording is more intuitive, and it can in fact be expressed directly in <span class="s44">SQL </span>as we shall see in Section 3.8.2.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">3.4.2 String Operations</p><p class="s42" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">SQL <span class="s43">speciﬁes strings by enclosing them in single quotes, for example, &#39;Computer&#39;. A single quote character that is part of a string can be speciﬁed by using two single quote characters; for example, the string “It’s right” can be speciﬁed by &#39;It&#39;&#39;s right&#39;.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s44">SQL </span>standard speciﬁes that the equality operation on strings is case sensitive; as a result, the expression “&#39;comp. sci.&#39; = &#39;Comp. Sci.&#39;” evaluates to false. However, some database systems, such as <span class="s44">M</span>y<span class="s44">SQL </span>and <span class="s44">SQL S</span>erver, do not distinguish uppercase from lowercase when matching strings; as a result, “&#39;comp. sci.&#39; = &#39;Comp. Sci.&#39;” would evaluate to true on these systems. This default behavior can, however, be changed, either at the database level or at the level of speciﬁc attributes.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">also permits a variety of functions on character strings, such as concatenating (using “</span><span class="s15">∥</span>”), extracting substrings, ﬁnding the length of strings, converting strings to uppercase (using the function <b>upper</b>(<i>s</i>) where <i>s </i>is a string) and lowercase (using the function <b>lower</b>(<i>s</i>)), removing spaces at the end of the string (using <b>trim</b>(<i>s</i>)), and so on. There are variations on the exact set of string functions supported by diﬀerent database systems. See your database system’s manual for more details on exactly what string functions it supports.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Pattern matching can be performed on strings using the operator <b>like</b>. We describe patterns by using two special characters:</p><p class="s39" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">Percent (%): The % character matches any substring.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_347.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_348.png"/></span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">Underscore ( ): The  character matches any character.</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Patterns are case sensitive; <span class="s76">4</span> that is, uppercase characters do not match lowercase char- acters, or vice versa. To illustrate pattern matching, we consider the following examples:</p><p class="s39" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">&#39;Intro%&#39; matches any string beginning with “Intro”.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">&#39;%Comp%&#39; matches any string containing “Comp” as a substring, for example, &#39;Intro. to Computer Science&#39;, and &#39;Computational Biology&#39;.</span></p><p class="s40" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span>&#39;<u>  </u>&#39; matches any string of exactly three characters.</p><p class="s40" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span>&#39;<u>  </u>%&#39; matches any string of at least three characters.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_349.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;"><span class="s77">4</span>Except for <span class="s153">M</span>y<span class="s153">SQL</span>, or with the <b>ilike </b><span class="s80">operator in </span><span class="s161">P</span><span class="s80">ostgre</span><span class="s161">SQL</span><span class="s80">, where patterns are case insensitive.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">SQL <span class="s43">expresses patterns by using the </span><span class="s46">like </span><span class="p">comparison operator. Consider the query “Find the names of all departments whose building name includes the substring &#39;Wat- son&#39;.” This query can be written as:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_350.png"/></span></p><p class="s46" style="padding-left: 238pt;text-indent: 0pt;text-align: left;">select <i>dept name</i></p><p class="s46" style="padding-left: 238pt;text-indent: 0pt;text-align: left;">from <i>department</i></p><p class="s46" style="padding-left: 238pt;text-indent: 0pt;text-align: left;">where <i>building </i>like <span class="p">&#39;%Watson%&#39;;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_351.png"/></span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">For patterns to include the special pattern characters (that is, % and ), <span class="s44">SQL </span>allows the speciﬁcation of an escape character. The escape character is used immediately before a special pattern character to indicate that the special pattern character is to be treated like a normal character. We deﬁne the escape character for a <b>like </b>comparison using the <b>escape </b>keyword. To illustrate, consider the following patterns, which use a backslash (<span class="s15">∖</span>) as the escape character:</p><p style="padding-top: 12pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><b>like </b>&#39;ab<span class="s15">∖</span>%cd%&#39; <b>escape </b>&#39;<span class="s15">∖</span>&#39; matches all strings beginning with “ab%cd”.</p><p style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><b>like </b>&#39;ab<span class="s15">∖∖</span>cd%&#39; <b>escape </b>&#39;<span class="s15">∖</span>&#39; matches all strings beginning with “ab<span class="s15">∖</span>cd”.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">allows us to search for mismatches instead of matches by using the </span>not like <span class="p">com- parison operator. Some implementations provide variants of the </span>like <span class="p">operation that do not distinguish lower- and uppercase.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Some <span class="s44">SQL </span>implementations, notably <span class="s44">P</span>ostgre<span class="s44">SQL</span>, oﬀer a <b>similar to </b>operation that provides more powerful pattern matching than the <b>like </b>operation; the syntax for speci- fying patterns is similar to that used in Unix regular expressions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">3.4.3 Attribute Specification in the Select Clause</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The asterisk symbol “ * ” can be used in the <b>select </b>clause to denote “all attributes.” Thus, the use of <i>instructor</i>.* in the <b>select </b>clause of the query:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 239pt;text-indent: 0pt;text-align: left;">select <i>instructor</i><span class="p">.*</span></p><p class="s13" style="padding-left: 239pt;text-indent: 0pt;text-align: left;"><b>from </b>instructor<span class="p">, </span>teaches</p><p style="padding-left: 239pt;text-indent: 0pt;text-align: left;"><b>where </b><i>instructor</i>.<span class="s69">ID</span><span class="s15">= </span><i>teaches</i>.<span class="s69">ID</span>;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">indicates that all attributes of <i>instructor </i>are to be selected. A <b>select </b>clause of the form</p><p class="s46" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">select <span class="p">* indicates that all attributes of the result relation of the </span>from <span class="p">clause are selected.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">3.4.4 Ordering the Display of Tuples</p><p class="s42" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">SQL <span class="s43">oﬀers the user some control over the order in which tuples in a relation are dis- played. The </span><span class="s63">order by </span><span class="p">clause causes the tuples in the result of a query to appear in sorted order. To list in alphabetic order all instructors in the Physics department, we write:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 214pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 214pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_352.png"/></span></p><p class="s46" style="padding-left: 214pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="s15">= </span><span class="p">&#39;Physics&#39;</span></p><p class="s46" style="padding-left: 214pt;text-indent: 0pt;text-align: left;">order by <i>name</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">By default, the <b>order by </b>clause lists items in ascending order. To specify the sort order, we may specify <b>desc </b>for descending order or <b>asc </b>for ascending order. Furthermore, ordering can be performed on multiple attributes. Suppose that we wish to list the entire <i>instructor </i>relation in descending order of <i>salary</i>. If several instructors have the same salary, we order them in ascending order by name. We express this query in <span class="s44">SQL </span>as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 209pt;text-indent: 0pt;text-align: left;">select <span class="p">*</span></p><p class="s46" style="padding-left: 209pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 209pt;text-indent: 0pt;text-align: left;">order by <i>salary </i>desc<span class="p">, </span><i>name </i>asc<span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">3.4.5 Where-Clause Predicates</p><p class="s46" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">includes a </span>between <span class="p">comparison operator to simplify </span>where <span class="p">clauses that specify that a value be less than or equal to some value and greater than or equal to some other value. If we wish to ﬁnd the names of instructors with salary amounts between $90,000 and $100,000, we can use the </span>between <span class="p">comparison to write:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 187pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 187pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 187pt;text-indent: 0pt;text-align: left;">where <i>salary </i>between <span class="p">90000 </span>and <span class="p">100000;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">instead of:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 173pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 173pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 173pt;text-indent: 0pt;line-height: 20pt;text-align: left;">where <i>salary </i><span class="s83">&lt;</span><span class="s15">= </span><span class="p">100000 </span>and <i>salary </i><span class="s83">&gt;</span><span class="s15">= </span><span class="p">90000;</span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">Similarly, we can use the <b>not between </b>comparison operator.</p><p class="s13" style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 86%;text-align: justify;"><span class="s42">SQL </span><span class="s43">permits us to use the notation (</span>v<span class="s98">1</span><span class="p">, </span>v<span class="s98">2</span><span class="p">, </span><span class="s15">… </span><span class="p">, </span>v<span class="s97">n</span><span class="p">) to denote a tuple of arity </span>n <span class="p">con- taining values </span>v<span class="s98">1</span><span class="p">, </span>v<span class="s98">2</span><span class="p">, </span><span class="s15">… </span><span class="p">, </span>v<span class="s97">n</span><span class="p">; the notation is called a </span>row constructor<span class="p">. The comparison operators can be used on tuples, and the ordering is deﬁned lexicographically. For ex- ample, (</span>a<span class="s130">1</span><span class="s94">, </span>a<span class="s130">2</span><span class="s94">) </span><span class="s83">&lt;</span><span class="s15">= </span><span class="p">(</span>b<span class="s130">1</span><span class="s94">, </span>b<span class="s130">2</span><span class="s94">) is true if </span>a<span class="s130">1 </span><span class="s83">&lt;</span><span class="s15">= </span>b<span class="s130">1 </span><b>and </b>a<span class="s130">2 </span><span class="s83">&lt;</span><span class="s15">= </span>b<span class="s130">2</span><span class="s94">; similarly, the two tuples</span></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 8pt;text-align: left;">are equal if all their attributes are equal. Thus, the <span class="s44">SQL </span>query:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_353.png"/></span></p><p class="s13" style="padding-left: 150pt;text-indent: 0pt;text-align: left;"><b>select </b>name<span class="p">, </span>course id</p><p class="s13" style="padding-left: 150pt;text-indent: 0pt;text-align: left;"><b>from </b>instructor<span class="p">, </span>teaches</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_354.png"/></span></p><p class="s13" style="padding-left: 150pt;text-indent: 0pt;text-align: left;"><b>where </b>instructor<span class="p">.</span><span class="s69">ID</span><span class="s15">= </span>teaches<span class="p">.</span><span class="s69">ID </span><b>and </b>dept name <span class="s15">= </span><span class="p">&#39;Biology&#39;;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="71" height="82" alt="image" src="Image_355.png"/></span></p><p class="s33" style="padding-top: 2pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">CS<span class="s141">-101 </span>CS<span class="s141">-347 </span>PHY<span class="s141">-101</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">course id</p><p style="text-indent: 0pt;text-align: left;"/><p class="s74" style="padding-top: 4pt;padding-left: 170pt;text-indent: 0pt;text-align: left;"><a name="bookmark49"><span class="s73">Figure 3.8 </span></a>The <span class="s91">c1 </span>relation, listing courses taught in Fall 2017.<a name="bookmark91">&zwnj;</a></p><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">can be rewritten as follows:<span class="s76">5</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_356.png"/></span></p><p class="s13" style="padding-left: 183pt;text-indent: 0pt;text-align: left;"><b>select </b>name<span class="p">, </span>course id</p><p class="s13" style="padding-left: 183pt;text-indent: 0pt;text-align: left;"><b>from </b>instructor<span class="p">, </span>teaches</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_357.png"/></span></p><p style="padding-left: 183pt;text-indent: 0pt;text-align: left;"><b>where </b>(<i>instructor</i>.<span class="s69">ID</span>, <i>dept name</i>) <span class="s15">= </span>(<i>teaches</i>.<span class="s69">ID</span>, &#39;Biology&#39;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part87.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part89.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
