<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>20.1 Simple Solution: Bigger Pages</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part202.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part204.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">20.1 Simple Solution: Bigger Pages</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 92%;text-align: justify;">We could reduce the size of the page table in one simple way: use bigger pages. Take our 32-bit address space again, but this time assume 16KB pages. We would thus have an 18-bit VPN plus a 14-bit offset. As- suming the same size for each PTE (4 bytes), we now have <span class="s44">2</span><span class="s101">18</span><span class="s64"> </span>entries in our linear page table and thus a total size of 1MB per page table, a factor</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_263.png"/></span></p><p class="s12" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 92%;text-align: justify;"><span class="s11">1</span>Or indeed, you might not; this paging thing is getting out of control, no? That said, always make sure you understand the <i>problem </i>you are solving before moving onto the solution; indeed, if you understand the problem, you can often derive the solution yourself. Here, the problem should be clear: simple linear (array-based) page tables are too big.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 21pt;text-indent: 0pt;text-align: center;">201</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 90pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>M<span class="s45">ULTIPLE </span>P<span class="s45">AGE </span>S<span class="s45">IZES</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">As an aside, do note that many architectures (e.g., MIPS, SPARC, x86-64) now support multiple page sizes. Usually, a small (4KB or 8KB) page size is used. However, if a “smart” application requests it, a single large page (e.g., of size 4MB) can be used for a specific portion of the address space, enabling such applications to place a frequently-used (and large) data structure in such a space while consuming only a single TLB en- try. This type of large page usage is common in database management systems and other high-end commercial applications. The main reason for multiple page sizes is not to save page table space, however; it is to reduce pressure on the TLB, enabling a program to access more of its ad- dress space without suffering from too many TLB misses. However, as researchers have shown [N+02], using multiple page sizes makes the OS virtual memory manager notably more complex, and thus large pages are sometimes most easily used simply by exporting a new interface to applications to request large pages directly.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">of four reduction in size of the page table (not surprisingly, the reduction exactly mirrors the factor of four increase in page size).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The major problem with this approach, however, is that big pages lead to waste <i>within </i>each page, a problem known as <b>internal fragmentation </b>(as the waste is <b>internal </b>to the unit of allocation). Applications thus end up allocating pages but only using little bits and pieces of each, and mem- ory quickly fills up with these overly-large pages. Thus, most systems use relatively small page sizes in the common case: 4KB (as in x86) or 8KB (as in SPARCv9). Our problem will not be solved so simply, alas.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part202.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part204.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
