<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.2  Storage</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part347.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part349.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">19.2  <span style=" color: #00AEEF;">Storage</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">As we saw in Chapter 13, the various data items in the database may be stored and accessed in a number of diﬀerent storage media. In Section 17.3, we saw that storage media can be distinguished by their relative speed, capacity, and resilience against fail- ure. We identiﬁed three categories of storage:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 97pt;text-indent: 0pt;text-align: left;">1. Volatile storage</p><p class="s63" style="padding-top: 6pt;padding-left: 96pt;text-indent: 0pt;text-align: left;">2. Non-Volatile storage</p><p class="s63" style="padding-top: 6pt;padding-left: 96pt;text-indent: 0pt;text-align: left;">3. Stable storage</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Stable storage or, more accurately, an approximation thereof, plays a critical role in recovery algorithms.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">19.2.1 Stable-Storage Implementation</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">To implement stable storage, we need to replicate the needed information in several non-volatile storage media (usually disk) with independent failure modes and to update the information in a controlled manner to ensure that failure during data transfer does not damage the needed information.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">Recall (from Chapter 12) that <span class="s44">RAID </span>systems guarantee that the failure of a single disk (even during data transfer) will not result in loss of data. The simplest and fastest form of <span class="s44">RAID </span>is the mirrored disk, which keeps two copies of each block on separate disks. Other forms of <span class="s44">RAID </span>oﬀer lower costs, but at the expense of lower performance.</p><p class="s42" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">RAID <span class="s43">systems, however, cannot guard against data loss due to disasters such as ﬁres or ﬂooding. Many systems store archival backups of tapes oﬀ-site to guard against such disasters. However, since tapes cannot be carried oﬀ-site continually, updates since the most recent time that tapes were carried oﬀ-site could be lost in such a disaster. More secure systems keep a copy of each block of stable storage at a remote site, writing it out over a computer network, in addition to storing the block on a local disk system. Since the blocks are output to a remote system as and when they are output to local storage, once an output operation is complete, the output is not lost, even in the event of a disaster such as a ﬁre or ﬂood. We study such </span><span class="s13">remote backup </span><span class="p">systems in Section 19.7.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In the remainder of this section, we discuss how storage media can be protected from failure during data transfer. Block transfer between memory and disk storage can result in:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 123pt;text-indent: 0pt;text-align: left;">• <span class="s63">Successful completion</span><span class="p">. The transferred information arrived safely at its destination.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s63">Partial failure</span><span class="p">. A failure occurred in the midst of transfer, and the destination block has incorrect information.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s63">Total failure</span><span class="p">. The failure occurred suﬃciently early during the transfer that the destination block remains intact.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We require that, if a <span class="s63">data-transfer failure </span>occurs, the system detects it and invokes a recovery procedure to restore the block to a consistent state. To do so, the system must maintain two physical blocks for each logical database block; in the case of mirrored disks, both blocks are at the same location; in the case of remote backup, one of the blocks is local, whereas the other is at a remote site. An output operation is executed as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 128pt;text-indent: 0pt;text-align: left;">1. <span class="p">Write the information onto the ﬁrst physical block.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: left;">2. <span class="p">When the ﬁrst write completes successfully, write the same information onto the second physical block.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">3. <span class="p">The output is completed only after the second write completes successfully.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">If the system fails while blocks are being written, it is possible that the two copies of a block could be inconsistent with each other. During recovery, for each block, the system would need to examine two copies of the blocks. If both are the same and no detectable error exists, then no further actions are necessary. (Recall that errors in a disk block, such as a partial write to the block, are detected by storing a checksum with each block.) If the system detects an error in one block, then it replaces its content with the content of the other block. If both blocks contain no detectable error, but they diﬀer in content, then the system can either replace the content of the ﬁrst block with the value of the second, or replace the content of the second block with the value of the ﬁrst. Either way, the recovery procedure ensures that a write to stable storage either succeeds completely (i.e., updates all copies) or results in no change.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The requirement of comparing every corresponding pair of blocks during recovery is expensive to meet. We can reduce the cost greatly by keeping track of block writes that are in progress, using a small amount of non-volatile <span class="s44">RAM</span>. On recovery, only blocks for which writes were in progress need to be compared.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The protocols for writing out a block to a remote site are similar to the protocols for writing blocks to a mirrored disk system, which we examined in Chapter 12, and particularly in Practice Exercise 12.6.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We can extend this procedure easily to allow the use of an arbitrarily large number of copies of each block of stable storage. Although a large number of copies reduces the probability of a failure to even lower than two copies do, it is usually reasonable to simulate stable storage with only two copies.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">19.2.2 Data Access</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">As we saw in Chapter 12, the database system resides permanently on non-volatile storage (usually disks), and only parts of the database are in memory at any time. (In main-memory databases, the entire database resides in memory, but a copy still resides on non-volatile storage so data can survive the loss of main-memory contents.) The database is partitioned into ﬁxed-length storage units called <span class="s63">blocks</span>. Blocks are the units of data transfer to and from disk and may contain several data items. We shall assume that no data item spans two or more blocks. This assumption is realistic for most data-processing applications, such as a bank or a university.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Transactions input information from the disk into main memory and then output the information back onto the disk. The input and output operations are done in block units. The blocks residing on the disk are referred to as <span class="s63">physical blocks</span>; the blocks resid- ing temporarily in main memory are referred to as <span class="s63">buﬀer blocks</span>. The area of memory where blocks reside temporarily is called the <span class="s63">disk buﬀer</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Block movements between disk and main memory are initiated through the follow- ing two operations:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 97pt;text-indent: 0pt;text-align: left;"><span class="s63">1. </span><span class="s49">input</span>(<i>B</i>) transfers the physical block <i>B </i>to main memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 145pt;text-indent: -17pt;text-align: left;"><span class="s63">2. </span><span class="s49">output</span>(<i>B</i>) transfers the buﬀer block <i>B </i>to the disk and replaces the appropriate physical block there.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Figure 19.1 illustrates this scheme.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 91%;text-align: justify;">Conceptually, each transaction <i>T</i><span class="s97">i </span>has a private work area in which copies of data items accessed and updated by <i>T</i><span class="s145">i </span>are kept. The system creates this work area when the transaction is initiated; the system removes it when the transaction either commits or aborts. Each data item <i>X </i>kept in the work area of transaction <i>T</i><span class="s97">i </span>is denoted by <i>x</i><span class="s97">i</span>. Transaction <i>T</i><span class="s97">i </span>interacts with the database system by transferring data to and from its</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">work area to the system buﬀer. We transfer data by these two operations:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: -16pt;line-height: 90%;text-align: left;"><span class="s63">1. </span><span class="s49">read</span>(<i>X</i>) assigns the value of data item <i>X </i>to the local variable <i>x</i><span class="s145">i</span>. It executes this operation as follows:</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: 0pt;text-align: left;">a. If block <i>B</i><span class="s97">X </span>on which <i>X </i>resides is not in main memory, it issues <span class="s49">input</span>(<i>B</i><span class="s97">X </span>).</p><p style="padding-top: 4pt;padding-left: 154pt;text-indent: 0pt;text-align: left;">b. It assigns to <i>x</i><span class="s97">i </span>the value of <i>X </i>from the buﬀer block.</p><p style="padding-top: 5pt;padding-left: 145pt;text-indent: -17pt;line-height: 87%;text-align: left;"><span class="s63">2. </span><span class="s49">write</span>(<i>X</i>) assigns the value of local variable <i>x</i><span class="s97">i </span>to data item <i>X </i>in the buﬀer block. It executes this operation as follows:</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: 0pt;text-align: left;">a. If block <i>B</i><span class="s97">X </span>on which <i>X </i>resides is not in main memory, it issues <span class="s49">input</span>(<i>B</i><span class="s97">X </span>).</p><p style="padding-top: 4pt;padding-left: 154pt;text-indent: 0pt;text-align: left;">b. It assigns the value of <i>x</i><span class="s97">i </span>to <i>X </i>in buﬀer <i>B</i><span class="s97">X </span>.</p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Note that both operations may require the transfer of a block from disk to main mem- ory. They do not, however, speciﬁcally require the transfer of a block from main mem- ory to disk.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A buﬀer block is eventually written out to the disk either because the buﬀer man- ager needs the memory space for other purposes or because the database system wishes</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-top: 9pt;padding-left: 196pt;text-indent: 0pt;text-align: center;">B</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="padding-top: 9pt;padding-left: 212pt;text-indent: 0pt;text-align: center;">main memory</p><p class="s42" style="padding-top: 4pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">input(<i>A</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="299" height="184" alt="image" src="Image_3059.png"/></span></p><p class="s42" style="padding-left: 30pt;text-indent: 0pt;text-align: left;">output(<i>B</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 52pt;text-indent: 0pt;line-height: 296%;text-align: left;">A B</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">disk</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 222pt;text-indent: 0pt;text-align: left;">Figure 19.1 <span class="s74">Block storage operations.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><a name="bookmark397">to reﬂect the change to </a><i>B </i>on the disk. We shall say that the database system performs a <span class="s63">force-output </span>of buﬀer <i>B </i>if it issues an <span class="s49">output</span>(<i>B</i>).<a name="bookmark437">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">When a transaction needs to access a data item <i>X </i>for the ﬁrst time, it must execute <span class="s49">read</span>(<i>X</i>). The transaction then performs all updates to <i>X </i>on <i>x</i><span class="s97">i</span>. At any point during its execution a transaction may execute <span class="s49">write</span>(<i>X</i>) to reﬂect the change to <i>X </i>in the database</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">itself; <span class="s49">write</span>(<i>X</i>) must certainly be done after the ﬁnal write to <i>x</i><span class="s145">i</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">The <span class="s49">output</span>(<i>B</i><span class="s145">X </span>) operation for the buﬀer block <i>B</i><span class="s145">X </span>on which <i>X </i>resides does not need to take eﬀect immediately after <span class="s49">write</span>(<i>X</i>) is executed, since the block <i>B</i><span class="s145">X </span>may contain other data items that are still being accessed. Thus, the actual output may take place later. Notice that, if the system crashes after the <span class="s49">write</span>(<i>X</i>) operation was executed but before <span class="s49">output</span>(<i>B</i><span class="s97">X </span>) was executed, the new value of <i>X </i>is never written to disk and, thus, is lost. As we shall see shortly, the database system executes extra actions to ensure</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">that updates performed by committed transactions are not lost even if there is a system crash.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part347.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part349.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
