<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>17.8  Transaction Isolation Levels</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part317.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part319.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">17.8  <span style=" color: #00AEEF;">Transaction Isolation Levels</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Serializability is a useful concept because it allows programmers to ignore issues related to concurrency when they code transactions. If every transaction has the property that it maintains database consistency if executed alone, then serializability ensures that concurrent executions maintain consistency. However, the protocols required to ensure serializability may allow too little concurrency for certain applications. In these cases, weaker levels of consistency are used. The use of weaker levels of consistency places additional burdens on programmers for ensuring database correctness.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <span class="s44">SQL </span>standard also allows a transaction to specify that it may be executed in such a way that it becomes nonserializable with respect to other transactions. For in- stance, a transaction may operate at the isolation level of <b>read uncommitted</b>, which permits the transaction to read a data item even if it was written by a transaction that has not been committed. <span class="s44">SQL </span>provides such features for the beneﬁt of long transac- tions whose results do not need to be precise. If these transactions were to execute in a serializable fashion, they could interfere with other transactions, causing the others’ execution to be delayed.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">The <span class="s63">isolation levels </span>speciﬁed by the <span class="s44">SQL </span>standard are as follows:</p><p class="s39" style="padding-top: 10pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Serializable </span><span class="p">usually ensures serializable execution. However, as we shall explain shortly, some database systems implement this isolation level in a manner that may, in certain cases, allow nonserializable executions.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Repeatable read </span><span class="p">allows only committed data to be read and further requires that, between two reads of a data item by a transaction, no other transaction is allowed to update it. However, the transaction may not be serializable with respect to other transactions. For instance, when it is searching for data satisfying some conditions, a transaction may ﬁnd some of the data inserted by a committed transaction, but may not ﬁnd other data inserted by the same transaction.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Read committed </span><span class="p">allows only committed data to be read, but does not require re- peatable reads. For instance, between two reads of a data item by the transaction, another transaction may have updated the data item and committed.</span></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Read uncommitted </span>allows uncommitted data to be read. It is the lowest isolation level allowed by <span class="s44">SQL</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">All the isolation levels above additionally disallow <span class="s63">dirty writes</span>, that is, they disallow writes to a data item that has already been written by another transaction that has not yet committed or aborted.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Many database systems run, by default, at the read-committed isolation level. In <span class="s44">SQL</span>, it is possible to set the isolation level explicitly, rather than accepting the system’s default setting. For example, the statement</p><p class="s46" style="padding-top: 6pt;padding-left: 137pt;text-indent: 0pt;text-align: justify;">set transaction isolation level serializable</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">sets the isolation level to serializable; any of the other isolation levels may be speciﬁed instead. The preceding syntax is supported by Oracle, <span class="s44">P</span>ostgre<span class="s44">SQL</span>, and <span class="s44">SQL S</span>erver;</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Oracle uses the syntax</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2987.png"/></span></p><p class="s46" style="padding-top: 6pt;padding-left: 137pt;text-indent: 0pt;text-align: justify;">alter session set isolation level <span class="s15">= </span>serializable</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">while <span class="s44">DB2 </span>uses the syntax “<b>change isolation level</b>” with its own abbreviations for iso- lation levels. Changing of the isolation level must be done as the ﬁrst statement of a transaction.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">By default, most databases commit individual statements as soon as they are exe- cuted. Such <span class="s63">automatic commit </span>of individual statements must be turned oﬀ to allow mul- tiple statements to run as a single transaction. The command <b>start transaction </b>ensures that subsequent <span class="s44">SQL </span>statements, until a subsequent <b>commit </b>or <b>rollback</b>, are executed as a single transaction. As expected, the <b>commit </b>operation commits the preceding <span class="s44">SQL </span>statements, while <b>rollback </b>rolls back the preceding <span class="s44">SQL </span>statements. (<span class="s44">SQL S</span>erver uses <b>begin transaction </b>in place of <b>start transaction</b>, while Oracle and <span class="s44">P</span>ostgre<span class="s44">SQL </span>treat <b>begin </b>as identical to <b>start transaction</b>.)</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="s42">API</span><span class="s43">s such as </span><span class="s42">JDBC </span><span class="s43">and </span><span class="s42">ODBC </span><span class="s43">provide functions to turn oﬀ automatic commit. In </span><span class="s42">JDBC </span><span class="s43">the </span><span class="s49">setAutoCommit </span>method of the <span class="s49">Connection </span>interface (which we saw earlier in Section 5.1.1.8) can be used to turn automatic commit oﬀ by invoking <span class="s49">setAutoCom- mit(false)</span>, or on by invoking <span class="s49">setAutoCommit(true)</span>. Further, in <span class="s44">JDBC </span>the method <span class="s49">set- TransactionIsolation(int level) </span>of the <span class="s49">Connection </span>interface can be invoked with any one of</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2988.png"/></span></p><p class="s39" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s49">Connection.TRANSACTION SERIALIZABLE</span><span class="p">,</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2989.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2990.png"/></span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s49">Connection.TRANSACTION REPEATABLE READ</span><span class="p">,</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2991.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2992.png"/></span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s49">Connection.TRANSACTION READ COMMITTED</span><span class="p">, or</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2993.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2994.png"/></span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s49">Connection.TRANSACTION READ UNCOMMITTED</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">to set the transaction isolation level correspondingly.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">An application designer may decide to accept a weaker isolation level in order to improve system performance. As we shall see in Section 17.9 and Chapter 18, ensuring serializability may force a transaction to wait for other transactions or, in some cases, to abort because the transaction can no longer be executed as part of a serializable ex- ecution. While it may seem shortsighted to risk database consistency for performance,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><a name="bookmark375">this trade-oﬀ makes sense if we can be sure that the inconsistency that may occur is not relevant to the application.</a><a name="bookmark417">&zwnj;</a></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">There are many means of implementing isolation levels. As long as the implemen- tation ensures serializability, the designer of a database application or a user of an application does not need to know the details of such implementations, except per- haps for dealing with performance issues. Unfortunately, even if the isolation level is set to <b>serializable</b>, some database systems actually implement a weaker level of isola- tion, which does not rule out every possible nonserializable execution; we revisit this issue in Section 17.9. If weaker levels of isolation are used, either explicitly or implic- itly, the application designer has to be aware of some details of the implementation, to avoid or minimize the chance of inconsistency due to lack of serializability.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part317.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part319.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
