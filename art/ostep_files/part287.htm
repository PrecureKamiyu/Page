<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.8 Evaluating Spin Locks</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part286.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part288.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">28.8 Evaluating Spin Locks</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Given our basic spin lock, we can now evaluate how effective it is along our previously described axes. The most important aspect of a lock is <b>correctness</b>: does it provide mutual exclusion? The answer here is ob- viously yes: the spin lock only allows a single thread to enter the critical section at a time. Thus, we have a correct lock.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The next axis is <b>fairness</b>. How fair is a spin lock to a waiting thread? Can you guarantee that a waiting thread will ever enter the critical sec- tion? The answer here, unfortunately, is bad news: spin locks don’t pro- vide any fairness guarantees. Indeed, a thread spinning may spin forever, under contention. Spin locks are not fair and may lead to starvation.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The final axis is <b>performance</b>. What are the costs of using a spin lock? To analyze this more carefully, we suggest thinking about a few different cases. In the first, imagine threads competing for the lock on a single processor; in the second, consider the threads as spread out across many processors.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">For spin locks, in the single CPU case, performance overheads can be quite painful; imagine the case where the thread holding the lock is pre-empted within a critical section. The scheduler might then run every other thread (imagine there are <span class="s43">N </span><span class="s4">− </span><span class="s44">1 </span>others), each of which tries to ac- quire the lock. In this case, each of those threads will spin for the duration of a time slice before giving up the CPU, a waste of CPU cycles.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">However, on multiple CPUs, spin locks work reasonably well (if the number of threads roughly equals the number of CPUs). The thinking goes as follows: imagine Thread A on CPU 1 and Thread B on CPU 2, both contending for a lock. If Thread A (CPU 1) grabs the lock, and then Thread B tries to, B will spin (on CPU 2). However, presumably the crit- ical section is short, and thus soon the lock becomes available, and is ac- quired by Thread B. Spinning to wait for a lock held on another processor doesn’t waste many cycles in this case, and thus can be quite effective.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part286.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part288.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
