<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>32.4 Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part349.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part351.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">32.4 Summary</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this chapter, we have studied the types of bugs that occur in con- current programs. The first type, non-deadlock bugs, are surprisingly common, but often are easier to fix. They include atomicity violations, in which a sequence of instructions that should have been executed to- gether was not, and order violations, in which the needed order between two threads was not enforced.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We have also briefly discussed deadlock: why it occurs, and what can be done about it. The problem is as old as concurrency itself, and many hundreds of papers have been written about the topic. The best solu- tion in practice is to be careful, develop a lock acquisition total order, and thus prevent deadlock from occurring in the first place. Wait-free approaches also have promise, as some wait-free data structures are now finding their way into commonly-used libraries and critical systems, in- cluding Linux. However, their lack of generality and the complexity to develop a new wait-free data structure will likely limit the overall util- ity of this approach. Perhaps the best solution is to develop new concur- rent programming models: in systems such as MapReduce (from Google) [GD02], programmers can describe certain types of parallel computations without any locks whatsoever. Locks are problematic by their very na- ture; perhaps we should seek to avoid using them unless we truly must.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part349.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part351.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
