<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Hold-and-wait</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part344.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part346.htm">下一个 &gt;</a></p><p class="s27" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Hold-and-wait</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The hold-and-wait requirement for deadlock can be avoided by acquiring all locks at once, atomically. In practice, this could be achieved as follows:</p><p class="s37" style="padding-top: 8pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1   <span class="s38">lock(prevention);</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2   <span class="s38">lock(L1);</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3   <span class="s38">lock(L2);</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4   <span class="s38">...</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5   <span class="s38">unlock(prevention);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">By first grabbing the lock <span class="s41">prevention</span>, this code guarantees that no untimely thread switch can occur in the midst of lock acquisition and thus deadlock can once again be avoided. Of course, it requires that any time any thread grabs a lock, it first acquires the global prevention lock. For example, if another thread was trying to grab locks L1 and L2 in a dif- ferent order, it would be OK, because it would be holding the prevention lock while doing so.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Note that the solution is problematic for a number of reasons. As be- fore, encapsulation works against us: this approach requires us to know when calling a routine exactly which locks must be held and to acquire them ahead of time. Further, the approach likely decreases concurrency as all locks must be acquired early on (at once) instead of when they are truly needed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part344.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part346.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
