<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>26.4  Consensus</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part464.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part466.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">26.4  <span style=" color: #00AEEF;">Consensus</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Because the blockchain is replicated at all participating nodes, each time a new block is added, all nodes must eventually agree ﬁrst on which node may propose a new block and then agree on the actual block itself.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In a traditional distributed database system, the consensus process is simpliﬁed by the fact that all participants are part of one controlling organization. Therefore, the distributed system can implement global concurrency control and enforce two- phase commit to decide on transaction commit or abort. In a blockchain, there may be no controlling organization, as is the case for a public blockchain like Bitcoin. In the case of a permissioned blockchain, there may be a desire to have a high degree of decentralized control in all matters except the actual permissioning of participants, which is managed by the organization controlling the permissioned blockchain.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">When transactions are created, they are broadcast to the blockchain network. Nodes may collect a set of transactions to place in a new block to be added to the chain. The consensus mechanisms used in blockchains fall roughly into two categories:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span class="p">Those where the nodes reach agreement on one node to add the next block. These typically use Byzantine consensus (Section 26.4.3).</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span class="p">Those where the blockchain is allowed temporarily to </span>fork <span class="p">by allowing multiple nodes to create a block following the last block in the chain. In this approach, nodes attempt to add blocks to the longest linear subchain. Those blocks not on that longest chain are </span>orphaned <span class="p">and not considered part of the blockchain. To avoid a massive number of forks being created, this approach limits the rate at which blocks may be added so that the expected length of orphaned branches is short. These typically use proof-of-work (Section 26.4.1) or proof-of-stake (Sec- tion 26.4.2).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">A node that adds a block to the chain must ﬁrst check that block of transactions. This entails checking that:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">Each transaction is well-formed.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">The transaction is not double-spending by using as input (i.e., spending) currency units that have been used already by a prior transaction. To do so, each node must track the set of all unspent currency units (transactions), and look up this set for each transaction </span>T <span class="p">to ensure that all the currency units that are inputs to </span>T <span class="p">are unspent.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">The transaction is correctly signed by the submitting user.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">When a node is selected to add a block to the chain, that block is propagated to all nodes, and each checks the block for validity before adding it to its local copy of the chain.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We next need to consider the question of why any node would want to use its resources for mining, that is to carry out the work needed to append blocks to the chain. Mining is a service to the blockchain network as a whole, and so miners are paid (in the currency of the blockchain) for their eﬀorts. There are two sources of payment to miners:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 97pt;text-indent: 0pt;text-align: justify;">1. <span class="p">A fee paid by the system in new coins in the currency of the blockchain.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">2. <span class="p">A fee included by the submitter of the transaction. In this case the output of the transaction includes an additional output representing a payment to the miner of the block containing the transaction. Users are incented to include fees since such fees incent miners to include their transactions preferentially in new blocks.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">The exact means of paying miners varies among blockchains.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In this section, we look at various ways to achieve consensus. We begin by assuming a public blockchain and describe consensus based on two approaches: <i>proof-of-work </i>and <i>proof-of-stake</i>. We then consider permissioned blockchains that in many cases choose to use a consensus mechanism based on <i>Byzantine consensus</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">26.4.1 Proof of Work</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Proof-of-work consensus is designed for public blockchains in which the number of par- ticipating nodes is changing continuously. Any computer may download the blockchain and attempt to add blocks. As a result, a majority-based approach can be overwhelmed by an adversary who sets up a large number of low-cost computers as nodes. As men- tioned earlier, such an attack is called a <i>Sybil attack</i>. Instead, proof-of-work requires a node to solve a computationally hard, but not infeasible, mathematical problem. An attacker cannot overwhelm a blockchain network simply by adding inexpensive nodes. Rather, the attacker would need to have access to computation capacity that forms a majority of the network’s total computation capacity, a task that is much more diﬃcult and costly than launching a Sybil attack.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The computationally hard problem is based on the concept of cryptographic hash- ing. A node that wishes to mine a block <i>B </i>as the next block needs to ﬁnd a value, called a <span class="s63">nonce</span>, that, when concatenated to <i>B </i>and the hash of the previous block, hashes to a value less than a preset target value speciﬁed for the blockchain. The nonce is typically a 32-bit value. If the target is set very low, say to 4, and assuming the usual 256-bit hash, a miner would have only a 1<span class="s15">∕</span>2<span class="s76">254</span> chance of succeeding for a single choice for the nonce. If the target were set very high, say to 2<span class="s76">255</span>, the miner would have a 50 percent chance of success. Blockchain implementations are designed to vary the target so as to control the rate of mining of blocks across the whole system. This variability allows the system to adjust as computation power increases whether due to hardware advances or due to additional nodes joining the network. The target times vary for diﬀerent blockchains. Bitcoin targets having some node in the system successfully mine a block every 10 minutes. Ethereum targeted a mining time of 10 to 15 seconds with its proof-of-work mechanism. As of late 2018, Ethereum is moving to a proof-of-stake mechanism and is expected to target a slightly faster rate. While faster may appear to be better, note that if mining occurs at a faster rate than the time it takes to propagate a new block throughout the network, the probability of forks and orphaned blocks increases.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Now that we have seen how proof-of-work mining works, let us recall the properties we stated about cryptographic hash functions. If there were an eﬃcient algorithm for ﬁnding a nonce that results in a hash less than the target, miners might ﬁnd nonces too quickly. Therefore, the hash function must ensure that there is no better way to ﬁnd a nonce than simply trying each possible nonce value in turn. This leads us to require one additional property for cryptographic hash functions, the <span class="s63">puzzle-friendliness </span>property. This property requires that given a value <i>k</i>, for any <i>n</i>-bit value <i>y </i>it is infeasible to ﬁnd</p><p class="s15" style="text-indent: 0pt;text-align: left;">‖</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">‖</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">a value <i>x </i>such that <i>h</i>(<i>x k</i>) <span class="s15">= </span><i>y </i>in time signiﬁcantly less that 2<i>n</i>, where  denotes concatenation of bit strings.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Proof-of-work mining is controversial. On the positive side, for a large network, it would be highly costly for an adversary to obtain enough computational power to dominate mining. However, on the negative side, the amount of energy used in mining is huge. Estimates as this chapter is being written suggest that Bitcoin mining worldwide consumes about 1 percent of the power consumed by the United States, or more than the entire consumption of several nations, for example Ireland. The large amount of computation needed has created incentives to design special-purpose computing chips for mining and incentives to locate large mining installations near sources of cheap power sources.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">These concerns are causing a movement to alternatives, such as proof-of-stake, which we discuss next. These concerns have led also to interest in alternative forms of proof-of-work that, for example, require having a large amount of main memory in order quickly to ﬁnd a nonce. Memory-intensive schemes retain the cost barrier of proof-of-work while reducing the energy waste. They are a subject of current research. Furthermore, we shall see that for enterprise permissioned-blockchain applications, much less costly means of consensus are possible.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">In practice, a group of users may unite to form a <i>mining pool</i>, which is a consortium that works together to mine blocks and then shares the proceeds among its members.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">26.4.2 Proof of Stake</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The concept of proof-of-stake is to allow nodes holding a large stake in the currency of the blockchain to be chosen preferentially to add blocks. This rule cannot be applied absolutely, since then a single largest stakeholder would control the chain. Instead, the probability of mining success, using proof-of-work, is made higher for nodes in proportion to their stake. By adjusting both the stake requirements and the mining diﬃculty, it remains possible to control the rate at which blocks are mined.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">There are a wide variety of proof-of-stake schemes. They may include measurement not only of overall stake, but also the total time a stake has been held. They may require that the stake or some fraction of it be held inactive for some period of time in the future.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Properly tuning a proof-of-stake mechanism is diﬃcult. Not only are there more parameters to consider than in proof-of-work, but also one must guard against a situa- tion where there is too little cost penalty for an adversary to add blocks to a fork other than the longest one.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">26.4.3 Byzantine Consensus</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">An important alternative to work- or stake-based consensus is message-based consen- sus. Message-based consensus is widely used in distributed database systems. As we noted earlier, the basic consensus protocols do not work for blockchain consensus be- cause it cannot be assumed that there are no malicious nodes.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Message-based systems aim to achieve consensus via a majority vote. Such systems are vulnerable to a Sybil attack. In an enterprise permissioned blockchain, in which users have to be granted permission to participate, Sybil attacks are not possible since the permissioning authority can easily deny permission when a malicious user attempts to add an excessive number of nodes. However, even in this setting, one cannot assume every user is totally honest.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">For example, consider a supply-chain blockchain in which all suppliers enter data on the chain pertaining to each item being supplied either to another supplier or the ultimate manufacturer of an end-user product. Some supplier might choose to falsify data for its own advantage, but, when a fraud investigation begins, that supplier may then seek to fork the blockchain to cover-up its fraud. Thus, even absent the possibility of Sybil attacks, there remains the possibility of adversarial behavior. It is diﬃcult to anticipate every possible form of adversarial behavior.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">For this reason, we model this situation using the concept of <span class="s63">Byzantine failure </span>in which it is assumed that a “failed” node can behave in an arbitrary manner, and the net- work of non-failed nodes must be robust to all such misbehavior, including misbehavior that takes exactly the needed set of steps to sabotage the network. The assumption of</p><p class="s66" style="padding-top: 3pt;padding-left: 298pt;text-indent: 0pt;text-align: left;"><a name="bookmark565">26.5 </a><span style=" color: #00AEEF;">Data Management in a Blockchain  </span><span class="s164">1267</span><a name="bookmark595">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Byzantine failure is quite diﬀerent from the assumption made by consensus protocols, where the only type of failure considered is the absence of function, that is, the only way a node or network link fails to stop working and thus do nothing. This is referred to as a <i>fail-stop </i>model and precludes any malicious behavior.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In Section 23.8, we discussed distributed consensus protocols, notably Paxos and Raft. These protocols depend on the fail-stop assumption, but allow agreement using majority rule (in contrast, <span class="s44">2PC </span>requires unanimity of agreement). For Byzantine con- sensus, we must seek a form of majority rule that overcomes not only the failure of a minority of nodes, but also the possible malicious behavior of that minority. For exam- ple, a malicious node <i>n</i><span class="s98">1</span> may tell node <i>n</i><span class="s98">2</span> that it desires to commit a transaction, but tell <i>n</i><span class="s98">3</span> that it desires to abort the transaction. As one might expect, achieving consensus in the face of such malicious nodes requires a higher cost in the number of messages sent to achieve agreement, but in a blockchain, that higher cost is acceptable since it can be much lower than the cost of proof-of-work or proof-of-stake mining.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The development of Byzantine consensus algorithms began in the early 1980s; see the Further Reading section at the end of the chapter for references. There has been much theoretical work relating the number of rounds of messaging, the total number of messages sent, and the fraction of the nodes that can be malicious without causing the protocol to fail. Early work made assumptions about network behavior, such as the time it takes to deliver a message or that the network behaves in a highly synchronous man- ner. Modern Byzantine consensus algorithms are based on real-world assumptions and incorporate cryptographic signatures to guard against forged messages. The degree of synchronization is reduced, but truly asychronous fault-tolerant consensus is provably impossible. One widely used approach, called <i>Practical Byzantine Fault Tolerance</i>, tol-</p><p class="s15" style="text-indent: 0pt;text-align: left;">⌋</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌊</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">erates malicious failure of up to</p><p class="s110" style="padding-left: 7pt;text-indent: 0pt;line-height: 7pt;text-align: left;">n<span class="s409">−</span><span class="s215">1</span></p><p style="text-indent: 0pt;text-align: left;">level of performance. Other protocols are referenced in the Further Reading section at the end of the chapter.</p><p style="text-indent: 0pt;text-align: left;"/><p class="s119" style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">3</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">nodes and is viewed as providing an acceptable</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part464.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part466.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
