<?xml version="1.0" encoding="utf-8"?><html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/"><head>
<meta name="dcterms.conformsTo" content="PXE Basic 1.0"></meta>
<meta name="generator" content="PXE Tools version 1.39.109"></meta>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.109, partial=false-->
<title>5.2 Routing Algorithms</title><link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/sepia.css"></link><link rel="alternate stylesheet" type="text/css" title="night" href="../css/night.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/main.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/print.css"></link>
<script src="js/format_lg_obj.js"></script>
</head><body epub:type="bodymatter">
<section id="P7001011952000000000000000001EFF" class="level1"><header><h1 class="title" id="P700101195200000000000000000AB72" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB72" epub:type="title"><span class="number">5.2</span> Routing Algorithms</h1></header>
<p id="P700101195200000000000000000AB73" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB73">In this section we’ll study <span class="keyword" id="P7001011952000000000000000001F02" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F02"><b>routing algorithms</b></span>, whose goal is to determine good paths (equivalently, routes), from senders to receivers, through the network of routers. Typically, a “good” path is one that has the least cost. We’ll see that in practice, however, real-world concerns such as policy issues (for example, a rule such as “router <i>x</i>, belonging to organization <i>Y</i>, should not forward any packets originating from the network owned by organization <i>Z</i> ”) also come into play. We note that whether the network control plane adopts a per-router control approach or a logically centralized approach, there must always be a well-defined sequence of routers that a packet will cross in traveling from sending to receiving host. Thus, the routing algorithms that compute these paths are of fundamental importance, and another candidate for our top-10 list of fundamentally important networking concepts.</p>
<p id="P700101195200000000000000000AB74" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB74">A graph is used to formulate routing problems. Recall that a <span class="keyword" id="P7001011952000000000000000001F04" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F04"><b>graph</b></span> <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="92" altimg-height="17" altimg="../images/ch05math01.png"><m:mrow><m:mi>G</m:mi><m:mo>=</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>N</m:mi><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi>E</m:mi></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math></span> is a set <i>N</i> of nodes and a collection <i>E</i> of edges, where each edge is a pair of nodes from <i>N</i>. In the context of network-layer routing, the nodes in the graph represent<span class="pagebreak" title="377" id="P7001011952000000000000000001F05" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F05" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001F06" class="figure" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F06">
<img alt="Illustration of an abstract graph model of a computer network." height="264" width="390" aria-describedby="P7001011952000000000000000001F0A" id="P700101195200000000000000000AB75" data-uri="P70010119520000000000000000055A6" src="../images/4055105003.png"></img>
<figcaption id="P700101195200000000000000000AB76" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB76"><header><h1 class="title" id="P700101195200000000000000000AB77" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB77" epub:type="title"><span class="label">Figure </span><span class="number">5.3</span> Abstract graph model of a computer network</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001F0A" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F0A" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055105003.xhtml#la_4055105003"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000AB79" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB79">routers—the points at which packet-forwarding decisions are made—and the edges connecting these nodes represent the physical links between these routers. Such a graph abstraction of a computer network is shown in <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a>. To view some graphs representing real network maps, see <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P70010119520000000000000000038D4" data-foobar="7">[Dodge 2016</a>, <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P700101195200000000000000000387F" data-foobar="7">Cheswick 2000]</a>; for a discussion of how well different graph-based models model the Internet, see <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C9A" data-foobar="7">[Zegura 1997</a>, <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P70010119520000000000000000038EB" data-foobar="7">Faloutsos 1999</a>, <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003A2C" data-foobar="7">Li 2004]</a>.</p>
<p id="P700101195200000000000000000AB7A" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB7A">As shown in <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a>, an edge also has a value representing its cost. Typically, an edge’s cost may reflect the physical length of the corresponding link (for example, a transoceanic link might have a higher cost than a short-haul terrestrial link), the link speed, or the monetary cost associated with a link. For our purposes, we’ll simply take the edge costs as a given and won’t worry about how they are determined. For any edge (<i>x</i>, <i>y</i>) in <i>E</i>, we denote <i>c</i>(<i>x</i>, <i>y</i>) as the cost of the edge between nodes <i>x</i> and <i>y.</i> If the pair (<i>x</i>, <i>y</i>) does not belong to <i>E</i>, we set <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="99" altimg-height="17" altimg="../images/ch05math02.png"><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi>y</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>∞</m:mi><m:mo>.</m:mo></m:mrow></m:math></span> Also, we’ll only consider undirected graphs (i.e., graphs whose edges do not have a direction) in our discussion here, so that edge (<i>x</i>, <i>y</i>) is the same as edge (<i>y</i>, <i>x</i>) and that <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="131" altimg-height="17" altimg="../images/ch05math03.png"><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi>y</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>y</m:mi><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi>x</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>;</m:mo></m:mrow></m:math></span> however, the algorithms we’ll study can be easily extended to the case of directed links with a different cost in each direction. Also, a node <i>y</i> is said to be a <span class="keyword" id="P7001011952000000000000000001F0E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F0E"><b>neighbor</b></span> of node <i>x</i> if (<i>x</i>, <i>y</i>) belongs to <i>E</i>.</p>
<p id="P700101195200000000000000000AB7B" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB7B">Given that costs are assigned to the various edges in the graph abstraction, a natural goal of a routing algorithm is to identify the least costly paths between sources and destinations. To make this problem more precise, recall that a <span class="keyword" id="P7001011952000000000000000001F10" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F10"><b>path</b></span> in a graph <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="92" altimg-height="17" altimg="../images/ch05math04.png"><m:mrow><m:mi>G</m:mi><m:mo>=</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>N</m:mi><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi>E</m:mi></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math></span> is a sequence of nodes <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="116" altimg-height="20" altimg="../images/ch05math05.png"><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>x</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mo>⋯</m:mo><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mi>p</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math></span> such that each of the pairs <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="232" altimg-height="20" altimg="../images/ch05math06.png"><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>x</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mn>2</m:mn></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>,</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>x</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mn>3</m:mn></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>,</m:mo><m:mo>⋯</m:mo><m:mo>,</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>x</m:mi><m:mrow><m:mi>p</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mi>p</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math></span> are edges in <i>E</i>. The cost of a path <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="115" altimg-height="20" altimg="../images/ch05math07.png"><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>x</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:mo>⋯</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>x</m:mi><m:mi>p</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math></span> is simply the sum of all the edge costs along the path, that is, <span class="pagebreak" title="378" id="P7001011952000000000000000001F11" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F11" epub:type="pagebreak" role="doc-pagebreak"></span><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="305" altimg-height="20" altimg="../images/ch05math08.png"><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>x</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mn>2</m:mn></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>x</m:mi><m:mn>2</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mn>3</m:mn></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:mo>⋯</m:mo><m:mo>+</m:mo><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>x</m:mi><m:mrow><m:mi>p</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mi>x</m:mi><m:mi>p</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>.</m:mo></m:mrow></m:math></span> Given any two nodes <i>x</i> and <i>y</i>, there are typically many paths between the two nodes, with each path having a cost. One or more of these paths is a <span class="keyword" id="P7001011952000000000000000001F12" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F12"><b>least-cost path</b></span>. The least-cost problem is therefore clear: Find a path between the source and destination that has least cost. In <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a>, for example, the least-cost path between source node <i>u</i> and destination node <i>w</i> is (<i>u</i>, <i>x</i>, <i>y</i>, <i>w</i>) with a path cost of 3. Note that if all edges in the graph have the same cost, the least-cost path is also the <span class="keyword" id="P7001011952000000000000000001F13" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F13"><b>shortest path</b></span> (that is, the path with the smallest number of links between the source and the destination).</p>
<p id="P700101195200000000000000000AB7C" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB7C">As a simple exercise, try finding the least-cost path from node <i>u</i> to <i>z</i> in <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a> and reflect for a moment on how you calculated that path. If you are like most people, you found the path from <i>u</i> to <i>z</i> by examining <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a>, tracing a few routes from <i>u</i> to <i>z</i>, and somehow convincing yourself that the path you had chosen had the least cost among all possible paths. (Did you check all of the 17 possible paths between <i>u</i> and <i>z</i>? Probably not!) Such a calculation is an example of a centralized routing algorithm—the routing algorithm was run in one location, your brain, with complete information about the network. Broadly, one way in which we can classify routing algorithms is according to whether they are centralized or decentralized.</p>
<ul id="P700101195200000000000000000AB7D" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB7D">
<li id="P700101195200000000000000000AB7E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB7E"><p id="P700101195200000000000000000AB7F" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB7F">A <span class="keyword" id="P7001011952000000000000000001F18" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F18"><b>centralized routing algorithm</b></span> computes the least-cost path between a source and destination using complete, global knowledge about the network. That is, the algorithm takes the connectivity between all nodes and all link costs as inputs. This then requires that the algorithm somehow obtain this information before actually performing the calculation. The calculation itself can be run at one site (e.g., a logically centralized controller as in <a class="xref" href="fileP7001011952000000000000000001EE4.xhtml#P7001011952000000000000000001EF6" data-foobar="7"><span class="label">Figure</span> <span class="number">5.2</span></a>) or could be replicated in the routing component of each and every router (e.g., as in <a class="xref" href="fileP7001011952000000000000000001EE4.xhtml#P7001011952000000000000000001EEC" data-foobar="7"><span class="label">Figure</span> <span class="number">5.1</span></a>). The key distinguishing feature here, however, is that the algorithm has complete information about connectivity and link costs. Algorithms with global state information are often referred to as <span class="keyword" id="P7001011952000000000000000001F19" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F19"><b>link-state</b> (<b>LS</b>) <b>algorithms</b></span>, since the algorithm must be aware of the cost of each link in the network. We’ll study LS algorithms in <a class="xref" href="#P7001011952000000000000000001F24" data-foobar="1"><span class="label">Section</span> <span class="number">5.2.1</span></a>.</p></li>
<li id="P700101195200000000000000000AB80" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB80"><p id="P700101195200000000000000000AB81" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB81">In a <span class="keyword" id="P7001011952000000000000000001F1C" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F1C"><b>decentralized routing algorithm</b></span>, the calculation of the least-cost path is carried out in an iterative, distributed manner by the routers. No node has complete information about the costs of all network links. Instead, each node begins with only the knowledge of the costs of its own directly attached links. Then, through an iterative process of calculation and exchange of information with its neighboring nodes, a node gradually calculates the least-cost path to a destination or set of destinations. The decentralized routing algorithm we’ll study below in <a class="xref" href="#P7001011952000000000000000001F96" data-foobar="1"><span class="label">Section</span> <span class="number">5.2.2</span></a> is called a distance-vector (DV) algorithm, because each node maintains a vector of estimates of the costs (distances) to all other nodes in the network. Such decentralized algorithms, with interactive message exchange between <span class="pagebreak" title="379" id="P7001011952000000000000000001F1D" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F1D" epub:type="pagebreak" role="doc-pagebreak"></span>neighboring routers is perhaps more naturally suited to control planes where the routers interact directly with each other, as in <a class="xref" href="fileP7001011952000000000000000001EE4.xhtml#P7001011952000000000000000001EEC" data-foobar="7"><span class="label">Figure</span> <span class="number">5.1</span></a>.</p></li>
</ul>
<p id="P700101195200000000000000000AB82" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB82">A second broad way to classify routing algorithms is according to whether they are static or dynamic. In <span class="keyword" id="P7001011952000000000000000001F1F" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F1F"><b>static routing algorithms</b></span>, routes change very slowly over time, often as a result of human intervention (for example, a human manually editing a link costs). <span class="keyword" id="P7001011952000000000000000001F20" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F20"><b>Dynamic routing algorithms</b></span> change the routing paths as the network traffic loads or topology change. A dynamic algorithm can be run either periodically or in direct response to topology or link cost changes. While dynamic algorithms are more responsive to network changes, they are also more susceptible to problems such as routing loops and route oscillation.</p>
<p id="P700101195200000000000000000AB83" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB83">A third way to classify routing algorithms is according to whether they are load-sensitive or load-insensitive. In a <span class="keyword" id="P7001011952000000000000000001F22" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F22"><b>load-sensitive algorithm</b></span>, link costs vary dynamically to reflect the current level of congestion in the underlying link. If a high cost is associated with a link that is currently congested, a routing algorithm will tend to choose routes around such a congested link. While early ARPAnet routing algorithms were load-sensitive <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003A49" data-foobar="7">[McQuillan 1980]</a>, a number of difficulties were encountered <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P700101195200000000000000000395B" data-foobar="7">[Huitema 1998]</a>. Today’s Internet routing algorithms (such as RIP, OSPF, and BGP) are <span class="keyword" id="P7001011952000000000000000001F23" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F23"><b>load-insensitive</b></span>, as a link’s cost does not explicitly reflect its current (or recent past) level of congestion.</p>
<section id="P7001011952000000000000000001F24" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F24" class="level2"><header><h1 class="title" id="P700101195200000000000000000AB84" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB84" epub:type="title"><span class="number">5.2.1</span> The Link-State (LS) Routing Algorithm</h1></header>
<p id="P700101195200000000000000000AB85" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB85">Recall that in a link-state algorithm, the network topology and all link costs are known, that is, available as input to the LS algorithm. In practice this is accomplished by having each node broadcast link-state packets to <i>all</i> other nodes in the network, with each link-state packet containing the identities and costs of its attached links. In practice (for example, with the Internet’s OSPF routing protocol, discussed in <a class="xref" href="fileP7001011952000000000000000002092.xhtml#P7001011952000000000000000002092" data-foobar="7"><span class="label">Section</span> <span class="number">5.3</span></a>) this is often accomplished by a <span class="keyword" id="P7001011952000000000000000001F27" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F27"><b>link-state broadcast</b></span> algorithm ­<a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003AA9" data-foobar="7">[Perlman 1999]</a>. The result of the nodes’ broadcast is that all nodes have an identical and complete view of the network. Each node can then run the LS algorithm and compute the same set of least-cost paths as every other node.</p>
<p id="P700101195200000000000000000AB86" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB86">The link-state routing algorithm we present below is known as <i>Dijkstra’s algorithm</i>, named after its inventor. A closely related algorithm is Prim’s algorithm; see <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P70010119520000000000000000038A9" data-foobar="7">[Cormen 2001]</a> for a general discussion of graph algorithms. Dijkstra’s algorithm computes the least-cost path from one node (the source, which we will refer to as <i>u</i>) to all other nodes in the network. Dijkstra’s algorithm is iterative and has the property that after the <i>k</i>th iteration of the algorithm, the least-cost paths are known to <i>k</i> destination nodes, and among the least-cost paths to all destination <span class="pagebreak" title="380" id="P7001011952000000000000000001F29" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F29" epub:type="pagebreak" role="doc-pagebreak"></span>nodes, these <i>k</i> paths will have the <i>k</i> smallest costs. Let us define the following notation:</p>
<ul id="P700101195200000000000000000AB87" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB87">
<li id="P700101195200000000000000000AB88" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB88"><p id="P700101195200000000000000000AB89" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB89"><i>D</i>(<i>v</i>): cost of the least-cost path from the source node to destination <i>v</i> as of this iteration of the algorithm.</p></li>
<li id="P700101195200000000000000000AB8A" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB8A"><p id="P700101195200000000000000000AB8B" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB8B"><i>p</i>(<i>v</i>): previous node (neighbor of <i>v</i>) along the current least-cost path from the source to <i>v.</i></p></li>
<li id="P700101195200000000000000000AB8C" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB8C"><p id="P700101195200000000000000000AB8D" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB8D"><i>N</i>′: subset of nodes; <i>v</i> is in <i>N</i>′ if the least-cost path from the source to <i>v</i> is definitively known.</p></li>
</ul>
<p class="continued" id="P700101195200000000000000000AB8E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB8E">The centralized routing algorithm consists of an initialization step followed by a loop. The number of times the loop is executed is equal to the number of nodes in the network. Upon termination, the algorithm will have calculated the shortest paths from the source node <i>u</i> to every other node in the network.</p>
<section id="P7001011952000000000000000001F32" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F32" class="level3"><header><h1 class="title" id="P700101195200000000000000000AB8F" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB8F" epub:type="title">Link-State (LS) Algorithm for Source Node <i>u</i></h1></header>
<pre id="P700101195200000000000000000AB90" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB90"><code id="P700101195200000000000000000AB91" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB91">
1  <b>Initialization:</b> 
2   N’ = {u}
3   for all nodes v
4     if v is a neighbor of u
5       then D(v) = c(u, v)
6     else D(v) = ∞
7
8  <b>Loop</b>
9   find w not in N’ such that D(w) is a minimum
10  add w to N’
11  update D(v) for each neighbor v of w and not in N’:
12        D(v) = min(D(v), D(w)+ c(w, v) )
13   /* new cost to v is either old cost to v or known
14    least path cost to w plus cost from w to v */
15 <b>until</b> N’= N</code></pre>
<p id="P700101195200000000000000000AB92" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB92">As an example, let’s consider the network in <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a> and compute the least-cost paths from <i>u</i> to all possible destinations. A tabular summary of the algorithm’s computation is shown in <a class="xref" href="#P7001011952000000000000000001F3B" data-foobar="1"><span class="label">Table</span> <span class="number">5.1</span></a>, where each line in the table gives the values of the algorithm’s variables at the end of the iteration. Let’s consider the few first steps in detail.</p>
<ul id="P700101195200000000000000000AB93" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB93">
<li id="P700101195200000000000000000AB94" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB94"><p id="P700101195200000000000000000AB95" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB95">In the initialization step, the currently known least-cost paths from <i>u</i> to its directly attached neighbors, <i>v, x</i>, and <i>w</i>, are initialized to 2, 1, and 5, respectively. Note in<span class="pagebreak" title="381" id="P7001011952000000000000000001F3A" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F3A" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001F3B" class="table" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F3B">
<figcaption id="P700101195200000000000000000AB96" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB96"><header><h1 class="title" id="P700101195200000000000000000AB97" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB97" epub:type="title"><span class="label">Table </span><span class="number">5.1</span> Running the link-state algorithm on the network in <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a></h1></header></figcaption>
<table id="P700101195200000000000000000AB98" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB98">
<thead>
<tr>
<th id="P700101195200000000000000000AB99" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB99"><i>step</i></th>
<th id="P700101195200000000000000000AB9A" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB9A"><i>N’</i></th>
<th id="P700101195200000000000000000AB9B" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB9B"><i>D (v), p (v)</i></th>
<th id="P700101195200000000000000000AB9C" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB9C"><i>D (w), p (w)</i></th>
<th id="P700101195200000000000000000AB9D" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB9D"><i>D (x), p (x)</i></th>
<th id="P700101195200000000000000000AB9E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB9E"><i>D (y), p (y)</i></th>
<th id="P700101195200000000000000000AB9F" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AB9F"><i>D (z), p (z)</i></th>
</tr>
</thead>
<tbody>
<tr>
<td id="P700101195200000000000000000ABA0" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA0">0</td>
<td id="P700101195200000000000000000ABA1" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA1">u</td>
<td id="P700101195200000000000000000ABA2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA2">2, u</td>
<td id="P700101195200000000000000000ABA3" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA3">5, u</td>
<td id="P700101195200000000000000000ABA4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA4">1,u</td>
<td id="P700101195200000000000000000ABA5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA5">∞</td>
<td id="P700101195200000000000000000ABA6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA6">∞</td>
</tr>
<tr>
<td id="P700101195200000000000000000ABA7" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA7">1</td>
<td id="P700101195200000000000000000ABA8" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA8">ux</td>
<td id="P700101195200000000000000000ABA9" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABA9">2, u</td>
<td id="P700101195200000000000000000ABAA" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABAA">4, x</td>
<td></td>
<td id="P700101195200000000000000000ABAB" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABAB">2, x</td>
<td id="P700101195200000000000000000ABAC" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABAC">∞</td>
</tr>
<tr>
<td id="P700101195200000000000000000ABAD" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABAD">2</td>
<td id="P700101195200000000000000000ABAE" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABAE">uxy</td>
<td id="P700101195200000000000000000ABAF" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABAF">2, u</td>
<td id="P700101195200000000000000000ABB0" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB0">3, y</td>
<td></td>
<td></td>
<td id="P700101195200000000000000000ABB1" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB1">4, y</td>
</tr>
<tr>
<td id="P700101195200000000000000000ABB2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB2">3</td>
<td id="P700101195200000000000000000ABB3" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB3">uxyv</td>
<td></td>
<td id="P700101195200000000000000000ABB4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB4">3, y</td>
<td></td>
<td></td>
<td id="P700101195200000000000000000ABB5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB5">4, y</td>
</tr>
<tr>
<td id="P700101195200000000000000000ABB6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB6">4</td>
<td id="P700101195200000000000000000ABB7" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB7">uxyvw</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td id="P700101195200000000000000000ABB8" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB8">4, y</td>
</tr>
<tr>
<td id="P700101195200000000000000000ABB9" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABB9">5</td>
<td id="P700101195200000000000000000ABBA" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABBA">uxyvwz</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</figure>
<p class="continued" id="P700101195200000000000000000ABBB" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABBB">particular that the cost to <i>w</i> is set to 5 (even though we will soon see that a lesser-cost path does indeed exist) since this is the cost of the direct (one hop) link from <i>u</i> to <i>w.</i> The costs to <i>y</i> and <i>z</i> are set to infinity because they are not directly connected to <i>u.</i></p></li>
<li id="P700101195200000000000000000ABBC" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABBC"><p id="P700101195200000000000000000ABBD" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABBD">In the first iteration, we look among those nodes not yet added to the set <i>N</i>′ and find that node with the least cost as of the end of the previous iteration. That node is <i>x</i>, with a cost of 1, and thus <i>x</i> is added to the set <i>N</i>′. Line 12 of the LS algorithm is then performed to update <i>D</i>(<i>v</i>) for all nodes <i>v</i>, yielding the results shown in the second line (Step 1) in <a class="xref" href="#P7001011952000000000000000001F3B" data-foobar="1"><span class="label">Table</span> <span class="number">5.1</span></a>. The cost of the path to <i>v</i> is unchanged. The cost of the path to <i>w</i> (which was 5 at the end of the initialization) through node <i>x</i> is found to have a cost of 4. Hence this lower-cost path is selected and <i>w</i>’s predecessor along the shortest path from <i>u</i> is set to <i>x</i>. Similarly, the cost to <i>y</i> (through <i>x</i>) is computed to be 2, and the table is updated accordingly.</p></li>
<li id="P700101195200000000000000000ABBE" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABBE"><p id="P700101195200000000000000000ABBF" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABBF">In the second iteration, nodes <i>v</i> and <i>y</i> are found to have the least-cost paths (2), and we break the tie arbitrarily and add <i>y</i> to the set <i>N</i>′ so that <i>N</i>′ now contains <i>u, x</i>, and <i>y.</i> The cost to the remaining nodes not yet in <i>N</i>′, that is, nodes <i>v, w</i>, and <i>z</i>, are updated via line 12 of the LS algorithm, yielding the results shown in the third row in <a class="xref" href="#P7001011952000000000000000001F3B" data-foobar="1"><span class="label">Table</span> <span class="number">5.1</span></a>.</p></li>
<li id="P700101195200000000000000000ABC0" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABC0"><p id="P700101195200000000000000000ABC1" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABC1">And so on . . .</p></li>
</ul>
<p class="continued" id="P700101195200000000000000000ABC2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABC2">When the LS algorithm terminates, we have, for each node, its predecessor along the least-cost path from the source node. For each predecessor, we also have <i>its</i> predecessor, and so in this manner we can construct the entire path from the source to all destinations. The forwarding table in a node, say node <i>u</i>, can then be constructed from this information by storing, for each destination, the next-hop node on the least-cost path from <i>u</i> to the destination. <a class="xref" href="#P7001011952000000000000000001F6A" data-foobar="1"><span class="label">Figure</span> <span class="number">5.4</span></a> shows the resulting least-cost paths and forwarding table in <i>u</i> for the network in <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a>.<span class="pagebreak" title="382" id="P7001011952000000000000000001F69" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F69" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001F6A" class="figure" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F6A">
<img alt="Illustration of least cost path, with a forwarding tale for node." height="197" width="524" aria-describedby="P7001011952000000000000000001F6E" id="P700101195200000000000000000ABC3" data-uri="P70010119520000000000000000055A7" src="../images/4055105004.png"></img>
<figcaption id="P700101195200000000000000000ABC4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABC4"><header><h1 class="title" id="P700101195200000000000000000ABC5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABC5" epub:type="title"><span class="label">Figure </span><span class="number">5.4</span> Least cost path and forwarding table for node u</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001F6E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F6E" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055105004.xhtml#la_4055105004"><span class="label">Description</span></a></div>
<p id="P700101195200000000000000000ABD4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABD4">What is the computational complexity of this algorithm? That is, given <i>n</i> nodes (not counting the source), how much computation must be done in the worst case to find the least-cost paths from the source to all destinations? In the first iteration, we need to search through all <i>n</i> nodes to determine the node, <i>w</i>, not in <i>N</i>′ that has the minimum cost. In the second iteration, we need to check <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="47" altimg-height="13" altimg="../images/ch05math09.png"><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> nodes to determine the minimum cost; in the third iteration <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="49" altimg-height="13" altimg="../images/ch05math10.png"><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>2</m:mn></m:mrow></m:math></span> nodes, and so on. Overall, the total number of nodes we need to search through over all the iterations is <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="90" altimg-height="17" altimg="../images/ch05math11.png"><m:mrow><m:mi>n</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>/</m:mo><m:mn>2</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> and thus we say that the preceding implementation of the LS algorithm has worst-case complexity of order <i>n</i> squared: <i>O</i>(<i>n</i><sup>2</sup>). (A more sophisticated implementation of this algorithm, using a data structure known as a heap, can find the minimum in line 9 in logarithmic rather than linear time, thus reducing the complexity.)</p>
<p id="P700101195200000000000000000ABD5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABD5">Before completing our discussion of the LS algorithm, let us consider a pathology that can arise. <a class="xref" href="#P7001011952000000000000000001F82" data-foobar="1"><span class="label">Figure</span> <span class="number">5.5</span></a> shows a simple network topology where link costs are equal to the load carried on the link, for example, reflecting the delay that would be experienced. In this example, link costs are not symmetric; that is, <i>c</i>(<i>u, v</i>) equals <i>c</i>(<i>v, u</i>) only if the load carried on both directions on the link (<i>u, v</i>) is the same. In this example, node <i>z</i> originates a unit of traffic destined for <i>w</i>, node <i>x</i> also originates a unit of traffic destined for <i>w</i>, and node <i>y</i> injects an amount of traffic equal to <i>e</i>, also destined for <i>w</i>. The initial routing is shown in <a class="xref" href="#P7001011952000000000000000001F82" data-foobar="1"><span class="label">Figure</span> <span class="number">5.5(a)</span></a> with the link costs corresponding to the amount of traffic carried.</p>
<p id="P700101195200000000000000000ABD6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABD6">When the LS algorithm is next run, node <i>y</i> determines (based on the link costs shown in <a class="xref" href="#P7001011952000000000000000001F82" data-foobar="1"><span class="label">Figure</span> <span class="number">5.5(a)</span></a>) that the clockwise path to <i>w</i> has a cost of 1, while the counterclockwise path to <i>w</i> (which it had been using) has a cost of <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="50" altimg-height="13" altimg="../images/ch05math12.png"><m:mrow><m:mn>1</m:mn><m:mo>+</m:mo><m:mi>e</m:mi><m:mo>.</m:mo></m:mrow></m:math></span> Hence <i>y’</i>s least-cost path to <i>w</i> is now clockwise. Similarly, <i>x</i> determines that its new least-cost path to <i>w</i> is also clockwise, resulting in costs shown in <a class="xref" href="#P7001011952000000000000000001F82" data-foobar="1"><span class="label">Figure</span> <span class="number">5.5(b)</span></a>. When the LS algorithm is run next, nodes <i>x, y</i>, and <i>z</i> all detect a zero-cost path to <i>w</i> in the counterclockwise direction, and all route their traffic to the counterclockwise routes. The next time the LS algorithm is run, <i>x, y</i>, and <i>z</i> all then route their traffic to the clockwise routes.</p>
<p id="P700101195200000000000000000ABD7" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABD7">What can be done to prevent such oscillations (which can occur in any algorithm, not just an LS algorithm, that uses a congestion or delay-based link metric)? One solution would be to mandate that link costs not depend on the amount of traffic<span class="pagebreak" title="383" id="P7001011952000000000000000001F81" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F81" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001F82" class="figure" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F82">
<img alt="Oscillations with congestion-sensitive routing: initial routing." height="240" width="240" aria-describedby="P7001011952000000000000000001F86" id="P700101195200000000000000000ABD8" data-uri="P70010119520000000000000000055A8" src="../images/4055105005.png"></img>
<figcaption id="P700101195200000000000000000ABD9" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABD9"><header><h1 class="title" id="P700101195200000000000000000ABDA" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABDA" epub:type="title"><span class="label">Figure </span><span class="number">5.5</span> Oscillations with congestion-sensitive routing</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001F86" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F86" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055105005.xhtml#la_4055105005"><span class="label">Description</span></a></div>
<figure id="P7001011952000000000000000001F88" class="figure" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F88">
<img alt="Oscillations with congestion-sensitive routing: x, y detect better path to w, clockwise." height="256" width="240" aria-describedby="P7001011952000000000000000001F8A" id="P700101195200000000000000000ABDC" data-uri="P70010119520000000000000000055A9" src="../images/4055105005a.png"></img>
<details class="longdesc" id="P7001011952000000000000000001F8A" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F8A">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000ABDD" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABDD">In this version of the illustration, blue arrows pointing from Z to Y, from Y to X, and from X to W are all labeled 0. A blue arrow pointing from Z to W is labeled 2 + e. A blue arrow pointing from X to Y is labeled 1. And a blue arrow pointing from Y to Z is labeled 1 + e.</p>
</details>
</figure>
<figure id="P7001011952000000000000000001F8C" class="figure" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F8C">
<img alt="Oscillations with congestion-sensitive routing: x, y, z detect better path to w, counterclockwise." height="256" width="240" aria-describedby="P7001011952000000000000000001F8E" id="P700101195200000000000000000ABDE" data-uri="P70010119520000000000000000055AA" src="../images/4055105005b.png"></img>
<details class="longdesc" id="P7001011952000000000000000001F8E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F8E">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000ABDF" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABDF">In this version of the illustration, blue arrows from X to Y, from Y to Z, and from Z to W are all labeled 0. Meanwhile, a blue arrow pointing from Z to Y is labeled 1, an arrow pointing from Y to X is labeled 1 + e, and an arrow pointing from X to W is labeled 2 + e.</p>
</details>
</figure>
<figure id="P7001011952000000000000000001F90" class="figure" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F90">
<img alt="Oscillations with congestion-sensitive routing: x, y, z detect better path to w, clockwise." height="256" width="240" aria-describedby="P7001011952000000000000000001F92" id="P700101195200000000000000000ABE0" data-uri="P70010119520000000000000000055AB" src="../images/4055105005c.png"></img>
<details class="longdesc" id="P7001011952000000000000000001F92" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F92">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000ABE1" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE1">In this version of the illustration, a blue arrow pointing from X to Y is labeled 1, an arrow pointing from Y to Z is labeled 1 + e, and an arrow pointing from Z to W is labeled 2 + e. Meanwhile, blue arrows pointing from Z to Y, from Y to X, and from X to W are all labeled 0.</p>
</details>
</figure>
<p class="continued" id="P700101195200000000000000000ABE2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE2">carried—an unacceptable solution since one goal of routing is to avoid highly congested (for example, high-delay) links. Another solution is to ensure that not all routers run the LS algorithm at the same time. This seems a more reasonable solution, since we would hope that even if routers ran the LS algorithm with the same periodicity, the execution instance of the algorithm would not be the same at each node. Interestingly, researchers have found that routers in the Internet can self-synchronize among themselves <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003908" data-foobar="7">[Floyd Synchronization 1994]</a>. That is, even though they initially execute the algorithm with the same period but at different instants of time, the algorithm execution instance can eventually become, and remain, synchronized at the routers. One way to avoid such self-synchronization is for each router to randomize the time it sends out a link advertisement.</p>
<p id="P700101195200000000000000000ABE3" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE3">Having studied the LS algorithm, let’s consider the other major routing algorithm that is used in practice today—the distance-vector routing algorithm.</p>
</section>
</section>
<section id="P7001011952000000000000000001F96" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F96" class="level2"><header><h1 class="title" id="P700101195200000000000000000ABE4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE4" epub:type="title"><span class="pagebreak" title="384" id="P7001011952000000000000000001F98" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F98" epub:type="pagebreak" role="doc-pagebreak"></span><span class="number">5.2.2</span> The Distance-Vector (DV) Routing Algorithm</h1></header>
<p id="P700101195200000000000000000ABE5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE5">Whereas the LS algorithm is an algorithm using global information, the <span class="keyword" id="P7001011952000000000000000001F9A" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F9A"><b>distance-vector</b> (<b>DV</b>)</span> algorithm is iterative, asynchronous, and distributed. It is <i>distributed</i> in that each node receives some information from one or more of its <i>directly attached</i> neighbors, performs a calculation, and then distributes the results of its calculation back to its neighbors. It is <i>iterative</i> in that this process continues on until no more information is exchanged between neighbors. (Interestingly, the algorithm is also self-terminating—there is no signal that the computation should stop; it just stops.) The algorithm is <i>asynchronous</i> in that it does not require all of the nodes to operate in lockstep with each other. We’ll see that an asynchronous, iterative, self-terminating, distributed algorithm is much more interesting and fun than a centralized algorithm!</p>
<p id="P700101195200000000000000000ABE6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE6">Before we present the DV algorithm, it will prove beneficial to discuss an important relationship that exists among the costs of the least-cost paths. Let <i>d</i><sub><i>x</i></sub>(<i>y</i>) be the cost of the least-cost path from node <i>x</i> to node <i>y</i>. Then the least costs are related by the celebrated Bellman-Ford equation, namely,</p>
<div class="equation" id="P7001011952000000000000000001F9C" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001F9C"><m:math display="block" alttext="" data-uri="" altimg-width="252" altimg-height="20" altimg="../images/ch05math13.png"><m:mrow><m:msub><m:mi>d</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msub><m:mrow><m:mi>min</m:mi></m:mrow><m:mi>v</m:mi></m:msub><m:mrow><m:mo>{</m:mo><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>v</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>d</m:mi><m:mi>v</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>,</m:mo></m:mrow></m:math><span class="number">(5.1)</span></div>
<p class="continued" id="P700101195200000000000000000ABE7" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE7">where the <i>min<sub>v</sub></i> in the equation is taken over all of <i>x</i>’s neighbors. The Bellman-Ford equation is rather intuitive. Indeed, after traveling from <i>x</i> to <i>v</i>, if we then take the least-cost path from <i>v</i> to <i>y</i>, the path cost will be <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="118" altimg-height="17" altimg="../images/ch05math14.png"><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>v</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>d</m:mi><m:mi>v</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>.</m:mo></m:mrow></m:math></span> Since we must begin by traveling to some neighbor <i>v</i>, the least cost from <i>x</i> to <i>y</i> is the minimum of <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="114" altimg-height="17" altimg="../images/ch05math15.png"><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>v</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>d</m:mi><m:mi>v</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:math></span> taken over all neighbors <i>v</i>.</p>
<p id="P700101195200000000000000000ABE8" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE8">But for those who might be skeptical about the validity of the equation, let’s check it for source node <i>u</i> and destination node <i>z</i> in <a class="xref" href="#P7001011952000000000000000001F06" data-foobar="1"><span class="label">Figure</span> <span class="number">5.3</span></a>. The source node <i>u</i> has three neighbors: nodes <i>v</i>, <i>x</i>, and <i>w</i>. By walking along various paths in the graph, it is easy to see that <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="164" altimg-height="17" altimg="../images/ch05math16.png"><m:mrow><m:msub><m:mi>d</m:mi><m:mi>v</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>5</m:mn><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>d</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>3</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> and <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="83" altimg-height="17" altimg="../images/ch05math17.png"><m:mrow><m:msub><m:mi>d</m:mi><m:mi>w</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>3.</m:mn></m:mrow></m:math></span> Plugging these values into <a class="xref" href="#P7001011952000000000000000001F9C" data-foobar="1"><span class="label">Equation</span> <span class="number">5.1</span></a>, along with the costs <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="191" altimg-height="17" altimg="../images/ch05math18.png"><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>u</m:mi><m:mo>,</m:mo><m:mi>v</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>u</m:mi><m:mo>,</m:mo><m:mi>x</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> and <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="98" altimg-height="17" altimg="../images/ch05math19.png"><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>u</m:mi><m:mo>,</m:mo><m:mi>w</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>5</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> gives <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="331" altimg-height="20" altimg="../images/ch05math20.png"><m:mrow><m:msub><m:mi>d</m:mi><m:mi>u</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>min</m:mi><m:mrow><m:mo>{</m:mo><m:mrow><m:mn>2</m:mn><m:mo>+</m:mo><m:mn>5</m:mn><m:mo>,</m:mo><m:mn>5</m:mn><m:mo>+</m:mo><m:mn>3</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>+</m:mo><m:mn>3</m:mn></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>=</m:mo><m:mn>4</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> which is obviously true and which is exactly what the Dijskstra algorithm gave us for the same network. This quick verification should help relieve any skepticism you may have.</p>
<p id="P700101195200000000000000000ABE9" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABE9">The Bellman-Ford equation is not just an intellectual curiosity. It actually has significant practical importance: the solution to the Bellman-Ford equation provides the entries in node <i>x</i>’s forwarding table. To see this, let <i>v*</i> be any neighboring node that achieves the minimum in <a class="xref" href="#P7001011952000000000000000001F9C" data-foobar="1"><span class="label">Equation</span> <span class="number">5.1</span></a>. Then, if node <i>x</i> wants to send a packet to node <i>y</i> along a least-cost path, it should first forward the packet to node <i>v*</i>. Thus, node <i>x</i>’s forwarding table would specify node <i>v*</i> as the next-hop router for the ultimate destination <i>y</i>. Another important practical contribution of the Bellman-Ford equation is that it suggests the form of the neighbor-to-neighbor communication that will take place in the DV algorithm.</p>
<p id="P700101195200000000000000000ABEA" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABEA">The basic idea is as follows. Each node <i>x</i> begins with <i>D<sub>x</sub></i>(<i>y</i>), an estimate of the cost of the least-cost path from itself to node <i>y</i>, for all nodes, <i>y</i>, in <i>N</i>. Let <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="158" altimg-height="17" altimg="../images/ch05math21.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>:</m:mo><m:mtext> </m:mtext><m:mi>y</m:mi><m:mtext> in </m:mtext><m:mi>N</m:mi></m:mrow><m:mo>]</m:mo></m:mrow></m:mrow></m:math></span> be node <i>x</i>’s distance vector, which is the vector of cost estimates from <i>x</i> to all other nodes, <i>y</i>, in <i>N.</i> With the DV algorithm, each node <i>x</i> maintains the following routing information:</p>
<ul id="P700101195200000000000000000ABEB" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABEB">
<li id="P700101195200000000000000000ABEC" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABEC"><p id="P700101195200000000000000000ABED" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABED"><span class="pagebreak" title="385" id="P7001011952000000000000000001FA4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FA4" epub:type="pagebreak" role="doc-pagebreak"></span>For each neighbor <i>v</i>, the cost <i>c</i>(<i>x, v</i>) from <i>x</i> to directly attached neighbor, <i>v</i></p></li>
<li id="P700101195200000000000000000ABEE" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABEE"><p id="P700101195200000000000000000ABEF" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABEF">Node <i>x</i>’s distance vector, that is, <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="160" altimg-height="17" altimg="../images/ch05math22.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>:</m:mo><m:mtext> </m:mtext><m:mi>y</m:mi><m:mtext> in </m:mtext><m:mi>N</m:mi></m:mrow><m:mo>]</m:mo></m:mrow></m:mrow></m:math></span>, containing <i>x</i>’s estimate of its cost to all destinations, <i>y</i>, in <i>N</i></p></li>
<li id="P700101195200000000000000000ABF0" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF0"><p id="P700101195200000000000000000ABF1" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF1">The distance vectors of each of its neighbors, that is, <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="158" altimg-height="17" altimg="../images/ch05math23.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>v</m:mi></m:msub><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mrow><m:msub><m:mi>D</m:mi><m:mi>v</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>:</m:mo><m:mtext> </m:mtext><m:mi>y</m:mi><m:mtext> in </m:mtext><m:mi>N</m:mi></m:mrow><m:mo>]</m:mo></m:mrow></m:mrow></m:math></span> for each neighbor <i>v</i> of <i>x</i></p></li>
</ul>
<p class="continued" id="P700101195200000000000000000ABF2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF2">In the distributed, asynchronous algorithm, from time to time, each node sends a copy of its distance vector to each of its neighbors. When a node <i>x</i> receives a new distance vector from any of its neighbors <i>w</i>, it saves <i>w</i>’s distance vector, and then uses the Bellman-Ford equation to update its own distance vector as follows:</p>
<div class="informalequation" id="P7001011952000000000000000001FAA" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FAA"><m:math display="block" alttext="" data-uri="" altimg-width="431" altimg-height="20" altimg="../images/ch05math24.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:msub><m:mrow><m:mi>min</m:mi></m:mrow><m:mi>v</m:mi></m:msub><m:mrow><m:mo>{</m:mo><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>v</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>D</m:mi><m:mi>v</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>}</m:mo></m:mrow><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext>for each node </m:mtext><m:mi>y</m:mi><m:mtext> in </m:mtext><m:mi>N</m:mi></m:mrow></m:math></div>
<p class="continued" id="P700101195200000000000000000ABF3" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF3">If node <i>x</i>’s distance vector has changed as a result of this update step, node <i>x</i> will then send its updated distance vector to each of its neighbors, which can in turn update their own distance vectors. Miraculously enough, as long as all the nodes continue to exchange their distance vectors in an asynchronous fashion, each cost estimate <i>D<sub>x</sub></i>(<i>y</i>) converges to <i>d<sub>x</sub></i>(<i>y</i>), the actual cost of the least-cost path from node <i>x</i> to node <i>y</i> <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003837" data-foobar="7">[Bertsekas 1991]</a>!</p>
<section id="P7001011952000000000000000001FAC" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FAC" class="level3"><header><h1 class="title" id="P700101195200000000000000000ABF4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF4" epub:type="title">Distance-Vector (DV) Algorithm</h1></header>
<p id="P700101195200000000000000000ABF5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF5">At each node, <i>x</i>:</p>
<pre id="P700101195200000000000000000ABF6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF6"><code id="P700101195200000000000000000ABF7" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF7">1  <b>Initialization:</b>
2    for all destinations y in N:
3       D<sub>x</sub>(y)= c(x, y)/* if y is not a neighbor then c(x, y)= ∞ */
4    for each neighbor w
5       D<sub>w</sub>(y) = ? for all destinations y in N
6    for each neighbor w
7       send distance vector  <b>D</b><sub>x</sub> = [D<sub>x</sub>(y): y in N] to w
8
9  <b>loop</b> 
10    <b>wait</b>  (until I see a link cost change to some neighbor w or
11            until I receive a distance vector from some neighbor w)
12
13    for each y in N:
14        D<sub>x</sub>(y) = min<sub>v</sub>{c(x, v) + D<sub>v</sub>(y)}
15
16 <b>if</b> Dx(y) changed for any destination y
17       send distance vector <b>D</b><sub>x</sub>  = [D<sub>x</sub>(y): y in N] to all neighbors
18
19 <b>forever</b> </code></pre>
<p id="P700101195200000000000000000ABF8" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF8"><span class="pagebreak" title="386" id="P7001011952000000000000000001FB2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FB2" epub:type="pagebreak" role="doc-pagebreak"></span>In the DV algorithm, a node <i>x</i> updates its distance-vector estimate when it either sees a cost change in one of its directly attached links or receives a distance-vector update from some neighbor. But to update its own forwarding table for a given destination <i>y</i>, what node <i>x</i> really needs to know is not the shortest-path distance to <i>y</i> but instead the neighboring node <i>v*</i>(<i>y</i>) that is the next-hop router along the shortest path to <i>y</i>. As you might expect, the next-hop router <i>v*</i>(<i>y</i>) is the neighbor <i>v</i> that achieves the minimum in Line 14 of the DV algorithm. (If there are multiple neighbors <i>v</i> that achieve the minimum, then <i>v*</i>(<i>y</i>) can be any of the minimizing neighbors.) Thus, in Lines 13–14, for each destination <i>y</i>, node <i>x</i> also determines <i>v*</i>(<i>y</i>) and updates its forwarding table for destination <i>y</i>.</p>
<p id="P700101195200000000000000000ABF9" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABF9">Recall that the LS algorithm is a centralized algorithm in the sense that it requires each node to first obtain a complete map of the network before running the Dijkstra algorithm. The DV algorithm is <i>decentralized</i> and does not use such global information. Indeed, the only information a node will have is the costs of the links to its directly attached neighbors and information it receives from these neighbors. Each node waits for an update from any neighbor (Lines 10–11), calculates its new distance vector when receiving an update (Line 14), and distributes its new distance vector to its neighbors (Lines 16–17). DV-like algorithms are used in many routing protocols in practice, including the Internet’s RIP and BGP, ISO IDRP, Novell IPX, and the original ARPAnet.</p>
<p id="P700101195200000000000000000ABFA" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABFA"><a class="xref" href="#P7001011952000000000000000001FBB" data-foobar="1"><span class="label">Figure</span> <span class="number">5.6</span></a> illustrates the operation of the DV algorithm for the simple three-node network shown at the top of the figure. The operation of the algorithm is illustrated in a synchronous manner, where all nodes simultaneously receive distance vectors from their neighbors, compute their new distance vectors, and inform their neighbors if their distance vectors have changed. After studying this example, you should convince yourself that the algorithm operates correctly in an asynchronous manner as well, with node computations and update generation/reception occurring at any time.</p>
<p id="P700101195200000000000000000ABFB" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABFB">The leftmost column of the figure displays three initial <span class="keyword" id="P7001011952000000000000000001FB6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FB6"><b>routing tables</b></span> for each of the three nodes. For example, the table in the upper-left corner is node <i>x</i>’s initial routing table. Within a specific routing table, each row is a distance vector— specifically, each node’s routing table includes its own distance vector and that of each of its neighbors. Thus, the first row in node <i>x</i>’s initial routing table is <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="298" altimg-height="17" altimg="../images/ch05math25.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>,</m:mo><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>,</m:mo><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>]</m:mo></m:mrow><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mrow><m:mn>0</m:mn><m:mo>,</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>7</m:mn></m:mrow><m:mo>]</m:mo></m:mrow><m:mo>.</m:mo></m:mrow></m:math></span> The second and third rows in this table are the most recently received distance vectors from nodes <i>y</i> and <i>z</i>, respectively. Because at initialization node <i>x</i> has not received anything from node <i>y</i> or <i>z</i>, the entries in the second and third rows are initialized to infinity.</p>
<p id="P700101195200000000000000000ABFC" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABFC">After initialization, each node sends its distance vector to each of its two neighbors. This is illustrated in <a class="xref" href="#P7001011952000000000000000001FBB" data-foobar="1"><span class="label">Figure</span> <span class="number">5.6</span></a> by the arrows from the first column of tables to the second column of tables. For example, node <i>x</i> sends its distance vector <b><i>D</i></b><i><sub>x</sub></i> <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="15" altimg-height="5" altimg="../images/ch05math26.png"><m:mo>=</m:mo></m:math></span> [0, 2, 7] to both nodes <i>y</i> and <i>z</i>. After receiving the updates, each node recomputes its own distance vector. For example, node <i>x</i> computes<span class="pagebreak" title="387" id="P7001011952000000000000000001FB8" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FB8" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<div class="informalequation" id="P7001011952000000000000000001FB9" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FB9"><m:math display="block" alttext="" data-uri="" altimg-width="593" altimg-height="88" altimg="../images/ch05math27.png"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>min</m:mi><m:mrow><m:mo>{</m:mo><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>,</m:mo><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>=</m:mo><m:mi>min</m:mi><m:mrow><m:mo>{</m:mo><m:mrow><m:mn>2</m:mn><m:mo>+</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mtext> </m:mtext><m:mn>7</m:mn><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>=</m:mo><m:mn>2</m:mn></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>min</m:mi><m:mrow><m:mo>{</m:mo><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>,</m:mo><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>z</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>=</m:mo><m:mi>min</m:mi><m:mrow><m:mo>{</m:mo><m:mrow><m:mn>2</m:mn><m:mo>+</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>7</m:mn><m:mo>+</m:mo><m:mn>0</m:mn></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>=</m:mo><m:mn>3</m:mn></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math></div>
<p class="continued" id="P700101195200000000000000000ABFD" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABFD">The second column therefore displays, for each node, the node’s new distance vector along with distance vectors just received from its neighbors. Note, for example, that</p>
<figure id="P7001011952000000000000000001FBB" class="figure" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FBB">
<img alt="Illustration of a distance-vector (DV) algorithm in operation." height="738" width="504" aria-describedby="P7001011952000000000000000001FBF" id="P700101195200000000000000000ABFE" data-uri="P70010119520000000000000000055AC" src="../images/4055105006.png"></img>
<figcaption id="P700101195200000000000000000ABFF" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ABFF"><header><h1 class="title" id="P700101195200000000000000000AC00" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AC00" epub:type="title"><span class="label">Figure </span><span class="number">5.6</span> Distance-vector (DV) algorithm in operation</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001FBF" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000001FBF" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055105006.xhtml#la_4055105006"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000AC9B" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AC9B"><span class="pagebreak" title="388" id="P700101195200000000000000000205B" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000205B" epub:type="pagebreak" role="doc-pagebreak"></span>node <i>x</i>’s estimate for the least cost to node <i>z</i>, <i>D<sub>x</sub></i>(<i>z</i>), has changed from 7 to 3. Also note that for node <i>x</i>, neighboring node <i>y</i> achieves the minimum in line 14 of the DV algorithm; thus at this stage of the algorithm, we have at node <i>x</i> that <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="79" altimg-height="17" altimg="../images/ch05math28.png"><m:mrow><m:mi>v</m:mi><m:mo>*</m:mo><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>y</m:mi></m:mrow></m:math></span> and <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="82" altimg-height="17" altimg="../images/ch05math29.png"><m:mrow><m:mi>v</m:mi><m:mo>*</m:mo><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>y</m:mi><m:mo>.</m:mo></m:mrow></m:math></span></p>
<p id="P700101195200000000000000000AC9C" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AC9C">After the nodes recompute their distance vectors, they again send their updated distance vectors to their neighbors (if there has been a change). This is illustrated in <a class="xref" href="#P7001011952000000000000000001FBB" data-foobar="1"><span class="label">Figure</span> <span class="number">5.6</span></a> by the arrows from the second column of tables to the third column of tables. Note that only nodes <i>x</i> and <i>z</i> send updates: node <i>y</i>’s distance vector didn’t change so node <i>y</i> doesn’t send an update. After receiving the updates, the nodes then recompute their distance vectors and update their routing tables, which are shown in the third column.</p>
<p id="P700101195200000000000000000AC9D" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AC9D">The process of receiving updated distance vectors from neighbors, recomputing routing table entries, and informing neighbors of changed costs of the least-cost path to a destination continues until no update messages are sent. At this point, since no update messages are sent, no further routing table calculations will occur and the algorithm will enter a quiescent state; that is, all nodes will be performing the wait in Lines 10–11 of the DV algorithm. The algorithm remains in the quiescent state until a link cost changes, as discussed next.</p>
</section>
<section id="P700101195200000000000000000205E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000205E" class="level3"><header><h1 class="title" id="P700101195200000000000000000AC9E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AC9E" epub:type="title">Distance-Vector Algorithm: Link-Cost Changes and Link Failure</h1></header>
<p id="P700101195200000000000000000AC9F" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000AC9F">When a node running the DV algorithm detects a change in the link cost from itself to a neighbor (Lines 10–11), it updates its distance vector (Lines 13–14) and, if there’s a change in the cost of the least-cost path, informs its neighbors (Lines 16–17) of its new distance vector. <a class="xref" href="#P700101195200000000000000000206A" data-foobar="1"><span class="label">Figure</span> <span class="number">5.7(a)</span></a> illustrates a scenario where the link cost from <i>y</i> to <i>x</i> changes from 4 to 1. We focus here only on <i>y</i>’ and <i>z</i>’s distance table entries to destination <i>x</i>. The DV algorithm causes the following sequence of events to occur:</p>
<ul id="P700101195200000000000000000ACA0" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA0">
<li id="P700101195200000000000000000ACA1" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA1"><p id="P700101195200000000000000000ACA2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA2">At time <i>t</i><sub>0</sub>, <i>y</i> detects the link-cost change (the cost has changed from 4 to 1), updates its distance vector, and informs its neighbors of this change since its distance vector has changed.</p></li>
<li id="P700101195200000000000000000ACA3" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA3"><p id="P700101195200000000000000000ACA4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA4">At time <i>t</i><sub>1</sub>, <i>z</i> receives the update from <i>y</i> and updates its table. It computes a new least cost to <i>x</i> (it has decreased from a cost of 5 to a cost of 2) and sends its new distance vector to its neighbors.</p></li>
<li id="P700101195200000000000000000ACA5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA5"><p id="P700101195200000000000000000ACA6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA6">At time <i>t</i><sub>2</sub>, <i>y</i> receives <i>z</i>’s update and updates its distance table. <i>y</i>’s least costs do not change and hence <i>y</i> does not send any message to <i>z</i>. The algorithm comes to a quiescent state.</p></li>
</ul>
<p class="continued" id="P700101195200000000000000000ACA7" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA7">Thus, only two iterations are required for the DV algorithm to reach a quiescent state. The good news about the decreased cost between <i>x</i> and <i>y</i> has propagated quickly through the network.<span class="pagebreak" title="389" id="P7001011952000000000000000002069" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000002069" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P700101195200000000000000000206A" class="figure" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000206A">
<img alt="Illustration of changes in link cost." height="177" width="600" aria-describedby="P700101195200000000000000000206E" id="P700101195200000000000000000ACA8" data-uri="P70010119520000000000000000055AD" src="../images/4055105007.png"></img>
<figcaption id="P700101195200000000000000000ACA9" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACA9"><header><h1 class="title" id="P700101195200000000000000000ACAA" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACAA" epub:type="title"><span class="label">Figure </span><span class="number">5.7</span> Changes in link cost</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000206E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000206E" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055105007.xhtml#la_4055105007"><span class="label">Description</span></a></div>
<p id="P700101195200000000000000000ACAD" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACAD">Let’s now consider what can happen when a link cost <i>increases.</i> Suppose that the link cost between <i>x</i> and <i>y</i> increases from 4 to 60, as shown in <a class="xref" href="#P700101195200000000000000000206A" data-foobar="1"><span class="label">Figure</span> <span class="number">5.7(b)</span></a>.</p>
<ol id="P700101195200000000000000000ACAE" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACAE">
<li id="P700101195200000000000000000ACAF" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACAF"><p id="P700101195200000000000000000ACB0" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB0">Before the link cost changes, <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="262" altimg-height="19" altimg="../images/ch05math30.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>4</m:mn><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> and <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="85" altimg-height="17" altimg="../images/ch05math31.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>5.</m:mn></m:mrow></m:math></span> At time <i>t</i><sub>0</sub>, <i>y</i> detects the link-cost change (the cost has changed from 4 to 60). <i>y</i> computes its new minimum-cost path to <i>x</i> to have a cost of</p>
<div class="informalequation" id="P7001011952000000000000000002075" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000002075"><m:math display="block" alttext="" data-uri="" altimg-width="603" altimg-height="22" altimg="../images/ch05math32.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>min</m:mi><m:mrow><m:mo>{</m:mo><m:mrow><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>y</m:mi><m:mo>,</m:mo><m:mi>x</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>D</m:mi><m:mi>x</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi>c</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>y</m:mi><m:mo>,</m:mo><m:mi>z</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>+</m:mo><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>=</m:mo><m:mi>min</m:mi><m:mrow><m:mo>{</m:mo><m:mrow><m:mn>60</m:mn><m:mo>+</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>+</m:mo><m:mn>5</m:mn></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>=</m:mo><m:mn>6</m:mn></m:mrow></m:math></div>
<p class="continued" id="P700101195200000000000000000ACB1" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB1">Of course, with our global view of the network, we can see that this new cost via <i>z</i> is <i>wrong.</i> But the only information node <i>y</i> has is that its direct cost to <i>x</i> is 60 and that <i>z</i> has last told <i>y</i> that <i>z</i> could get to <i>x</i> with a cost of 5. So in order to get to <i>x, y</i> would now route through <i>z</i>, fully expecting that <i>z</i> will be able to get to <i>x</i> with a cost of 5. As of <i>t</i><sub>1</sub> we have a <span class="keyword" id="P7001011952000000000000000002077" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000002077"><b>routing loop</b></span>—in order to get to <i>x, y</i> routes through <i>z</i>, and <i>z</i> routes through <i>y</i>. A routing loop is like a black hole—a packet destined for <i>x</i> arriving at <i>y</i> or <i>z</i> as of <i>t</i><sub>1</sub> will bounce back and forth between these two nodes forever (or until the forwarding tables are changed).</p></li>
<li id="P700101195200000000000000000ACB2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB2"><p id="P700101195200000000000000000ACB3" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB3">Since node <i>y</i> has computed a new minimum cost to <i>x</i>, it informs <i>z</i> of its new distance vector at time <i>t</i><sub>1</sub>.</p></li>
<li id="P700101195200000000000000000ACB4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB4"><p id="P700101195200000000000000000ACB5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB5">Sometime after <i>t</i><sub>1</sub>, <i>z</i> receives <i>y</i>’s new distance vector, which indicates that <i>y</i>’s minimum cost to <i>x</i> is 6. <i>z</i> knows it can get to <i>y</i> with a cost of 1 and hence computes a new least cost to <i>x</i> of <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="282" altimg-height="20" altimg="../images/ch05math33.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>min</m:mi><m:mrow><m:mo>{</m:mo><m:mrow><m:mn>50</m:mn><m:mo>+</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mn>1</m:mn><m:mo>+</m:mo><m:mn>6</m:mn></m:mrow><m:mo>}</m:mo></m:mrow><m:mo>=</m:mo><m:mn>7.</m:mn></m:mrow></m:math></span> Since <i>z</i>’s least cost to <i>x</i> has increased, it then informs <i>y</i> of its new distance vector at <i>t</i><sub>2</sub>.</p></li>
<li id="P700101195200000000000000000ACB6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB6"><p id="P700101195200000000000000000ACB7" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB7">In a similar manner, after receiving <i>z</i>’s new distance vector, <i>y</i> determines <span class="inlineequation" id="P700101195200000000000000000207E" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000207E"><m:math display="block" alttext="" data-uri="" altimg-width="81" altimg-height="20" altimg="../images/ch05math34.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>8</m:mn></m:mrow></m:math></span> and sends <i>z</i> its distance vector. <i>z</i> then determines <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="80" altimg-height="18" altimg="../images/ch05math35.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>9</m:mn></m:mrow></m:math></span> and sends <i>y</i> its distance vector, and so on.</p></li>
</ol>
<p class="continued" id="P700101195200000000000000000ACB8" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB8">How long will the process continue? You should convince yourself that the loop will persist for 44 iterations (message exchanges between <i>y</i> and <i>z</i>)—until <i>z</i> eventually computes the cost of its path via <i>y</i> to be greater than 50. At this point, <i>z</i> will (finally!) determine that its least-cost path to <i>x</i> is via its direct connection to <i>x</i>. <i>y</i> will then <span class="pagebreak" title="390" id="P7001011952000000000000000002080" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000002080" epub:type="pagebreak" role="doc-pagebreak"></span>route to <i>x</i> via <i>z</i>. The result of the bad news about the increase in link cost has indeed traveled slowly! What would have happened if the link cost <i>c</i>(<i>y, x</i>) had changed from 4 to 10,000 and the cost <i>c</i>(<i>z, x</i>) had been 9,999? Because of such scenarios, the problem we have seen is sometimes referred to as the count-to-infinity ­problem.</p>
</section>
<section id="P7001011952000000000000000002081" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000002081" class="level3"><header><h1 class="title" id="P700101195200000000000000000ACB9" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACB9" epub:type="title">Distance-Vector Algorithm: Adding Poisoned Reverse</h1></header>
<p id="P700101195200000000000000000ACBA" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACBA">The specific looping scenario just described can be avoided using a technique known as <i>poisoned reverse.</i> The idea is simple—if <i>z</i> routes through <i>y</i> to get to destination <i>x</i>, then <i>z</i> will advertise to <i>y</i> that its distance to <i>x</i> is infinity, that is, <i>z</i> will advertise to <i>y</i> that <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="86" altimg-height="18" altimg="../images/ch05math36.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>∞</m:mi></m:mrow></m:math></span> (even though <i>z</i> knows <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="80" altimg-height="18" altimg="../images/ch05math37.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>5</m:mn></m:mrow></m:math></span> in truth). <i>z</i> will continue telling this little white lie to <i>y</i> as long as it routes to <i>x</i> via <i>y</i>. Since <i>y</i> believes that <i>z</i> has no path to <i>x, y</i> will never attempt to route to <i>x</i> via <i>z</i>, as long as <i>z</i> continues to route to <i>x</i> via <i>y</i> (and lies about doing so).</p>
<p id="P700101195200000000000000000ACBB" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACBB">Let’s now see how poisoned reverse solves the particular looping problem we encountered before in <a class="xref" href="#P7001011952000000000000000001F82" data-foobar="1"><span class="label">Figure</span> <span class="number">5.5(b)</span></a>. As a result of the poisoned reverse, <i>y</i>’s distance table indicates <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="89" altimg-height="18" altimg="../images/ch05math38.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>∞</m:mi><m:mo>.</m:mo></m:mrow></m:math></span> When the cost of the (<i>x</i>, <i>y</i>) link changes from 4 to 60 at time <i>t</i><sub>0</sub>, <i>y</i> updates its table and continues to route directly to <i>x</i>, albeit at a higher cost of 60, and informs <i>z</i> of its new cost to <i>x</i>, that is, <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="97" altimg-height="22" altimg="../images/ch05math39.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>60.</m:mn></m:mrow></m:math></span> After receiving the update at <i>t</i><sub>1</sub>, <i>z</i> immediately shifts its route to <i>x</i> to be via the direct (<i>z, x</i>) link at a cost of 50. Since this is a new least-cost path to <i>x</i>, and since the path no longer passes through <i>y, z</i> now informs <i>y</i> that <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="90" altimg-height="18" altimg="../images/ch05math40.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>z</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>50</m:mn></m:mrow></m:math></span> at <i>t</i><sub>2</sub>. After receiving the update from <i>z, y</i> updates its distance table with <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="95" altimg-height="20" altimg="../images/ch05math41.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>51.</m:mn></m:mrow></m:math></span> Also, since <i>z</i> is now on <i>y</i>’s least-cost path to <i>x</i>, <i>y</i> poisons the reverse path from <i>z</i> to <i>x</i> by informing <i>z</i> at time <i>t</i><sub>3</sub> that <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="87" altimg-height="19" altimg="../images/ch05math42.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mi>∞</m:mi></m:mrow></m:math></span> (even though <i>y</i> knows that <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="90" altimg-height="19" altimg="../images/ch05math43.png"><m:mrow><m:msub><m:mi>D</m:mi><m:mi>y</m:mi></m:msub><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>51</m:mn></m:mrow></m:math></span> in truth).</p>
<p id="P700101195200000000000000000ACBC" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACBC">Does poisoned reverse solve the general count-to-infinity problem? It does not. You should convince yourself that loops involving three or more nodes (rather than simply two immediately neighboring nodes) will not be detected by the poisoned reverse technique.</p>
</section>
<section id="P7001011952000000000000000002086" data-uri="M05_KURO4140_07_SE_C05.xhtml#P7001011952000000000000000002086" class="level3"><header><h1 class="title" id="P700101195200000000000000000ACBD" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACBD" epub:type="title">A Comparison of LS and DV Routing Algorithms</h1></header>
<p id="P700101195200000000000000000ACBE" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACBE">The DV and LS algorithms take complementary approaches toward computing routing. In the DV algorithm, each node talks to <i>only</i> its directly connected neighbors, but it provides its neighbors with least-cost estimates from itself to <i>all</i> the nodes (that it knows about) in the network. The LS algorithm requires global information. Consequently, when implemented in each and every router, e.g., as in <a class="xref" href="fileP70010119520000000000000000019CC.xhtml#P70010119520000000000000000019EC" data-foobar="7"><span class="label">Figure</span> <span class="number">4.2</span></a> and 5.1, each node would need to communicate with <i>all</i> other nodes (via broadcast), but it tells them <i>only</i> the costs of its directly connected links. Let’s conclude our study of LS and DV algorithms with a quick comparison of some of their attributes. Recall that <i>N</i> is the set of nodes (routers) and <i>E</i> is the set of edges (links).</p>
<ul id="P700101195200000000000000000ACBF" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACBF">
<li id="P700101195200000000000000000ACC0" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACC0"><p id="P700101195200000000000000000ACC1" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACC1"><span class="leadin">Message complexity.</span> We have seen that LS requires each node to know the cost of each link in the network. This requires O(|N| |E|) messages to be sent. Also, <span class="pagebreak" title="391" id="P700101195200000000000000000208C" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000208C" epub:type="pagebreak" role="doc-pagebreak"></span>whenever a link cost changes, the new link cost must be sent to all nodes. The DV algorithm requires message exchanges between directly connected neighbors at each iteration. We have seen that the time needed for the algorithm to converge can depend on many factors. When link costs change, the DV algorithm will propagate the results of the changed link cost only if the new link cost results in a changed least-cost path for one of the nodes attached to that link.</p></li>
<li id="P700101195200000000000000000ACC2" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACC2"><p id="P700101195200000000000000000ACC3" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACC3"><span class="leadin">Speed of convergence.</span> We have seen that our implementation of LS is an O(|N|<sup>2</sup>) algorithm requiring O(|N| |E|)) messages. The DV algorithm can converge slowly and can have routing loops while the algorithm is converging. DV also suffers from the count-to-infinity problem.</p></li>
<li id="P700101195200000000000000000ACC4" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACC4"><p id="P700101195200000000000000000ACC5" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACC5"><span class="leadin">Robustness.</span> What can happen if a router fails, misbehaves, or is sabotaged? Under LS, a router could broadcast an incorrect cost for one of its attached links (but no others). A node could also corrupt or drop any packets it received as part of an LS broadcast. But an LS node is computing only its own forwarding tables; other nodes are performing similar calculations for themselves. This means route calculations are somewhat separated under LS, providing a degree of robustness. Under DV, a node can advertise incorrect least-cost paths to any or all destinations. (Indeed, in 1997, a malfunctioning router in a small ISP provided national backbone routers with erroneous routing information. This caused other routers to flood the malfunctioning router with traffic and caused large portions of the Internet to become disconnected for up to several hours <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003A71" data-foobar="7">[Neumann 1997]</a>.) More generally, we note that, at each iteration, a node’s calculation in DV is passed on to its neighbor and then indirectly to its neighbor’s neighbor on the next iteration. In this sense, an incorrect node calculation can be diffused through the entire network under DV.</p></li>
</ul>
<p class="continued" id="P700101195200000000000000000ACC6" data-uri="M05_KURO4140_07_SE_C05.xhtml#P700101195200000000000000000ACC6">In the end, neither algorithm is an obvious winner over the other; indeed, both algorithms are used in the Internet.</p>
</section>
</section>
</section></body></html>