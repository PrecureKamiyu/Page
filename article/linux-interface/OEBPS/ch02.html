<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 2. Fundamental Concepts</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch01.html" title="Chapter 1. History and Standards"/><link rel="next" href="ch03.html" title="Chapter 3. System Programming Concepts"/></head><body><section class="chapter" title="Chapter 2. Fundamental Concepts" epub:type="chapter" id="fundamental_concepts"><div class="titlepage"><div><div><h2 class="title">Chapter 2. Fundamental Concepts</h2></div></div></div><p>This chapter introduces a range of concepts related to Linux system programming. It is
            intended for readers who have worked primarily with other operating systems, or who have
            only limited experience with Linux or another UNIX implementation.</p><div class="sect1" title="The Core Operating System: The Kernel"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_core_operating_system_colon_the_kern">The Core Operating System: The Kernel</h2></div></div></div><p>The term <span class="emphasis"><em>operating system</em></span> is commonly used with two different
                    meanings:<a id="IDX-CHP-2-0247" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To denote the entire package consisting of the central software managing a
                        computer’s resources and all of the accompanying standard software tools,
                        such as command-line interpreters, graphical user interfaces, file
                        utilities, and editors.</p></li><li class="listitem"><p>More narrowly, to refer to the central software that manages and allocates
                        computer resources (i.e., the CPU, RAM, and devices).</p></li></ul></div><p>The term <span class="emphasis"><em>kernel</em></span> is often used as a synonym for the second
                meaning, and it is with this meaning of the term <span class="emphasis"><em>operating
                    system</em></span> that we are concerned in this book.<a id="IDX-CHP-2-0248" class="indexterm"/></p><p>Although it is possible to run programs on a computer without a kernel, the
                presence of a kernel greatly simplifies the writing and use of other programs, and
                increases the power and flexibility available to programmers. The kernel does this
                by providing a software layer to manage the limited resources of a computer.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The Linux kernel executable typically resides at the pathname <code class="literal">/boot/vmlinuz</code>, or something similar. The
                    derivation of this filename is historical. On early UNIX implementations, the
                    kernel was called <code class="literal">unix</code>. Later UNIX
                    implementations, which implemented virtual memory, renamed the kernel as
                        <code class="literal">vmunix</code>. On Linux, the filename mirrors
                    the system name, with the <span class="emphasis"><em>z</em></span> replacing the final
                        <span class="emphasis"><em>x</em></span> to signify that the kernel is a compressed
                    executable.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="tasks_performed_by_the_kernel"/></div></div></div><div class="sect3" title="Tasks performed by the kernel"><div class="titlepage"><div><div><h4 class="title" id="tasks_performed_by_the_kernel-id1">Tasks performed by the kernel</h4></div></div></div><p>Among other things, the kernel performs the following tasks:<a id="IDX-CHP-2-0249" class="indexterm"/><a id="IDX-CHP-2-0250" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Process scheduling</em></span>: A computer has one or
                                more central processing units (CPUs), which execute the instructions
                                of programs. Like other UNIX systems, Linux is a
                                    <span class="emphasis"><em>preemptive multitasking</em></span> operating system,
                                    <span class="emphasis"><em>Multitasking</em></span> means that multiple processes
                                (i.e., running programs) can simultaneously reside in memory and
                                each may receive use of the CPU(s). <span class="emphasis"><em>Preemptive</em></span>
                                means that the rules governing which processes receive use of the
                                CPU and for how long are determined by the kernel process scheduler
                                (rather than by the processes themselves).<a id="IDX-CHP-2-0251" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Memory management</em></span>: While computer memories
                                are enormous by the standards of a decade or two ago, the size of
                                software has also correspondingly grown, so that physical memory
                                (RAM) remains a limited resource that the kernel must share among
                                processes in an equitable and efficient fashion. Like most modern
                                operating systems, Linux employs virtual memory management (<a class="xref" href="ch06.html#virtual_memory_management" title="Virtual Memory Management">Virtual Memory Management</a>), a technique that confers
                                two main advantages:<a id="IDX-CHP-2-0252" class="indexterm"/><a id="IDX-CHP-2-0253" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Processes are isolated from one another and from the
                                        kernel, so that one process can’t read or modify the memory
                                        of another process or the kernel.</p></li><li class="listitem"><p>Only part of a process needs to be kept in memory, thereby
                                        lowering the memory requirements of each process and
                                        allowing more processes to be held in RAM simultaneously.
                                        This leads to better CPU utilization, since it increases the
                                        likelihood that, at any moment in time, there is at least
                                        one process that the CPU(s) can execute.</p></li></ul></div></li><li class="listitem"><p><span class="emphasis"><em>Provision of a file system</em></span>: The kernel
                                provides a file system on disk, allowing files to be created,
                                retrieved, updated, deleted, and so on.<a id="IDX-CHP-2-0254" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Creation and termination of processes</em></span>: The
                                kernel can load a new program into memory, providing it with the
                                resources (e.g., CPU, memory, and access to files) that it needs in
                                order to run. Such an instance of a running program is termed a
                                    <span class="emphasis"><em>process</em></span>. Once a process has completed
                                execution, the kernel ensures that the resources it uses are freed
                                for subsequent reuse by later programs.</p></li><li class="listitem"><p><span class="emphasis"><em>Access to devices</em></span>: The devices (mice,
                                monitors, keyboards, disk and tape drives, and so on) attached to a
                                computer allow communication of information between the computer and
                                the outside world, permitting input, output, or both. The kernel
                                provides programs with an interface that standardizes and simplifies
                                access to devices, while at the same time arbitrating access by
                                multiple processes to each device.</p></li><li class="listitem"><p><span class="emphasis"><em>Networking</em></span>: The kernel transmits and receives
                                network messages (packets) on behalf of user processes. This task
                                includes routing of network packets to the target system.</p></li><li class="listitem"><p><span class="emphasis"><em>Provision of a system call application programming
                                    interface (API)</em></span>: Processes can request the kernel to
                                perform various tasks using kernel entry points known as
                                    <span class="emphasis"><em>system calls</em></span>. The Linux system call API is
                                the primary topic of this book. <a class="xref" href="ch03.html#system_calls" title="System Calls">System Calls</a>
                                details the steps that occur when a process performs a system
                                    call.<a id="IDX-CHP-2-0255" class="indexterm"/></p></li></ul></div><p>In addition to the above features, multiuser operating systems such as
                        Linux generally provide users with the abstraction of a <span class="emphasis"><em>virtual
                            private computer</em></span>; that is, each user can log on to the system
                        and operate largely independently of other users. For example, each user has
                        their own disk storage space (home directory). In addition, users can run
                        programs, each of which gets a share of the CPU and operates in its own
                        virtual address space, and these programs can independently access devices
                        and transfer information over the network. The kernel resolves potential
                        conflicts in accessing hardware resources, so users and processes are
                        generally unaware of the conflicts.</p></div><div class="sect3" title="Kernel mode and user mode"><div class="titlepage"><div><div><h4 class="title" id="kernel_mode_and_user_mode">Kernel mode and user mode</h4></div></div></div><p>Modern processor architectures typically allow the CPU to operate in at
                        least two different modes: <span class="emphasis"><em>user mode</em></span> and
                            <span class="emphasis"><em>kernel mode</em></span> (sometimes also referred to as
                            <span class="emphasis"><em>supervisor mode</em></span>). Hardware instructions allow
                        switching from one mode to the other. Correspondingly, areas of virtual
                        memory can be marked as being part of <span class="emphasis"><em>user space</em></span> or
                            <span class="emphasis"><em>kernel space</em></span>. When running in user mode, the CPU
                        can access only memory that is marked as being in user space; attempts to
                        access memory in kernel space result in a hardware exception. When running
                        in kernel mode, the CPU can access both user and kernel memory
                            space.<a id="IDX-CHP-2-0256" class="indexterm"/><a id="IDX-CHP-2-0257" class="indexterm"/><a id="IDX-CHP-2-0258" class="indexterm"/><a id="IDX-CHP-2-0259" class="indexterm"/></p><p>Certain operations can be performed only while the processor is operating
                        in kernel mode. Examples include executing the halt instruction to stop the
                        system, accessing the memory-management hardware, and initiating device I/O
                        operations. By taking advantage of this hardware design to place the
                        operating system in kernel space, operating system implementers can ensure
                        that user processes are not able to access the instructions and data
                        structures of the kernel, or to perform operations that would adversely
                        affect the operation of the system.</p></div><div class="sect3" title="Process versus kernel views of the system"><div class="titlepage"><div><div><h4 class="title" id="process_versus_kernel_views_of_the_syste">Process versus kernel views of the system</h4></div></div></div><p>In many everyday programming tasks, we are accustomed to thinking about
                        programming in a process-oriented way. However, when considering various
                        topics covered later in this book, it can be useful to reorient our
                        perspective to consider things from the kernel’s point of view. To make the
                        contrast clear, we now consider how things look first from a process
                        viewpoint and then from a kernel viewpoint.</p><p>A running system typically has numerous processes. For a process, many
                        things happen asynchronously. An executing process doesn’t know when it will
                        next time out, which other processes will then be scheduled for the CPU (and
                        in what order), or when it will next be scheduled. The delivery of signals
                        and the occurrence of interprocess communication events are mediated by the
                        kernel, and can occur at any time for a process. Many things happen
                        transparently for a process. A process doesn’t know where it is located in
                        RAM or, in general, whether a particular part of its memory space is
                        currently resident in memory or held in the swap area (a reserved area of
                        disk space used to supplement the computer’s RAM). Similarly, a process
                        doesn’t know where on the disk drive the files it accesses are being held;
                        it simply refers to the files by name. A process operates in isolation; it
                        can’t directly communicate with another process. A process can’t itself
                        create a new process or even end its own existence. Finally, a process can’t
                        communicate directly with the input and output devices attached to the
                        computer.</p><p>By contrast, a running system has one kernel that knows and controls
                        everything. The kernel facilitates the running of all processes on the
                        system. The kernel decides which process will next obtain access to the CPU,
                        when it will do so, and for how long. The kernel maintains data structures
                        containing information about all running processes and updates these
                        structures as processes are created, change state, and terminate. The kernel
                        maintains all of the low-level data structures that enable the filenames
                        used by programs to be translated into physical locations on the disk. The
                        kernel also maintains data structures that map the virtual memory of each
                        process into the physical memory of the computer and the swap area(s) on
                        disk. All communication between processes is done via mechanisms provided by
                        the kernel. In response to requests from processes, the kernel creates new
                        processes and terminates existing processes. Lastly, the kernel (in
                        particular, device drivers) performs all direct communication with input and
                        output devices, transferring information to and from user processes as
                        required.</p><p>Later in this book we’ll say things such as “a process can create another
                        process,” “a process can create a pipe,” “a process can write data to a
                        file,” and “a process can terminate by calling <span class="emphasis"><em>exit()</em></span>.”
                        Remember, however, that the kernel mediates all such actions, and these
                        statements are just shorthand for “a process can <span class="emphasis"><em>request that the
                            kernel</em></span> create another process,” and so on.</p></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id2">Further information</h4></div></div></div><p>Modern texts covering operating systems concepts and design, with
                        particular reference to UNIX systems, include [Tanenbaum, 2007], [Tanenbaum
                        &amp; Woodhull, 2006], and [Vahalia, 1996], the last of these containing
                        much detail on virtual memory architectures. [Goodheart &amp; Cox, 1994]
                        provide details on System V Release 4. [Maxwell, 1999] provides an annotated
                        listing of selected parts of the Linux 2.2.5 kernel. [Lions, 1996] is a
                        detailed exposition of the Sixth Edition UNIX source code that remains a
                        useful introduction to UNIX operating system internals. [Bovet &amp;
                        Cesati, 2005] describes the implementation of the Linux 2.6
                            kernel.<a id="IDX-CHP-2-0260" class="indexterm"/><a id="IDX-CHP-2-0261" class="indexterm"/><a id="IDX-CHP-2-0262" class="indexterm"/><a id="IDX-CHP-2-0263" class="indexterm"/><a id="IDX-CHP-2-0264" class="indexterm"/><a id="IDX-CHP-2-0265" class="indexterm"/><a id="IDX-CHP-2-0266" class="indexterm"/></p></div></div></div><div class="sect1" title="The Shell"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_shell">The Shell</h2></div></div></div><p>A <span class="emphasis"><em>shell</em></span> is a special-purpose program designed to read
                commands typed by a user and execute appropriate programs in response to those
                commands. Such a program is sometimes known as a <span class="emphasis"><em>command
                    interpreter</em></span>.<a id="IDX-CHP-2-0267" class="indexterm"/><a id="IDX-CHP-2-0268" class="indexterm"/></p><p>The term <span class="emphasis"><em>login shell</em></span> is used to denote the process that is
                created to run a shell when the user first logs in.<a id="IDX-CHP-2-0269" class="indexterm"/></p><p>Whereas on some operating systems the command interpreter is an integral part of
                the kernel, on UNIX systems, the shell is a user process. Many different shells
                exist, and different users (or, for that matter, a single user) on the same computer
                can simultaneously use different shells. A number of important shells have appeared
                over time:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Bourne shell</em></span> (<span class="emphasis"><em>sh</em></span>): This is the
                        oldest of the widely used shells, and was written by Steve Bourne. It was
                        the standard shell for Seventh Edition UNIX. The Bourne shell contains many
                        of the features familiar in all shells: I/O redirection, pipelines, filename
                        generation (globbing), variables, manipulation of environment variables,
                        command substitution, background command execution, and functions. All later
                        UNIX implementations include the Bourne shell in addition to any other
                        shells they might provide.</p></li><li class="listitem"><p><span class="emphasis"><em>C shell</em></span> (<span class="emphasis"><em>csh</em></span>): This shell was
                        written by Bill Joy at the University of California at Berkeley. The name
                        derives from the resemblance of many of the flow-control constructs of this
                        shell to those of the C programming language. The C shell provided several
                        useful interactive features unavailable in the Bourne shell, including
                        command history, command-line editing, job control, and aliases. The C shell
                        was not backward compatible with the Bourne shell. Although the standard
                        interactive shell on BSD was the C shell, shell scripts (described in a
                        moment) were usually written for the Bourne shell, so as to be portable
                        across all UNIX implementations.</p></li><li class="listitem"><p><span class="emphasis"><em>Korn shell</em></span> (<span class="emphasis"><em>ksh</em></span>): This shell was
                        written as the successor to the Bourne shell by David Korn at AT&amp;T
                        Bell Laboratories. While maintaining backward compatibility with the Bourne
                        shell, it also incorporated interactive features similar to those provided
                        by the C shell.</p></li><li class="listitem"><p><span class="emphasis"><em>Bourne again shell</em></span> (<span class="emphasis"><em>bash</em></span>): This
                        shell is the GNU project’s reimplementation of the Bourne shell. It supplies
                        interactive features similar to those available in the C and Korn shells.
                        The principal authors of <span class="emphasis"><em>bash</em></span> are Brian Fox and Chet
                        Ramey. Bash is probably the most widely used shell on Linux. (On Linux, the
                        Bourne shell, <span class="emphasis"><em>sh</em></span>, is typically provided by
                            <span class="emphasis"><em>bash</em></span> emulating <span class="emphasis"><em>sh</em></span> as closely
                        as possible.)</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>POSIX.2-1992 specified a standard for the shell that was based on the then
                    current version of the Korn shell. Nowadays, the Korn shell and
                        <span class="emphasis"><em>bash</em></span> both conform to POSIX, but provide a number of
                    extensions to the standard, and many of these extensions differ between the two
                    shells.</p></div><p>The shells are designed not merely for interactive use, but also for the
                interpretation of <span class="emphasis"><em>shell scripts</em></span>, which are text files
                containing shell commands. For this purpose, each of the shells has the facilities
                typically associated with programming languages: variables, loop and conditional
                statements, I/O commands, and functions.</p><p>Each of the shells performs similar tasks, albeit with variations in syntax.
                Unless referring to the operation of a specific shell, we typically refer to “the
                shell,” with the understanding that all shells operate in the manner described. Most
                of the examples in this book that require a shell use <span class="emphasis"><em>bash</em></span>,
                but, unless otherwise noted, the reader can assume these examples work the same way
                in other Bourne-type shells.</p></div><div class="sect1" title="Users and Groups"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="users_and_groups">Users and Groups</h2></div></div></div><p>Each user on the system is uniquely identified, and users may belong to
                groups.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="users"/></div></div></div><div class="sect3" title="Users"><div class="titlepage"><div><div><h4 class="title" id="users-id1">Users</h4></div></div></div><p>Every user of the system has a unique <span class="emphasis"><em>login name</em></span>
                        (username) and a corresponding numeric <span class="emphasis"><em>user ID</em></span> (UID).
                        For each user, these are defined by a line in the system <span class="emphasis"><em>password
                            file</em></span>, <code class="literal">/etc/passwd</code>, which
                        includes the following additional information:<a id="IDX-CHP-2-0270" class="indexterm"/><a id="IDX-CHP-2-0271" class="indexterm"/><a id="IDX-CHP-2-0272" class="indexterm"/><a id="IDX-CHP-2-0273" class="indexterm"/><a id="IDX-CHP-2-0274" class="indexterm"/><a id="IDX-CHP-2-0275" class="indexterm"/><a id="IDX-CHP-2-0276" class="indexterm"/><a id="IDX-CHP-2-0277" class="indexterm"/><a id="IDX-CHP-2-0278" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Group ID</em></span>: the numeric group ID of the first
                                of the groups of which the user is a member.<a id="IDX-CHP-2-0279" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Home directory</em></span>: the initial directory into
                                which the user is placed after logging in.</p></li><li class="listitem"><p><span class="emphasis"><em>Login shell</em></span>: the name of the program to be
                                executed to interpret user commands.</p></li></ul></div><p>The password record may also include the user’s password, in encrypted
                        form. However, for security reasons, the password is often stored in the
                        separate <span class="emphasis"><em>shadow password file</em></span>, which is readable only
                        by privileged users.</p></div><div class="sect3" title="Groups"><div class="titlepage"><div><div><h4 class="title" id="groups">Groups</h4></div></div></div><p>For administrative purposes—in particular, for controlling access to files
                        and other system resources—it is useful to organize users into
                            <span class="emphasis"><em>groups</em></span>. For example, the people in a team working
                        on a single project, and thus sharing a common set of files, might all be
                        made members of the same group. In early UNIX implementations, a user could
                        be a member of only one group. BSD allowed a user to simultaneously belong
                        to multiple groups, an idea that was taken up by other UNIX implementations
                        and the POSIX.1-1990 standard. Each group is identified by a single line in
                        the system <span class="emphasis"><em>group file</em></span>, <code class="literal">/etc/group</code>, which includes the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Group name</em></span>: the (unique) name of the
                                group.</p></li><li class="listitem"><p><span class="emphasis"><em>Group ID</em></span> (GID): the numeric ID associated
                                with this group.</p></li><li class="listitem"><p><span class="emphasis"><em>User list</em></span>: a comma-separated list of login
                                names of users who are members of this group (and who are not
                                otherwise identified as members of the group by virtue of the group
                                ID field of their password file record).</p></li></ul></div></div><div class="sect3" title="Superuser"><div class="titlepage"><div><div><h4 class="title" id="superuser">Superuser</h4></div></div></div><p>One user, known as the <span class="emphasis"><em>superuser</em></span>, has special
                        privileges within the system. The superuser account has user ID 0, and
                        normally has the login name <span class="emphasis"><em>root</em></span>. On typical UNIX
                        systems, the superuser bypasses all permission checks in the system. Thus,
                        for example, the superuser can access any file in the system, regardless of
                        the permissions on that file, and can send signals to any user process in
                        the system. The system administrator uses the superuser account to perform
                        various administrative tasks on the system.<a id="IDX-CHP-2-0280" class="indexterm"/></p></div></div></div><div class="sect1" title="Single Directory Hierarchy, Directories, Links, and Files"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="single_directory_hierarchy_comma_directo">Single Directory Hierarchy, Directories, Links, and Files</h2></div></div></div><p>The kernel maintains a single hierarchical directory structure to organize all
                files in the system. (This contrasts with operating systems such as Microsoft
                Windows, where each disk device has its own directory hierarchy.) At the base of
                this hierarchy is the <span class="emphasis"><em>root directory</em></span>, named <code class="literal">/</code> (slash). All files and directories are children or
                further removed descendants of the root directory. <a class="xref" href="ch02.html#subset_of_the_linux_single_directory_hie" title="Figure 2-1. Subset of the Linux single directory hierarchy">Figure 2-1</a> shows an example of this
                hierarchical file structure.<a id="IDX-CHP-2-0281" class="indexterm"/><a id="IDX-CHP-2-0282" class="indexterm"/><a id="IDX-CHP-2-0283" class="indexterm"/></p><div class="figure"><a id="subset_of_the_linux_single_directory_hie"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e2906"/><img src="figs/web/02-1_CONCEPTS-file-system.png.jpg" alt="Subset of the Linux single directory hierarchy"/></div></div><div class="figure-title">Figure 2-1. Subset of the Linux single directory hierarchy</div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="file_types"/></div></div></div><div class="sect3" title="File types"><div class="titlepage"><div><div><h4 class="title" id="file_types-id1">File types</h4></div></div></div><p>Within the file system, each file is marked with a
                            <span class="emphasis"><em>type</em></span>, indicating what kind of file it is. One of
                        these file types denotes ordinary data files, which are usually called
                            <span class="emphasis"><em>regular</em></span> or <span class="emphasis"><em>plain</em></span> files to
                        distinguish them from other file types. These other file types include
                        devices, pipes, sockets, directories, and symbolic links.<a id="IDX-CHP-2-0284" class="indexterm"/><a id="IDX-CHP-2-0285" class="indexterm"/><a id="IDX-CHP-2-0286" class="indexterm"/><a id="IDX-CHP-2-0287" class="indexterm"/><a id="IDX-CHP-2-0288" class="indexterm"/><a id="IDX-CHP-2-0289" class="indexterm"/></p><p>The term <span class="emphasis"><em>file</em></span> is commonly used to denote a file of
                        any type, not just a regular file.<a id="IDX-CHP-2-0290" class="indexterm"/></p></div><div class="sect3" title="Directories and links"><div class="titlepage"><div><div><h4 class="title" id="directories_and_links">Directories and links</h4></div></div></div><p>A <span class="emphasis"><em>directory</em></span> is a special file whose contents take the
                        form of a table of filenames coupled with references to the corresponding
                        files. This filename-plus-reference association is called a
                            <span class="emphasis"><em>link</em></span>, and files may have multiple links, and thus
                        multiple names, in the same or in different directories.<a id="IDX-CHP-2-0291" class="indexterm"/></p><p>Directories may contain links both to files and to other directories. The
                        links between directories establish the directory hierarchy shown in <a class="xref" href="ch02.html#subset_of_the_linux_single_directory_hie" title="Figure 2-1. Subset of the Linux single directory hierarchy">Figure 2-1</a>.</p><p>Every directory contains at least two entries: <code class="literal">.</code> (dot), which is a link to the directory itself, and
                            <code class="literal">..</code> (dot-dot), which is a link to its
                            <span class="emphasis"><em>parent directory</em></span>, the directory above it in the
                        hierarchy. Every directory, except the root directory, has a parent. For the
                        root directory, the dot-dot entry is a link to the root directory itself
                        (thus, <code class="literal">/..</code> equates to <code class="literal">/</code>).<a id="IDX-CHP-2-0292" class="indexterm"/></p></div><div class="sect3" title="Symbolic links"><div class="titlepage"><div><div><h4 class="title" id="symbolic_links">Symbolic links</h4></div></div></div><p>Like a normal link, a <span class="emphasis"><em>symbolic link</em></span> provides an
                        alternative name for a file. But whereas a normal link is a
                        filename-plus-pointer entry in a directory list, a symbolic link is a
                        specially marked file containing the name of another file. (In other words,
                        a symbolic link has a filename-plus-pointer entry in a directory, and the
                        file referred to by the pointer contains a string that names another file.)
                        This latter file is often called the <span class="emphasis"><em>target</em></span> of the
                        symbolic link, and it is common to say that the symbolic link “points” or
                        “refers” to the target file. When a pathname is specified in a system call,
                        in most circumstances, the kernel automatically
                            <span class="emphasis"><em>dereferences</em></span> (or synonymously,
                            <span class="emphasis"><em>follows</em></span>) each symbolic link in the pathname,
                        replacing it with the filename to which it points. This process may happen
                        recursively if the target of a symbolic link is itself a symbolic link. (The
                        kernel imposes limits on the number of dereferences to handle the
                        possibility of circular chains of symbolic links.) If a symbolic link refers
                        to a file that doesn’t exist, it is said to be a <span class="emphasis"><em>dangling
                            link</em></span>.<a id="IDX-CHP-2-0293" class="indexterm"/><a id="IDX-CHP-2-0294" class="indexterm"/><a id="IDX-CHP-2-0295" class="indexterm"/><a id="IDX-CHP-2-0296" class="indexterm"/><a id="IDX-CHP-2-0297" class="indexterm"/></p><p>Often <span class="emphasis"><em>hard link</em></span> and <span class="emphasis"><em>soft link</em></span>
                        are used as alternative terms for normal and symbolic links. The reasons for
                        having two different types of links are explained in <a class="xref" href="ch18.html" title="Chapter 18. Directories and Links">Chapter 18</a>.</p></div><div class="sect3" title="Filenames"><div class="titlepage"><div><div><h4 class="title" id="filenames">Filenames</h4></div></div></div><p>On most Linux file systems, filenames can be up to 255 characters long.
                        Filenames may contain any characters except slashes (<code class="literal">/</code>) and null characters (<code class="literal">\</code>0). However, it is advisable to employ only
                        letters and digits, and the . (period), _ (underscore), and - (hyphen)
                        characters. This 65-character set, <code class="literal">[-._a-zA-Z0-9</code>], is referred to in SUSv3 as the
                            <span class="emphasis"><em>portable filename character set</em></span>.<a id="IDX-CHP-2-0298" class="indexterm"/><a id="IDX-CHP-2-0299" class="indexterm"/></p><p>We should avoid the use of characters in filenames that are not in the
                        portable filename character set because those characters may have special
                        meanings within the shell, within regular expressions, or in other contexts.
                        If a filename containing characters with special meanings appears in such
                        contexts, then these characters must be <span class="emphasis"><em>escaped</em></span>; that
                        is, specially marked—typically with a preceding backslash (<code class="literal">\</code>)—to indicate that they should not be
                        interpreted with those special meanings. In contexts where no escape
                        mechanism is available, the filename is not usable.</p><p>We should also avoid filenames beginning with a hyphen (<code class="literal">-</code>), since such filenames may be mistaken for
                        options when specified in a shell command.</p></div><div class="sect3" title="Pathnames"><div class="titlepage"><div><div><h4 class="title" id="pathnames">Pathnames</h4></div></div></div><p>A <span class="emphasis"><em>pathname</em></span> is a string consisting of an optional
                        initial slash (<code class="literal">/</code>) followed by a series of
                        filenames separated by slashes. All but the last of these component
                        filenames identifies a directory (or a symbolic link that resolves to a
                        directory). The last component of a pathname may identify any type of file,
                        including a directory. The series of component filenames preceding the final
                        slash is sometimes referred to as the <span class="emphasis"><em>directory</em></span> part of
                        a pathname, while the name following the final slash is sometimes referred
                        to as the file or <span class="emphasis"><em>base</em></span> part of the pathname.</p><p>A pathname is read from left to right; each filename resides in the
                        directory specified by the preceding part of the pathname. The string
                            <code class="literal">..</code> can be used anywhere in a pathname
                        to refer to the parent of the location so far specified in the
                        pathname.</p><p>A pathname describes the location of a file within the single directory
                        hierarchy, and is either absolute or relative:<a id="IDX-CHP-2-0300" class="indexterm"/><a id="IDX-CHP-2-0301" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An <span class="emphasis"><em>absolute pathname</em></span> begins with a slash
                                    (<code class="literal">/</code>) and specifies the
                                location of a file with respect to the root directory. Examples of
                                absolute pathnames for files in <a class="xref" href="ch02.html#subset_of_the_linux_single_directory_hie" title="Figure 2-1. Subset of the Linux single directory hierarchy">Figure 2-1</a> are
                                    <code class="literal">/home/mtk/.bashrc</code>, <code class="literal">/usr/include</code>, and <code class="literal">/</code> (the pathname of the root
                                    directory).<a id="IDX-CHP-2-0302" class="indexterm"/></p></li><li class="listitem"><p>A <span class="emphasis"><em>relative pathname</em></span> specifies the location of
                                a file relative to a process’s current working directory (see
                                below), and is distinguished from an absolute pathname by the
                                absence of an initial slash. In <a class="xref" href="ch02.html#subset_of_the_linux_single_directory_hie" title="Figure 2-1. Subset of the Linux single directory hierarchy">Figure 2-1</a>, from the
                                directory <code class="literal">usr</code>, the file <code class="literal">types.h</code> could be referenced using the
                                relative pathname <code class="literal">include/sys/types.h</code>, while from the directory
                                    <code class="literal">avr</code>, the file <code class="literal">.bashrc</code> could be accessed using the
                                relative pathname <code class="literal">../mtk/.bashrc</code>.<a id="IDX-CHP-2-0303" class="indexterm"/><a id="IDX-CHP-2-0304" class="indexterm"/><a id="IDX-CHP-2-0305" class="indexterm"/></p></li></ul></div></div><div class="sect3" title="Current working directory"><div class="titlepage"><div><div><h4 class="title" id="current_working_directory">Current working directory</h4></div></div></div><p>Each process has a <span class="emphasis"><em>current working directory</em></span>
                        (sometimes just referred to as the process’s <span class="emphasis"><em>working
                            directory</em></span> or <span class="emphasis"><em>current directory</em></span>). This is
                        the process’s “current location” within the single directory hierarchy, and
                        it is from this directory that relative pathnames are interpreted for the
                            process.<a id="IDX-CHP-2-0306" class="indexterm"/><a id="IDX-CHP-2-0307" class="indexterm"/><a id="IDX-CHP-2-0308" class="indexterm"/><a id="IDX-CHP-2-0309" class="indexterm"/><a id="IDX-CHP-2-0310" class="indexterm"/><a id="IDX-CHP-2-0311" class="indexterm"/><a id="IDX-CHP-2-0312" class="indexterm"/><a id="IDX-CHP-2-0313" class="indexterm"/></p><p>A process inherits its current working directory from its parent process.
                        A login shell has its initial current working directory set to the location
                        named in the home directory field of the user’s password file entry. The
                        shell’s current working directory can be changed with the
                            <span class="emphasis"><em>cd</em></span> command.</p></div><div class="sect3" title="File ownership and permissions"><div class="titlepage"><div><div><h4 class="title" id="file_ownership_and_permissions">File ownership and permissions</h4></div></div></div><p>Each file has an associated user ID and group ID that define the owner of
                        the file and the group to which it belongs. The ownership of a file is used
                        to determine the access rights available to users of the file.</p><p>For the purpose of accessing a file, the system divides users into three
                        categories: the <span class="emphasis"><em>owner</em></span> of the file (sometimes termed the
                            <span class="emphasis"><em>user</em></span> of the file), users who are members of the
                        group matching the file’s group ID (<span class="emphasis"><em>group</em></span>), and the
                        rest of the world (<span class="emphasis"><em>other</em></span>). Three permission bits may be
                        set for each of these categories of user (making a total of nine permission
                        bits): <span class="emphasis"><em>read</em></span> permission allows the contents of the file
                        to be read; <span class="emphasis"><em>write</em></span> permission allows modification of the
                        contents of the file; and <span class="emphasis"><em>execute</em></span> permission allows
                        execution of the file, which is either a program or a script to be processed
                        by some interpreter (usually, but not always, one of the shells).</p><p>These permissions may also be set on directories, although their meanings
                        are slightly different: <span class="emphasis"><em>read</em></span> permission allows the
                        contents of (i.e., the filenames in) the directory to be listed;
                            <span class="emphasis"><em>write</em></span> permission allows the contents of the
                        directory to be changed (i.e., filenames can be added, removed, and
                        changed); and <span class="emphasis"><em>execute</em></span> (sometimes called
                            <span class="emphasis"><em>search</em></span>) permission allows access to files within
                        the directory (subject to the permissions on the files themselves).</p></div></div></div><div class="sect1" title="File I/O Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="file_i_solidus_o_model">File I/O Model</h2></div></div></div><p>One of the distinguishing features of the I/O model on UNIX systems is the concept
                of <span class="emphasis"><em>universality of I/O</em></span>. This means that the same system calls
                    (<span class="emphasis"><em>open()</em></span>, <span class="emphasis"><em>read()</em></span>,
                    <span class="emphasis"><em>write()</em></span>, <span class="emphasis"><em>close()</em></span>, and so on) are used
                to perform I/O on all types of files, including devices. (The kernel translates the
                application’s I/O requests into appropriate file-system or device-driver operations
                that perform I/O on the target file or device.) Thus, a program employing these
                system calls will work on any type of file.<a id="IDX-CHP-2-0314" class="indexterm"/><a id="IDX-CHP-2-0315" class="indexterm"/></p><p>The kernel essentially provides one file type: a sequential stream of bytes,
                which, in the case of disk files, disks, and tape devices, can be randomly accessed
                using the <span class="emphasis"><em>lseek()</em></span> system call.<a id="IDX-CHP-2-0316" class="indexterm"/></p><p>Many applications and libraries interpret the <span class="emphasis"><em>newline</em></span>
                character (ASCII code 10 decimal, sometimes also known as
                    <span class="emphasis"><em>linefeed</em></span>) as terminating one line of text and commencing
                another. UNIX systems have no <span class="emphasis"><em>end-of-file</em></span> character; the end of
                a file is detected by a read that returns no data.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="file_descriptors"/></div></div></div><div class="sect3" title="File descriptors"><div class="titlepage"><div><div><h4 class="title" id="file_descriptors-id1">File descriptors</h4></div></div></div><p>The I/O system calls refer to open files using a <span class="emphasis"><em>file
                            descriptor</em></span>, a (usually small) nonnegative integer. A file
                        descriptor is typically obtained by a call to <span class="emphasis"><em>open()</em></span>,
                        which takes a pathname argument specifying a file upon which I/O is to be
                            performed.<a id="IDX-CHP-2-0317" class="indexterm"/><a id="IDX-CHP-2-0318" class="indexterm"/><a id="IDX-CHP-2-0319" class="indexterm"/><a id="IDX-CHP-2-0320" class="indexterm"/><a id="IDX-CHP-2-0321" class="indexterm"/><a id="IDX-CHP-2-0322" class="indexterm"/><a id="IDX-CHP-2-0323" class="indexterm"/><a id="IDX-CHP-2-0324" class="indexterm"/><a id="IDX-CHP-2-0325" class="indexterm"/><a id="IDX-CHP-2-0326" class="indexterm"/></p><p>Normally, a process inherits three open file descriptors when it is
                        started by the shell: descriptor 0 is <span class="emphasis"><em>standard input</em></span>,
                        the file from which the process takes its input; descriptor 1 is
                            <span class="emphasis"><em>standard output</em></span>, the file to which the process
                        writes its output; and descriptor 2 is <span class="emphasis"><em>standard error</em></span>,
                        the file to which the process writes error messages and notification of
                        exceptional or abnormal conditions. In an interactive shell or program,
                        these three descriptors are normally connected to the terminal. In the
                            <span class="emphasis"><em>stdio</em></span> library, these descriptors correspond to the
                        file streams <span class="emphasis"><em>stdin</em></span>, <span class="emphasis"><em>stdout</em></span>, and
                            <span class="emphasis"><em>stderr</em></span>.<a id="IDX-CHP-2-0327" class="indexterm"/><a id="IDX-CHP-2-0328" class="indexterm"/><a id="IDX-CHP-2-0329" class="indexterm"/><a id="IDX-CHP-2-0330" class="indexterm"/></p></div><div class="sect3" title="The stdio library"><div class="titlepage"><div><div><h4 class="title" id="the_stdio_library">The <span class="emphasis"><em>stdio</em></span> library</h4></div></div></div><p>To perform file I/O, C programs typically employ I/O functions contained
                        in the standard C library. This set of functions, referred to as the
                            <span class="emphasis"><em>stdio</em></span> library, includes
                            <span class="emphasis"><em>fopen()</em></span>, <span class="emphasis"><em>fclose()</em></span>,
                            <span class="emphasis"><em>scanf()</em></span>, <span class="emphasis"><em>printf()</em></span>,
                            <span class="emphasis"><em>fgets()</em></span>, <span class="emphasis"><em>fputs()</em></span>, and so on.
                        The <span class="emphasis"><em>stdio</em></span> functions are layered on top of the I/O
                        system calls (<span class="emphasis"><em>open()</em></span>, <span class="emphasis"><em>close()</em></span>,
                            <span class="emphasis"><em>read()</em></span>, <span class="emphasis"><em>write()</em></span>, and so
                        on).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We assume that the reader is already familiar with the C standard I/O
                                (<span class="emphasis"><em>stdio</em></span>) functions, and don’t cover them in this
                            book. Further information on the <span class="emphasis"><em>stdio</em></span> library can
                            be found in [Kernighan &amp; Ritchie, 1988], [Harbison &amp;
                            Steele, 2002], [Plauger, 1992], and [Stevens &amp; Rago,
                            2005].</p></div></div></div></div><div class="sect1" title="Programs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="programs">Programs</h2></div></div></div><p><span class="emphasis"><em>Programs</em></span> normally exist in two forms. The first form is
                    <span class="emphasis"><em>source code</em></span>, human-readable text consisting of a series of
                statements written in a programming language such as C. To be executed, source code
                must be converted to the second form: binary machine-language instructions that the
                computer can understand. (This contrasts with a <span class="emphasis"><em>script</em></span>, which
                is a text file containing commands to be directly processed by a program such as a
                shell or other command interpreter.) The two meanings of the term
                    <span class="emphasis"><em>program</em></span> are normally considered synonymous, since the step
                of compiling and linking converts source code into semantically equivalent binary
                machine code.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="filters"/></div></div></div><div class="sect3" title="Filters"><div class="titlepage"><div><div><h4 class="title" id="filters-id1">Filters</h4></div></div></div><p>A <span class="emphasis"><em>filter</em></span> is the name often applied to a program that
                        reads its input from <span class="emphasis"><em>stdin</em></span>, performs some
                        transformation of that input, and writes the transformed data to
                            <span class="emphasis"><em>stdout</em></span>. Examples of filters include
                            <span class="emphasis"><em>cat</em></span>, <span class="emphasis"><em>grep</em></span>,
                            <span class="emphasis"><em>tr</em></span>, <span class="emphasis"><em>sort</em></span>,
                            <span class="emphasis"><em>wc</em></span>, <span class="emphasis"><em>sed</em></span>, and
                            <span class="emphasis"><em>awk</em></span>.<a id="IDX-CHP-2-0331" class="indexterm"/></p></div><div class="sect3" title="Command-line arguments"><div class="titlepage"><div><div><h4 class="title" id="command-line_arguments">Command-line arguments</h4></div></div></div><p>In C, programs can access the <span class="emphasis"><em>command-line arguments</em></span>,
                        the words that are supplied on the command line when the program is run. To
                        access the command-line arguments, the <span class="emphasis"><em>main()</em></span> function
                        of the program is declared as follows:<a id="IDX-CHP-2-0332" class="indexterm"/><a id="IDX-CHP-2-0333" class="indexterm"/><a id="IDX-CHP-2-0334" class="indexterm"/><a id="IDX-CHP-2-0335" class="indexterm"/><a id="IDX-CHP-2-0336" class="indexterm"/><a id="IDX-CHP-2-0337" class="indexterm"/></p><a id="I_programlisting2_d1e3562"/><pre class="programlisting">int main(int argc, char *argv[])</pre><p>The <span class="emphasis"><em>argc</em></span> variable contains the total number of
                        command-line arguments, and the individual arguments are available as
                        strings pointed to by members of the array <span class="emphasis"><em>argv</em></span>. The
                        first of these strings, <span class="emphasis"><em>argv[0]</em></span>, identifies the name of
                        the program itself.</p></div></div></div><div class="sect1" title="Processes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="processes">Processes</h2></div></div></div><p>Put most simply, a <span class="emphasis"><em>process</em></span> is an instance of an executing
                program. When a program is executed, the kernel loads the code of the program into
                virtual memory, allocates space for program variables, and sets up kernel
                bookkeeping data structures to record various information (such as process ID,
                termination status, user IDs, and group IDs) about the process.<a id="IDX-CHP-2-0338" class="indexterm"/></p><p>From a kernel point of view, processes are the entities among which the kernel
                must share the various resources of the computer. For resources that are limited,
                such as memory, the kernel initially allocates some amount of the resource to the
                process, and adjusts this allocation over the lifetime of the process in response to
                the demands of the process and the overall system demand for that resource. When the
                process terminates, all such resources are released for reuse by other processes.
                Other resources, such as the CPU and network bandwidth, are renewable, but must be
                shared equitably among all processes.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="process_memory_layout"/></div></div></div><div class="sect3" title="Process memory layout"><div class="titlepage"><div><div><h4 class="title" id="process_memory_layout-id1">Process memory layout</h4></div></div></div><p>A process is logically divided into the following parts, known as
                            <span class="emphasis"><em>segments</em></span>:<a id="IDX-CHP-2-0339" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Text</em></span>: the instructions of the program.</p></li><li class="listitem"><p><span class="emphasis"><em>Data</em></span>: the static variables used by the
                                program.</p></li><li class="listitem"><p><span class="emphasis"><em>Heap</em></span>: an area from which programs can
                                dynamically allocate extra memory.</p></li><li class="listitem"><p><span class="emphasis"><em>Stack</em></span>: a piece of memory that grows and
                                shrinks as functions are called and return and that is used to
                                allocate storage for local variables and function call linkage
                                information.</p></li></ul></div></div><div class="sect3" title="Process creation and program execution"><div class="titlepage"><div><div><h4 class="title" id="process_creation_and_program_execution">Process creation and program execution</h4></div></div></div><p>A process can create a new process using the <span class="emphasis"><em>fork()</em></span>
                        system call. The process that calls <span class="emphasis"><em>fork()</em></span> is referred
                        to as the <span class="emphasis"><em>parent process</em></span>, and the new process is
                        referred to as the <span class="emphasis"><em>child process</em></span>. The kernel creates
                        the child process by making a duplicate of the parent process. The child
                        inherits copies of the parent’s data, stack, and heap segments, which it may
                        then modify independently of the parent’s copies. (The program text, which
                        is placed in memory marked as read-only, is shared by the two
                            processes.)<a id="IDX-CHP-2-0340" class="indexterm"/><a id="IDX-CHP-2-0341" class="indexterm"/><a id="IDX-CHP-2-0342" class="indexterm"/></p><p>The child process goes on either to execute a different set of functions
                        in the same code as the parent, or, frequently, to use the
                            <span class="emphasis"><em>execve()</em></span> system call to load and execute an
                        entirely new program. An <span class="emphasis"><em>execve()</em></span> call destroys the
                        existing text, data, stack, and heap segments, replacing them with new
                        segments based on the code of the new program.<a id="IDX-CHP-2-0343" class="indexterm"/></p><p>Several related C library functions are layered on top of
                            <span class="emphasis"><em>execve()</em></span>, each providing a slightly different
                        interface to the same functionality. All of these functions have names
                        starting with the string <span class="emphasis"><em>exec</em></span>, and where the
                        differences don’t matter, we’ll use the notation <span class="emphasis"><em>exec()</em></span>
                        to refer generally to these functions. Be aware, however, that there is no
                        actual function with the name <span class="emphasis"><em>exec()</em></span>.<a id="IDX-CHP-2-0344" class="indexterm"/></p><p>Commonly, we’ll use the verb <span class="emphasis"><em>to exec</em></span> to describe the
                        operation performed <span class="emphasis"><em>execve()</em></span> and the library functions
                        layered on top of it.</p></div><div class="sect3" title="Process ID and parent process ID"><div class="titlepage"><div><div><h4 class="title" id="process_id_and_parent_process_id">Process ID and parent process ID</h4></div></div></div><p>Each process has a unique integer <span class="emphasis"><em>process identifier</em></span>
                        (PID). Each process also has a <span class="emphasis"><em>parent process
                            identifier</em></span> (PPID) attribute, which identifies the process
                        that requested the kernel to create this process.<a id="IDX-CHP-2-0348" class="indexterm"/><a id="IDX-CHP-2-0349" class="indexterm"/><a id="IDX-CHP-2-0350" class="indexterm"/><a id="IDX-CHP-2-0351" class="indexterm"/><a id="IDX-CHP-2-0345" class="indexterm"/><a id="IDX-CHP-2-0346" class="indexterm"/><a id="IDX-CHP-2-0347" class="indexterm"/></p></div><div class="sect3" title="Process termination and termination status"><div class="titlepage"><div><div><h4 class="title" id="process_termination_and_termination_stat">Process termination and termination status</h4></div></div></div><p>A process can terminate in one of two ways: by requesting its own
                        termination using the <span class="emphasis"><em>_exit()</em></span> system call (or the
                        related <span class="emphasis"><em>exit()</em></span> library function), or by being killed by
                        the delivery of a signal. In either case, the process yields a
                            <span class="emphasis"><em>termination status</em></span>, a small nonnegative integer
                        value that is available for inspection by the parent process using the
                            <span class="emphasis"><em>wait()</em></span> system call. In the case of a call to
                            _<span class="emphasis"><em>exit()</em></span>, the process explicitly specifies its own
                        termination status. If a process is killed by a signal, the termination
                        status is set according to the type of signal that caused the death of the
                        process. (Sometimes, we’ll refer to the argument passed to
                            _<span class="emphasis"><em>exit()</em></span> as the <span class="emphasis"><em>exit status</em></span> of
                        the process, as distinct from the termination status, which is either the
                        value passed to _<span class="emphasis"><em>exit()</em></span> or an indication of the signal
                        that killed the process.)<a id="IDX-CHP-2-0352" class="indexterm"/><a id="IDX-CHP-2-0353" class="indexterm"/><a id="IDX-CHP-2-0354" class="indexterm"/><a id="IDX-CHP-2-0355" class="indexterm"/><a id="IDX-CHP-2-0356" class="indexterm"/><a id="IDX-CHP-2-0357" class="indexterm"/><a id="IDX-CHP-2-0358" class="indexterm"/></p><p>By convention, a termination status of 0 indicates that the process
                        succeeded, and a nonzero status indicates that some error occurred. Most
                        shells make the termination status of the last executed program available
                        via a shell variable named <span class="emphasis"><em>$?</em></span>.</p></div><div class="sect3" title="Process user and group identifiers (credentials)"><div class="titlepage"><div><div><h4 class="title" id="process_user_and_group_identifiers_open">Process user and group identifiers (credentials)</h4></div></div></div><p>Each process has a number of associated user IDs (UIDs) and group IDs
                        (GIDs). These include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Real user ID</em></span> and <span class="emphasis"><em>real group
                                    ID</em></span>: These identify the user and group to which the
                                process belongs. A new process inherits these IDs from its parent. A
                                login shell gets its real user ID and real group ID from the
                                corresponding fields in the system password file.<a id="IDX-CHP-2-0359" class="indexterm"/><a id="IDX-CHP-2-0360" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Effective user ID</em></span> and <span class="emphasis"><em>effective
                                    group ID</em></span>: These two IDs (in conjunction with the
                                supplementary group IDs discussed in a moment) are used in
                                determining the permissions that the process has when accessing
                                protected resources such as files and interprocess communication
                                objects. Typically, the process’s effective IDs have the same values
                                as the corresponding real IDs. Changing the effective IDs is a
                                mechanism that allows a process to assume the privileges of another
                                user or group, as described in a moment.<a id="IDX-CHP-2-0361" class="indexterm"/><a id="IDX-CHP-2-0362" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Supplementary group IDs</em></span>: These IDs identify
                                additional groups to which a process belongs. A new process inherits
                                its supplementary group IDs from its parent. A login shell gets its
                                supplementary group IDs from the system group file.</p></li></ul></div></div><div class="sect3" title="Privileged processes"><div class="titlepage"><div><div><h4 class="title" id="privileged_processes">Privileged processes</h4></div></div></div><p>Traditionally, on UNIX systems, a <span class="emphasis"><em>privileged process</em></span>
                        is one whose <span class="emphasis"><em>effective</em></span> user ID is 0 (superuser). Such a
                        process bypasses the permission restrictions normally applied by the kernel.
                        By contrast, the term <span class="emphasis"><em>unprivileged</em></span> (or
                            <span class="emphasis"><em>nonprivileged</em></span>) is applied to processes run by other
                        users. Such processes have a nonzero effective user ID and must abide by the
                        permission rules enforced by the kernel.<a id="IDX-CHP-2-0363" class="indexterm"/><a id="IDX-CHP-2-0364" class="indexterm"/><a id="IDX-CHP-2-0365" class="indexterm"/><a id="IDX-CHP-2-0366" class="indexterm"/><a id="IDX-CHP-2-0367" class="indexterm"/><a id="IDX-CHP-2-0368" class="indexterm"/><a id="IDX-CHP-2-0369" class="indexterm"/><a id="IDX-CHP-2-0370" class="indexterm"/><a id="IDX-CHP-2-0371" class="indexterm"/></p><p>A process may be privileged because it was created by another privileged
                        process—for example, by a login shell started by <span class="emphasis"><em>root</em></span>
                        (superuser). Another way a process may become privileged is via the
                        set-user-ID mechanism, which allows a process to assume an effective user ID
                        that is the same as the user ID of the program file that it is
                        executing.</p></div><div class="sect3" title="Capabilities"><div class="titlepage"><div><div><h4 class="title" id="capabilities">Capabilities</h4></div></div></div><p>Since kernel 2.2, Linux divides the privileges traditionally accorded to
                        the superuser into a set of distinct units called
                            <span class="emphasis"><em>capabilities</em></span>. Each privileged operation is
                        associated with a particular capability, and a process can perform an
                        operation only if it has the corresponding capability. A traditional
                        superuser process (effective user ID of 0) corresponds to a process with all
                        capabilities enabled.</p><p>Granting a subset of capabilities to a process allows it to perform some
                        of the operations normally permitted to the superuser, while preventing it
                        from performing others.</p><p>Capabilities are described in detail in <a class="xref" href="ch39.html" title="Chapter 39. Capabilities">Chapter 39</a>. In the remainder of the book, when noting that a particular operation
                        can be performed only by a privileged process, we’ll usually identify the
                        specific capability in parentheses. Capability names begin with the prefix
                            <code class="literal">CAP_</code>, as in <code class="literal">CAP_KILL</code>.</p></div><div class="sect3" title="The init process"><div class="titlepage"><div><div><h4 class="title" id="the_init_process">The <span class="emphasis"><em>init</em></span> process</h4></div></div></div><p>When booting the system, the kernel creates a special process called
                            <span class="emphasis"><em>init</em></span>, the “parent of all processes,” which is
                        derived from the program file <code class="literal">/sbin/init</code>.
                        All processes on the system are created (using <span class="emphasis"><em>fork()</em></span>)
                        either by <span class="emphasis"><em>init</em></span> or by one of its descendants. The
                            <span class="emphasis"><em>init</em></span> process always has the process ID 1 and runs
                        with superuser privileges. The <span class="emphasis"><em>init</em></span> process can’t be
                        killed (not even by the superuser), and it terminates only when the system
                        is shut down. The main task of <span class="emphasis"><em>init</em></span> is to create and
                        monitor a range of processes required by a running system. (For details, see
                        the <span class="emphasis"><em>init(8)</em></span> manual page.)<a id="IDX-CHP-2-0372" class="indexterm"/></p></div><div class="sect3" title="Daemon processes"><div class="titlepage"><div><div><h4 class="title" id="daemon_processes">Daemon processes</h4></div></div></div><p>A <span class="emphasis"><em>daemon</em></span> is a special-purpose process that is created
                        and handled by the system in the same way as other processes, but which is
                        distinguished by the following characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It is long-lived. A daemon process is often started at system boot
                                and remains in existence until the system is shut down.<a id="IDX-CHP-2-0373" class="indexterm"/></p></li><li class="listitem"><p>It runs in the background, and has no controlling terminal from
                                which it can read input or to which it can write output.<a id="IDX-CHP-2-0374" class="indexterm"/></p></li></ul></div><p>Examples of daemon processes include <span class="emphasis"><em>syslogd</em></span>, which
                        records messages in the system log, and <span class="emphasis"><em>httpd</em></span>, which
                        serves web pages via the Hypertext Transfer Protocol (HTTP).</p></div><div class="sect3" title="Environment list"><div class="titlepage"><div><div><h4 class="title" id="environment_list">Environment list</h4></div></div></div><p>Each process has an <span class="emphasis"><em>environment list</em></span>, which is a set
                        of <span class="emphasis"><em>environment variables</em></span> that are maintained within the
                        user-space memory of the process. Each element of this list consists of a
                        name and an associated value. When a new process is created via
                            <span class="emphasis"><em>fork()</em></span>, it inherits a copy of its parent’s
                        environment. Thus, the environment provides a mechanism for a parent process
                        to communicate information to a child process. When a process replaces the
                        program that it is running using <span class="emphasis"><em>exec()</em></span>, the new
                        program either inherits the environment used by the old program or receives
                        a new environment specified as part of the <span class="emphasis"><em>exec()</em></span>
                            call.<a id="IDX-CHP-2-0375" class="indexterm"/><a id="IDX-CHP-2-0376" class="indexterm"/><a id="IDX-CHP-2-0377" class="indexterm"/><a id="IDX-CHP-2-0378" class="indexterm"/></p><p>Environment variables are created with the <span class="emphasis"><em>export</em></span>
                        command in most shells (or the <span class="emphasis"><em>setenv</em></span> command in the C
                        shell), as in the following example:</p><a id="I_programlisting2_d1e4022"/><pre class="programlisting">$ export MYVAR='Hello world'</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Whenever we present a shell session log showing interactive input and
                            output, the input text is always boldfaced. Sometimes, we include
                            commentary in the log in italic text, adding notes about the commands
                            entered or the output produced.</p></div><p>C programs can access the environment using an external variable
                            (<span class="emphasis"><em>char **environ</em></span>), and various library functions
                        allow a process to retrieve and modify values in its environment.</p><p>Environment variables are used for a variety of purposes. For example, the
                        shell defines and uses a range of variables that can be accessed by scripts
                        and programs executed from the shell. These include the variable <code class="literal">HOME</code>, which specifies the pathname of the
                        user’s login directory, and the variable <code class="literal">PATH</code>, which specifies a list of directories that the shell
                        should search when looking for programs corresponding to commands entered by
                        the user.</p></div><div class="sect3" title="Resource limits"><div class="titlepage"><div><div><h4 class="title" id="resource_limits">Resource limits</h4></div></div></div><p>Each process consumes resources, such as open files, memory, and CPU time.
                        Using the <span class="emphasis"><em>setrlimit()</em></span> system call, a process can
                        establish upper limits on its consumption of various resources. Each such
                            <span class="emphasis"><em>resource limit</em></span> has two associated values: a
                            <span class="emphasis"><em>soft limit</em></span>, which limits the amount of the resource
                        that the process may consume; and a <span class="emphasis"><em>hard limit</em></span>, which
                        is a ceiling on the value to which the soft limit may be adjusted. An
                        unprivileged process may change its soft limit for a particular resource to
                        any value in the range from zero up to the corresponding hard limit, but can
                        only lower its hard limit.<a id="IDX-CHP-2-0379" class="indexterm"/></p><p>When a new process is created with <span class="emphasis"><em>fork()</em></span>, it
                        inherits copies of its parent’s resource limit settings.</p><p>The resource limits of the shell can be adjusted using the
                            <span class="emphasis"><em>ulimit</em></span> command (<span class="emphasis"><em>limit</em></span> in the C
                        shell). These limit settings are inherited by the child processes that the
                        shell creates to execute commands.</p></div></div></div><div class="sect1" title="Memory Mappings"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="memory_mappings">Memory Mappings</h2></div></div></div><p>The <span class="emphasis"><em>mmap()</em></span> system call creates a new <span class="emphasis"><em>memory
                    mapping</em></span> in the calling process’s virtual address space.<a id="IDX-CHP-2-0380" class="indexterm"/><a id="IDX-CHP-2-0381" class="indexterm"/><a id="IDX-CHP-2-0382" class="indexterm"/></p><p>Mappings fall into two categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="emphasis"><em>file mapping</em></span> maps a region of a file into the
                        calling process’s virtual memory. Once mapped, the file’s contents can be
                        accessed by operations on the bytes in the corresponding memory region. The
                        pages of the mapping are automatically loaded from the file as
                            required.<a id="IDX-CHP-2-0383" class="indexterm"/></p></li><li class="listitem"><p>By contrast, an <span class="emphasis"><em>anonymous mapping</em></span> doesn’t have a
                        corresponding file. Instead, the pages of the mapping are initialized to
                            0.<a id="IDX-CHP-2-0384" class="indexterm"/></p></li></ul></div><p>The memory in one process’s mapping may be shared with mappings in other
                processes. This can occur either because two processes map the same region of a file
                or because a child process created by <span class="emphasis"><em>fork()</em></span> inherits a mapping
                from its parent.<a id="IDX-CHP-2-0385" class="indexterm"/></p><p>When two or more processes share the same pages, each process may see the changes
                made by other processes to the contents of the pages, depending on whether the
                mapping is created as private or shared. When a mapping is
                    <span class="emphasis"><em>private</em></span>, modifications to the contents of the mapping are
                not visible to other processes and are not carried through to the underlying file.
                When a mapping is <span class="emphasis"><em>shared</em></span>, modifications to the contents of the
                mapping are visible to other processes sharing the same mapping and are carried
                through to the underlying file.<a id="IDX-CHP-2-0386" class="indexterm"/></p><p>Memory mappings serve a variety of purposes, including initialization of a
                process’s text segment from the corresponding segment of an executable file,
                allocation of new (zero-filled) memory, file I/O (memory-mapped I/O), and
                interprocess communication (via a shared mapping).</p></div><div class="sect1" title="Static and Shared Libraries"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="static_and_shared_libraries">Static and Shared Libraries</h2></div></div></div><p>An <span class="emphasis"><em>object library</em></span> is a file containing the compiled object
                code for a (usually logically related) set of functions that may be called from
                application programs. Placing code for a set of functions in a single object library
                eases the tasks of program creation and maintenance. Modern UNIX systems provide two
                types of object libraries: <span class="emphasis"><em>static libraries</em></span> and
                    <span class="emphasis"><em>shared libraries</em></span>.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="static_libraries"/></div></div></div><div class="sect3" title="Static libraries"><div class="titlepage"><div><div><h4 class="title" id="static_libraries-id1">Static libraries</h4></div></div></div><p>Static libraries (sometimes also known as <span class="emphasis"><em>archives</em></span>)
                        were the only type of library on early UNIX systems. A static library is
                        essentially a structured bundle of compiled object modules. To use functions
                        from a static library, we specify that library in the link command used to
                        build a program. After resolving the various function references from the
                        main program to the modules in the static library, the linker extracts
                        copies of the required object modules from the library and copies these into
                        the resulting executable file. We say that such a program is
                            <span class="emphasis"><em>statically linked</em></span>.</p><p>The fact that each statically linked program includes its own copy of the
                        object modules required from the library creates a number of disadvantages.
                        One is that the duplication of object code in different executable files
                        wastes disk space. A corresponding waste of memory occurs when statically
                        linked programs using the same library function are executed at the same
                        time; each program requires its own copy of the function to reside in
                        memory. Additionally, if a library function requires modification, then,
                        after recompiling that function and adding it to the static library, all
                        applications that need to use the updated function must be relinked against
                        the library.</p></div><div class="sect3" title="Shared libraries"><div class="titlepage"><div><div><h4 class="title" id="shared_libraries">Shared libraries</h4></div></div></div><p>Shared libraries were designed to address the problems with static
                            libraries.<a id="IDX-CHP-2-0387" class="indexterm"/></p><p>If a program is linked against a shared library, then, instead of copying
                        object modules from the library into the executable, the linker just writes
                        a record into the executable to indicate that at run time the executable
                        needs to use that shared library. When the executable is loaded into memory
                        at run time, a program called the <span class="emphasis"><em>dynamic linker</em></span>
                        ensures that the shared libraries required by the executable are found and
                        loaded into memory, and performs run-time linking to resolve the function
                        calls in the executable to the corresponding definitions in the shared
                        libraries. At run time, only a single copy of the code of the shared library
                        needs to be resident in memory; all running programs can use that
                            copy.<a id="IDX-CHP-2-0388" class="indexterm"/></p><p>The fact that a shared library contains the sole compiled version of a
                        function saves disk space. It also greatly eases the job of ensuring that
                        programs employ the newest version of a function. Simply rebuilding the
                        shared library with the new function definition causes existing programs to
                        automatically use the new definition when they are next executed.</p></div></div></div><div class="sect1" title="Interprocess Communication and Synchronization"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="interprocess_communication_and_synchroni">Interprocess Communication and Synchronization</h2></div></div></div><p>A running Linux system consists of numerous processes, many of which operate
                independently of each other. Some processes, however, cooperate to achieve their
                intended purposes, and these processes need methods of communicating with one
                another and synchronizing their actions.</p><p>One way for processes to communicate is by reading and writing information in disk
                files. However, for many applications, this is too slow and inflexible. Therefore,
                Linux, like all modern UNIX implementations, provides a rich set of mechanisms for
                    <span class="emphasis"><em>interprocess communication</em></span> (IPC), including the
                following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>signals</em></span>, which are used to indicate that an event has
                        occurred;</p></li><li class="listitem"><p><span class="emphasis"><em>pipes</em></span> (familiar to shell users as the <code class="literal">|</code> operator) and <span class="emphasis"><em>FIFOs</em></span>,
                        which can be used to transfer data between processes;</p></li><li class="listitem"><p><span class="emphasis"><em>sockets</em></span>, which can be used to transfer data from one
                        process to another, either on the same host computer or on different hosts
                        connected by a network;</p></li><li class="listitem"><p><span class="emphasis"><em>file locking</em></span>, which allows a process to lock regions
                        of a file in order to prevent other processes from reading or updating the
                        file contents;</p></li><li class="listitem"><p><span class="emphasis"><em>message queues</em></span>, which are used to exchange messages
                        (packets of data) between processes;</p></li><li class="listitem"><p><span class="emphasis"><em>semaphores</em></span>, which are used to synchronize the actions
                        of processes; and</p></li><li class="listitem"><p><span class="emphasis"><em>shared memory</em></span>, which allows two or more processes to
                        share a piece of memory. When one process changes the contents of the shared
                        memory, all of the other processes can immediately see the changes.</p></li></ul></div><p>The wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping
                functionality, is in part due to their evolution under different variants of the
                UNIX system and the requirements of various standards. For example, FIFOs and UNIX
                domain sockets essentially perform the same function of allowing unrelated processes
                on the same system to exchange data. Both exist in modern UNIX systems because FIFOs
                came from System V, while sockets came from BSD.</p></div><div class="sect1" title="Signals"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="signals">Signals</h2></div></div></div><p>Although we listed them as a method of IPC in the previous section, signals are
                more usually employed in a wide range of other contexts, and so deserve a longer
                    discussion.<a id="IDX-CHP-2-0389" class="indexterm"/></p><p>Signals are often described as “software interrupts.” The arrival of a signal
                informs a process that some event or exceptional condition has occurred. There are
                various types of signals, each of which identifies a different event or condition.
                Each signal type is identified by a different integer, defined with symbolic names
                of the form <code class="literal">SIGxxxx</code>.<a id="IDX-CHP-2-0390" class="indexterm"/></p><p>Signals are sent to a process by the kernel, by another process (with suitable
                permissions), or by the process itself. For example, the kernel may send a signal to
                a process when one of the following occurs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>the user typed the <span class="emphasis"><em>interrupt</em></span> character (usually
                            <span class="emphasis"><em>Control-C</em></span>) on the keyboard;</p></li><li class="listitem"><p>one of the process’s children has terminated;</p></li><li class="listitem"><p>a timer (alarm clock) set by the process has expired; or</p></li><li class="listitem"><p>the process attempted to access an invalid memory address.</p></li></ul></div><p>Within the shell, the <span class="emphasis"><em>kill</em></span> command can be used to send a
                signal to a process. The <span class="emphasis"><em>kill()</em></span> system call provides the same
                facility within programs.</p><p>When a process receives a signal, it takes one of the following actions, depending
                on the signal:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>it ignores the signal;</p></li><li class="listitem"><p>it is killed by the signal; or</p></li><li class="listitem"><p>it is suspended until later being resumed by receipt of a special-purpose
                        signal.</p></li></ul></div><p>For most signal types, instead of accepting the default signal action, a program
                can choose to ignore the signal (useful if the default action for the signal is
                something other than being ignored), or to establish a <span class="emphasis"><em>signal
                    handler</em></span>. A signal handler is a programmer-defined function that is
                automatically invoked when the signal is delivered to the process. This function
                performs some action appropriate to the condition that generated the
                    signal.<a id="IDX-CHP-2-0391" class="indexterm"/></p><p>In the interval between the time it is generated and the time it is delivered, a
                signal is said to be <span class="emphasis"><em>pending</em></span> for a process. Normally, a pending
                signal is delivered as soon as the receiving process is next scheduled to run, or
                immediately if the process is already running. However, it is also possible to
                    <span class="emphasis"><em>block</em></span> a signal by adding it to the process’s
                    <span class="emphasis"><em>signal mask</em></span>. If a signal is generated while it is blocked,
                it remains pending until it is later unblocked (i.e., removed from the signal
                    mask).<a id="IDX-CHP-2-0392" class="indexterm"/><a id="IDX-CHP-2-0393" class="indexterm"/><a id="IDX-CHP-2-0394" class="indexterm"/><a id="IDX-CHP-2-0395" class="indexterm"/><a id="IDX-CHP-2-0396" class="indexterm"/></p></div><div class="sect1" title="Threads"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="threads">Threads</h2></div></div></div><p>In modern UNIX implementations, each process can have multiple
                    <span class="emphasis"><em>threads</em></span> of execution. One way of envisaging threads is as a
                set of processes that share the same virtual memory, as well as a range of other
                attributes. Each thread is executing the same program code and shares the same data
                area and heap. However, each thread has it own stack containing local variables and
                function call linkage information.<a id="IDX-CHP-2-0397" class="indexterm"/></p><p>Threads can communicate with each other via the global variables that they share.
                The threading API provides <span class="emphasis"><em>condition variables</em></span> and
                    <span class="emphasis"><em>mutexes</em></span>, which are primitives that enable the threads of a
                process to communicate and synchronize their actions, in particular, their use of
                shared variables. Threads can also communicate with one another using the IPC and
                synchronization mechanisms described in <a class="xref" href="ch02.html#interprocess_communication_and_synchroni" title="Interprocess Communication and Synchronization">Interprocess Communication and Synchronization</a>.</p><p>The primary advantages of using threads are that they make it easy to share data
                (via global variables) between cooperating threads and that some algorithms
                transpose more naturally to a multithreaded implementation than to a multiprocess
                implementation. Furthermore, a multithreaded application can transparently take
                advantage of the possibilities for parallel processing on multiprocessor
                hardware.</p></div><div class="sect1" title="Process Groups and Shell Job Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="process_groups_and_shell_job_control">Process Groups and Shell Job Control</h2></div></div></div><p>Each program executed by the shell is started in a new process. For example, the
                shell creates three processes to execute the following pipeline of commands (which
                displays a list of files in the current working directory sorted by file
                size):</p><a id="I_programlisting2_d1e4370"/><pre class="programlisting">$ ls -l | sort -k5n | less</pre><p>All major shells, except the Bourne shell, provide an interactive feature called
                    <span class="emphasis"><em>job control</em></span>, which allows the user to simultaneously
                execute and manipulate multiple commands or pipelines. In job-control shells, all of
                the processes in a pipeline are placed in a new <span class="emphasis"><em>process group</em></span>
                or <span class="emphasis"><em>job</em></span>. (In the simple case of a shell command line containing
                a single command, a new process group containing just a single process is created.)
                Each process in a process group has the same integer <span class="emphasis"><em>process group
                    identifier</em></span>, which is the same as the process ID of one of the
                processes in the group, termed the <span class="emphasis"><em>process group
                    leader</em></span>.<a id="IDX-CHP-2-0398" class="indexterm"/><a id="IDX-CHP-2-0399" class="indexterm"/><a id="IDX-CHP-2-0400" class="indexterm"/><a id="IDX-CHP-2-0401" class="indexterm"/></p><p>The kernel allows for various actions, notably the delivery of signals, to be
                performed on all members of a process group. Job-control shells use this feature to
                allow the user to suspend or resume all of the processes in a pipeline, as described
                in the next section.</p></div><div class="sect1" title="Sessions, Controlling Terminals, and Controlling Processes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sessions_comma_controlling_terminals_com">Sessions, Controlling Terminals, and Controlling Processes</h2></div></div></div><p>A <span class="emphasis"><em>session</em></span> is a collection of process groups (jobs). All of
                the processes in a session have the same <span class="emphasis"><em>session identifier</em></span>. A
                    <span class="emphasis"><em>session leader</em></span> is the process that created the session, and
                its process ID becomes the session ID.<a id="IDX-CHP-2-0402" class="indexterm"/><a id="IDX-CHP-2-0403" class="indexterm"/><a id="IDX-CHP-2-0404" class="indexterm"/><a id="IDX-CHP-2-0405" class="indexterm"/><a id="IDX-CHP-2-0406" class="indexterm"/></p><p>Sessions are used mainly by job-control shells. All of the process groups created
                by a job-control shell belong to the same session as the shell, which is the session
                leader.</p><p>Sessions usually have an associated <span class="emphasis"><em>controlling terminal</em></span>. The
                controlling terminal is established when the session leader process first opens a
                terminal device. For a session created by an interactive shell, this is the terminal
                at which the user logged in. A terminal may be the controlling terminal of at most
                one session.<a id="IDX-CHP-2-0407" class="indexterm"/></p><p>As a consequence of opening the controlling terminal, the session leader becomes
                the <span class="emphasis"><em>controlling process</em></span> for the terminal. The controlling
                process receives a <code class="literal">SIGHUP</code> signal if a terminal
                disconnect occurs (e.g., if the terminal window is closed).<a id="IDX-CHP-2-0408" class="indexterm"/><a id="IDX-CHP-2-0409" class="indexterm"/></p><p>At any point in time, one process group in a session is the <span class="emphasis"><em>foreground
                    process group</em></span> (<span class="emphasis"><em>foreground job</em></span>), which may read
                input from the terminal and send output to it. If the user types the
                    <span class="emphasis"><em>interrupt</em></span> character (usually
                <span class="emphasis"><em>Control-C</em></span>) or the <span class="emphasis"><em>suspend</em></span> character
                (usually <span class="emphasis"><em>Control-Z</em></span>) on the controlling terminal, then the
                terminal driver sends a signal that kills or suspends (i.e., stops) the foreground
                process group. A session can have any number of <span class="emphasis"><em>background process
                    groups</em></span> (<span class="emphasis"><em>background jobs</em></span>), which are created by
                terminating a command with the ampersand (<code class="literal">&amp;</code>) character.<a id="IDX-CHP-2-0410" class="indexterm"/></p><p>Job-control shells provide commands for listing all jobs, sending signals to jobs,
                and moving jobs between the foreground and background.</p></div><div class="sect1" title="Pseudoterminals"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="pseudoterminals">Pseudoterminals</h2></div></div></div><p>A <span class="emphasis"><em>pseudoterminal</em></span> is a pair of connected virtual devices,
                known as the <span class="emphasis"><em>master</em></span> and <span class="emphasis"><em>slave</em></span>. This device
                pair provides an IPC channel allowing data to be transferred in both directions
                between the two devices.<a id="IDX-CHP-2-0411" class="indexterm"/></p><p>The key point about a pseudoterminal is that the slave device provides an
                interface that behaves like a terminal, which makes it possible to connect a
                terminal-oriented program to the slave device and then use another program connected
                to the master device to drive the terminal-oriented program. Output written by the
                driver program undergoes the usual input processing performed by the terminal driver
                (for example, in the default mode, a carriage return is mapped to a newline) and is
                then passed as input to the terminal-oriented program connected to the slave.
                Anything that the terminal-oriented program writes to the slave is passed (after
                performing all of the usual terminal output processing) as input to the driver
                program. In other words, the driver program is performing the function normally
                performed by the user at a conventional terminal.</p><p>Pseudoterminals are used in a variety of applications, most notably in the
                implementation of terminal windows provided under an X Window System login and in
                applications providing network login services, such as <span class="emphasis"><em>telnet</em></span>
                and <span class="emphasis"><em>ssh</em></span>.</p></div><div class="sect1" title="Date and Time"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="date_and_time">Date and Time</h2></div></div></div><p>Two types of time are of interest to a process:<a id="IDX-CHP-2-0412" class="indexterm"/><a id="IDX-CHP-2-0413" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Real time</em></span> is measured either from some standard point
                            (<span class="emphasis"><em>calendar</em></span> time) or from some fixed point, typically
                        the start, in the life of a process (<span class="emphasis"><em>elapsed</em></span> or
                            <span class="emphasis"><em>wall clock</em></span> time). On UNIX systems, calendar time is
                        measured in seconds since midnight on the morning of January 1, 1970,
                        Universal Coordinated Time (usually abbreviated UTC), and coordinated on the
                        base point for timezones defined by the longitudinal line passing through
                        Greenwich, England. This date, which is close to the birth of the UNIX
                        system, is referred to as the <span class="emphasis"><em>Epoch</em></span>.<a id="IDX-CHP-2-0414" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Process time</em></span>, also called <span class="emphasis"><em>CPU
                            time</em></span>, is the total amount of CPU time that a process has used
                        since starting. CPU time is further divided into <span class="emphasis"><em>system CPU
                            time</em></span>, the time spent executing code in <span class="emphasis"><em>kernel
                            mode</em></span> (i.e., executing system calls and performing other
                        kernel services on behalf of the process), and <span class="emphasis"><em>user CPU
                            time</em></span>, the time spent executing code in <span class="emphasis"><em>user
                            mode</em></span> (i.e., executing normal program code).<a id="IDX-CHP-2-0415" class="indexterm"/><a id="IDX-CHP-2-0416" class="indexterm"/></p></li></ul></div><p>The <span class="emphasis"><em>time</em></span> command displays the real time, the system CPU time,
                and user CPU time taken to execute the processes in a pipeline.<a id="IDX-CHP-2-0417" class="indexterm"/></p></div><div class="sect1" title="Client-Server Architecture"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="client-server_architecture">Client-Server Architecture</h2></div></div></div><p>At various points in this book, we discuss the design and implementation of
                client-server applications.<a id="IDX-CHP-2-0418" class="indexterm"/><a id="IDX-CHP-2-0419" class="indexterm"/></p><p>A <span class="emphasis"><em>client-server application</em></span> is one that is broken into two
                component processes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>a <span class="emphasis"><em>client</em></span>, which asks the server to carry out some
                            <span class="emphasis"><em>service</em></span> by sending it a request message; and</p></li><li class="listitem"><p>a <span class="emphasis"><em>server</em></span>, which examines the client’s request,
                        performs appropriate actions, and then sends a response message back to the
                        client.</p></li></ul></div><p>Sometimes, the client and server may engage in an extended dialogue of requests
                and responses.</p><p>Typically, the client application interacts with a user, while the server
                application provides access to some shared resource. Commonly, there are multiple
                instances of client processes communicating with one or a few instances of the
                server process.</p><p>The client and server may reside on the same host computer or on separate hosts
                connected via a network. To communicate with one another, the client and server use
                the IPC mechanisms discussed in <a class="xref" href="ch02.html#interprocess_communication_and_synchroni" title="Interprocess Communication and Synchronization">Interprocess Communication and Synchronization</a>.</p><p>Servers may implement a variety of services, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>providing access to a database or other shared information
                        resource;</p></li><li class="listitem"><p>providing access to a remote file across a network;</p></li><li class="listitem"><p>encapsulating some business logic;</p></li><li class="listitem"><p>providing access to a shared hardware resource (e.g., a printer);
                        or</p></li><li class="listitem"><p>serving web pages.</p></li></ul></div><p>Encapsulating a service within a single server is useful for a number of reasons,
                such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Efficiency</em></span>: It may be cheaper to provide one instance
                        of a resource (e.g., a printer) that is managed by a server than to provide
                        the same resource locally on every computer.</p></li><li class="listitem"><p><span class="emphasis"><em>Control, coordination, and security</em></span>: By holding a
                        resource (especially an information resource) at a single location, the
                        server can coordinate access to the resource (e.g., so that two clients
                        don’t simultaneously update the same piece of information) or secure it so
                        that it is made available to only selected clients.</p></li><li class="listitem"><p><span class="emphasis"><em>Operation in a heterogeneous environment</em></span>: In a
                        network, the various clients, and the server, can be running on different
                        hardware and operating system platforms.</p></li></ul></div></div><div class="sect1" title="Realtime"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="realtime">Realtime</h2></div></div></div><p><span class="emphasis"><em>Realtime applications</em></span> are those that need to respond in a
                timely fashion to input. Frequently, such input comes from an external sensor or a
                specialized input device, and output takes the form of controlling some external
                hardware. Examples of applications with realtime response requirements include
                automated assembly lines, bank ATMs, and aircraft navigation systems.<a id="IDX-CHP-2-0420" class="indexterm"/></p><p>Although many realtime applications require rapid responses to input, the defining
                factor is that the response is guaranteed to be delivered within a certain deadline
                time after the triggering event.</p><p>The provision of realtime responsiveness, especially where short response times
                are demanded, requires support from the underlying operating system. Most operating
                systems don’t natively provide such support because the requirements of realtime
                responsiveness can conflict with the requirements of multiuser time-sharing
                operating systems. Traditional UNIX implementations are not realtime operating
                systems, although realtime variants have been devised. Realtime variants of Linux
                have also been created, and recent Linux kernels are moving toward full native
                support for realtime applications.</p><p>POSIX.1b defined a number of extensions to POSIX.1 for the support of realtime
                applications. These include asynchronous I/O, shared memory, memory-mapped files,
                memory locking, realtime clocks and timers, alternative scheduling policies,
                realtime signals, message queues, and semaphores. Even though they don’t strictly
                qualify as realtime, most UNIX implementations now support some or all of these
                extensions. (During the course of this book, we describe those features of POSIX.1b
                that are supported by Linux.)<a id="IDX-CHP-2-0421" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In this book, we use the term <span class="emphasis"><em>real time</em></span> to refer to the
                    concept of calendar or elapsed time, and the term <span class="emphasis"><em>realtime</em></span>
                    to denote an operating system or application providing the type of
                    responsiveness described in this section.</p></div></div><div class="sect1" title="The /proc File System"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_solidus_proc_file_system">The <code class="literal">/proc</code> File System</h2></div></div></div><p>Like several other UNIX implementations, Linux provides a <code class="literal">/proc</code> file system, which consists of a set of directories and files
                mounted under the <code class="literal">/proc</code> directory.<a id="IDX-CHP-2-0422" class="indexterm"/></p><p>The <code class="literal">/proc</code> file system is a virtual file system
                that provides an interface to kernel data structures in a form that looks like files
                and directories on a file system. This provides an easy mechanism for viewing and
                changing various system attributes. In addition, a set of directories with names of
                the form <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span>, where
                    <span class="emphasis"><em>PID</em></span> is a process ID, allows us to view information about
                each process running on the system.</p><p>The contents of <code class="literal">/proc</code> files are generally in
                human-readable text form and can be parsed by shell scripts. A program can simply
                open and read from, or write to, the desired file. In most cases, a process must be
                privileged to modify the contents of files in the <code class="literal">/proc</code> directory.</p><p>As we describe various parts of the Linux programming interface, we’ll also
                describe the relevant <code class="literal">/proc</code> files. <a class="xref" href="ch12.html#the_solidus_proc_file_system-id1" title="The /proc File System">The <code class="literal">/proc</code> File System</a> provides further general
                information on this file system. The <code class="literal">/proc</code> file
                system is not specified by any standards, and the details that we describe are
                Linux-specific.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id1">Summary</h2></div></div></div><p>In this chapter, we surveyed a range of fundamental concepts related to Linux
                system programming. An understanding of these concepts should provide readers with
                limited experience on Linux or UNIX with enough background to begin learning system
                programming.</p></div></section></body></html>
