<?xml version="1.0" encoding="utf-8"?><html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/"><head>
<meta name="dcterms.conformsTo" content="PXE Basic 1.0"></meta>
<meta name="generator" content="PXE Tools version 1.39.109"></meta>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.109, partial=false-->
<title>3.5 Connection-Oriented Transport: TCP</title><link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/sepia.css"></link><link rel="alternate stylesheet" type="text/css" title="night" href="../css/night.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/main.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/print.css"></link>
<script src="js/format_lg_obj.js"></script>
</head><body epub:type="bodymatter">
<section id="P7001011952000000000000000001442" class="level1"><header><h1 class="title" id="P700101195200000000000000000A33F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A33F" epub:type="title"><span class="pagebreak" title="233" id="P7001011952000000000000000001444" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001444" epub:type="pagebreak" role="doc-pagebreak"></span><span class="number">3.5</span> Connection-Oriented Transport: TCP</h1></header>
<p id="P700101195200000000000000000A340" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A340">Now that we have covered the underlying principles of reliable data transfer, let’s turn to TCP—the Internet’s transport-layer, connection-oriented, reliable transport protocol. In this section, we’ll see that in order to provide reliable data transfer, TCP relies on many of the underlying principles discussed in the previous section, including error detection, retransmissions, cumulative acknowledgments, timers, and header fields for sequence and acknowledgment numbers. TCP is defined in RFC 793, RFC 1122, RFC 1323, RFC 2018, and RFC 2581.</p>
<section id="P7001011952000000000000000001446" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001446" class="level2"><header><h1 class="title" id="P700101195200000000000000000A341" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A341" epub:type="title"><span class="number">3.5.1</span> The TCP Connection</h1></header>
<p id="P700101195200000000000000000A342" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A342">TCP is said to be <span class="keyword" id="P7001011952000000000000000001449" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001449"><b>connection-oriented</b></span> because before one application process can begin to send data to another, the two processes must first “handshake” with each other—that is, they must send some preliminary segments to each other to establish the parameters of the ensuing data transfer. As part of TCP connection establishment, both sides of the connection will initialize many TCP state variables (many of which will be discussed in this section and in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="label">Section</span> <span class="number">3.7</span></a>) associated with the TCP connection.</p>
<p id="P700101195200000000000000000A343" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A343">The TCP “connection” is not an end-to-end TDM or FDM circuit as in a circuit-switched network. Instead, the “connection” is a logical one, with common state residing only in the TCPs in the two communicating end systems. Recall that because the TCP protocol runs only in the end systems and not in the intermediate network elements (routers and link-layer switches), the intermediate network elements do not maintain TCP connection state. In fact, the intermediate routers are completely oblivious to TCP connections; they see datagrams, not connections.</p>
<p id="P700101195200000000000000000A344" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A344">A TCP connection provides a <span class="keyword" id="P700101195200000000000000000144C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000144C"><b>full-duplex service</b></span>: If there is a TCP connection between Process A on one host and Process B on another host, then application-layer data can flow from Process A to Process B at the same time as application-layer data flows from Process B to Process A. A TCP connection is also always <span class="keyword" id="P700101195200000000000000000144D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000144D"><b>point-to-point</b></span>, that is, between a single sender and a single receiver. So-called “multicasting” (see the online supplementary materials for this text)—the transfer of data from one sender to many receivers in a single send operation—is not possible with TCP. With TCP, two hosts are company and three are a crowd!</p>
<p id="P700101195200000000000000000A345" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A345">Let’s now take a look at how a TCP connection is established. Suppose a process running in one host wants to initiate a connection with another process in another host. Recall that the process that is initiating the connection is called the <i>client process</i>, while the other process is called the <i>server process</i>. The client application process first informs the client transport layer that it wants to establish a connection</p>
<aside class="sidebar" id="P700101195200000000000000000144F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000144F"><header><h1 class="title" id="P700101195200000000000000000A346" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A346" epub:type="title"><span class="pagebreak" title="234" id="P7001011952000000000000000001451" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001451" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">CASE HISTORY </span></h1></header>
<section id="P7001011952000000000000000001452" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001452"><header><h1 class="title" id="P700101195200000000000000000A347" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A347" epub:type="title">Vinton Cerf, Robert Kahn, and TCP/IP</h1></header>
<p id="P700101195200000000000000000A348" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A348">In the early 1970s, packet-switched networks began to proliferate, with the ARPAnet—the precursor of the Internet—being just one of many networks. Each of these networks had its own protocol. Two researchers, Vinton Cerf and Robert Kahn, recognized the importance of interconnecting these networks and invented a cross-network protocol called TCP/IP, which stands for Transmission Control Protocol/Internet Protocol. Although Cerf and Kahn began by seeing the protocol as a single entity, it was later split into its two parts, TCP and IP, which operated separately. Cerf and Kahn published a paper on TCP/IP in May 1974 in <i>IEEE Transactions on Communications Technology</i> <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003867" data-foobar="7">[Cerf 1974]</a>.</p>
<p id="P700101195200000000000000000A349" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A349">The TCP/IP protocol, which is the bread and butter of today’s Internet, was devised before PCs, workstations, smartphones, and tablets, before the proliferation of Ethernet, cable, and DSL, WiFi, and other access network technologies, and before the Web, social media, and streaming video. Cerf and Kahn saw the need for a networking protocol that, on the one hand, provides broad support for yet-to-be-defined applications and, on the other hand, allows arbitrary hosts and link-layer protocols to interoperate.</p>
<p id="P700101195200000000000000000A34A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A34A">In 2004, Cerf and Kahn received the ACM’s Turing Award, considered the “Nobel Prize of Computing” for “pioneering work on internetworking, including the design and implementation of the Internet’s basic communications protocols, TCP/IP, and for inspired leadership in networking.”</p>
</section>
</aside>
<p class="continued" id="P700101195200000000000000000A34B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A34B">to a process in the server. Recall from <a class="xref" href="fileP7001011952000000000000000000E42.xhtml#P7001011952000000000000000000ECB" data-foobar="7"><span class="label">Section</span> <span class="number">2.7.2</span></a>, a  Python client program does this by issuing the command</p>
<pre id="P700101195200000000000000000A34C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A34C"><code id="P700101195200000000000000000A34D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A34D">clientSocket.connect((serverName, serverPort))</code></pre>
<p id="P700101195200000000000000000A34E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A34E">where <code id="P700101195200000000000000000A34F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A34F">serverName</code> is the name of the server and <code id="P700101195200000000000000000A350" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A350">serverPort</code> identifies the process on the server. TCP in the client then proceeds to establish a TCP connection with TCP in the server. At the end of this section we discuss in some detail the connection-establishment procedure. For now it suffices to know that the client first sends a special TCP segment; the server responds with a second special TCP segment; and finally the client responds again with a third special segment. The first two segments carry no payload, that is, no application-layer data; the third of these segments may carry a payload. Because three segments are sent between the two hosts, this connection-establishment procedure is often referred to as a <span class="keyword" id="P700101195200000000000000000145D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000145D"><b>three-way handshake</b></span>.</p>
<p id="P700101195200000000000000000A351" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A351"><span class="pagebreak" title="235" id="P700101195200000000000000000145F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000145F" epub:type="pagebreak" role="doc-pagebreak"></span>Once a TCP connection is established, the two application processes can send data to each other. Let’s consider the sending of data from the client process to the server process. The client process passes a stream of data through the socket (the door of the process), as described in <a class="xref" href="fileP7001011952000000000000000000E42.xhtml#P7001011952000000000000000000E42" data-foobar="7"><span class="label">Section</span> <span class="number">2.7</span></a>. Once the data passes through the door, the data is in the hands of TCP running in the client. As shown in <a class="xref" href="#P7001011952000000000000000001465" data-foobar="1"><span class="label">Figure</span> <span class="number">3.28</span></a>, TCP directs this data to the connection’s <span class="keyword" id="P7001011952000000000000000001460" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001460"><b>send buffer</b></span>, which is one of the buffers that is set aside during the initial three-way handshake. From time to time, TCP will grab chunks of data from the send buffer and pass the data to the network layer. Interestingly, the TCP specification <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003AE0" data-foobar="7">[RFC 793]</a> is very laid back about specifying when TCP should actually send buffered data, stating that TCP should “send that data in segments at its own convenience.” The maximum amount of data that can be grabbed and placed in a segment is limited by the <span class="keyword" id="P7001011952000000000000000001461" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001461"><b>maximum segment size (MSS)</b></span>. The MSS is typically set by first determining the length of the largest link-layer frame that can be sent by the local sending host (the so-called <span class="keyword" id="P7001011952000000000000000001462" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001462"><b>maximum transmission unit, MTU</b></span>), and then setting the MSS to ensure that a TCP segment (when encapsulated in an IP datagram) plus the TCP/IP header length (typically 40 bytes) will fit into a single link-layer frame. Both Ethernet and PPP link-layer protocols have an MTU of 1,500 bytes. Thus a typical value of MSS is 1460 bytes. Approaches have also been proposed for discovering the path MTU—the largest link-layer frame that can be sent on all links from source to destination <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003AEF" data-foobar="7">[RFC 1191]</a>—and setting the MSS based on the path MTU value. Note that the MSS is the maximum amount of application-layer data in the segment, not the maximum size of the TCP segment including headers. (This terminology is confusing, but we have to live with it, as it is well entrenched.)</p>
<p id="P700101195200000000000000000A352" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A352">TCP pairs each chunk of client data with a TCP header, thereby forming <span class="keyword" id="P7001011952000000000000000001464" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001464"><b>TCP segments</b></span>. The segments are passed down to the network layer, where they are separately encapsulated within network-layer IP datagrams. The IP datagrams are then sent into the network. When TCP receives a segment at the other end, the segment’s data is placed in the TCP connection’s receive buffer, as shown in <a class="xref" href="#P7001011952000000000000000001465" data-foobar="1"><span class="label">Figure</span> <span class="number">3.28</span></a>. The application reads the stream of data from this buffer. Each side of the connection has</p>
<figure id="P7001011952000000000000000001465" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001465">
<img alt="Illustration of TCP send and receive buffers." height="250" width="622" aria-describedby="P7001011952000000000000000001469" id="P700101195200000000000000000A353" data-uri="P7001011952000000000000000005560" src="../images/4055103028.png"></img>
<figcaption id="P700101195200000000000000000A354" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A354"><header><h1 class="title" id="P700101195200000000000000000A355" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A355" epub:type="title"><span class="label">Figure </span><span class="number">3.28</span> TCP send and receive buffers</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001469" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001469" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103028.xhtml#la_4055103028"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A357" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A357"><span class="pagebreak" title="236" id="P700101195200000000000000000146C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000146C" epub:type="pagebreak" role="doc-pagebreak"></span>its own send buffer and its own receive buffer. (You can see the online flow-control applet at <span class="url-obsolete">http://www.awl.com/kurose-ross</span>, which provides an animation of the send and receive buffers.)</p>
<p id="P700101195200000000000000000A358" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A358">We see from this discussion that a TCP connection consists of buffers, variables, and a socket connection to a process in one host, and another set of buffers, variables, and a socket connection to a process in another host. As mentioned earlier, no buffers or variables are allocated to the connection in the network elements (routers, switches, and repeaters) between the hosts.</p>
</section>
<section id="P700101195200000000000000000146E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000146E" class="level2"><header><h1 class="title" id="P700101195200000000000000000A359" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A359" epub:type="title"><span class="number">3.5.2</span> TCP Segment Structure</h1></header>
<p id="P700101195200000000000000000A35A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A35A">Having taken a brief look at the TCP connection, let’s examine the TCP segment structure. The TCP segment consists of header fields and a data field. The data field contains a chunk of application data. As mentioned above, the MSS limits the maximum size of a segment’s data field. When TCP sends a large file, such as an image as part of a Web page, it typically breaks the file into chunks of size MSS (except for the last chunk, which will often be less than the MSS). Interactive applications, however, often transmit data chunks that are smaller than the MSS; for example, with remote login applications like Telnet, the data field in the TCP segment is often only one byte. Because the TCP header is typically 20 bytes (12 bytes more than the UDP header), segments sent by Telnet may be only 21 bytes in length.</p>
<p id="P700101195200000000000000000A35B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A35B"><a class="xref" href="#P7001011952000000000000000001488" data-foobar="1"><span class="label">Figure</span> <span class="number">3.29</span></a> shows the structure of the TCP segment. As with UDP, the header includes <span class="keyword" id="P7001011952000000000000000001472" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001472"><b>source and destination port numbers</b></span>, which are used for multiplexing/demultiplexing data from/to upper-layer applications. Also, as with UDP, the header includes a <span class="keyword" id="P7001011952000000000000000001473" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001473"><b>checksum field</b></span>. A TCP segment header also contains the following fields:</p>
<ul id="P700101195200000000000000000A35C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A35C">
<li id="P700101195200000000000000000A35D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A35D"><p id="P700101195200000000000000000A35E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A35E">The 32-bit <span class="keyword" id="P7001011952000000000000000001477" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001477"><b>sequence number field</b></span> and the 32-bit <span class="keyword" id="P7001011952000000000000000001478" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001478"><b>acknowledgment number field</b></span> are used by the TCP sender and receiver in implementing a reliable data transfer service, as discussed below.</p></li>
<li id="P700101195200000000000000000A35F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A35F"><p id="P700101195200000000000000000A360" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A360">The 16-bit <span class="keyword" id="P700101195200000000000000000147B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000147B"><b>receive window</b></span> field is used for flow control. We will see shortly that it is used to indicate the number of bytes that a receiver is willing to accept.</p></li>
<li id="P700101195200000000000000000A361" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A361"><p id="P700101195200000000000000000A362" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A362">The 4-bit <span class="keyword" id="P700101195200000000000000000147E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000147E"><b>header length field</b></span> specifies the length of the TCP header in 32-bit words. The TCP header can be of variable length due to the TCP options field. (Typically, the options field is empty, so that the length of the typical TCP header is 20 bytes.)</p></li>
<li id="P700101195200000000000000000A363" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A363"><p id="P700101195200000000000000000A364" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A364">The optional and variable-length <span class="keyword" id="P7001011952000000000000000001481" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001481"><b>options field</b></span> is used when a sender and receiver negotiate the maximum segment size (MSS) or as a window scaling factor for use in high-speed networks. A time-stamping option is also defined. See RFC 854 and RFC 1323 for additional details.</p></li>
<li id="P700101195200000000000000000A365" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A365"><p id="P700101195200000000000000000A366" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A366">The <span class="keyword" id="P7001011952000000000000000001484" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001484"><b>flag field</b></span> contains 6 bits. The <span class="keyword" id="P7001011952000000000000000001485" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001485"><b>ACK bit</b></span> is used to indicate that the value carried in the acknowledgment field is valid; that is, the segment contains an acknowledgment for a segment that has been successfully received. The <span class="keyword" id="P7001011952000000000000000001486" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001486"><b>RST</b></span>,<span class="pagebreak" title="237" id="P7001011952000000000000000001487" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001487" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001488" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001488">
<img alt="Illustration of TCP segment structure." height="469" width="583" aria-describedby="P700101195200000000000000000148C" id="P700101195200000000000000000A367" data-uri="P7001011952000000000000000005561" src="../images/4055103029.png"></img>
<figcaption id="P700101195200000000000000000A368" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A368"><header><h1 class="title" id="P700101195200000000000000000A369" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A369" epub:type="title"><span class="label">Figure </span><span class="number">3.29</span> TCP segment structure</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000148C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000148C" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103029.xhtml#la_4055103029"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A37F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A37F"><span class="keyword" id="P70010119520000000000000000014A3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014A3"><b>SYN</b></span>, and <span class="keyword" id="P70010119520000000000000000014A4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014A4"><b>FIN</b></span> bits are used for connection setup and teardown, as we will discuss at the end of this section. The CWR and ECE bits are used in explicit congestion notification, as discussed in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P7001011952000000000000000001762" data-foobar="7"><span class="label">Section</span> <span class="number">3.7.2</span></a>. Setting the <span class="keyword" id="P70010119520000000000000000014A5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014A5"><b>PSH</b></span> bit indicates that the receiver should pass the data to the upper layer immediately. Finally, the <span class="keyword" id="P70010119520000000000000000014A6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014A6"><b>URG</b></span> bit is used to indicate that there is data in this segment that the sending-side upper-layer entity has marked as “urgent.” The location of the last byte of this urgent data is indicated by the 16-bit <span class="keyword" id="P70010119520000000000000000014A7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014A7"><b>urgent data pointer field</b></span>. TCP must inform the receiving-side upper-layer entity when urgent data exists and pass it a pointer to the end of the urgent data. (In practice, the PSH, URG, and the urgent data pointer are not used. However, we mention these fields for completeness.)</p></li>
</ul>
<p id="P700101195200000000000000000A380" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A380">Our experience as teachers is that our students sometimes find discussion of packet formats rather dry and perhaps a bit boring. For a fun and fanciful look at TCP header fields, particularly if you love Legos™ as we do, see <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003AB9" data-foobar="7">[Pomeranz 2010]</a>.</p>
<section id="P70010119520000000000000000014A9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014A9" class="level3"><header><h1 class="title" id="P700101195200000000000000000A381" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A381" epub:type="title">Sequence Numbers and Acknowledgment Numbers</h1></header>
<p id="P700101195200000000000000000A382" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A382">Two of the most important fields in the TCP segment header are the sequence number field and the acknowledgment number field. These fields are a critical part of TCP’s reliable data transfer service. But before discussing how these fields are used to provide reliable data transfer, let us first explain what exactly TCP puts in these fields.<span class="pagebreak" title="238" id="P70010119520000000000000000014AC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014AC" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000014AD" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014AD">
<img alt="Illustration of a data file divided into TCP segments" height="177" width="674" aria-describedby="P70010119520000000000000000014B1" id="P700101195200000000000000000A383" data-uri="P7001011952000000000000000005562" src="../images/4055103030.png"></img>
<figcaption id="P700101195200000000000000000A384" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A384"><header><h1 class="title" id="P700101195200000000000000000A385" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A385" epub:type="title"><span class="label">Figure </span><span class="number">3.30</span> Dividing file data into TCP segments</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000014B1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014B1" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103030.xhtml#la_4055103030"><span class="label">Description</span></a></div>
<p id="P700101195200000000000000000A38D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A38D">TCP views data as an unstructured, but ordered, stream of bytes. TCP’s use of sequence numbers reflects this view in that sequence numbers are over the stream of transmitted bytes and <i>not</i> over the series of transmitted segments. The <span class="keyword" id="P70010119520000000000000000014BA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014BA"><b>sequence number for a segment</b></span> is therefore the byte-stream number of the first byte in the segment. Let’s look at an example. Suppose that a process in Host A wants to send a stream of data to a process in Host B over a TCP connection. The TCP in Host A will implicitly number each byte in the data stream. Suppose that the data stream consists of a file consisting of 500,000 bytes, that the MSS is 1,000 bytes, and that the first byte of the data stream is numbered 0. As shown in <a class="xref" href="#P70010119520000000000000000014AD" data-foobar="1"><span class="label">Figure</span> <span class="number">3.30</span></a>, TCP constructs 500 segments out of the data stream. The first segment gets assigned sequence number 0, the second segment gets assigned sequence number 1,000, the third segment gets assigned sequence number 2,000, and so on. Each sequence number is inserted in the sequence number field in the header of the appropriate TCP segment.</p>
<p id="P700101195200000000000000000A38E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A38E">Now let’s consider acknowledgment numbers. These are a little trickier than sequence numbers. Recall that TCP is full-duplex, so that Host A may be receiving data from Host B while it sends data to Host B (as part of the same TCP connection). Each of the segments that arrive from Host B has a sequence number for the data flowing from B to A. <i>The acknowledgment number that Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B.</i> It is good to look at a few examples to understand what is going on here. Suppose that Host A has received all bytes numbered 0 through 535 from B and suppose that it is about to send a segment to Host B. Host A is waiting for byte 536 and all the subsequent bytes in Host B’s data stream. So Host A puts 536 in the acknowledgment number field of the segment it sends to B.</p>
<p id="P700101195200000000000000000A38F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A38F">As another example, suppose that Host A has received one segment from Host B containing bytes 0 through 535 and another segment containing bytes 900 through 1,000. For some reason Host A has not yet received bytes 536 through 899. In this example, Host A is still waiting for byte 536 (and beyond) in order to re-create B’s data stream. Thus, A’s next segment to B will contain 536 in the acknowledgment number field. Because TCP only acknowledges bytes up to the first missing byte in the stream, TCP is said to provide <span class="keyword" id="P70010119520000000000000000014BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014BD"><b>cumulative acknowledgments</b></span>.</p>
<p id="P700101195200000000000000000A390" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A390"><span class="pagebreak" title="239" id="P70010119520000000000000000014BF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014BF" epub:type="pagebreak" role="doc-pagebreak"></span>This last example also brings up an important but subtle issue. Host A received the third segment (bytes 900 through 1,000) before receiving the second segment (bytes 536 through 899). Thus, the third segment arrived out of order. The subtle issue is: What does a host do when it receives out-of-order segments in a TCP connection? Interestingly, the TCP RFCs do not impose any rules here and leave the decision up to the programmers implementing a TCP implementation. There are basically two choices: either (1) the receiver immediately discards out-of-order segments (which, as we discussed earlier, can simplify receiver design), or (2) the receiver keeps the out-of-order bytes and waits for the missing bytes to fill in the gaps. Clearly, the latter choice is more efficient in terms of network bandwidth, and is the approach taken in practice.</p>
<p id="P700101195200000000000000000A391" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A391">In <a class="xref" href="#P70010119520000000000000000014AD" data-foobar="1"><span class="label">Figure</span> <span class="number">3.30</span></a>, we assumed that the initial sequence number was zero. In truth, both sides of a TCP connection randomly choose an initial sequence number. This is done to minimize the possibility that a segment that is still present in the network from an earlier, already-terminated connection between two hosts is mistaken for a valid segment in a later connection between these same two hosts (which also happen to be using the same port numbers as the old connection) <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C3D" data-foobar="7">[Sunshine 1978]</a>.</p>
</section>
<section id="P70010119520000000000000000014C1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014C1" class="level3"><header><h1 class="title" id="P700101195200000000000000000A392" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A392" epub:type="title">Telnet: A Case Study for Sequence and Acknowledgment Numbers</h1></header>
<p id="P700101195200000000000000000A393" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A393">Telnet, defined in RFC 854, is a popular application-layer protocol used for remote login. It runs over TCP and is designed to work between any pair of hosts. Unlike the bulk data transfer applications discussed in <a class="xref" href="fileP700101195200000000000000000096B.xhtml#P700101195200000000000000000096B" data-foobar="7"><span class="label">Chapter</span> <span class="number">2</span></a>, Telnet is an interactive application. We discuss a Telnet example here, as it nicely illustrates TCP sequence and acknowledgment numbers. We note that many users now prefer to use the SSH protocol rather than Telnet, since data sent in a Telnet connection (including passwords!) are not encrypted, making Telnet vulnerable to eavesdropping attacks (as discussed in <a class="xref" href="fileP700101195200000000000000000305F.xhtml#P700101195200000000000000000305F" data-foobar="7"><span class="label">Section</span> <span class="number">8.7</span></a>).</p>
<p id="P700101195200000000000000000A394" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A394">Suppose Host A initiates a Telnet session with Host B. Because Host A initiates the session, it is labeled the client, and Host B is labeled the server. Each character typed by the user (at the client) will be sent to the remote host; the remote host will send back a copy of each character, which will be displayed on the Telnet user’s screen. This “echo back” is used to ensure that characters seen by the Telnet user have already been received and processed at the remote site. Each character thus traverses the network twice between the time the user hits the key and the time the character is displayed on the user’s monitor.</p>
<p id="P700101195200000000000000000A395" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A395">Now suppose the user types a single letter, ‘C,’ and then grabs a coffee. Let’s examine the TCP segments that are sent between the client and server. As shown in <a class="xref" href="#P70010119520000000000000000014C7" data-foobar="1"><span class="label">Figure</span> <span class="number">3.31</span></a>, we suppose the starting sequence numbers are 42 and 79 for the client and server, respectively. Recall that the sequence number of a segment is the sequence number of the first byte in the data field. Thus, the first segment sent from the client will have sequence number 42; the first segment sent from the server will have sequence number 79. Recall that the acknowledgment number is the sequence<span class="pagebreak" title="240" id="P70010119520000000000000000014C6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014C6" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000014C7" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014C7">
<img alt="Illustration of sequence and acknowledgment numbers for a simple Telnet application over TCP." height="514" width="544" aria-describedby="P70010119520000000000000000014CB" id="P700101195200000000000000000A396" data-uri="P7001011952000000000000000005563" src="../images/4055103031.png"></img>
<figcaption id="P700101195200000000000000000A397" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A397"><header><h1 class="title" id="P700101195200000000000000000A398" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A398" epub:type="title"><span class="label">Figure </span><span class="number">3.31</span> Sequence and acknowledgment numbers for a simple Telnet application over TCP</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000014CB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014CB" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103031.xhtml#la_4055103031"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A39B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A39B">number of the next byte of data that the host is waiting for. After the TCP connection is established but before any data is sent, the client is waiting for byte 79 and the server is waiting for byte 42.</p>
<p id="P700101195200000000000000000A39C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A39C">As shown in <a class="xref" href="#P70010119520000000000000000014C7" data-foobar="1"><span class="label">Figure</span> <span class="number">3.31</span></a>, three segments are sent. The first segment is sent from the client to the server, containing the 1-byte ASCII representation of the letter ‘C’ in its data field. This first segment also has 42 in its sequence number field, as we just described. Also, because the client has not yet received any data from the server, this first segment will have 79 in its acknowledgment number field.</p>
<p id="P700101195200000000000000000A39D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A39D">The second segment is sent from the server to the client. It serves a dual purpose. First it provides an acknowledgment of the data the server has received. By putting 43 in the acknowledgment field, the server is telling the client that it has successfully received everything up through byte 42 and is now waiting for bytes 43 onward. The second purpose of this segment is to echo back the letter ‘C.’ Thus, the second segment has the ASCII representation of ‘C’ in its data field. This second segment has the sequence number 79, the initial sequence number of the server-to-client data flow of this TCP connection, as this is the very first byte of data that the server is sending. Note that the acknowledgment for client-to-server data is carried in a segment <span class="pagebreak" title="241" id="P70010119520000000000000000014D1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014D1" epub:type="pagebreak" role="doc-pagebreak"></span>carrying server-to-client data; this acknowledgment is said to be <span class="keyword" id="P70010119520000000000000000014D2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014D2"><b>piggybacked</b></span> on the server-to-client data segment.</p>
<p id="P700101195200000000000000000A39E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A39E">The third segment is sent from the client to the server. Its sole purpose is to acknowledge the data it has received from the server. (Recall that the second segment contained data—the letter ‘C’—from the server to the client.) This segment has an empty data field (that is, the acknowledgment is not being piggybacked with any client-to-server data). The segment has 80 in the acknowledgment number field because the client has received the stream of bytes up through byte sequence number 79 and it is now waiting for bytes 80 onward. You might think it odd that this segment also has a sequence number since the segment contains no data. But because TCP has a sequence number field, the segment needs to have some sequence number.</p>
</section>
</section>
<section id="P70010119520000000000000000014D4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014D4" class="level2"><header><h1 class="title" id="P700101195200000000000000000A39F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A39F" epub:type="title"><span class="number">3.5.3</span> Round-Trip Time Estimation and Timeout</h1></header>
<p id="P700101195200000000000000000A3A0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A0">TCP, like our <code id="P700101195200000000000000000A3A1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A1"><b>rdt</b></code> protocol in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P700101195200000000000000000120D" data-foobar="7"><span class="label">Section</span> <span class="number">3.4</span></a>, uses a timeout/retransmit mechanism to recover from lost segments. Although this is conceptually simple, many subtle issues arise when we implement a timeout/retransmit mechanism in an actual protocol such as TCP. Perhaps the most obvious question is the length of the timeout intervals. Clearly, the timeout should be larger than the connection’s round-trip time (RTT), that is, the time from when a segment is sent until it is acknowledged. Otherwise, unnecessary retransmissions would be sent. But how much larger? How should the RTT be estimated in the first place? Should a timer be associated with each and every unacknowledged segment? So many questions! Our discussion in this section is based on the TCP work in <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P70010119520000000000000000039B2" data-foobar="7">[Jacobson 1988]</a> and the current IETF recommendations for managing TCP timers <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BC1" data-foobar="7">[RFC 6298]</a>.</p>
<section id="P70010119520000000000000000014D8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014D8" class="level3"><header><h1 class="title" id="P700101195200000000000000000A3A2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A2" epub:type="title">Estimating the Round-Trip Time</h1></header>
<p id="P700101195200000000000000000A3A3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A3">Let’s begin our study of TCP timer management by considering how TCP estimates the round-trip time between sender and receiver. This is accomplished as follows. The sample RTT, denoted <code id="P700101195200000000000000000A3A4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A4">SampleRTT</code>, for a segment is the amount of time between when the segment is sent (that is, passed to IP) and when an acknowledgment for the segment is received. Instead of measuring a <code id="P700101195200000000000000000A3A5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A5">SampleRTT</code> for every transmitted segment, most TCP implementations take only one <code id="P700101195200000000000000000A3A6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A6">SampleRTT</code> measurement at a time. That is, at any point in time, the <code id="P700101195200000000000000000A3A7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A7">SampleRTT</code> is being estimated for only one of the transmitted but currently unacknowledged segments, leading to a new value of <code id="P700101195200000000000000000A3A8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A8">SampleRTT</code> approximately once every RTT. Also, TCP never computes a <code id="P700101195200000000000000000A3A9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3A9">SampleRTT</code> for a segment that has been retransmitted; it only measures <code id="P700101195200000000000000000A3AA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3AA">SampleRTT</code> for segments that have been transmitted once <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P70010119520000000000000000039D5" data-foobar="7">[Karn 1987]</a>. (A problem at the end of the chapter asks you to consider why.)</p>
<p id="P700101195200000000000000000A3AB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3AB">Obviously, the <code id="P700101195200000000000000000A3AC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3AC">SampleRTT</code> values will fluctuate from segment to segment due to congestion in the routers and to the varying load on the end systems. Because of this fluctuation, any given <code id="P700101195200000000000000000A3AD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3AD">SampleRTT</code> value may be atypical. In order to estimate <span class="pagebreak" title="242" id="P70010119520000000000000000014E5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014E5" epub:type="pagebreak" role="doc-pagebreak"></span>a typical RTT, it is therefore natural to take some sort of average of the <code id="P700101195200000000000000000A3AE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3AE">SampleRTT</code> values. TCP maintains an average, called <code id="P700101195200000000000000000A3AF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3AF">EstimatedRTT</code>, of the <code id="P700101195200000000000000000A3B0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B0">SampleRTT</code> values. Upon obtaining a new <code id="P700101195200000000000000000A3B1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B1">SampleRTT</code>, TCP updates <code id="P700101195200000000000000000A3B2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B2">EstimatedRTT</code> according to the following formula:</p>
<pre id="P700101195200000000000000000A3B3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B3"><code id="P700101195200000000000000000A3B4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B4"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="534" altimg-height="16" altimg="../images/ch03math19.png"><m:mrow><m:mtext>EstimatedRTT</m:mtext><m:mo>=</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:mn>1</m:mn><m:mo>−</m:mo><m:mi>α</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>⋅</m:mo><m:mtext>EstimatedRTT</m:mtext><m:mo>+</m:mo><m:mi>α</m:mi><m:mo>⋅</m:mo><m:mtext>SampleRTT</m:mtext></m:mrow></m:math></span></code></pre>
<p id="P700101195200000000000000000A3B5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B5">The formula above is written in the form of a programming-language statement—the new value of <b>EstimatedRTT</b> is a weighted combination of the previous value of <b>EstimatedRTT</b> and the new value for <b>SampleRTT</b>. The recommended value of α is α = 0.125 (that is, 1/8) <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BC1" data-foobar="7">[RFC 6298]</a>, in which case the formula above becomes:</p>
<pre id="P700101195200000000000000000A3B6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B6"><code id="P700101195200000000000000000A3B7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B7"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="569" altimg-height="16" altimg="../images/ch03math20.png"><m:mrow><m:mtext>EstimatedRTT</m:mtext><m:mo>=</m:mo><m:mn>0.875</m:mn><m:mo>⋅</m:mo><m:mtext>EstimatedRTT</m:mtext><m:mo>+</m:mo><m:mn>0.125</m:mn><m:mo>⋅</m:mo><m:mtext>SampleRTT</m:mtext></m:mrow></m:math></span></code></pre>
<p id="P700101195200000000000000000A3B8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B8">Note that <b>EstimatedRTT</b> is a weighted average of the <b>SampleRTT</b> values. As discussed in a homework problem at the end of this chapter, this weighted average puts more weight on recent samples than on old samples. This is natural, as the more recent samples better reflect the current congestion in the network. In statistics, such an average is called an <span class="keyword" id="P70010119520000000000000000014F1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000014F1"><b>exponential weighted moving average (EWMA)</b></span>. The word “exponential” appears in EWMA because the weight of a given <code id="P700101195200000000000000000A3B9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3B9">SampleRTT</code> decays exponentially fast as the updates proceed. In the homework problems you will be asked to derive the exponential term in <code id="P700101195200000000000000000A3BA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3BA">EstimatedRTT</code>.</p>
<p id="P700101195200000000000000000A3BB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3BB"><a class="xref" href="#P7001011952000000000000000001521" data-foobar="1"><span class="label">Figure</span> <span class="number">3.32</span></a> shows the <code id="P700101195200000000000000000A3BC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3BC">SampleRTT</code> values and <code id="P700101195200000000000000000A3BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3BD">EstimatedRTT</code> for a value of α = 1/8 for a TCP connection between <code id="P700101195200000000000000000A3BE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3BE">gaia.cs.umass.edu</code> (in Amherst, Massachusetts) to <code id="P700101195200000000000000000A3BF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3BF">fantasia.eurecom.fr</code> (in the south of France). Clearly, the variations in the <code id="P700101195200000000000000000A3C0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C0">SampleRTT</code> are smoothed out in the computation of the <code id="P700101195200000000000000000A3C1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C1">EstimatedRTT</code>.</p>
<p id="P700101195200000000000000000A3C2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C2">In addition to having an estimate of the RTT, it is also valuable to have a measure of the variability of the RTT. <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BC1" data-foobar="7">[RFC 6298]</a> defines the RTT variation, <code id="P700101195200000000000000000A3C3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C3">DevRTT</code>, as an estimate of how much <code id="P700101195200000000000000000A3C4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C4">SampleRTT</code> typically deviates from <code id="P700101195200000000000000000A3C5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C5">EstimatedRTT</code>:</p>
<pre id="P700101195200000000000000000A3C6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C6"><code id="P700101195200000000000000000A3C7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C7"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="584" altimg-height="17" altimg="../images/ch03math21.png"><m:mrow><m:mtext>DevRTT</m:mtext><m:mo>=</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:mn>1</m:mn><m:mo>−</m:mo><m:mi>β</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>⋅</m:mo><m:mtext>DevRTT</m:mtext><m:mo>+</m:mo><m:mi>β</m:mi><m:mo>⋅</m:mo><m:mo>|</m:mo><m:mtext>SampleRTT</m:mtext><m:mo>−</m:mo><m:mtext>EstimatedRTT</m:mtext><m:mo>|</m:mo></m:mrow></m:math></span></code></pre>
<p id="P700101195200000000000000000A3C8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C8">Note that <code id="P700101195200000000000000000A3C9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3C9">DevRTT</code> is an EWMA of the difference between <code id="P700101195200000000000000000A3CA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3CA">SampleRTT</code> and <code id="P700101195200000000000000000A3CB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3CB">EstimatedRTT</code>. If the <code id="P700101195200000000000000000A3CC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3CC">SampleRTT</code> values have little fluctuation, then <code id="P700101195200000000000000000A3CD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3CD">DevRTT</code> will be small; on the other hand, if there is a lot of fluctuation, <code id="P700101195200000000000000000A3CE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3CE">DevRTT</code> will be large. The recommended value of β is 0.25.</p>
</section>
<section id="P7001011952000000000000000001508" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001508" class="level3"><header><h1 class="title" id="P700101195200000000000000000A3CF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3CF" epub:type="title">Setting and Managing the Retransmission Timeout Interval</h1></header>
<p id="P700101195200000000000000000A3D0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D0">Given values of <code id="P700101195200000000000000000A3D1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D1">EstimatedRTT</code> and <code id="P700101195200000000000000000A3D2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D2">DevRTT</code>, what value should be used for TCP’s timeout interval? Clearly, the interval should be greater than or equal to</p>
<aside class="sidebar" id="P700101195200000000000000000150D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000150D"><header><h1 class="title" id="P700101195200000000000000000A3D3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D3" epub:type="title"><span class="pagebreak" title="243" id="P700101195200000000000000000150F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000150F" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">PRINCIPLES IN PRACTICE </span></h1></header>
<p id="P700101195200000000000000000A3D4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D4">TCP provides reliable data transfer by using positive acknowledgments and timers in much the same way that we studied in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P700101195200000000000000000120D" data-foobar="7"><span class="label">Section</span> <span class="number">3.4</span></a>. TCP acknowledges data that has been received correctly, and it then retransmits segments when segments or their corresponding acknowledgments are thought to be lost or corrupted. Certain versions of TCP also have an implicit NAK mechanism—with TCP’s fast retransmit mechanism, the receipt of three duplicate ACKs for a given segment serves as an implicit NAK for the following segment, triggering retransmission of that segment before timeout. TCP uses sequences of numbers to allow the receiver to identify lost or duplicate segments. Just as in the case of our reliable data transfer protocol, <code id="P700101195200000000000000000A3D5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D5"><b>rdt3.0</b></code>, TCP cannot itself tell for certain if a segment, or its ACK, is lost, corrupted, or overly delayed. At the sender, TCP’s response will be the same: retransmit the segment in question.</p>
<p id="P700101195200000000000000000A3D6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D6">TCP also uses pipelining, allowing the sender to have multiple transmitted but yet-to-be-acknowledged segments outstanding at any given time. We saw earlier that pipelining can greatly improve a session’s throughput when the ratio of the segment size to round-trip delay is small. The specific number of outstanding, unacknowledged segments that a sender can have is determined by TCP’s flow-control and congestion-control mechanisms. TCP flow control is discussed at the end of this section; TCP congestion control is discussed in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="label">Section</span> <span class="number">3.7</span></a>. For the time being, we must simply be aware that the TCP sender uses pipelining.</p>
</aside>
<p class="continued" id="P700101195200000000000000000A3D7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D7"><code id="P700101195200000000000000000A3D8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D8">EstimatedRTT</code>, or unnecessary retransmissions would be sent. But the timeout interval should not be too much larger than <code id="P700101195200000000000000000A3D9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3D9">EstimatedRTT</code>; otherwise, when a segment is lost, TCP would not quickly retransmit the segment, leading to large data transfer delays. It is therefore desirable to set the timeout equal to the <code id="P700101195200000000000000000A3DA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3DA">EstimatedRTT</code> plus some margin. The margin should be large when there is a lot of fluctuation in the <code id="P700101195200000000000000000A3DB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3DB">SampleRTT</code> values; it should be small when there is little fluctuation. The value of <code id="P700101195200000000000000000A3DC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3DC">DevRTT</code> should thus come into play here. All of these considerations are taken into account in TCP’s method for determining the retransmission timeout interval:</p>
<pre id="P700101195200000000000000000A3DD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3DD"><code id="P700101195200000000000000000A3DE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3DE"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="449" altimg-height="12" altimg="../images/ch03math22.png"><m:mrow><m:mtext>TimeoutInterval</m:mtext><m:mo>=</m:mo><m:mtext>EstimatedRTT</m:mtext><m:mo>+</m:mo><m:mn>4</m:mn><m:mo>⋅</m:mo><m:mtext>DevRTT</m:mtext></m:mrow></m:math></span></code></pre>
<p id="P700101195200000000000000000A3DF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3DF">An initial <code id="P700101195200000000000000000A3E0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3E0">TimeoutInterval</code> value of 1 second is recommended <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BC1" data-foobar="7">[RFC 6298]</a>. Also, when a timeout occurs, the value of <code id="P700101195200000000000000000A3E1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3E1">TimeoutInterval</code> is doubled to avoid a premature timeout occurring for a subsequent segment that will soon be acknowledged. However, as soon as a segment is received and <code id="P700101195200000000000000000A3E2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3E2">EstimatedRTT</code> is updated, the <code id="P700101195200000000000000000A3E3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3E3">TimeoutInterval</code> is again computed using the formula above.<span class="pagebreak" title="244" id="P7001011952000000000000000001520" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001520" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001521" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001521">
<img alt="Illustration of RTT samples and RTT estimates." height="466" width="787" aria-describedby="P7001011952000000000000000001525" id="P700101195200000000000000000A3E4" data-uri="P7001011952000000000000000005564" src="../images/4055103032.png"></img>
<figcaption id="P700101195200000000000000000A3E5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3E5"><header><h1 class="title" id="P700101195200000000000000000A3E6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3E6" epub:type="title"><span class="label">Figure </span><span class="number">3.32</span> RTT samples and RTT estimates</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001525" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001525" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103032.xhtml#la_4055103032"><span class="label">Description</span></a></div>
</section>
</section>
<section id="P700101195200000000000000000152A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000152A" class="level2"><header><h1 class="title" id="P700101195200000000000000000A3EB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3EB" epub:type="title"><span class="number">3.5.4</span> Reliable Data Transfer</h1></header>
<p id="P700101195200000000000000000A3EC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3EC">Recall that the Internet’s network-layer service (IP service) is unreliable. IP does not guarantee datagram delivery, does not guarantee in-order delivery of datagrams, and does not guarantee the integrity of the data in the datagrams. With IP service, datagrams can overflow router buffers and never reach their destination, datagrams can arrive out of order, and bits in the datagram can get corrupted (flipped from 0 to 1 and vice versa). Because transport-layer segments are carried across the network by IP datagrams, transport-layer segments can suffer from these problems as well.</p>
<p id="P700101195200000000000000000A3ED" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3ED">TCP creates a <span class="keyword" id="P700101195200000000000000000152E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000152E"><b>reliable data transfer service</b></span> on top of IP’s unreliable best-effort service. TCP’s reliable data transfer service ensures that the data stream that a process reads out of its TCP receive buffer is uncorrupted, without gaps, without duplication, and in sequence; that is, the byte stream is exactly the same byte stream that was sent by the end system on the other side of the connection. How TCP provides a reliable data transfer involves many of the principles that we studied in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P700101195200000000000000000120D" data-foobar="7"><span class="label">Section</span> <span class="number">3.4</span></a>.</p>
<p id="P700101195200000000000000000A3EE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3EE">In our earlier development of reliable data transfer techniques, it was conceptually easiest to assume that an individual timer is associated with each transmitted but not yet acknowledged segment. While this is great in theory, timer management can require considerable overhead. Thus, the recommended TCP timer management <span class="pagebreak" title="245" id="P7001011952000000000000000001530" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001530" epub:type="pagebreak" role="doc-pagebreak"></span>procedures <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BC1" data-foobar="7">[RFC 6298]</a> use only a <i>single</i> retransmission timer, even if there are multiple transmitted but not yet acknowledged segments. The TCP protocol described in this section follows this single-timer recommendation.</p>
<p id="P700101195200000000000000000A3EF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3EF">We will discuss how TCP provides reliable data transfer in two incremental steps. We first present a highly simplified description of a TCP sender that uses only timeouts to recover from lost segments; we then present a more complete description that uses duplicate acknowledgments in addition to timeouts. In the ensuing discussion, we suppose that data is being sent in only one direction, from Host A to Host B, and that Host A is sending a large file.</p>
<p id="P700101195200000000000000000A3F0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F0"><a class="xref" href="#P7001011952000000000000000001533" data-foobar="1"><span class="label">Figure</span> <span class="number">3.33</span></a> presents a highly simplified description of a TCP sender. We see that there are three major events related to data transmission and retransmission in the TCP sender: data received from application above; timer timeout; and ACK</p>
<figure id="P7001011952000000000000000001533" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001533">
<img alt="" height="635" width="817" id="P700101195200000000000000000A3F1" data-uri="P7001011952000000000000000005565" src="../images/4055103033.png"></img>
<figcaption id="P700101195200000000000000000A3F2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F2"><header><h1 class="title" id="P700101195200000000000000000A3F3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F3" epub:type="title"><span class="label">Figure </span><span class="number">3.33</span> Simplified TCP sender</h1></header>
</figcaption>
</figure>
<p class="continued" id="P700101195200000000000000000A3F4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F4"><span class="pagebreak" title="246" id="P7001011952000000000000000001538" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001538" epub:type="pagebreak" role="doc-pagebreak"></span>receipt. Upon the occurrence of the first major event, TCP receives data from the application, encapsulates the data in a segment, and passes the segment to IP. Note that each segment includes a sequence number that is the byte-stream number of the first data byte in the segment, as described in <a class="xref" href="#P700101195200000000000000000146E" data-foobar="1"><span class="label">Section</span> <span class="number">3.5.2</span></a>. Also note that if the timer is already not running for some other segment, TCP starts the timer when the segment is passed to IP. (It is helpful to think of the timer as being associated with the oldest unacknowledged segment.) The expiration interval for this timer is the <code id="P700101195200000000000000000A3F5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F5">TimeoutInterval</code>, which is calculated from <code id="P700101195200000000000000000A3F6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F6">EstimatedRTT</code> and <code id="P700101195200000000000000000A3F7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F7">DevRTT</code>, as described in <a class="xref" href="#P70010119520000000000000000014D4" data-foobar="1"><span class="label">Section</span> <span class="number">3.5.3</span></a>.</p>
<p id="P700101195200000000000000000A3F8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F8">The second major event is the timeout. TCP responds to the timeout event by retransmitting the segment that caused the timeout. TCP then restarts the timer.</p>
<p id="P700101195200000000000000000A3F9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3F9">The third major event that must be handled by the TCP sender is the arrival of an acknowledgment segment (ACK) from the receiver (more specifically, a segment containing a valid ACK field value). On the occurrence of this event, TCP compares the ACK value <code id="P700101195200000000000000000A3FA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3FA"><b>y</b></code> with its variable <code id="P700101195200000000000000000A3FB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3FB">SendBase</code>. The TCP state variable <code id="P700101195200000000000000000A3FC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3FC">SendBase</code> is the sequence number of the oldest unacknowledged byte. (Thus <code id="P700101195200000000000000000A3FD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3FD">SendBase–1</code> is the sequence number of the last byte that is known to have been received correctly and in order at the receiver.) As indicated earlier, TCP uses cumulative acknowledgments, so that <code id="P700101195200000000000000000A3FE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3FE"><b>y</b></code> acknowledges the receipt of all bytes before byte number <code id="P700101195200000000000000000A3FF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A3FF">y</code>. If <code id="P700101195200000000000000000A400" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A400">y &gt; SendBase</code>, then the ACK is acknowledging one or more previously unacknowledged segments. Thus the sender updates its <code id="P700101195200000000000000000A401" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A401">SendBase</code> variable; it also restarts the timer if there currently are any not-yet-acknowledged segments.</p>
<section id="P7001011952000000000000000001546" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001546" class="level3"><header><h1 class="title" id="P700101195200000000000000000A402" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A402" epub:type="title">A Few Interesting Scenarios</h1></header>
<p id="P700101195200000000000000000A403" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A403">We have just described a highly simplified version of how TCP provides reliable data transfer. But even this highly simplified version has many subtleties. To get a good feeling for how this protocol works, let’s now walk through a few simple scenarios. <a class="xref" href="#P700101195200000000000000000154B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.34</span></a> depicts the first scenario, in which Host A sends one segment to Host B. Suppose that this segment has sequence number 92 and contains 8 bytes of data. After sending this segment, Host A waits for a segment from B with acknowledgment number 100. Although the segment from A is received at B, the acknowledgment from B to A gets lost. In this case, the timeout event occurs, and Host A retransmits the same segment. Of course, when Host B receives the retransmission, it observes from the sequence number that the segment contains data that has already been received. Thus, TCP in Host B will discard the bytes in the retransmitted segment.</p>
<p id="P700101195200000000000000000A404" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A404">In a second scenario, shown in <a class="xref" href="#P7001011952000000000000000001557" data-foobar="1"><span class="label">Figure</span> <span class="number">3.35</span></a>, Host A sends two segments back to back. The first segment has sequence number 92 and 8 bytes of data, and the second segment has sequence number 100 and 20 bytes of data. Suppose that both segments arrive intact at B, and B sends two separate acknowledgments for each of these segments. The first of these acknowledgments has acknowledgment number 100; the second has acknowledgment number 120. Suppose now that neither of the acknowledgments arrives at Host A before the timeout. When the timeout event occurs, Host<span class="pagebreak" title="247" id="P700101195200000000000000000154A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000154A" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P700101195200000000000000000154B" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000154B">
<img alt="Illustration of a retransmission due to a lost acknowledgment." height="514" width="450" aria-describedby="P700101195200000000000000000154F" id="P700101195200000000000000000A405" data-uri="P7001011952000000000000000005566" src="../images/4055103034.png"></img>
<figcaption id="P700101195200000000000000000A406" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A406"><header><h1 class="title" id="P700101195200000000000000000A407" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A407" epub:type="title"><span class="label">Figure </span><span class="number">3.34</span> Retransmission due to a lost acknowledgment</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000154F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000154F" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103034.xhtml#la_4055103034"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A409" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A409">A resends the first segment with sequence number 92 and restarts the timer. As long as the ACK for the second segment arrives before the new timeout, the second segment will not be retransmitted.</p>
<p id="P700101195200000000000000000A40A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A40A">In a third and final scenario, suppose Host A sends the two segments, exactly as in the second example. The acknowledgment of the first segment is lost in the network, but just before the timeout event, Host A receives an acknowledgment with acknowledgment number 120. Host A therefore knows that Host B has received <i>everything</i> up through byte 119; so Host A does not resend either of the two segments. This scenario is illustrated in <a class="xref" href="#P7001011952000000000000000001567" data-foobar="1"><span class="label">Figure</span> <span class="number">3.36</span></a>.</p>
</section>
<section id="P7001011952000000000000000001553" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001553" class="level3"><header><h1 class="title" id="P700101195200000000000000000A40B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A40B" epub:type="title">Doubling the Timeout Interval</h1></header>
<p id="P700101195200000000000000000A40C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A40C">We now discuss a few modifications that most TCP implementations employ. The first concerns the length of the timeout interval after a timer expiration. In this modification, whenever the timeout event occurs, TCP retransmits the not-yet-acknowledged segment with the smallest sequence number, as described above. But each time TCP retransmits, it sets the next timeout interval to twice the previous value,<span class="pagebreak" title="248" id="P7001011952000000000000000001556" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001556" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001557" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001557">
<img alt="Illustration of segment 100 not retransmitted." height="550" width="609" aria-describedby="P700101195200000000000000000155B" id="P700101195200000000000000000A40D" data-uri="P7001011952000000000000000005567" src="../images/4055103035.png"></img>
<figcaption id="P700101195200000000000000000A40E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A40E"><header><h1 class="title" id="P700101195200000000000000000A40F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A40F" epub:type="title"><span class="label">Figure </span><span class="number">3.35</span> Segment 100 not retransmitted</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000155B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000155B" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103035.xhtml#la_4055103035"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A412" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A412">rather than deriving it from the last <code id="P700101195200000000000000000A413" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A413">EstimatedRTT</code> and <code id="P700101195200000000000000000A414" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A414">DevRTT</code> (as described in <a class="xref" href="#P70010119520000000000000000014D4" data-foobar="1"><span class="label">Section</span> <span class="number">3.5.3</span></a>). For example, suppose <code id="P700101195200000000000000000A415" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A415">TimeoutInterval</code> associated with the oldest not yet acknowledged segment is .75 sec when the timer first expires. TCP will then retransmit this segment and set the new expiration time to 1.5 sec. If the timer expires again 1.5 sec later, TCP will again retransmit this segment, now setting the expiration time to 3.0 sec. Thus the intervals grow exponentially after each retransmission. However, whenever the timer is started after either of the two other events (that is, data received from application above, and ACK received), the <code id="P700101195200000000000000000A416" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A416">TimeoutInterval</code> is derived from the most recent values of <code id="P700101195200000000000000000A417" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A417">EstimatedRTT</code> and <code id="P700101195200000000000000000A418" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A418">DevRTT</code>.</p>
<p id="P700101195200000000000000000A419" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A419">This modification provides a limited form of congestion control. (More comprehensive forms of TCP congestion control will be studied in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="label">Section</span> <span class="number">3.7</span></a>.) The timer expiration is most likely caused by congestion in the network, that is, too many packets arriving at one (or more) router queues in the path between the source and destination, causing packets to be dropped and/or long queuing delays. In times of congestion, if the sources continue to retransmit packets persistently, the congestion<span class="pagebreak" title="249" id="P7001011952000000000000000001566" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001566" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001567" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001567">
<img alt="Illustration of cumulative acknowledgment." height="550" width="611" aria-describedby="P700101195200000000000000000156B" id="P700101195200000000000000000A41A" data-uri="P7001011952000000000000000005568" src="../images/4055103036.png"></img>
<figcaption id="P700101195200000000000000000A41B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A41B"><header><h1 class="title" id="P700101195200000000000000000A41C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A41C" epub:type="title"><span class="label">Figure </span><span class="number">3.36</span> A cumulative acknowledgment avoids retransmission of the first segment</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000156B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000156B" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103036.xhtml#la_4055103036"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A41E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A41E">may get worse. Instead, TCP acts more politely, with each sender retransmitting after longer and longer intervals. We will see that a similar idea is used by Ethernet when we study CSMA/CD in <a class="xref" href="fileP70010119520000000000000000023B1.xhtml#P70010119520000000000000000023B1" data-foobar="7"><span class="label">Chapter</span> <span class="number">6</span></a>.</p>
</section>
<section id="P700101195200000000000000000156E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000156E" class="level3"><header><h1 class="title" id="P700101195200000000000000000A41F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A41F" epub:type="title">Fast Retransmit</h1></header>
<p id="P700101195200000000000000000A420" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A420">One of the problems with timeout-triggered retransmissions is that the timeout period can be relatively long. When a segment is lost, this long timeout period forces the sender to delay resending the lost packet, thereby increasing the end-to-end delay. Fortunately, the sender can often detect packet loss well before the timeout event occurs by noting so-called duplicate ACKs. A <span class="keyword" id="P7001011952000000000000000001571" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001571"><b>duplicate ACK</b></span> is an ACK that reacknowledges a segment for which the sender has already received an earlier acknowledgment. To understand the sender’s response to a duplicate ACK, we must look at why the receiver sends a duplicate ACK in the first place. <a class="xref" href="#P7001011952000000000000000001573" data-foobar="1"><span class="label">Table</span> <span class="number">3.2</span></a> summarizes the TCP receiver’s ACK generation policy <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BBB" data-foobar="7">[RFC 5681]</a>. When a TCP receiver receives<span class="pagebreak" title="250" id="P7001011952000000000000000001572" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001572" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001573" class="table" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001573">
<figcaption id="P700101195200000000000000000A421" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A421"><header><h1 class="title" id="P700101195200000000000000000A422" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A422" epub:type="title"><span class="label">Table </span><span class="number">3.2</span> TCP ACK Generation Recommendation <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BBB" data-foobar="7">[RFC 5681]</a></h1></header></figcaption>
<table id="P700101195200000000000000000A423" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A423">
<thead>
<tr>
<th id="P700101195200000000000000000A424" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A424">Event</th>
<th id="P700101195200000000000000000A425" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A425">TCP Receiver Action</th>
</tr>
</thead>
<tbody>
<tr>
<td id="P700101195200000000000000000A426" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A426">Arrival of in-order segment with expected sequence number. All data up to expected sequence number already acknowledged.</td>
<td id="P700101195200000000000000000A427" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A427">Delayed ACK. Wait up to 500 msec for arrival of another in-order segment. If next in-order segment does not arrive in this interval, send an ACK.</td>
</tr>
<tr>
<td id="P700101195200000000000000000A428" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A428">Arrival of in-order segment with expected sequence number. One other in-order segment waiting for ACK transmission.</td>
<td id="P700101195200000000000000000A429" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A429">One Immediately send single cumulative ACK, ACKing both in-order segments.</td>
</tr>
<tr>
<td id="P700101195200000000000000000A42A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A42A">Arrival of out-of-order segment with higher-than-expected sequence number. Gap detected.</td>
<td id="P700101195200000000000000000A42B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A42B">Immediately send duplicate ACK, indicating sequence number of next expected byte (which is the lower end of the gap).</td>
</tr>
<tr>
<td id="P700101195200000000000000000A42C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A42C">Arrival of segment that partially or completely fills in gap in received data.</td>
<td id="P700101195200000000000000000A42D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A42D">Immediately send ACK, provided that segment starts at the lower end of gap.</td>
</tr>
</tbody>
</table>
</figure>
<p class="continued" id="P700101195200000000000000000A42E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A42E">a segment with a sequence number that is larger than the next, expected, in-order sequence number, it detects a gap in the data stream—that is, a missing segment. This gap could be the result of lost or reordered segments within the network. Since TCP does not use negative acknowledgments, the receiver cannot send an explicit negative acknowledgment back to the sender. Instead, it simply reacknowledges (that is, generates a duplicate ACK for) the last in-order byte of data it has received. (Note that <a class="xref" href="#P7001011952000000000000000001573" data-foobar="1"><span class="label">Table</span> <span class="number">3.2</span></a> allows for the case that the receiver does not discard out-of-order segments.)</p>
<p id="P700101195200000000000000000A42F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A42F">Because a sender often sends a large number of segments back to back, if one segment is lost, there will likely be many back-to-back duplicate ACKs. If the TCP sender receives three duplicate ACKs for the same data, it takes this as an indication that the segment following the segment that has been ACKed three times has been lost. (In the homework problems, we consider the question of why the sender waits for three duplicate ACKs, rather than just a single duplicate ACK.) In the case that three duplicate ACKs are received, the TCP sender performs a <span class="keyword" id="P7001011952000000000000000001583" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001583"><b>fast retransmit</b></span> <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BBB" data-foobar="7">[RFC 5681]</a>, retransmitting the missing segment <i>before</i> that segment’s timer expires. This is shown in <a class="xref" href="#P7001011952000000000000000001586" data-foobar="1"><span class="label">Figure</span> <span class="number">3.37</span></a>, where the second segment is lost, then retransmitted before its timer expires. For TCP with fast retransmit, the following code snippet replaces the ACK received event in <a class="xref" href="#P7001011952000000000000000001533" data-foobar="1"><span class="label">Figure</span> <span class="number">3.33</span></a>:</p>
<pre id="P700101195200000000000000000A430" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A430"><code id="P700101195200000000000000000A431" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A431">event: ACK received, with ACK field value of y
            if (y &gt; SendBase) {
            SendBase=y
            if (there are currently any not yet
                       acknowledged segments)
               start timer
               }</code></pre>
<figure id="P7001011952000000000000000001586" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001586">
<img alt="Illustration of a fast retransmit." height="587" width="478" aria-describedby="P700101195200000000000000000158B" id="P700101195200000000000000000A432" data-uri="P7001011952000000000000000005569" src="../images/4055103037.png"></img>
<figcaption id="P700101195200000000000000000A433" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A433"><header><h1 class="title" id="P700101195200000000000000000A434" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A434" epub:type="title"><span class="pagebreak" title="251" id="P700101195200000000000000000158A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000158A" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">Figure </span><span class="number">3.37</span> Fast retransmit: retransmitting the missing segment before the segment’s timer expires</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000158B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000158B" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103037.xhtml#la_4055103037"><span class="label">Description</span></a></div>
<pre id="P700101195200000000000000000A437" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A437"><code id="P700101195200000000000000000A438" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A438">
            else {/* a duplicate ACK for already ACKed
                   segment */
               increment number of duplicate ACKs
                   received for y
               if (number of duplicate ACKS received
                   for y==3)
                   /* TCP fast retransmit */
                   resend segment with sequence number y
               }
           break;</code></pre>
<p id="P700101195200000000000000000A439" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A439">We noted earlier that many subtle issues arise when a timeout/retransmit mechanism is implemented in an actual protocol such as TCP. The procedures above, which have evolved as a result of more than 20 years of experience with TCP timers, should convince you that this is indeed the case!</p>
</section>
<section id="P7001011952000000000000000001591" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001591" class="level3"><header><h1 class="title" id="P700101195200000000000000000A43A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A43A" epub:type="title"><span class="pagebreak" title="252" id="P7001011952000000000000000001593" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001593" epub:type="pagebreak" role="doc-pagebreak"></span>Go-Back-N or Selective Repeat?</h1></header>
<p id="P700101195200000000000000000A43B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A43B">Let us close our study of TCP’s error-recovery mechanism by considering the following question: Is TCP a GBN or an SR protocol? Recall that TCP acknowledgments are cumulative and correctly received but out-of-order segments are not individually ACKed by the receiver. Consequently, as shown in <a class="xref" href="#P7001011952000000000000000001533" data-foobar="1"><span class="label">Figure</span> <span class="number">3.33</span></a> (see also <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P700101195200000000000000000136B" data-foobar="7"><span class="label">Figure</span> <span class="number">3.19</span></a>), the TCP sender need only maintain the smallest sequence number of a transmitted but unacknowledged byte (<code id="P700101195200000000000000000A43C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A43C">SendBase</code>) and the sequence number of the next byte to be sent (<code id="P700101195200000000000000000A43D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A43D">NextSeqNum</code>). In this sense, TCP looks a lot like a GBN-style protocol. But there are some striking differences between TCP and Go-Back-N. Many TCP implementations will buffer correctly received but out-of-order segments <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C26" data-foobar="7">[Stevens 1994]</a>. Consider also what happens when the sender sends a sequence of segments 1, 2, . . ., <i>N</i>, and all of the segments arrive in order without error at the receiver. Further suppose that the acknowledgment for packet <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="55" altimg-height="14" altimg="../images/ch03math23.png"><m:mrow><m:mi>n</m:mi><m:mo>&lt;</m:mo><m:mi>N</m:mi></m:mrow></m:math></span> gets lost, but the remaining <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="51" altimg-height="14" altimg="../images/ch03math24.png"><m:mrow><m:mi>N</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> acknowledgments arrive at the sender before their respective timeouts. In this example, GBN would retransmit not only packet <i>n,</i> but also all of the subsequent packets <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="170" altimg-height="16" altimg="../images/ch03math25.png"><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mi>N</m:mi><m:mo>.</m:mo></m:mrow></m:math></span> TCP, on the other hand, would retransmit at most one segment, namely, segment <i>n</i>. Moreover, TCP would not even retransmit segment <i>n</i> if the acknowledgment for segment <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="47" altimg-height="13" altimg="../images/ch03math26.png"><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> arrived before the timeout for segment <i>n</i>.</p>
<p id="P700101195200000000000000000A43E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A43E">A proposed modification to TCP, the so-called <span class="keyword" id="P7001011952000000000000000001598" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001598"><b>selective acknowledgment</b></span> <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003B22" data-foobar="7">[RFC 2018]</a>, allows a TCP receiver to acknowledge out-of-order segments selectively rather than just cumulatively acknowledging the last correctly received, in-order segment. When combined with selective retransmission—skipping the retransmission of segments that have already been selectively acknowledged by the receiver—TCP looks a lot like our generic SR protocol. Thus, TCP’s error-recovery mechanism is probably best categorized as a hybrid of GBN and SR protocols.</p>
</section>
</section>
<section id="P7001011952000000000000000001599" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001599" class="level2"><header><h1 class="title" id="P700101195200000000000000000A43F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A43F" epub:type="title"><span class="number">3.5.5</span> Flow Control</h1></header>
<p id="P700101195200000000000000000A440" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A440">Recall that the hosts on each side of a TCP connection set aside a receive buffer for the connection. When the TCP connection receives bytes that are correct and in sequence, it places the data in the receive buffer. The associated application process will read data from this buffer, but not necessarily at the instant the data arrives. Indeed, the receiving application may be busy with some other task and may not even attempt to read the data until long after it has arrived. If the application is relatively slow at reading the data, the sender can very easily overflow the connection’s receive buffer by sending too much data too quickly.</p>
<p id="P700101195200000000000000000A441" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A441">TCP provides a <span class="keyword" id="P700101195200000000000000000159D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000159D"><b>flow-control service</b></span> to its applications to eliminate the possibility of the sender overflowing the receiver’s buffer. Flow control is thus a speed-matching service—matching the rate at which the sender is sending against the rate at which the receiving application is reading. As noted earlier, a TCP sender can also be throttled due to congestion within the IP network; this form of sender control is <span class="pagebreak" title="253" id="P700101195200000000000000000159E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000159E" epub:type="pagebreak" role="doc-pagebreak"></span>referred to as <span class="keyword" id="P700101195200000000000000000159F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000159F"><b>congestion control</b></span>, a topic we will explore in detail in <a class="xref" href="fileP7001011952000000000000000001627.xhtml#P7001011952000000000000000001627" data-foobar="7"><span class="label">Sections</span> <span class="number">3.6</span></a> and <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="number">3.7</span></a>. Even though the actions taken by flow and congestion control are similar (the throttling of the sender), they are obviously taken for very different reasons. Unfortunately, many authors use the terms interchangeably, and the savvy reader would be wise to distinguish between them. Let’s now discuss how TCP provides its flow-control service. In order to see the forest for the trees, we suppose throughout this section that the TCP implementation is such that the TCP receiver discards out-of-order segments.</p>
<p id="P700101195200000000000000000A442" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A442">TCP provides flow control by having the <i>sender</i> maintain a variable called the <span class="keyword" id="P70010119520000000000000000015A1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015A1"><b>receive window</b></span>. Informally, the receive window is used to give the sender an idea of how much free buffer space is available at the receiver. Because TCP is full-duplex, the sender at each side of the connection maintains a distinct receive window. Let’s investigate the receive window in the context of a file transfer. Suppose that Host A is sending a large file to Host B over a TCP connection. Host B allocates a receive buffer to this connection; denote its size by <code id="P700101195200000000000000000A443" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A443">RcvBuffer</code>. From time to time, the application process in Host B reads from the buffer. Define the following variables:</p>
<ul id="P700101195200000000000000000A444" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A444">
<li id="P700101195200000000000000000A445" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A445"><p id="P700101195200000000000000000A446" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A446"><code id="P700101195200000000000000000A447" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A447">LastByteRead</code>: the number of the last byte in the data stream read from the buffer by the application process in B</p></li>
<li id="P700101195200000000000000000A448" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A448"><p id="P700101195200000000000000000A449" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A449"><code id="P700101195200000000000000000A44A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A44A">LastByteRcvd</code>: the number of the last byte in the data stream that has arrived from the network and has been placed in the receive buffer at B</p></li>
</ul>
<p class="continued" id="P700101195200000000000000000A44B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A44B">Because TCP is not permitted to overflow the allocated buffer, we must have</p>
<pre id="P700101195200000000000000000A44C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A44C"><code id="P700101195200000000000000000A44D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A44D"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="445" altimg-height="16" altimg="../images/ch03math27.png"><m:mrow><m:mtext>LastByteRcvd</m:mtext><m:mo>−</m:mo><m:mtext>LastByteRead</m:mtext><m:mo>≤</m:mo><m:mtext>RcvBuffer</m:mtext></m:mrow></m:math></span></code></pre>
<p class="continued" id="P700101195200000000000000000A44E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A44E">The receive window, denoted <code id="P700101195200000000000000000A44F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A44F">rwnd</code> is set to the amount of spare room in the buffer:</p>
<pre id="P700101195200000000000000000A450" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A450"><code id="P700101195200000000000000000A451" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A451"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="553" altimg-height="16" altimg="../images/ch03math28.png"><m:mrow><m:mtext>rwnd</m:mtext><m:mo>=</m:mo><m:mtext>RcvBuffer</m:mtext><m:mo>−</m:mo><m:mrow><m:mo>[</m:mo><m:mrow><m:mtext>LastByteRcvd</m:mtext><m:mo>−</m:mo><m:mtext>LastByteRead</m:mtext></m:mrow><m:mo>]</m:mo></m:mrow></m:mrow></m:math></span></code></pre>
<p class="continued" id="P700101195200000000000000000A452" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A452">Because the spare room changes with time, <code id="P700101195200000000000000000A453" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A453">rwnd</code> is dynamic. The variable <code id="P700101195200000000000000000A454" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A454">rwnd</code> is illustrated in <a class="xref" href="#P70010119520000000000000000015BE" data-foobar="1"><span class="label">Figure</span> <span class="number">3.38</span></a>.</p>
<p id="P700101195200000000000000000A455" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A455">How does the connection use the variable <code id="P700101195200000000000000000A456" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A456">rwnd</code> to provide the flow-control service? Host B tells Host A how much spare room it has in the connection buffer by placing its current value of <code id="P700101195200000000000000000A457" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A457">rwnd</code> in the receive window field of every segment it sends to A. Initially, Host B sets <code id="P700101195200000000000000000A458" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A458">rwnd = RcvBuffer</code>. Note that to pull this off, Host B must keep track of several connection-specific variables.</p>
<p id="P700101195200000000000000000A459" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A459">Host A in turn keeps track of two variables, <code id="P700101195200000000000000000A45A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A45A">LastByteSent</code> and <code id="P700101195200000000000000000A45B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A45B">LastByteAcked</code>, which have obvious meanings. Note that the difference between these two variables, <code id="P700101195200000000000000000A45C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A45C">LastByteSent – LastByteAcked</code>, is the amount of unacknowledged data that A has sent into the connection. By keeping the amount of unacknowledged data less than the value of <code id="P700101195200000000000000000A45D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A45D">rwnd</code>, Host A is assured that it is not<span class="pagebreak" title="254" id="P70010119520000000000000000015BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015BD" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000015BE" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015BE">
<img alt="Illustration of the receive window and the receive buffer." height="268" width="527" aria-describedby="P70010119520000000000000000015C4" id="P700101195200000000000000000A45E" data-uri="P700101195200000000000000000556A" src="../images/4055103038.png"></img>
<figcaption id="P700101195200000000000000000A45F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A45F"><header><h1 class="title" id="P700101195200000000000000000A460" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A460" epub:type="title"><span class="label">Figure </span><span class="number">3.38</span> The receive window <code id="P700101195200000000000000000A461" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A461">(rwnd)</code> and the receive buffer <code id="P700101195200000000000000000A462" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A462"><b>(RcvBuffer)</b></code></h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000015C4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015C4" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103038.xhtml#la_4055103038"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A465" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A465">overflowing the receive buffer at Host B. Thus, Host A makes sure throughout the connection’s life that</p>
<pre id="P700101195200000000000000000A466" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A466"><code id="P700101195200000000000000000A467" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A467"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="400" altimg-height="16" altimg="../images/ch03math29.png"><m:mrow><m:mtext>LastByteSent</m:mtext><m:mo>−</m:mo><m:mtext>LastByteAcked</m:mtext><m:mo>≤</m:mo><m:mtext>rwnd</m:mtext></m:mrow></m:math></span></code></pre>
<p id="P700101195200000000000000000A468" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A468">There is one minor technical problem with this scheme. To see this, suppose Host B’s receive buffer becomes full so that <code id="P700101195200000000000000000A469" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A469">rwnd</code> = 0. After advertising <code id="P700101195200000000000000000A46A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A46A">rwnd</code> = 0 to Host A, also suppose that B has <i>nothing</i> to send to A. Now consider what happens. As the application process at B empties the buffer, TCP does not send new segments with new <code id="P700101195200000000000000000A46B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A46B">rwnd</code> values to Host A; indeed, TCP sends a segment to Host A only if it has data to send or if it has an acknowledgment to send. Therefore, Host A is never informed that some space has opened up in Host B’s receive buffer—Host A is blocked and can transmit no more data! To solve this problem, the TCP specification requires Host A to continue to send segments with one data byte when B’s receive window is zero. These segments will be acknowledged by the receiver. Eventually the buffer will begin to empty and the acknowledgments will contain a nonzero <code id="P700101195200000000000000000A46C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A46C">rwnd</code> value.</p>
<p id="P700101195200000000000000000A46D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A46D">The online site at <span class="url-obsolete">http://www.awl.com/kurose-ross</span> for this book provides an interactive Java applet that illustrates the operation of the TCP receive window.</p>
<p id="P700101195200000000000000000A46E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A46E">Having described TCP’s flow-control service, we briefly mention here that UDP does not provide flow control and consequently, segments may be lost at the receiver due to buffer overflow. For example, consider sending a series of UDP segments from a process on Host A to a process on Host B. For a typical UDP implementation, UDP will append the segments in a finite-sized buffer that “precedes” the corresponding socket (that is, the door to the process). The process reads one entire segment at a time from the buffer. If the process does not read the segments fast enough from the buffer, the buffer will overflow and segments will get dropped.</p>
</section>
<section id="P70010119520000000000000000015D1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015D1" class="level2"><header><h1 class="title" id="P700101195200000000000000000A46F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A46F" epub:type="title"><span class="pagebreak" title="255" id="P70010119520000000000000000015D3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015D3" epub:type="pagebreak" role="doc-pagebreak"></span><span class="number">3.5.6</span> TCP Connection Management</h1></header>
<p id="P700101195200000000000000000A470" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A470">In this subsection we take a closer look at how a TCP connection is established and torn down. Although this topic may not seem particularly thrilling, it is important because TCP connection establishment can significantly add to perceived delays (for example, when surfing the Web). Furthermore, many of the most common network attacks—including the incredibly popular SYN flood attack—exploit vulnerabilities in TCP connection management. Let’s first take a look at how a TCP connection is established. Suppose a process running in one host (client) wants to initiate a connection with another process in another host (server). The client application process first informs the client TCP that it wants to establish a connection to a process in the server. The TCP in the client then proceeds to establish a TCP connection with the TCP in the server in the following manner:</p>
<ul class="steplist" id="P700101195200000000000000000A471" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A471">
<li class="step" id="P700101195200000000000000000A472" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A472"><p id="P700101195200000000000000000A473" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A473"><i><span class="label">Step</span> <span class="number">1.</span></i> The client-side TCP first sends a special TCP segment to the server-side TCP. This special segment contains no application-layer data. But one of the flag bits in the segment’s header (see <a class="xref" href="#P7001011952000000000000000001488" data-foobar="1"><span class="label">Figure</span> <span class="number">3.29</span></a>), the SYN bit, is set to 1. For this reason, this special segment is referred to as a SYN segment. In addition, the client randomly chooses an initial sequence number (<code id="P700101195200000000000000000A474" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A474">client_isn</code>) and puts this number in the sequence number field of the initial TCP SYN segment. This segment is encapsulated within an IP datagram and sent to the server. There has been considerable interest in properly randomizing the choice of the <code id="P700101195200000000000000000A475" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A475">client_isn</code> in order to avoid certain security attacks <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P700101195200000000000000000386D" data-foobar="7">[CERT 2001–09]</a>.</p></li>
<li class="step" id="P700101195200000000000000000A476" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A476"><p id="P700101195200000000000000000A477" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A477"><i><span class="label">Step</span> <span class="number">2.</span></i> Once the IP datagram containing the TCP SYN segment arrives at the server host (assuming it does arrive!), the server extracts the TCP SYN segment from the datagram, allocates the TCP buffers and variables to the connection, and sends a connection-granted segment to the client TCP. (We’ll see in <a class="xref" href="fileP7001011952000000000000000002D4B.xhtml#P7001011952000000000000000002D4B" data-foobar="7"><span class="label">Chapter</span> <span class="number">8</span></a> that the allocation of these buffers and variables before completing the third step of the three-way handshake makes TCP vulnerable to a denial-of-service attack known as SYN flooding.) This connection-granted segment also contains no application-layer data. However, it does contain three important pieces of information in the segment header. First, the SYN bit is set to 1. Second, the acknowledgment field of the TCP segment header is set to <code id="P700101195200000000000000000A478" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A478">client_isn+1</code>. Finally, the server chooses its own initial sequence number (<code id="P700101195200000000000000000A479" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A479">server_isn</code>) and puts this value in the sequence number field of the TCP segment header. This connection-granted segment is saying, in effect, “I received your SYN packet to start a connection with your initial sequence number, <code id="P700101195200000000000000000A47A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A47A">client_isn</code>. I agree to establish this connection. My own initial sequence number is <code id="P700101195200000000000000000A47B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A47B">server_isn</code>.” The connection-granted segment is referred to as a <span class="keyword" id="P70010119520000000000000000015E0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015E0"><b>SYNACK segment</b></span>.</p></li>
<li class="step" id="P700101195200000000000000000A47C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A47C"><p id="P700101195200000000000000000A47D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A47D"><i><span class="label">Step</span> <span class="number">3.</span></i> Upon receiving the SYNACK segment, the client also allocates buffers and variables to the connection. The client host then sends the server yet another segment; this last segment acknowledges the server’s connection-granted segment (the client does so by putting the value <code id="P700101195200000000000000000A47E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A47E">server_isn+1</code> in the acknowledgment <span class="pagebreak" title="256" id="P70010119520000000000000000015E4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015E4" epub:type="pagebreak" role="doc-pagebreak"></span>field of the TCP segment header). The SYN bit is set to zero, since the connection is established. This third stage of the three-way handshake may carry client-to-server data in the segment payload.</p></li>
</ul>
<p id="P700101195200000000000000000A47F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A47F">Once these three steps have been completed, the client and server hosts can send segments containing data to each other. In each of these future segments, the SYN bit will be set to zero. Note that in order to establish the connection, three packets are sent between the two hosts, as illustrated in <a class="xref" href="#P70010119520000000000000000015E8" data-foobar="1"><span class="label">Figure</span> <span class="number">3.39</span></a>. For this reason, this connection-establishment procedure is often referred to as a <span class="keyword" id="P70010119520000000000000000015E6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015E6"><b>three-way handshake</b></span>. Several aspects of the TCP three-way handshake are explored in the homework problems (Why are initial sequence numbers needed? Why is a three-way handshake, as opposed to a two-way handshake, needed?). It’s interesting to note that a rock climber and a belayer (who is stationed below the rock climber and whose job it is to handle the climber’s safety rope) use a three-way-handshake communication protocol that is identical to TCP’s to ensure that both sides are ready before the climber begins ascent.</p>
<p id="P700101195200000000000000000A480" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A480">All good things must come to an end, and the same is true with a TCP connection. Either of the two processes participating in a TCP connection can end the connection. When a connection ends, the “resources” (that is, the buffers and variables)</p>
<figure id="P70010119520000000000000000015E8" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015E8">
<img alt="Illustration of a TCP three-way handshake: segment exchange." height="489" width="546" aria-describedby="P70010119520000000000000000015EC" id="P700101195200000000000000000A481" data-uri="P700101195200000000000000000556B" src="../images/4055103039.png"></img>
<figcaption id="P700101195200000000000000000A482" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A482"><header><h1 class="title" id="P700101195200000000000000000A483" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A483" epub:type="title"><span class="label">Figure </span><span class="number">3.39</span> TCP three-way handshake: segment exchange</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000015EC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015EC" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103039.xhtml#la_4055103039"><span class="label">Description</span></a></div>
<figure id="P70010119520000000000000000015EE" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015EE">
<img alt="Illustration of closing a TCP connection." height="537" width="484" aria-describedby="P70010119520000000000000000015F3" id="P700101195200000000000000000A485" data-uri="P700101195200000000000000000556C" src="../images/4055103040.png"></img>
<figcaption id="P700101195200000000000000000A486" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A486"><header><h1 class="title" id="P700101195200000000000000000A487" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A487" epub:type="title"><span class="pagebreak" title="257" id="P70010119520000000000000000015F2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015F2" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">Figure </span><span class="number">3.40</span> Closing a TCP connection</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000015F3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015F3" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103040.xhtml#la_4055103040"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A489" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A489">in the hosts are deallocated. As an example, suppose the client decides to close the connection, as shown in <a class="xref" href="#P70010119520000000000000000015EE" data-foobar="1"><span class="label">Figure</span> <span class="number">3.40</span></a>. The client application process issues a close command. This causes the client TCP to send a special TCP segment to the server process. This special segment has a flag bit in the segment’s header, the FIN bit (see <a class="xref" href="#P7001011952000000000000000001488" data-foobar="1"><span class="label">Figure</span> <span class="number">3.29</span></a>), set to 1. When the server receives this segment, it sends the client an acknowledgment segment in return. The server then sends its own shutdown segment, which has the FIN bit set to 1. Finally, the client acknowledges the server’s shutdown segment. At this point, all the resources in the two hosts are now deallocated.</p>
<p id="P700101195200000000000000000A48A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A48A">During the life of a TCP connection, the TCP protocol running in each host makes transitions through various <span class="keyword" id="P70010119520000000000000000015F7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015F7"><b>TCP states</b></span>. <a class="xref" href="#P70010119520000000000000000015F9" data-foobar="1"><span class="label">Figure</span> <span class="number">3.41</span></a> illustrates a typical sequence of TCP states that are visited by the <i>client</i> TCP. The client TCP begins in the CLOSED state. The application on the client side initiates a new TCP connection (by creating a Socket object in our Java examples as in the Python examples from <a class="xref" href="fileP700101195200000000000000000096B.xhtml#P700101195200000000000000000096B" data-foobar="7"><span class="label">Chapter</span> <span class="number">2</span></a>). This causes TCP in the client to send a SYN segment to TCP in the server. After having sent the SYN segment, the client TCP enters the SYN_SENT state. While in the SYN_SENT state, the client TCP waits for a segment from the server TCP that includes an acknowledgment for the client’s previous segment and<span class="pagebreak" title="258" id="P70010119520000000000000000015F8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015F8" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000015F9" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015F9">
<img alt="Illustration of a typical sequence of TCP states visited by a client TCP." height="448" width="602" aria-describedby="P70010119520000000000000000015FD" id="P700101195200000000000000000A48B" data-uri="P700101195200000000000000000556D" src="../images/4055103041.png"></img>
<figcaption id="P700101195200000000000000000A48C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A48C"><header><h1 class="title" id="P700101195200000000000000000A48D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A48D" epub:type="title"><span class="label">Figure </span><span class="number">3.41</span> A typical sequence of TCP states visited by a client TCP</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000015FD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000015FD" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103041.xhtml#la_4055103041"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A490" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A490">has the SYN bit set to 1. Having received such a segment, the client TCP enters the ESTABLISHED state. While in the ESTABLISHED state, the TCP client can send and receive TCP segments containing payload (that is, application-generated) data.</p>
<p id="P700101195200000000000000000A491" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A491">Suppose that the client application decides it wants to close the connection. (Note that the server could also choose to close the connection.) This causes the client TCP to send a TCP segment with the FIN bit set to 1 and to enter the FIN_WAIT_1 state. While in the FIN_WAIT_1 state, the client TCP waits for a TCP segment from the server with an acknowledgment. When it receives this segment, the client TCP enters the FIN_WAIT_2 state. While in the FIN_WAIT_2 state, the client waits for another segment from the server with the FIN bit set to 1; after receiving this segment, the client TCP acknowledges the server’s segment and enters the TIME_WAIT state. The TIME_WAIT state lets the TCP client resend the final acknowledgment in case the ACK is lost. The time spent in the TIME_WAIT state is implementation-dependent, but typical values are 30 seconds, 1 minute, and 2 minutes. After the wait, the connection formally closes and all resources on the client side (including port numbers) are released.</p>
<p id="P700101195200000000000000000A492" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A492"><a class="xref" href="#P7001011952000000000000000001604" data-foobar="1"><span class="label">Figure</span> <span class="number">3.42</span></a> illustrates the series of states typically visited by the server-side TCP, assuming the client begins connection teardown. The transitions are self-explanatory. In these two state-transition diagrams, we have only shown how a TCP connection is normally established and shut down. We have not described what happens in certain pathological scenarios, for example, when both sides of a connection want to initiate or shut down at the same time. If you are interested in learning about<span class="pagebreak" title="259" id="P7001011952000000000000000001603" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001603" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001604" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001604">
<img alt="Illustration of a typical sequence of TCP states visited by a server-side TCP." height="423" width="543" aria-describedby="P7001011952000000000000000001608" id="P700101195200000000000000000A493" data-uri="P700101195200000000000000000556E" src="../images/4055103042.png"></img>
<figcaption id="P700101195200000000000000000A494" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A494"><header><h1 class="title" id="P700101195200000000000000000A495" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A495" epub:type="title"><span class="label">Figure </span><span class="number">3.42</span> A typical sequence of TCP states visited by a server-side TCP</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001608" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001608" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103042.xhtml#la_4055103042"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A497" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A497">this and other advanced issues concerning TCP, you are encouraged to see Stevens’ comprehensive book <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C26" data-foobar="7">[Stevens 1994]</a>.</p>
<p id="P700101195200000000000000000A498" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A498">Our discussion above has assumed that both the client and server are prepared to communicate, i.e., that the server is listening on the port to which the client sends its SYN segment. Let’s consider what happens when a host receives a TCP segment whose port numbers or source IP address do not match with any of the ongoing sockets in the host. For example, suppose a host receives a TCP SYN packet with destination port 80, but the host is not accepting connections on port 80 (that is, it is not running a Web server on port 80). Then the host will send a special reset segment to the source. This TCP segment has the RST flag bit (see <a class="xref" href="#P700101195200000000000000000146E" data-foobar="1"><span class="label">Section</span> <span class="number">3.5.2</span></a>) set to 1. Thus, when a host sends a reset segment, it is telling the source “I don’t have a socket for that segment. Please do not resend the segment.” When a host receives a UDP packet whose destination port number doesn’t match with an ongoing UDP socket, the host sends a special ICMP datagram, as discussed in <a class="xref" href="fileP7001011952000000000000000001EDE.xhtml#P7001011952000000000000000001EDE" data-foobar="7"><span class="label">Chapter</span> <span class="number">5</span></a>.</p>
<p id="P700101195200000000000000000A499" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A499">Now that we have a good understanding of TCP connection management, let’s revisit the nmap port-scanning tool and examine more closely how it works. To explore a specific TCP port, say port 6789, on a target host, nmap will send a TCP SYN segment with destination port 6789 to that host. There are three possible outcomes:</p>
<ul id="P700101195200000000000000000A49A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A49A">
<li id="P700101195200000000000000000A49B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A49B"><p id="P700101195200000000000000000A49C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A49C"><span class="leadin">The source host receives a TCP SYNACK segment from the target host.</span> Since this means that an application is running with TCP port 6789 on the target post, nmap returns “open.”</p>
<aside class="sidebar" id="P7001011952000000000000000001610" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001610"><header><h1 class="title" id="P700101195200000000000000000A49D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A49D" epub:type="title"><span class="pagebreak" title="260" id="P7001011952000000000000000001612" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001612" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">FOCUS ON SECURITY </span></h1></header>
<section id="P7001011952000000000000000001613" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001613"><header><h1 class="title" id="P700101195200000000000000000A49E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A49E" epub:type="title">The Syn Flood Attack</h1></header>
<p id="P700101195200000000000000000A49F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A49F">We’ve seen in our discussion of TCP’s three-way handshake that a server allocates and initializes connection variables and buffers in response to a received SYN. The server then sends a SYNACK in response, and awaits an ACK segment from the client. If the client does not send an ACK to complete the third step of this 3-way handshake, eventually (often after a minute or more) the server will terminate the half-open connection and reclaim the allocated resources.</p>
<p id="P700101195200000000000000000A4A0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A0">This TCP connection management protocol sets the stage for a classic Denial of Service (DoS) attack known as the <span class="keyword" id="P7001011952000000000000000001617" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001617"><b>SYN flood attack</b></span>. In this attack, the attacker(s) send a large number of TCP SYN segments, without completing the third handshake step. With this deluge of SYN segments, the server’s connection resources become exhausted as they are allocated (but never used!) for half-open connections; legitimate clients are then denied service. Such SYN flooding attacks were among the first documented DoS attacks <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003871" data-foobar="7">[CERT SYN 1996]</a>. Fortunately, an effective defense known as <span class="keyword" id="P7001011952000000000000000001618" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001618"><b>SYN cookies</b></span> <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BA6" data-foobar="7">[RFC 4987]</a> are now deployed in most major operating systems. SYN cookies work as follows:</p>
<ul id="P700101195200000000000000000A4A1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A1">
<li id="P700101195200000000000000000A4A2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A2"><p id="P700101195200000000000000000A4A3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A3">When the server receives a SYN segment, it does not know if the segment is coming from a legitimate user or is part of a SYN flood attack. So, instead of creating a half-open TCP connection for this SYN, the server creates an initial TCP sequence number that is a complicated function (hash function) of source and destination IP addresses and port numbers of the SYN segment, as well as a secret number only known to the server. This carefully crafted initial sequence number is the so-called “cookie.” The server then sends the client a SYNACK packet with this special initial sequence number. <i>Importantly, the server does not remember the cookie or any other state information corresponding to the SYN</i>.</p></li>
<li id="P700101195200000000000000000A4A4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A4"><p id="P700101195200000000000000000A4A5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A5">A legitimate client will return an ACK segment. When the server receives this ACK, it must verify that the ACK corresponds to some SYN sent earlier. But how is this done if the server maintains no memory about SYN segments? As you may have guessed, it is done with the cookie. Recall that for a legitimate ACK, the value in the acknowledgment field is equal to the initial sequence number in the SYNACK (the cookie value in this case) plus one (see <a class="xref" href="#P70010119520000000000000000015E8" data-foobar="1"><span class="label">Figure</span> <span class="number">3.39</span></a>). The server can then run the same hash function using the source and destination IP address and port numbers in the SYNACK (which are the same as in the original SYN) and the secret number. If the result of the function plus one is the same as the acknowledgment (cookie) value in the client’s SYNACK, the server concludes that the ACK corresponds to an earlier SYN segment and is hence valid. The server then creates a fully open connection along with a socket.</p></li>
<li id="P700101195200000000000000000A4A6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A6"><p id="P700101195200000000000000000A4A7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A7">On the other hand, if the client does not return an ACK segment, then the original SYN has done no harm at the server, since the server hasn’t yet allocated any resources in response to the original bogus SYN.</p></li>
</ul>
</section>
</aside>
</li>
<li id="P700101195200000000000000000A4A8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A8"><p id="P700101195200000000000000000A4A9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4A9"><span class="pagebreak" title="261" id="P7001011952000000000000000001622" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001622" epub:type="pagebreak" role="doc-pagebreak"></span><span class="leadin">The source host receives a TCP RST segment from the target host.</span> This means that the SYN segment reached the target host, but the target host is not running an application with TCP port 6789. But the attacker at least knows that the segments destined to the host at port 6789 are not blocked by any firewall on the path between source and target hosts. (Firewalls are discussed in <a class="xref" href="fileP7001011952000000000000000002D4B.xhtml#P7001011952000000000000000002D4B" data-foobar="7"><span class="label">Chapter</span> <span class="number">8</span></a>.)</p></li>
<li id="P700101195200000000000000000A4AA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4AA"><p id="P700101195200000000000000000A4AB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4AB"><span class="leadin">The source receives nothing.</span> This likely means that the SYN segment was blocked by an intervening firewall and never reached the target host.</p></li>
</ul>
<p id="P700101195200000000000000000A4AC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4AC">Nmap is a powerful tool that can “case the joint” not only for open TCP ports, but also for open UDP ports, for firewalls and their configurations, and even for the versions of applications and operating systems. Most of this is done by manipulating TCP connection-management segments <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C16" data-foobar="7">[Skoudis 2006]</a>. You can download nmap from <a class="ulink" href="http://www.nmap.org">www.nmap.org</a>.</p>
<p id="P700101195200000000000000000A4AD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A4AD">This completes our introduction to error control and flow control in TCP. In <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="label">Section</span> <span class="number">3.7</span></a> we’ll return to TCP and look at TCP congestion control in some depth. Before doing so, however, we first step back and examine congestion-control issues in a broader context.</p>
</section>
</section></body></html>