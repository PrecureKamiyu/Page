<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.4 VM as a Tool for Memory Management</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P70004970270000000000000000070D3" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P700049702700000000000000004591B" data-uri="chapter09.xhtml#P700049702700000000000000004591B" epub:type="title"><span class="pcalibre label pcalibre1">9.4 </span>VM as a Tool for Memory Management</h1></header>
<p id="P700049702700000000000000004591C" data-uri="chapter09.xhtml#P700049702700000000000000004591C" class="pcalibre1 pcalibre calibre2">In the last section, we saw how virtual memory provides a mechanism for using the DRAM to cache pages from a typically larger virtual address space. Interestingly, some early systems such as the DEC PDP-11/70 supported a virtual address space that was <i class="calibre5 pcalibre pcalibre1">smaller</i> than the available physical memory. Yet virtual memory was still a useful mechanism because it greatly simplified memory management and provided a natural way to protect memory.</p>
<p id="P700049702700000000000000004591D" data-uri="chapter09.xhtml#P700049702700000000000000004591D" class="pcalibre1 pcalibre calibre2">Thus far, we have assumed a single page table that maps a single virtual address space to the physical address space. In fact, operating systems provide a separate page table, and thus a separate virtual address space, for each process. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007062.xhtml#P70004970270000000000000000070CD"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.9</span></a> shows the basic idea. In the example, the page table for process <var class="calibre5 pcalibre pcalibre1">i</var> maps VP 1 to PP 2 and VP 2 to PP 7. Similarly, the page table for process <var class="calibre5 pcalibre pcalibre1">j</var> maps VP 1 to PP 7 and VP 2 to PP 10. Notice that multiple virtual pages can be mapped to the same shared physical page.</p>
<p id="P700049702700000000000000004591E" data-uri="chapter09.xhtml#P700049702700000000000000004591E" class="pcalibre1 pcalibre calibre2">The combination of demand paging and separate virtual address spaces has a profound impact on the way that memory is used and managed in a system. In particular, VM simplifies linking and loading, the sharing of code and data, and allocating memory to applications.</p>
<ul id="P700049702700000000000000004591F" data-uri="chapter09.xhtml#P700049702700000000000000004591F" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000045920" data-uri="chapter09.xhtml#P7000497027000000000000000045920" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045921" data-uri="chapter09.xhtml#P7000497027000000000000000045921" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Simplifying linking. </span>A separate address space allows each process to use the same basic format for its memory image, regardless of where the code and data actually reside in physical memory. For example, as we saw in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000070F6.xhtml#P700049702700000000000000000713C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.13</span></a>, every process on a given Linux system has a similar memory format. For 64-bit address spaces, the code segment <i class="calibre5 pcalibre pcalibre1">always</i> starts at virtual address <code id="P7000497027000000000000000045922" data-uri="chapter09.xhtml#P7000497027000000000000000045922" class="pcalibre1 calibre8 pcalibre">0x400000</code>. The data segment follows the code segment after a suitable alignment gap. The stack occupies the highest portion of the user process address space and <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000070DC" title="812" data-uri="chapter09.xhtml#P70004970270000000000000000070DC" epub:type="pagebreak"></span>grows downward. Such uniformity greatly simplifies the design and implementation of linkers, allowing them to produce fully linked executables that are independent of the ultimate location of the code and data in physical memory.</p></li>
<li id="P7000497027000000000000000045923" data-uri="chapter09.xhtml#P7000497027000000000000000045923" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045924" data-uri="chapter09.xhtml#P7000497027000000000000000045924" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Simplifying loading. </span>Virtual memory also makes it easy to load executable and shared object files into memory. To load the <code id="P7000497027000000000000000045925" data-uri="chapter09.xhtml#P7000497027000000000000000045925" class="pcalibre1 calibre8 pcalibre">.text</code> and <code id="P7000497027000000000000000045926" data-uri="chapter09.xhtml#P7000497027000000000000000045926" class="pcalibre1 calibre8 pcalibre">.data</code> sections of an object file into a newly created process, the Linux loader allocates virtual pages for the code and data segments, marks them as invalid (i.e., not cached), and points their page table entries to the appropriate locations in the object file. The interesting point is that the loader never actually copies any data from disk into memory. The data are paged in automatically and on demand by the virtual memory system the first time each page is referenced, either by the CPU when it fetches an instruction or by an executing instruction when it references a memory location.</p>
<p id="P7000497027000000000000000045927" data-uri="chapter09.xhtml#P7000497027000000000000000045927" class="pcalibre1 calibre32 pcalibre">This notion of mapping a set of contiguous virtual pages to an arbitrary location in an arbitrary file is known as <i class="calibre5 pcalibre pcalibre1">memory mapping.</i> Linux provides a system call called <code id="P7000497027000000000000000045928" data-uri="chapter09.xhtml#P7000497027000000000000000045928" class="pcalibre1 calibre8 pcalibre">mmap</code> that allows application programs to do their own memory mapping. We will describe application-level memory mapping in more detail in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000072B5.xhtml#P70004970270000000000000000072B5"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">9.8</span></a>.</p></li>
<li id="P7000497027000000000000000045929" data-uri="chapter09.xhtml#P7000497027000000000000000045929" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004592A" data-uri="chapter09.xhtml#P700049702700000000000000004592A" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Simplifying sharing. </span>Separate address spaces provide the operating system with a consistent mechanism for managing sharing between user processes and the operating system itself. In general, each process has its own private code, data, heap, and stack areas that are not shared with any other process. In this case, the operating system creates page tables that map the corresponding virtual pages to disjoint physical pages.</p>
<p id="P700049702700000000000000004592B" data-uri="chapter09.xhtml#P700049702700000000000000004592B" class="pcalibre1 calibre32 pcalibre">However, in some instances it is desirable for processes to share code and data. For example, every process must call the same operating system kernel code, and every C program makes calls to routines in the standard C library such as <code id="P700049702700000000000000004592C" data-uri="chapter09.xhtml#P700049702700000000000000004592C" class="pcalibre1 calibre8 pcalibre">printf</code>. Rather than including separate copies of the kernel and standard C library in each process, the operating system can arrange for multiple processes to share a single copy of this code by mapping the appropriate virtual pages in different processes to the same physical pages, as we saw in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007062.xhtml#P70004970270000000000000000070CD"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.9</span></a>.</p></li>
<li id="P700049702700000000000000004592D" data-uri="chapter09.xhtml#P700049702700000000000000004592D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004592E" data-uri="chapter09.xhtml#P700049702700000000000000004592E" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Simplifying memory allocation. </span>Virtual memory provides a simple mechanism for allocating additional memory to user processes. When a program running in a user process requests additional heap space (e.g., as a result of calling <code id="P700049702700000000000000004592F" data-uri="chapter09.xhtml#P700049702700000000000000004592F" class="pcalibre1 calibre8 pcalibre">malloc</code>), the operating system allocates an appropriate number, say, <var class="calibre5 pcalibre pcalibre1">k</var>, of contiguous virtual memory pages, and maps them to <var class="calibre5 pcalibre pcalibre1">k</var> arbitrary physical pages located anywhere in physical memory. Because of the way page tables work, there is no need for the operating system to locate <var class="calibre5 pcalibre pcalibre1">k</var> contiguous pages of physical memory. The pages can be scattered randomly in physical memory.</p></li>
</ul>
</section></body></html>
