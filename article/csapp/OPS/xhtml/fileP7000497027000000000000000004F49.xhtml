<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.12 Understanding Memory Performance</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000004F49" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P70004970270000000000000000436AF" data-uri="chapter05.xhtml#P70004970270000000000000000436AF" epub:type="title"><span class="pcalibre label pcalibre1">5.12 </span>Understanding Memory Performance</h1></header>
<p id="P70004970270000000000000000436B0" data-uri="chapter05.xhtml#P70004970270000000000000000436B0" class="pcalibre1 pcalibre calibre2">All of the code we have written thus far, and all the tests we have run, access relatively small amounts of memory. For example, the combining routines were measured over vectors of length less than 1,000 elements, requiring no more than 8,000 bytes of data. All modern processors contain one or more <i class="calibre5 pcalibre pcalibre1">cache</i> memories to provide fast access to such small amounts of memory. In this section, we will further investigate the performance of programs that involve load (reading from memory into registers) and store (writing from registers to memory) operations, considering only the cases where all data are held in cache. In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000005190.xhtml#P7000497027000000000000000005190"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">6</span></a>, we go into much more detail about how caches work, their performance characteristics, and how to write code that makes best use of caches.</p>
<p id="P70004970270000000000000000436B1" data-uri="chapter05.xhtml#P70004970270000000000000000436B1" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004F4D" title="554" data-uri="chapter05.xhtml#P7000497027000000000000000004F4D" epub:type="pagebreak"></span>As <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004B76"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.11</span></a> shows, modern processors have dedicated functional units to perform load and store operations, and these units have internal buffers to hold sets of outstanding requests for memory operations. For example, our reference machine has two load units, each of which can holdup to 72 pending read requests. It has a single store unit with a store buffer containing up to 42 write requests. Each of these units can initiate 1 operation every clock cycle.</p>
<section id="P7000497027000000000000000004F4E" data-uri="chapter05.xhtml#P7000497027000000000000000004F4E" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000436B2" data-uri="chapter05.xhtml#P70004970270000000000000000436B2" epub:type="title"><span class="pcalibre label pcalibre1">5.12.1 </span>Load Performance</h1></header>
<p id="P70004970270000000000000000436B3" data-uri="chapter05.xhtml#P70004970270000000000000000436B3" class="pcalibre1 pcalibre calibre2">The performance of a program containing load operations depends on both the pipelining capability and the latency of the load unit. In our experiments with combining operations using our reference machine, we saw that the CPE never got below 0.50 for any combination of data type and combining operation, except when using SIMD operations. One factor limiting the CPE for our examples is that they all require reading one value from memory for each element computed. With two load units, each able to initiate at most 1 load operation every clock cycle, the CPE cannot be less than 0.50. For applications where we must load <var class="calibre5 pcalibre pcalibre1">k</var> values for every element computed, we can never achieve a CPE lower than <var class="calibre5 pcalibre pcalibre1">k</var>/2 (see, for example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050AF"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">5.15</span></a>).</p>
<p id="P70004970270000000000000000436B4" data-uri="chapter05.xhtml#P70004970270000000000000000436B4" class="pcalibre1 pcalibre calibre2">In our examples so far, we have not seen any performance effects due to the latency of load operations. The addresses for our load operations depended only on the loop index <var class="calibre5 pcalibre pcalibre1">i</var>, and so the load operations did not form part of a performance-limiting critical path.</p>
<p id="P70004970270000000000000000436B5" data-uri="chapter05.xhtml#P70004970270000000000000000436B5" class="pcalibre1 pcalibre calibre2">To determine the latency of the load operation on a machine, we can set up a computation with a sequence of load operations, where the outcome of one determines the address for the next. As an example, consider the function <code id="P70004970270000000000000000436B6" data-uri="chapter05.xhtml#P70004970270000000000000000436B6" class="pcalibre1 calibre8 pcalibre">list_len</code> in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004F57"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.31</span></a>, which computes the length of a linked list. In the loop of this function, each successive value of variable <code id="P70004970270000000000000000436B7" data-uri="chapter05.xhtml#P70004970270000000000000000436B7" class="pcalibre1 calibre8 pcalibre">ls</code> depends on the value read by the pointer reference <code id="P70004970270000000000000000436B8" data-uri="chapter05.xhtml#P70004970270000000000000000436B8" class="pcalibre1 calibre8 pcalibre">ls-&gt;next</code>. Our measurements show that function <code id="P70004970270000000000000000436B9" data-uri="chapter05.xhtml#P70004970270000000000000000436B9" class="pcalibre1 calibre8 pcalibre">list_len</code> has</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004F57" data-uri="chapter05.xhtml#P7000497027000000000000000004F57">

<pre id="P70004970270000000000000000436BA" data-uri="chapter05.xhtml#P70004970270000000000000000436BA" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000436BB" data-uri="chapter05.xhtml#P70004970270000000000000000436BB" class="calibre10 pcalibre pcalibre1">
1	typedef struct ELE {
2		struct ELE *next;
3		long data;
4	} list_ele, *list_ptr; 5
6	long list_len(list_ptr ls) {
7		long len = 0;
8		while (ls) {
9			len++;
10			ls = ls-&gt;next;
11		}
12		return len;
13	}
</code></pre>
<figcaption id="P70004970270000000000000000436BC" data-uri="chapter05.xhtml#P70004970270000000000000000436BC" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000436BD" data-uri="chapter05.xhtml#P70004970270000000000000000436BD" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.31 </span>Linked list function.</h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000436BE" data-uri="chapter05.xhtml#P70004970270000000000000000436BE"><p id="P70004970270000000000000000436BF" data-uri="chapter05.xhtml#P70004970270000000000000000436BF" class="pcalibre calibre3 pcalibre1">Its performance is limited by the latency of the load operation.</p></div></figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000436C0" data-uri="chapter05.xhtml#P70004970270000000000000000436C0"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004F5F" title="555" data-uri="chapter05.xhtml#P7000497027000000000000000004F5F" epub:type="pagebreak"></span>a CPE of 4.00, which we claim is a direct indication of the latency of the load operation. To see this, consider the assembly code for the loop:</p>
<pre id="P70004970270000000000000000436C1" data-uri="chapter05.xhtml#P70004970270000000000000000436C1" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000436C2" data-uri="chapter05.xhtml#P70004970270000000000000000436C2" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">Inner loop of list_len</i>
	<i class="calibre5 pcalibre pcalibre1">ls in %rdi, len in %rax</i>
1	.L3:			<b class="calibre4 pcalibre pcalibre1">loop:</b>
2	 addq $1, %rax		  <i class="calibre5 pcalibre pcalibre1">Increment len</i>
3	 movq (%rdi), %rdi	  <i class="calibre5 pcalibre pcalibre1">ls = ls-&gt;next</i>
4	 testq %rdi, %rdi	  <i class="calibre5 pcalibre pcalibre1">Test ls</i>
5	 jne .L3		  <i class="calibre5 pcalibre pcalibre1">If nonnull, goto</i> loop
</code></pre>
<p id="P70004970270000000000000000436C3" data-uri="chapter05.xhtml#P70004970270000000000000000436C3" class="pcalibre1 pcalibre calibre2">The <code id="P70004970270000000000000000436C4" data-uri="chapter05.xhtml#P70004970270000000000000000436C4" class="pcalibre1 calibre8 pcalibre">movq</code> instruction on line 3 forms the critical bottleneck in this loop. Each successive value of register <code id="P70004970270000000000000000436C5" data-uri="chapter05.xhtml#P70004970270000000000000000436C5" class="pcalibre1 calibre8 pcalibre">%rdi</code> depends on the result of a load operation having the value in <code id="P70004970270000000000000000436C6" data-uri="chapter05.xhtml#P70004970270000000000000000436C6" class="pcalibre1 calibre8 pcalibre">%rdi</code> as its address. Thus, the load operation for one iteration cannot begin until the one for the previous iteration has completed. The CPE of 4.00 for this function is determined by the latency of the load operation. Indeed, this measurement matches the documented access time of 4 cycles for the reference machine's L1 cache, as is discussed in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000556F.xhtml#P700049702700000000000000000556F"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">6.4</span></a>.</p>
</section>
<section id="P7000497027000000000000000004F66" data-uri="chapter05.xhtml#P7000497027000000000000000004F66" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000436C7" data-uri="chapter05.xhtml#P70004970270000000000000000436C7" epub:type="title"><span class="pcalibre label pcalibre1">5.12.2 </span>Store Performance</h1></header>
<p id="P70004970270000000000000000436C8" data-uri="chapter05.xhtml#P70004970270000000000000000436C8" class="pcalibre1 pcalibre calibre2">In all of our examples thus far, we analyzed only functions that reference memory mostly with load operations, reading from a memory location into a register. Its counterpart, the <i class="calibre5 pcalibre pcalibre1">store</i> operation, writes a register value to memory. The performance of this operation, particularly in relation to its interactions with load operations, involves several subtle issues.</p>
<p id="P70004970270000000000000000436C9" data-uri="chapter05.xhtml#P70004970270000000000000000436C9" class="pcalibre1 pcalibre calibre2">As with the load operation, in most cases, the store operation can operate in a fully pipelined mode, beginning a new store on every cycle. For example, consider the function shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004F6E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.32</span></a> that sets the elements of an array <code id="P70004970270000000000000000436CA" data-uri="chapter05.xhtml#P70004970270000000000000000436CA" class="pcalibre1 calibre8 pcalibre">dest</code> of length <code id="P70004970270000000000000000436CB" data-uri="chapter05.xhtml#P70004970270000000000000000436CB" class="pcalibre1 calibre8 pcalibre">n</code> to zero. Our measurements show a CPE of 1.0. This is the best we can achieve on a machine with a single store functional unit.</p>
<p id="P70004970270000000000000000436CC" data-uri="chapter05.xhtml#P70004970270000000000000000436CC" class="pcalibre1 pcalibre calibre2">Unlike the other operations we have considered so far, the store operation does not affect any register values. Thus, by their very nature, a series of store operations cannot create a data dependency. Only a load operation is affected by the result of a store operation, since only a load can read back the memory value that has been written by the store. The function <code id="P70004970270000000000000000436CD" data-uri="chapter05.xhtml#P70004970270000000000000000436CD" class="pcalibre1 calibre8 pcalibre">write_read</code> shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004F75"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.33</span></a></p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004F6E" data-uri="chapter05.xhtml#P7000497027000000000000000004F6E">

<pre id="P70004970270000000000000000436CE" data-uri="chapter05.xhtml#P70004970270000000000000000436CE" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000436CF" data-uri="chapter05.xhtml#P70004970270000000000000000436CF" class="calibre10 pcalibre pcalibre1">
1	/* Set elements of array to 0 */
2	void clear_array(long *dest, long n) {
3		long i;
4		for (i = 0; i &lt; n; i++)
5			dest[i] = 0;
6	}
</code></pre>
<figcaption id="P70004970270000000000000000436D0" data-uri="chapter05.xhtml#P70004970270000000000000000436D0" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000436D1" data-uri="chapter05.xhtml#P70004970270000000000000000436D1" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.32 </span>Function to set array elements to 0.</h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000436D2" data-uri="chapter05.xhtml#P70004970270000000000000000436D2"><p id="P70004970270000000000000000436D3" data-uri="chapter05.xhtml#P70004970270000000000000000436D3" class="pcalibre calibre3 pcalibre1">This code achieves a CPE of 1.0.</p></div></figcaption></figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004F75" data-uri="chapter05.xhtml#P7000497027000000000000000004F75">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004F76" title="556" data-uri="chapter05.xhtml#P7000497027000000000000000004F76" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000436D4" data-uri="chapter05.xhtml#P70004970270000000000000000436D4" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000436D5" data-uri="chapter05.xhtml#P70004970270000000000000000436D5" class="calibre10 pcalibre pcalibre1">
1	/* Write to dest, read from src */
2	void write_read(long *src, long *dst, long n)
3	{
4		long cnt = n;
5		long val = 0; 6
7		while (cnt) {
8			*dst = val;
9			val = (*src)+1;
10			cnt−;
11		}
12	}
</code></pre>
<img alt="A diagram includes a code and illustrations of two executions." id="P70004970270000000000000000436D6" data-uri="P700049702700000000000000000B722" src="../images/p556-1.png" class="calibre186 pcalibre pcalibre1"/>
<figcaption id="P70004970270000000000000000436D7" data-uri="chapter05.xhtml#P70004970270000000000000000436D7" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000436D8" data-uri="chapter05.xhtml#P70004970270000000000000000436D8" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.33 </span>Code to write and read memory locations, along with illustrative executions.</h1></header>
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000436D9" data-uri="chapter05.xhtml#P70004970270000000000000000436D9"><p id="P70004970270000000000000000436DA" data-uri="chapter05.xhtml#P70004970270000000000000000436DA" class="pcalibre calibre3 pcalibre1">This function highlights the interactions between stores and loads when arguments <code id="P70004970270000000000000000436DB" data-uri="chapter05.xhtml#P70004970270000000000000000436DB" class="pcalibre1 calibre8 pcalibre">src</code> and <code id="P70004970270000000000000000436DC" data-uri="chapter05.xhtml#P70004970270000000000000000436DC" class="pcalibre1 calibre8 pcalibre">dest</code> are equal.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000239C8" data-uri="chapter05.xhtml#P70004970270000000000000000239C8">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000436DD" data-uri="chapter05.xhtml#P70004970270000000000000000436DD" class="pcalibre1 pcalibre calibre2">The lines of the code are reproduced below.</p>
<ol id="P70004970270000000000000000436DE" data-uri="chapter05.xhtml#P70004970270000000000000000436DE" class="calibre72 pcalibre pcalibre1">
<li id="P70004970270000000000000000436DF" data-uri="chapter05.xhtml#P70004970270000000000000000436DF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436E0" data-uri="chapter05.xhtml#P70004970270000000000000000436E0" class="pcalibre calibre3 pcalibre1">/* Write to dest, read from src */</p></li>
<li id="P70004970270000000000000000436E1" data-uri="chapter05.xhtml#P70004970270000000000000000436E1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436E2" data-uri="chapter05.xhtml#P70004970270000000000000000436E2" class="pcalibre calibre3 pcalibre1">void write_read(long *src, long *dst, long n)</p></li>
<li id="P70004970270000000000000000436E3" data-uri="chapter05.xhtml#P70004970270000000000000000436E3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436E4" data-uri="chapter05.xhtml#P70004970270000000000000000436E4" class="pcalibre calibre3 pcalibre1">{</p></li>
<li id="P70004970270000000000000000436E5" data-uri="chapter05.xhtml#P70004970270000000000000000436E5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436E6" data-uri="chapter05.xhtml#P70004970270000000000000000436E6" class="pcalibre calibre3 pcalibre1">long cnt = n;</p></li>
<li id="P70004970270000000000000000436E7" data-uri="chapter05.xhtml#P70004970270000000000000000436E7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436E8" data-uri="chapter05.xhtml#P70004970270000000000000000436E8" class="pcalibre calibre3 pcalibre1">long val = 0;</p></li>
<li id="P70004970270000000000000000436E9" data-uri="chapter05.xhtml#P70004970270000000000000000436E9" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436EA" data-uri="chapter05.xhtml#P70004970270000000000000000436EA" class="pcalibre calibre3 pcalibre1">(blank)</p></li>
<li id="P70004970270000000000000000436EB" data-uri="chapter05.xhtml#P70004970270000000000000000436EB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436EC" data-uri="chapter05.xhtml#P70004970270000000000000000436EC" class="pcalibre calibre3 pcalibre1">while (cnt) {</p></li>
<li id="P70004970270000000000000000436ED" data-uri="chapter05.xhtml#P70004970270000000000000000436ED" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436EE" data-uri="chapter05.xhtml#P70004970270000000000000000436EE" class="pcalibre calibre3 pcalibre1"> *dst = val;</p></li>
<li id="P70004970270000000000000000436EF" data-uri="chapter05.xhtml#P70004970270000000000000000436EF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436F0" data-uri="chapter05.xhtml#P70004970270000000000000000436F0" class="pcalibre calibre3 pcalibre1"> val = (*src)+1;</p></li>
<li id="P70004970270000000000000000436F1" data-uri="chapter05.xhtml#P70004970270000000000000000436F1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436F2" data-uri="chapter05.xhtml#P70004970270000000000000000436F2" class="pcalibre calibre3 pcalibre1"> cnt–;</p></li>
<li id="P70004970270000000000000000436F3" data-uri="chapter05.xhtml#P70004970270000000000000000436F3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436F4" data-uri="chapter05.xhtml#P70004970270000000000000000436F4" class="pcalibre calibre3 pcalibre1"> }</p></li>
<li id="P70004970270000000000000000436F5" data-uri="chapter05.xhtml#P70004970270000000000000000436F5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000436F6" data-uri="chapter05.xhtml#P70004970270000000000000000436F6" class="pcalibre calibre3 pcalibre1">}</p></li>
</ol>
<p id="P70004970270000000000000000436F7" data-uri="chapter05.xhtml#P70004970270000000000000000436F7" class="pcalibre1 pcalibre calibre2">The two execution illustrations are arranged per the following tables.</p>
<table id="P70004970270000000000000000436F8" data-uri="chapter05.xhtml#P70004970270000000000000000436F8" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th colspan="5" id="P70004970270000000000000000436F9" data-uri="chapter05.xhtml#P70004970270000000000000000436F9" class="calibre18 pcalibre pcalibre1">Example A: write_read(&amp;a[0], &amp;a[1], 3)</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P70004970270000000000000000436FA" data-uri="chapter05.xhtml#P70004970270000000000000000436FA" class="calibre18 pcalibre pcalibre1"/>
<th id="P70004970270000000000000000436FB" data-uri="chapter05.xhtml#P70004970270000000000000000436FB" class="calibre18 pcalibre pcalibre1">Initial</th>
<th id="P70004970270000000000000000436FC" data-uri="chapter05.xhtml#P70004970270000000000000000436FC" class="calibre18 pcalibre pcalibre1">Iter. 1</th>
<th id="P70004970270000000000000000436FD" data-uri="chapter05.xhtml#P70004970270000000000000000436FD" class="calibre18 pcalibre pcalibre1">Iter. 2</th>
<th id="P70004970270000000000000000436FE" data-uri="chapter05.xhtml#P70004970270000000000000000436FE" class="calibre18 pcalibre pcalibre1">Iter. 3</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P70004970270000000000000000436FF" data-uri="chapter05.xhtml#P70004970270000000000000000436FF" class="calibre20 pcalibre pcalibre1">cnt</td>
<td id="P7000497027000000000000000043700" data-uri="chapter05.xhtml#P7000497027000000000000000043700" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P7000497027000000000000000043701" data-uri="chapter05.xhtml#P7000497027000000000000000043701" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P7000497027000000000000000043702" data-uri="chapter05.xhtml#P7000497027000000000000000043702" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000043703" data-uri="chapter05.xhtml#P7000497027000000000000000043703" class="calibre20 pcalibre pcalibre1">0</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043704" data-uri="chapter05.xhtml#P7000497027000000000000000043704" class="calibre20 pcalibre pcalibre1">a</td>
<td id="P7000497027000000000000000043705" data-uri="chapter05.xhtml#P7000497027000000000000000043705" class="calibre20 pcalibre pcalibre1">Negative 10 and 17</td>
<td id="P7000497027000000000000000043706" data-uri="chapter05.xhtml#P7000497027000000000000000043706" class="calibre20 pcalibre pcalibre1">Negative 10 and 2</td>
<td id="P7000497027000000000000000043707" data-uri="chapter05.xhtml#P7000497027000000000000000043707" class="calibre20 pcalibre pcalibre1">Negative 10 and negative 9</td>
<td id="P7000497027000000000000000043708" data-uri="chapter05.xhtml#P7000497027000000000000000043708" class="calibre20 pcalibre pcalibre1">Negative 10 and negative 9</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043709" data-uri="chapter05.xhtml#P7000497027000000000000000043709" class="calibre20 pcalibre pcalibre1">val</td>
<td id="P700049702700000000000000004370A" data-uri="chapter05.xhtml#P700049702700000000000000004370A" class="calibre20 pcalibre pcalibre1">0</td>
<td id="P700049702700000000000000004370B" data-uri="chapter05.xhtml#P700049702700000000000000004370B" class="calibre20 pcalibre pcalibre1">Negative 9</td>
<td id="P700049702700000000000000004370C" data-uri="chapter05.xhtml#P700049702700000000000000004370C" class="calibre20 pcalibre pcalibre1">Negative 9</td>
<td id="P700049702700000000000000004370D" data-uri="chapter05.xhtml#P700049702700000000000000004370D" class="calibre20 pcalibre pcalibre1">Negative 9</td>
</tr>
</tbody>
</table>
<table id="P700049702700000000000000004370E" data-uri="chapter05.xhtml#P700049702700000000000000004370E" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th colspan="5" id="P700049702700000000000000004370F" data-uri="chapter05.xhtml#P700049702700000000000000004370F" class="calibre18 pcalibre pcalibre1">Example B: write_read(&amp;a[0], &amp;a[0], 3)</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000043710" data-uri="chapter05.xhtml#P7000497027000000000000000043710" class="calibre18 pcalibre pcalibre1"/>
<th id="P7000497027000000000000000043711" data-uri="chapter05.xhtml#P7000497027000000000000000043711" class="calibre18 pcalibre pcalibre1">Initial</th>
<th id="P7000497027000000000000000043712" data-uri="chapter05.xhtml#P7000497027000000000000000043712" class="calibre18 pcalibre pcalibre1">Iter. 1</th>
<th id="P7000497027000000000000000043713" data-uri="chapter05.xhtml#P7000497027000000000000000043713" class="calibre18 pcalibre pcalibre1">Iter. 2</th>
<th id="P7000497027000000000000000043714" data-uri="chapter05.xhtml#P7000497027000000000000000043714" class="calibre18 pcalibre pcalibre1">Iter. 3</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043715" data-uri="chapter05.xhtml#P7000497027000000000000000043715" class="calibre20 pcalibre pcalibre1">cnt</td>
<td id="P7000497027000000000000000043716" data-uri="chapter05.xhtml#P7000497027000000000000000043716" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P7000497027000000000000000043717" data-uri="chapter05.xhtml#P7000497027000000000000000043717" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P7000497027000000000000000043718" data-uri="chapter05.xhtml#P7000497027000000000000000043718" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000043719" data-uri="chapter05.xhtml#P7000497027000000000000000043719" class="calibre20 pcalibre pcalibre1">0</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004371A" data-uri="chapter05.xhtml#P700049702700000000000000004371A" class="calibre20 pcalibre pcalibre1">a</td>
<td id="P700049702700000000000000004371B" data-uri="chapter05.xhtml#P700049702700000000000000004371B" class="calibre20 pcalibre pcalibre1">Negative 10 and 17</td>
<td id="P700049702700000000000000004371C" data-uri="chapter05.xhtml#P700049702700000000000000004371C" class="calibre20 pcalibre pcalibre1">Negative 0 and 17</td>
<td id="P700049702700000000000000004371D" data-uri="chapter05.xhtml#P700049702700000000000000004371D" class="calibre20 pcalibre pcalibre1">1 and 17</td>
<td id="P700049702700000000000000004371E" data-uri="chapter05.xhtml#P700049702700000000000000004371E" class="calibre20 pcalibre pcalibre1">2 and 17</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004371F" data-uri="chapter05.xhtml#P700049702700000000000000004371F" class="calibre20 pcalibre pcalibre1">val</td>
<td id="P7000497027000000000000000043720" data-uri="chapter05.xhtml#P7000497027000000000000000043720" class="calibre20 pcalibre pcalibre1">0</td>
<td id="P7000497027000000000000000043721" data-uri="chapter05.xhtml#P7000497027000000000000000043721" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000043722" data-uri="chapter05.xhtml#P7000497027000000000000000043722" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P7000497027000000000000000043723" data-uri="chapter05.xhtml#P7000497027000000000000000043723" class="calibre20 pcalibre pcalibre1">3</td>
</tr>
</tbody>
</table>
</details>

</figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043724" data-uri="chapter05.xhtml#P7000497027000000000000000043724">illustrates the potential interactions between loads and stores. This figure also shows two example executions of this function, when it is called for a two-element array a, with initial contents −10 and 17, and with argument <code id="P7000497027000000000000000043725" data-uri="chapter05.xhtml#P7000497027000000000000000043725" class="pcalibre1 calibre8 pcalibre">cnt</code> equal to 3. These executions illustrate some subtleties of the load and store operations.</p>
<p id="P7000497027000000000000000043726" data-uri="chapter05.xhtml#P7000497027000000000000000043726" class="pcalibre1 pcalibre calibre2">In Example A of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004F75"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.33</span></a>, argument <code id="P7000497027000000000000000043727" data-uri="chapter05.xhtml#P7000497027000000000000000043727" class="pcalibre1 calibre8 pcalibre">src</code> is a pointer to array element <code id="P7000497027000000000000000043728" data-uri="chapter05.xhtml#P7000497027000000000000000043728" class="pcalibre1 calibre8 pcalibre">a[0]</code>, while <code id="P7000497027000000000000000043729" data-uri="chapter05.xhtml#P7000497027000000000000000043729" class="pcalibre1 calibre8 pcalibre">dest</code> is a pointer to array element <code id="P700049702700000000000000004372A" data-uri="chapter05.xhtml#P700049702700000000000000004372A" class="pcalibre1 calibre8 pcalibre">a[1]</code>. In this case, each load by the pointer reference <code id="P700049702700000000000000004372B" data-uri="chapter05.xhtml#P700049702700000000000000004372B" class="pcalibre1 calibre8 pcalibre">*src</code> will yield the value −10. Hence, after two iterations, the array elements will remain fixed at −10 and −9, respectively. The result of the read from <code id="P700049702700000000000000004372C" data-uri="chapter05.xhtml#P700049702700000000000000004372C" class="pcalibre1 calibre8 pcalibre">src</code> is not affected by the write to <code id="P700049702700000000000000004372D" data-uri="chapter05.xhtml#P700049702700000000000000004372D" class="pcalibre1 calibre8 pcalibre">dest</code>. Measuring this example over a larger number of iterations gives a CPE of 1.3.</p>
<p id="P700049702700000000000000004372E" data-uri="chapter05.xhtml#P700049702700000000000000004372E" class="pcalibre1 pcalibre calibre2">In Example B of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004F75"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.33</span></a>, both arguments <code id="P700049702700000000000000004372F" data-uri="chapter05.xhtml#P700049702700000000000000004372F" class="pcalibre1 calibre8 pcalibre">src</code> and <code id="P7000497027000000000000000043730" data-uri="chapter05.xhtml#P7000497027000000000000000043730" class="pcalibre1 calibre8 pcalibre">dest</code> are pointers to array element <code id="P7000497027000000000000000043731" data-uri="chapter05.xhtml#P7000497027000000000000000043731" class="pcalibre1 calibre8 pcalibre">a[0]</code>. In this case, each load by the pointer reference <code id="P7000497027000000000000000043732" data-uri="chapter05.xhtml#P7000497027000000000000000043732" class="pcalibre1 calibre8 pcalibre">*src</code> will yield the value stored by the previous execution of the pointer reference <code id="P7000497027000000000000000043733" data-uri="chapter05.xhtml#P7000497027000000000000000043733" class="pcalibre1 calibre8 pcalibre">*dest</code>.</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004F90" data-uri="chapter05.xhtml#P7000497027000000000000000004F90">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004F91" title="557" data-uri="chapter05.xhtml#P7000497027000000000000000004F91" epub:type="pagebreak"></span>
<img alt="A diagram depicts interactions between load unit, store unit, and data cache." id="P7000497027000000000000000043734" data-uri="P700049702700000000000000000B723" src="../images/p557-1.png" class="calibre187 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000043735" data-uri="chapter05.xhtml#P7000497027000000000000000043735" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000043736" data-uri="chapter05.xhtml#P7000497027000000000000000043736" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.34 </span>Detail of load and store units.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043737" data-uri="chapter05.xhtml#P7000497027000000000000000043737"><p id="P7000497027000000000000000043738" data-uri="chapter05.xhtml#P7000497027000000000000000043738" class="pcalibre calibre3 pcalibre1">The store unit maintains a buffer of pending writes. The load unit must check its address with those in the store unit to detect a write/read dependency.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000023A25" data-uri="chapter05.xhtml#P7000497027000000000000000023A25">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000043739" data-uri="chapter05.xhtml#P7000497027000000000000000043739" class="pcalibre calibre3 pcalibre1">A diagram shows a load unit sending address to store unit and data cache and receiving data from each. The store unit includes the store buffer, composed of matching addresses within address and data, each of which is sent to data cache.</p>
</details>
</figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004373A" data-uri="chapter05.xhtml#P700049702700000000000000004373A">As a consequence, a series of ascending values will be stored in this location. In general, if function <code id="P700049702700000000000000004373B" data-uri="chapter05.xhtml#P700049702700000000000000004373B" class="pcalibre1 calibre8 pcalibre">write_read</code> is called with arguments <code id="P700049702700000000000000004373C" data-uri="chapter05.xhtml#P700049702700000000000000004373C" class="pcalibre1 calibre8 pcalibre">src</code> and <code id="P700049702700000000000000004373D" data-uri="chapter05.xhtml#P700049702700000000000000004373D" class="pcalibre1 calibre8 pcalibre">dest</code> pointing to the same memory location, and with argument <code id="P700049702700000000000000004373E" data-uri="chapter05.xhtml#P700049702700000000000000004373E" class="pcalibre1 calibre8 pcalibre">cnt</code> having some value <var class="calibre5 pcalibre pcalibre1">n</var> &gt; 0, the net effect is to set the location to <var class="calibre5 pcalibre pcalibre1">n</var> − 1. This example illustrates a phenomenon we will call a <i class="calibre5 pcalibre pcalibre1">write/read dependency</i>—the outcome of a memory read depends on a recent memory write. Our performance measurements show that Example B has a CPE of 7.3. The write/read dependency causes a slowdown in the processing of around 6 clock cycles.</p>
<p id="P700049702700000000000000004373F" data-uri="chapter05.xhtml#P700049702700000000000000004373F" class="pcalibre1 pcalibre calibre2">To see how the processor can distinguish between these two cases and why one runs slower than the other, we must take a more detailed look at the load and store execution units, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004F90"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.34</span></a>. The store unit includes a <i class="calibre5 pcalibre pcalibre1">store buffer</i> containing the addresses and data of the store operations that have been issued to the store unit, but have not yet been completed, where completion involves updating the data cache. This buffer is provided so that a series of store operations can be executed without having to wait for each one to update the cache. When a load operation occurs, it must check the entries in the store buffer for matching addresses. If it finds a match (meaning that any of the bytes being written have the same address as any of the bytes being read), it retrieves the corresponding data entry as the result of the load operation.</p>
<p id="P7000497027000000000000000043740" data-uri="chapter05.xhtml#P7000497027000000000000000043740" class="pcalibre1 pcalibre calibre2"><span class="smallcaps pcalibre pcalibre1">gcc </span>generates the following code for the inner loop of <code id="P7000497027000000000000000043741" data-uri="chapter05.xhtml#P7000497027000000000000000043741" class="pcalibre1 calibre8 pcalibre">write_read</code>:</p>
<pre id="P7000497027000000000000000043742" data-uri="chapter05.xhtml#P7000497027000000000000000043742" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043743" data-uri="chapter05.xhtml#P7000497027000000000000000043743" class="calibre10 pcalibre pcalibre1">
<i class="calibre5 pcalibre pcalibre1">Inner loop of write_read</i>
<i class="calibre5 pcalibre pcalibre1">src in %rdi, dst in %rsi, val in %rax</i>
.L3:			<b class="calibre4 pcalibre pcalibre1">loop:</b>
 movq	%rax, (%rsi)	  <i class="calibre5 pcalibre pcalibre1">Write val to dst</i>
 movq	(%rdi), %rax	  <i class="calibre5 pcalibre pcalibre1">t = *src</i>
 addq	$1, %rax	  <i class="calibre5 pcalibre pcalibre1">val = t+1</i>
 subq	$1, %rdx	  <i class="calibre5 pcalibre pcalibre1">cnt−</i>
 jne	. L3		  <i class="calibre5 pcalibre pcalibre1">If != 0, goto</i> <b class="calibre4 pcalibre pcalibre1">loop</b>
</code></pre>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004FA1" data-uri="chapter05.xhtml#P7000497027000000000000000004FA1">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004FA2" title="558" data-uri="chapter05.xhtml#P7000497027000000000000000004FA2" epub:type="pagebreak"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for write_read." id="P7000497027000000000000000043744" data-uri="P700049702700000000000000000B724" src="../images/p558-1.png" class="pcalibre calibre188 pcalibre1"/>
<figcaption id="P7000497027000000000000000043745" data-uri="chapter05.xhtml#P7000497027000000000000000043745" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000043746" data-uri="chapter05.xhtml#P7000497027000000000000000043746" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">5.35 </span>Graphical representation of inner-loop code for <code id="P7000497027000000000000000043747" data-uri="chapter05.xhtml#P7000497027000000000000000043747" class="pcalibre1 calibre8 pcalibre">write_read</code>.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043748" data-uri="chapter05.xhtml#P7000497027000000000000000043748"><p id="P7000497027000000000000000043749" data-uri="chapter05.xhtml#P7000497027000000000000000043749" class="pcalibre calibre3 pcalibre1">The first <code id="P700049702700000000000000004374A" data-uri="chapter05.xhtml#P700049702700000000000000004374A" class="pcalibre1 calibre8 pcalibre">movl</code> instruction is decoded into separate operations to compute the store address and to store the data to memory.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000023A38" data-uri="chapter05.xhtml#P7000497027000000000000000023A38">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P700049702700000000000000004374B" data-uri="chapter05.xhtml#P700049702700000000000000004374B" class="pcalibre1 pcalibre calibre2">A diagram has two rows of boxes, each with %rax, %rdi, %rsi, and %rdx, with output from top %rdi and %rsi to bottom %rdi and %rsi, respectively. A column of boxes includes the six operations summarized below, from top to bottom:</p>
<ul id="P700049702700000000000000004374C" data-uri="chapter05.xhtml#P700049702700000000000000004374C" class="pcalibre calibre31 pcalibre1">
<li id="P700049702700000000000000004374D" data-uri="chapter05.xhtml#P700049702700000000000000004374D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004374E" data-uri="chapter05.xhtml#P700049702700000000000000004374E" class="pcalibre calibre3 pcalibre1">s_addr: receives input from top %rsi and sends output to s_data and load operations below</p></li>
<li id="P700049702700000000000000004374F" data-uri="chapter05.xhtml#P700049702700000000000000004374F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043750" data-uri="chapter05.xhtml#P7000497027000000000000000043750" class="pcalibre calibre3 pcalibre1">s_data: receives input from s_addr, with the two together representing movq %rax, (%rsi); receives input from top %rax and sends output to load below</p></li>
<li id="P7000497027000000000000000043751" data-uri="chapter05.xhtml#P7000497027000000000000000043751" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043752" data-uri="chapter05.xhtml#P7000497027000000000000000043752" class="pcalibre calibre3 pcalibre1">Load (movq (%rdi), %rax): receives input from s_addr, s_data, and top %rdi; sends output to add below</p></li>
<li id="P7000497027000000000000000043753" data-uri="chapter05.xhtml#P7000497027000000000000000043753" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043754" data-uri="chapter05.xhtml#P7000497027000000000000000043754" class="pcalibre calibre3 pcalibre1">add (addq $1, %rax): receives input from load and sends output to bottom %rax</p></li>
<li id="P7000497027000000000000000043755" data-uri="chapter05.xhtml#P7000497027000000000000000043755" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043756" data-uri="chapter05.xhtml#P7000497027000000000000000043756" class="pcalibre calibre3 pcalibre1">sub (subq $1, %rdx): receives input from top %rdx and sends output to bottom %rdx and jne below</p></li>
<li id="P7000497027000000000000000043757" data-uri="chapter05.xhtml#P7000497027000000000000000043757" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043758" data-uri="chapter05.xhtml#P7000497027000000000000000043758" class="pcalibre calibre3 pcalibre1">jne (jne loop): receives input from sub and sends output to bottom %rdx</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043759" data-uri="chapter05.xhtml#P7000497027000000000000000043759"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004FA1"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.35</span></a> shows a data-flow representation of this loop code. The instruction <code id="P700049702700000000000000004375A" data-uri="chapter05.xhtml#P700049702700000000000000004375A" class="pcalibre1 calibre8 pcalibre">movq %rax,(%rsi)</code> is translated into two operations: The s_addr instruction computes the address for the store operation, creates an entry in the store buffer, and sets the address field for that entry. The s_data operation sets the data field for the entry. As we will see, the fact that these two computations are performed independently can be important to program performance. This motivates the separate functional units for these operations in the reference machine.</p>
<p id="P700049702700000000000000004375B" data-uri="chapter05.xhtml#P700049702700000000000000004375B" class="pcalibre1 pcalibre calibre2">In addition to the data dependencies between the operations caused by the writing and reading of registers, the arcs on the right of the operators denote a set of implicit dependencies for these operations. In particular, the address computation of the s_addr operation must clearly precede the s_data operation. In addition, the load operation generated by decoding the instruction <code id="P700049702700000000000000004375C" data-uri="chapter05.xhtml#P700049702700000000000000004375C" class="pcalibre1 calibre8 pcalibre">movq</code> <code id="P700049702700000000000000004375D" data-uri="chapter05.xhtml#P700049702700000000000000004375D" class="pcalibre1 calibre8 pcalibre">(%rdi), %rax</code> must check the addresses of any pending store operations, creating a data dependency between it and the s_addr operation. The figure shows a dashed arc between the s_data and load operations. This dependency is conditional: if the two addresses match, the load operation must wait until the s_data has deposited its result into the store buffer, but if the two addresses differ, the two operations can proceed independently.</p>
<p id="P700049702700000000000000004375E" data-uri="chapter05.xhtml#P700049702700000000000000004375E" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004FB3"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.36</span></a> illustrates the data dependencies between the operations for the inner loop of <code id="P700049702700000000000000004375F" data-uri="chapter05.xhtml#P700049702700000000000000004375F" class="pcalibre1 calibre8 pcalibre">write_read</code>. In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004FB3"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.36(a)</span></a>, we have rearranged the operations to allow the dependencies to be seen more clearly. We have labeled the three dependencies involving the load and store operations for special attention. The arc labeled "1" represents the requirement that the store address must be computed before the data can be stored. The arc labeled "2" represents the need for the load operation to compare its address with that for any pending store operations. Finally, the dashed arc labeled "3" represents the conditional data dependency that arises when the load and store addresses match.</p>
<p id="P7000497027000000000000000043760" data-uri="chapter05.xhtml#P7000497027000000000000000043760" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004FB3"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.36(b)</span></a> illustrates what happens when we take away those operations that do not directly affect the flow of data from one iteration to the next. The data-flow graph shows just two chains of dependencies: the one on the left, with data values being stored, loaded, and incremented (only for the case of matching addresses); and the one on the right, decrementing variable <code id="P7000497027000000000000000043761" data-uri="chapter05.xhtml#P7000497027000000000000000043761" class="pcalibre1 calibre8 pcalibre">cnt</code>.</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004FB3" data-uri="chapter05.xhtml#P7000497027000000000000000004FB3">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004FB4" title="559" data-uri="chapter05.xhtml#P7000497027000000000000000004FB4" epub:type="pagebreak"></span>
<img alt="A diagram depicts two data-flow graphs for write_read." id="P7000497027000000000000000043762" data-uri="P700049702700000000000000000B725" src="../images/p559-1.png" class="pcalibre1 pcalibre calibre189"/>
<figcaption id="P7000497027000000000000000043763" data-uri="chapter05.xhtml#P7000497027000000000000000043763" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000043764" data-uri="chapter05.xhtml#P7000497027000000000000000043764" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">5.36 </span>Abstracting the operations for <code id="P7000497027000000000000000043765" data-uri="chapter05.xhtml#P7000497027000000000000000043765" class="pcalibre1 calibre8 pcalibre">write_read</code>.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043766" data-uri="chapter05.xhtml#P7000497027000000000000000043766"><p id="P7000497027000000000000000043767" data-uri="chapter05.xhtml#P7000497027000000000000000043767" class="pcalibre calibre3 pcalibre1">We first rearrange the operators of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004FA1"><span class="pcalibre label pcalibre1">Figure </span><span class="number pcalibre pcalibre1">5.35(a)</span></a> and then show only those operations that use values from one iteration to produce new values for the next (b).</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000023A56" data-uri="chapter05.xhtml#P7000497027000000000000000023A56">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<ol class="pcalibre1 pcalibre ol_lower-alpha1" id="P7000497027000000000000000043768" data-uri="chapter05.xhtml#P7000497027000000000000000043768">
<li id="P7000497027000000000000000043769" data-uri="chapter05.xhtml#P7000497027000000000000000043769" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004376A" data-uri="chapter05.xhtml#P700049702700000000000000004376A" class="pcalibre calibre3 pcalibre1">Data flows from top %rax to s_data to load (numbered 3) to add to bottom %rax; from %rdi to load; from %rsi to s_addr, with 1 to s_data and 2 to load; top %rdx to sub, which moves to jne and bottom %rdx.</p></li>
<li id="P700049702700000000000000004376B" data-uri="chapter05.xhtml#P700049702700000000000000004376B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004376C" data-uri="chapter05.xhtml#P700049702700000000000000004376C" class="pcalibre calibre3 pcalibre1">Data flows from top %rax through s_data, load, and add to bottom %rax; from top %rdx to sub to bottom %rdx.</p></li>
</ol>
</details>
</figcaption></figure>
<p id="P700049702700000000000000004376D" data-uri="chapter05.xhtml#P700049702700000000000000004376D" class="pcalibre1 pcalibre calibre2">We can now understand the performance characteristics of function <code id="P700049702700000000000000004376E" data-uri="chapter05.xhtml#P700049702700000000000000004376E" class="pcalibre1 calibre8 pcalibre">write_read</code>. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004FC7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.37</span></a> illustrates the data dependencies formed by multiple iterations of its inner loop. For the case of Example A in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004F75"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.33</span></a>, with differing source and destination addresses, the load and store operations can proceed independently, and hence the only critical path is formed by the decrementing of variable <code id="P700049702700000000000000004376F" data-uri="chapter05.xhtml#P700049702700000000000000004376F" class="pcalibre1 calibre8 pcalibre">cnt</code>, resulting in a CPE bound of 1.0. For the case of Example B with matching source and destination addresses, the data dependency between the s_data and load instructions causes a critical path to form involving data being stored, loaded, and incremented. We found that these three operations in sequence require a total of around 7 clock cycles.</p>
<p id="P7000497027000000000000000043770" data-uri="chapter05.xhtml#P7000497027000000000000000043770" class="pcalibre1 pcalibre calibre2">As these two examples show, the implementation of memory operations involves many subtleties. With operations on registers, the processor can determine which instructions will affect which others as they are being decoded into operations. With memory operations, on the other hand, the processor cannot predict which will affect which others until the load and store addresses have been computed. Efficient handling of memory operations is critical to the performance of many programs. The memory subsystem makes use of many optimizations, such as the potential parallelism when operations can proceed independently.</p>
<section id="P7000497027000000000000000004FBF" data-uri="chapter05.xhtml#P7000497027000000000000000004FBF" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000043771" data-uri="chapter05.xhtml#P7000497027000000000000000043771" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.10 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000043772" data-uri="chapter05.xhtml#P7000497027000000000000000043772">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000043773" data-uri="chapter05.xhtml#P7000497027000000000000000043773">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043774" data-uri="chapter05.xhtml#P7000497027000000000000000043774"><p id="P7000497027000000000000000043775" data-uri="chapter05.xhtml#P7000497027000000000000000043775" class="pcalibre calibre3 pcalibre1">As another example of code with potential load-store interactions, consider the following function to copy the contents of one array to another:</p>
<pre id="P7000497027000000000000000043776" data-uri="chapter05.xhtml#P7000497027000000000000000043776" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043777" data-uri="chapter05.xhtml#P7000497027000000000000000043777" class="calibre10 pcalibre pcalibre1">
1	void copy_array(long *src, long *dest, long n)
2	{
3		long i;
4		for (i = 0; i &lt; n; i++)
5			dest[i] = src[i];
6	}
</code></pre>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004FC7" data-uri="chapter05.xhtml#P7000497027000000000000000004FC7">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004FC8" title="560" data-uri="chapter05.xhtml#P7000497027000000000000000004FC8" epub:type="pagebreak"></span>
<img alt="Example A shows a critical path flowing through sub operations. Example B shows a critical path flowing between groups through s_data, load, and add." id="P7000497027000000000000000043778" data-uri="P700049702700000000000000000B726" src="../images/p560-1.png" class="calibre190 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000043779" data-uri="chapter05.xhtml#P7000497027000000000000000043779" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004377A" data-uri="chapter05.xhtml#P700049702700000000000000004377A" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">5.37 </span>Data-flow representation of function <code id="P700049702700000000000000004377B" data-uri="chapter05.xhtml#P700049702700000000000000004377B" class="pcalibre1 calibre8 pcalibre">write_read</code>.</h1></header>
<div class="caption pcalibre pcalibre1" id="P700049702700000000000000004377C" data-uri="chapter05.xhtml#P700049702700000000000000004377C"><p id="P700049702700000000000000004377D" data-uri="chapter05.xhtml#P700049702700000000000000004377D" class="pcalibre calibre3 pcalibre1">When the two addresses do not match, the only critical path is formed by the decrementing of <b class="calibre4 pcalibre pcalibre1">cnt</b> (Example A). When they do match, the chain of data being stored, loaded, and incremented forms the critical path (Example B).</p></div>
</figcaption></figure>
<p id="P700049702700000000000000004377E" data-uri="chapter05.xhtml#P700049702700000000000000004377E" class="pcalibre calibre3 pcalibre1">Suppose <code id="P700049702700000000000000004377F" data-uri="chapter05.xhtml#P700049702700000000000000004377F" class="pcalibre1 calibre8 pcalibre">a</code> is an array of length 1,000 initialized so that each element <code id="P7000497027000000000000000043780" data-uri="chapter05.xhtml#P7000497027000000000000000043780" class="pcalibre1 calibre8 pcalibre">a[<var class="calibre5 pcalibre pcalibre1">i</var>]</code> equals <i class="calibre5 pcalibre pcalibre1">i.</i></p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P7000497027000000000000000043781" data-uri="chapter05.xhtml#P7000497027000000000000000043781">
<li id="P7000497027000000000000000043782" data-uri="chapter05.xhtml#P7000497027000000000000000043782" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043783" data-uri="chapter05.xhtml#P7000497027000000000000000043783" class="pcalibre calibre3 pcalibre1">What would be the effect of the call <code id="P7000497027000000000000000043784" data-uri="chapter05.xhtml#P7000497027000000000000000043784" class="pcalibre1 calibre8 pcalibre">copy_array(a+1,a,999)?</code></p></li>
<li id="P7000497027000000000000000043785" data-uri="chapter05.xhtml#P7000497027000000000000000043785" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043786" data-uri="chapter05.xhtml#P7000497027000000000000000043786" class="pcalibre calibre3 pcalibre1">What would be the effect of the call <code id="P7000497027000000000000000043787" data-uri="chapter05.xhtml#P7000497027000000000000000043787" class="pcalibre1 calibre8 pcalibre">copy_array(a,a+1,999)?</code></p></li>
<li id="P7000497027000000000000000043788" data-uri="chapter05.xhtml#P7000497027000000000000000043788" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043789" data-uri="chapter05.xhtml#P7000497027000000000000000043789" class="pcalibre calibre3 pcalibre1">Our performance measurements indicate that the call of part A has a CPE of 1.2 (which drops to 1.0 when the loop is unrolled by a factor of 4), while the call of part B has a CPE of 5.0. To what factor do you attribute this performance difference?</p></li>
<li id="P700049702700000000000000004378A" data-uri="chapter05.xhtml#P700049702700000000000000004378A" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004378B" data-uri="chapter05.xhtml#P700049702700000000000000004378B" class="pcalibre calibre3 pcalibre1">What performance would you expect for the call <code id="P700049702700000000000000004378C" data-uri="chapter05.xhtml#P700049702700000000000000004378C" class="pcalibre1 calibre8 pcalibre">copy_array (a,a, 999)?</code></p></li>
</ol></div></li>
</ol>
</section>
<section id="P7000497027000000000000000004FDE" data-uri="chapter05.xhtml#P7000497027000000000000000004FDE" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004378D" data-uri="chapter05.xhtml#P700049702700000000000000004378D" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004FE0" title="561" data-uri="chapter05.xhtml#P7000497027000000000000000004FE0" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.11 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P700049702700000000000000004378E" data-uri="chapter05.xhtml#P700049702700000000000000004378E">
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004378F" data-uri="chapter05.xhtml#P700049702700000000000000004378F">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043790" data-uri="chapter05.xhtml#P7000497027000000000000000043790"><p id="P7000497027000000000000000043791" data-uri="chapter05.xhtml#P7000497027000000000000000043791" class="pcalibre calibre3 pcalibre1">We saw that our measurements of the prefix-sum function <code id="P7000497027000000000000000043792" data-uri="chapter05.xhtml#P7000497027000000000000000043792" class="pcalibre1 calibre8 pcalibre">psum1</code> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004949"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.1</span></a>) yield a CPE of 9.00 on a machine where the basic operation to be performed, floating-point addition, has a latency of just 3 clock cycles. Let us try to understand why our function performs so poorly.</p>
<p id="P7000497027000000000000000043793" data-uri="chapter05.xhtml#P7000497027000000000000000043793" class="pcalibre calibre3 pcalibre1">The following is the assembly code for the inner loop of the function:</p>
<pre id="P7000497027000000000000000043794" data-uri="chapter05.xhtml#P7000497027000000000000000043794" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043795" data-uri="chapter05.xhtml#P7000497027000000000000000043795" class="calibre10 pcalibre pcalibre1">
<i class="calibre5 pcalibre pcalibre1">Inner loop of psum1</i>
<i class="calibre5 pcalibre pcalibre1">a in %rdi, i in %rax, cnt in %rdx</i>
1	.L5:					<b class="calibre4 pcalibre pcalibre1">loop:</b>
2	  vmovss −4(%rsi,%rax,4), %xmm0		  <i class="calibre5 pcalibre pcalibre1">Get p[i-1]</i>
3	  vaddss (%rdi,%rax,4), %xmm0, %xmm0	  <i class="calibre5 pcalibre pcalibre1">Add a[i]</i>
4	  vmovss %xmm0, (%rsi,%rax,4)		  <i class="calibre5 pcalibre pcalibre1">Store at p[i]</i>
5	  addq $1, %rax				  <i class="calibre5 pcalibre pcalibre1">Increment i</i>
6	  cmpq %rdx, %rax			  <i class="calibre5 pcalibre pcalibre1">Compare i : cnt</i>
7	  jne .L5				  <i class="calibre5 pcalibre pcalibre1">If ! =, goto</i> <b class="calibre4 pcalibre pcalibre1">loop</b>
</code></pre>
<p id="P7000497027000000000000000043796" data-uri="chapter05.xhtml#P7000497027000000000000000043796" class="pcalibre calibre3 pcalibre1">Perform an analysis similar to those shown for <code id="P7000497027000000000000000043797" data-uri="chapter05.xhtml#P7000497027000000000000000043797" class="pcalibre1 calibre8 pcalibre">combine3</code> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C33"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.14</span></a>) and for <code id="P7000497027000000000000000043798" data-uri="chapter05.xhtml#P7000497027000000000000000043798" class="pcalibre1 calibre8 pcalibre">write_read</code> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004FB3"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.36</span></a>) to diagram the data dependencies created by this loop, and hence the critical path that forms as the computation proceeds. Explain why the CPE is so high.</p></div></li>
</ol>
</section>
<section id="P7000497027000000000000000004FEC" data-uri="chapter05.xhtml#P7000497027000000000000000004FEC" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000043799" data-uri="chapter05.xhtml#P7000497027000000000000000043799" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.12 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005159">577</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P700049702700000000000000004379A" data-uri="chapter05.xhtml#P700049702700000000000000004379A">
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004379B" data-uri="chapter05.xhtml#P700049702700000000000000004379B">
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000004379C" data-uri="chapter05.xhtml#P700049702700000000000000004379C"><p id="P700049702700000000000000004379D" data-uri="chapter05.xhtml#P700049702700000000000000004379D" class="pcalibre calibre3 pcalibre1">Rewrite the code for <code id="P700049702700000000000000004379E" data-uri="chapter05.xhtml#P700049702700000000000000004379E" class="pcalibre1 calibre8 pcalibre">psum1</code> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000493B.xhtml#P7000497027000000000000000004949"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.1</span></a>) so that it does not need to repeatedly retrieve the value of <code id="P700049702700000000000000004379F" data-uri="chapter05.xhtml#P700049702700000000000000004379F" class="pcalibre1 calibre8 pcalibre">p[i]</code> from memory. You do not need to use loop unrolling. We measured the resulting code to have a CPE of 3.00, limited by the latency of floating-point addition.</p></div></li>
</ol>
</section>
</section>
</section></body></html>
