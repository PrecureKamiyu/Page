<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>14.7  Creation of Indices</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part266.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part268.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark282">14.7  </a><span style=" color: #00AEEF;">Creation of Indices</span><a name="bookmark315">&zwnj;</a></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Although the <span class="s44">SQL </span>standard does not specify any speciﬁc syntax for creation of indices, most databases support <span class="s44">SQL </span>commands to create and drop indices. As we saw in Sec- tion 4.6, indices can be created using the following syntax, which is supported by most databases.</p><p class="s83" style="padding-top: 10pt;padding-left: 128pt;text-indent: 0pt;text-align: justify;"><span class="s46">create index </span>&lt;<span class="p">index-name</span>&gt; <span class="s46">on </span>&lt;<span class="p">relation-name</span>&gt; <span class="p">(</span>&lt;<span class="p">attribute-list</span>&gt;<span class="p">);</span></p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <i>attribute-list </i>is the list of attributes of the relations that form the search key for the index. Indices can be dropped using a command of the form</p><p class="s83" style="padding-top: 10pt;padding-left: 218pt;text-indent: 0pt;text-align: justify;"><span class="s46">drop index </span>&lt;<span class="p">index-name</span>&gt;<span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2719.png"/></span></p><p style="padding-top: 7pt;padding-left: 106pt;text-indent: 0pt;text-align: justify;">For example, to deﬁne an index named <i>dept index </i>on the <i>instructor </i>relation with</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2720.png"/></span></p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">dept name <span class="p">as the search key, we write:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2721.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2722.png"/></span></p><p class="s13" style="padding-left: 59pt;text-indent: 0pt;text-align: center;"><b>create index </b>dept index <b>on </b>instructor <span class="p">(</span>dept name<span class="p">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To declare that an attribute or list of attributes is a candidate key, we can use the syntax <b>create unique index </b>in place of <b>create index </b>above. Databases that support mul- tiple types of indices also allow the type of index to be speciﬁed as part of the index creation command. Refer to the manual of your database system to ﬁnd out what index types are available, and the syntax for specifying the index type.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">When a user submits an <span class="s44">SQL </span>query that can beneﬁt from using an index, the <span class="s44">SQL</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">query processor automatically uses the index.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Indices can be very useful on attributes that participate in selection conditions or join conditions of queries, since they can reduce the cost of queries signiﬁcantly. Con- sider a query that retrieves <i>takes </i>records for a particular student <span class="s44">ID </span>12345 (expressed in relational algebra as <span class="s15">σ</span><i>ID</i><span class="s137">=</span><span class="s98">12345</span>(<i>takes</i>)). If there were an index on the <span class="s44">ID </span>attribute of <i>takes</i>, pointers to the required records could be obtained with only a few <span class="s44">I/O </span>opera- tions. Since students typically only take a few tens of courses, even fetching the actual records would take only a few tens of <span class="s44">I/O </span>operations subsequently. In contrast, in the absence of this index, the database system would be forced to read all <i>takes </i>records and select those with matching <span class="s44">ID </span>values. Reading an entire relation can be very expensive if there are a large number of students.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">However, indices do have a cost, since they have to be updated whenever there is an update to the underlying relation. Creating too many indices would slow down update processing, since each update would have to also update all aﬀected indices.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Sometimes performance problems are apparent during testing, for example, if a query takes tens of seconds, it is clear that it is quite slow. However, suppose each query takes 1 second to scan a large relation without an index, versus 10 milliseconds to retrieve the same records using an index. If testers run one query at a time, queries</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><a name="bookmark283">respond quickly, even without an index. However, suppose that the queries are part of a registration system that is used by a thousand students in an hour, and the actions of each student require 10 such queries to be executed. The total execution time would then be 10,000 seconds for queries submitted in 1 hour, that is, 3600 seconds. Students are then likely to ﬁnd that the registration system is extremely slow, or even totally unre- sponsive. In contrast, if the required indices were present, the execution time required would be 100 seconds for queries submitted in 1 hour, and the performance of the registration system would be very good.</a><a name="bookmark316">&zwnj;</a></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">It is therefore important when building an application to ﬁgure out which indices are important for performance and to create them before the application goes live.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If a relation is declared to have a primary key, most database systems automatically create an index on the primary key. Whenever a tuple is inserted into the relation, the index can be used to check that the primary-key constraint is not violated (i.e., there are no duplicates on the primary-key value). Without the index on the primary key, whenever a tuple is inserted, the entire relation has to be scanned to ensure that the primary-key constraint is satisﬁed.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Although most database systems do not automatically create them, it is often a good idea to create indices on foreign-key attributes, too. Most joins are between foreign-key and primary-key attributes, and queries containing such joins, where there is also a selection condition on the referenced table, are not uncommon. Consider a query <i>takes </i><span class="s86">⋈ </span><span class="s15">σ</span><i>name</i><span class="s137">=</span><span class="s98">Shankar</span>(<i>student</i>), where the foreign-key attribute <span class="s44">ID </span>of <i>takes </i>refer-</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">ences the primary-key attribute <span class="s44">ID </span>of student. Since very few students are likely to be</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">named Shankar, the index on the foreign-key attribute <i>takes</i>.<span class="s44">ID </span>can be used to eﬃciently retrieve the <i>takes </i>tuples corresponding to these students.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Many database systems provide tools that help database administrators track what queries and updates are being executed on the system and recommend the creation of indices depending on the frequencies of the queries and updates. Such tools are referred to as index tuning wizards or advisors.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Some recent cloud-based database systems also support completely automated cre- ation of indices whenever the system ﬁnds that doing so would avoid repeated relation scans, without the intervention of a database administrator.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part266.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part268.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
