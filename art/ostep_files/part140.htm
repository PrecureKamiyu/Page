<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Mechanism: Address Translation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part139.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part141.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 121pt;text-indent: 0pt;text-align: left;">Mechanism: Address Translation</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In developing the virtualization of the CPU, we focused on a general mechanism known as <b>limited direct execution </b>(or <b>LDE</b>). The idea be- hind LDE is simple: for the most part, let the program run directly on the hardware; however, at certain key points in time (such as when a process issues a system call, or a timer interrupt occurs), arrange so that the OS gets involved and makes sure the “right” thing happens. Thus, the OS, with a little hardware support, tries its best to get out of the way of the running program, to deliver an <i>efficient </i>virtualization; however, by <b>inter- posing </b>at those critical points in time, the OS ensures that it maintains <i>control </i>over the hardware. Efficiency and control together are two of the main goals of any modern operating system.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In virtualizing memory, we will pursue a similar strategy, attaining both efficiency and control while providing the desired virtualization. Ef- ficiency dictates that we make use of hardware support, which at first will be quite rudimentary (e.g., just a few registers) but will grow to be fairly complex (e.g., TLBs, page-table support, and so forth, as you will see). Control implies that the OS ensures that no application is allowed to access any memory but its own; thus, to protect applications from one another, and the OS from applications, we will need help from the hard- ware here too. Finally, we will need a little more from the VM system, in terms of <i>flexibility</i>; specifically, we’d like for programs to be able to use their address spaces in whatever way they would like, thus making the system easier to program. And thus arrive at the refined crux:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>:</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: center;">H<span class="s7">OW </span>T<span class="s7">O </span>E<span class="s7">FFICIENTLY </span>A<span class="s7">ND </span>F<span class="s7">LEXIBLY </span>V<span class="s7">IRTUALIZE </span>M<span class="s7">EMORY</span></p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: justify;">How can we build an efficient virtualization of memory? How do we provide the flexibility needed by applications? How do we maintain control over which memory locations an application can access, and thus ensure that application memory accesses are properly restricted? How do we do all of this efficiently?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 21pt;text-indent: 0pt;text-align: center;">129</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The generic technique we will use, which you can consider an addition to our general approach of limited direct execution, is something that is referred to as <b>hardware-based address translation</b>, or just <b>address trans- lation </b>for short. With address translation, the hardware transforms each memory access (e.g., an instruction fetch, load, or store), changing the <b>vir- tual </b>address provided by the instruction to a <b>physical </b>address where the desired information is actually located. Thus, on each and every memory reference, an address translation is performed by the hardware to redirect application memory references to their actual locations in memory.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Of course, the hardware alone cannot virtualize memory, as it just pro- vides the low-level mechanism for doing so efficiently. The OS must get involved at key points to set up the hardware so that the correct trans- lations take place; it must thus <b>manage memory</b>, keeping track of which locations are free and which are in use, and judiciously intervening to maintain control over how memory is used.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Once again the goal of all of this work is to create a beautiful <b>illu- sion</b>: that the program has its own private memory, where its own code and data reside. Behind that virtual reality lies the ugly physical truth: that many programs are actually sharing memory at the same time, as the CPU (or CPUs) switches between running one program and the next. Through virtualization, the OS (with the hardware’s help) turns the ugly machine reality into something that is a useful, powerful, and easy to use abstraction.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part141.htm">15.1 Assumptions</a><a class="toc0" href="part142.htm">15.2 An Example</a><a class="toc0" href="part143.htm">15.3 Dynamic (Hardware-based) Relocation</a><a class="toc1" href="part144.htm">Example Translations</a><a class="toc0" href="part145.htm">15.4 OS Issues</a><a class="toc0" href="part146.htm">15.5 Summary</a><a class="toc0" href="part147.htm">References</a><a class="toc0" href="part148.htm">Homework</a><a class="toc1" href="part149.htm">Questions</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part139.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part141.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
