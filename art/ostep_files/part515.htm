<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Run-Time Library</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part514.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part516.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Run-Time Library</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The run-time library handles much of the heavy lifting in an RPC system; most performance and reliability issues are handled herein. We’ll now discuss some of the major challenges in building such a run-time layer.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One of the first challenges we must overcome is how to locate a re- mote service. This problem, of <b>naming</b>, is a common one in distributed systems, and in some sense goes beyond the scope of our current discus- sion. The simplest of approaches build on existing naming systems, e.g., hostnames and port numbers provided by current internet protocols. In such a system, the client must know the hostname or IP address of the machine running the desired RPC service, as well as the port number it is using (a port number is just a way of identifying a particular communica- tion activity taking place on a machine, allowing multiple communication channels at once). The protocol suite must then provide a mechanism to route packets to a particular address from any other machine in the sys- tem. For a good discussion of naming, read either the Grapevine paper or about DNS and name resolution on the Internet, or better yet just read the excellent chapter in Saltzer and Kaashoek’s book [SK09].</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Once a client knows which server it should talk to for a particular re- mote service, the next question is which transport-level protocol should RPC be built upon. Specifically, should the RPC system use a reliable pro- tocol such as TCP/IP, or be built upon an unreliable communication layer such as UDP/IP?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Naively the choice would seem easy: clearly we would like for a re- quest to be reliably delivered to the remote server, and clearly we would</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">like to reliably receive a reply. Thus we should choose the reliable trans- port protocol such as TCP, right?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Unfortunately, building RPC on top of a reliable communication layer can lead to a major inefficiency in performance. Recall from the discus- sion above how reliable communication layers work: with acknowledg- ments plus timeout/retry. Thus, when the client sends an RPC request to the server, the server responds with an acknowledgment so that the caller knows the request was received. Similarly, when the server sends the reply to the client, the client acks it so that the server knows it was received. By building a request/response protocol (such as RPC) on top of a reliable communication layer, two “extra” messages are sent.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">For this reason, many RPC packages are built on top of unreliable com- munication layers, such as UDP. Doing so enables a more efficient RPC layer, but does add the responsibility of providing reliability to the RPC system. The RPC layer achieves the desired level of responsibility by us- ing timeout/retry and acknowledgments much like we described above. By using some form of sequence numbering, the communication layer can guarantee that each RPC takes place exactly once (in the case of no failure), or at most once (in the case where failure arises).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part514.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part516.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
