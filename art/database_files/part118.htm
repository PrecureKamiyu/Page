<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>5.1   Accessing SQL from a Programming Language</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part117.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part119.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">5.1   <span style=" color: #00AEEF;">Accessing SQL from a Programming Language</span></p><p class="s42" style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">SQL <span class="s43">provides a powerful declarative query language. Writing queries in </span>SQL <span class="s43">is usually much easier than coding the same queries in a general-purpose programming language. However, a database programmer must have access to a general-purpose programming language for at least two reasons:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span>Not all queries can be expressed in <span class="s44">SQL</span>, since <span class="s44">SQL </span>does not provide the full ex- pressive power of a general-purpose language. That is, there exist queries that can be expressed in a language such as C, Java, or Python that cannot be expressed in <span class="s44">SQL</span>. To write such queries, we can embed <span class="s44">SQL </span>within a more powerful language.</p><p style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;"><span class="s63">2. </span>Nondeclarative actions— such as printing a report, interacting with a user, or sending the results of a query to a graphical user interface— cannot be done from within <span class="s44">SQL</span>. Applications usually have several components, and querying or up- dating data are only one component; other components are written in general- purpose programming languages. For an integrated application, there must be a means to combine <span class="s44">SQL </span>with a general-purpose programming language.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: left;">There are two approaches to accessing <span class="s44">SQL </span>from a general-purpose programming language:</p><p class="s20" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">183</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 113pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span><b>Dynamic </b><span class="s47">SQL</span>: A general-purpose program can connect to and communicate with a database server using a collection of functions (for procedural languages) or methods (for object-oriented languages). Dynamic <span class="s44">SQL </span>allows the program to construct an <span class="s44">SQL </span>query as a character string at runtime, submit the query, and then retrieve the result into program variables a tuple at a time. The <i>dynamic </i><span class="s101">SQL </span>component of <span class="s44">SQL </span>allows programs to construct and submit <span class="s44">SQL </span>queries at runtime.</p><p style="padding-left: 113pt;text-indent: 14pt;text-align: justify;">In this chapter, we look at two standards for connecting to an <span class="s44">SQL </span>database and performing queries and updates. One, <span class="s44">JDBC </span>(Section 5.1.1), is an application program interface for the Java language. The other, <span class="s44">ODBC </span>(Section 5.1.3), is an application program interface originally developed for the C language, and subsequently extended to other languages such as C++, C#, Ruby, Go, <span class="s44">PHP</span>, and Visual Basic. We also illustrate how programs written in Python can connect to a database using the Python Database <span class="s44">API </span>(Section 5.1.2).</p><p style="padding-left: 113pt;text-indent: 15pt;text-align: justify;">The <span class="s44">ADO.NET API</span>, designed for the Visual Basic <span class="s44">.NET </span>and C# languages, provides functions to access data, which at a high level are similar to the <span class="s44">JDBC </span>functions, although details diﬀer. The <span class="s44">ADO.NET API </span>can also be used with some kinds of non-relational data sources. Details of <span class="s44">ADO.NET </span>may be found in the manuals available online and are not covered further in this chapter.</p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;"><span class="s63">2. </span><b>Embedded </b><span class="s47">SQL</span>: Like dynamic <span class="s44">SQL</span>, embedded <span class="s44">SQL </span>provides a means by which a program can interact with a database server. However, under embedded <span class="s44">SQL</span>, the <span class="s44">SQL </span>statements are identiﬁed at compile time using a preprocessor, which translates requests expressed in embedded <span class="s44">SQL </span>into function calls. At runtime, these function calls connect to the database using an <span class="s44">API </span>that provides dynamic <span class="s44">SQL </span>facilities but may be speciﬁc to the database that is being used. Section 5.1.4 brieﬂy covers embedded <span class="s44">SQL</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A major challenge in mixing <span class="s44">SQL </span>with a general-purpose language is the mismatch in the ways these languages manipulate data. In <span class="s44">SQL</span>, the primary type of data are relations. <span class="s44">SQL </span>statements operate on relations and return relations as a result. Pro- gramming languages normally operate on a variable at a time, and those variables cor- respond roughly to the value of an attribute in a tuple in a relation. Thus, integrating these two types of languages into a single application requires providing a mechanism to return the result of a query in a manner that the program can handle.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Our examples in this section assume that we are accessing a database on a server that runs a database system. An alternative approach using an <span class="s63">embedded database </span>is discussed in Note 5.1 on page 198.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">5.1.1 JDBC</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <span class="s63">JDBC </span>standard deﬁnes an <span class="s63">application program interface (</span><span class="s82">API</span><span class="s63">) </span>that Java programs can use to connect to database servers. (The word <span class="s44">JDBC </span>was originally an abbreviation for <b>Java Database Connectivity</b>, but the full form is no longer used.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Figure 5.1 shows example Java code that uses the <span class="s44">JDBC </span>interface. The Java program must import <span class="s49">java.sql.*</span>, which contains the interface deﬁnitions for the functionality provided by <span class="s44">JDBC</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">5.1.1.1 Connecting to the Database</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The ﬁrst step in accessing a database from a Java program is to open a connection to the database. This step is required to select which database to use, such as an instance of Oracle running on your machine, or a <span class="s44">P</span>ostgre<span class="s44">SQL </span>database running on another machine. Only after openinga connection can a Java program execute <span class="s44">SQL </span>statements.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_889.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-top: 4pt;padding-left: 120pt;text-indent: 0pt;text-align: left;">public static void JDBCexample(String userid, String passwd)</p><p class="s49" style="padding-left: 120pt;text-indent: 0pt;text-align: left;">{</p><p class="s49" style="padding-left: 141pt;text-indent: 0pt;text-align: left;">try (</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-top: 9pt;padding-left: 141pt;text-indent: 0pt;text-align: left;">){ </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 42pt;text-indent: -42pt;text-align: left;">Connection conn = DriverManager.getConnection( &quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;, userid, passwd);</p><p class="s49" style="text-indent: 0pt;line-height: 12pt;text-align: left;">Statement stmt = conn.createStatement();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="text-indent: 0pt;text-align: left;">try {</p><p class="s49" style="padding-left: 21pt;text-indent: 0pt;text-align: left;">stmt.executeUpdate(</p><p class="s49" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">&quot;insert into instructor values(’77987’,’Kim’,’Physics’,98000)&quot;);</p><p class="s49" style="padding-left: 162pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-left: 162pt;text-indent: 0pt;text-align: left;">catch (<span class="s157">SQLException </span>sqle) {</p><p class="s49" style="padding-left: 184pt;text-indent: 0pt;text-align: left;">System.out.println(&quot;Could not insert tuple. &quot; + sqle);</p><p class="s49" style="padding-left: 162pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-left: 162pt;text-indent: 0pt;text-align: left;">ResultSet rset = stmt.executeQuery(</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_890.png"/></span></p><p class="s49" style="padding-left: 205pt;text-indent: 0pt;text-align: left;">&quot;select dept name, avg (salary) &quot;+ &quot; from instructor &quot;+</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_891.png"/></span></p><p class="s49" style="padding-left: 162pt;text-indent: 42pt;text-align: left;">&quot; group by dept name&quot;); while (rset.next()) {</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_892.png"/></span></p><p class="s49" style="padding-left: 226pt;text-indent: -42pt;text-align: left;">System.out.println(rset.getString(&quot;dept name&quot;)+&quot;&quot;+ rset.getFloat(2));</p><p class="s49" style="padding-left: 162pt;text-indent: 0pt;line-height: 12pt;text-align: left;">}</p><p class="s49" style="padding-left: 141pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-left: 141pt;text-indent: 0pt;text-align: left;">catch (Exception sqle)</p><p class="s49" style="padding-left: 141pt;text-indent: 0pt;text-align: left;">{</p><p class="s49" style="padding-left: 162pt;text-indent: 0pt;text-align: left;">System.out.println(&quot;Exception : &quot; + sqle);</p><p class="s49" style="padding-left: 141pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-left: 120pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_893.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s74" style="padding-top: 4pt;padding-left: 222pt;text-indent: 0pt;text-align: left;"><span class="s73">Figure 5.1 </span>An example of <span class="s157">JDBC </span>code.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">A connection is opened using the <span class="s49">getConnection() </span>method of the <span class="s49">DriverManager </span>class (within <span class="s49">java.sql</span>). This method takes three parameters.<span class="s76">1</span></p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span>The ﬁrst parameter to the <span class="s49">getConnection() </span>call is a string that speciﬁes the <span class="s44">URL</span>, or machine name, where the server runs (in our example, <span class="s49">db.yale.edu</span>), along with possibly some other information such as the protocol to be used to commu- nicate with the database (in our example, <span class="s49">jdbc:oracle:thin:</span>; we shall shortly see why this is required), the port number the database system uses for communica- tion (in our example, 2000), and the speciﬁc database on the server to be used (in our example, <span class="s49">univdb</span>). Note that <span class="s44">JDBC </span>speciﬁes only the <span class="s44">API</span>, not the commu- nication protocol. A <span class="s44">JDBC </span>driver may support multiple protocols, and we must specify one supported by both the database and the driver. The protocol details are vendor speciﬁc.</p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;"><span class="s63">2. </span>The second parameter to <span class="s49">getConnection() </span>is a database user identiﬁer, which is a string.</p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;"><span class="s63">3. </span>The third parameter is a password, which is also a string. (Note that the need to specify a password within the <span class="s44">JDBC </span>code presents a security risk if an unautho- rized person accesses your Java code.)</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In our example in the ﬁgure, we have created a <span class="s49">Connection </span>object whose handle is</p><p class="s49" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">conn<span class="p">.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Each database product that supports <span class="s44">JDBC </span>(all the major database vendors do) provides a <span class="s44">JDBC </span>driver that must be dynamically loaded in order to access the database from Java. In fact, loading the driver must be done ﬁrst, before connecting to the database. If the appropriate driver has been downloaded from the vendor’s web site and is in the classpath, the <span class="s49">getConnection() </span>method will locate the needed driver.<span class="s76">2</span> The driver provides for the translation of product-independent <span class="s44">JDBC </span>calls into the product- speciﬁc calls needed by the speciﬁc database management system being used. The ac- tual protocol used to exchange information with the database depends on the driver that is used, and it is not deﬁned by the <span class="s44">JDBC </span>standard. Some drivers support more than one protocol, and a suitable protocol must be chosen depending on what protocol the particular database product supports. In our example, when opening a connection with the database, the string <span class="s49">jdbc:oracle:thin: </span>speciﬁes a particular protocol supported by Oracle. The <span class="s44">M</span>y<span class="s44">SQL </span>equivalent is <span class="s49">jdbc:mysql:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">5.1.1.2 Shipping SQL Statements to the Database System</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Once a database connection is open, the program can use it to send <span class="s44">SQL </span>statements to the database system for execution. This is done via an instance of the class <span class="s49">Statement</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_894.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">1<span class="s78">There are multiple versions of the </span><span class="s184">getConnection() </span><span class="s80">method, which diﬀer in the parameters that they accept. We present the most commonly used version.</span></p><p class="s77" style="padding-left: 88pt;text-indent: 0pt;line-height: 9pt;text-align: left;">2<span class="s78">Prior to version 4, locating the driver was done manually by invoking </span><span class="s184">Class.forName </span><span class="s80">with one argument specifying a</span></p><p class="s80" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">concrete class implementing the <span class="s184">java.sql.Driver </span>interface, in a line of code prior to the <span class="s184">getConnection call.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">A <span class="s49">Statement </span>object is not the <span class="s44">SQL </span>statement itself, but rather an object that allows the Java program to invoke methods that ship an <span class="s44">SQL </span>statement given as an argument for execution by the database system. Our example creates a <span class="s49">Statement </span>handle (<span class="s49">stmt</span>) on the connection <span class="s49">conn</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To execute a statement, we invoke either the <span class="s49">executeQuery() </span>method or the <span class="s49">exe- cuteUpdate() </span>method, depending on whether the <span class="s44">SQL </span>statement is a query (and, thus, returns a result set) or nonquery statement such as <b>update</b>, <b>insert</b>, <b>delete</b>, or <b>create ta- ble</b>. In our example, <span class="s49">stmt.executeUpdate() </span>executes an update statement that inserts into the <i>instructor </i>relation. It returns an integer giving the number of tuples inserted, updated, or deleted. For <span class="s44">DDL </span>statements, the return value is zero.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">5.1.1.3 Exceptions and Resource Management</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Executing any <span class="s44">SQL </span>method might result in an exception being thrown. The <span class="s49">try { </span><span class="s185">… </span><span class="s49">} catch { </span><span class="s185">… </span><span class="s49">} </span>construct permits us to catch any exceptions (error conditions) that arise when <span class="s44">JDBC </span>calls are made and take appropriate action. In <span class="s44">JDBC </span>programming, it may be useful to distinguish between an <span class="s49">SQLexception</span>, which is an <span class="s44">SQL</span>-speciﬁc exception, and the general case of an <span class="s49">Exception</span>, which could be any Java exception such as a null-pointer exception, or array-index-out-of-bounds exception. We show both in Figure</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">5.1. In practice, one would write more complete exception handlers than we do (for the sake of conciseness) in our example code.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Opening a connection, a statement, and other <span class="s44">JDBC </span>objects are all actions that consume system resources. Programmers must take care to ensure that programs close all such resources. Failure to do so may cause the database system’s resource pools to become exhausted, rendering the system inaccessible or inoperative until a time-out period expires. One way to do this is to code explicit calls to close connections and statements. This approach fails if the code exits due to an exception and, in so do- ing, avoids the Java statement with the close invocation. For this reason, the preferred approach is to use the <i>try-with-resources </i>construct in Java. In the example of Figure 5.1, the opening of the connection and statement objects is done within parentheses rather than in the main body of the <span class="s49">try </span>in curly braces. Resources opened in the code within parentheses are closed automatically at the end of the <span class="s49">try </span>block. This protects us from leaving connections or statements unclosed. Since closing a statement implicitly closes objects opened for that statement (i.e., the <span class="s49">ResultSet </span>objects we shall discuss in the next section, this coding practice protects us from leaving resources unclosed.<span class="s76">3</span> In the example of Figure 5.1, we could have closed the connection explicitly with the statement <span class="s49">conn.close() </span>and closed the statement explicitly with <span class="s49">stmt.close()</span>, though doing so was not necessary in our example.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">5.1.1.4 Retrieving the Result of a Query</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The example code of Figure 5.1 executes a query by using <span class="s49">stmt.executeQuery()</span>. It retrieves the set of tuples in the result into a <span class="s49">ResultSet </span>object <span class="s49">rset </span>and fetches them one</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_895.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">3<span class="s78">This Java feature, called </span><span class="s111">try-with-resources</span><span class="s80">, was introduced in Java 7.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_896.png"/></span></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">tuple at a time. The <span class="s49">next() </span>method on the result set tests whether or not there remains at least one unfetched tuple in the result set and if so, fetches it. The return value of the <span class="s49">next() </span>method is a Boolean indicating whether it fetched a tuple. Attributes from the fetched tuple are retrieved using various methods whose names begin with <span class="s49">get</span>. The method <span class="s49">getString() </span>can retrieve any of the basic <span class="s44">SQL </span>data types (converting the value to a Java String object), but more restrictive methods such as <span class="s49">getFloat() </span>can be used as well. The argument to the various <span class="s49">get </span>methods can either be an attribute name speciﬁed as a string, or an integer indicating the position of the desired attribute within the tuple. Figure 5.1 shows two ways of retrieving the values of attributes in a tuple: using the name of the attribute (<i>dept name</i>) and using the position of the attribute (2, to denote the second attribute).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">5.1.1.5 Prepared Statements</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We can create a prepared statement in which some values are replaced by “?”, thereby specifying that actual values will be provided later. The database system compiles the query when it is prepared. Each time the query is executed (with new values to replace the “?”s), the database system can reuse the previously compiled form of the query and apply the new values as parameters. The code fragment in Figure 5.2 shows how prepared statements can be used.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s49">prepareStatement() </span>method of the <span class="s49">Connection </span>class deﬁnes a query that may contain parameter values; some <span class="s44">JDBC </span>drivers may submit the query to the database for compilation as part of the method, but other drivers do not contact the database at this point. The method returns an object of class <span class="s49">PreparedStatement</span>. At this point, no <span class="s44">SQL </span>statement has been executed. The <span class="s49">executeQuery() </span>and <span class="s49">executeUpdate() </span>methods of <span class="s49">PreparedStatement </span>class do that. But before they can be invoked, we must use methods of class <span class="s49">PreparedStatement </span>that assign values for the “?” parameters. The <span class="s49">setString() </span>method and other similar methods such as <span class="s49">setInt() </span>for other basic <span class="s44">SQL </span>types allow us to specify the values for the parameters. The ﬁrst argument speciﬁes the “?” parameter for which we are assigning a value (the ﬁrst parameter is 1, unlike most other Java constructs, which start with 0). The second argument speciﬁes the value to be assigned.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In the example in Figure 5.2, we prepare an <b>insert </b>statement, set the “?” parame- ters, and then invoke <span class="s49">executeUpdate()</span>. The ﬁnal two lines of our example show that parameter assignments remain unchanged until we speciﬁcally reassign them. Thus, the ﬁnal statement, which invokes <span class="s49">executeUpdate()</span>, inserts the tuple (“88878”, “Perry”, “Finance”, 125000).</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Prepared statements allow for more eﬃcient execution in cases where the same query can be compiled once and then run multiple times with diﬀerent parameter val- ues. However, there is an even more signiﬁcant advantage to prepared statements that makes them the preferred method of executing <span class="s44">SQL </span>queries whenever a user-entered value is used, even if the query is to be run only once. Suppose that we read in a user- entered value and then use Java string manipulation to construct the <span class="s44">SQL </span>statement.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_897.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-top: 4pt;padding-left: 247pt;text-indent: -63pt;text-align: left;">PreparedStatement pStmt = conn.prepareStatement( &quot;insert into instructor values(?,?,?,?)&quot;);</p><p class="s49" style="padding-left: 183pt;text-indent: 0pt;text-align: left;">pStmt.setString(1, &quot;88877&quot;); pStmt.setString(2, &quot;Perry&quot;); pStmt.setString(3, &quot;Finance&quot;); pStmt.setInt(4, 125000); pStmt.executeUpdate(); pStmt.setString(1, &quot;88878&quot;); pStmt.executeUpdate();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_898.png"/></span></p><p class="s74" style="padding-top: 8pt;padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s73">Figure 5.2 </span>Prepared statements in <span class="s157">JDBC </span>code.</p><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">If the user enters certain special characters, such as a single quote, the resulting <span class="s44">SQL </span>statement may be syntactically incorrect unless we take extraordinary care in checking the input. The <span class="s49">setString() </span>method does this for us automatically and inserts the needed escape characters to ensure syntactic correctness.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_899.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In our example, suppose that the values for the variables <span class="s49">ID</span>, <span class="s49">name</span>, <span class="s49">dept name</span>, and <span class="s49">salary </span>have been entered by a user, and a corresponding row is to be inserted into the <i>instructor </i>relation. Suppose that, instead of using a prepared statement, a query is constructed by concatenating the strings using the following Java expression:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_900.png"/></span></p><p class="s49" style="padding-left: 228pt;text-indent: -63pt;text-align: left;">&quot;insert into instructor values(’ &quot; + <span class="s157">ID </span>+&quot; ’, ’&quot;+ name+ &quot; ’,&quot;+ &quot; ’&quot; + dept name +&quot; ’, &quot;+ salary + &quot;)&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_901.png"/></span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">and the query is executed directly using the <span class="s49">executeQuery() </span>method of a <span class="s49">Statement </span>object. Observe the use of single quotes in the string, which would surround the values of <span class="s49">ID</span>, <span class="s49">name </span>and <span class="s49">dept name </span>in the generated <span class="s44">SQL </span>query.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Now, if the user typed a single quote in the <span class="s44">ID </span>or name ﬁelds, the query string would have a syntax error. It is quite possible that an instructor name may have a quotation mark in its name (for example, “O’Henry”).</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">While the above example might be considered an annoyance, the situation can be much worse. A technique called <span class="s64">SQL </span><span class="s84">injection </span>can be used by malicious hackers to steal data or damage the database.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">Suppose a Java program inputs a string <i>name </i>and constructs the query:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">&quot;select * from instructor where name = ’&quot; + name + &quot;’&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">If the user, instead of entering a name, enters:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">X’ or ’Y’ = ’Y</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">then the resulting statement becomes:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-top: 4pt;padding-left: 56pt;text-indent: 0pt;text-align: center;">&quot;select * from instructor where name = ’&quot; + &quot;X’ or ’Y’ = ’Y&quot; + &quot;’&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">which is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 56pt;text-indent: 0pt;text-align: center;">select * from instructor where name = ’X’ or ’Y’ = ’Y’</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">In the resulting query, the <b>where </b>clause is always true and the entire instructor relation is returned.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">More clever malicious users could arrange to output even more data, including credentials such as passwords that allow the user to connect to the database and per- form any actions they want. <span class="s44">SQL </span>injection attacks on <b>update </b>statements can be used to change the values that are being stored in updated columns. In fact there have been a number of attacks in the real world using <span class="s44">SQL </span>injections; attacks on multiple ﬁnancial sites have resulted in theft of large amounts of money by using <span class="s44">SQL </span>injection attacks.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Use of a prepared statement would prevent this problem because the input string would have escape characters inserted, so the resulting query becomes:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 56pt;text-indent: 0pt;text-align: center;">&quot;select * from instructor where name = ’X<span class="s185">∖</span>’ or <span class="s185">∖</span>’Y<span class="s185">∖</span>’= <span class="s185">∖</span>’Y’</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">which is harmless and returns the empty relation.</p><p class="s13" style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Programmers must pass user-input strings to the database only through parameters of prepared statements; creating <span class="s101">SQL </span>queries by concatenating strings with user-input values is an extremely serious security risk and should never be done in any program.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Some database systems allow multiple <span class="s44">SQL </span>statements to be executed in a single <span class="s44">JDBC </span><span class="s49">execute </span>method, with statements separated by a semicolon. This feature has been turned oﬀ by default on some <span class="s44">JDBC </span>drivers because it allows malicious hackers to insert whole <span class="s44">SQL </span>statements using <span class="s44">SQL </span>injection. For instance, in our earlier <span class="s44">SQL </span>injection example a malicious user could enter:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 56pt;text-indent: 0pt;text-align: center;">X’; drop table instructor; – –</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">which will result in a query string with two statements separated by a semicolon being submitted to the database. Because these statements run with the privileges of the database userid used by the <span class="s44">JDBC </span>connection, devastating <span class="s44">SQL </span>statements such as <b>drop table</b>, or updates to any table of the user’s choice, could be executed. However, some databases still allow execution of multiple statements as above; it is thus very important to correctly use prepared statements to avoid the risk of <span class="s44">SQL </span>injection.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">5.1.1.6 Callable Statements</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s42">JDBC </span><span class="s43">also provides a </span><span class="s49">CallableStatement </span>interface that allows invocation of <span class="s44">SQL </span>stored procedures and functions (described in Section 5.2). These play the same role for func- tions and procedures as <span class="s49">prepareStatement </span>does for queries.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_902.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_903.png"/></span></p><p class="s151" style="padding-top: 4pt;padding-left: 145pt;text-indent: 0pt;line-height: 112%;text-align: left;">CallableStatement cStmt1 = conn.prepareCall(&quot;{? = call some function(?)}&quot;); CallableStatement cStmt2 = conn.prepareCall(&quot;{call some procedure(?,?)}&quot;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">The data types of function return values and out parameters of procedures must be registered using the method <span class="s49">registerOutParameter()</span>, and can be retrieved using get methods similar to those for result sets. See a <span class="s44">JDBC </span>manual for more details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">5.1.1.7 Metadata Features</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">As we noted earlier, a Java application program does not include declarations for data stored in the database. Those declarations are part of the <span class="s44">SQL DDL </span>statements. There- fore, a Java program that uses <span class="s44">JDBC </span>must either have assumptions about the database schema hard-coded into the program or determine that information directly from the database system at runtime. The latter approach is usually preferable, since it makes the application program more robust to changes in the database schema.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Recall that when we submit a query using the <span class="s49">executeQuery() </span>method, the result of the query is contained in a <span class="s49">ResultSet </span>object. The interface <span class="s49">ResultSet </span>has a method, <span class="s49">get- MetaData()</span>, that returns a <span class="s49">ResultSetMetaData </span>object that contains metadata about the result set. <span class="s49">ResultSetMetaData</span>, in turn, has methods to ﬁnd metadata information, such as the number of columns in the result, the name of a speciﬁed column, or the type of a speciﬁed column. In this way, we can write code to execute a query even if we have no prior knowledge of the schema of the result.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The following Java code segment uses <span class="s44">JDBC </span>to print out the names and types of all columns of a result set. The variable <span class="s49">rs </span>in the code is assumed to refer to a <span class="s49">ResultSet </span>instance obtained by executing a query.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 182pt;text-indent: 0pt;line-height: 86%;text-align: left;">ResultSetMetaData rsmd = rs.getMetaData(); for(inti= 1;i <span class="s186">&lt;</span>= rsmd.getColumnCount(); i++) {</p><p class="s49" style="padding-left: 203pt;text-indent: 0pt;line-height: 8pt;text-align: left;">System.out.println(rsmd.getColumnName(i));</p><p class="s49" style="padding-left: 203pt;text-indent: 0pt;text-align: left;">System.out.println(rsmd.getColumnTypeName(i));</p><p class="s49" style="text-indent: 0pt;text-align: center;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <span class="s49">getColumnCount() </span>method returns the arity (number of attributes) of the result relation. That allows us to iterate through each attribute (note that we start at 1, as is conventional in <span class="s44">JDBC</span>). For each attribute, we retrieve its name and data type using the methods <span class="s49">getColumnName() </span>and <span class="s49">getColumnTypeName()</span>, respectively.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <span class="s49">DatabaseMetaData </span>interface provides a way to ﬁnd metadata about the data- base. The interface <span class="s49">Connection </span>has a method <span class="s49">getMetaData() </span>that returns a <span class="s49">Database- MetaData </span>object. The <span class="s49">DatabaseMetaData </span>interface in turn has a very large number of methods to get metadata about the database and the database system to which the application is connected.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For example, there are methods that return the product name and version number of the database system. Other methods allow the application to query the database system about its supported features.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-top: 4pt;padding-left: 100pt;text-indent: 0pt;text-align: left;">DatabaseMetaData dbmd = conn.getMetaData();</p><p class="s49" style="padding-left: 100pt;text-indent: 0pt;text-align: left;">ResultSet rs = dbmd.getColumns(null, &quot;univdb&quot;, &quot;department&quot;, &quot;%&quot;);</p><p class="s49" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">// Arguments to getColumns: Catalog, Schema-pattern, Table-pattern,</p><p class="s49" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">//   and Column-Pattern</p><p class="s49" style="padding-left: 121pt;text-indent: 0pt;text-align: left;">// Returns: One row for each column; row has a number of attributes</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_904.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_905.png"/></span></p><p class="s49" style="padding-left: 60pt;text-indent: 0pt;text-align: center;">//   such as COLUMN NAME, TYPE NAME</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_906.png"/></span></p><p class="s49" style="padding-left: 121pt;text-indent: -21pt;text-align: left;">while( rs.next()) { System.out.println(rs.getString(&quot;COLUMN NAME&quot;),</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_907.png"/></span></p><p class="s49" style="padding-left: 56pt;text-indent: 0pt;line-height: 12pt;text-align: center;">rs.getString(&quot;TYPE NAME&quot;);</p><p class="s49" style="padding-left: 100pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_908.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s74" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;"><span class="s73">Figure 5.3 </span>Finding column information in <span class="s157">JDBC </span>using <span class="s157">DatabaseMetaData</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_909.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Still other methods return information about the database itself. The code in Fig- ure 5.3 illustrates how to ﬁnd information about columns (attributes) of relations in a database. The variable <span class="s49">conn </span>is assumed to be a handle for an already opened database connection. The method <span class="s49">getColumns() </span>takes four arguments: a catalog name (null signiﬁes that the catalog name is to be ignored), a schema name pattern, a table name pattern, and a column name pattern. The schema name, table name, and column name patterns can be used to specify a name or a pattern. Patterns can use the <span class="s44">SQL </span>string matching special characters “%” and “ ”; for instance, the pattern “%” matches all names. Only columns of tables of schemas satisfying the speciﬁed name or pattern are retrieved. Each row in the result set contains information about one column. The rows have a number of columns such as the name of the catalog, schema, table and column, the type of the column, and so on.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s49">getTables() </span>method allows you to get a list of all tables in the database. The ﬁrst three parameters to <span class="s49">getTables() </span>are the same as for <span class="s49">getColumns()</span>. The fourth parameter can be used to restrict the types of tables returned; if set to null, all tables, including system internal tables are returned, but the parameter can be set to restrict the tables returned to only user-created tables.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Examples of other methods provided by <span class="s49">DatabaseMetaData </span>that provide informa- tion about the database include those for primary keys (<span class="s49">getPrimaryKeys()</span>), foreign-key references (<span class="s49">getCrossReference())</span>, authorizations, database limits such as maximum number of connections, and so on.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The metadata interfaces can be used for a variety of tasks. For example, they can be used to write a database browser that allows a user to ﬁnd the tables in a database, examine their schema, examine rows in a table, apply selections to see desired rows, and so on. The metadata information can be used to make code used for these tasks generic; for example, code to display the rows in a relation can be written in such a way that it would work on all possible relations regardless of their schema. Similarly, it is</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">possible to write code that takes a query string, executes the query, and prints out the results as a formatted table; the code can work regardless of the actual query submitted.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">5.1.1.8 Other Features</p><p class="s42" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">JDBC <span class="s43">provides a number of other features, such as </span><span class="s63">updatable result sets</span><span class="p">. It can create an updatable result set from a query that performs a selection and/or a projection on a database relation. An update to a tuple in the result set then results in an update to the corresponding tuple of the database relation.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Recall from Section 4.3 that a transaction allows multiple actions to be treated as a single atomic unit which can be committed or rolled back. By default, each <span class="s44">SQL </span>state- ment is treated as a separate transaction that is committed automatically. The method <span class="s49">setAutoCommit() </span>in the <span class="s44">JDBC </span><span class="s49">Connection </span>interface allows this behavior to be turned on or oﬀ. Thus, if <span class="s49">conn </span>is an open connection, <span class="s49">conn.setAutoCommit(false) </span>turns oﬀ automatic commit. Transactions must then be committed or rolled back explicitly using either <span class="s49">conn.commit() </span>or <span class="s49">conn.rollback()</span>. <span class="s49">conn.setAutoCommit(true) </span>turns on auto- matic commit.</p><p class="s49" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;"><span class="s42">JDBC </span><span class="s43">provides interfaces to deal with large objects without requiring an entire large object to be created in memory. To fetch large objects, the </span>ResultSet <span class="p">interface provides methods </span>getBlob() <span class="p">and </span>getClob() <span class="p">that are similar to the </span>getString() <span class="p">method, but return objects of type </span>Blob <span class="p">and </span>Clob<span class="p">, respectively. These objects do not store the entire large object, but instead store “locators” for the large objects, that is, logical pointers to the actual large object in the database. Fetching data from these objects is very much like fetching data from a ﬁle or an input stream, and it can be performed using methods such as </span>getBytes() <span class="p">and </span>getSubString()<span class="p">.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Conversely, to store large objects in the database, the <span class="s49">PreparedStatement </span>class permits a database column whose type is <b>blob </b>to be linked to an input stream (such as a ﬁle that has been opened) using the method <span class="s49">setBlob(int parameterIndex, Input- Stream inputStream)</span>. When the prepared statement is executed, data are read from the input stream and written to the <b>blob </b>in the database. Similarly, a <b>clob </b>column can be set using the <span class="s49">setClob() </span>method, which takes as arguments a parameter index and a character stream.</p><p class="s42" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">JDBC <span class="s43">includes a </span><span class="s13">row set </span><span class="p">feature that allows result sets to be collected and shipped to other applications. Row sets can be scanned both backward and forward and can be modiﬁed.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">5.1.2 Database Access from Python</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Database access can be done from Python as illustrated by the method shown in Figure</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">5.4. The statement containing the <span class="s49">insert </span>query shows how to use the Python equivalent of <span class="s44">JDBC </span>prepared statements, with parameters identiﬁed in the <span class="s44">SQL </span>query by “%s”, and parameter values provided as a list. Updates are not committed to the database automatically; the <span class="s49">commit() </span>method needs to be called to commit an update.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-top: 4pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">import psycopg2</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 130pt;text-indent: -21pt;text-align: left;">def PythonDatabaseExample(userid, passwd) try:</p><p class="s49" style="padding-left: 193pt;text-indent: -42pt;text-align: left;">conn = psycopg2.connect( host=&quot;db.yale.edu&quot;, port=5432, dbname=&quot;univdb&quot;, user=userid, password=passwd)</p><p class="s49" style="padding-left: 151pt;text-indent: 0pt;text-align: left;">cur = conn.cursor() try:</p><p class="s49" style="padding-left: 215pt;text-indent: -42pt;text-align: left;">cur.execute(&quot;insert into instructor values(%s, %s, %s, %s)&quot;, (&quot;77987&quot;,&quot;Kim&quot;,&quot;Physics&quot;,98000))</p><p class="s49" style="padding-left: 151pt;text-indent: 21pt;text-align: left;">conn.commit(); except Exception as sqle:</p><p class="s49" style="padding-left: 172pt;text-indent: 0pt;text-align: left;">print(&quot;Could not insert tuple. &quot;, sqle) conn.rollback()</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_910.png"/></span></p><p class="s49" style="padding-left: 151pt;text-indent: 0pt;line-height: 12pt;text-align: left;">cur.execute( (&quot;select dept name, avg (salary) &quot;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_911.png"/></span></p><p class="s49" style="padding-left: 151pt;text-indent: 63pt;text-align: left;">&quot; from instructor group by dept name&quot;)) for dept in cur:</p><p class="s49" style="padding-left: 130pt;text-indent: 42pt;text-align: left;">print dept[0], dept[1] except Exception as sqle:</p><p class="s49" style="padding-left: 151pt;text-indent: 0pt;line-height: 12pt;text-align: left;">print(&quot;Exception : &quot;, sqle)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_912.png"/></span></p><p class="s73" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 5.4 <span class="s74">Database access from Python</span></p><p class="s49" style="padding-top: 9pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="p">The </span>try:<span class="p">, </span>except <span class="s185">…</span>: <span class="p">block shows how to catch exceptions and to print information about the exception. The </span>for <span class="p">loop illustrates how to loop over the result of a query execution, and to access individual attributes of a particular row.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_913.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The preceding program uses the <span class="s49">psycopg2 </span>driver, which allows connection to <span class="s44">P</span>ostgre<span class="s44">SQL </span>databases and is imported in the ﬁrst line of the program. Drivers are usu- ally database speciﬁc, with the <span class="s44">M</span>y<span class="s44">SQL</span>db driver to connect to <span class="s44">M</span>y<span class="s44">SQL</span>, and cx Oracle to connect to Oracle; but the <span class="s49">pyodbc </span>driver can connect to most databases that support <span class="s44">ODBC</span>. The Python Database <span class="s44">API </span>used in the program is implemented by drivers for many databases, but unlike with <span class="s44">JDBC</span>, there are minor diﬀerences in the <span class="s44">API </span>across diﬀerent drivers, in particular in the parameters to the <span class="s49">connect() </span>function.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">5.1.3 ODBC</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <span class="s63">Open Database Connectivity </span>(<span class="s64">ODBC</span>) standard deﬁnes an <span class="s44">API </span>that applications can use to open a connection with a database, send queries and updates, and get back results. Applications such as graphical user interfaces, statistics packages, and spread- sheets can make use of the same <span class="s44">ODBC API </span>to connect to any database server that supports <span class="s44">ODBC</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Each database system supporting <span class="s44">ODBC </span>provides a library that must be linked with the client program. When the client program makes an <span class="s44">ODBC API </span>call, the code</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_914.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-top: 4pt;padding-left: 138pt;text-indent: 0pt;text-align: left;">void <span class="s157">ODBCexample</span>()</p><p class="s49" style="padding-left: 138pt;text-indent: 0pt;text-align: left;">{</p><p class="s151" style="padding-left: 159pt;text-indent: 0pt;text-align: left;">RETCODE <span class="s187">error;</span></p><p class="s151" style="padding-left: 159pt;text-indent: 0pt;text-align: left;">HENV <span class="s187">env; /* environment */</span></p><p class="s151" style="padding-left: 159pt;text-indent: 0pt;text-align: left;">HDBC <span class="s187">conn; /* database connection */</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s151" style="padding-left: 159pt;text-indent: 0pt;text-align: left;">SQLAllocEnv<span class="s187">(&amp;env); </span>SQLAllocConnect<span class="s187">(env, &amp;conn);</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_915.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_916.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_917.png"/></span></p><p class="s151" style="padding-left: 223pt;text-indent: -63pt;text-align: left;">SQLConnect<span class="s187">(conn, &quot;db.yale.edu&quot;, </span>SQL NTS<span class="s187">, &quot;avi&quot;, </span>SQL NTS<span class="s187">, &quot;avipasswd&quot;, </span>SQL NTS<span class="s187">);</span></p><p class="s49" style="padding-left: 159pt;text-indent: 0pt;line-height: 12pt;text-align: left;">{</p><p class="s49" style="padding-left: 181pt;text-indent: 0pt;text-align: left;">char deptname[80]; float salary;</p><p class="s49" style="padding-left: 181pt;text-indent: 0pt;line-height: 12pt;text-align: left;">int lenOut1, lenOut2;</p><p class="s151" style="padding-left: 181pt;text-indent: 0pt;text-align: left;">HSTMT <span class="s187">stmt;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_918.png"/></span></p><p class="s49" style="padding-left: 265pt;text-indent: -84pt;text-align: left;">char * sqlquery = &quot;select dept name, sum (salary) from instructor</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_919.png"/></span></p><p class="s49" style="padding-left: 265pt;text-indent: 0pt;line-height: 12pt;text-align: left;">group by dept name&quot;;</p><p class="s151" style="padding-left: 181pt;text-indent: 0pt;text-align: left;">SQLAllocStmt<span class="s187">(conn, &amp;stmt);</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_920.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_921.png"/></span></p><p class="s49" style="padding-left: 181pt;text-indent: 0pt;text-align: left;">error = <span class="s157">SQLExecDirect</span>(stmt, sqlquery, <span class="s157">SQL NTS</span>); if (error == <span class="s157">SQL SUCCESS</span>){ </p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_922.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_923.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_924.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_925.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_926.png"/></span></p><p class="s151" style="padding-left: 202pt;text-indent: 0pt;text-align: left;">SQLBindCol<span class="s187">(stmt, 1, </span>SQL C CHAR<span class="s187">, deptname , 80, &amp;lenOut1); </span>SQLBindCol<span class="s187">(stmt, 2, </span>SQL C FLOAT<span class="s187">, &amp;salary, 0 , &amp;lenOut2); while (</span>SQLFetch<span class="s187">(stmt) </span><span class="s185">== </span>SQL SUCCESS<span class="s187">){ </span></p><p class="s49" style="padding-left: 223pt;text-indent: 0pt;line-height: 12pt;text-align: left;">printf (&quot; %s %g<span class="s185">∖</span>n&quot;, deptname, salary);</p><p class="s49" style="text-indent: 0pt;text-align: center;">}</p><p class="s49" style="text-indent: 0pt;text-align: center;">}</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_927.png"/></span></p><p class="s151" style="padding-left: 8pt;text-indent: 0pt;text-align: center;">SQLFreeStmt<span class="s187">(stmt, </span>SQL DROP<span class="s187">);</span></p><p class="s49" style="padding-left: 159pt;text-indent: 0pt;text-align: left;">}</p><p class="s151" style="padding-left: 159pt;text-indent: 0pt;text-align: left;">SQLDisconnect<span class="s187">(conn); </span>SQLFreeConnect<span class="s187">(conn); </span>SQLFreeEnv<span class="s187">(env);</span></p><p class="s49" style="padding-left: 138pt;text-indent: 0pt;line-height: 12pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_928.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 233pt;text-indent: 0pt;text-align: left;">Figure 5.5 <span class="s151">ODBC </span><span class="s152">code example.</span></p><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">in the library communicates with the server to carry out the requested action and fetch results.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Figure 5.5 shows an example of C code using the <span class="s44">ODBC API</span>. The ﬁrst step in using <span class="s44">ODBC </span>to communicate with a server is to set up a connection with the server. To do so, the program ﬁrst allocates an SQL environment, then a database connection handle. <span class="s44">ODBC </span>deﬁnes the types <span class="s49">HENV</span>, <span class="s49">HDBC</span>, and <span class="s49">RETCODE</span>. The program then opens the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_929.png"/></span></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">database connection by using <span class="s49">SQLConnect</span>. This call takes several parameters, includ- ing the connection handle, the server to which to connect, the user identiﬁer, and the password for the database. The constant <span class="s49">SQL NTS </span>denotes that the previous argument is a null-terminated string.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Once the connection is set up, the program can send <span class="s44">SQL </span>commands to the database by using <span class="s49">SQLExecDirect</span>. C language variables can be bound to attributes of the query result, so that when a result tuple is fetched using <span class="s49">SQLFetch</span>, its attribute val- ues are stored in corresponding C variables. The <span class="s49">SQLBindCol </span>function does this task; the second argument identiﬁes the position of the attribute in the query result, and the third argument indicates the type conversion required from <span class="s44">SQL </span>to C. The next argu- ment gives the address of the variable. For variable-length types like character arrays, the last two arguments give the maximum length of the variable and a location where the actual length is to be stored when a tuple is fetched. A negative value returned for the length ﬁeld indicates that the value is <b>null</b>. For ﬁxed-length types such as integer or ﬂoat, the maximum length ﬁeld is ignored, while a negative value returned for the length ﬁeld indicates a null value.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_930.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s49">SQLFetch </span>statement is in a <b>while </b>loop that is executed until <span class="s49">SQLFetch </span>returns a value other than <span class="s49">SQL SUCCESS</span>. On each fetch, the program stores the values in C variables as speciﬁed by the calls on <span class="s49">SQLBindCol </span>and prints out these values.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">At the end of the session, the program frees the statement handle, disconnects from the database, and frees up the connection and <span class="s44">SQL </span>environment handles. Good programming style requires that the result of every function call must be checked to make sure there are no errors; we have omitted most of these checks for brevity.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">It is possible to create an <span class="s44">SQL </span>statement with parameters; for example, consider the statement <span class="s49">insert into department values(?,?,?)</span>. The question marks are placeholders for values which will be supplied later. The above statement can be “prepared,” that is, compiled at the database, and repeatedly executed by providing actual values for the placeholders— in this case, by providing a department name, building, and budget for the relation <i>department</i>.</p><p class="s42" style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">ODBC <span class="s43">deﬁnes functions for a variety of tasks, such as ﬁnding all the relations in the database and ﬁnding the names and types of columns of a query result or a relation in the database.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_931.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_932.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_933.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">By default, each <span class="s44">SQL </span>statement is treated as a separate transaction that is commit- ted automatically. The <span class="s49">SQLSetConnectOption</span>(<span class="s49">conn</span>, <span class="s49">SQL AUTOCOMMIT, 0) </span>turns oﬀ automatic commit on connection <span class="s49">conn</span>, and transactions must then be committed explicitly by <span class="s49">SQLTransact(conn, SQL COMMIT) </span>or rolled back by <span class="s49">SQLTransact(conn, SQL ROLLBACK)</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s44">ODBC </span>standard deﬁnes <i>conformance levels</i>, which specify subsets of the func- tionality deﬁned by the standard. An <span class="s44">ODBC </span>implementation may provide only core level features, or it may provide more advanced (level 1 or level 2) features. Level 1 requires support for fetching information about the catalog, such as information about what relations are present and the types of their attributes. Level 2 requires further fea-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">tures, such as the ability to send and retrieve arrays of parameter values and to retrieve more detailed catalog information.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: left;">The <span class="s44">SQL </span>standard deﬁnes a <b>call level interface (CLI) </b>that is similar to the <span class="s44">ODBC</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">interface.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">5.1.4 Embedded SQL</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The <span class="s44">SQL </span>standard deﬁnes embeddings of <span class="s44">SQL </span>in a variety of programming languages, such as C, C++, Cobol, Pascal, Java, <span class="s44">PL/I</span>, and Fortran. A language in which <span class="s44">SQL </span>queries are embedded is referred to as a <i>host </i>language, and the <span class="s44">SQL </span>structures per- mitted in the host language constitute <i>embedded </i><span class="s42">SQL</span><span class="s43">.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Programs written in the host language can use the embedded <span class="s44">SQL </span>syntax to access and update data stored in a database. An embedded <span class="s44">SQL </span>program must be processed by a special preprocessor prior to compilation. The preprocessor replaces embedded <span class="s44">SQL </span>requests with host-language declarations and procedure calls that allow runtime execution of the database accesses. Then the resulting program is compiled by the host- language compiler. This is the main distinction between embedded <span class="s44">SQL </span>and <span class="s44">JDBC </span>or <span class="s44">ODBC</span>.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: left;">To identify embedded <span class="s44">SQL </span>requests to the preprocessor, we use the <span class="s44">EXEC SQL</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">statement; it has the form:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 216pt;text-indent: 0pt;text-align: left;"><span class="s42">EXEC SQL </span><span class="s83">&lt;</span>embedded <span class="s44">SQL </span>statement <span class="s83">&gt;</span>;</p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Before executing any <span class="s44">SQL </span>statements, the program must ﬁrst connect to the database. Variables of the host language can be used within embedded <span class="s44">SQL </span>statements, but they must be preceded by a colon (:) to distinguish them from <span class="s44">SQL </span>variables.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To iterate over the results of an embedded <span class="s44">SQL </span>query, we must declare a <i>cursor </i>variable, which can then be opened, and <i>fetch </i>commands issued in a host language loop to fetch consecutive rows of the query result. Attributes of a row can be fetched into host language variables. Database updates can also be performed using a cursor on a relation to iterate through the rows of the relation, optionally using a <b>where </b>clause to iterate through only selected rows. Embedded <span class="s44">SQL </span>commands can be used to update the current row where the cursor is pointing.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The exact syntax for embedded <span class="s44">SQL </span>requests depends on the language in which <span class="s44">SQL </span>is embedded. You may refer to the manuals of the speciﬁc language embedding that you use for further details.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In <span class="s44">JDBC</span>, <span class="s44">SQL </span>statements are interpreted at runtime (even if they are created using the prepared statement feature). When embedded <span class="s44">SQL </span>is used, there is a potential for catching some SQL-related errors (including data-type errors) at the time of prepro- cessing. <span class="s44">SQL </span>queries in embedded <span class="s44">SQL </span>programs are also easier to comprehend than in programs using dynamic <span class="s44">SQL</span>. However, there are also some disadvantages with em- bedded <span class="s44">SQL</span>. The preprocessor creates new host language code, which may complicate debugging of the program. The constructs used by the preprocessor to identify <span class="s44">SQL</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-left: 43pt;text-indent: 0pt;text-align: center;"><a name="bookmark70">Note 5.1 </a><span class="s146">EMBEDDED DATABASES</span><a name="bookmark110">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 9pt;text-indent: 0pt;text-align: justify;">Both <span class="s44">JDBC </span>and <span class="s44">ODBC </span>assume that a server is running on the database system hosting the database. Some applications use a database that exists entirely within the application. Such applications maintain the database only for internal use and oﬀer no accessibility to the database except through the application itself. In such cases, one may use an <span class="s63">embedded database </span>and use one of several packages that implement an <span class="s44">SQL </span>database accessible from within a programming language. Pop-</p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">ular choices include Java DB, <span class="s44">SQL</span>ite, <span class="s44">HSQLBD</span>, and <span class="s129">˝</span>2. There is also an embedded version of <span class="s44">M</span>y<span class="s44">SQL</span>.</p><p style="padding-left: 9pt;text-indent: 17pt;text-align: justify;">Embedded database systems lack many of the features of full server-based database systems, but they oﬀer advantages for applications that can beneﬁt from the database abstractions but do not need to support very large databases or large- scale transaction processing.</p><p style="padding-left: 9pt;text-indent: 17pt;text-align: justify;">Do not confuse embedded databases with embedded <span class="s44">SQL</span>; the latter is a means of connecting to a database running on a server.</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">statements may clash syntactically with host language syntax introduced in subsequent versions of the host language.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As a result, most current systems use dynamic <span class="s44">SQL</span>, rather than embedded <span class="s44">SQL</span>. One exception is the Microsoft Language Integrated Query (<span class="s44">LINQ</span>) facility, which ex- tends the host language to include support for queries instead of using a preprocessor to translate embedded <span class="s44">SQL </span>queries into the host language.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part117.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part119.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
