<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>8.5 Tuning MLFQ And Other Issues</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part88.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part90.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">8.5 Tuning MLFQ And Other Issues</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">A few other issues arise with MLFQ scheduling. One big question is how to <b>parameterize </b>such a scheduler. For example, how many queues should there be? How big should the time slice be per queue? How often should priority be boosted in order to avoid starvation and account for changes in behavior? There are no easy answers to these questions, and thus only some experience with workloads and subsequent tuning of the scheduler will lead to a satisfactory balance.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">For example, most MLFQ variants allow for varying time-slice length across different queues. The high-priority queues are usually given short time slices; they are comprised of interactive jobs, after all, and thus quickly alternating between them makes sense (e.g., 10 or fewer millisec- onds). The low-priority queues, in contrast, contain long-running jobs that are CPU-bound; hence, longer time slices work well (e.g., 100s of ms). Figure <span style=" color: #00AEEF;">8.7 </span>shows an example in which two long-running jobs run for 10 ms at the highest queue, 20 in the middle, and 40 at the lowest.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: A<span class="s7">VOID </span>V<span class="s7">OO</span>-<span class="s7">DOO </span>C<span class="s7">ONSTANTS </span>(O<span class="s7">USTERHOUT</span>’<span class="s7">S </span>L<span class="s7">AW</span>)</p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Avoiding voo-doo constants is a good idea whenever possible. Unfor- tunately, as in the example above, it is often difficult. One could try to make the system learn a good value, but that too is not straightforward. The frequent result: a configuration file filled with default parameter val- ues that a seasoned administrator can tweak when something isn’t quite working correctly. As you can imagine, these are often left unmodified, and thus we are left to hope that the defaults work well in the field. This tip brought to you by our old OS professor, John Ousterhout, and hence we call it <b>Ousterhout’s Law</b>.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">The Solaris MLFQ implementation – the Time-Sharing scheduling class, or TS – is particularly easy to configure; it provides a set of tables that determine exactly how the priority of a process is altered throughout its lifetime, how long each time slice is, and how often to boost the priority of a job [AD00]; an administrator can muck with this table in order to make the scheduler behave in different ways. Default values for the table are 60 queues, with slowly increasing time-slice lengths from 20 milliseconds (highest priority) to a few hundred milliseconds (lowest), and priorities boosted around every 1 second or so.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Other MLFQ schedulers don’t use a table or the exact rules described in this chapter; rather they adjust priorities using mathematical formu- lae. For example, the FreeBSD scheduler (version 4.3) uses a formula to calculate the current priority level of a job, basing it on how much CPU the process has used [LM+89]; in addition, usage is decayed over time, providing the desired priority boost in a different manner than described herein. See [E95] for an excellent overview of such <b>decay-usage </b>algo- rithms and their properties.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Finally, many schedulers have a few other features that you might en- counter. For example, some schedulers reserve the highest priority levels for operating system work; thus typical user jobs can never obtain the highest levels of priority in the system. Some systems also allow some user <b>advice </b>to help set priorities; for example, by using the command-line utility <span class="s41">nice </span>you can increase or decrease the priority of a job (somewhat) and thus increase or decrease its chances of running at any given time. See the man page for more.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part88.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part90.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
