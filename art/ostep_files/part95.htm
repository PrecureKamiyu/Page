<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>9.1 Basic Concept: Tickets Represent Your Share</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part94.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part96.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 16pt;text-indent: 0pt;text-align: left;">9.1 Basic Concept: Tickets Represent Your Share</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Underlying lottery scheduling is one very basic concept: <b>tickets</b>, which are used to represent the share of a resource that a process (or user or whatever) should receive. The percent of tickets that a process has repre- sents its share of the system resource in question.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let’s look at an example. Imagine two processes, A and B, and further that A has 75 tickets while B has only 25. Thus, what we would like is for A to receive 75% of the CPU and B the remaining 25%.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Lottery scheduling achieves this probabilistically (but not determinis- tically) by holding a lottery every so often (say, every time slice). Holding a lottery is straightforward: the scheduler must know how many total tickets there are (in our example, there are 100). The scheduler then picks</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">83</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: U<span class="s7">SE </span>R<span class="s7">ANDOMNESS</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">One of the most beautiful aspects of lottery scheduling is its use of <b>ran- domness</b>. When you have to make a decision, using such a randomized approach is often a robust and simple way of doing so.</p><p style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Random approaches has at least three advantages over more traditional decisions. First, random often avoids strange corner-case behaviors that a more traditional algorithm may have trouble handling. For example, consider LRU page replacement (studied in more detail in a future chap- ter on virtual memory); while often a good replacement algorithm, LRU performs pessimally for some cyclic-sequential workloads. Random, on the other hand, has no such worst case.</p><p style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Second, random also is lightweight, requiring little state to track alter- natives. In a traditional fair-share scheduling algorithm, tracking how much CPU each process has received requires per-process accounting, which must be updated after running each process. Doing so randomly necessitates only the most minimal of per-process state (e.g., the number of tickets each has).</p><p style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Finally, random can be quite fast. As long as generating a random num- ber is quick, making the decision is also, and thus random can be used in a number of places where speed is required. Of course, the faster the need, the more random tends towards pseudo-random.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">a winning ticket, which is a number from 0 to 99<span class="s35">1</span>. Assuming A holds tickets 0 through 74 and B 75 through 99, the winning ticket simply de- termines whether A or B runs. The scheduler then loads the state of that winning process and runs it.</p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Here is an example output of a lottery scheduler’s winning tickets:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: justify;">63 85 70 39 76 17 29 41 36 39 10 99 68 83 63 62 43 0 49 49</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 80pt;text-indent: 0pt;text-align: justify;">Here is the resulting schedule:</p><p class="s38" style="padding-top: 7pt;padding-left: 73pt;text-indent: 0pt;text-align: justify;">A B A A B A A A A A A B A B A A A A A A</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As you can see from the example, the use of randomness in lottery scheduling leads to a probabilistic correctness in meeting the desired pro- portion, but no guarantee. In our example above, B only gets to run 4 out of 20 time slices (20%), instead of the desired 25% allocation. However, the longer these two jobs compete, the more likely they are to achieve the desired percentages.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_103.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: left;">1<span class="s12">Computer Scientists always start counting at 0. It is so odd to non-computer-types that famous people have felt obliged to write about why we do it this way [D82].</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 68pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: U<span class="s7">SE </span>T<span class="s7">ICKETS </span>T<span class="s7">O </span>R<span class="s7">EPRESENT </span>S<span class="s7">HARES</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">One of the most powerful (and basic) mechanisms in the design of lottery (and stride) scheduling is that of the <b>ticket</b>. The ticket is used to represent a process’s share of the CPU in these examples, but can be applied much more broadly. For example, in more recent work on virtual memory man- agement for hypervisors, Waldspurger shows how tickets can be used to represent a guest operating system’s share of memory [W02]. Thus, if you are ever in need of a mechanism to represent a proportion of ownership, this concept just might be ... (wait for it) ... the ticket.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part94.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part96.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
