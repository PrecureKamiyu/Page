<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Multiprocessor Scheduling (Advanced)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part104.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part106.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Multiprocessor Scheduling (Advanced)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">This chapter will introduce the basics of <b>multiprocessor scheduling</b>. As this topic is relatively advanced, it may be best to cover it <i>after </i>you have studied the topic of concurrency in some detail (i.e., the second major “easy piece” of the book).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">After years of existence only in the high-end of the computing spec- trum, <b>multiprocessor </b>systems are increasingly commonplace, and have found their way into desktop machines, laptops, and even mobile de- vices. The rise of the <b>multicore </b>processor, in which multiple CPU cores are packed onto a single chip, is the source of this proliferation; these chips have become popular as computer architects have had a difficult time making a single CPU much faster without using (way) too much power. And thus we all now have a few CPUs available to us, which is a good thing, right?</p><p style="padding-bottom: 2pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Of course, there are many difficulties that arise with the arrival of more than a single CPU. A primary one is that a typical application (i.e., some C program you wrote) only uses a single CPU; adding more CPUs does not make that single application run faster. To remedy this problem, you’ll have to rewrite your application to run in <b>parallel</b>, perhaps using <b>threads </b>(as discussed in great detail in the second piece of this book). Multi- threaded applications can spread work across multiple CPUs and thus run faster when given more CPU resources.</p><p style="padding-top: 6pt;padding-left: 90pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A<span class="s7">SIDE</span>: <b>A</b><span class="s45">DVANCED </span><b>C</b><span class="s45">HAPTERS</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Advanced chapters require material from a broad swath of the book to truly understand, while logically fitting into a section that is earlier than said set of prerequisite materials. For example, this chapter on multipro- cessor scheduling makes much more sense if you’ve first read the middle piece on concurrency; however, it logically fits into the part of the book on virtualization (generally) and CPU scheduling (specifically). Thus, it is recommended such chapters be covered out of order; in this case, after the second piece of the book.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">93</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:191.39pt" cellspacing="0"><tr style="height:36pt"><td style="width:43pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s71" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">CPU</p></td></tr><tr style="height:14pt"><td style="width:43pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2" bgcolor="#D3D3D3"><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Cache</p></td></tr><tr style="height:22pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:2pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:21pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:2pt;border-bottom-style:solid;border-bottom-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:43pt"><td style="width:43pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" colspan="2"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s71" style="text-indent: 0pt;text-align: left;">Memory</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 140pt;text-indent: 0pt;text-align: justify;">Figure 10.1: <b>Single CPU With Cache</b></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Beyond applications, a new problem that arises for the operating sys- tem is (not surprisingly!) that of <b>multiprocessor scheduling</b>. Thus far we’ve discussed a number of principles behind single-processor schedul- ing; how can we extend those ideas to work on multiple CPUs? What new problems must we overcome? And thus, our problem:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>S<span class="s7">CHEDULE </span>J<span class="s7">OBS </span>O<span class="s7">N </span>M<span class="s7">ULTIPLE </span>CPU<span class="s7">S</span></p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: left;">How should the OS schedule jobs on multiple CPUs? What new prob- lems arise? Do the same old techniques work, or are new ideas required?</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part106.htm">10.1 Background: Multiprocessor Architecture</a><a class="toc0" href="part107.htm">10.2 Don’t Forget Synchronization</a><a class="toc0" href="part108.htm">10.3 One Final Issue: Cache Affinity</a><a class="toc0" href="part109.htm">10.4 Single-Queue Scheduling</a><a class="toc0" href="part110.htm">10.5 Multi-Queue Scheduling</a><a class="toc0" href="part111.htm">10.6 Linux Multiprocessor Schedulers</a><a class="toc0" href="part112.htm">10.7 Summary</a><a class="toc0" href="part113.htm">References</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part104.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part106.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
