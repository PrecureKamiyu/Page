<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>13.4 Goals</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part119.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part121.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">13.4 Goals</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus we arrive at the job of the OS in this set of notes: to virtualize memory. The OS will not only virtualize memory, though; it will do so with style. To make sure the OS does so, we need some goals to guide us. We have seen these goals before (think of the Introduction), and we’ll see them again, but they are certainly worth repeating.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One major goal of a virtual memory (VM) system is <b>transparency</b><span class="s35">2</span>. The OS should implement virtual memory in a way that is invisible to the running program. Thus, the program shouldn’t be aware of the fact that memory is virtualized; rather, the program behaves as if it has its own private physical memory. Behind the scenes, the OS (and hardware) does all the work to multiplex memory among many different jobs, and hence implements the illusion.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Another goal of VM is <b>efficiency</b>. The OS should strive to make the virtualization as <b>efficient </b>as possible, both in terms of time (i.e., not mak- ing programs run much more slowly) and space (i.e., not using too much memory for structures needed to support virtualization). In implement- ing time-efficient virtualization, the OS will have to rely on hardware support, including hardware features such as TLBs (which we will learn about in due course).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Finally, a third VM goal is <b>protection</b>. The OS should make sure to <b>protect </b>processes from one another as well as the OS itself from pro- cesses. When one process performs a load, a store, or an instruction fetch, it should not be able to access or affect in any way the memory contents of any other process or the OS itself (that is, anything <i>outside </i>its address space). Protection thus enables us to deliver the property of <b>isolation </b>among processes; each process should be running in its own isolated co- coon, safe from the ravages of other faulty or even malicious processes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_131.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 92%;text-align: justify;">2<span class="s12">This usage of transparency is sometimes confusing; some students think that “being transparent” means keeping everything out in the open, i.e., what government should be like. Here, it means the opposite: that the illusion provided by the OS should not be visible to ap- plications. Thus, in common usage, a transparent system is one that is hard to notice, not one that responds to requests as stipulated by the Freedom of Information Act.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="408" height="466" alt="image" src="Image_132.png"/></span></p><p class="s27" style="padding-left: 117pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>E<span class="s45">VERY </span>A<span class="s45">DDRESS </span>Y<span class="s45">OU </span>S<span class="s45">EE </span>I<span class="s45">S </span>V<span class="s45">IRTUAL</span></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Ever write a C program that prints out a pointer? The value you see (some large number, often printed in hexadecimal), is a <b>virtual address</b>. Ever wonder where the code of your program is found? You can print that out too, and yes, if you can print it, it also is a virtual address. In fact, any address you can see as a programmer of a user-level program is a virtual address. It’s only the OS, through its tricky techniques of virtualizing memory, that knows where in the physical memory of the machine these instructions and data values lie. So never forget: if you print out an address in a program, it’s a virtual one, an illusion of how things are laid out in memory; only the OS (and the hardware) knows the real truth.</p><p style="padding-top: 2pt;padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: justify;">Here’s a little program that prints out the locations of the <span class="s41">main() </span>rou- tine (where code lives), the value of a heap-allocated value returned from <span class="s41">malloc()</span>, and the location of an integer on the stack:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#include &lt;stdio.h&gt;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2  <span class="s38">#include &lt;stdlib.h&gt;</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">3  </span>int main(int argc, char <span class="s39">*</span>argv[]) {</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 85%;text-align: left;"><span class="s37">4     </span>printf(&quot;location of code : %p\n&quot;, (void <span class="s39">*</span>) main);</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">5     </span>printf(&quot;location of heap : %p\n&quot;, (void <span class="s39">*</span>) malloc(1));</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">6    <span class="s38">int x = 3;</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">7     </span>printf(&quot;location of stack : %p\n&quot;, (void <span class="s39">*</span>) &amp;x);</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">8    <span class="s38">return x;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">When run on a 64-bit Mac OS X machine, we get the following output:</p><p class="s38" style="padding-top: 6pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">location of code : 0x1095afe50 location of heap : 0x1096008c0 location of stack : 0x7fff691aea64</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">From this, you can see that code comes first in the address space, then the heap, and the stack is all the way at the other end of this large virtual space. All of these addresses are virtual, and will be translated by the OS and hardware in order to fetch values from their true physical locations.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In the next chapters, we’ll focus our exploration on the basic <b>mecha- nisms </b>needed to virtualize memory, including hardware and operating systems support. We’ll also investigate some of the more relevant <b>poli- cies </b>that you’ll encounter in operating systems, including how to manage free space and which pages to kick out of memory when you run low on space. In doing so, we’ll build up your understanding of how a modern</p><p style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">virtual memory system really works<span class="s35">3</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 5pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: left;">3<span class="s12">Or, we’ll convince you to drop the course. But hold on; if you make it through VM, you’ll likely make it all the way!</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part119.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part121.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
