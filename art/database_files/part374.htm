<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>20.6  Transaction Processing in Parallel and Distributed Systems</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part373.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part375.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">20.6  <span style=" color: #00AEEF;">Transaction Processing in Parallel and Distributed Systems</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Atomicity of transactions is an important issue in building a parallel and distributed database system. If a transaction runs across two nodes, unless the system designers are careful, it may commit at one node and abort at another, leading to an inconsistent state. Transaction commit protocols ensure such a situation cannot arise. The <i>two-phase commit protocol </i>(<span class="s44">2PC</span>) is the most widely used of these protocols.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <span class="s44">2PC </span>protocol is described in detail in Section 23.2.1, but the key ideas are as follows: The basic idea behind <span class="s44">2PC </span>is for each node to execute the transaction until it enters the partially committed state, and then leave the commit decision to a single coordinator node; the transaction is said to be in the <i>ready </i>state at a node at this point. The coordinator decides to commit the transaction only if the transaction reaches the ready state at every node where it executed; otherwise (e.g., if the transaction aborts at any node), the coordinator decides to abort the transaction. Every node where the transaction executed must follow the decision of the coordinator. If a node fails when a transaction is in ready state, when the node recovers from failure it should be in a position to either commit or abort the transaction, depending on the decision of the coordinator.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_3133.png"/></span></p><p class="s111" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: left;"><span class="s77">5</span><span class="s78">Do not confuse the term </span>network partitioning <span class="s80">with the term </span>data partitioning<span class="s80">; data partitioning refers to dividing up of data items into partitions, which may be stored at diﬀerent nodes.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;"><a name="bookmark456">Concurrency control is another issue in parallel and distributed databases. Since a transaction may access data items at several nodes, transaction managers at several nodes may need to coordinate to implement concurrency control. If locking is used, locking can be performed locally at the nodes containing accessed data items, but there is also a possibility of deadlock involving transactions originating at multiple nodes. Therefore deadlock detection needs to be carried out across multiple nodes. Failures are more common in distributed systems since not only may computers fail, but communication links may also fail. Replication of data items, which is the key to the continued functioning of distributed databases when failures occur, further compli- cates concurrency control. We describe concurrency-control techniques for distributed databases in Section 23.3 (which describes techniques based on locking) and Section</a><a name="bookmark503">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">23.3.4 (which describes techniques based on timestamps).</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The standard transaction models, based on multiple actions carried out by a single program unit, are often inappropriate for carrying out tasks that cross the boundaries of databases that cannot or will not cooperate to implement protocols such as <span class="s44">2PC</span>. Alternative approaches, based on <i>persistent messaging </i>for communication, are generally used for such tasks; persistent messaging is discussed in Section 23.2.3.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When the tasks to be carried out are complex, involving multiple databases and/or multiple interactions with humans, coordination of the tasks and ensuring transaction properties for the tasks become more complicated. <i>Workflow management systems </i>are systems designed to help with carrying out such tasks.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part373.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part375.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
