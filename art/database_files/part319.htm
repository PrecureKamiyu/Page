<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>17.9  Implementation of Isolation Levels</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part318.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part320.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 8pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">17.9  <span style=" color: #00AEEF;">Implementation of Isolation Levels</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">So far, we have seen what properties a schedule must have if it is to leave the database in a consistent state and allow transaction failures to be handled in a safe manner.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">There are various <span class="s63">concurrency-control </span>policies that we can use to ensure that, even when multiple transactions are executed concurrently, only acceptable schedules are generated, regardless of how the operating system time-shares resources (such as <span class="s44">CPU </span>time) among the transactions.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As a trivial example of a concurrency-control policy, consider this: A transaction acquires a <span class="s63">lock </span>on the entire database before it starts and releases the lock after it has committed. While a transaction holds a lock, no other transaction is allowed to acquire the lock, and all must therefore wait for the lock to be released. As a result of the locking policy, only one transaction can execute at a time. Therefore, only serial schedules are generated. These are trivially serializable, and it is easy to verify that they are recoverable and cascadeless as well.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">A concurrency-control policy such as this one leads to poor performance, since it forces transactions to wait for preceding transactions to ﬁnish before they can start. In other words, it provides a poor degree of concurrency (indeed, no concurrency at all). As we saw in Section 17.5, concurrent execution has substantial performance beneﬁts. The goal of concurrency-control policies is to provide a high degree of concurrency, while ensuring that all schedules that can be generated are conﬂict or view serializable,</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">recoverable, and cascadeless.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Here we provide an overview of how some of most important concurrency-control mechanisms work, and we defer the details to Chapter 18.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">17.9.1 Locking</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Instead of locking the entire database, a transaction could instead lock only those data items that it accesses. Under such a policy, the transaction must hold locks long enough to ensure serializability, but for a period short enough not to harm performance exces-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="493" height="580" alt="image" src="Image_2995.png"/></span></p><p class="s73" style="padding-left: 59pt;text-indent: 0pt;text-align: center;">Note 17.2 <span class="s146">SERIALIZABILITY IN THE REAL WORLD</span></p><p style="padding-top: 2pt;padding-left: 97pt;text-indent: 3pt;text-align: justify;">Serializable schedules are the ideal way to ensure consistency, but in our day-to- day lives, we don’t impose such stringent requirements. A web site oﬀering goods for sale may list an item as being in stock, yet by the time a user selects the item and goes through the checkout process, that item might no longer be available. Viewed from a database perspective, this would be a nonrepeatable read.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">As another example, consider seat selection for air travel. Assume that a trav- eler has already booked an itinerary and now is selecting seats for each ﬂight. Many airline web sites allow the user to step through the various ﬂights and choose a seat, after which the user is asked to conﬁrm the selection. It could be that other trav- elers are selecting seats or changing their seat selections for the same ﬂights at the same time. The seat availability that the traveler was shown is thus actually changing, but the traveler is shown a snapshot of the seat availability as of when the traveler started the seat selection process.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">Even if two travelers are selecting seats at the same time, most likely they will select diﬀerent seats, and if so there would be no real conﬂict. However, the trans- actions are not serializable, since each traveler has read data that was subsequently updated by the other traveler, leading to a cycle in the precedence graph. If two travelers performing seat selection concurrently actually selected the same seat, one of them would not be able to get the seat they selected; however, the situation could be easily resolved by asking the traveler to perform the selection again, with updated seat availability information.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">It is possible to enforce serializability by allowing only one traveler to do seat selection for a particular ﬂight at a time. However, doing so could cause signiﬁcant delays as travelers would have to wait for their ﬂight to become available for seat selection; in particular a traveler who takes a long time to make a choice could cause serious problems for other travelers. Instead, any such transaction is typically broken up into a part that requires user interaction and a part that runs exclusively on the database. In the example above, the database transaction would check if the seats chosen by the user are still available, and if so update the seat selection in the database. Serializability is ensured only for the transactions that run on the database, without user interaction.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">sively. Complicating matters are <span class="s44">SQL </span>statements where the data items accessed depend on a <b>where </b>clause, which we discuss in Section 17.10. In Chapter 18, we present the two-phase locking protocol, a simple, widely used technique that ensures serializability. Stated simply, two-phase locking requires a transaction to have two phases, one where it acquires locks but does not release any, and a second phase where the transaction re- leases locks but does not acquire any. (In practice, locks are usually released only when the transaction completes its execution and has been either committed or aborted.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Further improvements to locking result if we have two kinds of locks: shared and exclusive. Shared locks are used for data that the transaction reads and exclusive locks are used for those it writes. Many transactions can hold shared locks on the same data item at the same time, but a transaction is allowed an exclusive lock on a data item only if no other transaction holds any lock (regardless of whether shared or exclusive) on the data item. This use of two modes of locks along with two-phase locking allows concurrent reading of data while still ensuring serializability.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">17.9.2 Timestamps</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Another category of techniques for the implementation of isolation assigns each trans- action a <span class="s63">timestamp</span>, typically when it begins. For each data item, the system keeps two timestamps. The read timestamp of a data item holds the largest (that is, the most re- cent) timestamp of those transactions that read the data item. The write timestamp of a data item holds the timestamp of the transaction that wrote the current value of the data item. Timestamps are used to ensure that transactions access each data item in or- der of the transactions’ timestamps if their accesses conﬂict. When this is not possible, oﬀending transactions are aborted and restarted with a new timestamp.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">17.9.3 Multiple Versions and Snapshot Isolation</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">By maintaining more than one version of a data item, it is possible to allow a trans- action to read an old version of a data item rather than a newer version written by an uncommitted transaction or by a transaction that should come later in the serializa- tion order. There are a variety of multiversion concurrency-control techniques. One in particular, called <span class="s63">snapshot isolation</span>, is widely used in practice.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In snapshot isolation, we can imagine that each transaction is given its own version, or snapshot, of the database when it begins.<span class="s76">5</span> It reads data from this private version and is thus isolated from the updates made by other transactions. If the transaction updates the database, that update appears only in its own version, not in the actual database itself. Information about these updates is saved so that the updates can be applied to the “real” database if the transaction commits.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">When a transaction <i>T </i>enters the partially committed state, it then proceeds to the committed state only if no other concurrent transaction has modiﬁed data that <i>T </i>intends to update. Transactions that, as a result, cannot commit abort instead.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Snapshot isolation ensures that attempts to read data never need to wait (unlike locking). Read-only transactions cannot be aborted; only those that modify data run a slight risk of aborting. Since each transaction reads its own version or snapshot of the database, reading data does not cause subsequent update attempts by other transactions to wait (unlike locking). Since most transactions are read-only (and most others read more data than they update), this is often a major source of performance improvement as compared to locking.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2996.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">5<span class="s78">In reality, the entire database is not copied. Multiple versions are kept only of those data items that are changed.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;"><a name="bookmark376">The problem with snapshot isolation is that, paradoxically, it provides </a><i>too much </i>isolation. Consider two transactions <i>T </i>and <i>T </i><span class="s181">′</span>. In a serializable execution, either <i>T </i>sees all the updates made by <i>T </i><span class="s181">′</span><span class="s15"> </span>or <i>T </i><span class="s181">′</span><span class="s15"> </span>sees all the updates made by <i>T </i>, because one must follow the other in the serialization order. Under snapshot isolation, there are cases where neither transaction sees the updates of the other. This is a situation that cannot occur in a serializable execution. In many (indeed, most) cases, the data accesses by the two transactions do not conﬂict and there is no problem. However, if <i>T </i>reads some data item that <i>T </i><span class="s181">′</span><span class="s15"> </span>updates and <i>T </i><span class="s181">′</span><span class="s15"> </span>reads some data item that <i>T </i>updates, it is possible that both transactions fail to read the update made by the other. The result, as we shall see in Chapter 18, may be an inconsistent database state that, of course, could not be obtained in any serializable execution.<a name="bookmark418">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Oracle, <span class="s44">P</span>ostgre<span class="s44">SQL</span>, and <span class="s44">SQL </span>Server oﬀer the option of snapshot isolation. Oracle and <span class="s44">P</span>ostgre<span class="s44">SQL </span>versions prior to <span class="s44">P</span>ostgre<span class="s44">SQL </span>9.1 implement the <b>serializable </b>isolation level using snapshot isolation. As a result, their implementation of serializability can, in exceptional circumstances, result in a nonserializable execution being allowed. <span class="s44">SQL </span>Server instead includes an additional isolation level beyond the standard ones, called <b>snapshot</b>, to oﬀer the option of snapshot isolation. <span class="s44">P</span>ostgre<span class="s44">SQL </span>versions subsequent to 9.1 implement a form of concurrency control called serializable snapshot isolation, which provides the beneﬁts of snapshot isolation while ensuring serializability.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part318.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part320.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
