<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1252328" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_80"><span class="bold">19. Portability</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1252485"> </div>
<p class="calibre_2">Linux is a <em class="calibre4">portable</em> operating system that supports a wide range of computer architectures. <em class="calibre4">Portability</em> refers to how easily—if at all—code can move from one system architecture to another. We know that Linux is portable because it has already been <em class="calibre4">ported</em> to various systems. But this portability did not occur overnight—it requires diligence and a constant eye toward writing portable code. Consequently, it is now easy, relatively speaking, to bring Linux up on a new system. This chapter discusses how to write portable code—the issues you need to keep in mind when writing both core kernel code and device drivers.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1253255"> </div>
<h3 class="calibre_21"><span class="bold">Portable Operating Systems</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Some operating systems are designed with portability as a primary feature. As little code as possible is machine-specific. Assembly is kept to a minimum, and interfaces and features are sufficiently general and abstract so that they work on a wide range of architectures. The obvious benefit is the relative ease with which a new architecture can be supported. In some cases, highly portable and simple operating systems can be moved to a new architecture with just a few hundred lines of unique code. The downside is that architecture-specific features are not supported, and code cannot be hand-tuned for a specific machine. With this design choice, optimal code is traded for portable code. Some examples of highly portable operating systems are Minix, NetBSD, and many academic systems.</p><div class="calibre_3"> </div>
<p class="calibre_2">On the opposite side are operating systems that trade all portability for highly customized, optimal code. As much as possible, code is written in assembly or otherwise designed for a specific architecture. Kernel features are designed around specific architectural features. Consequently, moving the operating system to a new architecture is tantamount to rewriting the kernel from scratch and, even if possible, the operating system might be ill-suited for use on other architectures. With this design decision, portable code is traded for optimal code. Such systems are often harder to maintain than more portable systems. Of course, these systems need not be more efficient than a more portable system; their willingness to disregard portability, however, allows for a no-compromise design. Microsoft DOS and Windows 95 are two examples of this design decision.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1255141"></a>Linux takes the middle road toward portability. As much as practical, interfaces and core code are architecture-independent C code. Where performance is critical, however, kernel features are tuned for each architecture. For example, much fast-path and low-level code is architecture-dependent and often written in assembly. This approach enables Linux to remain portable without foregoing optimizations. Where portability would hinder performance, performance generally wins. Otherwise, code is kept portable.</p><div class="calibre_3"> </div>
<p class="calibre_2">Generally, exported kernel interfaces are architecture-independent. If any parts of the function need to be unique for each supported architecture (either for performance reasons or as a necessity), that code is implemented in separate functions and called as needed. Each supported architecture then implements its architecture-specific functions and links them into the kernel image.</p><div class="calibre_3"> </div>
<p class="calibre_2">A good example is the scheduler. The large majority of the scheduler is written in architecture-independent C and lives in <code class="calibre6"><span class="calibre7">kernel/sched.c</span></code>. A few jobs of the scheduler, such as switching processor state or swapping out the address space, are architecture-dependent. Consequently, the C method <code class="calibre6"><span class="calibre7">context_switch()</span></code>, which switches from one process to another, calls the methods <code class="calibre6"><span class="calibre7">switch_to()</span></code> and <code class="calibre6"><span class="calibre7">switch_mm()</span></code>, to switch processor state and switch address space, respectively.</p><div class="calibre_3"> </div>
<p class="calibre_2">The code for <code class="calibre6"><span class="calibre7">switch_to()</span></code> and <code class="calibre6"><span class="calibre7">switch_mm()</span></code> is independently implemented by each architecture that Linux supports. When Linux is ported to a new architecture, the new architecture must provide an implementation for these functions.</p><div class="calibre_3"> </div>
<p class="calibre_2">Architecture-specific files are located in <code class="calibre6"><span class="calibre7">arch/</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">architecture</span></code></em><code class="calibre6"><span class="calibre7">/</span></code>, where <em class="calibre4"><code class="calibre6"><span class="calibre7">architecture</span></code></em> is a short name representing each architecture in Linux. As an example, the Intel x86 architecture is given the short name <code class="calibre6"><span class="calibre7">x86</span></code>. (This architecture supports both x86-32 and x86-64.) Architecture-specific files for these machines live in <code class="calibre6"><span class="calibre7">arch/x86</span></code>. The supported architectures in the 2.6 kernel series are <code class="calibre6"><span class="calibre7">alpha</span></code>, <code class="calibre6"><span class="calibre7">arm</span></code>, <code class="calibre6"><span class="calibre7">avr32</span></code>, <code class="calibre6"><span class="calibre7">blackfin</span></code>, <code class="calibre6"><span class="calibre7">cris</span></code>, <code class="calibre6"><span class="calibre7">frv</span></code>, <code class="calibre6"><span class="calibre7">h8300</span></code>, <code class="calibre6"><span class="calibre7">ia64</span></code>, <code class="calibre6"><span class="calibre7">m32r</span></code>, <code class="calibre6"><span class="calibre7">m68k</span></code>, <code class="calibre6"><span class="calibre7">m68knommu</span></code>, <code class="calibre6"><span class="calibre7">mips</span></code>, <code class="calibre6"><span class="calibre7">mn10300</span></code>, <code class="calibre6"><span class="calibre7">parisc</span></code>, <code class="calibre6"><span class="calibre7">powerpc</span></code>, <code class="calibre6"><span class="calibre7">s390</span></code>, <code class="calibre6"><span class="calibre7">sh</span></code>, <code class="calibre6"><span class="calibre7">sparc</span></code>, <code class="calibre6"><span class="calibre7">um</span></code>, <code class="calibre6"><span class="calibre7">x86</span></code>, and <code class="calibre6"><span class="calibre7">xtensa</span></code>. A more complete listing of these architectures is in <a href="#filepos1258803">Table 19.1</a>, later in this chapter.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1258803"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 19.1. Supported Linux Architectures</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00250.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1259094"> </div>
<h3 class="calibre_21"><span class="bold">History of Portability in Linux</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">When Linus first unleashed Linux on the unsuspecting world, it ran only on Intel i386 machines. Although the operating system was rather generalized and well written, portability was not a major concern. In fact, Linus even once suggested Linux would never run on anything but the i386 architecture! In 1993, however, work began on porting Linux to the Digital Alpha architecture. The Digital Alpha was a modern high-performance RISC-based architecture with 64-bit memory addressing. This is a stark contrast to Linus’s original 386. Nonetheless, the initial port of Linux to the Alpha took about a year, and the Alpha became the first officially supported architecture after x86. This port was perhaps rather difficult because it had the unwelcome challenge of being the first. Instead of simply grafting support for the Alpha onto the kernel, pieces of the kernel were rewritten as <a id="filepos1260118"></a>needed with portability in mind.<sup class="calibre8"><a id="filepos1260155" href="#filepos1260369">1</a></sup> Although this made for more work overall, the result was much cleaner and future porting was made much easier.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1260369" href="#filepos1260155">1</a></sup>
<em class="calibre4">This is a common occurrence in Linux kernel development. If something is going to be done at all, it must be done right. Kernel developers are not averse to rewriting large amounts of code in the name of perfection.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">Although the first releases of Linux supported only the Intel i386 architecture, the 1.2 kernel series added support for Digital Alpha, MIPS, and SPARC—although support was somewhat experimental.</p><div class="calibre_3"> </div>
<p class="calibre_2">With the release of the 2.0 kernel, Linux officially added support for the Motorola 68k and PowerPC. Additionally, the architectures previously supported in 1.2 were labeled official and stable.</p><div class="calibre_3"> </div>
<p class="calibre_2">The 2.2 kernel series brought even more architecture support with the addition of ARM, IBM S/390, and UltraSPARC. A few years later, 2.4 nearly doubled the number of supported architectures to 15, as support was added for the CRIS, IA-64, 64-bit MIPS, HP PA-RISC, 64-bit IBM S/390, and Hitachi SH.</p><div class="calibre_3"> </div>
<p class="calibre_2">The current kernel, 2.6, brought the number of supported architectures to 21 with the addition of AVR, FR-V, Motorola 68k without MMU, M32xxx, H8/300, IBM POWER, Xtensa, and a version of the kernel that runs in a virtual machine under Linux, known as Usermode Linux.</p><div class="calibre_3"> </div>
<p class="calibre_2">Each of these architectures supports various chip and machine types. Some supported architectures, such as ARM and PowerPC, each support many different chips and machine types. Others, such as x86 and SPARC, support both 32-bit and 64-bit variants of their processors. Therefore, although Linux runs under 21 broad architectures, it runs on many more machines!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1262269"> </div>
<h3 class="calibre_21"><span class="bold">Word Size and Data Types</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">A <em class="calibre4">word</em> is the amount of data that a machine can process at one time. This fits into the document analogy that includes <em class="calibre4">characters</em> (usually 8 bits) and <em class="calibre4">pages</em> (many words, often 4KB or 8KB worth) as other measurements of data. A word is an integer number of bytes—for example, one, two, four, or eight. When someone talks about the “n-bits” of a machine, they are generally talking about the machine’s <em class="calibre4">word size</em>. For example, when people say that the Intel i7 is a 64-bit chip, they are referring to its word size, which is 64 bits, or eight bytes.</p><div class="calibre_3"> </div>
<p class="calibre_2">The size of a processor’s general-purpose registers (GPRs) is equal to its word size. The widths of the components in a given architecture—for example, the memory bus—are usually at least as wide as the word size. Typically, at least in the architectures that Linux supports, the virtual memory address space is equal to the word size, although the physical address space is sometimes less. Consequently, the size of a pointer is equal to the word size. Additionally, the size of the C type <code class="calibre6"><span class="calibre7">long</span></code> is equal to the word size, whereas the size of <a id="filepos1263649"></a>the <code class="calibre6"><span class="calibre7">int</span></code> type is sometimes less than that of the word size. For example, the Alpha has a 64-bit word size. Consequently, registers, pointers, and the <code class="calibre6"><span class="calibre7">long</span></code> type are 64 bits in length. The <code class="calibre6"><span class="calibre7">int</span></code> type, however, is 32-bits long. The Alpha can access and manipulate 64 bits—one word—at a time.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Words, Doublewords, and Confusion</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">Some operating systems and processors do not call the standard data size a <em class="calibre4">word</em>. Instead, a word is some fixed size based on history or arbitrary naming decisions. For example, some operating systems might partition data sizes into bytes (8 bits), words (16 bits), double words (32 bits), and quad words (64 bits), despite the fact that the system in question may be 32 bits. Windows NT-based systems, such as Windows 7, employ this naming scheme. In this book—and Linux in general—a word is the standard data size of the processor, as previously discussed.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2">Each supported architecture under Linux defines <code class="calibre6"><span class="calibre7">BITS_PER_LONG</span></code> in <code class="calibre6"><span class="calibre7">&lt;asm/types.h&gt;</span></code> to the length of the C <code class="calibre6"><span class="calibre7">long</span></code> type, which is the system word size. A full listing of all supported architectures and their word size is in <a href="#filepos1258803">Table 19.1</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1265450"></a>Traditionally, Linux implemented 32- and 64-bit variants of a given architecture separately. For example, early in the 2.6 kernel series there existed both <code class="calibre6"><span class="calibre7">i386</span></code> &amp; <code class="calibre6"><span class="calibre7">x86-64</span></code>, <code class="calibre6"><span class="calibre7">mips</span></code> &amp; <code class="calibre6"><span class="calibre7">mips64</span></code>, and <code class="calibre6"><span class="calibre7">ppc</span></code> &amp; <code class="calibre6"><span class="calibre7">ppc64</span></code> architectures. An effort, now complete, has unified these architectures under a single directory in <code class="calibre6"><span class="calibre7">arch/</span></code>, capable of supporting both 32 and 64-bits from a single codebase.</p><div class="calibre_3"> </div>
<p class="calibre_2">The C standard explicitly leaves the size of the standard variable types up to implementations.<sup class="calibre8"><a id="filepos1266232" href="#filepos1266972">2</a></sup> The uncertainty in the standard C types across architectures is both a pro and a con. On the plus side, the standard types can take advantage of the word size of various architectures, and types need not explicitly specify a size. The size of the C <code class="calibre6"><span class="calibre7">long</span></code> type is guaranteed to be the machine’s word size. On the downside, however, code cannot assume that the standard C types have any specific size. Furthermore, there is no guarantee that an <code class="calibre6"><span class="calibre7">int</span></code> is the same size as a <code class="calibre6"><span class="calibre7">long.</span></code><sup class="calibre8"><a id="filepos1266869" href="#filepos1267175">3</a></sup></p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1266972" href="#filepos1266232">2</a></sup>
<em class="calibre4">With the exception of <code class="calibre6"><span class="calibre7">char</span></code>, which is always 1 byte.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1267175" href="#filepos1266869">3</a></sup>
<em class="calibre4">On the 64-bit architectures supported in Linux, in fact, an <code class="calibre6"><span class="calibre7">int</span></code> and a <code class="calibre6"><span class="calibre7">long</span></code> are not the same size; an <code class="calibre6"><span class="calibre7">int</span></code> is 32 bits and a <code class="calibre6"><span class="calibre7">long</span></code> is 64 bits. Linux’s supported 32-bit architectures define both <code class="calibre6"><span class="calibre7">int</span></code> and <code class="calibre6"><span class="calibre7">long</span></code> to 32 bits.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">The situation grows even more confusing because there doesn’t need to be a relation between the types in user-space and kernel-space. The <code class="calibre6"><span class="calibre7">sparc64</span></code> architecture provides a 32-bit user-space; therefore, pointers and both the <code class="calibre6"><span class="calibre7">int</span></code> and <code class="calibre6"><span class="calibre7">long</span></code> types are 32-bit. In kernel-space, however, <code class="calibre6"><span class="calibre7">sparc64</span></code> has a 32-bit <code class="calibre6"><span class="calibre7">int</span></code> type and 64-bit pointers and <code class="calibre6"><span class="calibre7">long</span></code> types. This is not the norm, however.</p><div class="calibre_3"> </div>
<p class="calibre_2">Some rules to keep in mind:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• As dictated by the ANSI C standard, a <code class="calibre6"><span class="calibre7">char</span></code> is always 1 byte.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Although there is no rule that the <code class="calibre6"><span class="calibre7">int</span></code> type be 32 bits, it is in Linux on all currently supported architectures.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The same goes for the <code class="calibre6"><span class="calibre7">short</span></code> type, which is 16 bits on all current architectures, although no rule explicitly decrees that.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Never assume the size of a pointer or a <code class="calibre6"><span class="calibre7">long</span></code>, which can be either 32 bits or 64 bits on the currently supported machines in Linux.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Because the size of a <code class="calibre6"><span class="calibre7">long</span></code> varies on different architectures, <em class="calibre4">never</em> assume that <code class="calibre6"><span class="calibre7">sizeof(int)</span></code> is equal to <code class="calibre6"><span class="calibre7">sizeof(long).</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Likewise, do not assume that a pointer and an <code class="calibre6"><span class="calibre7">int</span></code> are the same size.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Operating systems use a simple mnemonic to describe what sizes their types are. For example, 64-bit Windows is said to be <em class="calibre4">LLP64</em>, which means that <code class="calibre6"><span class="calibre7">long</span></code> and pointer types <a id="filepos1270064"></a>are 64 bits. 64-bit Linux systems are <em class="calibre4">LP64</em>: <code class="calibre6"><span class="calibre7">long</span></code> and pointer types are 64-bit. 32-bit Linux systems are ILP32: <code class="calibre6"><span class="calibre7">int</span></code>, <code class="calibre6"><span class="calibre7">long</span></code>, and pointer types are all 32-bit. The mnemonic is useful for showing at a glance what type of operating system implements its word size, because that choice involves a trade off.</p><div class="calibre_3"> </div>
<p class="calibre_2">Consider ILP64, LP64, and LLP64. In ILP64, the <code class="calibre6"><span class="calibre7">int</span></code>, <code class="calibre6"><span class="calibre7">long</span></code>, and pointer types are all 64 bits in size. This makes programming easier because the main C types are the same size (size mismatch between integers and pointers is a frequent source of programming error), but it has the downside that the common integer type is much larger than often needed. In LP64, programmers can use differently sized integer types, but must be mindful that the size of an <code class="calibre6"><span class="calibre7">int</span></code> type is smaller than that of a pointer. With LLP64, programmers are stuck with both <code class="calibre6"><span class="calibre7">int</span></code> and <code class="calibre6"><span class="calibre7">long</span></code> types of the same size and also have to worry about a size mismatch between all integers and pointers. Most programmers greatly prefer LP64, the model Linux employs.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1271473"> </div>
<h4 class="calibre_27"><span class="calibre3">Opaque Types</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Opaque data types do not reveal their internal format or structure. They are about as “black box” as you can get in C. There is not a lot of language support for them. Instead, developers declare a <code class="calibre6"><span class="calibre7">typedef</span></code>, call it an opaque type, and hope no one typecasts it back to a standard C type. All use is generally through a special set of interfaces that the developer creates. An example is the <code class="calibre6"><span class="calibre7">pid_t</span></code> type, which stores a process identification number. The actual size of this type is not revealed—although anyone can cheat and take a peak and see that it is an <code class="calibre6"><span class="calibre7">int</span></code>. If no code makes explicit use of this type’s size, it can be changed without too much hassle. Indeed, this was once the case: In older Unix systems, <code class="calibre6"><span class="calibre7">pid_t</span></code> was declared as a <code class="calibre6"><span class="calibre7">short</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Another example of an opaque type is <code class="calibre6"><span class="calibre7">atomic_t</span></code>. As discussed in <a href="index_split_019.html#filepos613760">Chapter 10</a>, “Kernel Synchronization Methods,” this type holds an integer value that can be manipulated atomically. Although this type is an <code class="calibre6"><span class="calibre7">int</span></code>, using the opaque type helps ensure that the data is used only in the special atomic operation functions. The opaque type also helps hide the usable size of <code class="calibre6"><span class="calibre7">atomic_t</span></code>, which was not always the full 32 bits because of architectural limitations on 32-bit SPARC.</p><div class="calibre_3"> </div>
<p class="calibre_2">Other examples of opaque types in the kernel include <code class="calibre6"><span class="calibre7">dev_t</span></code>, <code class="calibre6"><span class="calibre7">gid_t</span></code>, and <code class="calibre6"><span class="calibre7">uid_t</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Keep the following rules in mind when dealing with opaque types:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Do not assume the size of the type. It might be 32-bit on some systems and 64-bit on others. Moreover, kernel developers are free to change its size over time.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Do not convert the type back to a standard C type.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Be size agnostic. Write your code so that the actual storage and format of the type can change.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1274148"> </div>
<h4 class="calibre_27"><span class="calibre3">Special Types</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Some data in the kernel, despite not being represented by an opaque type, requires a specific data type. One example is the <code class="calibre6"><span class="calibre7">flags</span></code> parameter used in interrupt control, which should always be stored in an unsigned <code class="calibre6"><span class="calibre7">long</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1274601"></a>When storing and manipulating specific data, always pay careful attention to the data type that represents the type and use it. It is a common mistake to store one of these values in another type, such as <code class="calibre6"><span class="calibre7">unsigned int</span></code>. Although this will not result in a problem on 32-bit architectures, 64-bit machines will have trouble.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1275008"> </div>
<h4 class="calibre_27"><span class="calibre3">Explicitly Sized Types</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Often, as a programmer, you need explicitly sized data in your code. This is usually to match external requirements, such as those imposed by hardware, networking, or binary files. For example, a sound card might have a 32-bit register, a networking packet might have a 16-bit field, or an executable file might have an 8-bit cookie. In these cases, the data type that represents the data needs to be <em class="calibre4">exactly</em> the right size.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel defines these explicitly sized data types in <code class="calibre6"><span class="calibre7">&lt;asm/types.h&gt;</span></code>, which is included by <code class="calibre6"><span class="calibre7">&lt;linux/types.h&gt;</span></code>. <a href="#filepos1275918">Table 19.2</a> is a complete listing.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1275918"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 19.2. Explicitly Sized Data Types</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00251.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The signed variants are rarely used.</p><div class="calibre_3"> </div>
<p class="calibre_2">These explicit types are merely <code class="calibre6"><span class="calibre7">typedefs</span></code> to standard C types. On a 64-bit machine, they may look like this:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">typedef signed char s8;<br class="calibre1"/>typedef unsigned char u8;<br class="calibre1"/>typedef signed short s16;<br class="calibre1"/>typedef unsigned short u16;<br class="calibre1"/>typedef signed int s32;<br class="calibre1"/>typedef unsigned int u32;<br class="calibre1"/>typedef signed long s64;<br class="calibre1"/>typedef unsigned long u64;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos1276823"></a>On a 32-bit machine, however, they are likely defined as follows:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">typedef signed char s8;<br class="calibre1"/>typedef unsigned char u8;<br class="calibre1"/>typedef signed short s16;<br class="calibre1"/>typedef unsigned short u16;<br class="calibre1"/>typedef signed int s32;<br class="calibre1"/>typedef unsigned int u32;<br class="calibre1"/>typedef signed long long s64;<br class="calibre1"/>typedef unsigned long long u64;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">These types can be used only inside the kernel, in code that is never revealed to user-space (say, inside a user-visible structure in a header file). This is for reasons of namespace. The kernel also defines user-visible variants of these types, which are simply the same type prefixed by two underscores. For example, the unsigned 32-bit integer type that is safe to export to user-space is <code class="calibre6"><span class="calibre7">__u32</span></code>. This type is the same as <code class="calibre6"><span class="calibre7">u32</span></code>; the only difference is the name. You can use either name inside the kernel, but if the type is user-visible, you must use the underscored prefixed version to prevent polluting user-space’s namespace.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1278040"> </div>
<h4 class="calibre_27"><span class="calibre3">Signedness of Chars</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The C standard says that the <code class="calibre6"><span class="calibre7">char</span></code> data type can be either signed or unsigned. It is the responsibility of the compiler, the processor, or both to decide what the suitable default for the <code class="calibre6"><span class="calibre7">char</span></code> type is.</p><div class="calibre_3"> </div>
<p class="calibre_2">On most architectures, <code class="calibre6"><span class="calibre7">char</span></code> is signed by default and thus has a range from –128 to 127. On a few other architectures, such as ARM, <code class="calibre6"><span class="calibre7">char</span></code> is unsigned by default and has a range from 0 to 255.</p><div class="calibre_3"> </div>
<p class="calibre_2">For example, on systems where a <code class="calibre6"><span class="calibre7">char</span></code> is by default unsigned, this code ends up storing 255 instead of –1 in <code class="calibre6"><span class="calibre7">i</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">char i = -1;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">On other machines, where <code class="calibre6"><span class="calibre7">char</span></code> is by default signed, this code correctly stores –1 in <code class="calibre6"><span class="calibre7">i</span></code>. If the programmer’s intention is to store –1, the previous code should be</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">signed char i = -1;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">And if the programmer really intends to store 255, the code should read</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">unsigned char = 255;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If you use <code class="calibre6"><span class="calibre7">char</span></code> in your code, assume it can be <em class="calibre4">either</em> a <code class="calibre6"><span class="calibre7">signed char</span></code> or an <code class="calibre6"><span class="calibre7">unsigned char</span></code>. If you need it to be explicitly one or the other, declare it as such.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1280140"> </div>
<h3 class="calibre_21"><span class="bold">Data Alignment</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"><em class="calibre4">Alignment</em> refers to a piece of data’s location in memory. A variable is <em class="calibre4">naturally aligned</em> if it exists at a memory address that is a multiple of its size. For example, a 32-bit type is naturally aligned if it is located in memory at an address that is a multiple of 4 (that is, its lowest 2 bits are zero). Thus, a data type with size 2<sup class="calibre8"><em class="calibre4">n</em></sup> bytes must have an address with the <em class="calibre4">n</em> least significant bits set to zero.</p><div class="calibre_3"> </div>
<p class="calibre_2">Some architectures have stringent requirements on the alignment of data. On some systems, usually RISC-based ones, a load of unaligned data results in a processor trap (a <a id="filepos1280943"></a>handled error). On other systems, accessing unaligned data works but results in a degradation of performance. When writing portable code, alignment issues must be avoided, and all types should be naturally aligned.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1281208"> </div>
<h4 class="calibre_27"><span class="calibre3">Avoiding Alignment Issues</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The compiler generally prevents alignment issues by naturally aligning all data types. In fact, alignment issues are normally not major concerns of the kernel developers—the gcc developers worry about them so other programmers need not. Issues arise, however, when a programmer plays too closely with pointers and accesses data outside the environment anticipated by the compiler.</p><div class="calibre_3"> </div>
<p class="calibre_2">Accessing an aligned address with a recast pointer of a larger-aligned address causes an alignment issue (whatever that might mean for a particular architecture). That is, this is bad news:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">char wolf[] = "Like a wolf";<br class="calibre1"/>char *p = &amp;wolf[1];<br class="calibre1"/>unsigned long l = *(unsigned long *)p;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This example treats the pointer to a <code class="calibre6"><span class="calibre7">char</span></code> as a pointer to an unsigned <code class="calibre6"><span class="calibre7">long</span></code>, which might result in the 32- or 64-bit <code class="calibre6"><span class="calibre7">unsigned long</span></code> value being loaded from an address that is not a multiple of 4 or 8, respectively.</p><div class="calibre_3"> </div>
<p class="calibre_2">This sort of convoluted access might look obscure, and it usually is. Nevertheless, it comes up; so be careful. The real-world examples are generally not so obvious or convoluted.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1282812"> </div>
<h4 class="calibre_27"><span class="calibre3">Alignment of Nonstandard Types</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">As mentioned, the aligned address of a standard data type is a multiple of the size of that data type. Nonstandard (complex) C types have the following alignment rules:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The alignment of an array is the alignment of the base type; thus, each element is further aligned correctly.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The alignment of a <code class="calibre6"><span class="calibre7">union</span></code> is the alignment of the largest included type.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The alignment of a structure is such that an array of the structure will have each element of the array properly aligned.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Structures also introduce padding, which introduces other issues.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1283873"> </div>
<h4 class="calibre_27"><span class="calibre3">Structure Padding</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Structures are padded so that each element of the structure is naturally aligned. This ensures that when the processor accesses a given element in the structure, that element is aligned. For example, consider this structure on a 32-bit machine:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00252.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The structure is not laid out exactly like this in memory because the natural alignment of the structure’s members is insufficient. Instead, the compiler creates the structure such that in memory, the <code class="calibre6"><span class="calibre7">struct</span></code> resembles the following:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00253.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The padding variables exist to ensure proper natural alignment. The first padding provides a 3-byte waste-of-space to place <code class="calibre6"><span class="calibre7">cat</span></code> on a 4-byte boundary. This automatically aligns the remaining types because they are all smaller than <code class="calibre6"><span class="calibre7">cat</span></code>. The second and final padding is to pad the size of the <code class="calibre6"><span class="calibre7">struct</span></code>. The extra byte ensures the structure is a multiple of 4, and thus each member of an array of this structure is naturally aligned.</p><div class="calibre_3"> </div>
<p class="calibre_2">Note that <code class="calibre6"><span class="calibre7">sizeof(animal_struct)</span></code> returns 12 for <em class="calibre4">either</em> of these structures on most 32-bit machines. The C compiler automatically adds this padding to ensure proper alignment.</p><div class="calibre_3"> </div>
<p class="calibre_2">You can often rearrange the order of members in a structure to obviate the need for padding. This gives you properly aligned data without the need for padding and therefore a smaller structure:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00254.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This structure is only 8 bytes in size. It might not always be possible to rearrange structure definitions, however. For example, if this structure were specified as part of a standard or already used in existing code, its order is set in stone, although such requirements are less common in the kernel (which lacks a formal ABI) than user-space. Often, you might want to use a specific order for other reasons—for example, to best lay out variables to optimize cache behavior. Note that ANSI C specifies that the compiler must never change the order of members in a structure<sup class="calibre8"><a id="filepos1286557" href="#filepos1286877">4</a></sup>—it is always up to you, the programmer. The <a id="filepos1286655"></a>compiler can help you out, however: The <code class="calibre6"><span class="calibre7">-Wpadded</span></code> flag instructs gcc to generate a warning whenever padding is added to a structure.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1286877" href="#filepos1286557">4</a></sup>
<em class="calibre4">If the compiler could arbitrarily change the order of items in a structure, any existing code using the structure would break. In C, functions calculate the location of variables in a structure simply by adding offsets to the base address of the structure.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">Kernel developers need to be aware of structure padding when using structures wholesale—that is, when sending them out over the network or when saving a structure directly to disk, because the required padding might differ among various architectures. This is one reason C does not have a native structure comparison operator. The padding in a structure might contain gibberish, and it is not possible to do a byte-by-byte comparison of one structure to another. The C designers (correctly) felt it is best for the programmer to write a comparison function unique to each situation, taking advantage of the structure’s layout.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1287934"> </div>
<h3 class="calibre_21"><span class="bold">Byte Order</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"><em class="calibre4">Byte ordering</em> is the order of bytes within a word. Processors can number the bytes in a word such that the least significant bit is either the first (left-most) or last (right-most) value in the word. The byte ordering is called <em class="calibre4">big-endian</em> if the most significant byte is encoded first, with the remaining bytes decreasing in significance. The byte ordering is called <em class="calibre4">little-endian</em> if the least significant byte is encoded first, with the remaining bytes growing in significance.</p><div class="calibre_3"> </div>
<p class="calibre_2">Never assume any given byte ordering when writing kernel code (unless you are writing code for a specific architecture, of course). The Linux kernel supports machines of both byte orders—including machines that can select from either ordering upon boot—and generic code must be compatible with either.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a href="#filepos1289189">Figure 19.1</a> is an example of a big-endian byte ordering. <a href="#filepos1289477">Figure 19.2</a> is an example of a little-endian byte ordering.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1289189"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 19.1. Big-endian byte ordering.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00255.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1289477"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 19.2. Little-endian byte ordering.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00256.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The x86 architecture, in both 32- and 64-bit variants, is little-endian. Most other architectures are big-endian.</p><div class="calibre_3"> </div>
<p class="calibre_2">Let’s look at what this encoding means in practice. Consider the number 1027, stored as a four-byte integer in binary:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">00000000 00000000 00000100 00000011</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos1290245"></a>The internal storage in memory is different on big- versus little-endian, as shown in <a href="#filepos1290420">Table 19.3</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1290420"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 19.3. Big Versus Little Endian</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00257.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Notice how the big-endian architecture stores the most significant bytes in its smallest address. This is the exact inverse of little-endian.</p><div class="calibre_3"> </div>
<p class="calibre_2">As a final example, here is a simple code snippet to test whether a given architecture is big- or little-endian:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int x = 1;<br class="calibre1"/><br class="calibre1"/>if (*(char *)&amp;x == 1)<br class="calibre1"/>    /* little endian */<br class="calibre1"/>else<br class="calibre1"/>    /* big endian */</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This works either in user-space or inside the kernel.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">History of Big- and Little-Endian</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">The terms <em class="calibre4">big-endian</em> and <em class="calibre4">little-endian</em> derive from Jonathan Swift’s 1726 satirical novel, <em class="calibre4">Gulliver’s Travels</em>. In the novel, the fictional Lilliputians’ major political issue is whether eggs should be cracked open on the big end or the little end. Those who favor the big end are big-endians, whereas those who favor the small are little-endians.</p><div class="calibre_3"> </div>
<p class="calibre_2">The similarity between the Lilliputians and our big-endian versus little-endian debate is that the argument is rooted deeper in politics than technical merits.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos1292369"></a>Each supported architecture in Linux defines one of <code class="calibre6"><span class="calibre7">__BIG_ENDIAN</span></code> or <code class="calibre6"><span class="calibre7">__LITTLE_ENDIAN</span></code> in <code class="calibre6"><span class="calibre7">&lt;asm/byteorder.h&gt;</span></code> in correspondence to the machine’s byte order.</p><div class="calibre_3"> </div>
<p class="calibre_2">This header file also includes a family of macros from <code class="calibre6"><span class="calibre7">include/linux/byteorder/</span></code>, which help with conversions to and from the various orderings. The most commonly needed macros are</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00258.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">These convert from one byte order to another. In the case that the orders are the same (for example, if converting from native ordering to big-endian, and the processor is big-endian), the macros do nothing. Otherwise, they return the converted value.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1293343"> </div>
<h3 class="calibre_21"><span class="bold">Time</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The measurement of time is another kernel concept that can differ between architectures or even kernel revisions. Never assume the frequency of the timer interrupt or the number of jiffies per second. Instead, always use <code class="calibre6"><span class="calibre7">HZ</span></code> to scale your units of time correctly. This is important because not only can the timer frequency differ among the various architectures, but it can also change on a given architecture from one kernel release to the next.</p><div class="calibre_3"> </div>
<p class="calibre_2">For example, <code class="calibre6"><span class="calibre7">HZ</span></code> is 100 on the x86 platforms. That is, the timer interrupt occurs 100 times per second, or every 10 milliseconds. Earlier in the 2.6 kernel series, however, <code class="calibre6"><span class="calibre7">HZ</span></code> was 1000 on x86. On other architectures, the value differs: Alpha has <code class="calibre6"><span class="calibre7">HZ</span></code> equal to 1024 and ARM has it equal to 100.</p><div class="calibre_3"> </div>
<p class="calibre_2">Never simply compare <code class="calibre6"><span class="calibre7">jiffies</span></code> to a number such as 100 and assume that always means the same thing. To scale time appropriately, multiply or divide by <code class="calibre6"><span class="calibre7">HZ</span></code>. For example</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00259.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><code class="calibre6"><span class="calibre7">HZ</span></code> is defined in <code class="calibre6"><span class="calibre7">&lt;asm/param.h&gt;</span></code>. The subject is discussed further in <a href="index_split_019.html#filepos613760">Chapter 10</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1295033"> </div>
<h3 class="calibre_21"><span class="bold">Page Size</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">When working with pages of memory, never assume the page size. It is a common mistake for x86-32 programmers to assume that the page size is 4KB. Although this is true on x86-32 machines, other architectures have different sizes. Some architectures support multiple page sizes, in fact! <a href="#filepos1295631">Table 19.4</a> lists each support architecture’s valid page size(s).</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1295580"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1295631"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 19.4. Architecture Page Size(s)</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00260.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">When working with pages of memory, use <code class="calibre6"><span class="calibre7">PAGE_SIZE</span></code> as the size of a page, in bytes. The value <code class="calibre6"><span class="calibre7">PAGE_SHIFT</span></code> is the number of bits to left-shift an address to derive its page number. For example, on x86-32 with 4KB pages, <code class="calibre6"><span class="calibre7">PAGE_SIZE</span></code> is 4096 and <code class="calibre6"><span class="calibre7">PAGE_SHIFT</span></code> is 12. These values are defined in <code class="calibre6"><span class="calibre7">&lt;asm/page.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1296447"> </div>
<h3 class="calibre_21"><span class="bold">Processor Ordering</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Recall from <a href="index_split_018.html#filepos575425">Chapter 9</a>, “An Introduction to Kernel Synchronization,” and <a href="index_split_019.html#filepos613760">Chapter 10</a> that architectures have varying degrees of processor ordering. Some have strict ordering constraints in which all loads and stores occur in the order prescribed by the code. Other chips have weak ordering, and loads and stores are reordered as the processor sees fit.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1297035"></a>In your code, if you depend on data ordering, ensure that even the weakest ordered processor commits your load and stores in the right order by using the appropriate barriers, such as <code class="calibre6"><span class="calibre7">rmb()</span></code> and <code class="calibre6"><span class="calibre7">wmb()</span></code>. <a href="index_split_019.html#filepos613760">Chapter 10</a> has more information.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1297416"> </div>
<h3 class="calibre_21"><span class="bold">SMP, Kernel Preemption, and High Memory</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">It might seem somewhat incorrect to include symmetrical multiprocessing, kernel preemption, and high memory in a discussion of portability. After all, these are not machine characteristics that affect an operating system, but instead they are features of the Linux kernel that are indeed somewhat architecture-agnostic. They represent, however, important configuration options that you should always assume are available in your code. That is, always program for an SMP/preempt/highmem system and you will always be safe, in any configuration. In addition to the previous portability rules, you need to follow these as well:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Always assume your code will run on an SMP system and use appropriate locking.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Always assume your code will run with kernel preemption enabled and use appropriate locking and kernel preemption statements.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Always assume your code will run on a system with high memory (memory not permanently mapped) and use <code class="calibre6"><span class="calibre7">kmap()</span></code> as needed.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1298848"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Writing portable, clean, proper code for the Linux kernel has two major implications:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Always code for the greatest common factor: Assume anything can happen and any potential constraint is in place.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Always assume that only the lowest common denominator is available: Do not assume any given kernel feature is available and require only the minimum architectural features.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Writing portable code requires awareness of many issues, including wordsize, data type size, alignment, padding, byte order, signedness, endianness, page size, and processor load/store ordering. In the majority of kernel programming, the primary concern is in ensuring that data types are used correctly. Nonetheless, one day an archaic architecture issue will arise, so it is important to understand portability issues and always write clean, portable code inside the kernel.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_81"></div>
</body></html>
