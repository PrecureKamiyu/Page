<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part341.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part343.htm">下一个 &gt;</a></p><p class="s45" style="padding-top: 11pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Exercises</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 124pt;text-indent: -34pt;text-align: justify;">18.17 <span class="p">What beneﬁt does strict two-phase locking provide? What disadvantages re- sult?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -34pt;text-align: justify;">18.18 <span class="p">Most implementations of database systems use strict two-phase locking. Sug- gest three reasons for the popularity of this protocol.</span></p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;line-height: 94%;text-align: justify;"><b>18.19  </b>Consider a variant of the tree protocol called the <i>forest </i>protocol. The database is organized as a forest of rooted trees. Each transaction <i>T</i><span class="s97">i </span>must follow the following rules:</p><p class="s39" style="padding-top: 5pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">The ﬁrst lock in each tree may be on any data item.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 143pt;text-indent: -16pt;text-align: left;">• <span class="s40">The second, and all subsequent, locks in a tree may be requested only if the parent of the requested node is currently locked.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 127pt;text-indent: 0pt;text-align: left;">• <span class="s40">Data items may be unlocked at any time.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 124pt;text-indent: 3pt;line-height: 135%;text-align: left;"><span class="s39">• </span><span class="s40">A data item may not be relocked by </span>T<span class="s97">i </span><span class="p">after it has been unlocked by </span>T<span class="s97">i</span><span class="p">. Show that the forest protocol does </span>not <span class="p">ensure serializability.</span></p><p class="s46" style="padding-top: 1pt;padding-left: 124pt;text-indent: -35pt;text-align: left;">18.20  <span class="p">Under what conditions is it less expensive to avoid deadlock than to allow deadlocks to occur and then to detect them?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: left;">18.21 <span class="p">If deadlock is avoided by deadlock-avoidance schemes, is starvation still possi- ble? Explain your answer.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: left;">18.22 <span class="p">In multiple-granularity locking, what is the diﬀerence between implicit and explicit locking?</span></p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: left;"><b>18.23  </b>Although <span class="s44">SIX </span>mode is useful in multiple-granularity locking, an exclusive and intention-shared (<span class="s44">XIS</span>) mode is of no use. Why is it useless?</p><p style="padding-top: 7pt;padding-left: 124pt;text-indent: -35pt;line-height: 87%;text-align: left;"><b>18.24  </b>The multiple-granularity protocol rules specify that a transaction <i>T</i><span class="s97">i </span>can lock a node <i>Q </i>in S or <span class="s44">IS </span>mode only if <i>T</i><span class="s97">i </span>currently has the parent of <i>Q </i>locked in either</p><p class="s64" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Exercises  <span class="s164">903</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="padding-left: 155pt;text-indent: 0pt;text-align: justify;">IX <span class="s43">or </span>IS <span class="s43">mode. Given that </span>SIX <span class="s43">and S locks are stronger than </span>IX <span class="s43">or </span>IS <span class="s43">locks, why does the protocol not allow locking a node in S or </span>IS <span class="s43">mode if the parent is locked in either </span>SIX <span class="s43">or S mode?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;">18.25 <span class="p">Suppose the lock hierarchy for a database consists of database, relations, and tuples.</span></p><p style="padding-top: 10pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">a.  If a transaction needs to read a lot of tuples from a relation <i>r</i>, what locks should it acquire?</p><p style="padding-top: 6pt;padding-left: 162pt;text-indent: 0pt;text-align: justify;">b.  Now suppose the transaction wants to update a few of the tuples in <i>r</i></p><p style="padding-left: 181pt;text-indent: 0pt;text-align: justify;">after reading a lot of tuples. What locks should it acquire?</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">c.  If at run-time the transaction ﬁnds that it needs to actually update a very large number of tuples (after acquiring locks assuming only a few tuples would be updated). What problems would this cause to the lock table, and what could the database do to avoid the problem?</p><p class="s46" style="padding-top: 10pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;">18.26 <span class="p">When a transaction is rolled-back under timestamp ordering, it is assigned a new timestamp. Why can it not simply keep its old timestamp?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;">18.27  <span class="p">Show that there are schedules that are possible under the two-phase locking protocol but not possible under the timestamp protocol, and vice versa.</span></p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;"><b>18.28  </b>Under a modiﬁed version of the timestamp protocol, we require that a commit bit be tested to see whether a <span class="s49">read </span>request must wait. Explain how the com- mit bit can prevent cascading abort. Why is this test not necessary for <span class="s49">write </span>requests?</p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;">18.29 <span class="p">As discussed in Exercise 18.15, snapshot isolation can be implemented using a form of timestamp validation. However, unlike the multiversion timestamp- ordering scheme, which guarantees serializability, snapshot isolation does not guarantee serializability. Explain the key diﬀerence between the protocols that results in this diﬀerence.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;">18.30 <span class="p">Outline the key similarities and diﬀerences between the timestamp-based im- plementation of the ﬁrst-committer-wins version of snapshot isolation, de- scribed in Exercise 18.15, and the optimistic-concurrency control-without-read- validation scheme, described in Section 18.9.3.</span></p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;"><b>18.31  </b>Consider a relation <i>r</i>(<i>A</i>, <i>B</i>, <i>C</i>) and a transaction <i>T </i>that does the following: ﬁnd the maximum <i>A </i>value in <i>r</i>, and insert a new tuple in <i>r </i>whose <i>A </i>value is 1<span class="s15">+ </span>the maximum <i>A </i>value. Assume that an index is used to ﬁnd the maximum <i>A </i>value.</p><p style="padding-top: 10pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">a.  Suppose that the transaction locks each tuple it reads in S mode, and the tuple it creates in X mode, and performs no other locking. Now sup- pose two instances of <i>T </i>are run concurrently. Explain how the resultant execution could be non-serializable.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 150pt;text-indent: -19pt;line-height: 70%;text-align: left;"><a name="bookmark393"><span class="p">b. Now suppose that </span></a>r<span class="s83">.</span>A <span class="p">is declared as a primary key. Can the above non- serializable execution occur in this case? Explain why or why not.</span><a name="bookmark434">&zwnj;</a></p><p class="s46" style="padding-top: 7pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;">18.32  <span class="p">Explain the phantom phenomenon. Why may this phenomenon lead to an incorrect concurrent execution despite the use of the two-phase locking proto- col?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;">18.33  <span class="p">Explain the reason for the use of degree-two consistency. What disadvantages does this approach have?</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;">18.34  <span class="p">Give example schedules to show that with key-value locking, if lookup, insert, or delete does not lock the next-key value, the phantom phenomenon could go undetected.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;">18.35  <span class="p">Many transactions update a common item (e.g., the cash balance at a branch) and private items (e.g., individual account balances). Explain how you can in- crease concurrency (and throughput) by ordering the operations of the trans- action.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -35pt;text-align: justify;">18.36  <span class="p">Consider the following locking protocol: All items are numbered, and once an item is unlocked, only higher-numbered items may be locked. Locks may be released at any time. Only X-locks are used. Show by an example that this protocol does not guarantee serializability.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part341.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part343.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
