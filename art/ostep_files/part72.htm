<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>7.7 Incorporating I/O</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part71.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part73.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">7.7 Incorporating I/O</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">First we will relax assumption 3 – of course all programs perform I/O. Imagine a program that didn’t take any input: it would produce the same output each time. Imagine one without output: it is the proverbial tree</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">falling in the forest, with no one to see it; it doesn’t matter that it ran.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A scheduler clearly has a decision to make when a job initiates an I/O request, because the currently-running job won’t be using the CPU dur- ing the I/O; it is <b>blocked </b>waiting for I/O completion. If the I/O is sent to a hard disk drive, the process might be blocked for a few milliseconds or longer, depending on the current I/O load of the drive. Thus, the sched- uler should probably schedule another job on the CPU at that time.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The scheduler also has to make a decision when the I/O completes. When that occurs, an interrupt is raised, and the OS runs and moves the process that issued the I/O from blocked back to the ready state. Of course, it could even decide to run the job at that point. How should the OS treat each job?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To understand this issue better, let us assume we have two jobs, A and B, which each need 50 ms of CPU time. However, there is one obvious difference: A runs for 10 ms and then issues an I/O request (assume here that I/Os each take 10 ms), whereas B simply uses the CPU for 50 ms and performs no I/O. The scheduler runs A first, then B after (Figure <span style=" color: #00AEEF;">7.8</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">CPU</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 5pt;padding-left: 105pt;text-indent: 0pt;text-align: left;">Disk</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">A  A  A  A  A B B B B B</p><p style="text-indent: 0pt;text-align: left;"><span><img width="174" height="54" alt="image" src="Image_051.png"/></span></p><p class="s46" style="text-indent: 0pt;text-align: left;">0  20  40  60  80  100  120  140</p><p class="s46" style="padding-left: 58pt;text-indent: 0pt;text-align: left;">Time</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 117pt;text-indent: 0pt;text-align: left;">Figure 7.8: <b>Poor Use of Resources</b></p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Assume we are trying to build a STCF scheduler. How should such a scheduler account for the fact that A is broken up into 5 10-ms sub-jobs, whereas B is just a single 50-ms CPU demand? Clearly, just running one job and then the other without considering how to take I/O into account makes little sense.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 104pt;text-indent: 0pt;text-align: left;">CPU</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 5pt;padding-left: 105pt;text-indent: 0pt;text-align: left;">Disk</p><p class="s46" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">A B A B A B A B A B</p><p style="text-indent: 0pt;text-align: left;"><span><img width="174" height="54" alt="image" src="Image_052.png"/></span></p><p class="s46" style="text-indent: 0pt;text-align: left;">0  20  40  60  80  100  120  140</p><p class="s46" style="padding-left: 58pt;text-indent: 0pt;text-align: left;">Time</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 81pt;text-indent: 0pt;text-align: justify;">Figure 7.9: <b>Overlap Allows Better Use of Resources</b></p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A common approach is to treat each 10-ms sub-job of A as an indepen- dent job. Thus, when the system starts, its choice is whether to schedule a 10-ms A or a 50-ms B. With STCF, the choice is clear: choose the shorter one, in this case A. Then, when the first sub-job of A has completed, only B is left, and it begins running. Then a new sub-job of A is submitted, and it preempts B and runs for 10 ms. Doing so allows for <b>overlap</b>, with</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 58pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: O<span class="s7">VERLAP </span>E<span class="s7">NABLES </span>H<span class="s7">IGHER </span>U<span class="s7">TILIZATION</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">When possible, <b>overlap </b>operations to maximize the utilization of sys- tems. Overlap is useful in many different domains, including when per- forming disk I/O or sending messages to remote machines; in either case, starting the operation and then switching to other work is a good idea, and improved the overall utilization and efficiency of the system.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">the CPU being used by one process while waiting for the I/O of another process to complete; the system is thus better utilized (see Figure <span style=" color: #00AEEF;">7.9</span>).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">And thus we see how a scheduler might incorporate I/O. By treating each CPU burst as a job, the scheduler makes sure processes that are “in- teractive” get run frequently. While those interactive jobs are performing I/O, other CPU-intensive jobs run, thus better utilizing the processor.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part71.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part73.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
