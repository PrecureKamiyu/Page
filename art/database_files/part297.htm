<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>16.2  Transformation of Relational Expressions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part296.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part298.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">16.2  <span style=" color: #00AEEF;">Transformation of Relational Expressions</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">A query can be expressed in several diﬀerent ways, with diﬀerent costs of evaluation. In this section, rather than take the relational expression as given, we consider alternative, equivalent expressions.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Two relational-algebra expressions are said to be <span class="s63">equivalent </span>if, on every legal data- base instance, the two expressions generate the same set of tuples. (Recall that a legal database instance is one that satisﬁes all the integrity constraints speciﬁed in the data- base schema.) Note that the order of the tuples is irrelevant; the two expressions may generate the tuples in diﬀerent orders, but would be considered equivalent as long as the set of tuples is the same.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In <span class="s44">SQL</span>, the inputs and outputs are multisets of tuples, and the multiset version of the relational algebra (described in Note 3.1 on page 80, Note 3.2 on page 97, and Note</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">3.3 on page 108) is used for evaluating <span class="s44">SQL </span>queries. Two expressions in the <i>multiset </i>version of the relational algebra are said to be equivalent if on every legal database the two expressions generate the same multiset of tuples. The discussion in this chapter is based on the relational algebra. We leave extensions to the multiset version of the relational algebra to you as exercises.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">16.2.1 Equivalence Rules</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">An <span class="s63">equivalence rule </span>says that expressions of two forms are equivalent. We can replace an expression of the ﬁrst form with an expression of the second form, or vice versa— that is, we can replace an expression of the second form by an expression of the ﬁrst form— since the two expressions generate the same result on any valid database. The optimizer uses equivalence rules to transform expressions into other logically equiva- lent expressions.</p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;"><span class="p">We now describe several equivalence rules on relational-algebra expressions. Some of the equivalences listed appear in Figure 16.3. We use </span><span class="s15">θ</span><span class="p">, </span><span class="s15">θ</span><span class="s98">1</span><span class="p">, </span><span class="s15">θ</span><span class="s98">2</span><span class="p">, and so on to denote predicates, </span>L<span class="s93">1</span><span class="s94">, </span>L<span class="s93">2</span><span class="s94">, </span>L<span class="s93">3</span><span class="s94">, and so on to denote lists of attributes, and </span>E<span class="p">, </span>E<span class="s93">1</span><span class="s94">, </span>E<span class="s93">2</span><span class="s94">, and so on to denote relational-algebra expressions. A relation name </span>r <span class="p">is simply a special case of a relational-algebra expression and can be used wherever </span>E <span class="p">appears.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: -16pt;text-align: left;"><span class="s63">1. </span>Conjunctive selection operations can be deconstructed into a sequence of indi- vidual selections. This transformation is referred to as a cascade of <span class="s15">σ</span>.</p><p class="s158" style="padding-top: 5pt;padding-left: 264pt;text-indent: 0pt;text-align: left;"><span class="s15">σ</span><span class="s137">θ</span>1 <span class="s171">∧θ</span>2 <span class="s388">(</span><span class="s13">E</span><span class="p">) </span><span class="s86">≡ </span><span class="s15">σ</span><span class="s137">θ</span>1 <span class="s388">(</span><span class="s15">σ</span><span class="s137">θ</span>2 <span class="s388">(</span><span class="s13">E</span><span class="p">))</span></p><p class="s63" style="padding-left: 128pt;text-indent: 0pt;text-align: left;">2. <span class="p">Selection operations are </span>commutative<span class="p">.</span></p><p class="s15" style="padding-top: 5pt;padding-left: 259pt;text-indent: 0pt;text-align: left;">σ<span class="s137">θ</span><span class="s158">1 </span><span class="s388">(</span>σ<span class="s137">θ</span><span class="s158">2 </span><span class="s388">(</span><span class="s13">E</span><span class="p">)) </span><span class="s86">≡ </span>σ<span class="s137">θ</span><span class="s158">2 </span><span class="s388">(</span>σ<span class="s137">θ</span><span class="s158">1 </span><span class="s388">(</span><span class="s13">E</span><span class="p">))</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="37" alt="image" src="Image_2853.png"/></span></p><p class="s111" style="text-indent: 0pt;text-align: right;">θ</p><p style="padding-left: 185pt;text-indent: 0pt;text-align: left;"><span><img width="18" height="18" alt="image" src="Image_2854.png"/></span></p><p class="s69" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">E<span class="s389">1     </span>E<span class="s389">2</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="padding-bottom: 1pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">Rule 5</p><p style="padding-left: 26pt;text-indent: 0pt;line-height: 4pt;text-align: left;"><span><img width="119" height="5" alt="image" src="Image_2855.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s390" style="padding-left: 58pt;text-indent: 0pt;text-align: left;">θ</p><p style="padding-left: 62pt;text-indent: 0pt;text-align: left;"><span><img width="18" height="18" alt="image" src="Image_2856.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="37" alt="image" src="Image_2857.png"/></span></p><p class="s69" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">E<span class="s389">2     </span>E<span class="s389">1</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="98" height="78" alt="image" src="Image_2858.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="text-indent: 0pt;text-align: right;">E<span class="s391">3</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="96" height="78" alt="image" src="Image_2859.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="text-indent: 0pt;text-align: left;">E<span class="s389">1</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s42" style="padding-top: 4pt;padding-bottom: 1pt;padding-left: 60pt;text-indent: 0pt;text-align: center;">Rule 6.a</p><p style="padding-left: 230pt;text-indent: 0pt;line-height: 4pt;text-align: left;"><span><img width="120" height="5" alt="image" src="Image_2860.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-top: 6pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">E<span class="s389">1      </span>E<span class="s389">2                           </span>E<span class="s389">2      </span>E<span class="s389">3</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="119" height="5" alt="image" src="Image_2861.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="64" height="64" alt="image" src="Image_2862.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="64" height="38" alt="image" src="Image_2863.png"/></span></p><p class="s392" style="padding-top: 4pt;padding-left: 160pt;text-indent: 0pt;text-align: left;">σ<span class="s393">θ            </span><span class="s42">Rule 7.a</span></p><p class="s42" style="padding-top: 8pt;padding-left: 60pt;text-indent: 0pt;line-height: 10pt;text-align: center;">If <span class="s111">θ </span>only has</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="22" alt="image" src="Image_2864.png"/></span></p><p class="s42" style="padding-left: 237pt;text-indent: 0pt;text-align: left;">attributes from <i>E</i><span class="s394">1       </span><span class="s395">σ</span><span class="s396">θ     </span><i>E</i><span class="s109">2</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-top: 4pt;padding-left: 135pt;text-indent: 0pt;text-align: left;">E<span class="s389">1      </span>E<span class="s389">2                       </span>E<span class="s389">1</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 16.3 <span class="s74">Pictorial representation of equivalences.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 113pt;text-indent: -17pt;text-align: justify;"><span class="s63">3. </span>Only the ﬁnal operations in a sequence of projection operations are needed; the others can be omitted. This transformation can also be referred to as a cascade of <span class="s15">Π</span>.</p><p class="s15" style="padding-top: 3pt;padding-left: 84pt;text-indent: 0pt;line-height: 17pt;text-align: center;">Π<span class="s123">L</span><span class="s158">1 </span><span class="s388">(</span>Π<span class="s123">L</span><span class="s158">2 </span><span class="s388">(</span>… <span class="p">(</span>Π<span class="s123">L</span><span class="s378">n </span><span class="p">(</span><span class="s13">E</span><span class="p">)) </span>…<span class="p">)) </span><span class="s86">≡ </span>Π<span class="s123">L</span><span class="s158">1 </span><span class="s388">(</span><span class="s13">E</span><span class="p">)</span></p><p style="padding-left: 113pt;text-indent: 0pt;line-height: 21pt;text-align: justify;">where <i>L</i><span class="s98">1</span> <span class="s83">⊆ </span><i>L</i><span class="s98">2</span> <span class="s83">⊆ </span><span class="s15">… </span><span class="s83">⊆ </span><i>L</i><span class="s97">n</span>.</p><p class="s63" style="padding-left: 96pt;text-indent: 0pt;text-align: left;">4. <span class="p">Selections can be combined with Cartesian products and theta joins.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">a. </span><span class="s15">σ</span><span class="s137">θ</span><span class="p">(</span>E<span class="s130">1 </span><span class="s15">× </span>E<span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span>E<span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span>E<span class="s130">2</span></p><p style="padding-top: 3pt;padding-left: 22pt;text-indent: 0pt;text-align: center;">This expression is just the deﬁnition of the theta join.</p><p class="s158" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">b. </span><span class="s15">σ</span><span class="s137">θ</span>1 <span class="s388">(</span><span class="s13">E</span><span class="s93">1 </span><span class="s86">⋈</span><span class="s171">θ</span>2 <span class="s13">E</span><span class="s93">2</span><span class="s94">) </span><span class="s86">≡ </span><span class="s13">E</span><span class="s93">1 </span><span class="s86">⋈</span><span class="s171">θ</span>1 <span class="s171">∧θ</span>2 <span class="s13">E</span><span class="s93">2</span></p><p class="s63" style="padding-top: 2pt;padding-left: 96pt;text-indent: 0pt;text-align: left;">5. <span class="p">Theta-join operations are commutative.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">E<span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span>E<span class="s130">2 </span><span class="s86">≡ </span>E<span class="s130">2 </span><span class="s86">⋈</span><span class="s136">θ </span>E<span class="s130">1</span></p><p style="padding-top: 2pt;padding-left: 113pt;text-indent: 0pt;text-align: justify;">Recall that the natural-join operator is simply a special case of the theta-join operator; hence, natural joins are also commutative.</p><p style="padding-left: 113pt;text-indent: 14pt;text-align: justify;">The order of attributes diﬀers between the left-hand side and right-hand side of the commutativity rule, so the equivalence does not hold if the order of at- tributes is taken into account. Since we use a version of relational algebra where every attribute must have a name for it to be referenced, the order of attributes</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 145pt;text-indent: 0pt;text-align: justify;">does not actually matter, except when the result is ﬁnally displayed. When the order does matter, a projection operation can be added to one of the sides of the equivalence to appropriately reorder attributes. However, for simplicity, we omit the projection and ignore the attribute order in all our equivalence rules.</p><p class="s63" style="padding-top: 6pt;padding-left: 128pt;text-indent: 0pt;text-align: justify;">6.  <span class="p">a. Natural-join operations are </span>associative<span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 245pt;text-indent: 0pt;text-align: left;"><span class="p">(</span>E<span class="s93">1 </span><span class="s86">⋈ </span>E<span class="s93">2</span><span class="s94">) </span><span class="s86">⋈ </span>E<span class="s93">3 </span><span class="s86">≡ </span>E<span class="s93">1 </span><span class="s86">⋈ </span><span class="p">(</span>E<span class="s93">2 </span><span class="s86">⋈ </span>E<span class="s93">3</span><span class="s94">)</span></p><p style="padding-top: 4pt;padding-left: 154pt;text-indent: 0pt;text-align: left;">b. Theta joins are associative in the following manner:</p><p class="s171" style="padding-top: 10pt;padding-left: 224pt;text-indent: 0pt;text-align: left;"><span class="p">(</span><span class="s13">E</span><span class="s93">1 </span><span class="s86">⋈</span>θ<span class="s158">1 </span><span class="s13">E</span><span class="s93">2</span><span class="s94">) </span><span class="s86">⋈</span>θ<span class="s158">2 </span>∧θ<span class="s158">3 </span><span class="s13">E</span><span class="s93">3 </span><span class="s86">≡ </span><span class="s13">E</span><span class="s93">1 </span><span class="s86">⋈</span>θ<span class="s158">1 </span>∧θ<span class="s158">3 </span><span class="s388">(</span><span class="s13">E</span><span class="s93">2 </span><span class="s86">⋈</span>θ<span class="s158">2 </span><span class="s13">E</span><span class="s93">3</span><span class="s94">)</span></p><p style="padding-top: 8pt;padding-left: 170pt;text-indent: 0pt;text-align: justify;">where <span class="s15">θ</span><span class="s98">2</span> involves attributes from only <i>E</i><span class="s98">2</span> and <i>E</i><span class="s98">3</span>. Any of these conditions may be empty; hence, it follows that the Cartesian product (<span class="s15">×</span>) operation is also associative. The commutativity and associativity of join operations are important for join reordering in query optimization.</p><p class="s63" style="padding-top: 5pt;padding-left: 145pt;text-indent: -16pt;text-align: justify;">7. <span class="p">The selection operation distributes over the theta-join operation under the fol- lowing two conditions:</span></p><p style="padding-top: 6pt;padding-left: 170pt;text-indent: -15pt;text-align: justify;">a. Selection distributes over the theta-join operation when all the attributes in selection condition <span class="s15">θ</span><span class="s98">1</span> involve only the attributes of one of the expressions (say, <i>E</i><span class="s98">1</span>) being joined.</p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1           1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 11pt;padding-left: 256pt;text-indent: 0pt;text-align: justify;">σ<span class="s137">θ</span> <span class="p">(</span><span class="s13">E</span><span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span><span class="s13">E</span><span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span><span class="p">(</span>σ<span class="s137">θ</span> <span class="p">(</span><span class="s13">E</span><span class="s130">1</span><span class="s94">)) </span><span class="s86">⋈</span><span class="s136">θ </span><span class="s13">E</span><span class="s130">2</span></p><p style="padding-top: 4pt;padding-left: 170pt;text-indent: -16pt;text-align: justify;">b. Selection distributes over the theta-join operation when selection condition <span class="s15">θ</span><span class="s98">1</span> involves only the attributes of <i>E</i><span class="s98">1</span> and <span class="s15">θ</span><span class="s98">2</span> involves only the attributes of <i>E</i><span class="s130">2</span><span class="s94">.</span></p><p class="s158" style="padding-left: 235pt;text-indent: 0pt;line-height: 17pt;text-align: left;"><span class="s15">σ</span><span class="s137">θ</span>1 <span class="s136">∧θ</span>2 <span class="s388">(</span><span class="s13">E</span><span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span><span class="s13">E</span><span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span><span class="p">(</span><span class="s15">σ</span><span class="s137">θ</span>1 <span class="s388">(</span><span class="s13">E</span><span class="s130">1</span><span class="s94">)) </span><span class="s86">⋈</span><span class="s136">θ </span><span class="p">(</span><span class="s15">σ</span><span class="s137">θ</span>2 <span class="s388">(</span><span class="s13">E</span><span class="s130">2</span><span class="s94">))</span></p><p class="s63" style="padding-top: 3pt;padding-left: 145pt;text-indent: -17pt;text-align: left;">8. <span class="p">The projection operation distributes over the theta-join operation under the fol- lowing conditions.</span></p><p class="s13" style="padding-top: 7pt;padding-left: 170pt;text-indent: -15pt;line-height: 86%;text-align: justify;"><span class="p">a. Let </span>L<span class="s130">1 </span><span class="s94">and </span>L<span class="s130">2 </span><span class="s94">be attributes of </span>E<span class="s130">1 </span><span class="s94">and </span>E<span class="s130">2</span><span class="s94">, respectively. Suppose that the join condition </span><span class="s15">θ </span><span class="p">involves only attributes in </span>L<span class="s98">1</span><span class="p"> </span><span class="s15">∪ </span>L<span class="s98">2</span><span class="p">. Then,</span></p><p class="s158" style="padding-top: 12pt;padding-left: 231pt;text-indent: 0pt;text-align: left;"><span class="s15">Π</span><span class="s123">L</span>1 <span class="s136">∪</span><span class="s149">L</span>2 <span class="s388">(</span><span class="s13">E</span><span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span><span class="s13">E</span><span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span><span class="p">(</span><span class="s15">Π</span><span class="s123">L</span>1 <span class="s388">(</span><span class="s13">E</span><span class="s130">1</span><span class="s94">)) </span><span class="s86">⋈</span><span class="s136">θ </span><span class="p">(</span><span class="s15">Π</span><span class="s123">L</span>2 <span class="s388">(</span><span class="s13">E</span><span class="s130">2</span><span class="s94">))</span></p><p class="s13" style="padding-top: 2pt;padding-left: 170pt;text-indent: -16pt;line-height: 93%;text-align: justify;"><span class="p">b. Consider a join </span>E<span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span>E<span class="s130">2</span><span class="s94">. Let </span>L<span class="s130">1 </span><span class="s94">and </span>L<span class="s130">2 </span><span class="s94">be sets of attributes from </span>E<span class="s130">1 </span><span class="s94">and </span>E<span class="s98">2</span><span class="p">, respectively. Let </span>L<span class="s98">3</span><span class="p"> be attributes of </span>E<span class="s98">1</span><span class="p"> that are involved in join condition </span><span class="s15">θ</span><span class="p">, but are not in </span>L<span class="s98">1</span><span class="p"> and let </span>L<span class="s98">4</span><span class="p"> be attributes of </span>E<span class="s98">2</span><span class="p"> that are involved in join</span></p><p style="padding-left: 170pt;text-indent: 0pt;text-align: justify;">condition <span class="s15">θ</span>, but are not in <i>L</i><span class="s98">2</span>. Then,</p><p class="s158" style="padding-top: 4pt;padding-left: 187pt;text-indent: 0pt;text-align: left;"><span class="s15">Π</span><span class="s123">L</span>1 <span class="s171">∪</span><span class="s169">L</span>2 <span class="s388">(</span><span class="s13">E</span><span class="s93">1 </span><span class="s86">⋈</span><span class="s171">θ </span><span class="s13">E</span><span class="s93">2</span><span class="s94">) </span><span class="s86">≡ </span><span class="s15">Π</span><span class="s123">L</span>1 <span class="s171">∪</span><span class="s169">L</span>2 <span class="s388">((</span><span class="s15">Π</span><span class="s123">L</span>1 <span class="s171">∪</span><span class="s169">L</span>3 <span class="s388">(</span><span class="s13">E</span><span class="s93">1</span><span class="s94">)) </span><span class="s86">⋈</span><span class="s171">θ </span><span class="p">(</span><span class="s15">Π</span><span class="s123">L</span>2 <span class="s171">∪</span><span class="s169">L</span>4 <span class="s388">(</span><span class="s13">E</span><span class="s93">2</span><span class="s94">)))</span></p><p style="padding-top: 3pt;padding-left: 145pt;text-indent: 0pt;text-align: left;">Similar equivalences hold for outer join operations <span class="s15">⟕</span>, <span class="s15">⟖ </span>and <span class="s15">⟗</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-top: 4pt;padding-left: 96pt;text-indent: 0pt;text-align: left;">9. <span class="p">The set operations union and intersection are commutative.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">a. </span>E<span class="s130">1 </span><span class="s15">∪ </span>E<span class="s130">2 </span><span class="s86">≡ </span>E<span class="s130">2 </span><span class="s15">∪ </span>E<span class="s130">1</span></p><p class="s13" style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">b. </span>E<span class="s93">1 </span><span class="s15">∩ </span>E<span class="s93">2 </span><span class="s86">≡ </span>E<span class="s93">2 </span><span class="s15">∩ </span>E<span class="s93">1</span></p><p style="padding-top: 3pt;padding-left: 113pt;text-indent: 0pt;text-align: justify;">Set diﬀerence is not commutative.</p><p class="s63" style="padding-top: 6pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">10. <span class="p">Set union and intersection are associative.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">a. (</span>E<span class="s130">1 </span><span class="s15">∪ </span>E<span class="s130">2</span><span class="s94">) </span><span class="s15">∪ </span>E<span class="s130">3 </span><span class="s86">≡ </span>E<span class="s130">1 </span><span class="s15">∪ </span><span class="p">(</span>E<span class="s130">2 </span><span class="s15">∪ </span>E<span class="s130">3</span><span class="s94">)</span></p><p class="s13" style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">b. (</span>E<span class="s93">1 </span><span class="s15">∩ </span>E<span class="s93">2</span><span class="s94">) </span><span class="s15">∩ </span>E<span class="s93">3 </span><span class="s86">≡ </span>E<span class="s93">1 </span><span class="s15">∩ </span><span class="p">(</span>E<span class="s93">2 </span><span class="s15">∩ </span>E<span class="s93">3</span><span class="s94">)</span></p><p class="s63" style="padding-top: 3pt;padding-left: 113pt;text-indent: -21pt;text-align: justify;">11. <span class="p">The selection operation distributes over the union, intersection, and set- diﬀerence operations.</span></p><p class="s15" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">a. </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s93">1 </span>∪ <span class="s13">E</span><span class="s93">2</span><span class="s94">) </span><span class="s86">≡ </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s93">1</span><span class="s94">) </span>∪ σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s93">2</span><span class="s94">)</span></p><p class="s15" style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">b. </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">1 </span>∩ <span class="s13">E</span><span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">1</span><span class="s94">) </span>∩ σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">2</span><span class="s94">)</span></p><p class="s15" style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">c. </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">1 </span>− <span class="s13">E</span><span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">1</span><span class="s94">) </span>− σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">2</span><span class="s94">)</span></p><p class="s15" style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="p">d. </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">1 </span>∩ <span class="s13">E</span><span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">1</span><span class="s94">) </span>∩ <span class="s13">E</span><span class="s130">2</span></p><p class="s15" style="padding-top: 2pt;padding-left: 124pt;text-indent: 0pt;text-align: left;"><span class="p">e. </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">1 </span>− <span class="s13">E</span><span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span>σ<span class="s137">θ</span><span class="p">(</span><span class="s13">E</span><span class="s130">1</span><span class="s94">) </span>− <span class="s13">E</span><span class="s130">2</span></p><p style="padding-top: 3pt;padding-left: 87pt;text-indent: 0pt;text-align: right;">The preceding equivalence does not hold if <span class="s15">− </span>is replaced by <span class="s15">∪</span>.</p><p class="s63" style="padding-top: 6pt;padding-left: 87pt;text-indent: 0pt;text-align: right;">12. <span class="p">The projection operation distributes over the union operation</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">Π<span class="s123">L</span><span class="p">(</span><span class="s13">E</span><span class="s130">1 </span>∪ <span class="s13">E</span><span class="s130">2</span><span class="s94">) </span><span class="s86">≡ </span><span class="p">(</span>Π<span class="s123">L</span><span class="p">(</span><span class="s13">E</span><span class="s130">1</span><span class="s94">)) </span>∪ <span class="p">(</span>Π<span class="s123">L</span><span class="p">(</span><span class="s13">E</span><span class="s130">2</span><span class="s94">))</span></p><p class="s13" style="padding-top: 3pt;padding-left: 113pt;text-indent: 0pt;text-align: justify;"><span class="p">provided </span>E<span class="s93">1 </span><span class="s94">and </span>E<span class="s93">2 </span><span class="s94">have the same schema.</span></p><p style="padding-top: 4pt;padding-left: 113pt;text-indent: -22pt;text-align: justify;"><span class="s63">13. </span>Selection distributes over aggregation under the following conditions. Let <i>G </i>be a set of group by attributes, and <i>A </i>a set of aggregate expressions. When <span class="s15">θ </span>only involves attributes in <i>G</i>, the following equivalence holds.</p><p style="padding-top: 9pt;padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s15">σ</span><span class="s137">θ</span>(<span class="s149">G </span><span class="s15">γ</span><i>A</i>(<i>E</i>) <span class="s86">≡ </span><span class="s149">G </span><span class="s15">γ</span><i>A</i>(<span class="s15">σ</span><span class="s137">θ</span>(<i>E</i>))</p><p class="s63" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">14.  <span class="p">a. Full outer join is commutative.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">E<span class="s93">1 </span><span class="s15">⟗ </span>E<span class="s93">2 </span><span class="s86">≡ </span>E<span class="s93">2 </span><span class="s15">⟗ </span>E<span class="s93">2</span></p><p style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">b. Left and right outer join are not commutative. However, left outer join and right outer join can be exchanged as follows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">E<span class="s93">1 </span><span class="s15">⟕ </span>E<span class="s93">2 </span><span class="s86">≡ </span>E<span class="s93">2 </span><span class="s15">⟖ </span>E<span class="s93">1</span></p><p style="padding-top: 3pt;padding-left: 113pt;text-indent: -22pt;text-align: justify;"><span class="s63">15. </span>Selection distributes over left and right outer join under some conditions. Specif- ically, when the selection condition <span class="s15">θ</span><span class="s98">1</span> involves only the attributes of one of the expressions being joined, say <i>E</i><span class="s98">1</span>, the following equivalences hold.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="padding-top: 4pt;padding-left: 155pt;text-indent: 0pt;text-align: justify;"><span class="p">a. </span>σ<span class="s137">θ</span><span class="s158">1 </span><span class="s388">(</span><span class="s13">E</span><span class="s93">1 </span>⟕<span class="s137">θ</span> <span class="s13">E</span><span class="s93">2</span><span class="s94">) </span><span class="s86">≡ </span><span class="p">(</span>σ<span class="s137">θ</span><span class="s158">1 </span><span class="s388">(</span><span class="s13">E</span><span class="s93">1</span><span class="s94">)) </span>⟕<span class="s137">θ</span> <span class="s13">E</span><span class="s93">2</span></p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1                  1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 1pt;padding-left: 154pt;text-indent: 0pt;text-align: justify;"><span class="p">b. </span>σ<span class="s137">θ</span> <span class="p">(</span><span class="s13">E</span><span class="s93">2 </span>⟖<span class="s137">θ</span> <span class="s13">E</span><span class="s93">1</span><span class="s94">) </span><span class="s86">≡ </span><span class="p">(</span><span class="s13">E</span><span class="s93">2 </span>⟖<span class="s137">θ</span> <span class="p">(</span>σ<span class="s137">θ</span> <span class="p">(</span><span class="s13">E</span><span class="s93">1</span><span class="s94">)))</span></p><p style="padding-top: 3pt;padding-left: 145pt;text-indent: -22pt;text-align: justify;"><span class="s63">16. </span>Outer joins can be replaced by inner joins under some conditions. Speciﬁcally, if <span class="s15">θ</span><span class="s98">1</span> has the property that it evaluates to false or unknown whenever the attributes of <i>E</i><span class="s98">2</span> are null, then the following equivalences hold.</p><p class="s15" style="padding-top: 4pt;padding-left: 155pt;text-indent: 0pt;text-align: justify;"><span class="p">a. </span>σ<span class="s137">θ</span><span class="s158">1 </span><span class="s388">(</span><span class="s13">E</span><span class="s93">1 </span>⟕<span class="s137">θ</span> <span class="s13">E</span><span class="s93">2</span><span class="s94">) </span><span class="s86">≡ </span>σ<span class="s137">θ</span><span class="s158">1 </span><span class="s388">(</span><span class="s13">E</span><span class="s93">1 </span><span class="s86">⋈ </span><span class="s171">θ </span><span class="s13">E</span><span class="s93">2</span><span class="s94">)</span></p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1           1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 1pt;padding-left: 154pt;text-indent: 0pt;text-align: justify;"><span class="p">b. </span>σ<span class="s137">θ</span> <span class="p">(</span><span class="s13">E</span><span class="s93">2 </span>⟖<span class="s137">θ</span> <span class="s13">E</span><span class="s93">1</span><span class="s94">) </span><span class="s86">≡ </span>σ<span class="s137">θ</span> <span class="p">(</span><span class="s13">E</span><span class="s93">2 </span><span class="s86">⋈ </span><span class="s171">θ </span><span class="s13">E</span><span class="s93">2</span><span class="s94">)</span></p><p style="padding-top: 6pt;padding-left: 145pt;text-indent: 0pt;line-height: 76%;text-align: justify;">A predicate <span class="s15">θ</span><span class="s98">1</span> satisfying the above property is said to be <span class="s63">null rejecting </span>on <i>E</i><span class="s98">2</span>. For example, if <span class="s15">θ</span><span class="s98">1</span> is of the form <i>A </i><span class="s83">&lt; </span>4 where <i>A </i>is an attribute from <i>E</i><span class="s98">2</span>, then <span class="s15">θ</span><span class="s98">1</span> would evaluate to unknown whenever <i>A </i>is null, and as a result any tuples in <i>E</i><span class="s98">1</span> <span class="s15">⟕</span><span class="s137">θ</span><span class="s15"> </span><i>E</i><span class="s98">2</span></p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-left: 145pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="p">that are not in </span>E<span class="s130">1 </span><span class="s86">⋈ </span><span class="s136">θ </span>E<span class="s130">2 </span><span class="s94">would be rejected by </span><span class="s15">σ</span><span class="s137">θ</span><span class="s15"> </span><span class="p">. We can therefore replace the</span></p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 12pt;text-align: left;">outer join by an inner join (or vice versa).</p><p class="s15" style="padding-left: 159pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="p">More generally, the condition would hold if </span>θ<span class="s98">1</span><span class="p"> is of the form </span>θ<span class="s398">1 </span>∧θ<span class="s398">2 </span>∧…∧θ<span class="s399">k</span><span class="p">,</span></p><p style="padding-top: 4pt;padding-left: 145pt;text-indent: 0pt;line-height: 1pt;text-align: left;">and at least one of the terms <span class="s15">θ</span><span class="s399">i</span></p><p style="padding-top: 5pt;padding-left: 3pt;text-indent: 0pt;line-height: 1pt;text-align: left;">is of the form <i>e</i></p><p class="s13" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;line-height: 1pt;text-align: left;">relop e</p><p class="s119" style="padding-left: 29pt;text-indent: 0pt;line-height: 7pt;text-align: left;">1  1     1</p><p class="s13" style="padding-left: 37pt;text-indent: 0pt;line-height: 1pt;text-align: left;">e   e</p><p class="s93" style="padding-left: 281pt;text-indent: 0pt;line-height: 58%;text-align: left;"><span class="s359">1          </span>1     2<span class="s94">, where </span>1 <span class="s94">and </span>2 <span class="s94">are</span></p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 11pt;text-align: left;">arithmetic or string expressions involving at least one attribute from <i>E</i><span class="s98">2</span>, and <i>relop</i></p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 20pt;text-align: left;">is any of <span class="s83">&lt;</span>, <span class="s86">≤</span>, <span class="s15">=</span>, <span class="s86">≥</span>, <span class="s83">&gt;</span>.</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">This is only a partial list of equivalences. More equivalences are discussed in the exercises.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Some equivalences that hold for joins do not hold for outer joins. For example, the selection operation does not distribute over outer join when the conditions speciﬁed in rule 15.a or rule 15.b do hold. To see this, we look at the expression:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="padding-left: 239pt;text-indent: 0pt;text-align: left;">σ<span class="s123">year</span><span class="s137">=</span><span class="s98">2017</span><span class="p">(</span><span class="s13">instructor </span>⟕ <span class="s13">teaches</span><span class="p">)</span></p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">and consider the case of an instructor who teaches no courses at all, regardless of year. In the above expression, the left outer join retains a tuple for each such instructor with a null value for <i>year</i>. Then the selection operation removes those tuples since the predicate <i>null</i>=2017 evaluates to <i>unknown</i>, and such instructors do not appear in the result. However, if we push the selection operation down to <i>teaches</i>, the resulting expression:</p><p class="s13" style="padding-left: 239pt;text-indent: 0pt;text-align: justify;">instructor <span class="s15">⟕ σ</span><span class="s123">year</span><span class="s137">=</span><span class="s98">2017</span><span class="p">(</span>teaches<span class="p">)</span></p><p style="padding-top: 5pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">is syntactically correct since the selection predicate includes only attributes from <i>teaches</i>, but the result is diﬀerent. For an instructor that does not teach at all, the <i>instruc- tor </i>tuple appears in the result of <i>instructor </i><span class="s15">⟕ σ</span><i>year</i><span class="s137">=</span><span class="s98">2017</span>(<i>teaches</i>), but not in the result of <span class="s15">σ</span><i>year</i><span class="s137">=</span><span class="s98">2017</span>(<i>instructor </i><span class="s15">⟕ </span><i>teaches</i>). The following equivalence, however, does hold:</p><p class="s13" style="padding-top: 9pt;padding-left: 164pt;text-indent: 0pt;text-align: left;"><span class="s15">σ</span><span class="s123">year</span><span class="s137">=</span><span class="s98">2017</span><span class="p">(</span>instructor <span class="s15">⟕ </span>teaches<span class="p">) </span><span class="s86">≡ </span><span class="s15">σ</span><span class="s123">year</span><span class="s137">=</span><span class="s98">2017</span><span class="p">(</span>instructor <span class="s86">⋈ </span>teaches<span class="p">)</span></p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 17pt;text-align: left;">As another example, unlike inner joins, outer joins are not associative. We show thus using an example for the natural left outer join. Similar examples can be con-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">structed for natural right and natural full outer join, as well as for the corresponding theta-join versions of the outer join operations.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Let relation <i>r</i>(<i>A</i>, <i>B</i>) be a relation consisting of the single tuple (1, 1), <i>s</i>(<i>B</i>, <i>C</i>) be a relation consisting of the single tuple (1, 1), and <i>t</i>(<i>A</i>, <i>C</i>) be an empty relation with no tuples. We shall show that for this example,</p><p class="s13" style="padding-top: 10pt;padding-left: 59pt;text-indent: 0pt;text-align: center;"><span class="p">(</span>r <span class="s15">⟕ </span>s<span class="p">) </span><span class="s15">⟕ </span>t <span class="s86">≢ </span>r <span class="s15">⟕</span><span class="p">(</span>s <span class="s15">⟕ </span>t<span class="p">)</span></p><p class="s13" style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="p">To see this, note ﬁrst that (</span>r <span class="s15">⟕ </span>s<span class="p">) produces a result with schema (</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">) having one tuple (1, 1, 1). Computing the left outer join of that result with relation </span>t <span class="p">produces a result with schema (</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">) having one tuple (1, 1, 1). Next, we look at the expression </span>r <span class="s15">⟕</span><span class="p">(</span>s <span class="s15">⟕ </span>t<span class="p">), and note that </span>s <span class="s15">⟕ </span>t <span class="p">produces a result with schema (</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">) having one tuple (</span>null<span class="p">, 1, 1). Computing the left outer join of </span>r <span class="p">with that result produces a result with schema (</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">) having one tuple (1, 1, </span>null<span class="p">).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">16.2.2 Examples of Transformations</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We now illustrate the use of the equivalence rules. We use our university example with the relation schemas:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2865.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2866.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2867.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2868.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2869.png"/></span></p><p style="padding-left: 182pt;text-indent: 0pt;text-align: left;"><i>instructor</i>(<span class="s69">ID</span>, <i>name</i>, <i>dept name</i>, <i>salary</i>) <i>teaches</i>(<span class="s69">ID</span>, <i>course id</i>, <i>sec id</i>, <i>semester</i>, <i>year</i>) <i>course</i>(<i>course id</i>, <i>title</i>, <i>dept name</i>, <i>credits</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 106pt;text-indent: 0pt;text-align: left;">In our example in Section 16.1, the expression:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2870.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2871.png"/></span></p><p class="s109" style="padding-top: 10pt;padding-left: 88pt;text-indent: 21pt;line-height: 162%;text-align: left;"><span class="s117">Π</span>name<span class="s119">,</span>title <span class="s122">(</span><span class="s117">σ</span>dept name <span class="s118">= </span><span class="s119">“Music” </span><span class="s120">(</span><span class="s121">instructor </span><span class="s138">⋈ </span><span class="s122">(</span><span class="s121">teaches </span><span class="s138">⋈ </span><span class="s117">Π</span>course id<span class="s119">,</span>title<span class="s122">(</span><span class="s121">course</span><span class="s122">)))) </span><span class="p">was transformed into the following expression:</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2872.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2873.png"/></span></p><p class="s109" style="padding-top: 3pt;padding-left: 107pt;text-indent: 0pt;text-align: left;"><span class="s125">Π</span>name<span class="s119">,</span>title <span class="s129">((</span><span class="s125">σ</span>dept name <span class="s118">= </span><span class="s119">“Music” </span><span class="s127">(</span><span class="s128">instructor</span><span class="s129">)) </span><span class="s147">⋈ </span><span class="s129">(</span><span class="s128">teaches </span><span class="s147">⋈ </span><span class="s125">Π</span>course id<span class="s119">,</span>title<span class="s129">(</span><span class="s128">course</span><span class="s129">)))</span></p><p style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">which is equivalent to our original algebra expression but generates smaller intermedi- ate relations. We can carry out this transformation by using rule 7.a. Remember that the rule merely says that the two expressions are equivalent; it does not say that one is better than the other.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Multiple equivalence rules can be used, one after the other, on a query or on parts of the query. As an illustration, suppose that we modify our original query to restrict attention to instructors who have taught a course in 2017. The new relational-algebra query is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2874.png"/></span></p><p class="s109" style="padding-top: 5pt;padding-left: 133pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s117">Π</span>name<span class="s119">,</span>title <span class="s122">(</span><span class="s117">σ</span>dept name <span class="s118">= </span><span class="s119">“Music” </span><span class="s118">∧ </span>year <span class="s118">= </span><span class="s119">2017</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2875.png"/></span></p><p class="s13" style="padding-left: 208pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="p">(</span>instructor <span class="s86">⋈ </span><span class="p">(</span>teaches <span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">))))</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We cannot apply the selection predicate directly to the <i>instructor </i>relation, since the predicate involves attributes of both the <i>instructor </i>and <i>teaches </i>relations. However, we can ﬁrst apply rule 6.a (associativity of natural join) to transform the join <i>instructor </i><span class="s86">⋈</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2876.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2877.png"/></span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;"><span class="p">(</span>teaches <span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">)) into (</span>instructor <span class="s86">⋈ </span>teaches<span class="p">) </span><span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">):</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2878.png"/></span></p><p class="s109" style="padding-top: 10pt;padding-left: 169pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s117">Π</span>name<span class="s119">,</span>title <span class="s122">(</span><span class="s117">σ</span>dept name <span class="s118">= </span><span class="s119">“Music” </span><span class="s118">∧ </span>year <span class="s118">= </span><span class="s119">2017</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2879.png"/></span></p><p class="s13" style="padding-left: 198pt;text-indent: 0pt;line-height: 15pt;text-align: center;"><span class="p">((</span>instructor <span class="s86">⋈ </span>teaches<span class="p">) </span><span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">)))</span></p><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Then, using rule 7.a, we can rewrite our query as:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2880.png"/></span></p><p class="s109" style="padding-left: 170pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s117">Π</span>name<span class="s119">,</span>title <span class="s122">((</span><span class="s117">σ</span>dept name <span class="s118">= </span><span class="s119">“Music” </span><span class="s118">∧ </span>year <span class="s118">= </span><span class="s119">2017</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2881.png"/></span></p><p class="s13" style="padding-left: 201pt;text-indent: 0pt;line-height: 15pt;text-align: center;"><span class="p">(</span>instructor <span class="s86">⋈ </span>teaches<span class="p">)) </span><span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">))</span></p><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Let us examine the selection subexpression within this expression. Using rule 1, we can break the selection into two selections to get the following subexpression:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2882.png"/></span></p><p class="s117" style="padding-left: 196pt;text-indent: 0pt;text-align: left;">σ<span class="s109">dept name </span><span class="s118">= </span><span class="s119">“Music” </span><span class="s120">(</span>σ<span class="s109">year </span><span class="s118">= </span><span class="s119">2017 </span><span class="s120">(</span><span class="s121">instructor </span><span class="s138">⋈ </span><span class="s121">teaches</span><span class="s122">))</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2883.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2884.png"/></span></p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Both of the preceding expressions select tuples with <i>dept name </i><span class="s15">= </span>“Music” and <i>course id </i>= 2017. However, the latter form of the expression provides a new opportunity to apply rule 7.a (“perform selections early”), resulting in the subexpression:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2885.png"/></span></p><p class="s125" style="padding-left: 196pt;text-indent: 0pt;text-align: left;">σ<span class="s109">dept name </span><span class="s118">= </span><span class="s119">“Music” </span><span class="s127">(</span><span class="s128">instructor</span><span class="s129">) </span><span class="s147">⋈ </span>σ<span class="s109">year </span><span class="s118">= </span><span class="s119">2017 </span><span class="s127">(</span><span class="s128">teaches</span><span class="s129">)</span></p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Figure 16.4 depicts the initial expression and the ﬁnal expression after all these transformations. We could equally well have used rule 7.b to get the ﬁnal expression directly, without using rule 1 to break the selection into two selections. In fact, rule 7.b can itself be derived from rules 1 and 7.a.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s385" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">∏ <span class="s108">name, title</span></p><p class="s385" style="padding-top: 4pt;padding-left: 84pt;text-indent: 0pt;text-align: center;">∏ <span class="s108">name, title</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="83" height="83" alt="image" src="Image_2886.png"/></span></p><p class="s385" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">σ<span class="s108">dept_name = </span><span class="s312">Music</span></p><p class="s400" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">^ <span class="s108">year = </span><span class="s312">2017</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 184pt;text-indent: 0pt;text-align: left;"><span><img width="1" height="20" alt="image" src="Image_2887.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 394pt;text-indent: 0pt;text-align: left;"><span><img width="50" height="20" alt="image" src="Image_2888.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="88" height="85" alt="image" src="Image_2889.png"/></span></p><p style="padding-left: 155pt;text-indent: 0pt;text-align: left;"><span><img width="29" height="20" alt="image" src="Image_2890.png"/></span></p><p class="s338" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">instructor</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s385" style="padding-left: 133pt;text-indent: 0pt;text-align: left;">σ<span class="s108">dept_name = </span><span class="s312">Music  </span><span class="s401">σ </span><span class="s402">year = </span><span class="s403">2017</span></p><p class="s385" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;">∏ <span class="s108">course_id, title</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="24" alt="image" src="Image_2891.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="24" alt="image" src="Image_2892.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="54" alt="image" src="Image_2893.png"/></span></p><p class="s338" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">teaches</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s404" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">∏ <span class="s108">course_id, title</span></p><p style="padding-left: 47pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span><img width="1" height="12" alt="image" src="Image_2894.png"/></span></p><p class="s338" style="padding-left: 50pt;text-indent: 0pt;text-align: center;">course</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s338" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">instructor     teaches   course</p><p class="s119" style="padding-top: 5pt;padding-left: 170pt;text-indent: 0pt;text-align: left;">(a) Initial expression tree            (b) Tree after multiple transformations</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 221pt;text-indent: 0pt;text-align: left;">Figure 16.4 <span class="s74">Multiple transformations.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">A set of equivalence rules is said to be <span class="s63">minimal </span>if no rule can be derived from any combination of the others. The preceding example illustrates that the set of equiva- lence rules in Section 16.2.1 is not minimal. An expression equivalent to the original expression may be generated in diﬀerent ways; the number of diﬀerent ways of generat- ing an expression increases when we use a nonminimal set of equivalence rules. Query optimizers therefore use minimal sets of equivalence rules.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">Now consider the following form of our example query:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2895.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2896.png"/></span></p><p class="s109" style="padding-left: 88pt;text-indent: 27pt;line-height: 160%;text-align: justify;"><span class="s125">Π</span>name<span class="s119">,</span>title <span class="s129">((</span><span class="s125">σ</span>dept name <span class="s118">= </span><span class="s119">“Music” </span><span class="s127">(</span><span class="s128">instructor</span><span class="s129">) </span><span class="s147">⋈ </span><span class="s128">teaches</span><span class="s129">) </span><span class="s147">⋈ </span><span class="s125">Π</span>course id<span class="s119">,</span>title<span class="s129">(</span><span class="s128">course</span><span class="s129">)) </span><span class="p">When we compute the subexpression:</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2897.png"/></span></p><p class="s13" style="padding-top: 3pt;padding-left: 88pt;text-indent: 100pt;line-height: 161%;text-align: justify;"><span class="p">(</span><span class="s15">σ</span><span class="s123">dept</span> <span class="s123">name</span> <span class="s137">=</span><span class="s15"> </span><span class="s98">“Music”</span><span class="p"> (</span>instructor<span class="p">) </span><span class="s86">⋈ </span>teaches<span class="p">) we obtain a relation whose schema is:</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2898.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2899.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2900.png"/></span></p><p style="padding-top: 4pt;padding-left: 141pt;text-indent: 0pt;text-align: justify;">(<span class="s69">ID</span>, <i>name</i>, <i>dept name</i>, <i>salary</i>, <i>course id</i>, <i>sec id</i>, <i>semester</i>, <i>year</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2901.png"/></span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">We can eliminate several attributes from the schema by pushing projections based on equivalence rules 8.a and 8.b. The only attributes that we must retain are those that ei- ther appear in the result of the query or are needed to process subsequent operations. By eliminating unneeded attributes, we reduce the number of columns of the interme- diate result. Thus, we reduce the size of the intermediate result. In our example, the only attributes we need from the join of <i>instructor </i>and <i>teaches </i>are <i>name </i>and <i>course id</i>. Therefore, we can modify the expression to:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2902.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2903.png"/></span></p><p class="s109" style="padding-top: 10pt;padding-left: 63pt;text-indent: 0pt;line-height: 15pt;text-align: center;"><span class="s117">Π</span>name<span class="s119">,</span>title <span class="s122">((</span><span class="s117">Π</span>name<span class="s119">,</span>course id <span class="s122">((</span><span class="s117">σ</span>dept name <span class="s118">= </span><span class="s119">“Music” </span><span class="s120">(</span><span class="s121">instructor</span><span class="s122">)) </span><span class="s138">⋈ </span><span class="s121">teaches</span><span class="s122">))</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2904.png"/></span></p><p class="s109" style="padding-left: 164pt;text-indent: 0pt;line-height: 15pt;text-align: center;"><span class="s147">⋈ </span><span class="s125">Π</span>course id<span class="s119">,</span>title<span class="s129">(</span><span class="s128">course</span><span class="s129">))</span></p><p class="s123" style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="p">The projection </span><span class="s15">Π</span>name<span class="s98">,</span>course<span class="s13"> </span>id<span class="s13"> </span><span class="p">reduces the size of the intermediate join results.</span></p><p style="padding-left: 199pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="3" height="0" alt="image" src="Image_2905.png"/></span></p><p class="s68" style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">16.2.3 Join Ordering</p><p class="s13" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="p">A good ordering of join operations is important for reducing the size of temporary results; hence, most query optimizers pay a lot of attention to the join order. As men- tioned in equivalence rule 6.a, the natural-join operation is associative. Thus, for all relations </span>r<span class="s93">1</span><span class="s94">, </span>r<span class="s93">2</span><span class="s94">, and </span>r<span class="s93">3</span><span class="s94">:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 2pt;padding-left: 63pt;text-indent: 0pt;text-align: center;"><span class="p">(</span>r<span class="s93">1 </span><span class="s86">⋈ </span>r<span class="s93">2</span><span class="s94">) </span><span class="s86">⋈ </span>r<span class="s93">3 </span><span class="s86">≡ </span>r<span class="s93">1 </span><span class="s86">⋈ </span><span class="p">(</span>r<span class="s93">2 </span><span class="s86">⋈ </span>r<span class="s93">3</span><span class="s94">)</span></p><p style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">Although these expressions are equivalent, the costs of computing them may diﬀer. Consider again the expression:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2906.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2907.png"/></span></p><p class="s109" style="padding-top: 10pt;padding-left: 63pt;text-indent: 0pt;text-align: center;"><span class="s117">Π</span>name<span class="s119">,</span>title <span class="s122">((</span><span class="s117">σ</span>dept name <span class="s118">= </span><span class="s119">“Music” </span><span class="s120">(</span><span class="s121">instructor</span><span class="s122">)) </span><span class="s138">⋈ </span><span class="s121">teaches </span><span class="s138">⋈ </span><span class="s117">Π</span>course id<span class="s119">,</span>title<span class="s122">(</span><span class="s121">course</span><span class="s122">))</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2908.png"/></span></p><p class="s123" style="padding-top: 5pt;padding-left: 119pt;text-indent: 0pt;line-height: 85%;text-align: left;"><span class="p">We could choose to compute </span><span class="s13">teaches </span><span class="s86">⋈ </span><span class="s15">Π</span>course<span class="s13"> </span>id<span class="s98">,</span>title<span class="p">(</span><span class="s13">course</span><span class="p">) ﬁrst, and then to join the result with:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2909.png"/></span></p><p class="s117" style="padding-top: 5pt;padding-left: 84pt;text-indent: 0pt;text-align: center;">σ<span class="s109">dept name </span><span class="s118">= </span><span class="s119">“Music” </span><span class="s120">(</span><span class="s121">instructor</span><span class="s122">)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2910.png"/></span></p><p class="s123" style="padding-top: 10pt;padding-left: 119pt;text-indent: 17pt;line-height: 86%;text-align: left;"><span class="p">However, </span><span class="s13">teaches </span><span class="s86">⋈ </span><span class="s15">Π</span>course<span class="s13"> </span>id<span class="s98">,</span>title<span class="p">(</span><span class="s13">course</span><span class="p">) is likely to be a large relation, since it contains one tuple for every course taught. In contrast:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2911.png"/></span></p><p class="s13" style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s15">σ</span><span class="s123">dept</span> <span class="s123">name</span> <span class="s137">=</span><span class="s15"> </span><span class="s98">“Music”</span><span class="p"> (</span>instructor<span class="p">) </span><span class="s86">⋈ </span>teaches</p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">is probably a small relation. To see that it is, we note that a university has fewer in- structors than courses and, since a university has a large number of departments, it is likely that only a small fraction of the university instructors are associated with the Music department. Thus, the preceding expression results in one tuple for each course taught by an instructor in the Music department. Therefore, the temporary relation that we must store is smaller than it would have been had we computed</p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2912.png"/></span></p><p class="s123" style="padding-left: 119pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="s13">teaches </span><span class="s86">⋈ </span><span class="s15">Π</span>course<span class="s13"> </span>id<span class="s98">,</span>title<span class="p">(</span><span class="s13">course</span><span class="p">) ﬁrst.</span></p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 12pt;text-align: left;">There are other options to consider for evaluating our query. We do not care about</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">the order in which attributes appear in a join, since it is easy to change the order before displaying the result. Thus, for all relations <i>r</i><span class="s98">1</span> and <i>r</i><span class="s98">2</span>:</p><p class="s13" style="padding-top: 10pt;padding-left: 84pt;text-indent: 0pt;text-align: center;">r<span class="s93">1 </span><span class="s86">⋈ </span>r<span class="s93">2 </span><span class="s86">≡ </span>r<span class="s93">2 </span><span class="s86">⋈ </span>r<span class="s93">1</span></p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">That is, natural join is commutative (equivalence rule 5).</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: left;">Using the associativity and commutativity of the natural join (rules 5 and 6), con- sider the following relational-algebra expression:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2913.png"/></span></p><p class="s13" style="padding-top: 10pt;padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="p">(</span>instructor <span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">)) </span><span class="s86">⋈ </span>teaches</p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2914.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2915.png"/></span></p><p class="s13" style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="p">Note that there are no attributes in common between </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">) and </span>instruc- tor<span class="p">, so the join is just a Cartesian product. If there are </span>a <span class="p">tuples in </span>instructor <span class="p">and </span>b <span class="p">tuples in </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">), this Cartesian product generates </span>a <span class="s15">∗ </span>b <span class="p">tuples, one for every possible pair of instructor tuple and course (without regard for whether the instruc- tor taught the course). This Cartesian product would produce a very large temporary relation. However, if the user had entered the preceding expression, we could use the associativity and commutativity of the natural join to transform this expression to the more eﬃcient expression:</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2916.png"/></span></p><p class="s13" style="padding-top: 10pt;padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="p">(</span>instructor <span class="s86">⋈ </span>teaches<span class="p">) </span><span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">course</span> <span class="s123">id</span><span class="s98">,</span><span class="s123">title</span><span class="p">(</span>course<span class="p">)</span></p><p class="s68" style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">16.2.4 Enumeration of Equivalent Expressions</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Query optimizers can use equivalence rules to systematically generate expressions equivalent to the given query expression. The cost of an expression is computed based</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2917.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 116pt;text-indent: 0pt;text-align: left;"><b>procedure </b>genAllEquivalent(<i>E</i>)</p><p class="s13" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">EQ <span class="p">= </span><span class="s15">{</span>E<span class="s15">}</span></p><p class="s46" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">repeat</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 14pt;text-align: left;">Match each expression <i>E</i><span class="s97">i </span>in <i>EQ </i>with each equivalence rule <i>R</i><span class="s97">j</span></p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><b>if </b>any subexpression <i>e</i><span class="s97">i </span>of <i>E</i><span class="s97">i </span>matches one side of <i>R</i><span class="s97">j</span></p><p style="padding-left: 159pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Create a new expression <i>E</i><span class="s181">′</span><span class="s15"> </span>which is identical to <i>E</i><span class="s97">i</span>, except that</p><p class="s13" style="padding-left: 180pt;text-indent: 0pt;line-height: 13pt;text-align: left;">e<span class="s97">i </span><span class="p">is transformed to match the other side of </span>R<span class="s97">j</span></p><p style="padding-left: 159pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Add <i>E</i><span class="s181">′</span><span class="s15"> </span>to <i>EQ </i>if it is not already present in <i>EQ</i></p><p class="s46" style="padding-left: 116pt;text-indent: 0pt;text-align: left;">until <span class="p">no new expression can be added to </span><i>EQ</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2918.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 16.5 <span class="s74">Procedure to generate all equivalent expressions.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 90pt;text-indent: 0pt;text-align: right;"><span class="p">on statistics that are discussed in Section 16.3. Cost-based query optimizers, described in Section 16.4 compute the cost of each alternative and pick the least cost alternative. Conceptually, enumeration of equivalent expressions can be done as outlined in Figure 16.5. The process proceeds as follows: Given a query expression </span>E<span class="p">, the set of equivalent expressions </span>EQ <span class="p">initially contains only </span>E<span class="p">. Now, each expression in </span>EQ <span class="p">is matched with each equivalence rule. If a subexpression </span>e<span class="s97">j </span><span class="p">of any expression </span>E<span class="s97">i </span><span class="s15">∈ </span>EQ</p><p style="padding-left: 87pt;text-indent: 0pt;line-height: 12pt;text-align: right;">(as a special case, <i>e</i><span class="s145">j </span>could be <i>E</i><span class="s145">i </span>itself) matches one side of an equivalence rule, the</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 94%;text-align: justify;">optimizer generates a copy <i>E</i><span class="s145">k </span>of <i>E</i><span class="s145">i</span>, in which <i>e</i><span class="s145">j </span>is transformed to match the other side of the rule, and adds <i>E</i><span class="s145">k </span>to <i>EQ</i>. This process continues until no more new expressions can be generated. With a properly chosen set of equivalence rules, the set of equivalent expressions is ﬁnite, and the process can be guaranteed to terminate.</p><p class="s13" style="padding-left: 88pt;text-indent: 17pt;line-height: 79%;text-align: justify;"><span class="p">For example, given an expression </span>r <span class="s86">⋈ </span><span class="p">(</span>s <span class="s86">⋈ </span>t<span class="p">), the commutativity rule can match the subexpression (</span>s <span class="s86">⋈ </span>t<span class="p">), and would create a new expression </span>r <span class="s86">⋈ </span><span class="p">(</span>t <span class="s86">⋈ </span>s<span class="p">). The commutativity rule also matches the join at the root of </span>r <span class="s86">⋈ </span><span class="p">(</span>s <span class="s86">⋈ </span>t<span class="p">), and creates a new expression (</span>s <span class="s86">⋈ </span>t<span class="p">) </span><span class="s86">⋈ </span>r<span class="p">. Associativity and commutativity rules can continue to be applied to generate new expressions. But eventually applying any equivalence rule</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">will only generate expressions that were already generated earlier, and the process will terminate.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The preceding process is extremely costly both in space and in time, but optimizers can greatly reduce both the space and time cost, using two key ideas.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 113pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span>If we generate an expression <i>E</i><span class="s181">′</span><span class="s15"> </span>from an expression <i>E</i><span class="s98">1</span> by using an equivalence rule on subexpression <i>e</i><span class="s97">i</span>, then <i>E</i><span class="s181">′</span><span class="s15"> </span>and <i>E</i><span class="s98">1</span> have identical subexpressions except for <i>e</i><span class="s97">i </span>and its transformation. Even <i>e</i><span class="s97">i </span>and its transformed version usually share many identical subexpressions. Expression-representation techniques that allow both expressions to point to shared subexpressions can reduce the space requirement signiﬁcantly.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-top: 4pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;"><a name="bookmark338">2. </a><span class="p">It is not always necessary to generate every expression that can be generated with the equivalence rules. If an optimizer takes cost estimates of evaluation into account, it may be able to avoid examining some of the expressions, as we shall see in Section 16.4. We can reduce the time required for optimization by using techniques such as these.</span><a name="bookmark358">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">With these and other techniques to reduce the optimization time, equivalence rules can be used to enumerate alternative plans, whose costs can be computed; the lowest-cost plan amongst the alternatives is then chosen. We discuss eﬃcient implementation of cost-based query optimization based on equivalence rules in Section 16.4.2.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Some query optimizers use equivalence rules in a heuristic manner. With such an approach, if the left-hand side of an equivalence rule matches a subtree in a query plan, the subtree is rewritten to match the right-hand side of the rule. This process is repeated till the query plan cannot be further rewritten. Rules must be carefully chosen such that the cost decreases when a rule is applied, and rewriting must eventually terminate. Although this approach can be implemented to execute quite fast, there is no guarantee that it will ﬁnd the optimal plan.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Yet other query optimizers focus on join order selection, which is often a key factor in query cost. We discuss algorithms for join-order optimization in Section 16.4.1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part296.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part298.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
