<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>8.2   Object Orientation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part171.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part173.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">8.2   <span style=" color: #00AEEF;">Object Orientation</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <span class="s63">object-relational data model </span>extends the relational data model by providing a richer type system, including complex data types and object orientation. Relational query</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">languages, in particular <span class="s44">SQL</span>, have been extended correspondingly to deal with the richer type system. Such extensions attempt to preserve the relational foundations — in particular, the declarative access to data— while extending the modeling power.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Many database applications are written using an object-oriented programming language, such as Java, Python, or C++, but they need to store and fetch data from databases. Due to the type diﬀerence between the native type system of the object- oriented programming language and the relational model supported by databases, data need to be translated between the two models whenever they are fetched or stored. Merely extending the type system supported by the database was not enough to solve this problem completely. Having to express database access using a language (<span class="s44">SQL</span>) that is diﬀerent from the programming language again makes the job of the program- mer harder. It is desirable, for many applications, to have programming language con- structs or extensions that permit direct access to data in the database, without having to go through an intermediate language such as <span class="s44">SQL</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Three approaches are used in practice for integrating object orientation with database systems:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span class="p">Build an </span>object-relational database system<span class="p">, which adds object-oriented features to a relational database system.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span class="p">Automatically convert data from the native object-oriented type system of the programming language to a relational representation for storage, and vice versa for retrieval. Data conversion is speciﬁed using an </span>object-relational mapping<span class="p">.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">3. <span class="p">Build an </span>object-oriented database system<span class="p">, that is, a database system that natively supports an object-oriented type system and allows direct access to data from an object-oriented programming language using the native type system of the language.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">We provide a brief introduction to the ﬁrst two approaches in this section. While the third approach, the object-oriented database approach, has some beneﬁts over the ﬁrst two approaches in terms of language integration, it has not seen much success for two reasons. First, declarative querying is very important for eﬃciently accessing data, and such querying is not supported by imperative programming languages. Second, direct access to objects via pointers was found to result in increased risk of database corruption due to pointer errors. We do not describe the object-oriented approach any further.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">8.2.1 Object-Relational Database Systems</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">In this section, we outline how object-oriented features can be added to relational database systems.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">8.2.1.1 User-Defined Types</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">Object extensions to <span class="s44">SQL </span>allow creation of structured user-deﬁned types, references to such types, and tables containing tuples of such types.<span class="s76">1</span></p><p class="s46" style="padding-top: 10pt;padding-left: 201pt;text-indent: 0pt;text-align: left;">create type <i>Person</i></p><p style="padding-left: 222pt;text-indent: 0pt;text-align: left;">(<i>ID </i><b>varchar</b>(20) <b>primary key</b>,</p><p style="padding-left: 222pt;text-indent: 0pt;text-align: left;"><i>name </i><b>varchar</b>(20), <i>address </i><b>varchar</b>(20)) <b>ref from</b>(<i>ID</i>);</p><p class="s46" style="padding-left: 201pt;text-indent: 0pt;text-align: left;">create table <i>people </i>of <i>Person</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 10pt;padding-left: 106pt;text-indent: 0pt;text-align: left;">We can create a new person as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 50pt;text-indent: 0pt;text-align: center;"><b>insert into </b>people <span class="p">(</span>ID, name, address<span class="p">) </span><b>values</b></p><p style="padding-left: 196pt;text-indent: 0pt;text-align: left;">(&#39;12345&#39;, &#39;Srinivasan&#39;, &#39;23 Coyote Run&#39;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Many database systems support array and table types; attributes of relations and of user-deﬁned types can be declared to be of such array or table types. The support for such features as well as the syntax varies widely by database system. In <span class="s44">P</span>ostgre<span class="s44">SQL</span>, for example, <i>integer</i>[] denotes an array of integers whose size is not prespeciﬁed, while Oracle supports the syntax <b>varray</b>(10) <b>of integer </b>to specify an array of 10 integers. <span class="s44">SQL S</span>erver allows table-valued types to be declared as shown in the following example:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2155.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2156.png"/></span></p><p class="s46" style="padding-left: 234pt;text-indent: -21pt;text-align: left;">create type <i>interest </i>as table <span class="p">( </span><i>topic </i>varchar<span class="p">(20), </span><i>degree of interest </i>int</p><p style="padding-left: 212pt;text-indent: 0pt;text-align: left;">);</p><p class="s46" style="padding-left: 212pt;text-indent: 0pt;text-align: left;">create table <i>users </i><span class="p">(</span></p><p class="s13" style="padding-left: 234pt;text-indent: 0pt;text-align: left;">ID <b>varchar</b><span class="p">(20), </span>name <b>varchar</b><span class="p">(20), </span>interests interest</p><p style="padding-left: 33pt;text-indent: 0pt;text-align: center;">);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: left;">User-deﬁned types can also have methods associated with them. Only a few database systems, such as Oracle, support this feature; we omit details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">8.2.1.2 Type Inheritance</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">Consider the earlier deﬁnition of the type <i>Person </i>and the table <i>people</i>. We may want to store extra information in the database about people who are students and about people</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2157.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">1<span class="s78">Structured types are diﬀerent from the simpler “distinct” data types that we covered in Section 4.5.5.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">who are teachers. Since students and teachers are also people, we can use inheritance to deﬁne the student and teacher types in <span class="s44">SQL</span>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">create type <i>Student </i>under <i>Person</i></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;">(<i>degree </i><b>varchar</b>(20)) ;</p><p class="s46" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">create type <i>Teacher </i>under <i>Person</i></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;">(<i>salary </i><b>integer</b>);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Both <i>Student </i>and <i>Teacher </i>inherit the attributes of <i>Person </i>— namely, <i>ID</i>, <i>name</i>, and <i>ad- dress</i>. <i>Student </i>and <i>Teacher </i>are said to be subtypes of <i>Person</i>, and <i>Person </i>is a supertype of <i>Student</i>, as well as of <i>Teacher</i>.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">Methods of a structured type are inherited by its subtypes, just as attributes are.</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">However, a subtype can redeﬁne the eﬀect of a method. We omit details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">8.2.1.3 Table Inheritance</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Table inheritance allows a table to be declared as a subtable of another table and cor- responds to the <span class="s44">E-R </span>notion of specialization/generalization. Several database systems support table inheritance, but in diﬀerent ways.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">In <span class="s44">P</span>ostgre<span class="s44">SQL</span>, we could create a table <i>people </i>and then create tables <i>students </i>and</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">teachers <span class="p">as subtables of </span>people <span class="p">as follows:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 271pt;text-indent: -21pt;text-align: left;">create table <i>students </i><span class="p">(</span><i>degree </i>varchar<span class="p">(20)) </span>inherits <i>people</i><span class="p">;</span></p><p class="s46" style="padding-left: 271pt;text-indent: -21pt;text-align: justify;">create table <i>teachers </i><span class="p">(</span><i>salary </i>integer<span class="p">) </span>inherits <i>people</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">As a result, every attribute present in the table <i>people </i>is also present in the subtables</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">students <span class="p">and </span>teachers<span class="p">.</span></p><p class="s42" style="padding-left: 137pt;text-indent: 0pt;text-align: left;">SQL:1999 <span class="s43">supports table inheritance but requires table types to be speciﬁed ﬁrst.</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">Thus, in Oracle, which supports <span class="s44">SQL:1999</span>, we could use:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 238pt;text-indent: 0pt;text-align: left;">create table <i>people </i>of <i>Person</i><span class="p">;</span></p><p class="s46" style="padding-left: 238pt;text-indent: 0pt;text-align: left;">create table <i>students </i>of <i>Student</i></p><p class="s46" style="padding-left: 259pt;text-indent: 0pt;text-align: left;">under <i>people</i><span class="p">;</span></p><p class="s46" style="padding-left: 238pt;text-indent: 0pt;text-align: left;">create table <i>teachers </i>of <i>Teacher</i></p><p class="s46" style="padding-left: 259pt;text-indent: 0pt;text-align: left;">under <i>people</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">where the types <i>Student </i>and <i>Teacher </i>have been declared to be subtypes of <i>Person </i>as described earlier.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 18pt;text-indent: 0pt;text-align: center;">In either case, we can insert a tuple into the <i>student </i>table as follows:</p><p class="s46" style="padding-top: 10pt;padding-left: 56pt;text-indent: 0pt;text-align: center;">insert into <i>student </i>values <span class="p">(&#39;00128&#39;, &#39;Zhang&#39;, &#39;235 Coyote Run&#39;, &#39;Ph.D.&#39;);</span></p><p style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">where we provide values for the attributes inherited from <i>people </i>as well as the local attributes of <i>student</i>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When we declare <i>students </i>and <i>teachers </i>as subtables of <i>people</i>, every tuple present in <i>students </i>or <i>teachers </i>becomes implicitly present in <i>people</i>. Thus, if a query uses the table <i>people</i>, it will ﬁnd not only tuples directly inserted into that table but also tuples inserted into its subtables, namely, <i>students </i>and <i>teachers</i>. However, only those attributes that are present in <i>people </i>can be accessed by that query. <span class="s44">SQL </span>permits us to ﬁnd tuples that are in <i>people </i>but not in its subtables by using “<b>only </b><i>people</i>” in place of <i>people </i>in a query.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">8.2.1.4 Reference Types in SQL</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Some <span class="s44">SQL </span>implementations such as Oracle support reference types. For example, we could deﬁne the <i>Person </i>type as follows, with a reference-type declaration:</p><p class="s46" style="padding-top: 8pt;padding-left: 201pt;text-indent: 0pt;text-align: left;">create type <i>Person</i></p><p style="padding-left: 222pt;text-indent: 0pt;text-align: left;">(<i>ID </i><b>varchar</b>(20) <b>primary key</b>,</p><p style="padding-left: 222pt;text-indent: 0pt;text-align: left;"><i>name </i><b>varchar</b>(20), <i>address </i><b>varchar</b>(20)) <b>ref from</b>(<i>ID</i>);</p><p class="s46" style="padding-left: 201pt;text-indent: 0pt;text-align: left;">create table <i>people </i>of <i>Person</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">By default, <span class="s44">SQL </span>assigns system-deﬁned identiﬁers for tuples, but an existing primary- key value can be used to reference a tuple by including the <b>ref from </b>clause in the type deﬁnition as shown above.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We can deﬁne a type <i>Department </i>with a ﬁeld <i>name </i>and a ﬁeld <i>head </i>that is a refer- ence to the type <i>Person</i>. We can then create a table <i>departments </i>of type <i>Department</i>, as follows:</p><p class="s46" style="padding-top: 7pt;padding-left: 188pt;text-indent: 0pt;text-align: left;">create type <i>Department </i><span class="p">(</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2158.png"/></span></p><p class="s13" style="padding-left: 210pt;text-indent: 0pt;text-align: left;">dept name <b>varchar(20)</b><span class="p">,</span></p><p class="s13" style="padding-left: 210pt;text-indent: 0pt;text-align: left;">head <b>ref</b><span class="p">(</span>Person<span class="p">) </span><b>scope </b>people<span class="p">);</span></p><p class="s46" style="padding-left: 188pt;text-indent: 0pt;text-align: left;">create table <i>departments </i>of <i>Department</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">Note that the <b>scope </b>clause above completes the deﬁnition of the foreign key from <i>de- partments.head </i>to the <i>people </i>relation.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: left;">When inserting a tuple for <i>departments</i>, we can then use:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 215pt;text-indent: 0pt;text-align: left;">insert into <i>departments</i></p><p style="padding-left: 77pt;text-indent: 0pt;text-align: center;"><b>values </b>(&#39;<span class="s44">CS</span>&#39;, &#39;12345&#39;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">since the <span class="s44">ID </span>attribute is used as a reference to <i>Person</i>. Alternatively, the deﬁnition of <i>Person </i>can specify that the reference must be generated automatically by the system when a <i>Person </i>object is created. System-generated identiﬁers can be retrieved using <b>ref</b>(<i>r</i>) where <i>r </i>is a table name of table alias used in a query. Thus, we could create a <i>Person </i>tuple, and, using the ID or name of the person, we could retrieve the reference to the tuple in a subquery, which is used to create the value for the <i>head </i>attribute when inserting a tuple into the <i>departments </i>table. Since most database systems do not allow subqueries in an <b>insert into </b><i>departments </i><b>values </b>statement, the following two queries can be used to carry out the task:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">insert into <i>departments</i></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: right;"><b>values </b>(&#39;<span class="s44">CS</span>&#39;, null);</p><p class="s46" style="padding-left: 241pt;text-indent: 0pt;text-align: left;">update <i>departments</i></p><p class="s46" style="padding-left: 283pt;text-indent: -21pt;text-align: left;">set <i>head </i><span class="p">= (</span>select ref<span class="p">(</span><i>p</i><span class="p">) </span>from <i>people </i>as <i>p </i>where <i>ID </i><span class="p">= &#39;12345&#39;)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2159.png"/></span></p><p class="s46" style="padding-left: 262pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="p">= &#39;CS&#39;;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 70%;text-align: justify;">References are dereferenced in <span class="s44">SQL:1999 </span>by the <span class="s15">−</span><span class="s83">&gt; </span>symbol. Consider the <i>depart- ments </i>table deﬁned earlier. We can use this query to ﬁnd the names and addresses of</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">the heads of all departments:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 227pt;text-indent: 0pt;line-height: 19pt;text-align: left;"><b>select </b>head<span class="s15">−</span><span class="s83">&gt;</span>name<span class="p">, </span>head<span class="s15">−</span><span class="s83">&gt;</span>address</p><p class="s46" style="padding-left: 228pt;text-indent: 0pt;line-height: 10pt;text-align: left;">from <i>departments</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 19pt;text-align: justify;">An expression such as “<i>head</i><span class="s15">−</span><span class="s83">&gt;</span><i>name</i>” is called a <span class="s63">path expression</span>.</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Since <i>head </i>is a reference to a tuple in the <i>people </i>table, the attribute <i>name </i>in the</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">preceding query is the <i>name </i>attribute of the tuple from the <i>people </i>table. References can be used to hide join operations; in the preceding example, without the references, the <i>head </i>ﬁeld of <i>department </i>would be declared a foreign key of the table <i>people</i>. To ﬁnd the name and address of the head of a department, we would require an explicit join of the relations <i>departments </i>and <i>people</i>. The use of references simpliﬁes the query considerably.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We can use the operation <b>deref </b>to return the tuple pointed to by a reference and then access its attributes, as shown below:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 253pt;text-indent: 0pt;text-align: left;"><b>select deref</b><span class="p">(</span>head<span class="p">).</span>name <b>from </b>departments<span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">8.2.2 Object-Relational Mapping</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s63">Object-relational mapping </span>(<span class="s64">ORM</span>) systems allow a programmer to deﬁne a mapping between tuples in database relations and objects in the programming language.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;"><a name="bookmark179">An object, or a set of objects, can be retrieved based on a selection condition on its attributes; relevant data are retrieved from the underlying database based on the selection conditions, and one or more objects are created from the retrieved data, based on the prespeciﬁed mapping between objects and relations.</a><a name="bookmark200">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">The program can update retrieved objects, create new objects, or specify that an object is to be deleted, and then issue a save command; the mapping from objects to relations is then used to correspondingly update, insert, or delete tuples in the database. The primary goal of object-relational mapping systems is to ease the job of pro- grammers who build applications by providing them an object model while retaining the beneﬁts of using a robust relational database underneath. As an added beneﬁt, when operating on objects cached in memory, object-relational systems can provide</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">signiﬁcant performance gains over direct access to the underlying database.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Object-relational mapping systems also provide query languages that allow pro- grammers to write queries directly on the object model; such queries are translated into <span class="s44">SQL </span>queries on the underlying relational database, and result objects are created from the <span class="s44">SQL </span>query results.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A fringe beneﬁt of using an <span class="s44">ORM </span>is that any of a number of databases can be used to store data, with exactly the same high-level code. <span class="s44">ORM</span>s hide minor <span class="s44">SQL </span>diﬀerences between databases from the higher levels. Migration from one database to another is thus relatively straightforward when using an <span class="s44">ORM</span>, whereas <span class="s44">SQL </span>diﬀerences can make such migration signiﬁcantly harder if an application uses <span class="s44">SQL </span>to communicate with the database.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">On the negative side, object-relational mapping systems can suﬀer from signiﬁcant performance ineﬃciencies for bulk database updates, as well as for complex queries that are written directly in the imperative language. It is possible to update the database directly, bypassing the object-relational mapping system, and to write complex queries directly in <span class="s44">SQL </span>in cases where such ineﬃciencies are discovered.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The beneﬁts of object-relational models exceed the drawbacks for many applica- tions, and object-relational mapping systems have seen widespread adoption in recent years. In particular, Hibernate has seen wide adoption with Java, while several <span class="s44">ORM</span>s including Django and <span class="s44">SQLA</span>lchemy are widely used with Python. More information on the Hibernate <span class="s44">ORM </span>system, which provides an object-relational mapping for Java, and the Django <span class="s44">ORM </span>system, which provides an object-relational mapping for Python, can be found in Section 9.6.2.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part171.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part173.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
