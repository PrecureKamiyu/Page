<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>4.6   Index Definition in SQL</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part107.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part109.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark63">4.6   </a><span style=" color: #00AEEF;">Index Definition in SQL</span><a name="bookmark104">&zwnj;</a></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Many queries reference only a small proportion of the records in a ﬁle. For example, a query like “Find all instructors in the Physics department” or “Find the <i>salary </i>value of the instructor with <span class="s69">ID </span>22201” references only a fraction of the instructor records. It is ineﬃcient for the system to read every record and to check <span class="s69">ID </span>ﬁeld for the <span class="s69">ID </span>“32556,” or the <i>building </i>ﬁeld for the value “Physics”.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_825.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_826.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_827.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">An <span class="s63">index </span>on an attribute of a relation is a data structure that allows the database system to ﬁnd those tuples in the relation that have a speciﬁed value for that attribute eﬃciently, without scanning through all the tuples of the relation. For example, if we create an index on attribute <i>dept name </i>of relation <i>instructor</i>, the database system can ﬁnd the record with any speciﬁed <i>dept name </i>value, such as “Physics”, or “Music”, di- rectly, without reading all the tuples of the <i>instructor </i>relation. An index can also be created on a list of attributes, for example, on attributes <i>name </i>and <i>dept name </i>of <i>instruc- tor</i>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Indices are not required for correctness, since they are redundant data structures. Indices form part of the physical schema of the database, as opposed to its logical schema.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">However, indices are important for eﬃcient processing of transactions, including both update transactions and queries. Indices are also important for eﬃcient enforce- ment of integrity constraints such as primary-key and foreign-key constraints. In prin- ciple, a database system can decide automatically what indices to create. However, be- cause of the space cost of indices, as well as the eﬀect of indices on update processing, it is not easy to automatically make the right choices about what indices to maintain.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Therefore, most <span class="s44">SQL </span>implementations provide the programmer with control over the creation and removal of indices via data-deﬁnition-language commands. We illus- trate the syntax of these commands next. Although the syntax that we show is widely used and supported by many database systems, it is not part of the <span class="s44">SQL </span>standard. The <span class="s44">SQL </span>standard does not support control of the physical database schema; it restricts itself to the logical database schema.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">We create an index with the <b>create index </b>command, which takes the form:</p><p class="s83" style="padding-top: 10pt;padding-left: 128pt;text-indent: 0pt;text-align: justify;"><span class="s46">create index </span>&lt;<span class="p">index-name</span>&gt; <span class="s46">on </span>&lt;<span class="p">relation-name</span>&gt; <span class="p">(</span>&lt;<span class="p">attribute-list</span>&gt;<span class="p">);</span></p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <i>attribute-list </i>is the list of attributes of the relations that form the search key for the index.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_828.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_829.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To deﬁne an index named <i>dept index </i>on the <i>instructor </i>relation with <i>dept name </i>as the search key, we write:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_830.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_831.png"/></span></p><p class="s13" style="padding-left: 59pt;text-indent: 0pt;text-align: center;"><b>create index </b>dept index <b>on </b>instructor <span class="p">(</span>dept name<span class="p">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 87pt;text-indent: 0pt;text-align: right;">When a user submits an <span class="s44">SQL </span>query that can beneﬁt from using an index, the <span class="s44">SQL</span></p><p style="padding-left: 87pt;text-indent: 0pt;text-align: right;">query processor automatically uses the index. For example, given an <span class="s44">SQL </span>query that</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_832.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_833.png"/></span></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><a name="bookmark64">selects the </a><i>instructor </i>tuple with <i>dept name </i>“Music”, the <span class="s44">SQL </span>query processor would use the index <i>dept index </i>deﬁned above to ﬁnd the required tuple without reading the whole relation.<a name="bookmark105">&zwnj;</a></p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">If we wish to declare that the search key is a candidate key, we add the attribute</p><p class="s46" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">unique <span class="p">to the index deﬁnition. Thus, the command:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_834.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_835.png"/></span></p><p class="s13" style="padding-left: 184pt;text-indent: 0pt;text-align: left;"><b>create unique index </b>dept index <b>on </b>instructor <span class="p">(</span>dept name<span class="p">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_836.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_837.png"/></span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">declares <i>dept name </i>to be a candidate key for <i>instructor </i>(which is probably not what we actually would want for our university database). If, at the time we enter the <b>create unique index </b>command, <i>dept name </i>is not a candidate key, the system will display an error message, and the attempt to create the index will fail. If the index-creation attempt succeeds, any subsequent attempt to insert a tuple that violates the key declaration will fail. Note that the <b>unique </b>feature is redundant if the database system supports the <b>unique </b>declaration of the <span class="s44">SQL </span>standard.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The index name we speciﬁed for an index is required to drop an index. The <b>drop index </b>command takes the form:</p><p class="s83" style="padding-top: 10pt;padding-left: 247pt;text-indent: 0pt;text-align: justify;"><span class="s46">drop index </span>&lt;<span class="p">index-name</span>&gt;<span class="p">;</span></p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Many database systems also provide a way to specify the type of index to be used, such as B<span class="s181">+</span>-tree or hash indices, which we study in Chapter 14. Some database systems also permit one of the indices on a relation to be declared to be clustered; the system then stores the relation sorted by the search key of the clustered index. We study in Chapter 14 how indices are actually implemented, as well as what indices are automat- ically created by databases, and how to decide on what additional indices to create.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part107.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part109.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
