<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2.4 Persistence</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part23.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part25.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 8pt;padding-left: 16pt;text-indent: 0pt;text-align: left;">2.4 Persistence</p><p style="padding-top: 2pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">Figure 2.6: <b>A Program That Does I/O</b></p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The third major theme of the course is <b>persistence</b>. In system memory, data can be easily lost, as devices such as DRAM store values in a <b>volatile </b>manner; when power goes away or the system crashes, any data in mem- ory is lost. Thus, we need hardware and software to be able to store data <b>persistently</b>; such storage is thus critical to any system as users care a great deal about their data.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The hardware comes in the form of some kind of <b>input/output </b>or <b>I/O </b>device; in modern systems, a <b>hard drive </b>is a common repository for long- lived information, although <b>solid-state drives </b>(<b>SSDs</b>) are making head- way in this arena as well.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The software in the operating system that usually manages the disk is called the <b>file system</b>; it is thus responsible for storing any <b>files </b>the user creates in a reliable and efficient manner on the disks of the system.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 92%;text-align: justify;">Unlike the abstractions provided by the OS for the CPU and memory, the OS does not create a private, virtualized disk for each application. Rather, it is assumed that often times, users will want to <b>share </b>informa- tion that is in files. For example, when writing a C program, you might first use an editor (e.g., Emacs<span class="s35">7</span>) to create and edit the C file (<span class="s41">emacs -nw</span></p><p class="s41" style="padding-left: 38pt;text-indent: 0pt;line-height: 88%;text-align: right;">main.c<span class="p">). Once done, you might use the compiler to turn the source code into an executable (e.g., </span>gcc -o main main.c<span class="p">). When you’re finished, you might run the new executable (e.g., </span>./main<span class="p">). Thus, you can see how files are shared across different processes. First, Emacs creates a file that serves as input to the compiler; the compiler uses that input file to create a new executable file (in many steps – take a compiler course for details); finally, the new executable is then run. And thus a new program is born!</span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To understand this better, let’s look at some code. Figure <span style=" color: #00AEEF;">2.6 </span>presents code to create a file (<span class="s41">/tmp/file</span>) that contains the string “hello world”.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_017.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 92%;text-align: justify;">7<span class="s12">You should be using Emacs. If you are using vi, there is probably something wrong with you. If you are using something that is not a real code editor, that is even worse.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX OF THE </span>P<span class="s7">ROBLEM</span>:</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: center;">H<span class="s7">OW </span>T<span class="s7">O </span>S<span class="s7">TORE </span>D<span class="s7">ATA </span>P<span class="s7">ERSISTENTLY</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The file system is the part of the OS in charge of managing persistent data. What techniques are needed to do so correctly? What mechanisms and policies are required to do so with high performance? How is reliability achieved, in the face of failures in hardware and software?</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To accomplish this task, the program makes three calls into the oper- ating system. The first, a call to <span class="s41">open()</span>, opens the file and creates it; the second, <span class="s41">write()</span>, writes some data to the file; the third, <span class="s41">close()</span>, sim- ply closes the file thus indicating the program won’t be writing any more data to it. These <b>system calls </b>are routed to the part of the operating sys- tem called the <b>file system</b>, which then handles the requests and returns some kind of error code to the user.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">You might be wondering what the OS does in order to actually write to disk. We would show you but you’d have to promise to close your eyes first; it is that unpleasant. The file system has to do a fair bit of work: first figuring out where on disk this new data will reside, and then keep- ing track of it in various structures the file system maintains. Doing so requires issuing I/O requests to the underlying storage device, to either read existing structures or update (write) them. As anyone who has writ-</p><p style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">ten a <b>device driver</b><span class="s35">8</span> knows, getting a device to do something on your behalf is an intricate and detailed process. It requires a deep knowledge of the low-level device interface and its exact semantics. Fortunately, the OS provides a standard and simple way to access devices through its sys- tem calls. Thus, the OS is sometimes seen as a <b>standard library</b>.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Of course, there are many more details in how devices are accessed, and how file systems manage data persistently atop said devices. For performance reasons, most file systems first delay such writes for a while, hoping to batch them into larger groups. To handle the problems of sys- tem crashes during writes, most file systems incorporate some kind of intricate write protocol, such as <b>journaling </b>or <b>copy-on-write</b>, carefully ordering writes to disk to ensure that if a failure occurs during the write sequence, the system can recover to reasonable state afterwards. To make different common operations efficient, file systems employ many differ- ent data structures and access methods, from simple lists to complex b- trees. If all of this doesn’t make sense yet, good! We’ll be talking about all of this quite a bit more in the third part of this book on <b>persistence</b>, where we’ll discuss devices and I/O in general, and then disks, RAIDs, and file systems in great detail.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_018.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: left;">8<span class="s12">A device driver is some code in the operating system that knows how to deal with a specific device. We will talk more about devices and device drivers later.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part23.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part25.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
