<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>17.1 Assumptions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part162.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part164.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">17.1 Assumptions</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 94%;text-align: justify;">Most of this discussion will focus on the great history of allocators found in user-level memory-allocation libraries. We draw on Wilson’s excellent survey [W+95] but encourage interested readers to go to the source document itself for more details<span class="s35">1</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_159.png"/></span></p><p class="s41" style="padding-left: 68pt;text-indent: 12pt;line-height: 86%;text-align: justify;"><span class="p">We assume a basic interface such as that provided by </span>malloc() <span class="p">and </span>free()<span class="p">. Specifically, </span>void <span class="s86">*</span>malloc(size t size) <span class="p">takes a single pa- rameter, </span>size<span class="p">, which is the number of bytes requested by the applica- tion; it hands back a pointer (of no particular type, or a </span><span class="s27">void pointer </span><span class="p">in C lingo) to a region of that size (or greater). The complementary routine </span>void free(void <span class="s86">*</span>ptr) <span class="p">takes a pointer and frees the corresponding chunk. Note the implication of the interface: the user, when freeing the space, does not inform the library of its size; thus, the library must be able to figure out how big a chunk of memory is when handed just a pointer to it. We’ll discuss how to do this a bit later on in the chapter.</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The space that this library manages is known historically as the <span class="s41">heap</span>, and the generic data structure used to manage free space in the heap is some kind of <b>free list</b>. This structure contains references to all of the free chunks of space in the managed region of memory. Of course, this data structure need not be a list <i>per se</i>, but just some kind of data structure to track free space.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We further assume that primarily we are concerned with <b>external frag- mentation</b>, as described above. Allocators could of course also have the problem of <b>internal fragmentation</b>; if an allocator hands out chunks of memory bigger than that requested, any unasked for (and thus unused) space in such a chunk is considered <i>internal </i>fragmentation (because the waste occurs inside the allocated unit) and is another example of space waste. However, for the sake of simplicity, and because it is the more in- teresting of the two types of fragmentation, we’ll mostly focus on external fragmentation.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We’ll also assume that once memory is handed out to a client, it cannot be relocated to another location in memory. For example, if a program calls <span class="s41">malloc() </span>and is given a pointer to some space within the heap, that memory region is essentially “owned” by the program (and cannot be moved by the library) until the program returns it via a correspond- ing call to <span class="s41">free()</span>. Thus, no <b>compaction </b>of free space is possible, which</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_160.png"/></span></p><p class="s11" style="padding-top: 1pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">1<span class="s12">It is nearly 80 pages long; thus, you really have to be interested!</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">would be useful to combat fragmentation<span class="s35">2</span>. Compaction could, however, be used in the OS to deal with fragmentation when implementing <b>seg- mentation</b>; see the chapter on segmentation for details.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Finally, we’ll assume that the allocator manages a contiguous region of bytes. In some cases, an allocator could ask for that region to grow; for example, a user-level memory-allocation library might call into the kernel to grow the heap (via a system call such as <span class="s41">sbrk</span>) when it runs out of space. However, for simplicity, we’ll just assume that the region is a single fixed size throughout its life.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part162.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part164.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
