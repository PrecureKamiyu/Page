<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Appendix F. Solutions to Selected Exercises</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ape.html" title="Appendix E. Further Sources of Information"/><link rel="next" href="bi01.html" title="Bibliography"/></head><body><section class="appendix" title="Appendix F. Solutions to Selected Exercises" epub:type="appendix" id="solutions_to_selected_exercises"><div class="titlepage"><div><div><h2 class="title">Appendix F. Solutions to Selected Exercises</h2></div></div></div><div class="sect1" title="Chapter 5"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_5-id2">
                        <a class="xref" href="ch05.html" title="Chapter 5. File I/O: Further Details">Chapter 5</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">fileio/atomic_append.c</code> in the source code
                                distribution for this book. Here is an example of the results that
                                we see when we run this program as suggested:<a id="IDX-APP-F-8939" class="indexterm"/></p><a id="I_programlisting_d1e178359"/><pre class="programlisting">$ <strong class="userinput"><code>ls -l f1 f2</code></strong>
-rw-------    1 mtk      users     2000000 Jan  9 11:14 f1
-rw-------    1 mtk      users     1999962 Jan  9 11:14 f2</pre><p>Because the combination of <span class="emphasis"><em>lseek()</em></span> plus
                                    <span class="emphasis"><em>write()</em></span> is not atomic, one instance of the
                                program sometimes overwrote bytes written by the other instance. As
                                a result, the file <code class="literal">f2</code> contains
                                less than 2 million bytes.</p></li><li class="listitem"><p>A call to <span class="emphasis"><em>dup()</em></span> can be rewritten
                                    as:<a id="IDX-APP-F-8940" class="indexterm"/></p><a id="I_programlisting_d1e178385"/><pre class="programlisting">fd = fcntl(oldfd, F_DUPFD, 0);</pre><p>A call to <span class="emphasis"><em>dup2()</em></span> can be rewritten
                                    as:<a id="IDX-APP-F-8941" class="indexterm"/></p><a id="I_programlisting_d1e178396"/><pre class="programlisting">if (oldfd == newfd) {                /* oldfd == newfd is a special case */
    if (fcntl(oldfd, F_GETFL) == -1) {                /* Is oldfd valid? */
        errno = EBADF;
        fd = -1;
    } else {
        fd = oldfd;
    }
} else {
    close(newfd);
    fd = fcntl(oldfd, F_DUPFD, newfd);
}</pre></li><li class="listitem"><p>The first point to realize is that, since <span class="emphasis"><em>fd2</em></span>
                                is a duplicate of <span class="emphasis"><em>fd1</em></span>, they both share a single
                                open file description, and thus a single file offset. However,
                                because <span class="emphasis"><em>fd3</em></span> is created via a separate call to
                                    <span class="emphasis"><em>open()</em></span>, it has a separate file
                                offset.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>After the first <span class="emphasis"><em>write()</em></span>, the file
                                        contents are <code class="literal">Hello</code>,.</p></li><li class="listitem"><p>Since <span class="emphasis"><em>fd2</em></span> shares a file offset with
                                            <span class="emphasis"><em>fd1</em></span>, the second
                                            <span class="emphasis"><em>write()</em></span> call appends to the
                                        existing text, yielding <code class="literal">Hello,
                                            world</code>.</p></li><li class="listitem"><p>The <span class="emphasis"><em>lseek()</em></span> call adjusts the single
                                        file offset shared by <span class="emphasis"><em>fd1</em></span> and
                                            <span class="emphasis"><em>fd2</em></span> to point to the start of the
                                        file, and thus the third <span class="emphasis"><em>write()</em></span> call
                                        overwrites part of the existing text to yield <code class="literal">HELLO, world</code>.</p></li><li class="listitem"><p>The file offset for <span class="emphasis"><em>fd3</em></span> has not so
                                        far been modified, and so points to the start of the file.
                                        Therefore, the final <span class="emphasis"><em>write()</em></span> call
                                        changes the file contents to <code class="literal">Gidday
                                            world</code>.</p></li></ul></div><p>Run the program <code class="literal">fileio/multi_descriptors.c</code> in the source code
                                distribution for this book to see these results.</p></li></ol></div></div><div class="sect1" title="Chapter 6"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_6">
                        <a class="xref" href="ch06.html" title="Chapter 6. Processes">Chapter 6</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Since the array <span class="emphasis"><em>mbuf</em></span> is not initialized, it
                                is part of the uninitialized data segment. Therefore, no disk space
                                is required to hold this variable. Instead, it is allocated (and
                                initialized to 0) when the program is loaded.<a id="IDX-APP-F-8942" class="indexterm"/><a id="IDX-APP-F-8943" class="indexterm"/><a id="IDX-APP-F-8944" class="indexterm"/><a id="IDX-APP-F-8945" class="indexterm"/></p></li><li class="listitem"><p>A demonstration of the incorrect usage of
                                    <span class="emphasis"><em>longjmp()</em></span> is provided in the file <code class="literal">proc/bad_longjmp.c</code> in the source code
                                distribution for this book.</p></li><li class="listitem"><p>Sample implementations of <span class="emphasis"><em>setenv()</em></span> and
                                    <span class="emphasis"><em>unsetenv()</em></span> are provided in the file
                                    <code class="literal">proc/setenv.c</code> in the source
                                code distribution for this book.<a id="IDX-APP-F-8946" class="indexterm"/><a id="IDX-APP-F-8947" class="indexterm"/></p></li></ol></div></div><div class="sect1" title="Chapter 8"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_8">
                        <a class="xref" href="ch08.html" title="Chapter 8. Users and Groups">Chapter 8</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The two <span class="emphasis"><em>getpwnam()</em></span> calls are executed before
                                the <span class="emphasis"><em>printf()</em></span> output string is constructed,
                                and—since <span class="emphasis"><em>getpwnam()</em></span> returns its result in a
                                statically allocated buffer—the second call overwrites the result
                                returned by the first call.</p></li></ol></div></div><div class="sect1" title="Chapter 9"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_9">
                        <a class="xref" href="ch09.html" title="Chapter 9. Process Credentials">Chapter 9</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In considering the following, remember that changes to the
                                effective user ID always also change the file-system user ID.</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                                        <span class="emphasis"><em>real=2000, effective=2000, saved=2000,
                                            file-system=2000</em></span>
                                    </p></li><li class="listitem"><p>
                                        <span class="emphasis"><em>real=1000, effective=2000, saved=2000,
                                            file-system=2000</em></span>
                                    </p></li><li class="listitem"><p>
                                        <span class="emphasis"><em>real=1000, effective=2000, saved=0,
                                            file-system=2000</em></span>
                                    </p></li><li class="listitem"><p>
                                        <span class="emphasis"><em>real=1000, effective=0, saved=0,
                                            file-system=2000</em></span>
                                    </p></li><li class="listitem"><p>
                                        <span class="emphasis"><em>real=1000, effective=2000, saved=3000,
                                            file-system=2000</em></span>
                                    </p></li></ol></div></li><li class="listitem"><p>Strictly speaking, such a process is unprivileged, since its
                                effective user ID is nonzero. However, an unprivileged process can
                                use the <span class="emphasis"><em>setuid()</em></span>,
                                    <span class="emphasis"><em>setreuid()</em></span>, <span class="emphasis"><em>seteuid()</em></span>,
                                or <span class="emphasis"><em>setresuid()</em></span> calls to set its effective user
                                ID to the same value as its real user ID or saved set-user-ID. Thus,
                                this process could use one of these calls to regain
                                privilege.</p></li><li class="listitem"><p>The following code shows the steps for each system call.</p><a id="I_programlisting_d1e178590"/><pre class="programlisting">e = geteuid();     /* Save initial value of effective user ID */

setuid(getuid());                         /* Suspend privileges */
setuid(e);                                /* Resume privileges */
/* Can't permanently drop the set-user-ID identity with setuid() */

seteuid(getuid());                        /* Suspend privileges */
seteuid(e);                               /* Resume privileges */
/* Can't permanently drop the set-user-ID identity with seteuid() */

setreuid(-1, getuid());                   /* Temporarily drop privileges */
setreuid(-1, e);                          /* Resume privileges */
setreuid(getuid(), getuid());             /* Permanently drop privileges */

setresuid(-1, getuid(), -1);              /* Temporarily drop privileges */
setresuid(-1, e, -1);                     /* Resume privileges */
setresuid(getuid(), getuid(), getuid());  /* Permanently drop privileges */</pre></li><li class="listitem"><p>With the exception of <span class="emphasis"><em>setuid()</em></span>, the answers
                                are the same as for the previous exercise, except that we can
                                substitute the value 0 for the variable <span class="emphasis"><em>e</em></span>. For
                                    <span class="emphasis"><em>setuid()</em></span>, the following holds:</p><a id="I_programlisting_d1e178604"/><pre class="programlisting">/* (a) Can't suspend and resume privileges with setuid() */

setuid(getuid());          /* (b) Permanently drop privileges */</pre></li></ol></div></div><div class="sect1" title="Chapter 10"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_10">
                        <a class="xref" href="ch10.html" title="Chapter 10. Time">Chapter 10</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The maximum unsigned 32-bit integer value is 4,294,967,295.
                                Divided by 100 clock ticks per second, this corresponds to slightly
                                more than 497 days. Divided by 1 million (<code class="literal">CLOCKS_PER_SEC</code>), this corresponds to 71 minutes and
                                35 seconds.</p></li></ol></div></div><div class="sect1" title="Chapter 12"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_12">
                        <a class="xref" href="ch12.html" title="Chapter 12. System and Process Information">Chapter 12</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">sysinfo/procfs_user_exe.c</code> in the source code
                                distribution for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 13"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_13">
                        <a class="xref" href="ch13.html" title="Chapter 13. File I/O Buffering">Chapter 13</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>This sequence of statements ensures that the data written to a
                                    <span class="emphasis"><em>stdio</em></span> buffer is flushed to the disk. The
                                    <span class="emphasis"><em>fflush()</em></span> call flushes the
                                    <span class="emphasis"><em>stdio</em></span> buffer for <span class="emphasis"><em>fp</em></span> to
                                the kernel buffer cache. The argument given to the subsequent
                                    <span class="emphasis"><em>fsync()</em></span> is the file descriptor underlying
                                    <span class="emphasis"><em>fp</em></span>; thus, the call flushes the (recently
                                filled) kernel buffer for that file descriptor to disk.<a id="IDX-APP-F-8948" class="indexterm"/><a id="IDX-APP-F-8949" class="indexterm"/><a id="IDX-APP-F-8950" class="indexterm"/></p></li><li class="listitem"><p>When standard output is sent to a terminal, it is line-buffered,
                                so that the output of the <span class="emphasis"><em>printf()</em></span> call appears
                                immediately, and is followed by the output of
                                    <span class="emphasis"><em>write()</em></span>. When standard output is sent to a
                                disk file, it is block-buffered. Consequently, the output of the
                                    <span class="emphasis"><em>printf()</em></span> is held in a
                                    <span class="emphasis"><em>stdio</em></span> buffer and is flushed only when the
                                program exits (i.e., after the <span class="emphasis"><em>write()</em></span> call).
                                (A complete program containing the code of this exercise is
                                available in the file <code class="literal">filebuff/mix23_linebuff.c</code> in the source code
                                distribution for this book.)</p></li></ol></div></div><div class="sect1" title="Chapter 15"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_15">
                        <a class="xref" href="ch15.html" title="Chapter 15. File Attributes">Chapter 15</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <span class="emphasis"><em>stat()</em></span> system call doesn’t change any
                                file timestamps, since all it does is fetch information from the
                                file i-node (and there is no <span class="emphasis"><em>last i-node access</em></span>
                                    timestamp).<a id="IDX-APP-F-8951" class="indexterm"/></p></li><li class="listitem"><p>The GNU C library provides just such a function, named
                                    <span class="emphasis"><em>euidaccess()</em></span>, in the library source file
                                    <code class="literal">sysdeps/posix/euidaccess.c</code>.</p></li><li class="listitem"><p>In order to do this, we must use two calls to
                                    <span class="emphasis"><em>umask()</em></span>, as follows:</p><a id="I_programlisting_d1e178718"/><pre class="programlisting">mode_t currUmask;

currUmask = umask(0);       /* Retrieve current umask, set umask to 0 */
umask(currUmask);           /* Restore umask to previous value */</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Note, however, that this solution is not thread-safe, since
                                    threads share the process umask setting.</p></div></li><li class="listitem"><p>A solution is provided in the file <code class="literal">files/chiflag.c</code> in the source code distribution for
                                this book.</p></li></ol></div></div><div class="sect1" title="Chapter 18"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_18">
                        <a class="xref" href="ch18.html" title="Chapter 18. Directories and Links">Chapter 18</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Using <span class="emphasis"><em>ls -li</em></span> shows that the executable file
                                has different i-node numbers after each compilation. What happens is
                                that the compiler removes (unlinks) any existing file with the same
                                name as its target executable, and then creates a new file with the
                                same name. It is permissible to unlink an executable file. The name
                                is removed immediately, but the file itself remains in existence
                                until the process executing it terminates.</p></li><li class="listitem"><p>The file <code class="literal">myfile</code> is created in
                                the subdirectory <code class="literal">test</code>. The
                                    <span class="emphasis"><em>symlink()</em></span> call creates a relative link in
                                the parent directory. Despite appearances, this is a dangling link,
                                since it is interpreted relative to the location of the link file,
                                and thus refers to a nonexistent file in the parent directory.
                                Consequently, <span class="emphasis"><em>chmod()</em></span> fails with the error
                                    <code class="literal">ENOENT</code> (“No such file or
                                directory”). (A complete program containing the code of this
                                exercise is available in the file <code class="literal">dirs_links/bad_symlink.c</code> in the source code
                                distribution for this book.)</p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">dirs_links/list_files_readdir_r.c</code>, which can be found
                                in the source code distribution for this book.</p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">dirs_links/file_type_stats.c</code>, which can be found in
                                the source code distribution for this book.</p></li><li class="listitem"><p>Using <span class="emphasis"><em>fchdir()</em></span> is more efficient. If we are
                                performing the operation repeatedly within a loop, then with
                                    <span class="emphasis"><em>fchdir()</em></span> we can perform one call to
                                    <span class="emphasis"><em>open()</em></span> before executing the loop, and with
                                    <span class="emphasis"><em>chdir()</em></span> we can place the
                                    <span class="emphasis"><em>getcwd()</em></span> call outside the loop. Then we are
                                measuring the difference between repeated calls to
                                    <span class="emphasis"><em>fchdir(fd)</em></span> and
                                    <span class="emphasis"><em>chdir(buf)</em></span>. Calls to
                                    <span class="emphasis"><em>chdir()</em></span> are more expensive for two reasons:
                                passing the <span class="emphasis"><em>buf</em></span> argument to the kernel requires
                                a larger data transfer between user space and kernel space, and the
                                pathname in <span class="emphasis"><em>buf</em></span> must be resolved to the
                                corresponding directory i-node on each call. (Kernel caching of
                                directory entry information reduces the work required for the second
                                point, but some work must still be done.)</p></li></ol></div></div><div class="sect1" title="Chapter 20"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_20">
                        <a class="xref" href="ch20.html" title="Chapter 20. Signals: Fundamental Concepts">Chapter 20</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">signals/ignore_pending_sig.c</code> in the source code
                                distribution for this book.<a id="IDX-APP-F-8952" class="indexterm"/><a id="IDX-APP-F-8953" class="indexterm"/><a id="IDX-APP-F-8954" class="indexterm"/><a id="IDX-APP-F-8955" class="indexterm"/><a id="IDX-APP-F-8956" class="indexterm"/><a id="IDX-APP-F-8957" class="indexterm"/><a id="IDX-APP-F-8958" class="indexterm"/><a id="IDX-APP-F-8959" class="indexterm"/></p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">signals/siginterrupt.c</code> in the source code
                                distribution for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 22"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_22">
                        <a class="xref" href="ch22.html" title="Chapter 22. Signals: Advanced Features">Chapter 22</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>As with most UNIX implementations, Linux delivers standard signals
                                before realtime signals (SUSv3 doesn’t require this). This makes
                                sense, because some standard signals indicate critical conditions
                                (e.g., hardware exceptions) that a program should deal with as soon
                                as possible.</p></li><li class="listitem"><p>Replacing <span class="emphasis"><em>sigsuspend()</em></span> plus a signal handler
                                with <span class="emphasis"><em>sigwaitinfo()</em></span> in this program provides a
                                25 to 40 percent speed improvement. (The exact figure varies
                                somewhat across kernel versions.)</p></li></ol></div></div><div class="sect1" title="Chapter 23"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_23">
                        <a class="xref" href="ch23.html" title="Chapter 23. Timers and Sleeping">Chapter 23</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A modified program using <span class="emphasis"><em>clock_nanosleep()</em></span> is
                                provided in the file <code class="literal">timers/t_clock_nanosleep.c</code> in the source code
                                distribution for this book.</p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">timers/ptmr_null_evp.c</code> in the source code
                                distribution for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 24"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_24">
                        <a class="xref" href="ch24.html" title="Chapter 24. Process Creation">Chapter 24</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The first <span class="emphasis"><em>fork()</em></span> call creates one new child.
                                Both parent and child carry on to execute the second
                                    <span class="emphasis"><em>fork()</em></span>, and thus each creates a further
                                process, making a total of four processes. All four processes carry
                                on to execute the next <span class="emphasis"><em>fork()</em></span>, each creating a
                                further child. Consequently, a total of seven new processes are
                                    created.<a id="IDX-APP-F-8960" class="indexterm"/></p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">procexec/vfork_fd_test.c</code> in the source code
                                distribution for this book.</p></li><li class="listitem"><p>If we call <span class="emphasis"><em>fork()</em></span>, and then have the child
                                call <span class="emphasis"><em>raise()</em></span> to send itself a signal such as
                                    <code class="literal">SIGABRT</code>, this will yield a
                                core dump file that closely mirrors the state of the parent at the
                                time of the <span class="emphasis"><em>fork()</em></span>. The <span class="emphasis"><em>gdb
                                    gcore</em></span> command allows us to perform a similar task for
                                a program, without needing to change the source code.</p></li><li class="listitem"><p>Add a converse <span class="emphasis"><em>kill()</em></span> call in the
                                parent:</p><a id="I_programlisting_d1e178942"/><pre class="programlisting">if (kill(childPid, SIGUSR1) == -1)
    errExit("kill")</pre><p>And in the child, add a converse <span class="emphasis"><em>sigsuspend()</em></span>
                                call:</p><a id="I_programlisting_d1e178949"/><pre class="programlisting">sigsuspend(&amp;origMask);          /* Unblock SIGUSR1, wait for signal */</pre></li></ol></div></div><div class="sect1" title="Chapter 25"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_25">
                        <a class="xref" href="ch25.html" title="Chapter 25. Process Termination">Chapter 25</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Assuming a two’s complement architecture, where -1 is represented
                                by a bit pattern with all bits on, then the parent will see an exit
                                status of 255 (all bits on in the least significant 8 bits, which
                                are all that is passed back to the parent when it calls
                                    <span class="emphasis"><em>wait())</em></span>. (The presence of the call
                                    <span class="emphasis"><em>exit(-1)</em></span> in a program is usually a
                                programmer error resulting from confusion with the -1 return used to
                                indicate failure of a system call.)<a id="IDX-APP-F-8961" class="indexterm"/><a id="IDX-APP-F-8962" class="indexterm"/><a id="IDX-APP-F-8963" class="indexterm"/><a id="IDX-APP-F-8964" class="indexterm"/><a id="IDX-APP-F-8965" class="indexterm"/></p></li></ol></div></div><div class="sect1" title="Chapter 26"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_26">
                        <a class="xref" href="ch26.html" title="Chapter 26. Monitoring Child Processes">Chapter 26</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">procexec/orphan.c</code> in the source code distribution for
                                this book.</p></li></ol></div></div><div class="sect1" title="Chapter 27"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_27">
                        <a class="xref" href="ch27.html" title="Chapter 27. Program Execution">Chapter 27</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <span class="emphasis"><em>execvp()</em></span> function first fails to exec the
                                file <code class="literal">xyz</code> in <code class="literal">dir1</code>, because execute permission is
                                denied. It therefore continues its search in <code class="literal">dir2</code>, where it successfully execs
                                    <code class="literal">xyz</code>.<a id="IDX-APP-F-8966" class="indexterm"/></p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">procexec/execlp.c</code> in the source code distribution of
                                this book.</p></li><li class="listitem"><p>The script specifies the <span class="emphasis"><em>cat</em></span> program as its
                                interpreter. The <span class="emphasis"><em>cat</em></span> program “interprets” a
                                file by printing its contents—in this case with the
                                    <span class="emphasis"><em>-n</em></span> (line numbering) option enabled (as
                                though we had entered the command <span class="emphasis"><em>cat -n
                                    ourscript</em></span>). Thus, we would see the following:</p><a id="I_programlisting_d1e179047"/><pre class="programlisting">1  #!/bin/cat -n
     2  Hello world</pre></li><li class="listitem"><p>Two successive <span class="emphasis"><em>fork()</em></span> calls yield a total of
                                three processes related as parent, child, and grandchild. Having
                                created the grandchild process, the child immediately exits, and is
                                reaped by the <span class="emphasis"><em>waitpid()</em></span> call in the parent. As
                                a consequence of being orphaned, the grandchild is adopted by
                                    <span class="emphasis"><em>init</em></span> (process ID of 1). The program doesn’t
                                need to perform a second <span class="emphasis"><em>wait()</em></span> call, since
                                    <span class="emphasis"><em>init</em></span> automatically reaps the zombie when
                                the grandchild terminates. Therein lies a possible use for this code
                                sequence: if we need to create a child for which we can’t later
                                wait, then this sequence can be used to ensure that no zombie
                                results. One example of such a requirement is where the parent execs
                                some program that is not guaranteed to perform a wait (and we don’t
                                want to rely on setting the disposition of <code class="literal">SIGCHLD</code> to <code class="literal">SIG_IGN</code>, since the disposition of an ignored <code class="literal">SIGCHLD</code> after an
                                    <span class="emphasis"><em>exec()</em></span> is left unspecified by
                                SUSv3).</p></li><li class="listitem"><p>The string given to <span class="emphasis"><em>printf()</em></span> doesn’t include
                                a newline character, and therefore the output is not flushed before
                                the <span class="emphasis"><em>execlp()</em></span> call. The
                                    <span class="emphasis"><em>execlp()</em></span> overwrites the existing program’s
                                data segments (as well as the heap and stack), which contain the
                                    <span class="emphasis"><em>stdio</em></span> buffers, and thus the unflushed
                                output is lost.</p></li><li class="listitem"><p><code class="literal">SIGCHLD</code> is delivered to the
                                parent. If the <code class="literal">SIGCHLD</code> handler
                                attempts to do a <span class="emphasis"><em>wait()</em></span>, then the call returns
                                an error (<code class="literal">ECHILD</code>) indicating that
                                there were no children whose status could be returned. (This assumes
                                that the parent had no other terminated children. If it did, then
                                the <span class="emphasis"><em>wait()</em></span> would block; or if
                                    <span class="emphasis"><em>waitpid()</em></span> was used with the <code class="literal">WNOHANG</code> flag,
                                    <span class="emphasis"><em>waitpid()</em></span> would return 0.) This is exactly
                                the situation that may arise if a program establishes a handler for
                                    <code class="literal">SIGCHLD</code> before calling
                                    <span class="emphasis"><em>system()</em></span>.</p></li></ol></div></div><div class="sect1" title="Chapter 29"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_29">
                        <a class="xref" href="ch29.html" title="Chapter 29. Threads: Introduction">Chapter 29</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>There are two possible outcomes (both permitted by SUSv3): the
                                thread deadlocks, blocked while trying to join with itself, or the
                                    <span class="emphasis"><em>pthread_join()</em></span> call fails, returning the
                                error <code class="literal">EDEADLK</code>. On Linux, the
                                latter behavior occurs. Given a thread ID in
                                    <span class="emphasis"><em>tid</em></span>, we can prevent such an eventuality
                                using the following code:<a id="IDX-APP-F-8967" class="indexterm"/><a id="IDX-APP-F-8968" class="indexterm"/><a id="IDX-APP-F-8969" class="indexterm"/><a id="IDX-APP-F-8970" class="indexterm"/><a id="IDX-APP-F-8971" class="indexterm"/></p><a id="I_programlisting_d1e179165"/><pre class="programlisting">if (!pthread_equal(tid, pthread_self()))
   pthread_join(tid, NULL);</pre></li><li class="listitem"><p>After the main thread terminates,
                                    <span class="emphasis"><em>threadFunc()</em></span> will continue working with
                                storage on the main thread’s stack, with unpredictable
                                results.</p></li></ol></div></div><div class="sect1" title="Chapter 31"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_31">
                        <a class="xref" href="ch31.html" title="Chapter 31. Threads: Thread Safety and Per-Thread Storage">Chapter 31</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">threads/one_time_init.c</code> in the source code
                                distribution for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 33"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_33">
                        <a class="xref" href="ch33.html" title="Chapter 33. Threads: Further Details">Chapter 33</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <code class="literal">SIGCHLD</code> signal that is
                                generated on child termination is process-directed. It may be
                                delivered to any thread (not necessarily the one that called
                                    <span class="emphasis"><em>fork()</em></span>) that is not blocking the
                                    signal.<a id="IDX-APP-F-8972" class="indexterm"/></p></li></ol></div></div><div class="sect1" title="Chapter 34"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_34">
                        <a class="xref" href="ch34.html" title="Chapter 34. Process Groups, Sessions, and Job Control">Chapter 34</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Suppose that the program is part of a shell pipeline:</p><a id="I_programlisting_d1e179208"/><pre class="programlisting">$ <strong class="userinput"><code>./ourprog | grep '</code></strong><strong class="userinput"><code><em class="replaceable"><code>some string</code></em></code></strong><strong class="userinput"><code>'</code></strong></pre><p>The problem is that <span class="emphasis"><em>grep</em></span> will be part of the
                                same process group as <span class="emphasis"><em>ourprog</em></span>, and therefore
                                the <span class="emphasis"><em>killpg()</em></span> call will also terminate the
                                    <span class="emphasis"><em>grep</em></span> process. This is probably not desired,
                                and is likely to confuse users. The solution is to use
                                    <span class="emphasis"><em>setpgid()</em></span> to ensure that the child
                                processes are placed in their own new group (the process ID of the
                                first child could be used as the process group ID of the group), and
                                then signal that process group. This also removes the need for the
                                parent to make itself immune to the signal.</p></li><li class="listitem"><p>If the <code class="literal">SIGTSTP</code> signal is
                                unblocked before raising it again, then there is a small window of
                                time (between the calls to <span class="emphasis"><em>sigprocmask()</em></span> and
                                    <span class="emphasis"><em>raise()</em></span>) during which, if the user types a
                                second suspend character (<span class="emphasis"><em>Control-Z</em></span>), the
                                process will be stopped while still in the handler. Consequently,
                                two <code class="literal">SIGCONT</code> signals will be
                                required to resume the process.</p></li></ol></div></div><div class="sect1" title="Chapter 35"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_35">
                        <a class="xref" href="ch35.html" title="Chapter 35. Process Priorities and Scheduling">Chapter 35</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">procpri/demo_sched_fifo.c</code> in the source code
                                distribution for this book.<a id="IDX-APP-F-8973" class="indexterm"/><a id="IDX-APP-F-8974" class="indexterm"/><a id="IDX-APP-F-8975" class="indexterm"/><a id="IDX-APP-F-8976" class="indexterm"/><a id="IDX-APP-F-8977" class="indexterm"/></p></li></ol></div></div><div class="sect1" title="Chapter 36"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_36">
                        <a class="xref" href="ch36.html" title="Chapter 36. Process Resources">Chapter 36</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">procres/rusage_wait.c</code> in the source code distribution
                                for this book.</p></li><li class="listitem"><p>A solution is provided in the files <code class="literal">rusage.c</code> and <code class="literal">print_rusage.c</code> in the <code class="literal">procres</code> subdirectory in the source code distribution
                                for this book.<a id="IDX-APP-F-8978" class="indexterm"/><a id="IDX-APP-F-8979" class="indexterm"/></p></li></ol></div></div><div class="sect1" title="Chapter 37"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_37">
                        <a class="xref" href="ch37.html" title="Chapter 37. Daemons">Chapter 37</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">daemons/t_syslog.c</code> in the source code distribution
                                for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 38"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_38">
                        <a class="xref" href="ch38.html" title="Chapter 38. Writing Secure Privileged Programs">Chapter 38</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Whenever a file is modified by an unprivileged user, the kernel
                                clears the file’s set-user-ID permission bit. The set-group-ID
                                permission bit is similarly cleared if the group-execute permission
                                bit is enabled. (As detailed in Section 55.4, the combination of
                                having the set-group-ID bit on while the group-execute bit is
                                    <span class="emphasis"><em>off</em></span> has nothing to do with set-group-ID
                                programs; instead, it is used to enable mandatory locking, and for
                                this reason modifications to such a file don’t disable the
                                set-group-ID bit.) Clearing these bits ensures that if the program
                                file is writable by arbitrary users, then it can’t be modified and
                                still retain its ability to give privileges to users executing the
                                file. A privileged (<code class="literal">CAP_FSETID</code>)
                                process can modify a file without the kernel clearing these
                                permission bits.<a id="IDX-APP-F-8980" class="indexterm"/><a id="IDX-APP-F-8981" class="indexterm"/></p></li></ol></div></div><div class="sect1" title="Chapter 44"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_44">
                        <a class="xref" href="ch44.html" title="Chapter 44. Pipes and FIFOs">Chapter 44</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">pipes/change_case.c</code> in the source code distribution
                                for this book.</p></li><li class="listitem"><p>It creates a race condition. Suppose that between the time the
                                server sees end-of-file and the time it closes the file reading
                                descriptor, a client opens the FIFO for writing (this will succeed
                                without blocking), and then writes data to the FIFO
                                    <span class="emphasis"><em>after</em></span> the server has closed the reading
                                descriptor. At this point, the client will receive a <code class="literal">SIGPIPE</code> signal, since no process has
                                the FIFO open for reading. Alternatively, the client might be able
                                to both open the FIFO and write data to it before the server closes
                                the reading descriptor. In this case, the client’s data would be
                                lost, and it wouldn’t receive a response from the server. As a
                                further exercise, you could try to demonstrate these behaviors by
                                making the suggested modification to the server and creating a
                                special-purpose client that repeatedly opens the server’s FIFOs,
                                sends a message to the server, closes the server’s FIFO, and reads
                                the server’s response (if any).</p></li><li class="listitem"><p>One possible solution would be to set a timer on the
                                    <span class="emphasis"><em>open()</em></span> of the client FIFO using
                                    <span class="emphasis"><em>alarm()</em></span>, as described in Section 23.3. This
                                solution suffers from the drawback that the server would still be
                                delayed for the period of the timeout. Another possible solution
                                would be to open the client FIFO using the <code class="literal">O_NONBLOCK</code> flag. If this fails, then the server can
                                assume a misbehaving client. This latter solution also requires
                                changes to the client, which needs to ensure that it opens its FIFO
                                (also using the <code class="literal">O_NONBLOCK</code> flag)
                                prior to sending a request to the server. For convenience, the
                                client should then turn off the <code class="literal">O_NONBLOCK</code> flag for the FIFO file descriptor, so that
                                the subsequent <span class="emphasis"><em>read()</em></span> call blocks. Finally, it
                                is possible to implement a concurrent server solution for this
                                application, with the main server process creating a child to send
                                the response message to each client. (This would represent a rather
                                resource-expensive solution in the case of this simple
                                application.)</p><p>Other conditions that are not handled by this server remain. For
                                example, it doesn’t handle the possibilities of the sequence number
                                overflowing or a misbehaving client requesting large groups of
                                sequence numbers in order to produce such overflows. The server also
                                does not handle the possibility that the client specifies a negative
                                value for the sequence length. Furthermore, a malicious client could
                                create its reply FIFO, and then open the FIFO for reading and
                                writing, and fill it with data before sending a request to the
                                server; as a consequence, the server would be able to successfully
                                open the reply FIFO, but would block when it tries to write the
                                reply. As a further exercise, you could try to devise strategies for
                                dealing with these possibilities.</p><p>In Section 44.8, we also noted another limitation that applies to
                                the server in <a class="xref" href="ch44.html#an_iterative_server_using_fifos" title="Example 44-7. An iterative server using FIFOs">Example 44-7</a>: if
                                a client sends a message that contains the wrong number of bytes,
                                then the server will be out of step when reading all subsequent
                                client messages. One simple way to deal with this problem is to
                                discard the use of fixed-length messages in favor of the use of a
                                delimiter character.</p></li></ol></div></div><div class="sect1" title="Chapter 45"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_45">
                        <a class="xref" href="ch45.html" title="Chapter 45. Introduction to System V IPC">Chapter 45</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">svipc/t_ftok.c</code> in the source code distribution for
                                this book.<a id="IDX-APP-F-8982" class="indexterm"/></p></li></ol></div></div><div class="sect1" title="Chapter 46"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_46">
                        <a class="xref" href="ch46.html" title="Chapter 46. System V Message Queues">Chapter 46</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The value 0 is a valid message queue identifier, but 0 can’t be
                                used as a message type.</p></li></ol></div></div><div class="sect1" title="Chapter 47"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_47">
                        <a class="xref" href="ch47.html" title="Chapter 47. System V Semaphores">Chapter 47</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">svsem/event_flags.c</code> in the source code distribution
                                for this book.</p></li><li class="listitem"><p>A reserve operation can be implemented by reading a byte from the
                                FIFO. Conversely, a release operation can be implemented by writing
                                a byte to the FIFO. A conditional reserve operation can be
                                implemented as a nonblocking read of a byte from the FIFO.</p></li></ol></div></div><div class="sect1" title="Chapter 48"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_48">
                        <a class="xref" href="ch48.html" title="Chapter 48. System V Shared Memory">Chapter 48</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Since access to the <span class="emphasis"><em>shmp-&gt; cnt</em></span> value
                                in the <code class="literal">for</code> loop increment step is
                                no longer protected by the semaphore, there is a race condition
                                between the writer next updating this value and the reader fetching
                                    it.<a id="IDX-APP-F-8983" class="indexterm"/><a id="IDX-APP-F-8984" class="indexterm"/><a id="IDX-APP-F-8985" class="indexterm"/><a id="IDX-APP-F-8986" class="indexterm"/><a id="IDX-APP-F-8987" class="indexterm"/><a id="IDX-APP-F-8988" class="indexterm"/></p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">svshm/svshm_mon.c</code> in the source code distribution for
                                this book.</p></li></ol></div></div><div class="sect1" title="Chapter 49"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_49">
                        <a class="xref" href="ch49.html" title="Chapter 49. Memory Mappings">Chapter 49</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">mmap/mmcopy.c</code> in the source code distribution for
                                this book.</p></li></ol></div></div><div class="sect1" title="Chapter 50"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_50">
                        <a class="xref" href="ch50.html" title="Chapter 50. Virtual Memory Operations">Chapter 50</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">vmem/madvise_dontneed.c</code> in the source code
                                distribution for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 52"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_52">
                        <a class="xref" href="ch52.html" title="Chapter 52. POSIX Message Queues">Chapter 52</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">pmsg/mq_notify_sigwaitinfo.c</code> in the source code
                                distribution for this book.</p></li><li class="listitem"><p>It would not be safe to make <span class="emphasis"><em>buffer</em></span> global.
                                Once message notification is reenabled in
                                    <span class="emphasis"><em>threadFunc()</em></span>, there is a chance that a
                                second notification would be generated while
                                    <span class="emphasis"><em>threadFunc()</em></span> is still executing. This
                                second notification could initiate a second thread that executes
                                    <span class="emphasis"><em>threadFunc()</em></span> at the same time as the first
                                thread. Both threads would attempt to use the same global
                                    <span class="emphasis"><em>buffer</em></span>, with unpredictable results. Note
                                that the behavior here is implementation-dependent. SUSv3 permits an
                                implementation to sequentially deliver notifications to the same
                                thread. However, it is also permissible to deliver notifications in
                                separate threads that execute concurrently, and this is what Linux
                                does.</p></li></ol></div></div><div class="sect1" title="Chapter 53"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_53">
                        <a class="xref" href="ch53.html" title="Chapter 53. POSIX Semaphores">Chapter 53</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">psem/psem_timedwait.c</code> in the source code distribution
                                for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 55"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_55">
                        <a class="xref" href="ch55.html" title="Chapter 55. File Locking">Chapter 55</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The following hold for <span class="emphasis"><em>flock()</em></span> on
                                    Linux:<a id="IDX-APP-F-8989" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>A series of shared locks can starve a process waiting to
                                        place an exclusive lock.</p></li><li class="listitem"><p>There are no rules regarding which process is granted the
                                        lock. Essentially, the lock is granted to the process that
                                        is next scheduled. If that process happens to be one that
                                        obtains a shared lock, then all other processes requesting
                                        shared locks will also be able to have their requests
                                        granted simultaneously.</p></li></ol></div></li><li class="listitem"><p>The <span class="emphasis"><em>flock()</em></span> system call doesn’t detect
                                deadlock. This is true of most <span class="emphasis"><em>flock()</em></span>
                                implementations, except those that implement
                                    <span class="emphasis"><em>flock()</em></span> in terms of
                                    <span class="emphasis"><em>fcntl()</em></span>.</p></li><li class="listitem"><p>In all except early (1.2 and earlier) Linux kernels, the two types
                                of locking operate independently, and have no affect on one
                                another.</p></li></ol></div></div><div class="sect1" title="Chapter 57"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_57">
                        <a class="xref" href="ch57.html" title="Chapter 57. Sockets: UNIX Domain">Chapter 57</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>On Linux, the <span class="emphasis"><em>sendto()</em></span> call fails with the
                                error <code class="literal">EPERM</code>. On some other UNIX
                                systems, a different error results. Some other UNIX implementations
                                don’t enforce this constraint, letting a connected UNIX domain
                                datagram socket receive datagrams from a sender other than its
                                    peer.<a id="IDX-APP-F-8990" class="indexterm"/><a id="IDX-APP-F-8991" class="indexterm"/><a id="IDX-APP-F-8992" class="indexterm"/></p></li></ol></div></div><div class="sect1" title="Chapter 59"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_59">
                        <a class="xref" href="ch59.html" title="Chapter 59. Sockets: Internet Domains">Chapter 59</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the files <code class="literal">read_line_buf.h</code> and <code class="literal">read_line_buf.c</code> in the <code class="literal">sockets</code> subdirectory in the source code distribution
                                for this book.<a id="IDX-APP-F-8993" class="indexterm"/><a id="IDX-APP-F-8994" class="indexterm"/></p></li><li class="listitem"><p>A solution is provided in the files <code class="literal">is_seqnum_v2_sv.c</code>, <code class="literal">is_seqnum_v2_cl.c</code>, and <code class="literal">is_seqnum_v2.h</code> in the <code class="literal">sockets</code> subdirectory in the source code distribution
                                for this book.<a id="IDX-APP-F-8995" class="indexterm"/><a id="IDX-APP-F-8996" class="indexterm"/><a id="IDX-APP-F-8997" class="indexterm"/></p></li><li class="listitem"><p>A solution is provided in the files <code class="literal">unix_sockets.h</code>, <code class="literal">unix_sockets.c</code>, <code class="literal">us_xfr_v2.h</code>, <code class="literal">us_xfr_v2_sv.c</code>, and <code class="literal">us_xfr_v2_cl.c</code> in the <code class="literal">sockets</code> subdirectory in the source code distribution
                                for this book.<a id="IDX-APP-F-8998" class="indexterm"/><a id="IDX-APP-F-8999" class="indexterm"/><a id="IDX-APP-F-9000" class="indexterm"/><a id="IDX-APP-F-9001" class="indexterm"/></p></li><li class="listitem"><p>In the Internet domain, datagrams from a nonpeer socket are
                                silently discarded.</p></li></ol></div></div><div class="sect1" title="Chapter 60"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_60">
                        <a class="xref" href="ch60.html" title="Chapter 60. Sockets: Server Design">Chapter 60</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">sockets/is_echo_v2_sv.c</code> in the source code
                                distribution for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 61"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_61">
                        <a class="xref" href="ch61.html" title="Chapter 61. Sockets: Advanced Topics">Chapter 61</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Since the send and receive buffers for a TCP socket have a limited
                                size, if the client sent a large quantity of data, then it might
                                fill these buffers, at which point a further
                                    <span class="emphasis"><em>write()</em></span> would (permanently) block the
                                client before it read any of the server’s response.</p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">sockets/sendfile.c</code> in the source code distribution
                                for this book.</p></li></ol></div></div><div class="sect1" title="Chapter 62"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_62">
                        <a class="xref" href="ch62.html" title="Chapter 62. Terminals">Chapter 62</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <span class="emphasis"><em>tcgetattr()</em></span> fails if it is applied to a
                                file descriptor that doesn’t refer to a terminal.</p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">tty/ttyname.c</code> in the source code distribution for
                                this book.</p></li></ol></div></div><div class="sect1" title="Chapter 63"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_63">
                        <a class="xref" href="ch63.html" title="Chapter 63. Alternative I/O Models">Chapter 63</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A solution is provided in the file <code class="literal">altio/select_mq.c</code> in the source code distribution for
                                this book.<a id="IDX-APP-F-9002" class="indexterm"/><a id="IDX-APP-F-9003" class="indexterm"/><a id="IDX-APP-F-9004" class="indexterm"/></p></li><li class="listitem"><p>A race condition would result. Suppose the following sequence of
                                events: (a) after <span class="emphasis"><em>select()</em></span> has informed the
                                program that the self-pipe has data, it performs the appropriate
                                actions in response to the signal; (b) another signal arrives, and
                                the handler writes a byte to the self-pipe and returns; and (c) the
                                main program drains the self-pipe. As a consequence, the program
                                misses the signal that was delivered in step (b).</p></li><li class="listitem"><p>The <span class="emphasis"><em>epoll_wait()</em></span> call blocks, even when the
                                interest list is empty. This can be useful in a multithreaded
                                program, where one thread might add a descriptor to the
                                    <span class="emphasis"><em>epoll</em></span> interest list, while another thread
                                is blocked in an <span class="emphasis"><em>epoll_wait()</em></span> call.</p></li><li class="listitem"><p>Successive <span class="emphasis"><em>epoll_wait()</em></span> calls cycle through
                                the list of ready file descriptors. This is useful because it helps
                                prevent file-descriptor starvation, which could occur if
                                    <span class="emphasis"><em>epoll_wait()</em></span> always (for example) returned
                                the lowest-numbered ready file descriptor, and that file descriptor
                                always had some input available.</p></li></ol></div></div><div class="sect1" title="Chapter 64"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="chapter_64">
                        <a class="xref" href="ch64.html" title="Chapter 64. Pseudoterminals">Chapter 64</a>
                    </h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>First, the child shell process terminates, followed by the
                                    <span class="emphasis"><em>script</em></span> parent process. Since the terminal
                                is operating in raw mode, the <span class="emphasis"><em>Control-D</em></span>
                                character is not interpreted by the terminal driver, but is instead
                                passed as a literal character to the <span class="emphasis"><em>script</em></span>
                                parent process, which writes it to the pseudoterminal master. The
                                pseudoterminal slave is operating in canonical mode, so this
                                    <span class="emphasis"><em>Control-D</em></span> character is treated as an
                                end-of-file, which causes the child shell’s next
                                    <span class="emphasis"><em>read()</em></span> to return 0, with the result that
                                the shell terminates. The termination of the shell closes the only
                                file descriptor referring to the pseudoterminal slave. As a
                                consequence, the next <span class="emphasis"><em>read()</em></span> by the parent
                                    <span class="emphasis"><em>script</em></span> process fails with the error
                                    <code class="literal">EIO</code> (or end-of-file on some
                                other UNIX implementations), and this process then
                                    terminates.<a id="IDX-APP-F-9005" class="indexterm"/><a id="IDX-APP-F-9006" class="indexterm"/><a id="IDX-APP-F-9007" class="indexterm"/><a id="IDX-APP-F-9008" class="indexterm"/><a id="IDX-APP-F-9009" class="indexterm"/><a id="IDX-APP-F-9010" class="indexterm"/><a id="IDX-APP-F-9011" class="indexterm"/><a id="IDX-APP-F-9012" class="indexterm"/><a id="IDX-APP-F-9013" class="indexterm"/><a id="IDX-APP-F-9014" class="indexterm"/><a id="IDX-APP-F-9015" class="indexterm"/><a id="IDX-APP-F-9016" class="indexterm"/><a id="IDX-APP-F-9017" class="indexterm"/><a id="IDX-APP-F-9018" class="indexterm"/><a id="IDX-APP-F-9019" class="indexterm"/><a id="IDX-APP-F-9020" class="indexterm"/><a id="IDX-APP-F-9021" class="indexterm"/><a id="IDX-APP-F-9022" class="indexterm"/><a id="IDX-APP-F-9023" class="indexterm"/><a id="IDX-APP-F-9024" class="indexterm"/><a id="IDX-APP-F-9025" class="indexterm"/><a id="IDX-APP-F-9026" class="indexterm"/><a id="IDX-APP-F-9027" class="indexterm"/><a id="IDX-APP-F-9028" class="indexterm"/><a id="IDX-APP-F-9029" class="indexterm"/><a id="IDX-APP-F-9030" class="indexterm"/><a id="IDX-APP-F-9031" class="indexterm"/><a id="IDX-APP-F-9032" class="indexterm"/><a id="IDX-APP-F-9033" class="indexterm"/><a id="IDX-APP-F-9034" class="indexterm"/><a id="IDX-APP-F-9035" class="indexterm"/><a id="IDX-APP-F-9036" class="indexterm"/><a id="IDX-APP-F-9037" class="indexterm"/><a id="IDX-APP-F-9038" class="indexterm"/><a id="IDX-APP-F-9039" class="indexterm"/><a id="IDX-APP-F-9040" class="indexterm"/><a id="IDX-APP-F-9041" class="indexterm"/><a id="IDX-APP-F-9042" class="indexterm"/><a id="IDX-APP-F-9043" class="indexterm"/><a id="IDX-APP-F-9044" class="indexterm"/><a id="IDX-APP-F-9045" class="indexterm"/><a id="IDX-APP-F-9046" class="indexterm"/><a id="IDX-APP-F-9047" class="indexterm"/><a id="IDX-APP-F-9048" class="indexterm"/><a id="IDX-APP-F-9049" class="indexterm"/><a id="IDX-APP-F-9050" class="indexterm"/><a id="IDX-APP-F-9051" class="indexterm"/><a id="IDX-APP-F-9052" class="indexterm"/><a id="IDX-APP-F-9053" class="indexterm"/><a id="IDX-APP-F-9054" class="indexterm"/><a id="IDX-APP-F-9055" class="indexterm"/><a id="IDX-APP-F-9056" class="indexterm"/><a id="IDX-APP-F-9057" class="indexterm"/><a id="IDX-APP-F-9058" class="indexterm"/><a id="IDX-APP-F-9059" class="indexterm"/><a id="IDX-APP-F-9060" class="indexterm"/><a id="IDX-APP-F-9061" class="indexterm"/><a id="IDX-APP-F-9062" class="indexterm"/><a id="IDX-APP-F-9063" class="indexterm"/><a id="IDX-APP-F-9064" class="indexterm"/><a id="IDX-APP-F-9065" class="indexterm"/><a id="IDX-APP-F-9066" class="indexterm"/><a id="IDX-APP-F-9067" class="indexterm"/><a id="IDX-APP-F-9068" class="indexterm"/><a id="IDX-APP-F-9069" class="indexterm"/><a id="IDX-APP-F-9070" class="indexterm"/><a id="IDX-APP-F-9071" class="indexterm"/><a id="IDX-APP-F-9072" class="indexterm"/><a id="IDX-APP-F-9073" class="indexterm"/><a id="IDX-APP-F-9074" class="indexterm"/><a id="IDX-APP-F-9075" class="indexterm"/><a id="IDX-APP-F-9076" class="indexterm"/><a id="IDX-APP-F-9077" class="indexterm"/><a id="IDX-APP-F-9078" class="indexterm"/><a id="IDX-APP-F-9079" class="indexterm"/><a id="IDX-APP-F-9080" class="indexterm"/><a id="IDX-APP-F-9081" class="indexterm"/><a id="IDX-APP-F-9082" class="indexterm"/><a id="IDX-APP-F-9083" class="indexterm"/><a id="IDX-APP-F-9084" class="indexterm"/><a id="IDX-APP-F-9085" class="indexterm"/><a id="IDX-APP-F-9086" class="indexterm"/><a id="IDX-APP-F-9087" class="indexterm"/><a id="IDX-APP-F-9088" class="indexterm"/><a id="IDX-APP-F-9089" class="indexterm"/><a id="IDX-APP-F-9090" class="indexterm"/><a id="IDX-APP-F-9091" class="indexterm"/><a id="IDX-APP-F-9092" class="indexterm"/><a id="IDX-APP-F-9093" class="indexterm"/><a id="IDX-APP-F-9094" class="indexterm"/><a id="IDX-APP-F-9095" class="indexterm"/><a id="IDX-APP-F-9096" class="indexterm"/><a id="IDX-APP-F-9097" class="indexterm"/><a id="IDX-APP-F-9098" class="indexterm"/><a id="IDX-APP-F-9099" class="indexterm"/><a id="IDX-APP-F-9100" class="indexterm"/><a id="IDX-APP-F-9101" class="indexterm"/><a id="IDX-APP-F-9102" class="indexterm"/><a id="IDX-APP-F-9103" class="indexterm"/><a id="IDX-APP-F-9104" class="indexterm"/><a id="IDX-APP-F-9105" class="indexterm"/><a id="IDX-APP-F-9106" class="indexterm"/><a id="IDX-APP-F-9107" class="indexterm"/><a id="IDX-APP-F-9108" class="indexterm"/><a id="IDX-APP-F-9109" class="indexterm"/><a id="IDX-APP-F-9110" class="indexterm"/><a id="IDX-APP-F-9111" class="indexterm"/><a id="IDX-APP-F-9112" class="indexterm"/><a id="IDX-APP-F-9113" class="indexterm"/><a id="IDX-APP-F-9114" class="indexterm"/><a id="IDX-APP-F-9115" class="indexterm"/><a id="IDX-APP-F-9116" class="indexterm"/><a id="IDX-APP-F-9117" class="indexterm"/><a id="IDX-APP-F-9118" class="indexterm"/><a id="IDX-APP-F-9119" class="indexterm"/><a id="IDX-APP-F-9120" class="indexterm"/><a id="IDX-APP-F-9121" class="indexterm"/><a id="IDX-APP-F-9122" class="indexterm"/><a id="IDX-APP-F-9123" class="indexterm"/><a id="IDX-APP-F-9124" class="indexterm"/><a id="IDX-APP-F-9125" class="indexterm"/><a id="IDX-APP-F-9126" class="indexterm"/><a id="IDX-APP-F-9127" class="indexterm"/><a id="IDX-APP-F-9128" class="indexterm"/><a id="IDX-APP-F-9129" class="indexterm"/><a id="IDX-APP-F-9130" class="indexterm"/><a id="IDX-APP-F-9131" class="indexterm"/><a id="IDX-APP-F-9132" class="indexterm"/><a id="IDX-APP-F-9133" class="indexterm"/><a id="IDX-APP-F-9134" class="indexterm"/><a id="IDX-APP-F-9135" class="indexterm"/><a id="IDX-APP-F-9136" class="indexterm"/><a id="IDX-APP-F-9137" class="indexterm"/><a id="IDX-APP-F-9138" class="indexterm"/><a id="IDX-APP-F-9139" class="indexterm"/><a id="IDX-APP-F-9140" class="indexterm"/><a id="IDX-APP-F-9141" class="indexterm"/><a id="IDX-APP-F-9142" class="indexterm"/><a id="IDX-APP-F-9143" class="indexterm"/><a id="IDX-APP-F-9144" class="indexterm"/><a id="IDX-APP-F-9145" class="indexterm"/><a id="IDX-APP-F-9146" class="indexterm"/><a id="IDX-APP-F-9147" class="indexterm"/><a id="IDX-APP-F-9148" class="indexterm"/><a id="IDX-APP-F-9149" class="indexterm"/><a id="IDX-APP-F-9150" class="indexterm"/><a id="IDX-APP-F-9151" class="indexterm"/><a id="IDX-APP-F-9152" class="indexterm"/><a id="IDX-APP-F-9153" class="indexterm"/><a id="IDX-APP-F-9154" class="indexterm"/><a id="IDX-APP-F-9155" class="indexterm"/><a id="IDX-APP-F-9156" class="indexterm"/><a id="IDX-APP-F-9157" class="indexterm"/><a id="IDX-APP-F-9158" class="indexterm"/><a id="IDX-APP-F-9159" class="indexterm"/><a id="IDX-APP-F-9160" class="indexterm"/><a id="IDX-APP-F-9161" class="indexterm"/><a id="IDX-APP-F-9162" class="indexterm"/><a id="IDX-APP-F-9163" class="indexterm"/><a id="IDX-APP-F-9164" class="indexterm"/><a id="IDX-APP-F-9165" class="indexterm"/><a id="IDX-APP-F-9166" class="indexterm"/><a id="IDX-APP-F-9167" class="indexterm"/><a id="IDX-APP-F-9168" class="indexterm"/><a id="IDX-APP-F-9169" class="indexterm"/><a id="IDX-APP-F-9170" class="indexterm"/><a id="IDX-APP-F-9171" class="indexterm"/><a id="IDX-APP-F-9172" class="indexterm"/><a id="IDX-APP-F-9173" class="indexterm"/><a id="IDX-APP-F-9174" class="indexterm"/><a id="IDX-APP-F-9175" class="indexterm"/><a id="IDX-APP-F-9176" class="indexterm"/><a id="IDX-APP-F-9177" class="indexterm"/><a id="IDX-APP-F-9178" class="indexterm"/><a id="IDX-APP-F-9179" class="indexterm"/><a id="IDX-APP-F-9180" class="indexterm"/><a id="IDX-APP-F-9181" class="indexterm"/><a id="IDX-APP-F-9182" class="indexterm"/><a id="IDX-APP-F-9183" class="indexterm"/><a id="IDX-APP-F-9184" class="indexterm"/><a id="IDX-APP-F-9185" class="indexterm"/><a id="IDX-APP-F-9186" class="indexterm"/><a id="IDX-APP-F-9187" class="indexterm"/><a id="IDX-APP-F-9188" class="indexterm"/><a id="IDX-APP-F-9189" class="indexterm"/><a id="IDX-APP-F-9190" class="indexterm"/><a id="IDX-APP-F-9191" class="indexterm"/><a id="IDX-APP-F-9192" class="indexterm"/><a id="IDX-APP-F-9193" class="indexterm"/><a id="IDX-APP-F-9194" class="indexterm"/><a id="IDX-APP-F-9195" class="indexterm"/><a id="IDX-APP-F-9196" class="indexterm"/><a id="IDX-APP-F-9197" class="indexterm"/><a id="IDX-APP-F-9198" class="indexterm"/><a id="IDX-APP-F-9199" class="indexterm"/><a id="IDX-APP-F-9200" class="indexterm"/><a id="IDX-APP-F-9201" class="indexterm"/><a id="IDX-APP-F-9202" class="indexterm"/><a id="IDX-APP-F-9203" class="indexterm"/><a id="IDX-APP-F-9204" class="indexterm"/><a id="IDX-APP-F-9205" class="indexterm"/><a id="IDX-APP-F-9206" class="indexterm"/><a id="IDX-APP-F-9207" class="indexterm"/><a id="IDX-APP-F-9208" class="indexterm"/><a id="IDX-APP-F-9209" class="indexterm"/><a id="IDX-APP-F-9210" class="indexterm"/><a id="IDX-APP-F-9211" class="indexterm"/><a id="IDX-APP-F-9212" class="indexterm"/><a id="IDX-APP-F-9213" class="indexterm"/><a id="IDX-APP-F-9214" class="indexterm"/><a id="IDX-APP-F-9215" class="indexterm"/><a id="IDX-APP-F-9216" class="indexterm"/><a id="IDX-APP-F-9217" class="indexterm"/><a id="IDX-APP-F-9218" class="indexterm"/><a id="IDX-APP-F-9219" class="indexterm"/><a id="IDX-APP-F-9220" class="indexterm"/><a id="IDX-APP-F-9221" class="indexterm"/><a id="IDX-APP-F-9222" class="indexterm"/><a id="IDX-APP-F-9223" class="indexterm"/><a id="IDX-APP-F-9224" class="indexterm"/><a id="IDX-APP-F-9225" class="indexterm"/><a id="IDX-APP-F-9226" class="indexterm"/><a id="IDX-APP-F-9227" class="indexterm"/><a id="IDX-APP-F-9228" class="indexterm"/><a id="IDX-APP-F-9229" class="indexterm"/><a id="IDX-APP-F-9230" class="indexterm"/><a id="IDX-APP-F-9231" class="indexterm"/><a id="IDX-APP-F-9232" class="indexterm"/><a id="IDX-APP-F-9233" class="indexterm"/><a id="IDX-APP-F-9234" class="indexterm"/><a id="IDX-APP-F-9235" class="indexterm"/><a id="IDX-APP-F-9236" class="indexterm"/><a id="IDX-APP-F-9237" class="indexterm"/><a id="IDX-APP-F-9238" class="indexterm"/><a id="IDX-APP-F-9239" class="indexterm"/><a id="IDX-APP-F-9240" class="indexterm"/><a id="IDX-APP-F-9241" class="indexterm"/><a id="IDX-APP-F-9242" class="indexterm"/><a id="IDX-APP-F-9243" class="indexterm"/><a id="IDX-APP-F-9244" class="indexterm"/><a id="IDX-APP-F-9245" class="indexterm"/><a id="IDX-APP-F-9246" class="indexterm"/><a id="IDX-APP-F-9247" class="indexterm"/><a id="IDX-APP-F-9248" class="indexterm"/><a id="IDX-APP-F-9249" class="indexterm"/><a id="IDX-APP-F-9250" class="indexterm"/><a id="IDX-APP-F-9251" class="indexterm"/><a id="IDX-APP-F-9252" class="indexterm"/><a id="IDX-APP-F-9253" class="indexterm"/><a id="IDX-APP-F-9254" class="indexterm"/><a id="IDX-APP-F-9255" class="indexterm"/><a id="IDX-APP-F-9256" class="indexterm"/><a id="IDX-APP-F-9257" class="indexterm"/><a id="IDX-APP-F-9258" class="indexterm"/><a id="IDX-APP-F-9259" class="indexterm"/><a id="IDX-APP-F-9260" class="indexterm"/><a id="IDX-APP-F-9261" class="indexterm"/><a id="IDX-APP-F-9262" class="indexterm"/><a id="IDX-APP-F-9263" class="indexterm"/><a id="IDX-APP-F-9264" class="indexterm"/><a id="IDX-APP-F-9265" class="indexterm"/><a id="IDX-APP-F-9266" class="indexterm"/><a id="IDX-APP-F-9267" class="indexterm"/><a id="IDX-APP-F-9268" class="indexterm"/><a id="IDX-APP-F-9269" class="indexterm"/><a id="IDX-APP-F-9270" class="indexterm"/><a id="IDX-APP-F-9271" class="indexterm"/><a id="IDX-APP-F-9272" class="indexterm"/><a id="IDX-APP-F-9273" class="indexterm"/><a id="IDX-APP-F-9274" class="indexterm"/><a id="IDX-APP-F-9275" class="indexterm"/><a id="IDX-APP-F-9276" class="indexterm"/><a id="IDX-APP-F-9277" class="indexterm"/><a id="IDX-APP-F-9278" class="indexterm"/><a id="IDX-APP-F-9279" class="indexterm"/><a id="IDX-APP-F-9280" class="indexterm"/><a id="IDX-APP-F-9281" class="indexterm"/><a id="IDX-APP-F-9282" class="indexterm"/><a id="IDX-APP-F-9283" class="indexterm"/><a id="IDX-APP-F-9284" class="indexterm"/><a id="IDX-APP-F-9285" class="indexterm"/><a id="IDX-APP-F-9286" class="indexterm"/><a id="IDX-APP-F-9287" class="indexterm"/><a id="IDX-APP-F-9288" class="indexterm"/><a id="IDX-APP-F-9289" class="indexterm"/><a id="IDX-APP-F-9290" class="indexterm"/><a id="IDX-APP-F-9291" class="indexterm"/><a id="IDX-APP-F-9292" class="indexterm"/><a id="IDX-APP-F-9293" class="indexterm"/><a id="IDX-APP-F-9294" class="indexterm"/><a id="IDX-APP-F-9295" class="indexterm"/><a id="IDX-APP-F-9296" class="indexterm"/><a id="IDX-APP-F-9297" class="indexterm"/><a id="IDX-APP-F-9298" class="indexterm"/><a id="IDX-APP-F-9299" class="indexterm"/><a id="IDX-APP-F-9300" class="indexterm"/><a id="IDX-APP-F-9301" class="indexterm"/><a id="IDX-APP-F-9302" class="indexterm"/><a id="IDX-APP-F-9303" class="indexterm"/><a id="IDX-APP-F-9304" class="indexterm"/><a id="IDX-APP-F-9305" class="indexterm"/><a id="IDX-APP-F-9306" class="indexterm"/><a id="IDX-APP-F-9307" class="indexterm"/><a id="IDX-APP-F-9308" class="indexterm"/><a id="IDX-APP-F-9309" class="indexterm"/><a id="IDX-APP-F-9310" class="indexterm"/><a id="IDX-APP-F-9311" class="indexterm"/><a id="IDX-APP-F-9312" class="indexterm"/><a id="IDX-APP-F-9313" class="indexterm"/><a id="IDX-APP-F-9314" class="indexterm"/><a id="IDX-APP-F-9315" class="indexterm"/><a id="IDX-APP-F-9316" class="indexterm"/><a id="IDX-APP-F-9317" class="indexterm"/><a id="IDX-APP-F-9318" class="indexterm"/><a id="IDX-APP-F-9319" class="indexterm"/><a id="IDX-APP-F-9320" class="indexterm"/><a id="IDX-APP-F-9321" class="indexterm"/><a id="IDX-APP-F-9322" class="indexterm"/><a id="IDX-APP-F-9323" class="indexterm"/><a id="IDX-APP-F-9324" class="indexterm"/><a id="IDX-APP-F-9325" class="indexterm"/><a id="IDX-APP-F-9326" class="indexterm"/><a id="IDX-APP-F-9327" class="indexterm"/></p></li><li class="listitem"><p>A solution is provided in the file <code class="literal">pty/unbuffer.c</code> in the source code distribution for
                                this book.</p></li></ol></div></div></section></body></html>
