<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 56. Sockets: Introduction</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch55.html" title="Chapter 55. File Locking"/><link rel="next" href="ch57.html" title="Chapter 57. Sockets: UNIX Domain"/></head><body><section class="chapter" title="Chapter 56. Sockets: Introduction" epub:type="chapter" id="sockets_colon_introduction"><div class="titlepage"><div><div><h2 class="title">Chapter 56. Sockets: Introduction</h2></div></div></div><p>Sockets are a method of IPC that allow data to be exchanged between applications,
            either on the same host (computer) or on different hosts connected by a network. The
            first widespread implementation of the sockets API appeared with 4.2BSD in 1983, and
            this API has been ported to virtually every UNIX implementation, as well as most other
            operating systems.<a id="IDX-CHP-56-7298" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The sockets API is formally specified in POSIX.1g, which was ratified in 2000
                after spending about a decade as a draft standard. This standard has been superseded
                by SUSv3.<a id="IDX-CHP-56-7299" class="indexterm"/></p></div><p>This chapter and the following chapters describe the use of sockets, as
            follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>This chapter provides a general introduction to the sockets API. The following
                    chapters assume an understanding of the general concepts presented here. We
                    don’t present any example code in this chapter. Code examples in the UNIX and
                    Internet domains are presented in the following chapters.</p></li><li class="listitem"><p><a class="xref" href="ch57.html" title="Chapter 57. Sockets: UNIX Domain">Chapter 57</a> describes UNIX domain sockets,
                    which allow communication between applications on the same host system.</p></li><li class="listitem"><p><a class="xref" href="ch58.html" title="Chapter 58. Sockets: Fundamentals of TCP/IP Networks">Chapter 58</a> introduces various
                    computer networking concepts and describes key features of the TCP/IP networking
                    protocols. It provides background needed for the next chapters.</p></li><li class="listitem"><p><a class="xref" href="ch59.html" title="Chapter 59. Sockets: Internet Domains">Chapter 59</a> describes Internet domain
                    sockets, which allow applications on different hosts to communicate via a TCP/IP
                    network.</p></li><li class="listitem"><p><a class="xref" href="ch60.html" title="Chapter 60. Sockets: Server Design">Chapter 60</a> discusses the design of servers
                    that use sockets.</p></li><li class="listitem"><p><a class="xref" href="ch61.html" title="Chapter 61. Sockets: Advanced Topics">Chapter 61</a> covers a range of advanced
                    topics, including additional features for socket I/O, a more detailed look at
                    the TCP protocol, and the use of socket options to retrieve and modify various
                    attributes of sockets.</p></li></ul></div><p>These chapters merely aim to give the reader a good grounding in the use of sockets.
            Sockets programming, especially for network communication, is an enormous topic in its
            own right, and forms the subject of entire books. Sources of further information are
            listed in <a class="xref" href="ch59.html#further_information-id81" title="Further Information">Further Information</a>.</p><div class="sect1" title="Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="overview-id19">Overview</h2></div></div></div><p>In a typical client-server scenario, applications communicate using sockets as
                    follows:<a id="IDX-CHP-56-7300" class="indexterm"/><a id="IDX-CHP-56-7301" class="indexterm"/><a id="IDX-CHP-56-7302" class="indexterm"/><a id="IDX-CHP-56-7303" class="indexterm"/><a id="IDX-CHP-56-7304" class="indexterm"/><a id="IDX-CHP-56-7305" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Each application creates a socket. A socket is the “apparatus” that allows
                        communication, and both applications require one.</p></li><li class="listitem"><p>The server binds its socket to a well-known address (name) so that clients
                        can locate it.</p></li></ul></div><p>A socket is created using the <span class="emphasis"><em>socket()</em></span> system call, which
                returns a file descriptor used to refer to the socket in subsequent system
                    calls:<a id="IDX-CHP-56-7306" class="indexterm"/></p><a id="I_programlisting56_d1e144823"/><pre class="programlisting">fd = socket(domain, type, protocol);</pre><p>We describe socket domains and types in the following paragraphs. For all
                applications described in this book, <span class="emphasis"><em>protocol</em></span> is always
                specified as 0.<a id="IDX-CHP-56-7307" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="communication_domains"/></div></div></div><div class="sect3" title="Communication domains"><div class="titlepage"><div><div><h4 class="title" id="communication_domains-id1">Communication domains</h4></div></div></div><p>Sockets exist in a <span class="emphasis"><em>communication domain</em></span>, which
                        determines:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>the method of identifying a socket (i.e., the format of a socket
                                “address”); and</p></li><li class="listitem"><p>the range of communication (i.e., either between applications on
                                the same host or between applications on different hosts connected
                                via a network).</p></li></ul></div><p>Modern operating systems support at least the following domains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>UNIX</em></span> (<code class="literal">AF_UNIX</code>) domain allows communication between
                                applications on the same host. (POSIX.1g used the name <code class="literal">AF_LOCAL</code> as a synonym for <code class="literal">AF_UNIX</code>, but this name is not used in
                                SUSv3.)</p></li><li class="listitem"><p>The <span class="emphasis"><em>IPv4</em></span> (<code class="literal">AF_INET</code>) domain allows communication between
                                applications running on hosts connected via an Internet Protocol
                                version 4 (IPv4) network.</p></li><li class="listitem"><p>The <span class="emphasis"><em>IPv6</em></span> (<code class="literal">AF_INET6</code>) domain allows communication between
                                applications running on hosts connected via an Internet Protocol
                                version 6 (IPv6) network. Although IPv6 is designed as the successor
                                to IPv4, the latter protocol is currently still the most widely
                                used.</p></li></ul></div><p><a class="xref" href="ch56.html#socket_domains" title="Table 56-1. Socket domains">Table 56-1</a> summarizes the characteristics of these
                        socket domains.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In some code, we may see constants with names such as <code class="literal">PF_UNIX</code> instead of <code class="literal">AF_UNIX</code>. In this context, <code class="literal">AF</code> stands for “address family” and
                                <code class="literal">PF</code> stands for “protocol family.”
                            Initially, it was conceived that a single protocol family might support
                            multiple address families. In practice, no protocol family supporting
                            multiple address families has ever been defined, and all existing
                            implementations define the <code class="literal">PF_</code>
                            constants to be synonymous with the corresponding <code class="literal">AF_</code> constants. (SUSv3 specifies the
                                <code class="literal">AF_</code> constants, but not the
                                <code class="literal">PF_</code> constants.) In this book, we
                            always use the <code class="literal">AF_</code> constants. Further
                            information about the history of these constants can be found in <a class="xref" href="ch04.html#universality_of_i_solidus_o" title="Universality of I/O">Universality of I/O</a> of [Stevens et al.,
                            2004].</p></div><div class="table"><a id="socket_domains"/><div class="table-title">Table 56-1. Socket domains</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/><col class="col5"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Domain</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Communication performed</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Communication between applications</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Address format</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                        <p>Address structure</p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">AF_UNIX</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>within kernel</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>on same host</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>sockaddr_un</em></span>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">AF_INET</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>via IPv4</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>on hosts connected via an IPv4 network</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>32-bit IPv4 address + 16-bit port number</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>sockaddr_in</em></span>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">AF_INET6</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>via IPv6</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>on hosts connected via an IPv6 network</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>128-bit IPv6 address + 16-bit port number</p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>
                                            <span class="emphasis"><em>sockaddr_in6</em></span>
                                        </p>
                                    </td></tr></tbody></table></div></div></div><div class="sect3" title="Socket types"><div class="titlepage"><div><div><h4 class="title" id="socket_types">Socket types</h4></div></div></div><p>Every sockets implementation provides at least two types of sockets:
                        stream and datagram. These socket types are supported in both the UNIX and
                        the Internet domains. <a class="xref" href="ch56.html#socket_types_and_their_properties" title="Table 56-2. Socket types and their properties">Table 56-2</a>
                        summarizes the properties of these socket types.<a id="IDX-CHP-56-7308" class="indexterm"/><a id="IDX-CHP-56-7309" class="indexterm"/><a id="IDX-CHP-56-7310" class="indexterm"/><a id="IDX-CHP-56-7311" class="indexterm"/><a id="IDX-CHP-56-7312" class="indexterm"/><a id="IDX-CHP-56-7313" class="indexterm"/><a id="IDX-CHP-56-7314" class="indexterm"/><a id="IDX-CHP-56-7315" class="indexterm"/><a id="IDX-CHP-56-7316" class="indexterm"/></p><div class="table"><a id="socket_types_and_their_properties"/><div class="table-title">Table 56-2. Socket types and their properties</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; " rowspan="2">
                                        <p>Property</p>
                                    </td><td style="text-align: center; vertical-align: bottom; border-bottom: 0.5pt solid ; " colspan="2">
                                        <p>Socket type<a id="IDX-CHP-56-7317" class="indexterm"/></p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Stream</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                        <p>Datagram</p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Reliable delivery?</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Y</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>N</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Message boundaries preserved?</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>N</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Y</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>Connection-oriented?</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>Y</p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>N</p>
                                    </td></tr></tbody></table></div></div><p><span class="emphasis"><em>Stream sockets</em></span> (<code class="literal">SOCK_STREAM</code>) provide a reliable, bidirectional, byte-stream
                        communication channel. By the terms in this description, we mean the
                        following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Reliable</em></span> means that we are guaranteed that
                                either the transmitted data will arrive intact at the receiving
                                application, exactly as it was transmitted by the sender (assuming
                                that neither the network link nor the receiver crashes), or that
                                we’ll receive notification of a probable failure in
                                transmission.</p></li><li class="listitem"><p><span class="emphasis"><em>Bidirectional</em></span> means that data may be
                                transmitted in either direction between two sockets.</p></li><li class="listitem"><p><span class="emphasis"><em>Byte-stream</em></span> means that, as with pipes, there
                                is no concept of message boundaries (refer to <a class="xref" href="ch44.html#overview-id11" title="Overview">Overview</a>).</p></li></ul></div><p>A stream socket is similar to using a pair of pipes to allow bidirectional
                        communication between two applications, with the difference that (Internet
                        domain) sockets permit communication over a network.</p><p>Stream sockets operate in connected pairs. For this reason, stream sockets
                        are described as <span class="emphasis"><em>connection-oriented</em></span>. The term
                            <span class="emphasis"><em>peer socket</em></span> refers to the socket at the other end
                        of a connection; <span class="emphasis"><em>peer address</em></span> denotes the address of
                        that socket; and <span class="emphasis"><em>peer application</em></span> denotes the
                        application utilizing the peer socket. Sometimes, the term
                            <span class="emphasis"><em>remote</em></span> (or <span class="emphasis"><em>foreign</em></span>) is used
                        synonymously with <span class="emphasis"><em>peer</em></span>. Analogously, sometimes the term
                            <span class="emphasis"><em>local</em></span> is used to refer to the application, socket,
                        or address for this end of the connection. A stream socket can be connected
                        to only one peer.<a id="IDX-CHP-56-7318" class="indexterm"/><a id="IDX-CHP-56-7319" class="indexterm"/><a id="IDX-CHP-56-7320" class="indexterm"/><a id="IDX-CHP-56-7321" class="indexterm"/></p><p><span class="emphasis"><em>Datagram sockets</em></span> (<code class="literal">SOCK_DGRAM</code>) allow data to be exchanged in the form of
                        messages called <span class="emphasis"><em>datagrams</em></span>. With datagram sockets,
                        message boundaries are preserved, but data transmission is not reliable.
                        Messages may arrive out of order, be duplicated, or not arrive at
                            all.<a id="IDX-CHP-56-7322" class="indexterm"/></p><p>Datagram sockets are an example of the more generic concept of a
                            <span class="emphasis"><em>connectionless</em></span> socket. Unlike a stream socket, a
                        datagram socket doesn’t need to be connected to another socket in order to
                        be used. (In <a class="xref" href="ch56.html#using_connect_open_parenthesis_close_par" title="Using connect() with Datagram Sockets">Using <span class="emphasis"><em>connect()</em></span> with Datagram Sockets</a>,
                        we’ll see that datagram sockets may be connected with one another, but this
                        has somewhat different semantics from connected stream sockets.)<a id="IDX-CHP-56-7323" class="indexterm"/></p><p>In the Internet domain, datagram sockets employ the User Datagram Protocol
                        (UDP), and stream sockets (usually) employ the Transmission Control Protocol
                        (TCP). Instead of using the terms <span class="emphasis"><em>Internet domain datagram
                            socket</em></span> and <span class="emphasis"><em>Internet domain stream
                        socket</em></span>, we’ll often just use the terms <span class="emphasis"><em>UDP
                            socket</em></span> and <span class="emphasis"><em>TCP socket</em></span>,
                        respectively.</p></div><div class="sect3" title="Socket system calls"><div class="titlepage"><div><div><h4 class="title" id="socket_system_calls">Socket system calls</h4></div></div></div><p>The key socket system calls are the following:<a id="IDX-CHP-56-7324" class="indexterm"/><a id="IDX-CHP-56-7325" class="indexterm"/><a id="IDX-CHP-56-7326" class="indexterm"/><a id="IDX-CHP-56-7327" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>socket()</em></span> system call creates a new
                                    socket.<a id="IDX-CHP-56-7328" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>bind()</em></span> system call binds a socket to an
                                address. Usually, a server employs this call to bind its socket to a
                                well-known address so that clients can locate the socket.<a id="IDX-CHP-56-7329" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>listen()</em></span> system call allows a stream
                                socket to accept incoming connections from other sockets.<a id="IDX-CHP-56-7330" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>accept()</em></span> system call accepts a connection
                                from a peer application on a listening stream socket, and optionally
                                returns the address of the peer socket.<a id="IDX-CHP-56-7331" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>connect()</em></span> system call establishes a
                                connection with another socket.<a id="IDX-CHP-56-7332" class="indexterm"/></p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>On most Linux architectures (the exceptions include Alpha and IA-64),
                            all of the sockets system calls are actually implemented as library
                            functions multiplexed through a single system call,
                                <span class="emphasis"><em>socketcall()</em></span>. (This is an artifact of the
                            original development of the Linux sockets implementation as a separate
                            project.) Nevertheless, we refer to all of these functions as system
                            calls in this book, since this is what they were in the original BSD
                            implementation, as well as in many other contemporary UNIX
                                implementations.<a id="IDX-CHP-56-7333" class="indexterm"/></p></div><p>Socket I/O can be performed using the conventional
                            <span class="emphasis"><em>read()</em></span> and <span class="emphasis"><em>write()</em></span> system
                        calls, or using a range of socket-specific system calls (e.g.,
                            <span class="emphasis"><em>send()</em></span>, <span class="emphasis"><em>recv()</em></span>,
                            <span class="emphasis"><em>sendto()</em></span>, and <span class="emphasis"><em>recvfrom()</em></span>). By
                        default, these system calls block if the I/O operation can’t be completed
                        immediately. Nonblocking I/O is also possible, by using the
                            <span class="emphasis"><em>fcntl()</em></span>
                        <code class="literal">F_SETFL</code> operation (<a class="xref" href="ch05.html#open_file_status_flags" title="Open File Status Flags">Open File Status Flags</a>) to enable the <code class="literal">O_NONBLOCK</code> open file status flag.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, we can call <span class="emphasis"><em>ioctl(fd, FIONREAD,
                                &amp;cnt)</em></span> to obtain the number of unread bytes
                            available on the stream socket referred to by the file descriptor
                                <span class="emphasis"><em>fd</em></span>. For a datagram socket, this operation
                            returns the number of bytes in the next unread datagram (which may be
                            zero if the next datagram is of zero length), or zero if there are no
                            pending datagrams. This feature is not specified in SUSv3.</p></div></div></div></div><div class="sect1" title="Creating a Socket: socket()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="creating_a_socket_colon_socket_open_pare">Creating a Socket: <span class="emphasis"><em>socket()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>socket()</em></span> system call creates a new socket.<a id="IDX-CHP-56-7335" class="indexterm"/><a id="IDX-CHP-56-7336" class="indexterm"/><a id="IDX-CHP-56-7337" class="indexterm"/><a id="IDX-CHP-56-7338" class="indexterm"/><a id="IDX-CHP-56-7339" class="indexterm"/><a id="IDX-CHP-56-7340" class="indexterm"/><a id="IDX-CHP-56-7341" class="indexterm"/><a id="IDX-CHP-56-7342" class="indexterm"/><a id="IDX-CHP-56-7343" class="indexterm"/><a id="IDX-CHP-56-7344" class="indexterm"/><a id="IDX-CHP-56-7345" class="indexterm"/><a id="IDX-CHP-56-7346" class="indexterm"/><a id="IDX-CHP-56-7334" class="indexterm"/></p><a id="I_programlisting56_d1e145429"/><pre class="programlisting">#include &lt;sys/socket.h&gt;

int <strong class="userinput"><code>socket</code></strong>(int <span class="emphasis"><em>domain</em></span>, int <span class="emphasis"><em>type</em></span>, int <span class="emphasis"><em>protocol</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns file descriptor on success, or -1 on error</p></div><p>The <span class="emphasis"><em>domain</em></span> argument specifies the communication domain for
                the socket. The <span class="emphasis"><em>type</em></span> argument specifies the socket type. This
                argument is usually specified as either <code class="literal">SOCK_STREAM</code>, to create a stream socket, or <code class="literal">SOCK_DGRAM</code>, to create a datagram socket.</p><p>The <span class="emphasis"><em>protocol</em></span> argument is always specified as 0 for the socket
                types we describe in this book. Nonzero <span class="emphasis"><em>protocol</em></span> values are
                used with some socket types that we don’t describe. For example,
                    <span class="emphasis"><em>protocol</em></span> is specified as <code class="literal">IPPROTO_RAW</code> for raw sockets (<code class="literal">SOCK_RAW</code>).</p><p>On success, <span class="emphasis"><em>socket()</em></span> returns a file descriptor used to refer
                to the newly created socket in later system calls.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Starting with kernel 2.6.27, Linux provides a second use for the
                        <span class="emphasis"><em>type</em></span> argument, by allowing two nonstandard flags to be
                    ORed with the socket type. The <code class="literal">SOCK_CLOEXEC</code>
                    flag causes the kernel to enable the close-on-exec flag (<code class="literal">FD_CLOEXEC</code>) for the new file descriptor. This flag
                    is useful for the same reasons as the <span class="emphasis"><em>open()</em></span>
                    <code class="literal">O_CLOEXEC</code> flag described in <a class="xref" href="ch04.html#file_descriptor_number_returned_by-id1" title="File descriptor number returned by open()">File descriptor number returned by <span class="emphasis"><em>open()</em></span></a>. The SOCK_NONBLOCK flag
                    causes the kernel to set the <code class="literal">O_NONBLOCK</code> flag
                    on the underlying open file description, so that future I/O operations on the
                    socket will be nonblocking. This saves additional calls to
                        <span class="emphasis"><em>fcntl()</em></span> to achieve the same result.<a id="IDX-CHP-56-7347" class="indexterm"/></p></div></div><div class="sect1" title="Binding a Socket to an Address: bind()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="binding_a_socket_to_an_address_colon_bin">Binding a Socket to an Address: <span class="emphasis"><em>bind()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>bind()</em></span> system call binds a socket to an
                    address.<a id="IDX-CHP-56-7348" class="indexterm"/></p><a id="I_programlisting56_d1e145526"/><pre class="programlisting">#include &lt;sys/socket.h&gt;

int <strong class="userinput"><code>bind</code></strong>(int <span class="emphasis"><em>sockfd</em></span>, const struct sockaddr <span class="emphasis"><em>*addr</em></span>, socklen_t <span class="emphasis"><em>addrlen</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>sockfd</em></span> argument is a file descriptor obtained from a
                previous call to <span class="emphasis"><em>socket()</em></span>. The <span class="emphasis"><em>addr</em></span>
                argument is a pointer to a structure specifying the address to which this socket is
                to be bound. The type of structure passed in this argument depends on the socket
                domain. The <span class="emphasis"><em>addrlen</em></span> argument specifies the size of the address
                structure. The <span class="emphasis"><em>socklen_t</em></span> data type used for the
                    <span class="emphasis"><em>addrlen</em></span> argument is an integer type specified by
                    SUSv3.<a id="IDX-CHP-56-7349" class="indexterm"/><a id="IDX-CHP-56-7350" class="indexterm"/></p><p>Typically, we bind a server’s socket to a well-known address—that is, a fixed
                address that is known in advance to client applications that need to communicate
                with that server.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>There are other possibilities than binding a server’s socket to a well-known
                    address. For example, for an Internet domain socket, the server could omit the
                    call to <span class="emphasis"><em>bind()</em></span> and simply call
                        <span class="emphasis"><em>listen()</em></span>, which causes the kernel to choose an
                    ephemeral port for that socket. (We describe ephemeral ports in <a class="xref" href="ch58.html#port_numbers" title="Port Numbers">Port Numbers</a>.) Afterward, the server can use
                        <span class="emphasis"><em>getsockname()</em></span> (<a class="xref" href="ch61.html#retrieving_socket_addresses" title="Retrieving Socket Addresses">Retrieving Socket Addresses</a>) to retrieve the address of its
                    socket. In this scenario, the server must then publish that address so that
                    clients know how to locate the server’s socket. Such publication could be done
                    by registering the server’s address with a centralized directory service
                    application that clients then contact in order to obtain the address. (For
                    example, Sun RPC solves this problem using its <span class="emphasis"><em>portmapper</em></span>
                    server.) Of course, the directory service application’s socket must reside at a
                    well-known address.</p></div></div><div class="sect1" title="Generic Socket Address Structures: struct sockaddr"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="generic_socket_address_structures_colon">Generic Socket Address Structures: <span class="emphasis"><em>struct sockaddr</em></span></h2></div></div></div><p>The <span class="emphasis"><em>addr</em></span> and <span class="emphasis"><em>addrlen</em></span> arguments to
                    <span class="emphasis"><em>bind()</em></span> require some further explanation. Looking at <a class="xref" href="ch56.html#socket_domains" title="Table 56-1. Socket domains">Table 56-1</a>, we see that each socket domain uses a different
                address format. For example, UNIX domain sockets use pathnames, while Internet
                domain sockets use the combination of an IP address plus a port number. For each
                socket domain, a different structure type is defined to store a socket address.
                However, because system calls such as <span class="emphasis"><em>bind()</em></span> are generic to all
                socket domains, they must be able to accept address structures of any type. In order
                to permit this, the sockets API defines a generic address structure,
                    <span class="emphasis"><em>struct sockaddr</em></span>. The only purpose for this type is to cast
                the various domain-specific address structures to a single type for use as arguments
                in the socket system calls. The <span class="emphasis"><em>sockaddr</em></span> structure is typically
                defined as follows:<a id="IDX-CHP-56-7351" class="indexterm"/><a id="IDX-CHP-56-7352" class="indexterm"/></p><a id="I_programlisting56_d1e145637"/><pre class="programlisting">struct sockaddr {
    sa_family_t sa_family;          /* Address family (AF_* constant) */
    char        sa_data[14];        /* Socket address (size varies
                                       according to socket domain) */
};</pre><p>This structure serves as a template for all of the domain-specific address
                structures. Each of these address structures begins with a
                    <span class="emphasis"><em>family</em></span> field corresponding to the
                    <span class="emphasis"><em>sa_family</em></span> field of the <span class="emphasis"><em>sockaddr</em></span>
                structure. (The <span class="emphasis"><em>sa_family_t</em></span> data type is an integer type
                specified in SUSv3.) The value in the <span class="emphasis"><em>family</em></span> field is
                sufficient to determine the size and format of the address stored in the remainder
                of the structure.<a id="IDX-CHP-56-7353" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some UNIX implementations also define an additional field in the
                        <span class="emphasis"><em>sockaddr</em></span> structure, <span class="emphasis"><em>sa_len</em></span>, that
                    specifies the total size of the structure. SUSv3 doesn’t require this field, and
                    it is not present in the Linux implementation of the sockets API.</p><p>If we define the <code class="literal">_GNU_SOURCE</code> feature test
                    macro, then <span class="emphasis"><em>glibc</em></span> prototypes the various socket system
                    calls in <code class="literal">&lt;sys/socket.h&gt;</code> using a
                        <span class="emphasis"><em>gcc</em></span> extension that eliminates the need for the
                        <span class="emphasis"><em>(struct sockaddr *)</em></span> cast. However, reliance on this
                    feature is nonportable (it will result in compilation warnings on other
                    systems).</p></div></div><div class="sect1" title="Stream Sockets"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="stream_sockets">Stream Sockets</h2></div></div></div><p>The operation of stream sockets can be explained by analogy with the telephone
                    system:<a id="IDX-CHP-56-7354" class="indexterm"/><a id="IDX-CHP-56-7355" class="indexterm"/><a id="IDX-CHP-56-7356" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <span class="emphasis"><em>socket()</em></span> system call, which creates a socket, is
                        the equivalent of installing a telephone. In order for two applications to
                        communicate, each of them must create a socket.</p></li><li class="listitem"><p>Communication via a stream socket is analogous to a telephone call. One
                        application must connect its socket to another application’s socket before
                        communication can take place. Two sockets are connected as follows:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>One application calls <span class="emphasis"><em>bind()</em></span> in order to bind
                                the socket to a well-known address, and then calls
                                    <span class="emphasis"><em>listen()</em></span> to notify the kernel of its
                                willingness to accept incoming connections. This step is analogous
                                to having a known telephone number and ensuring that our telephone
                                is turned on so that people can call us.<a id="IDX-CHP-56-7357" class="indexterm"/></p></li><li class="listitem"><p>The other application establishes the connection by calling
                                    <span class="emphasis"><em>connect()</em></span>, specifying the address of the
                                socket to which the connection is to be made. This is analogous to
                                dialing someone’s telephone number.</p></li><li class="listitem"><p>The application that called <span class="emphasis"><em>listen()</em></span> then
                                accepts the connection using <span class="emphasis"><em>accept()</em></span>. This is
                                analogous to picking up the telephone when it rings. If the
                                    <span class="emphasis"><em>accept()</em></span> is performed before the peer
                                application calls <span class="emphasis"><em>connect()</em></span>, then the
                                    <span class="emphasis"><em>accept()</em></span> blocks (“waiting by the
                                telephone”).</p></li></ol></div></li><li class="listitem"><p>Once a connection has been established, data can be transmitted in both
                        directions between the applications (analogous to a two-way telephone
                        conversation) until one of them closes the connection using
                            <span class="emphasis"><em>close()</em></span>. Communication is performed using the
                        conventional <span class="emphasis"><em>read()</em></span> and <span class="emphasis"><em>write()</em></span>
                        system calls or via a number of socket-specific system calls (such as
                            <span class="emphasis"><em>send()</em></span> and <span class="emphasis"><em>recv()</em></span>) that
                        provide additional functionality.</p></li></ol></div><p><a class="xref" href="ch56.html#overview_of_system_calls_used_with_strea" title="Figure 56-1. Overview of system calls used with stream sockets">Figure 56-1</a> illustrates the use of
                the system calls used with stream sockets.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="active_and_passive_sockets"/></div></div></div><div class="sect3" title="Active and passive sockets"><div class="titlepage"><div><div><h4 class="title" id="active_and_passive_sockets-id1">Active and passive sockets</h4></div></div></div><p>Stream sockets are often distinguished as being either active or
                            passive:<a id="IDX-CHP-56-7358" class="indexterm"/><a id="IDX-CHP-56-7359" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>By default, a socket that has been created using
                                    <span class="emphasis"><em>socket()</em></span> is <span class="emphasis"><em>active</em></span>. An
                                active socket can be used in a <span class="emphasis"><em>connect()</em></span> call
                                to establish a connection to a passive socket. This is referred to
                                as performing an <span class="emphasis"><em>active open</em></span>.</p></li><li class="listitem"><p>A <span class="emphasis"><em>passive</em></span> socket (also called a
                                    <span class="emphasis"><em>listening</em></span> socket) is one that has been
                                marked to allow incoming connections by calling
                                    <span class="emphasis"><em>listen()</em></span>. Accepting an incoming connection
                                is referred to as performing a <span class="emphasis"><em>passive
                                open</em></span>.</p></li></ul></div><p>In most applications that employ stream sockets, the server performs the
                        passive open, and the client performs the active open. We presume this
                        scenario in subsequent sections, so that instead of saying “the application
                        that performs the active socket open,” we’ll often just say “the client.”
                        Similarly, we’ll equate “the server” with “the application that performs the
                        passive socket open.”<a id="IDX-CHP-56-7360" class="indexterm"/></p><div class="figure"><a id="overview_of_system_calls_used_with_strea"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject56_d1e145829"/><img src="figs/web/56-1_SOCKINTRO-stream-overview-scale90.png.jpg" alt="Overview of system calls used with stream sockets"/></div></div><div class="figure-title">Figure 56-1. Overview of system calls used with stream sockets</div></div></div></div><div class="sect2" title="Listening for Incoming Connections: listen()"><div class="titlepage"><div><div><h3 class="title" id="listening_for_incoming_connections_colon">Listening for Incoming Connections: <span class="emphasis"><em>listen()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>listen()</em></span> system call marks the stream socket referred
                    to by the file descriptor <span class="emphasis"><em>sockfd</em></span> as
                        <span class="emphasis"><em>passive</em></span>. The socket will subsequently be used to accept
                    connections from other (active) sockets.<a id="IDX-CHP-56-7362" class="indexterm"/><a id="IDX-CHP-56-7363" class="indexterm"/><a id="IDX-CHP-56-7364" class="indexterm"/><a id="IDX-CHP-56-7365" class="indexterm"/><a id="IDX-CHP-56-7366" class="indexterm"/><a id="IDX-CHP-56-7367" class="indexterm"/><a id="IDX-CHP-56-7368" class="indexterm"/><a id="IDX-CHP-56-7361" class="indexterm"/></p><a id="I_programlisting56_d1e145902"/><pre class="programlisting">#include &lt;sys/socket.h&gt;

int <strong class="userinput"><code>listen</code></strong>(int <span class="emphasis"><em>sockfd</em></span>, int <span class="emphasis"><em>backlog</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>We can’t apply <span class="emphasis"><em>listen()</em></span> to a connected socket--that is, a
                    socket on which a <span class="emphasis"><em>connect()</em></span> has been successfully performed
                    or a socket returned by a call to <span class="emphasis"><em>accept()</em></span>.</p><p>To understand the purpose of the <span class="emphasis"><em>backlog</em></span> argument, we
                    first observe that the client may call <span class="emphasis"><em>connect()</em></span> before the
                    server calls <span class="emphasis"><em>accept()</em></span>. This could happen, for example,
                    because the server is busy handling some other client(s). This results in a
                        <span class="emphasis"><em>pending connection</em></span>, as illustrated in <a class="xref" href="ch56.html#a_pending_socket_connection" title="Figure 56-2. A pending socket connection">Figure 56-2</a>.<a id="IDX-CHP-56-7369" class="indexterm"/></p><div class="figure"><a id="a_pending_socket_connection"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject56_d1e145952"/><img src="figs/web/56-2_SOCKINTRO-unaccepted-connect-scale90.png.jpg" alt="A pending socket connection"/></div></div><div class="figure-title">Figure 56-2. A pending socket connection</div></div><p>The kernel must record some information about each pending connection request
                    so that a subsequent <span class="emphasis"><em>accept()</em></span> can be processed. The
                        <span class="emphasis"><em>backlog</em></span> argument allows us to limit the number of such
                    pending connections. Connection requests up to this limit succeed immediately.
                    (For TCP sockets, the story is a little more complicated, as we’ll see in <a class="xref" href="ch61.html#tcp_connection_establishment" title="TCP Connection Establishment">TCP Connection Establishment</a>.) Further connection requests block
                    until a pending connection is accepted (via <span class="emphasis"><em>accept()</em></span>), and
                    thus removed from the queue of pending connections.<a id="IDX-CHP-56-7370" class="indexterm"/></p><p>SUSv3 allows an implementation to place an upper limit on the value that can
                    be specified for <span class="emphasis"><em>backlog</em></span>, and permits an implementation to
                    silently round <span class="emphasis"><em>backlog</em></span> values down to this limit. SUSv3
                    specifies that the implementation should advertise this limit by defining the
                    constant <code class="literal">SOMAXCONN</code> in <code class="literal">&lt;sys/socket.h&gt;</code>. On Linux, this
                    constant is defined with the value 128. However, since kernel 2.4.25, Linux
                    allows this limit to be adjusted at run time via the Linux-specific <code class="literal">/proc/sys/net/core/somaxconn</code> file. (In earlier
                    kernel versions, the <code class="literal">SOMAXCONN</code> limit is
                        immutable.)<a id="IDX-CHP-56-7371" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In the original BSD sockets implementation, the upper limit for
                            <span class="emphasis"><em>backlog</em></span> was 5, and we may see this number specified
                        in older code. All modern implementations allow higher values of
                            <span class="emphasis"><em>backlog</em></span>, which are necessary for network servers
                        employing TCP sockets to serve large numbers of clients.</p></div></div><div class="sect2" title="Accepting a Connection: accept()"><div class="titlepage"><div><div><h3 class="title" id="accepting_a_connection_colon_accept_open">Accepting a Connection: <span class="emphasis"><em>accept()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>accept()</em></span> system call accepts an incoming connection
                    on the listening stream socket referred to by the file descriptor
                        <span class="emphasis"><em>sockfd</em></span>. If there are no pending connections when
                        <span class="emphasis"><em>accept()</em></span> is called, the call blocks until a connection
                    request arrives.<a id="IDX-CHP-56-7372" class="indexterm"/><a id="IDX-CHP-56-7373" class="indexterm"/><a id="IDX-CHP-56-7374" class="indexterm"/><a id="IDX-CHP-56-7375" class="indexterm"/><a id="IDX-CHP-56-7376" class="indexterm"/></p><a id="I_programlisting56_d1e146053"/><pre class="programlisting">#include &lt;sys/socket.h&gt;

int <strong class="userinput"><code>accept</code></strong>(int <span class="emphasis"><em>sockfd</em></span>, struct sockaddr *<span class="emphasis"><em>addr</em></span>, socklen_t *<span class="emphasis"><em>addrlen</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns file descriptor on success, or -1 on error</p></div><p>The key point to understand about <span class="emphasis"><em>accept()</em></span> is that it
                    creates a <span class="emphasis"><em>new</em></span> socket, and it is this new socket that is
                    connected to the peer socket that performed the <span class="emphasis"><em>connect()</em></span>.
                    A file descriptor for the connected socket is returned as the function result of
                    the <span class="emphasis"><em>accept()</em></span> call. The listening socket
                        (<span class="emphasis"><em>sockfd</em></span>) remains open, and can be used to accept
                    further connections. A typical server application creates one listening socket,
                    binds it to a well-known address, and then handles all client requests by
                    accepting connections via that socket.<a id="IDX-CHP-56-7377" class="indexterm"/></p><p>The remaining arguments to <span class="emphasis"><em>accept()</em></span> return the address of
                    the peer socket. The <span class="emphasis"><em>addr</em></span> argument points to a structure
                    that is used to return the socket address. The type of this argument depends on
                    the socket domain (as for <span class="emphasis"><em>bind()</em></span>).</p><p>The <span class="emphasis"><em>addrlen</em></span> argument is a value-result argument. It
                    points to an integer that, prior to the call, must be initialized to the size of
                    the buffer pointed to by <span class="emphasis"><em>addr</em></span>, so that the kernel knows how
                    much space is available to return the socket address. Upon return from
                        <span class="emphasis"><em>accept()</em></span>, this integer is set to indicate the number of
                    bytes of data actually copied into the buffer.</p><p>If we are not interested in the address of the peer socket, then
                        <span class="emphasis"><em>addr</em></span> and <span class="emphasis"><em>addrlen</em></span> should be
                    specified as <code class="literal">NULL</code> and 0, respectively. (If
                    desired, we can retrieve the peer’s address later using the
                        <span class="emphasis"><em>getpeername()</em></span> system call, as described in Section
                    61.5.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Starting with kernel 2.6.28, Linux supports a new, nonstandard system
                        call, <span class="emphasis"><em>accept4()</em></span>. This system call performs the same
                        task as <span class="emphasis"><em>accept()</em></span>, but supports an additional argument,
                            <span class="emphasis"><em>flags</em></span>, that can be used to modify the behavior of
                        the system call. Two flags are supported: <code class="literal">SOCK_CLOEXEC</code> and <code class="literal">SOCK_NONBLOCK</code>. The <code class="literal">SOCK_CLOEXEC</code> flag causes the kernel to enable the
                        close-on-exec flag (<code class="literal">FD_CLOEXEC</code>) for the
                        new file descriptor returned by the call. This flag is useful for the same
                        reasons as the <span class="emphasis"><em>open()</em></span>
                        <code class="literal">O_CLOEXEC</code> flag described in <a class="xref" href="ch04.html#file_descriptor_number_returned_by-id1" title="File descriptor number returned by open()">File descriptor number returned by <span class="emphasis"><em>open()</em></span></a>. The <code class="literal">SOCK_NONBLOCK</code> flag causes the kernel to enable
                        the <code class="literal">O_NONBLOCK</code> flag on the underlying
                        open file description, so that future I/O operations on the socket will be
                        nonblocking. This saves additional calls to <span class="emphasis"><em>fcntl()</em></span> to
                        achieve the same result.<a id="IDX-CHP-56-7378" class="indexterm"/><a id="IDX-CHP-56-7379" class="indexterm"/></p></div></div><div class="sect2" title="Connecting to a Peer Socket: connect()"><div class="titlepage"><div><div><h3 class="title" id="connecting_to_a_peer_socket_colon_connec">Connecting to a Peer Socket: <span class="emphasis"><em>connect()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>connect()</em></span> system call connects the active socket
                    referred to by the file descriptor <span class="emphasis"><em>sockfd</em></span> to the listening
                    socket whose address is specified by <span class="emphasis"><em>addr</em></span> and
                        <span class="emphasis"><em>addrlen</em></span>.<a id="IDX-CHP-56-7380" class="indexterm"/><a id="IDX-CHP-56-7381" class="indexterm"/><a id="IDX-CHP-56-7382" class="indexterm"/><a id="IDX-CHP-56-7383" class="indexterm"/><a id="IDX-CHP-56-7384" class="indexterm"/><a id="IDX-CHP-56-7385" class="indexterm"/><a id="IDX-CHP-56-7386" class="indexterm"/><a id="IDX-CHP-56-7387" class="indexterm"/></p><a id="I_programlisting56_d1e146240"/><pre class="programlisting">#include &lt;sys/socket.h&gt;

int <strong class="userinput"><code>connect</code></strong>(int <span class="emphasis"><em>sockfd</em></span>, const struct sockaddr *<span class="emphasis"><em>addr</em></span>, socklen_t <span class="emphasis"><em>addrlen</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>addr</em></span> and <span class="emphasis"><em>addrlen</em></span> arguments are
                    specified in the same way as the corresponding arguments to
                        <span class="emphasis"><em>bind()</em></span>.</p><p>If <span class="emphasis"><em>connect()</em></span> fails and we wish to reattempt the
                    connection, then SUSv3 specifies that the portable method of doing so is to
                    close the socket, create a new socket, and reattempt the connection with the new
                    socket.</p></div><div class="sect2" title="I/O on Stream Sockets"><div class="titlepage"><div><div><h3 class="title" id="i_solidus_o_on_stream_sockets">I/O on Stream Sockets</h3></div></div></div><p>A pair of connected stream sockets provides a bidirectional communication
                    channel between the two endpoints. <a class="xref" href="ch56.html#unix_domain_stream_sockets_provide_a_bid" title="Figure 56-3. UNIX domain stream sockets provide a bidirectional communication channel">Figure 56-3</a> shows what this looks
                    like in the UNIX domain.<a id="IDX-CHP-56-7388" class="indexterm"/></p><div class="figure"><a id="unix_domain_stream_sockets_provide_a_bid"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject56_d1e146290"/><img src="figs/web/56-3_SOCKINTRO-unix-connected-scale90.png.jpg" alt="UNIX domain stream sockets provide a bidirectional communication channel"/></div></div><div class="figure-title">Figure 56-3. UNIX domain stream sockets provide a bidirectional communication
                        channel</div></div><p>The semantics of I/O on connected stream sockets are similar to those for
                    pipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To perform I/O, we use the <span class="emphasis"><em>read()</em></span> and
                                <span class="emphasis"><em>write()</em></span> system calls (or the socket-specific
                                <span class="emphasis"><em>send()</em></span> and <span class="emphasis"><em>recv()</em></span>, which
                            we describe in <a class="xref" href="ch61.html#socket-specific_i_solidus_o_system_calls" title="Socket-Specific I/O System Calls: recv() and send()">Socket-Specific I/O System Calls: <span class="emphasis"><em>recv()</em></span> and
                    <span class="emphasis"><em>send()</em></span></a>). Since sockets are bidirectional, both calls may be used on each end
                            of the connection.</p></li><li class="listitem"><p>A socket may be closed using the <span class="emphasis"><em>close()</em></span> system
                            call or as a consequence of the application terminating. Afterward, when
                            the peer application attempts to read from the other end of the
                            connection, it receives end-of-file (once all buffered data has been
                            read). If the peer application attempts to write to its socket, it
                            receives a <code class="literal">SIGPIPE</code> signal, and the
                            system call fails with the error <code class="literal">EPIPE</code>. As we noted in <a class="xref" href="ch44.html#creating_and_using_pipes" title="Creating and Using Pipes">Creating and Using Pipes</a>, the usual way of dealing with
                            this possibility is to ignore the <code class="literal">SIGPIPE</code> signal and find out about the closed connection
                            via the <code class="literal">EPIPE</code> error.<a id="IDX-CHP-56-7389" class="indexterm"/><a id="IDX-CHP-56-7390" class="indexterm"/></p></li></ul></div></div><div class="sect2" title="Connection Termination: close()"><div class="titlepage"><div><div><h3 class="title" id="connection_termination_colon_close_open">Connection Termination: <span class="emphasis"><em>close()</em></span></h3></div></div></div><p>The usual way of terminating a stream socket connection is to call
                        <span class="emphasis"><em>close()</em></span>. If multiple file descriptors refer to the same
                    socket, then the connection is terminated when all of the descriptors are
                        closed.<a id="IDX-CHP-56-7391" class="indexterm"/></p><p>Suppose that, after we close a connection, the peer application crashes or
                    otherwise fails to read or correctly process the data that we previously sent to
                    it. In this case, we have no way of knowing that an error occurred. If we need
                    to ensure that the data was successfully read and processed, then we must build
                    some type of acknowledgement protocol into our application. This normally
                    consists of an explicit acknowledgement message passed back to us from the
                    peer.</p><p>In <a class="xref" href="ch61.html#the_shutdown_open_parenthesis_close_pare" title="The shutdown() System Call">The <span class="emphasis"><em>shutdown()</em></span> System Call</a>, we describe the
                        <span class="emphasis"><em>shutdown()</em></span> system call, which provides finer control of
                    how a stream socket connection is closed.</p></div></div><div class="sect1" title="Datagram Sockets"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="datagram_sockets">Datagram Sockets</h2></div></div></div><p>The operation of datagram sockets can be explained by analogy with the postal
                    system:<a id="IDX-CHP-56-7392" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <span class="emphasis"><em>socket()</em></span> system call is the equivalent of setting
                        up a mailbox. (Here, we assume a system like the rural postal service in
                        some countries, which both picks up letters from and delivers letters to the
                        mailbox.) Each application that wants to send or receive datagrams creates a
                        datagram socket using <span class="emphasis"><em>socket()</em></span>.</p></li><li class="listitem"><p>In order to allow another application to send it datagrams (letters), an
                        application uses <span class="emphasis"><em>bind()</em></span> to bind its socket to a
                        well-known address. Typically, a server binds its socket to a well-known
                        address, and a client initiates communication by sending a datagram to that
                        address. (In some domains--notably the UNIX domain--the client may also need
                        to use <span class="emphasis"><em>bind()</em></span> to assign an address to its socket if it
                        wants to receive datagrams sent by the server.)</p></li><li class="listitem"><p>To send a datagram, an application calls <span class="emphasis"><em>sendto()</em></span>,
                        which takes as one of its arguments the address of the socket to which the
                        datagram is to be sent. This is analogous to putting the recipient’s address
                        on a letter and posting it.<a id="IDX-CHP-56-7393" class="indexterm"/></p></li><li class="listitem"><p>In order to receive a datagram, an application calls
                            <span class="emphasis"><em>recvfrom()</em></span>, which may block if no datagram has yet
                        arrived. Because <span class="emphasis"><em>recvfrom()</em></span> allows us to obtain the
                        address of the sender, we can send a reply if desired. (This is useful if
                        the sender’s socket is bound to an address that is not well known, which is
                        typical of a client.) Here, we stretch the analogy a little, since there is
                        no requirement that a posted letter is marked with the sender’s
                            address.<a id="IDX-CHP-56-7394" class="indexterm"/></p></li><li class="listitem"><p>When the socket is no longer needed, the application closes it using
                            <span class="emphasis"><em>close()</em></span>.</p></li></ol></div><p>Just as with the postal system, when multiple datagrams (letters) are sent from
                one address to another, there is no guarantee that they will arrive in the order
                they were sent, or even arrive at all. Datagrams add one further possibility not
                present in the postal system: since the underlying networking protocols may
                sometimes retransmit a data packet, the same datagram could arrive more than
                once.</p><p><a class="xref" href="ch56.html#overview_of_system_calls_used_with_datag" title="Figure 56-4. Overview of system calls used with datagram sockets">Figure 56-4</a> illustrates the use of
                the system calls employed with datagram sockets.</p><div class="figure"><a id="overview_of_system_calls_used_with_datag"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject56_d1e146437"/><img src="figs/web/56-4_SOCKINTRO-datagram-overview-scale90.png.jpg" alt="Overview of system calls used with datagram sockets"/></div></div><div class="figure-title">Figure 56-4. Overview of system calls used with datagram sockets</div></div><div class="sect2" title="Exchanging Datagrams: recvfrom() and sendto()"><div class="titlepage"><div><div><h3 class="title" id="exchanging_datagrams_colon_recvfrom_open">Exchanging Datagrams: <span class="emphasis"><em>recvfrom()</em></span> and
                        <span class="emphasis"><em>sendto()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>recvfrom()</em></span> and <span class="emphasis"><em>sendto()</em></span> system
                    calls receive and send datagrams on a datagram socket.<a id="IDX-CHP-56-7395" class="indexterm"/><a id="IDX-CHP-56-7396" class="indexterm"/><a id="IDX-CHP-56-7397" class="indexterm"/><a id="IDX-CHP-56-7398" class="indexterm"/><a id="IDX-CHP-56-7399" class="indexterm"/></p><a id="I_programlisting56_d1e146493"/><pre class="programlisting">#include &lt;sys/socket.h&gt;

ssize_t <strong class="userinput"><code>recvfrom</code></strong>(int <span class="emphasis"><em>sockfd</em></span>, void *<span class="emphasis"><em>buffer</em></span>, size_t <span class="emphasis"><em>length</em></span>, int <span class="emphasis"><em>flags</em></span>,
                 struct sockaddr *<span class="emphasis"><em>src_addr</em></span>, socklen_t *<span class="emphasis"><em>addrlen</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of bytes received, 0 on EOF, or -1 on error</p></div><a id="I_programlisting56_d1e146520"/><pre class="programlisting">ssize_t <strong class="userinput"><code>sendto</code></strong>(int <span class="emphasis"><em>sockfd</em></span>, const void *<span class="emphasis"><em>buffer</em></span>, size_t <span class="emphasis"><em>length</em></span>, int <span class="emphasis"><em>flags</em></span>,
               const struct sockaddr *<span class="emphasis"><em>dest_addr</em></span>, socklen_t <span class="emphasis"><em>addrlen</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of bytes sent, or -1 on error</p></div><p>The return value and the first three arguments to these system calls are the
                    same as for <span class="emphasis"><em>read()</em></span> and <span class="emphasis"><em>write()</em></span>.</p><p>The fourth argument, <span class="emphasis"><em>flags</em></span>, is a bit mask controlling
                    socket-specific I/O features. We cover these features when we describe the
                        <span class="emphasis"><em>recv()</em></span> and <span class="emphasis"><em>send()</em></span> system calls in
                    Section 61.3. If we don’t require any of these features, we can specify
                        <span class="emphasis"><em>flags</em></span> as 0.</p><p>The <span class="emphasis"><em>src_addr</em></span> and <span class="emphasis"><em>addrlen</em></span> arguments
                    are used to obtain or specify the address of the peer socket with which we are
                    communicating.</p><p>For <span class="emphasis"><em>recvfrom()</em></span>, the <span class="emphasis"><em>src_addr</em></span> and
                        <span class="emphasis"><em>addrlen</em></span> arguments return the address of the remote
                    socket used to send the datagram. (These arguments are analogous to the
                        <span class="emphasis"><em>addr</em></span> and <span class="emphasis"><em>addrlen</em></span> arguments of
                        <span class="emphasis"><em>accept()</em></span>, which return the address of a connecting peer
                    socket.) The <span class="emphasis"><em>src_addr</em></span> argument is a pointer to an address
                    structure appropriate to the communication domain. As with
                        <span class="emphasis"><em>accept()</em></span>, <span class="emphasis"><em>addrlen</em></span> is a
                    value-result argument. Prior to the call, <span class="emphasis"><em>addrlen</em></span> should be
                    initialized to the size of the structure pointed to by
                        <span class="emphasis"><em>src_addr</em></span>; upon return, it contains the number of bytes
                    actually written to this structure.</p><p>If we are not interested in the address of the sender, then we specify both
                        <span class="emphasis"><em>src_addr</em></span> and <span class="emphasis"><em>addrlen</em></span> as <code class="literal">NULL</code>. In this case,
                        <span class="emphasis"><em>recvfrom()</em></span> is equivalent to using
                        <span class="emphasis"><em>recv()</em></span> to receive a datagram. We can also use
                        <span class="emphasis"><em>read()</em></span> to read a datagram, which is equivalent to using
                        <span class="emphasis"><em>recv()</em></span> with a <span class="emphasis"><em>flags</em></span> argument of
                    0.</p><p>Regardless of the value specified for <span class="emphasis"><em>length</em></span>,
                        <span class="emphasis"><em>recvfrom()</em></span> retrieves exactly one message from a
                    datagram socket. If the size of that message exceeds <span class="emphasis"><em>length</em></span>
                    bytes, the message is silently truncated to <span class="emphasis"><em>length</em></span>
                    bytes.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If we employ the <span class="emphasis"><em>recvmsg()</em></span> system call (<a class="xref" href="ch61.html#the_sendmsg_open_parenthesis_close_paren" title="The sendmsg() and recvmsg() System Calls">The <span class="emphasis"><em>sendmsg()</em></span> and <span class="emphasis"><em>recvmsg()</em></span> System
                    Calls</a>), then it is
                        possible to find out about a truncated datagram via the <code class="literal">MSG_TRUNC</code> flag returned in the
                            <span class="emphasis"><em>msg_flags</em></span> field of the returned
                            <span class="emphasis"><em>msghdr</em></span> structure. See the
                            <span class="emphasis"><em>recvmsg(2)</em></span> manual page for details.</p></div><p>For <span class="emphasis"><em>sendto()</em></span>, the <span class="emphasis"><em>dest_addr</em></span> and
                        <span class="emphasis"><em>addrlen</em></span> arguments specify the socket to which the
                    datagram is to be sent. These arguments are employed in the same manner as the
                    corresponding arguments to <span class="emphasis"><em>connect()</em></span>. The
                        <span class="emphasis"><em>dest_addr</em></span> argument is an address structure suitable for
                    this communication domain. It is initialized with the address of the destination
                    socket. The <span class="emphasis"><em>addrlen</em></span> argument specifies the size of
                        <span class="emphasis"><em>addr</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, it is possible to use <span class="emphasis"><em>sendto()</em></span> to send
                        datagrams of length 0. However, not all UNIX implementations permit
                        this.</p></div></div><div class="sect2" title="Using connect() with Datagram Sockets"><div class="titlepage"><div><div><h3 class="title" id="using_connect_open_parenthesis_close_par">Using <span class="emphasis"><em>connect()</em></span> with Datagram Sockets</h3></div></div></div><p>Even though datagram sockets are connectionless, the
                        <span class="emphasis"><em>connect()</em></span> system call serves a purpose when applied to
                    datagram sockets. Calling <span class="emphasis"><em>connect()</em></span> on a datagram socket
                    causes the kernel to record a particular address as this socket’s peer. The term
                        <span class="emphasis"><em>connected datagram socket</em></span> is applied to such a socket.
                    The term <span class="emphasis"><em>unconnected datagram socket</em></span> is applied to a
                    datagram socket on which <span class="emphasis"><em>connect()</em></span> has not been called
                    (i.e., the default for a new datagram socket).<a id="IDX-CHP-56-7400" class="indexterm"/></p><p>After a datagram socket has been connected:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Datagrams can be sent through the socket using
                                <span class="emphasis"><em>write()</em></span> (or <span class="emphasis"><em>send()</em></span>) and
                            are automatically sent to the same peer socket. As with
                                <span class="emphasis"><em>sendto()</em></span>, each <span class="emphasis"><em>write()</em></span>
                            call results in a separate datagram.</p></li><li class="listitem"><p>Only datagrams sent by the peer socket may be read on the
                            socket.</p></li></ul></div><p>Note that the effect of <span class="emphasis"><em>connect()</em></span> is asymmetric for
                    datagram sockets. The above statements apply only to the socket on which
                        <span class="emphasis"><em>connect()</em></span> has been called, not to the remote socket to
                    which it is connected (unless the peer application also calls
                        <span class="emphasis"><em>connect()</em></span> on its socket).</p><p>We can change the peer of a connected datagram socket by issuing a further
                        <span class="emphasis"><em>connect()</em></span> call. It is also possible to dissolve the
                    peer association altogether by specifying an address structure in which the
                    address family (e.g., the <span class="emphasis"><em>sun_family</em></span> field in the UNIX
                    domain) is specified as <code class="literal">AF_UNSPEC</code>. Note,
                    however, that many other UNIX implementations don’t support the use of <code class="literal">AF_UNSPEC</code> for this purpose.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 was somewhat vague about dissolving peer associations, stating that
                        a connection can be reset by making a <span class="emphasis"><em>connect()</em></span> call
                        that specifies a “null address,” without defining that term. SUSv4
                        explicitly specifies the use of <code class="literal">AF_UNSPEC</code>.</p></div><p>The obvious advantage of setting the peer for a datagram socket is that we can
                    use simpler I/O system calls when transmitting data on the socket. We no longer
                    need to use <span class="emphasis"><em>sendto()</em></span> with <span class="emphasis"><em>dest_addr</em></span>
                    and <span class="emphasis"><em>addrlen</em></span> arguments, but can instead use
                        <span class="emphasis"><em>write()</em></span>. Setting the peer is useful primarily in an
                    application that needs to send multiple datagrams to a single peer (which is
                    typical of some datagram clients).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On some TCP/IP implementations, connecting a datagram socket to a peer
                        yields a performance improvement ([Stevens et al., 2004]). On Linux,
                        connecting a datagram socket makes little difference to performance.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id55">Summary</h2></div></div></div><p>Sockets allow communication between applications on the same host or on different
                hosts connected via a network.<a id="IDX-CHP-56-7401" class="indexterm"/><a id="IDX-CHP-56-7402" class="indexterm"/><a id="IDX-CHP-56-7403" class="indexterm"/></p><p>A socket exists within a communication domain, which determines the range of
                communication and the address format used to identify the socket. SUSv3 specifies
                the UNIX (<code class="literal">AF_UNIX</code>), IPv4 (<code class="literal">AF_INET</code>), and IPv6 (<code class="literal">AF_INET6</code>) communication domains.</p><p>Most applications use one of two socket types: stream or datagram. Stream sockets
                    (<code class="literal">SOCK_STREAM</code>) provide a reliable,
                bidirectional, byte-stream communication channel between two endpoints. Datagram
                sockets (<code class="literal">SOCK_DGRAM</code>) provide unreliable,
                connectionless, message-oriented communication.</p><p>A typical stream socket server creates its socket using
                    <span class="emphasis"><em>socket()</em></span>, and then binds the socket to a well-known address
                using <span class="emphasis"><em>bind()</em></span>. The server then calls
                    <span class="emphasis"><em>listen()</em></span> to allow connections to be received on the socket.
                Each client connection is then accepted on the listening socket using
                    <span class="emphasis"><em>accept()</em></span>, which returns a file descriptor for a new socket
                that is connected to the client’s socket. A typical stream socket client creates a
                socket using <span class="emphasis"><em>socket()</em></span>, and then establishes a connection by
                calling <span class="emphasis"><em>connect()</em></span>, specifying the server’s well-known address.
                After two stream sockets are connected, data can be transferred in either direction
                using <span class="emphasis"><em>read()</em></span> and <span class="emphasis"><em>write()</em></span>. Once all
                processes with a file descriptor referring to a stream socket endpoint have
                performed an implicit or explicit <span class="emphasis"><em>close()</em></span>, the connection is
                terminated.</p><p>A typical datagram socket server creates a socket using
                    <span class="emphasis"><em>socket()</em></span>, and then binds it to a well-known address using
                    <span class="emphasis"><em>bind()</em></span>. Because datagram sockets are connectionless, the
                server’s socket can be used to receive datagrams from any client. Datagrams can be
                received using <span class="emphasis"><em>read()</em></span> or using the socket-specific
                    <span class="emphasis"><em>recvfrom()</em></span> system call, which returns the address of the
                sending socket. A datagram socket client creates a socket using
                    <span class="emphasis"><em>socket()</em></span>, and then uses <span class="emphasis"><em>sendto()</em></span> to
                send a datagram to a specified (i.e., the server’s) address. The
                    <span class="emphasis"><em>connect()</em></span> system call can be used with a datagram socket to
                set a peer address for the socket. After doing this, it is no longer necessary to
                specify the destination address for outgoing datagrams; a
                    <span class="emphasis"><em>write()</em></span> call can be used to send a datagram.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id75"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id76">Further information</h4></div></div></div><p>Refer to the sources of further information listed in <a class="xref" href="ch59.html#further_information-id81" title="Further Information">Further Information</a>.</p></div></div></div></section></body></html>
