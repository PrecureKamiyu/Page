<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>32.3 Deadlock Bugs</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part339.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part341.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">32.3 Deadlock Bugs</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">Beyond the concurrency bugs mentioned above, a classic problem that arises in many concurrent systems with complex locking protocols is known as <b>deadlock</b>. Deadlock occurs, for example, when a thread (say Thread 1) is holding a lock (L1) and waiting for another one (L2); unfortunately, the thread (Thread 2) that holds lock L2 is waiting for L1 to be released. Here is a code snippet that demonstrates such a potential deadlock:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">Thread 1:     Thread 2:</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">lock(L1);     lock(L2);</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">lock(L2);     lock(L1);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Note that if this code runs, deadlock does not necessarily occur; rather, it may occur, if, for example, Thread 1 grabs lock L1 and then a context switch occurs to Thread 2. At that point, Thread 2 grabs L2, and tries to acquire L1. Thus we have a deadlock, as each thread is waiting for the other and neither can run. See Figure <span style=" color: #00AEEF;">32.1 </span>for details; the presence of a <b>cycle </b>in the graph is indicative of the deadlock.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The figure should make clear the problem. How should programmers write code so as to handle deadlock in some way?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 71pt;text-indent: 0pt;line-height: 11pt;text-align: left;">C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>D<span class="s7">EAL </span>W<span class="s7">ITH </span>D<span class="s7">EADLOCK</span></p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: left;">How should we build systems to prevent, avoid, or at least detect and recover from deadlock? Is this a real problem in systems today?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part341.htm">Why Do Deadlocks Occur?</a><a class="toc0" href="part342.htm">Conditions for Deadlock</a><a class="toc0" href="part343.htm">Prevention</a><a class="toc1" href="part344.htm">Circular Wait</a><a class="toc1" href="part345.htm">Hold-and-wait</a><a class="toc1" href="part346.htm">No Preemption</a><a class="toc1" href="part347.htm">Mutual Exclusion</a><a class="toc0" href="part348.htm">Deadlock Avoidance via Scheduling</a><a class="toc0" href="part349.htm">Detect and Recover</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part339.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part341.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
