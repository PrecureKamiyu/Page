<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>25.3  Other Issues in Application Development</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part449.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part451.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">25.3  <span style=" color: #00AEEF;">Other Issues in Application Development</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In this section, we discuss two issues in application development: testing of applications and migration of applications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">25.3.1 Testing Applications</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Testing of programs involves designing a <span class="s63">test suite</span>, that is, a collection of test cases. Testing is not a one-time process, since programs evolve continuously, and bugs may appear as an unintended consequence of a change in the program; such a bug is referred to as program <span class="s63">regression</span>. Thus, after every change to a program, the program must be tested again. It is usually infeasible to have a human perform tests after every change to a program. Instead, expected test outputs are stored with each test case in a test suite. <span class="s63">Regression testing </span>involves running the program on each test case in a test suite and checking that the program generates the expected test output.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In the context of database applications, a test case consists of two parts: a database state and an input to a speciﬁc interface of the application.</p><p class="s13" style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 91%;text-align: justify;"><span class="s42">SQL </span><span class="s43">queries can have subtle bugs that can be diﬃcult to catch. For example, a query may execute a join when it should have performed an outer join (i.e., </span>r <span class="s86">⋈ </span>s<span class="p">, when it should have actually performed </span>r <span class="s15">⟕ </span>s<span class="p">). The diﬀerence between these two queries would be found only if the test database had an </span>r <span class="p">tuple with no matching </span>s <span class="p">tuple. Thus, it is</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">important to create test databases that can catch commonly occurring errors. Such errors are referred to as <span class="s63">mutations</span>, since they are usually small changes to a query (or program). A test case that produces diﬀerent outputs on an intended query and a mutant of the query is said to <span class="s63">kill the mutant</span>. A test suite should have test cases that kill (most) commonly occurring mutants.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If a test case performs an update on the database, to check that it executed properly one must verify that the contents of the database match the expected contents. Thus,</p><p class="s66" style="padding-top: 3pt;padding-left: 275pt;text-indent: 0pt;text-align: left;">25.3 <span style=" color: #00AEEF;">Other Issues in Application Development  </span><span class="s164">1235</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">the expected output consists not only of data displayed on the user’s screen, but also (updates to) the database state.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">Since the database state can be rather large, multiple test cases would share a com- mon database state. Testing is complicated by the fact that if a test case performs an update on the database, the results of other test cases run subsequently on the same database may not match the expected results. The other test cases would then be erro- neously reported as having failed. To avoid this problem, whenever a test case performs an update, the database state must be restored to its original state after running the test. Testing can also be used to ensure that an application meets performance require- ments. To carry out such <span class="s63">performance testing</span>, the test database must be of the same size as the real database would be. In some cases, there is already existing data on which performance testing can be carried out. In other cases, a test database of the required size must be generated; there are several tools available for generating such test databases. These tools ensure that the generated data satisfy constraints such as primary- and foreign-key constraints. They may additionally generate data that look meaningful, for example, by populating a name attribute using meaningful names in- stead of random strings. Some tools also allow data distributions to be speciﬁed; for example, a university database may require a distribution with most students in the</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">range of 18 to 25 years and most faculty in the range of 25 to 65 years.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Even if there is an existing database, organizations usually do not want to reveal sensitive data to an external organization that may be carrying out the performance tests. In such a situation, a copy of the real database may be made, and the values in the copy may be modiﬁed in such a way that any sensitive data, such as credit-card numbers, social security numbers, or dates of birth, are <span class="s63">obfuscated</span>. Obfuscation is done in most cases by replacing a real value with a randomly generated value (taking care to also update all references to that value, in case the value is a primary key). On the other hand, if the application execution depends on the value, such as the date of birth in an application that performs diﬀerent actions based on the date of birth, obfuscation may make small random changes in the value instead of replacing it completely.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">25.3.2 Application Migration</p><p class="s63" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Legacy systems <span class="p">are older-generation application systems that are still in use despite being obsolete. They continue in use due to the cost and risk in replacing them. For example, many organizations developed applications in-house, but they may decide to replace them with a commercial product. In some cases, a legacy system may use old technology that is incompatible with current-generation standards and systems. Some legacy systems in operation today are several decades old and are based on technologies such as databases that use the network or hierarchical data models, or use Cobol and ﬁle systems without a database. Such systems may still contain valuable data and may support critical applications.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Replacing legacy applications with new applications is often costly in terms of both time and money, since they are often very large, consisting of millions of lines of code</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">developed by teams of programmers, often over several decades. They contain large amounts of data that must be ported to the new application, which may use a com- pletely diﬀerent schema. Switchover from an old to a new application involves retrain- ing large numbers of staﬀ. Switchover must usually be done without any disruption, with data entered in the old system available through the new system as well.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Many organizations attempt to avoid replacing legacy systems and instead try to interoperate them with newer systems. One approach used to interoperate between relational databases and legacy databases is to build a layer, called a <span class="s63">wrapper</span>, on top of the legacy systems that can make the legacy system appear to be a relational database. The wrapper may provide support for <span class="s44">ODBC </span>or other interconnection standards such as <span class="s44">OLE-DB</span>, which can be used to query and update the legacy system. The wrapper is responsible for converting relational queries and updates into queries and updates on the legacy system.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When an organization decides to replace a legacy system with a new system, it may follow a process called <span class="s63">reverse engineering</span>, which consists of going over the code of the legacy system to come up with schema designs in the required data model (such as an <span class="s44">E-R </span>model or an object-oriented data model). Reverse engineering also examines the code to ﬁnd out what procedures and processes were implemented, in order to get a high-level model of the system. Reverse engineering is needed because legacy systems usually do not have high-level documentation of their schema and overall system design. When coming up with a new system, developers review the design so that it can be improved rather than just reimplemented as is. Extensive coding is required to support all the functionality (such as user interface and reporting systems) that was provided by the legacy system. The overall process is called <span class="s63">re-engineering</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When a new system has been built and tested, the system must be populated with data from the legacy system, and all further activities must be carried out on the new system. However, abruptly transitioning to a new system, which is called the <span class="s63">big-bang approach</span>, carries several risks. First, users may not be familiar with the interfaces of the new system. Second, there may be bugs or performance problems in the new system that were not discovered when it was tested. Such problems may lead to great losses for companies, since their ability to carry out critical transactions such as sales and purchases may be severely aﬀected. In some extreme cases the new system has even been abandoned, and the legacy system reused, after an attempted switchover failed.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">An alternative approach, called the <span class="s63">chicken-little approach</span>, incrementally re- places the functionality of the legacy system. For example, the new user inter- faces may be used with the old system in the back end, or vice versa. Another option is to use the new system only for some functionality that can be decou- pled from the legacy system. In either case, the legacy and new systems coex- ist for some time. There is therefore a need for developing and using wrappers on the legacy system to provide required functionality to interoperate with the new system. This approach therefore has a higher development cost.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part449.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part451.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
