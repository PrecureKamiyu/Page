<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>11.2   Data Warehousing</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part218.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part220.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">11.2   <span style=" color: #00AEEF;">Data Warehousing</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Large organizations have a complex internal organization structure, and therefore dif- ferent data may be present in diﬀerent locations, or on diﬀerent operational systems, or under diﬀerent schemas. For instance, manufacturing-problem data and customer- complaint data may be stored on diﬀerent database systems. Organizations often pur- chase data from external sources, such as mailing lists that are used for product pro- motions, or credit scores of customers that are provided by credit bureaus, to decide on creditworthiness of customers.<span class="s76">1</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Corporate decision makers require access to information from multiple such sources. Setting up queries on individual sources is both cumbersome and ineﬃcient.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_2374.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">1<span class="s78">Credit bureaus are companies that gather information about consumers from multiple sources and compute a credit- worthiness score for each consumer.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Moreover, the sources of data may store only current data, whereas decision makers may need access to past data as well; for instance, information about how purchase pat- terns have changed in the past few years could be of great importance. Data warehouses provide a solution to these problems.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A <span class="s63">data warehouse </span>is a repository (or archive) of information gathered from multi- ple sources, stored under a uniﬁed schema, at a single site. Once gathered, the data are stored for a long time, permitting access to historical data. Thus, data warehouses pro- vide the user a single consolidated interface to data, making decision-support queries easier to write. Moreover, by accessing information for decision support from a data warehouse, the decision maker ensures that online transaction-processing systems are not aﬀected by the decision-support workload.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">11.2.1 Components of a Data Warehouse</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Figure 11.1 shows the architecture of a typical data warehouse and illustrates the gath- ering of data, the storage of data, and the querying and data analysis support. Among the issues to be addressed in building a warehouse are the following:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>When and how to gather data. </b>In a <span class="s63">source-driven architecture </span>for gathering data, the data sources transmit new information, either continually (as transaction pro- cessing takes place), or periodically (nightly, for example). In a <span class="s63">destination-driven architecture</span>, the data warehouse periodically sends requests for new data to the sources.</p><p style="padding-left: 107pt;text-indent: 17pt;text-align: justify;">Unless updates at the sources are “synchronously” replicated at the warehouse, the warehouse will never be quite up-to-date with the sources. Synchronous repli- cation can be expensive, so many data warehouses do not use synchronous repli- cation, and they perform queries only on data that are old enough that they have</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="424" height="196" alt="image" src="Image_2375.png"/></span></p><p class="s33" style="text-indent: 0pt;line-height: 10pt;text-align: left;">data source 1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="text-indent: 5pt;line-height: 106%;text-align: left;">data loaders</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="text-indent: 0pt;line-height: 10pt;text-align: left;">data source 2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="text-indent: 0pt;line-height: 10pt;text-align: left;">DBMS</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="text-indent: 0pt;line-height: 107%;text-align: left;">query and analysis tools</p><p style="text-indent: 0pt;text-align: left;"/><p class="s280" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">data source <i>n</i></p><p class="s33" style="padding-top: 4pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">data warehouse</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 11.1 <span class="s74">Data-warehouse architecture.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;">been completely replicated. Traditionally, analysts were happy with using yester- day’s data, so data warehouses could be loaded with data up to the end of the previous day. However, increasingly organizations want more up-to-date data. The data freshness requirements depend on the application. Data that are within a few hours old may be suﬃcient for some applications; others that require real-time re- sponses to events may use stream processing infrastructure (described in Section 10.5) instead of depending on a warehouse infrastructure.</p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s46">What schema to use. </span><span class="p">Data sources that have been constructed independently are likely to have diﬀerent schemas. In fact, they may even use diﬀerent data models. Part of the task of a warehouse is to perform schema integration and to convert data to the integrated schema before they are stored. As a result, the data stored in the warehouse are not just a copy of the data at the sources. Instead, they can be thought of as a materialized view of the data at the sources.</span></p><p style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Data transformation and cleansing. </b>The task of correcting and preprocessing data is called <span class="s63">data cleansing</span>. Data sources often deliver data with numerous minor in- consistencies, which can be corrected. For example, names are often misspelled, and addresses may have street, area, or city names misspelled, or postal codes en- tered incorrectly. These can be corrected to a reasonable extent by consulting a database of street names and postal codes in each city. The approximate matching of data required for this task is referred to as <span class="s63">fuzzy lookup</span>.</p><p style="padding-left: 139pt;text-indent: 17pt;text-align: justify;">Address lists collected from multiple sources may have duplicates that need to be eliminated in a <span class="s63">merge–purge operation </span>(this operation is also referred to as <span class="s63">dedu- plication</span>). Records for multiple individuals in a house may be grouped together so only one mailing is sent to each house; this operation is called <span class="s63">householding</span>.</p><p style="padding-left: 139pt;text-indent: 17pt;text-align: justify;">Data may be <span class="s63">transformed </span>in ways other than cleansing, such as changing the units of measure, or converting the data to a diﬀerent schema by joining data from multiple source relations. Data warehouses typically have graphical tools to support data transformation. Such tools allow transformation to be speciﬁed as boxes, and edges can be created between boxes to indicate the ﬂow of data. Conditional boxes can route data to an appropriate next step in transformation.</p><p style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>How to propagate updates</b>. Updates on relations at the data sources must be propa- gated to the data warehouse. If the relations at the data warehouse are exactly the same as those at the data source, the propagation is straightforward. If they are not, the problem of propagating updates is basically the <i>view-maintenance </i>prob- lem, which was discussed in Section 4.2.3, and is covered in more detail in Section 16.5.</p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s46">What data to summarize. </span><span class="p">The raw data generated by a transaction-processing sys- tem may be too large to store online. However, we can answer many queries by maintaining just summary data obtained by aggregation on a relation, rather than maintaining the entire relation. For example, instead of storing data about every sale of clothing, we can store total sales of clothing by item name and category.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">The diﬀerent steps involved in getting data into a data warehouse are called <span class="s63">extract, transform, and load </span>or <span class="s64">ETL </span>tasks; extraction refers to getting data from the sources, while load refers to loading the data into the data warehouse. In current generation data warehouses that support user-deﬁned functions or MapReduce frameworks, data may be extracted, loaded into the warehouse, and then transformed. The steps are then referred to as <span class="s63">extract, load, and transform </span>or <span class="s64">ELT </span>tasks. The <span class="s44">ELT </span>approach permits the use of parallel processing frameworks for data transformation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">11.2.2 Multidimensional Data and Warehouse Schemas</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Data warehouses typically have schemas that are designed for data analysis, using tools such as <span class="s44">OLAP </span>tools. The relations in a data <span class="s63">warehouse schema </span>can usually be classi- ﬁed as <i>fact tables </i>and <i>dimension tables</i>. <span class="s63">Fact tables </span>record information about individual events, such as sales, and are usually very large. A table recording sales information for a retail store, with one tuple for each item that is sold, is a typical example of a fact table. The attributes in fact table can be classiﬁed as either <i>dimension attributes </i>or <i>measure attributes</i>, The <span class="s63">measure attributes </span>store quantitative information, which can be aggregated upon; the measure attributes of a <i>sales </i>table would include the number of items sold and the price of the items. In contrast, <span class="s63">dimension attributes </span>are dimensions upon which measure attributes, and summaries of measure attributes, are grouped and viewed. The dimension attributes of a <i>sales </i>table would include an item identiﬁer, the date when the item is sold, which location (store) the item was sold from, the customer who bought the item, and so on.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Data that can be modeled using dimension attributes and measure attributes are called <span class="s63">multidimensional data</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2376.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2377.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2378.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2379.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2380.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2381.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2382.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2383.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To minimize storage requirements, dimension attributes are usually short identi- ﬁers that are foreign keys into other tables called <span class="s63">dimension tables</span>. For instance, a fact table <i>sales </i>would have dimension attributes <i>item id</i>, <i>store id</i>, <i>customer id</i>, and <i>date</i>, and measure attributes <i>number </i>and <i>price</i>. The attribute <i>store id </i>is a foreign key into a dimen- sion table <i>store</i>, which has other attributes such as store location (city, state, country). The <i>item id </i>attribute of the <i>sales </i>table would be a foreign key into a dimension table <i>item info</i>, which would contain information such as the name of the item, the category to which the item belongs, and other item details such as color and size. The <i>customer id </i>attribute would be a foreign key into a <i>customer </i>table containing attributes such as name and address of the customer. We can also view the <i>date </i>attribute as a foreign key into a <i>date info </i>table giving the month, quarter, and year of each date.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2384.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2385.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The resultant schema appears in Figure 11.2. Such a schema, with a fact table, multiple dimension tables, and foreign keys from the fact table to the dimension tables is called a <span class="s63">star schema</span>. More complex data-warehouse designs may have multiple levels of dimension tables; for instance, the <i>item info </i>table may have an attribute <i>manufacturer id </i>that is a foreign key into another table giving details of the manufacturer. Such schemas are called <span class="s63">snowflake schemas</span>. Complex data-warehouse designs may also have more than one fact table.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="91" height="17" alt="image" src="Image_2386.png"/></span></p><p class="s99" style="padding-top: 3pt;padding-left: 12pt;text-indent: -2pt;text-align: left;"> store_id<span class="s69"> city state country</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 22pt;text-indent: 0pt;text-align: center;">store</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="89" height="17" alt="image" src="Image_2387.png"/></span></p><p class="s99" style="padding-top: 3pt;padding-left: 10pt;text-indent: 0pt;text-align: left;">item_id<span class="s69"> itemname color</span></p><p class="s69" style="padding-left: 10pt;text-indent: 0pt;text-align: left;">size category</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 15pt;text-indent: 0pt;line-height: 11pt;text-align: left;">item_info</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="167" height="28" alt="image" src="Image_2388.png"/></span></p><p class="s99" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">customer_id<span class="s69"> name</span></p><p class="s69" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">street city state zipcode country</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 17pt;text-indent: 0pt;text-align: left;">customer</p><p style="text-indent: 0pt;text-align: left;"/><p class="s99" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">item_id <span class="s69"> </span>store_id <span class="s69"> </span>customer_id<span class="s69"> </span>date <span class="s69"> number price</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: center;">sales</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="252" height="76" alt="image" src="Image_2389.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="180" height="108" alt="image" src="Image_2390.png"/></span></p><p class="s99" style="padding-top: 3pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">date <span class="s69"> month quarter year</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 14pt;text-indent: 0pt;line-height: 12pt;text-align: left;">date_info</p><p style="text-indent: 0pt;text-align: left;"/><p class="s73" style="padding-top: 4pt;padding-left: 201pt;text-indent: 0pt;text-align: left;">Figure 11.2 <span class="s74">Star schema for a data warehouse.</span></p><p class="s68" style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">11.2.3 Database Support for Data Warehouses</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The requirements of a database system designed for transaction processing are some- what diﬀerent from one designed to support a data-warehouse system. One key diﬀer- ence is that a transaction-processing database needs to support many small queries, which may involve updates in addition to reads. In contrast, data warehouses typically need to process far fewer queries, but each query accesses a much larger amount of data.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Most importantly, while new records are inserted into relations in a data ware- house, and old records may be deleted once they are no longer needed, to make space for new data, records are typically never updated once they are added to a relation. Thus, data warehouses do not need to pay any overhead for concurrency control. (As described in Chapter 17 and Chapter 18, if concurrent transactions read and write the same data, the resultant data may become inconsistent. Concurrency control restricts concurrent accesses in a way that ensures there is no erroneous update to the database.) The overhead of concurrency control can be signiﬁcant in terms of not just time taken for query processing, but also in terms of storage, since databases often store multiple versions of data to avoid conﬂicts between small update transactions and long read-only transactions. None of these overheads are needed in a data warehouse.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Databases traditionally store all attributes of a tuple together, and tuples are stored sequentially in a ﬁle. Such a storage layout is referred to as <i>row-oriented storage</i>. In con- trast, in <span class="s63">column-oriented storage</span>, each attribute of a relation is stored in a separate ﬁle, with values from successive tuples stored at successive positions in the ﬁle. Assuming ﬁxed-size data types, the value of attribute <i>A </i>of the <i>i</i>th tuple of a relation can be found</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">by accessing the ﬁle corresponding to attribute <i>A </i>and reading the value at oﬀset (<i>i </i><span class="s15">− </span>1) times the size (in bytes) of values in attribute <i>A</i>.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: left;">Column-oriented storage has at least two major beneﬁts over row-oriented storage:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 113pt;text-indent: -16pt;text-align: justify;">1. <span class="p">When a query needs to access only a few attributes of a relation with a large number of attributes, the remaining attributes need not be fetched from disk into memory. In contrast, in row-oriented storage, not only are irrelevant attributes fetched into memory, but they may also get prefetched into processor cache, wast- ing cache space and memory bandwidth, if they are stored adjacent to attributes used in the query.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">2. <span class="p">Storing values of the same type together increases the eﬀectiveness of compres- sion; compression can greatly reduce both the disk storage cost and the time to retrieve data from disk.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">On the other hand, column-oriented storage has the drawback that storing or fetching a single tuple requires multiple <span class="s44">I/O </span>operations.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As a result of these trade-oﬀs, column-oriented storage is not widely used for transaction-processing applications. However, column-oriented storage is today widely used for data-warehousing applications, where accesses are rarely to individual tuples but rather require scanning and aggregating multiple tuples. Column-oriented storage is described in more detail in Section 13.6.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Database implementations that are designed purely for data warehouse applica- tions include Teradata, Sybase IQ, and Amazon Redshift. Many traditional databases support eﬃcient execution of data warehousing applications by adding features such as columnar storage; these include Oracle, <span class="s44">SAP HANA</span>, Microsoft <span class="s44">SQL S</span>erver, and <span class="s44">IBM DB2</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In the 2010s there has been an explosive growth in Big Data systems that are de- signed to process queries over data stored in ﬁles. Such systems are now a key part of the data warehouse infrastructure. As we saw in Section 10.3, the motivation for such systems was the growth of data generated by online systems in the form of log ﬁles, which have a lot of valuable information that can be exploited for decision support. However, these systems can handle any kind of data, including relational data. Apache Hadoop is one such system, and the Hive system allows <span class="s44">SQL </span>queries to be executed on top of the Hadoop system.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A number of companies provide software to optimize Hive query processing, in- cluding Cloudera and Hortonworks. Apache Spark is another popular Big Data system that supports <span class="s44">SQL </span>queries on data stored in ﬁles. Compressed ﬁle structures contain- ing records with columns, such as Orc and Parquet, are increasingly used to store such log records, simplifying integration with <span class="s44">SQL</span>. Such ﬁle formats are discussed in more detail in Section 13.6.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;"><a name="bookmark231">11.2.4 Data Lakes</a><a name="bookmark248">&zwnj;</a></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">While data warehouses pay a lot of attention to ensuring a common data schema to ease the job of querying the data, there are situations where organizations want to store data without paying the cost of creating a common schema and transforming data to the common schema. The term <span class="s63">data lake </span>is used to refer to a repository where data can be stored in multiple formats, including structured records and unstructured ﬁle formats. Unlike data warehouses, data lakes do not require up-front eﬀort to preprocess data, but they do require more eﬀort when creating queries. Since data may be stored in many diﬀerent formats, querying tools also need to be quite ﬂexible. Apache Hadoop and Apache Spark are popular tools for querying such data, since they support querying of both unstructured and structured data.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part218.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part220.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
