<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>10.2 Don’t Forget Synchronization</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part106.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part108.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">10.2 Don’t Forget Synchronization</p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Given that the caches do all of this work to provide coherence, do pro- grams (or the OS itself) have to worry about anything when they access shared data? The answer, unfortunately, is yes, and is documented in great detail in the second piece of this book on the topic of concurrency. While we won’t get into the details here, we’ll sketch/review some of the basic ideas here (assuming you’re familiar with concurrency).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">When accessing (and in particular, updating) shared data items or structures across CPUs, mutual exclusion primitives (such as locks) should likely be used to guarantee correctness (other approaches, such as build- ing <b>lock-free </b>data structures, are complex and only used on occasion; see the chapter on deadlock in the piece on concurrency for details). For example, assume we have a shared queue being accessed on multiple CPUs concurrently. Without locks, adding or removing elements from the queue concurrently will not work as expected, even with the under- lying coherence protocols; one needs locks to atomically update the data structure to its new state.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">To make this more concrete, imagine this code sequence, which is used to remove an element from a shared linked list, as we see in Figure <span style=" color: #00AEEF;">10.3</span>. Imagine if threads on two CPUs enter this routine at the same time. If Thread 1 executes the first line, it will have the current value of <span class="s41">head </span>stored in its <span class="s41">tmp </span>variable; if Thread 2 then executes the first line as well, it also will have the same value of <span class="s41">head </span>stored in its own private <span class="s41">tmp </span>variable (<span class="s41">tmp </span>is allocated on the stack, and thus each thread will have its own private storage for it). Thus, instead of each thread removing an element from the head of the list, each thread will try to remove the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 5pt;padding-left: 26pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>typedef struct <span class="s75">&nbsp;</span>Node_t {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2     <span class="s38">int      value;</span></p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">3    </span>struct <span class="s75">&nbsp;</span>Node_t <span class="s39">*</span>next;</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">4  <span class="s38">} Node_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">5</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6  <span class="s38">int List_Pop() {</span></p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">7     </span>Node_t <span class="s39">*</span>tmp = head;    // remember old head ...</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;">8     <span class="s38">int value  = head-&gt;value; // ... and its value</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">9     <span class="s38">head   = head-&gt;next;  // advance head to next pointer</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10     <span class="s38">free(tmp);       // free old head</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11     <span class="s38">return value;      // return value at head</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12  <span class="s38">}</span></p><p style="padding-left: 110pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Figure 10.3: <b>Simple List Delete Code</b></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">same head element, leading to all sorts of problems (such as an attempted double free of the head element at line 4, as well as potentially returning the same data value twice).</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_111.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_112.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The solution, of course, is to make such routines correct via <b>lock- ing</b>. In this case, allocating a simple mutex (e.g., <span class="s41">pthread mutex t m;</span>) and then adding a <span class="s41">lock(&amp;m) </span>at the beginning of the routine and an <span class="s41">unlock(&amp;m) </span>at the end will solve the problem, ensuring that the code will execute as desired. Unfortunately, as we will see, such an approach is not without problems, in particular with regards to performance. Specifi- cally, as the number of CPUs grows, access to a synchronized shared data structure becomes quite slow.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part106.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part108.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
