<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>21.4 What If Memory Is Full?</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part218.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part220.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">21.4 What If Memory Is Full?</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In the process described above, you may notice that we assumed there is plenty of free memory in which to <b>page in </b>a page from swap space. Of course, this may not be the case; memory may be full (or close to it). Thus, the OS might like to first <b>page out </b>one or more pages to make room for the new page(s) the OS is about to bring in. The process of picking a page to kick out, or <b>replace </b>is known as the <b>page-replacement policy</b>.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As it turns out, a lot of thought has been put into creating a good page- replacement policy, as kicking out the wrong page can exact a great cost on program performance. Making the wrong decision can cause a pro- gram to run at disk-like speeds instead of memory-like speeds; in cur- rent technology that means a program could run 10,000 or 100,000 times slower. Thus, such a policy is something we should study in some detail; indeed, that is exactly what we will do in the next chapter. For now, it is good enough to understand that such a policy exists, built on top of the mechanisms described here.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2  <span class="s38">(Success, TlbEntry) = TLB_Lookup(VPN)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">if (Success == True) // TLB Hit</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4    <span class="s38">if (CanAccess(TlbEntry.ProtectBits) == True)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5       <span class="s38">Offset  = VirtualAddress &amp; OFFSET_MASK</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6       <span class="s38">PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7       <span class="s38">Register = </span><span class="s119">AccessMemory(PhysAddr)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8    <span class="s38">else</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9       <span class="s38">RaiseException(PROTECTION_FAULT)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10  <span class="s38">else       // TLB Miss</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">11     </span>PTEAddr = PTBR + (VPN <span class="s39">* </span>sizeof(PTE))</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">12    <span class="s38">PTE = </span><span class="s119">AccessMemory(PTEAddr)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">13    <span class="s38">if (PTE.Valid == False)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">14       <span class="s38">RaiseException(SEGMENTATION_FAULT)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">15    <span class="s38">else</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">16       <span class="s38">if (CanAccess(PTE.ProtectBits) == False)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">17          <span class="s38">RaiseException(PROTECTION_FAULT)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">18       <span class="s38">else if (PTE.Present == True)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">19          <span class="s38">// assuming hardware-managed TLB</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">20          <span class="s38">TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">21          <span class="s38">RetryInstruction()</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">22       <span class="s38">else if (PTE.Present == False)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">23          <span class="s38">RaiseException(PAGE_FAULT)</span></p><p style="padding-top: 5pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Figure 21.2: <b>Page-Fault Control Flow Algorithm (Hardware)</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part218.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part220.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
