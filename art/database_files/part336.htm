<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.8  Snapshot Isolation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part335.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part337.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">18.8  <span style=" color: #00AEEF;">Snapshot Isolation</span></p><p style="padding-top: 8pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Snapshot isolation is a particular type of concurrency-control scheme that has gained wide acceptance in commercial and open-source systems, including Oracle,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">P<span class="s43">ostgre</span>SQL<span class="s43">, and </span>SQL <span class="s43">Server. We introduced snapshot isolation in Section 17.9.3. Here, we take a more detailed look into how it works.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Conceptually, snapshot isolation involves giving a transaction a “snapshot” of the database at the time when it begins its execution. It then operates on that snapshot in complete isolation from concurrent transactions. The data values in the snapshot consist only of values written by committed transactions. This isolation is ideal for read-only transactions since they never wait and are never aborted by the concurrency manager.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Transactions that update the database potentially have conﬂicts with other transac- tions that update the database. Updates performed by a transaction must be validated before the transaction is allowed to commit. We describe how validation is performed, later in this section. Updates are kept in the transaction’s private workspace until the transaction is validated, at which point the updates are written to the database.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">When a transaction <i>T </i>is allowed to commit, the transition of <i>T </i>to the committed state and the writing of all of the updates made by <i>T </i>to the database must be concep- tually done as an atomic action so that any snapshot created for another transaction either includes all updates by transaction <i>T </i>or none of them.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">18.8.1 Multiversioning in Snapshot Isolation</p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;line-height: 94%;text-align: justify;">To implement snapshot isolation, transactions are given two timestamps. The ﬁrst timestamp, <i>StartTS</i>(<i>T</i><span class="s97">i</span>), is the time at which transaction <i>T</i><span class="s97">i </span>started. The second times- tamp, <i>CommitTS</i>(<i>T</i><span class="s97">i</span>) is the time when the transaction <i>T</i><span class="s97">i </span>requested validation.</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Note that timestamps can be wall clock time, as long as no two transactions are</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">given the same timestamp, but they are usually assigned from a counter that is incre- mented every time a transaction enters its validation phase.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Snapshot isolation is based on multiversioning, and each transaction that updates a data item creates a version of the data item. Versions have only one timestamp, which is the write timestamp, indicating when the version was created. The timestamp of a version created by transaction <i>T</i><span class="s97">i </span>is set to <i>CommitTS</i>(<i>T</i><span class="s97">i</span>). (Since updates to the database</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">are also only made after validation of the transaction <i>T</i><span class="s145">i</span>, <i>CommitTS</i>(<i>T</i><span class="s145">i</span>) is available</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">when a version is created.)<span class="s76">2</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 85%;text-align: justify;">When a transaction <i>T</i><span class="s145">i </span>reads a data item, the latest version of the data item whose timestamp is <span class="s86">≤ </span><i>StartTS</i>(<i>T</i><span class="s97">i</span>) is returned to <i>T</i><span class="s97">i</span>. Thus, <i>T</i><span class="s97">i </span>does not see the updates of any transactions that committed after <i>T</i><span class="s97">i </span>started, while it does see the updates of all transactions that commit before it started. As a result, <i>T</i><span class="s97">i </span>eﬀectively sees a snapshot of the database as of the time it started.<span class="s76">3</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_3021.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">2<span class="s78">Many implementations create versions even before the transaction starts validation; since the version timestamp is not available at this point, the timestamp is set to inﬁnity initially, and is updated to the correct value at the time of validation. Further optimizations are used in actual implementations, but we ignore them for simplicity.</span></p><p class="s77" style="padding-left: 119pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">3<span class="s78">To eﬃciently ﬁnd the correct version of a data item for a given timestamp, many implementations store not only</span></p><p class="s80" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">the timestamp when a version was created, but also the timestamp when the next version was created, which can be considered an <i>invalidation timestamp </i>for that version; the version is valid between the creation and invalidation timestamps. The current version of a data item has the invalidation timestamp set to inﬁnity.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">18.8.2 Validation Steps for Update Transactions</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Deciding whether or not to allow an update transaction to commit requires some care. Potentially, two transactions running concurrently might both update the same data item. Since these two transactions operate in isolation using their own private snap- shots, neither transaction sees the update made by the other. If both transactions are allowed to write to the database, the ﬁrst update written will be overwritten by the second. The result is a <span class="s63">lost update</span>. This must be prevented. There are two variants of snapshot isolation, both of which prevent lost updates. They are called <i>first committer wins </i>and <i>first updater wins</i>. Both approaches are based on testing the transaction against concurrent transactions.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A transaction <i>T</i><span class="s145">j </span>is said to be <span class="s63">concurrent with </span>a given transaction <i>T</i><span class="s145">i </span>if it was active or partially committed at any point from the start of <i>T </i>up to the point when validation of <i>T</i><span class="s97">i </span>started. Formally, <i>T</i><span class="s97">j </span>is concurrent with <i>T</i><span class="s97">i </span>if either</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 14pt;text-align: left;">StartTS<span class="p">(</span>T<span class="s97">j </span><span class="p">) </span><span class="s86">≤ </span>StartTS<span class="p">(</span>T<span class="s97">i</span><span class="p">) </span><span class="s86">≤ </span>CommitTS<span class="p">(</span>T<span class="s97">j </span><span class="p">), or</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 16pt;text-align: left;">StartTS<span class="p">(</span>T<span class="s97">i</span><span class="p">) </span><span class="s86">≤ </span>StartTS<span class="p">(</span>T<span class="s97">j </span><span class="p">) </span><span class="s86">≤ </span>CommitTS<span class="p">(</span>T<span class="s97">i</span><span class="p">).</span></p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">Under <span class="s63">first committer wins</span>, when a transaction <i>T</i><span class="s97">i </span>starts validation, the following actions are performed as part of validation, after its <i>CommitTS </i>is assigned. (We assume for simplicity that only one transaction performs validation at a time, although real</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">implementations do support concurrent validation.)</p><p class="s13" style="padding-top: 6pt;padding-left: 107pt;text-indent: -16pt;line-height: 93%;text-align: left;"><span class="s39">• </span><span class="s40">A test is made to see if any transaction that was concurrent with </span>T <span class="p">has already written an update to the database for some data item that </span>T <span class="p">intends to write. This can be done by checking for each data item </span>d <span class="p">that </span>T<span class="s97">i </span><span class="p">intends to write, whether there is a version of the data item </span>d <span class="p">whose timestamp is between </span>StartTS<span class="p">(</span>T<span class="s97">i</span><span class="p">) and </span>CommitTS<span class="p">(</span>T<span class="s97">i</span><span class="p">).</span><span class="s76">4</span></p><p class="s39" style="padding-left: 91pt;text-indent: 0pt;line-height: 17pt;text-align: left;">• <span class="s40">If any such data item is found, then </span><span class="s13">T</span><span class="s97">i </span><span class="p">aborts.</span></p><p class="s39" style="padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">If no such data item is found, then </span><span class="s13">T </span><span class="p">commits and its updates are written to the database.</span></p><p style="padding-top: 8pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">This approach is called “ﬁrst committer wins” because if transactions conﬂict, the ﬁrst one to be tested using the above rule succeeds in writing its updates, while the subse- quent ones are forced to abort. Details of how to implement these tests are addressed in Exercise 18.15.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Under <span class="s63">first updater wins</span>, the system uses a locking mechanism that applies only to updates (reads are unaﬀected by this, since they do not obtain locks). When a trans- action <i>T</i><span class="s97">i </span>attempts to update a data item, it requests a <i>write lock </i>on that data item. If</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">the lock is not held by a concurrent transaction, the following steps are taken after the</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">lock is acquired:</p><p class="s39" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">If the item has been updated by any concurrent transaction, then </span><span class="s13">T</span><span class="s97">i </span><span class="p">aborts.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_3022.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">4<span class="s78">There are alternative implementations, based on keeping track of read and write sets for transactions.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: left;">• <span class="s40">Otherwise </span><span class="s13">T</span><span class="s145">i </span><span class="p">may proceed with its execution, including possibly committing.</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;line-height: 90%;text-align: justify;">If, however, some other concurrent transaction <i>T</i><span class="s145">j </span>already holds a write lock on that data item, then <i>T</i><span class="s145">i </span>cannot proceed, and the following rules are followed:</p><p class="s13" style="padding-top: 8pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span>T<span class="s145">i </span><span class="p">waits until </span>T<span class="s145">j </span><span class="p">aborts or commits.</span></p><p class="s13" style="padding-top: 6pt;padding-left: 153pt;text-indent: -8pt;line-height: 77%;text-align: left;"><span class="s50">° </span><span class="s51">If </span>T<span class="s145">j </span><span class="p">aborts, then the lock is released and </span>T<span class="s145">i </span><span class="p">can obtain the lock. After the lock is acquired, the check for an update by a concurrent transaction is performed</span></p><p style="padding-top: 1pt;padding-left: 153pt;text-indent: 0pt;line-height: 87%;text-align: left;">as described earlier: <i>T</i><span class="s97">i </span>aborts if a concurrent transaction had updated the data item, and it proceeds with its execution otherwise.</p><p class="s13" style="padding-top: 5pt;padding-left: 145pt;text-indent: 0pt;text-align: left;"><span class="s50">° </span><span class="s51">If </span>T<span class="s97">j </span><span class="p">commits, then </span>T<span class="s97">i </span><span class="p">must abort.</span></p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Locks are released when the transaction commits or aborts.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">This approach is called “ﬁrst updater wins” because if transactions conﬂict, the ﬁrst one to obtain the lock is the one that is permitted to commit and perform its update. Those that attempt the update later abort unless the ﬁrst updater subsequently aborts for some other reason. (As an alternative to waiting to see if the ﬁrst updater <i>T</i><span class="s145">j </span>aborts, a subsequent updater <i>T</i><span class="s145">i </span>can be aborted as soon as it ﬁnds that the write lock it wishes to obtain is held by <i>T</i><span class="s97">j </span>.)</p><p class="s68" style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">18.8.3 Serializability Issues and Solutions</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Snapshot isolation is attractive in practice because transactions that read a lot of data (typically for data analysis) do not interfere with shorter update transactions (typi- cally used for transaction processing). With two-phase locking, such long read-only transactions would block update transactions for long periods of time, which is often unacceptable.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">It is worth noting that integrity constraints that are enforced by the database, such as primary-key and foreign-key constraints, cannot be checked on a snapshot; other- wise it would be possible for two concurrent transactions to insert two tuples with the same primary key value, or for a transaction to insert a foreign key value that is con- currently deleted from the referenced table. This problem is handled by checking these constraints on the current state of the database, rather than on the snapshot, as part of validation at the time of commit.</p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;"><span class="p">Even with the above ﬁx, there is still a serious problem with the snapshot isolation scheme as we have presented it and as it is implemented in practice: </span>snapshot isolation does <b>not </b>ensure serializability!</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Next we give examples of possible nonserializable executions under snapshot iso- lation. We then outline the <i>serializable snapshot isolation </i>technique that is supported by some databases, which extends the snapshot isolation technique to ensure serializ- ability. Snapshot isolation implementations that do not support serializable snapshot isolation often support <span class="s44">SQL </span>extensions that allow the programmer to ensure serializ- ability even with snapshot isolation; we study these extensions at the end of the section.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:221.214pt" cellspacing="0"><tr style="height:18pt"><td style="width:52pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p class="s71" style="padding-top: 2pt;padding-left: 20pt;padding-right: 21pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s364">i</span></p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F" bgcolor="#C6E9FA"><p class="s71" style="padding-top: 2pt;padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s364">j</span></p></td></tr><tr style="height:18pt"><td style="width:52pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>A</i>)</p></td><td style="width:53pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:13pt"><td style="width:52pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>B</i>)</p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:13pt"><td style="width:52pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>A</i>)</p></td></tr><tr style="height:13pt"><td style="width:52pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>B</i>)</p></td></tr><tr style="height:13pt"><td style="width:52pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;">A=B</p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:13pt"><td style="width:52pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;">B=A</p></td></tr><tr style="height:13pt"><td style="width:52pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">write</span>(<i>A</i>)</p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:52pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">write</span>(<i>B</i>)</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 18.20 <span class="s74">Nonserializable schedule under snapshot isolation.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">Consider the transaction schedule shown in Figure 18.20. Two concurrent trans- actions </span>T<span class="s145">i </span><span class="p">and </span>T<span class="s145">j </span><span class="p">both read data items </span>A <span class="p">and </span>B<span class="p">. </span>T<span class="s145">i </span><span class="p">sets </span>A <span class="s15">= </span>B <span class="p">and writes </span>A<span class="p">, while </span>T<span class="s145">j </span><span class="p">sets </span>B <span class="s15">= </span>A <span class="p">and writes </span>B<span class="p">. Since </span>T<span class="s145">i </span><span class="p">and </span>T<span class="s145">j </span><span class="p">are concurrent, under snapshot isolation neither transaction sees the update by the other in its snapshot. But, since they update diﬀerent data items, both are allowed to commit regardless of whether the system uses the ﬁrst-update-wins policy or the ﬁrst-committer-wins policy.</span></p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">However, the execution is not serializable, since it results in swapping of the values of <i>A </i>and <i>B</i>, whereas any serializable schedule would set both <i>A </i>and <i>B </i>to the same value: either the initial value of <i>A </i>or the initial value of <i>B</i>, depending on the order of <i>T</i><span class="s145">i </span>and <i>T</i><span class="s145">j </span>.</p><p style="padding-left: 123pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">It can be easily seen that the precedence graph has a cycle. There is an edge</p><p style="padding-top: 1pt;padding-left: 107pt;text-indent: 0pt;line-height: 87%;text-align: justify;">in the precedence graph from <i>T</i><span class="s97">i </span>to <i>T</i><span class="s97">j </span>because <i>T</i><span class="s97">i </span>reads the value of <i>A </i>that existed before <i>T</i><span class="s97">j </span>writes <i>A</i>. There is also an edge in the precedence graph from <i>T</i><span class="s97">j </span>to <i>T</i><span class="s97">i </span>because <i>T</i><span class="s97">j </span>reads the value of <i>B </i>that existed before <i>T</i><span class="s97">i </span>writes <i>B</i>. Since there is a cycle in the precedence graph, the result is a nonserializable schedule.</p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">This situation, where each of a pair of transactions has read a data item that is written by the other, but the set of data items written by the two transactions do not have any data item in common, is referred to as <span class="s63">write skew</span>.</p><p class="s13" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">As another example of write skew, consider a banking scenario. Suppose that the bank enforces the integrity constraint that the sum of the balances in the checking and the savings account of a customer must not be negative. Suppose the checking and savings balances for a customer are $100 and $200, respectively. Suppose that transaction </span>T<span class="s98">36</span><span class="p"> withdraws $200 from the checking account, after verifying the in- tegrity constraint by reading both balances. Suppose that concurrently transaction </span>T<span class="s98">37</span><span class="p"> withdraws $200 from the savings account, again after verifying the integrity constraint. Since each of the transactions checks the integrity constraint on its own snapshot, if they run concurrently each will believe that the sum of the bal- ances after the withdrawal is $100, and therefore its withdrawal does not violate</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: right;">the constraint. Since the two transactions update diﬀerent data items, they do not have any update conﬂict, and under snapshot isolation both of them can commit.</p><p class="s13" style="padding-left: 139pt;text-indent: 14pt;line-height: 94%;text-align: justify;"><span class="p">Unfortunately, in the ﬁnal state after both </span>T<span class="s130">36 </span><span class="s94">and </span>T<span class="s130">37 </span><span class="s94">have committed, the sum of the balances is $100, violating the integrity constraint. Such a violation could never have occurred in any serial execution of </span>T<span class="s130">36 </span><span class="s94">and </span>T<span class="s130">37</span><span class="s94">.</span></p><p class="s39" style="padding-top: 1pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Many ﬁnancial applications create consecutive sequence numbers, for example to number bills, by taking the maximum current bill number and adding 1 to the value to get a new bill number. If two such transactions run concurrently, each would see the same set of bills in its snapshot, and each would create a new bill with the same number. Both transactions pass the validation tests for snapshot isolation, since they do not update any tuple in common. However, the execution is not serializable; the resultant database state cannot be obtained by any serial execution of the two transactions. Creating two bills with the same number could have serious legal implications.</span></p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">The above problem is in fact an example of the phantom phenomenon, which we saw in Section 18.4.3, since the insert performed by each transaction conﬂicts with the read performed by the other transaction to ﬁnd the maximum bill number, but the conﬂict is not detected by snapshot isolation.<span class="s76">5</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The problems listed above seem to indicate that the snapshot isolation technique is vulnerable to many serializability problems and should never be used. However, se- rializability problems are relatively rare for two reasons:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span class="p">The fact that the database must check integrity constraints at the time of com- mit, and not on a snapshot, helps avoid inconsistencies in many situations. For example, in the ﬁnancial application example that we saw earlier, the bill number would likely have been declared as a primary key. The database system would detect the primary key violation outside the snapshot and roll back one of the two transactions.</span></p><p style="padding-left: 145pt;text-indent: 15pt;text-align: justify;">It was shown that primary key constraints ensured that all transactions in a popular transaction processing benchmark, <span class="s44">TPC-C</span>, were free from nonserializ- ability problems, when executed under snapshot isolation. This was viewed as an indication that such problems are rare. However, they do occur occasionally, and when they occur they must be dealt with.<span class="s76">6</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span class="p">In many applications that are vulnerable to serializability problems, such as skew writes, on some data items, the transactions conﬂict on other data items, ensuring</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_3023.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s77">5</span>The <span class="s153">SQL </span>standard uses the term <i>phantom problem </i><span class="s80">to refer to nonrepeatable predicate reads, leading some to claim that snapshot isolation avoids the phantom problem; however, such a claim is not valid under our deﬁnition of phantom conﬂict.</span></p><p class="s77" style="padding-left: 119pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">6<span class="s78">For example, the problem of duplicate bill numbers actually occurred several times in a ﬁnancial application in I.I.T.</span></p><p class="s80" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Bombay, where (for reasons too complex to discuss here) the bill number was not a primary key, and it was detected by ﬁnancial auditors.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 113pt;text-indent: 0pt;text-align: left;">such transactions cannot execute concurrently; as a result, the execution of such transactions under snapshot isolation remains serializable.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Nonserializable may nevertheless occur with snapshot isolation. The impact of nonserializable execution due to snapshot isolation is not very severe for many applica- tions. For example, consider a university application that implements enrollment limits for a course by counting the current enrollment before allowing registration. Snapshot isolation could allow the class enrollment limit to be exceeded. However, this may hap- pen very rarely, and if it does, having one extra student in a class is usually not a major problem. The fact that snapshot isolation allows long read transactions to execute with- out blocking updaters is a large enough beneﬁt for many such applications to live with occasional glitches.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Nonserializability may not be acceptable for many other applications, such as ﬁ- nancial applications. There are several possible solutions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">A modiﬁed form of snapshot isolation, called serializable snapshot isolation, can be used if it is supported by the database system. This technique extends the snap- shot isolation technique in a way that ensures serializability.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Some systems allow diﬀerent transactions to run under diﬀerent isolation levels, which can be used to avoid the serializability problems mentioned above.</span></p><p class="s40" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>Some systems that support snapshot isolation provide a way for <span class="s41">SQL </span>programmers to create artiﬁcial conﬂicts, using a <b>for update </b><span class="p">clause in </span><span class="s44">SQL</span><span class="p">, which can be used to ensure serializability.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">We brieﬂy outline each of these solutions below.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Since version 9.1, <span class="s44">P</span>ostgre<span class="s44">SQL </span>implements a technique called serializable snapshot isolation, which ensures serializability; in addition, <span class="s44">P</span>ostgre<span class="s44">SQL </span>versions from 9.1 on- wards include an index-locking-based technique to provide protection against phantom problems.</p><p class="s13" style="padding-left: 88pt;text-indent: 17pt;line-height: 13pt;text-align: justify;"><span class="p">The intuition behind the </span><span class="s63">serializable snapshot isolation </span><span class="p">(</span><span class="s63">SSI</span><span class="p">) protocol is as follows: Suppose we track all conﬂicts (i.e., write-write, read-write, and write-read conﬂicts) between transactions. Recall from Section 17.6 that we can construct a transaction precedence graph which has a directed edge from </span>T<span class="s130">1 </span><span class="s94">to </span>T<span class="s130">2 </span><span class="s94">if transactions </span>T<span class="s130">1 </span><span class="s94">and </span>T<span class="s130">2 </span><span class="s94">have conﬂicting operations on a tuple, with </span>T<span class="s98">1</span><span class="p">’s action preceding </span>T<span class="s98">2</span><span class="p">’s action. As we saw in Section 17.6, one way to ensure serializability is to look for cycles in the transaction precedence graph and roll back transactions if a cycle is found.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The key reason for loss of serializability with snapshot isolation is that read-write conﬂicts, where a transaction <i>T</i><span class="s98">1</span> writes a version of an object, and a transaction <i>T</i><span class="s98">2</span> sub- sequently reads an earlier version of the object, are not tracked by snapshot isolation. This conﬂict can be represented by a read-write conﬂict edge from <i>T</i><span class="s98">2</span> to <i>T</i><span class="s98">1</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">It has been shown that in all cases where snapshot isolation allows nonserializable schedules, there must be a transaction that has both an incoming read-write conﬂict</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">edge and an outgoing read-write conﬂict edge (all other cases of cycles in the conﬂict graph are caught by the snapshot isolation rules). Thus, serializable snapshot isolation implementations track all read-write conﬂicts between concurrent transactions to de- tect if a transaction has both an incoming and an outgoing read-write conﬂict edge. If such a situation is detected, one of the transactions involved in the read-write conﬂicts is rolled back. This check is signiﬁcantly cheaper than tracking all conﬂicts and looking for cycles, although it may result in some unnecessary rollbacks.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">It is also worth mentioning that the technique used by <span class="s44">P</span>ostgre<span class="s44">SQL </span>to prevent phan- toms uses index locking, but the locks are not held in a two-phase manner. Instead, they are used to detect potential conﬂicts between concurrent transactions and must be re- tained for some time even after a transaction commits, to allow checks against other concurrent transactions. The index-locking technique used by <span class="s44">P</span>ostgre<span class="s44">SQL </span>also does not result in any deadlocks.</p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">Server oﬀers the option of allowing some transactions to run under </span>snapshot <span class="p">isolation, while allowing others to run under the </span>serializable <span class="p">isolation level. Running long read-only transactions under the snapshot isolation level while running update transactions under the serializable isolation level ensures that the read-only transaction does not block updaters, while also ensuring that the above anomalies cannot occur.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In Oracle versions till at least Oracle 12c (to the best of our knowledge), and in <span class="s44">P</span>ostgre<span class="s44">SQL </span>versions prior to 9.1, the <i>serializable </i>isolation level actually implements snapshot isolation. As a result, even with the isolation level set to serializable, it is possible that the database permits some schedules that are not serializable.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If an application has to run under snapshot isolation, on several of these databases an application developer can guard against certain snapshot anomalies by appending a <b>for update </b>clause to the <span class="s44">SQL </span>select query as illustrated below:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 268pt;text-indent: 0pt;text-align: left;">select <span class="p">*</span></p><p class="s46" style="padding-left: 268pt;text-indent: 0pt;text-align: left;">from <i>instructor </i>where <span class="s42">ID </span><span class="s43">= 22222 </span>for update<span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 122pt;text-indent: 0pt;text-align: right;">Adding the <b>for update </b>clause causes the system to treat data that are read as if they had been updated for purposes of concurrency control. In our ﬁrst example of write skew shown in Figure 18.20, if the <b>for update </b>clause were appended to the select queries that read the values of <i>A </i>and <i>B</i>, only one of the two concurrent transactions would be allowed to commit since it appears that both transactions have updated both <i>A </i>and <i>B</i>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Formal methods exist (see the online bibliographical notes) to determine whether a given mix of transactions runs the risk of nonserializable execution under snapshot isolation and to decide on what conﬂicts to introduce (using the <b>for update </b>clause, for example) to ensure serializability. Such methods can work only if we know in advance what transactions are being executed. In some applications, all transactions are from a predetermined set of transactions, making this analysis possible. However, if the appli- cation allows unrestricted, ad hoc transactions, then no such analysis is possible.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part335.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part337.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
