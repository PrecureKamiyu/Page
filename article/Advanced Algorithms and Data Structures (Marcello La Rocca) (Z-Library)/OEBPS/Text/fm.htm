<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <div class="tocheadb">
    <h1 class="tochead" id="heading_id_2">front matter</h1>
  </div>

  <h2 class="fm-head" id="heading_id_3"><a id="pgfId-1017768"></a>foreword</h2>

  <p class="body"><a id="pgfId-1017769"></a>Algorithms and data structures lie at the very heart of the intersection between the beauty of theory and the excitement of cutting-edge technology. One can say that if the body of the advancements in computation is hardware, then the mind is certainly the study of algorithms and data structures. Many of the recent advances in technology have come to life thanks to the effective use of computing resources to solve problems, and this is often due to the effective development and implementation of algorithms and clever use of data structures.</p>

  <p class="body"><a id="pgfId-1017770"></a>A computer scientist, a software developer, a data scientist, or anyone whose work is dependent on the power of computation needs to be fluent in the language of algorithms and data structures. It is for this reason that problems in this field are some of the most common in interviews for companies in Silicon Valley or similar technology sectors.</p>

  <p class="body"><a id="pgfId-1017771"></a>It is quite difficult, even for experts, to learn and remember all the details of all the algorithms in existence. However, it is important to have a good intuition about them in such a way that one can use them as building blocks to create larger projects or to solve problems. In order to master this intuition, one must develop a rigid theoretical and mathematical base, solid programming knowledge, and a strong understanding of the core concepts.</p>

  <p class="body"><a id="pgfId-1017772"></a>Building this intuition is precisely what <i class="calibre17">Advanced Algorithms and Data Structures</i> does so well. In this book, Marcello combines the rigidity of the theory with the versatility of the practical application, painted with the strokes of a colorful narrative full of enjoyable stories and real-life examples.</p>

  <p class="body"><a id="pgfId-1017773"></a>Marcello also uses his extensive experience as a developer at some of the most prominent technology companies and as a researcher in machine learning to give the reader a very clear, concise, and thorough picture of some of the most important algorithms and data structures used across industries and research fields.</p>

  <p class="body"><a id="pgfId-1017774"></a>With a one-size-fits-all approach, a friendly language, and fun analogies, Marcello manages to lift the curtain and demystify complicated topics such as map reduce, genetic algorithms, and simulated annealing, with the same ease as he exposes the basics of trees and heaps. Certainly a must-read for anyone who wants to get a solid understanding of the building principles of computer science. The only question in my head after reading <i class="calibre17">Advanced Algorithms and Data Structures</i> was, “Where was this book when I was preparing for my first Silicon Valley interview?”</p>

  <p class="fm-head1"><a id="pgfId-1017775"></a>Luis Serrano, PhD</p>

  <p class="fm-head1"><a id="pgfId-1017776"></a>Research Scientist in Quantum Artificial Intelligence</p>

  <p class="fm-head1"><a id="pgfId-1017777"></a>Zapata Computing</p>

  <h2 class="fm-head" id="heading_id_4"><a id="pgfId-1017778"></a>preface</h2>

  <h3 class="fm-head2" id="heading_id_5"><a id="pgfId-1017780"></a><a id="id_Toc513656055"></a>Welcome to Advanced Algorithms and Data Structures</h3>

  <p class="body"><a id="pgfId-1017781"></a>It’s great to have you on board for this journey into the world of data structures and algorithms. I hope this will be as exciting a journey for you as it was for us.</p>

  <p class="body"><a id="pgfId-1017783"></a>The topics discussed in this book have contributed to advancing software engineering and have changed the world around us. They still do make a difference, and on average, you likely come in contact every day with dozens of devices and services using these algorithms.</p>

  <p class="body"><a id="pgfId-1017784"></a>The study of algorithms far predates the dawn of computer science: think about the Euler algorithm and the whole field of graph theory, which are three centuries old. But that’s nothing compared to the two millennia since the sieve of <a id="id_Hlk55399091"></a>Eratosthenes (used to make tables of prime numbers) was first conceived.</p>

  <p class="body"><a id="pgfId-1017786"></a>And yet, for a long time in the computer era, algorithms were mostly relegated to academia, with a few notable exceptions like Bell Labs, where between the 1950s and the 1990s their R&amp;D teams produced great advancements in the field, such as (to name a few) dynamic programming, the <a id="id_Hlk55399216"></a>Bellman-Ford algorithm, and convolutional neural networks for image recognition.</p>

  <p class="body"><a id="pgfId-1017788"></a>Luckily, many things have changed since those days. In the new millennium, mathematicians and computer scientists are increasingly sought by the largest software companies, new fields like machine learning have emerged, others like Artificial Intelligence (AI) and neural networks have regained interest after a <i class="calibre17">long winter</i>, and top experts in these fields are now among the best paid positions in the entire software engineering industry.</p>

  <p class="body"><a id="pgfId-1017789"></a>Personally, I became fascinated by algorithms in college—I had already studied search and sorting algorithms in high school—but it wasn’t until I learned about trees and graphs that I became aware of the difference they can make and how much I liked these topics.</p>

  <p class="body"><a id="pgfId-1017790"></a>It was the first time I had a feeling that writing code that worked was not the only goal, nor the main goal. How it works, how efficiently it runs, and how clean it is can be just as important, if not more so. (Unfortunately, I still had to wait a couple more years to have the same epiphany about testing.)</p>

  <p class="body"><a id="pgfId-1017791"></a>Writing this book was a lot of work, far more than I anticipated four years ago when I first pitched the idea to an editor. The story of how it came to be published is quite funny (well, at least in retrospect!), but I won’t bother you with it here. Just know that while writing this book I went through four years, three jobs (and a half!), two countries, and five different apartments!</p>

  <p class="body"><a id="pgfId-1017792"></a>It took a great (team) effort, for sure, but it was also rewarding. First and foremost, writing a book means starting a growth path, because it doesn’t matter how long you’ve worked on a topic and how well you think you know it. To write about any topic, you’ll be forced to question all you know about it, delve into details you might have overlooked when you previously applied it, and spend a lot of time researching, digesting, and processing the concepts until you are confident enough to explain them to someone who doesn’t know anything about the subject. Usually a good test is getting someone in your family who doesn’t work in that field and forcing them to listen to you while you unravel your lecture. Just make sure you choose someone very patient.</p>

  <h2 class="fm-head" id="heading_id_6"><a id="pgfId-1017793"></a>acknowledgments</h2>

  <p class="body"><a id="pgfId-1017794"></a>There are quite a few people I’d like to thank for helping me along the way.</p>

  <p class="body"><a id="pgfId-1017795"></a>I’d like to acknowledge my editors at Manning: Helen Stergius, who had the unenviable task of helping me transition my manuscript from its original draft to Manning’s standards, and Jennifer Stout, who worked on this project for the last couple of years. Without their help, it would have been impossible to get this to the goal. It was a pleasure working with you both. Thank you for your help, your invaluable advice, and your patience! I feel that by working with you, I learned a lot about the best way to write about a topic, teach, and address readers, and you have made this book better for everyone who reads it.</p>

  <p class="body"><a id="pgfId-1017796"></a>Next, I’d like to thank both the technical editors who worked on this book.</p>

  <p class="body"><a id="pgfId-1017797"></a>A huge thank you to Arthur Zubarev, who joined the team a couple of years ago, providing a ton of great feedback and always giving voice to my critical conscience. Working with you has been a pleasure and an honor.</p>

  <p class="body"><a id="pgfId-1017798"></a>A special shout-out goes to my friend Aurelio De Rosa. I had the privilege to have him as an editor on a JavaScript blog, on which we both wrote long before this book got started. Besides teaching me so much about technical writing, his contribution to this book is huge. He was its first technical editor and set the course for the whole book, discussed the topics to include, and reviewed the code. In addition to that, he also introduced me to Manning when I was looking for a publisher for my draft.</p>

  <p class="body"><a id="pgfId-1018642"></a>Thanks as well to all the other folks at Manning who worked with me on the production and promotion of the book: Deirdre Hiam, my project editor; Katie Petito, my copyeditor; Melody Dolab, my page proofer; and Aleksandar Dragosavljevic, my reviewing editor. It was truly a team effort. And thanks to the reviewers: Andrei Formiga, Christoffer Fink, Christopher Haupt, David T. Kerns, Eddu Melendez, George Thomas, Jim Amrhein, John Montgomery, Lucas Gerardo Tettamanti, Maciej Jurkowski, Matteo Gildone, Michael Jensen, Michael Kumm, Michelle Williamson, Rasmus Kirkeby Strøbæk, Riccardo Noviello, Rich Ward, Richard Vaughan, Timmy Jose, Tom Jenice, Ursula Cervantes, Vincent Zaballa, and Zachary Fleischmann who took the time to read my manuscript at various stages during its development and who provided invaluable feedback.</p>

  <p class="body"><a id="pgfId-1017800"></a>I couldn’t wrap this up without thanking my family and friends, as they have all been supportive and patient during these years. I’m not sure if I’ve mentioned this already (have I?), but writing this book was quite an effort! If you ever try the experience, you’ll see it will mean giving up many evenings, holidays, and weekends, where instead of going to the lake or having a beer with friends—or just doing your chores—you need to focus and work on the manuscript. I couldn’t have done this without the help and patience of my closest ones—and now I’ll have to make up for all the time together that we missed (and for all those chores I skipped)!</p>

  <p class="body"><a id="pgfId-1017801"></a>Finally, I need two special mentions, to special people who allowed me to be the computer scientist I am today.</p>

  <p class="body"><a id="pgfId-1017803"></a>First, I’d like to thank my former professors at the <a id="id_Hlk55399769"></a>University of Catania. For the sake of brevity, I can only individually thank my mentors, Prof. Gallo, Prof. Cutello, and Prof. Pappalardo, but I have a really long list of names, and I’d probably still leave someone out. I feel that, in a time where the usefulness of college degrees is being questioned in favor of quicker, more practical alternatives, it’s important to give recognition to the outstanding job carried out by my former instructors and by my alma mater over the years. MOOCs and code camps are great alternatives, and they are a step in the direction of a more affordable and democratic education regardless of location and status, but one thing that I feel I would have missed without my college experience is the development of a critical attitude, a scientist mentality of learning how to reason on problems and getting a broader skillset than just the bare minimum needed to land a job.</p>

  <p class="body"><a id="pgfId-1017804"></a>I must admit that I, too, was skeptical about some of the courses in my curriculum, like the one on linear algebra, because I couldn’t see how to apply them as a developer. A few years after my graduation, I started studying machine learning and then all that math came in handy and gave me an advantage.</p>

  <p class="body"><a id="pgfId-1017805"></a>The last mention has to be for the one who supported me through my early life and my studies: my mother who, at the price of many sacrifices, raised me and sustained me through the years of my education, allowing me to follow my passion. Her support enabled me to reach all the goals in my career, including writing this book, and so, in a way, she shares the credit for all its good parts.</p>

  <h2 class="fm-head" id="heading_id_7"><a id="pgfId-1017806"></a>about this book</h2>

  <p class="body"><a id="pgfId-1017809"></a>I can give you at least three good reasons to invest your time in learning algorithms:</p>

  <ol class="calibre18">
    <li class="fm-list-numbered">
      <p class="list"><a class="calibre14" id="pgfId-1017810"></a><i class="calibre15">Performance</i>—Choosing the right algorithm can speed your application up dramatically. Just limiting to something as simple as search, we’ll see that there is a huge gain going from linear search to binary search.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1017811"></a><i class="calibre15">Security</i>—If you choose the wrong algorithm, an attacker can use it to crash your server, node, or application. Consider, for instance, the hash DoS attack,<a class="calibre14" href="#pgfId-1017815"><sup class="footnotenumber">1</sup></a> where the use of a hash table as a dictionary to store variables sent with <i class="calibre15">POST</i> requests was leveraged to overload it with a sequence causing a huge number of collisions. This in turn would make a server unresponsive. Another interesting example was how flawed random number generators<a class="calibre14" href="#pgfId-1017818"><sup class="footnotenumber">2</sup></a> allowed the hacking of online poker sites.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1017820"></a><i class="calibre15">Efficiency in designing code</i>—If you already know that there are building blocks for whatever you’d like to accomplish, you will be faster in developing it, and the result will be cleaner (especially if you reuse code).</p>
    </li>
  </ol>

  <p class="body"><a id="pgfId-1017821"></a>That said, why should you read <i class="calibre17">this</i> book? I believe one great reason is that we are striving to select and present in the same book a strategic pool of advanced algorithms that will help developers improve their code and face some of the challenges of modern systems.</p>

  <p class="body"><a id="pgfId-1017822"></a>Moreover, we are trying to use a different approach than the usual college textbook. Like those books, we will explain the theory behind algorithms, but at the same time, we will also try to give you some context about real-world applications that leverage each algorithm we describe and situations where it is advisable to use them.</p>

  <p class="body"><a id="pgfId-1017824"></a>In your daily work, you’ll often have to deal with small, specific parts of larger (possibly legacy) software. However, in your career, there will be moments in which those large software applications need to be designed. That is the moment where you’ll need most of the content discussed here, and we will try to provide you with insight about how to write clean, fast code to solve some of the most relevant problems you could face.</p>

  <p class="body"><a id="pgfId-1017825"></a>By using a fresh approach, where for each chapter we enumerate problems that a given data structure can help solve, we will offer a handbook, a helper tool that you can refer to any time you need a suggestion on the best way to improve your application’s performance.</p>

  <p class="body"><a id="pgfId-1017826"></a>Last but not least, if you happened to have read <i class="calibre17">Grokking Algorithms</i>, by Aditya. Y. Bhargava (Manning Publications, 2016), and you enjoyed it, then this book represents the natural next step if you’d like to continue on your path of learning about algorithms. If you haven’t read it yet, I warmly encourage you to take a look at that book: it’s a great choice to get an introduction to these topics, explained clearly to all audiences. It’s not by chance that it turned out to be a wildly popular book. We hope to have made this book as enjoyable and clear.</p>

  <h3 class="fm-head2" id="heading_id_8"><a id="pgfId-1017827"></a>Who should read this book?</h3>

  <p class="body"><a id="pgfId-1017828"></a>Most of the chapters in this book are written for an audience that has already some basic understanding of algorithms, programming, and math, but we also provide a crash course in the appendices, if you need a refresher or a quick intro to these topics.</p>

  <p class="body"><a id="pgfId-1017829"></a>Reading this book will be much easier if you are already familiar (or make yourself familiar) with the following concepts:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1017830"></a>Good foundations in math and algebra will help you understand the theory sections, but we will nonetheless include a short introduction to <a class="calibre14" id="id_Hlk55400346"></a>big-O notation and asymptotic analysis in appendix B.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1017832"></a>Likewise, if you have taken an introductory class in computer science, or even algorithms, it’s likely you are already familiar with the basic data structures that will be the basis for what we will build throughout the book.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1018332"></a>The data structures discussed in this book require some basic prior knowledge to be fully understood:</p>

      <ul class="calibre20">
        <li class="fm-list-bullet1">
          <p class="list"><a class="calibre14" id="pgfId-1017833"></a>Basic storage structures such as arrays and linked lists</p>
        </li>

        <li class="fm-list-bullet1">
          <p class="list"><a class="calibre14" id="pgfId-1017834"></a>Hash tables and hashing</p>
        </li>

        <li class="fm-list-bullet1">
          <p class="list"><a class="calibre14" id="pgfId-1017835"></a>Trees</p>
        </li>

        <li class="fm-list-bullet1">
          <p class="list"><a class="calibre14" id="pgfId-1017836"></a>Containers (queues and stacks)</p>
        </li>

        <li class="fm-list-bullet1">
          <p class="list"><a class="calibre14" id="pgfId-1017837"></a>The basics of recursion</p>
        </li>
      </ul>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1017838"></a>If you need a refresher, we do provide a quick review of these structures in appendix C.</p>
    </li>
  </ul>

  <h3 class="fm-head2" id="heading_id_9"><a id="pgfId-1017849"></a><a id="id_Toc513656071"></a>How this book is organized: a roadmap</h3>

  <p class="body"><a id="pgfId-1017850"></a>The book starts in chapter 1, with a gentle introduction to the way topics are discussed in this book, a preview of what you’ll find in the typical chapter.</p>

  <p class="body"><a id="pgfId-1017851"></a>Starting from chapter 2, the rest of the book will be divided into three parts, plus the appendices. Each part is focused on a theme that can be either an abstract goal or a class of problems we aim to solve.</p>

  <p class="body"><a id="pgfId-1017852"></a>Part 1 focuses on discovering advanced data structures that allow you to improve some basic operations, for example, keeping track of things or groups of things. The key point is to become accustomed to the idea that there are many ways to perform operations on data, and the best way depends on the context and requirements.</p>

  <p class="body"><a id="pgfId-1017853"></a>Chapter 1 defines algorithms and data structures, explains the differences between them, and, through an example, explains the process of exploring different algorithms to solve a problem and how they can be leveraged to find better solutions.</p>

  <p class="body"><a id="pgfId-1017854"></a>Chapter 2 introduces an advanced variant of binary heaps, the <i class="calibre17">d-way heap</i>. It also describes the structure we use in each chapter in this part to explain topics.</p>

  <p class="body"><a id="pgfId-1017855"></a>Chapter 3 further explores advanced use of heaps with <i class="calibre17">treap</i>, a hybrid between a binary search tree and a heap that can also help in different contexts.</p>

  <p class="body"><a id="pgfId-1017856"></a>Chapter 4 switches to <i class="calibre17">Bloom filters</i>, an advanced form of hash table that can help save memory while maintaining amortized constant-time search.</p>

  <p class="body"><a id="pgfId-1017857"></a>Chapter 5 introduces a few alternative data structures used to keep track of <i class="calibre17">disjoint sets</i>, a cornerstone needed to build countless advanced algorithms and used in several practical real-world applications.</p>

  <p class="body"><a id="pgfId-1017858"></a>Chapter 6 presents two data structures that outperform general-purpose containers when it comes to storing and searching strings: tries and radix tries, also known as compact prefix trees.</p>

  <p class="body"><a id="pgfId-1017859"></a>Chapter 7 leverages the data structures presented so far to build a composed data structure, the <i class="calibre17">LRU-cache</i><a id="id_Hlk55400711"></a>, to efficiently handle caching. The <i class="calibre17">LFU-cache</i> variant is also discussed at length, as well as the issues with synchronizing shared containers in multi-thread environments.</p>

  <p class="body"><a id="pgfId-1017861"></a>Part 2 introduces another special case in search: dealing with multidimensional data, indexing this data and performing spatial queries. We will once again show how ad-hoc data structures can provide drastic improvements over using basic search algorithms. But this part also describes other important topics: clustering, heavily leveraging spatial queries, and distributed computing, in particular with the MapReduce programming model.</p>

  <p class="body"><a id="pgfId-1017862"></a>Chapter 8 introduces the <i class="calibre17">nearest neighbor</i> problem.</p>

  <p class="body"><a id="pgfId-1017863"></a>Chapter 9 describes <i class="calibre17">k-d trees</i>, a solution for efficient search in multidimensional data sets.</p>

  <p class="body"><a id="pgfId-1017864"></a>Chapter 10 presents more advanced versions of these trees, <i class="calibre17">ss-trees</i> and <i class="calibre17">r-trees</i>.</p>

  <p class="body"><a id="pgfId-1017865"></a>Chapter 11 focuses on the applications of <i class="calibre17">nearest neighbor search</i>, with a use case described in depth (finding the closest warehouse from which goods should be shipped to customers).</p>

  <p class="body"><a id="pgfId-1017866"></a>Chapter 12 presents another real-world use case leveraging the efficient nearest neighbor search algorithms presented so far: three clustering algorithms, <i class="calibre17">k-means</i>, <i class="calibre17">DBSCAN</i> and <i class="calibre17">OPTICS</i>.</p>

  <p class="body"><a id="pgfId-1017867"></a>Chapter 13 concludes this part by introducing <i class="calibre17">MapReduce</i>, a powerful computational model for distributed computing, and applying it to the clustering algorithms discussed in chapter 12.</p>

  <p class="body"><a id="pgfId-1017869"></a><a id="id_Hlk52362489"></a>Part 3 focuses on a single data structure, <i class="calibre17">graphs</i>, that will be the common thread in introducing a few optimization techniques that drive today’s AI and big data efforts.</p>

  <p class="body"><a id="pgfId-1017870"></a>Chapter 14 is a short introduction to <i class="calibre17">graphs</i>, condensing the basics for this fundamental data structure, needed to understand part 3. It also illustrates <i class="calibre17">DFS</i>, <i class="calibre17">BFS</i>, <i class="calibre17">Dijkstra’s</i> and the <i class="calibre17">A*</i> algorithms, and describes how to use them to solve the “minimum-distance path” problem.</p>

  <p class="body"><a id="pgfId-1017871"></a>Chapter 15 introduces graph <i class="calibre17">embeddings</i>, planarity, and a couple of problems we will try to solve in the remaining chapters: finding the minimum crossing number (MCN) embedding of a graph and drawing a graph nicely.</p>

  <p class="body"><a id="pgfId-1017872"></a>Chapter 16 describes a fundamental algorithm in machine learning, <i class="calibre17">gradient descent</i>, and shows how it can be applied to graphs and embeddings.</p>

  <p class="body"><a id="pgfId-1017873"></a>Chapter 17 builds on the previous chapter and presents <i class="calibre17">simulated annealing</i>, a more powerful optimization technique that tries to overcome gradient descent shortcomings when we have to deal with non-differentiable functions or functions with multiple local minima.</p>

  <p class="body"><a id="pgfId-1017874"></a>Chapter 18, finally, describes <i class="calibre17">genetic algorithms</i>, an even more advanced optimization technique that helps with faster convergence.</p>

  <p class="body"><a id="pgfId-1017875"></a>Chapters follow a specific structure, guiding you on a path from a problem to designing a data structure for its solution, to implementing that solution, and understanding its running time and memory needs.</p>

  <p class="body"><a id="pgfId-1017876"></a>But enough for now; you’ll learn more about this structure in chapter 2.</p>

  <p class="body"><a id="pgfId-1017877"></a>At the end of the book, there is an extra section for appendices, covering crucial topics that are needed to navigate through the topics of this book. Appendices have a different structure than chapters because they are not built around examples, but rather present a summary of material that the reader should be familiar with before embarking on the journey through the chapters. Most of the topics in the appendices are covered in basic algorithm classes, and chapters have several references to the appendices to help readers leverage them at the right time, but our suggestion is for you to at least skim through them before going to chapter 2.</p>

  <p class="body"><a id="pgfId-1017878"></a>Appendix A introduces the notation we use for our <i class="calibre17">pseudo-code</i> to describe algorithms.</p>

  <p class="body"><a id="pgfId-1017879"></a>Appendix B provides an overview of <i class="calibre17">big-O notation</i> and time-space analysis.</p>

  <p class="body"><a id="pgfId-1017880"></a>Appendix C and appendix D offer a summary of the <i class="calibre17">core data structures</i> that are used as building blocks of the advanced ones in this book.</p>

  <p class="body"><a id="pgfId-1017881"></a>Appendix E explains <i class="calibre17">recursion</i>, a challenging programming technique that often allows for clearer and more concise definitions of algorithms—with some tradeoffs, as we will see.</p>

  <p class="body"><a id="pgfId-1017882"></a>Appendix F gives the definition of <i class="calibre17">randomized algorithms</i>, both <i class="calibre17">Monte Carlo</i> and <i class="calibre17">Las Vegas</i> types, and introduces classification problems and metrics for randomized solutions.</p>

  <h3 class="fm-head2" id="heading_id_10"><a id="pgfId-1017839"></a>About the code</h3>

  <p class="body"><a id="pgfId-1017840"></a>The algorithms in this book will be explained using pseudo-code, so you are not required to have any prior knowledge of any specific programming language.</p>

  <p class="body"><a id="pgfId-1017841"></a>It is, however, assumed that you have a certain familiarity with basic, language-agnostic, programming concepts such as loops and conditionals, not to mention Boolean operators and the concepts of variables and assignments.</p>

  <p class="body"><a id="pgfId-1017842"></a>To help you go through the pseudo-code in this book, we provide a short guide in appendix A describing the syntax (or rather, pseudo-syntax) that we’ll use throughout the chapters. You might want to take a look at appendix A before starting with chapter 1, or if you feel more confident, you can start looking at code snippets and refer to appendix A if or when you feel the syntax used is not immediately clear.</p>

  <p class="body"><a id="pgfId-1017843"></a>Besides pseudo-code, if you do have knowledge of or an interest in a specific programming language, or if you’d like to see these concepts implemented in real, executable, code, we provide a repository on GitHub<a href="#pgfId-1017847"><sup class="footnotenumber">3</sup></a> with implementations in a few languages (starting with Java, Python, and JavaScript) for the data structures described.</p>

  <h3 class="fm-head2" id="heading_id_11"><a id="pgfId-1018805"></a>liveBook discussion forum</h3>

  <p class="body"><a id="pgfId-1018823"></a>Purchase of <i class="calibre17">Advanced Algorithms and Data Structures</i> includes free access to a private web forum run by Manning Publications where you can make comments about the book, ask technical questions, and receive help from the author and from other users. To access the forum, go to <span class="fm-hyperlink"><a href="https://livebook.manning.com/book/algorithms-and-data-structures-in-action/welcome/v-14">https://livebook.manning.com/book/algorithms-and-data-structures-in-action/welcome/v-14</a></span>. You can also learn more about Manning's forums and the rules of conduct at <span class="fm-hyperlink"><a href="https://livebook.manning.com/#!/discussion">https://livebook.manning.com/#!/discussion</a></span>.</p>

  <p class="body"><a id="pgfId-1018824"></a>Manning’s commitment to our readers is to provide a venue where a meaningful dialogue between individual readers and between readers and the author can take place. It is not a commitment to any specific amount of participation on the part of the author, whose contribution to the forum remains voluntary (and unpaid). We suggest you try asking the author some challenging questions lest his interest stray! The forum and the archives of previous discussions will be accessible from the publisher’s website as long as the book is in print.</p>

  <h2 class="fm-head" id="heading_id_12"><a id="pgfId-1018819"></a>about the author</h2>

  <p class="body"><a id="pgfId-1018884"></a><b class="calibre21">Marcello La Rocca</b> is a senior software engineer at Tundra.com. His work and interests focus on graphs, optimization algorithms, genetic algorithms, machine learning, and quantum computing. He has contributed to large-scale web applications and data infrastructure at companies like Twitter, Microsoft, and Apple, undertaken applied research in both academia and industry, and authored the NeatSort adaptive sorting algorithm.</p>

  <h2 class="fm-head" id="heading_id_13"><a id="pgfId-1017883"></a>about the cover illustration</h2>

  <p class="body"><a id="pgfId-1018906"></a>The figure on the cover of <i class="calibre17">Advanced Algorithms and Data Structures</i> is captioned “Femme de Fiume,” or “Woman from Rijeka.” The illustration is taken from a collection of dress costumes from various countries by Jacques Grasset de Saint-Sauveur (1757-1810), titled <i class="calibre17">Costumes de Différents Pays</i>, published in France in 1797. Each illustration is finely drawn and colored by hand. The rich variety of Grasset de Saint-Sauveur’s collection reminds us vividly of how culturally apart the world’s towns and regions were just 200 years ago. Isolated from each other, people spoke different dialects and languages. In the streets or in the countryside, it was easy to identify where they lived and what their trade or station in life was just by their dress.</p>

  <p class="body"><a id="pgfId-1018907"></a>The way we dress has changed since then and the diversity by region, so rich at the time, has faded away. It is now hard to tell apart the inhabitants of different continents, let alone different towns, regions, or countries. Perhaps we have traded cultural diversity for a more varied personal life—certainly for a more varied and fast-paced technological life.</p>

  <p class="body"><a id="pgfId-1015277"></a>At a time when it is hard to tell one computer book from another, Manning celebrates the inventiveness and initiative of the computer business with book covers based on the rich diversity of regional life of two centuries ago, brought back to life by Grasset de Saint-Sauveur’s pictures.</p>
  <hr class="calibre22"/>

  <p class="fm-footnote"><sup class="footnotenumber">1.</sup> <a id="pgfId-1017815"></a>See <span class="fm-hyperlink"><a href="http://ocert.org/advisories/ocert-2011-003.html">http://ocert.org/advisories/ocert-2011-003.html</a></span>.</p>

  <p class="fm-footnote"><sup class="footnotenumber">2.</sup> <a id="pgfId-1017818"></a>See, for instance, Arkin, Brad, et al. “<i class="calibre17">How we learned to cheat at online poker: A study in software security.</i>” The developer.com journal (1999), <a href="http://www.bluffnakedpoker.com/PDF/developer_gambling.pdf">http://www.bluffnakedpoker.com/PDF/developer_gambling.pdf</a>.</p>

  <p class="fm-footnote"><sup class="footnotenumber">3.</sup> <a id="pgfId-1017847"></a>See <span class="fm-hyperlink"><a href="https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction">https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction</a></span>.</p>
</body>
</html>
