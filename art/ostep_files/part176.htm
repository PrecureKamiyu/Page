<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Segregated Lists</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part175.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part177.htm">下一个 &gt;</a></p><p class="s32" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Segregated Lists</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">One interesting approach that has been around for some time is the use of <b>segregated lists</b>. The basic idea is simple: if a particular application has one (or a few) popular-sized request that it makes, keep a separate list just to manage objects of that size; all other requests are forwarded to a more general memory allocator.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The benefits of such an approach are obvious. By having a chunk of memory dedicated for one particular size of requests, fragmentation is much less of a concern; moreover, allocation and free requests can be served quite quickly when they are of the right size, as no complicated search of a list is required.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Just like any good idea, this approach introduces new complications into a system as well. For example, how much memory should one ded- icate to the pool of memory that serves specialized requests of a given size, as opposed to the general pool? One particular allocator, the <b>slab allocator </b>by uber-engineer Jeff Bonwick (which was designed for use in the Solaris kernel), handles this issue in a rather nice way [B94].</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Specifically, when the kernel boots up, it allocates a number of <b>object caches </b>for kernel objects that are likely to be requested frequently (such as locks, file-system inodes, etc.); the object caches thus are each segregated free lists of a given size and serve memory allocation and free requests quickly. When a given cache is running low on free space, it requests some <b>slabs </b>of memory from a more general memory allocator (the to- tal amount requested being a multiple of the page size and the object in question). Conversely, when the reference counts of the objects within a given slab all go to zero, the general allocator can reclaim them from the specialized allocator, which is often done when the VM system needs more memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 55pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>G<span class="s45">REAT </span>E<span class="s45">NGINEERS </span>A<span class="s45">RE </span>R<span class="s45">EALLY </span>G<span class="s45">REAT</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Engineers like Jeff Bonwick (who not only wrote the slab allocator men- tioned herein but also was the lead of an amazing file system, ZFS) are the heart of Silicon Valley. Behind almost any great product or technol- ogy is a human (or small group of humans) who are way above average in their talents, abilities, and dedication. As Mark Zuckerberg (of Face- book) says: “Someone who is exceptional in their role is not just a little better than someone who is pretty good. They are 100 times better.” This is why, still today, one or two people can start a company that changes the face of the world forever (think Google, Apple, or Facebook). Work hard and you might become such a “100x” person as well. Failing that, work <i>with </i>such a person; you’ll learn more in day than most learn in a month. Failing that, feel sad.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The slab allocator also goes beyond most segregated list approaches by keeping free objects on the lists in a pre-initialized state. Bonwick shows that initialization and destruction of data structures is costly [B94]; by keeping freed objects in a particular list in their initialized state, the slab allocator thus avoids frequent initialization and destruction cycles per object and thus lowers overheads noticeably.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part175.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part177.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
