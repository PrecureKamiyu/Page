<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>27.4 Condition Variables</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part274.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part276.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">27.4 Condition Variables</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The other major component of any threads library, and certainly the case with POSIX threads, is the presence of a <b>condition variable</b>. Con- dition variables are useful when some kind of signaling must take place between threads, if one thread is waiting for another to do something be- fore it can continue. Two primary routines are used by programs wishing to interact in this way:</p><p class="s38" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: left;">int pthread_cond_wait(pthread_cond_t <span class="s39">*</span>cond, pthread_mutex_t <span class="s39">*</span>mutex); int pthread_cond_signal(pthread_cond_t <span class="s39">*</span>cond);</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To use a condition variable, one has to in addition have a lock that is associated with this condition. When calling either of the above routines, this lock should be held.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_349.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_350.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">The first routine, <span class="s41">pthread cond wait()</span>, puts the calling thread to sleep, and thus waits for some other thread to signal it, usually when something in the program has changed that the now-sleeping thread might care about. For example, a typical usage looks like this:</p><p class="s38" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t init = PTHREAD_COND_INITIALIZER;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Pthread_mutex_lock(&amp;lock); while (initialized == 0)</p><p class="s38" style="padding-left: 41pt;text-indent: 16pt;text-align: left;">Pthread_cond_wait(&amp;init, &amp;lock); Pthread_mutex_unlock(&amp;lock);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this code, after initialization of the relevant lock and condition<span class="s35">3</span>, a thread checks to see if the variable <span class="s41">initialized </span>has yet been set to something other than zero. If not, the thread simply calls the wait routine in order to sleep until some other thread wakes it.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The code to wake a thread, which would run in some other thread, looks like this:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">Pthread_mutex_lock(&amp;lock); initialized = 1; Pthread_cond_signal(&amp;init); Pthread_mutex_unlock(&amp;lock);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">A few things to note about this code sequence. First, when signal- ing (as well as when modifying the global variable <span class="s41">initialized</span>), we always make sure to have the lock held. This ensures that we don’t acci- dentally introduce a race condition into our code.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_351.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_352.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Second, you might notice that the wait call takes a lock as its second parameter, whereas the signal call only takes a condition. The reason for this difference is that the wait call, in addition to putting the call- ing thread to sleep, <i>releases </i>the lock when putting said caller to sleep. Imagine if it did not: how could the other thread acquire the lock and signal it to wake up? However, <i>before </i>returning after being woken, the <span class="s41">pthread cond wait() </span>re-acquires the lock, thus ensuring that any time the waiting thread is running between the lock acquire at the beginning of the wait sequence, and the lock release at the end, it holds the lock.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One last oddity: the waiting thread re-checks the condition in a while loop, instead of a simple if statement. We’ll discuss this issue in detail when we study condition variables in a future chapter, but in general, using a while loop is the simple and safe thing to do. Although it rechecks the condition (perhaps adding a little overhead), there are some pthread implementations that could spuriously wake up a waiting thread; in such a case, without rechecking, the waiting thread will continue thinking that the condition has changed even though it has not. It is safer thus to view waking up as a hint that something might have changed, rather than an absolute fact.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Note that sometimes it is tempting to use a simple flag to signal be- tween two threads, instead of a condition variable and associated lock. For example, we could rewrite the waiting code above to look more like this in the waiting code:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">while (initialized == 0)</p><p class="s38" style="padding-left: 39pt;text-indent: 0pt;text-align: center;">; // spin</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 80pt;text-indent: 0pt;text-align: left;">The associated signaling code would look like this:</p><p class="s38" style="padding-top: 7pt;padding-left: 34pt;text-indent: 0pt;text-align: center;">initialized = 1;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_353.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_354.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_355.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_356.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_357.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_358.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_359.png"/></span></p><p class="s12" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 90%;text-align: justify;"><span class="s11">3</span>Note  that  one  could  use  <span class="s38">pthread cond init() </span>(and  correspond- ing  the  <span class="s38">pthread cond destroy() </span>call)  instead  of  the  static  initializer <span class="s38">PTHREAD COND INITIALIZER</span>. Sound like more work? It is.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Don’t ever do this, for the following reasons. First, it performs poorly in many cases (spinning for a long time just wastes CPU cycles). Sec- ond, it is error prone. As recent research shows [X+10], it is surprisingly easy to make mistakes when using flags (as above) to synchronize be- tween threads; roughly half the uses of these <i>ad hoc </i>synchronizations were buggy! Don’t be lazy; use condition variables even when you think you can get away without doing so.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part274.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part276.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
