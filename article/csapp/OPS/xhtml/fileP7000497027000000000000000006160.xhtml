<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>7.6 Symbol Resolution</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000006160" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P70004970270000000000000000448F7" data-uri="chapter07.xhtml#P70004970270000000000000000448F7" epub:type="title"><span class="pcalibre label pcalibre1">7.6 </span>Symbol Resolution</h1></header>
<p id="P70004970270000000000000000448F8" data-uri="chapter07.xhtml#P70004970270000000000000000448F8" class="pcalibre1 pcalibre calibre2">The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol tables of its input relocatable object files. Symbol resolution is straightforward for references to local symbols that are defined in the same module as the reference. The compiler allows only one definition of each local symbol per module. The compiler also ensures that static local variables, which get local linker symbols, have unique names.</p>
<p id="P70004970270000000000000000448F9" data-uri="chapter07.xhtml#P70004970270000000000000000448F9" class="pcalibre1 pcalibre calibre2">Resolving references to global symbols, however, is trickier. When the compiler encounters a symbol (either a variable or function name) that is not defined in the current module, it assumes that it is defined in some other module, generates a linker symbol table entry, and leaves it for the linker to handle. If the linker is unable to find a definition for the referenced symbol in any of its input modules, it prints an (often cryptic) error message and terminates. For example, if we try to compile and link the following source file on a Linux machine,</p>
<pre id="P70004970270000000000000000448FA" data-uri="chapter07.xhtml#P70004970270000000000000000448FA" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000448FB" data-uri="chapter07.xhtml#P70004970270000000000000000448FB" class="calibre10 pcalibre pcalibre1">
1	void foo(void); 
2
3	int main() {
4	    foo();
5	    return 0;
6	}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000448FC" data-uri="chapter07.xhtml#P70004970270000000000000000448FC">then the compiler runs without a hitch, but the linker terminates when it cannot resolve the reference to <code id="P70004970270000000000000000448FD" data-uri="chapter07.xhtml#P70004970270000000000000000448FD" class="pcalibre1 calibre8 pcalibre">foo:</code></p>
<pre id="P70004970270000000000000000448FE" data-uri="chapter07.xhtml#P70004970270000000000000000448FE" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000448FF" data-uri="chapter07.xhtml#P70004970270000000000000000448FF" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Wall -Og -o linkerror linkerror.c</i>
/tmp/ccSz5uti.o: In function `main':
/tmp/ccSz5uti.o(.text+0x7): undefined reference to `foo'</code></pre>
<p id="P7000497027000000000000000044900" data-uri="chapter07.xhtml#P7000497027000000000000000044900" class="pcalibre1 pcalibre calibre2">Symbol resolution for global symbols is also tricky because multiple object modules might define global symbols with the same name. In this case, the linker must either flag an error or somehow choose one of the definitions and discard the rest. The approach adopted by Linux systems involves cooperation between the compiler, assembler, and linker and can introduce some baffling bugs to the unwary programmer.</p>
<aside class="sidebar pcalibre5 pcalibre" id="P700049702700000000000000000616B" data-uri="chapter07.xhtml#P700049702700000000000000000616B"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000044901" data-uri="chapter07.xhtml#P7000497027000000000000000044901" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000616D" title="680" data-uri="chapter07.xhtml#P700049702700000000000000000616D" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Mangling of linker symbols in C++ and Java</h1></header>
<p id="P7000497027000000000000000044902" data-uri="chapter07.xhtml#P7000497027000000000000000044902" class="calibre13 pcalibre pcalibre1">Both C++ and Java allow overloaded methods that have the same name in the source code but different parameter lists. So how does the linker tell the difference between these different overloaded functions? Overloaded functions in C++ and Java work because the compiler encodes each unique method and parameter list combination into a unique name for the linker. This encoding process is called <i class="calibre5 pcalibre pcalibre1">mangling</i>, and the inverse process is known as <i class="calibre5 pcalibre pcalibre1">demangling.</i></p>
<p id="P7000497027000000000000000044903" data-uri="chapter07.xhtml#P7000497027000000000000000044903" class="pcalibre calibre3 pcalibre1">Happily, C++ and Java use compatible mangling schemes. A mangled class name consists of the integer number of characters in the name followed by the original name. For example, the class <code id="P7000497027000000000000000044904" data-uri="chapter07.xhtml#P7000497027000000000000000044904" class="pcalibre1 calibre8 pcalibre">Foo</code> is encoded as <code id="P7000497027000000000000000044905" data-uri="chapter07.xhtml#P7000497027000000000000000044905" class="pcalibre1 calibre8 pcalibre">3Foo</code>. A method is encoded as the original method name, followed by __, followed by the mangled class name, followed by single letter encodings of each argument. For example, <code id="P7000497027000000000000000044906" data-uri="chapter07.xhtml#P7000497027000000000000000044906" class="pcalibre1 calibre8 pcalibre">Foo::bar(int, long)</code> is encoded as <code id="P7000497027000000000000000044907" data-uri="chapter07.xhtml#P7000497027000000000000000044907" class="pcalibre1 calibre8 pcalibre">bar_3Fooil</code>. Similar schemes are used to mangle global variable and template names.</p>
</aside>
<section id="P7000497027000000000000000006174" data-uri="chapter07.xhtml#P7000497027000000000000000006174" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000044908" data-uri="chapter07.xhtml#P7000497027000000000000000044908" epub:type="title"><span class="pcalibre label pcalibre1">7.6.1 </span>How Linkers Resolve Duplicate Symbol Names</h1></header>
<p id="P7000497027000000000000000044909" data-uri="chapter07.xhtml#P7000497027000000000000000044909" class="pcalibre1 pcalibre calibre2">The input to the linker is a collection of relocatable object modules. Each of these modules defines a set of symbols, some of which are local (visible only to the module that defines it), and some of which are global (visible to other modules). What happens if multiple modules define global symbols with the same name? Here is the approach that Linux compilation systems use.</p>
<p id="P700049702700000000000000004490A" data-uri="chapter07.xhtml#P700049702700000000000000004490A" class="pcalibre1 pcalibre calibre2">At compile time, the compiler exports each global symbol to the assembler as either <i class="calibre5 pcalibre pcalibre1">strong</i> or <i class="calibre5 pcalibre pcalibre1">weak</i>, and the assembler encodes this information implicitly in the symbol table of the relocatable object file. Functions and initialized global variables get strong symbols. Uninitialized global variables get weak symbols.</p>
<p id="P700049702700000000000000004490B" data-uri="chapter07.xhtml#P700049702700000000000000004490B" class="pcalibre1 pcalibre calibre2">Given this notion of strong and weak symbols, Linux linkers use the following rules for dealing with duplicate symbol names:</p>
<ul class="pcalibre ul_none pcalibre1" id="P700049702700000000000000004490C" data-uri="chapter07.xhtml#P700049702700000000000000004490C">
<li id="P700049702700000000000000004490D" data-uri="chapter07.xhtml#P700049702700000000000000004490D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004490E" data-uri="chapter07.xhtml#P700049702700000000000000004490E" class="calibre13 pcalibre pcalibre1">Rule 1. Multiple strong symbols with the same name are not allowed.</p></li>
<li id="P700049702700000000000000004490F" data-uri="chapter07.xhtml#P700049702700000000000000004490F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044910" data-uri="chapter07.xhtml#P7000497027000000000000000044910" class="calibre13 pcalibre pcalibre1">Rule 2. Given a strong symbol and multiple weak symbols with the same name, choose the strong symbol.</p></li>
<li id="P7000497027000000000000000044911" data-uri="chapter07.xhtml#P7000497027000000000000000044911" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044912" data-uri="chapter07.xhtml#P7000497027000000000000000044912" class="calibre13 pcalibre pcalibre1">Rule 3. Given multiple weak symbols with the same name, choose any of the weak symbols.</p></li>
</ul>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044913" data-uri="chapter07.xhtml#P7000497027000000000000000044913">For example, suppose we attempt to compile and link the following two C modules:</p>
<pre id="P7000497027000000000000000044914" data-uri="chapter07.xhtml#P7000497027000000000000000044914" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044915" data-uri="chapter07.xhtml#P7000497027000000000000000044915" class="calibre10 pcalibre pcalibre1">
1	/* foo1.c */
2	int main()
3	{
4		return 0;
5	}
1	/* bar1.c */
2	int main()
3	{
4		return 0;
5	}</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044916" data-uri="chapter07.xhtml#P7000497027000000000000000044916"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006184" title="681" data-uri="chapter07.xhtml#P7000497027000000000000000006184" epub:type="pagebreak"></span>In this case, the linker will generate an error message because the strong symbol main is defined multiple times (rule 1):</p>
<pre id="P7000497027000000000000000044917" data-uri="chapter07.xhtml#P7000497027000000000000000044917" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044918" data-uri="chapter07.xhtml#P7000497027000000000000000044918" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc foo1.c bar1.c</i>
/tmp/ccq2Uxnd.o: In function `main':
bar1.c:(.text+0x0): multiple definition of `main'</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044919" data-uri="chapter07.xhtml#P7000497027000000000000000044919">Similarly, the linker will generate an error message for the following modules because the strong symbol <code id="P700049702700000000000000004491A" data-uri="chapter07.xhtml#P700049702700000000000000004491A" class="pcalibre1 calibre8 pcalibre">x</code> is defined twice (rule 1):</p>
<pre id="P700049702700000000000000004491B" data-uri="chapter07.xhtml#P700049702700000000000000004491B" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004491C" data-uri="chapter07.xhtml#P700049702700000000000000004491C" class="calibre10 pcalibre pcalibre1">
1	/* foo2.c */
2	int x = 15213;
3
4	int main()
5	{
6		return 0;
7	}
</code></pre>
<pre id="P700049702700000000000000004491D" data-uri="chapter07.xhtml#P700049702700000000000000004491D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004491E" data-uri="chapter07.xhtml#P700049702700000000000000004491E" class="calibre10 pcalibre pcalibre1">
1	/* bar2.c */
2	int x = 15213;
3
4	void f()
5	{
6	}</code></pre>
<p id="P700049702700000000000000004491F" data-uri="chapter07.xhtml#P700049702700000000000000004491F" class="pcalibre1 pcalibre calibre2">However, if <code id="P7000497027000000000000000044920" data-uri="chapter07.xhtml#P7000497027000000000000000044920" class="pcalibre1 calibre8 pcalibre">x</code> is uninitialized in one module, then the linker will quietly choose the strong symbol defined in the other (rule 2):</p>
<pre id="P7000497027000000000000000044921" data-uri="chapter07.xhtml#P7000497027000000000000000044921" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044922" data-uri="chapter07.xhtml#P7000497027000000000000000044922" class="calibre10 pcalibre pcalibre1">
1	/* foo3.c */
2	#include &lt;stdio.h&gt;
3	void f(void);
4
5	int x = 15213;
6
7	int main()
8	{
9		f();
10		printf(″x = %dn″, x);
11		return 0;
12	}
</code></pre>
<pre id="P7000497027000000000000000044923" data-uri="chapter07.xhtml#P7000497027000000000000000044923" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044924" data-uri="chapter07.xhtml#P7000497027000000000000000044924" class="calibre10 pcalibre pcalibre1">
1	/* bar3.c */
2	int x;
3
4	void f()
5	{
6		x = 15212;
7	}</code></pre>
<p id="P7000497027000000000000000044925" data-uri="chapter07.xhtml#P7000497027000000000000000044925" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006194" title="682" data-uri="chapter07.xhtml#P7000497027000000000000000006194" epub:type="pagebreak"></span>At run time, function <code id="P7000497027000000000000000044926" data-uri="chapter07.xhtml#P7000497027000000000000000044926" class="pcalibre1 calibre8 pcalibre">f</code> changes the value of <code id="P7000497027000000000000000044927" data-uri="chapter07.xhtml#P7000497027000000000000000044927" class="pcalibre1 calibre8 pcalibre">x</code> from 15213 to 15212, which might come as an unwelcome surprise to the author of function <code id="P7000497027000000000000000044928" data-uri="chapter07.xhtml#P7000497027000000000000000044928" class="pcalibre1 calibre8 pcalibre">main</code>! Notice that the linker normally gives no indication that it has detected multiple definitions of <code id="P7000497027000000000000000044929" data-uri="chapter07.xhtml#P7000497027000000000000000044929" class="pcalibre1 calibre8 pcalibre">x</code>:</p>
<pre id="P700049702700000000000000004492A" data-uri="chapter07.xhtml#P700049702700000000000000004492A" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004492B" data-uri="chapter07.xhtml#P700049702700000000000000004492B" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -o foobar3 foo3.c bar3.c</i>
linux&gt; <i class="calibre5 pcalibre pcalibre1"> ./foobar3</i>
x = 15212</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004492C" data-uri="chapter07.xhtml#P700049702700000000000000004492C">The same thing can happen if there are two weak definitions of <code id="P700049702700000000000000004492D" data-uri="chapter07.xhtml#P700049702700000000000000004492D" class="pcalibre1 calibre8 pcalibre">x</code> (rule 3):</p>
<pre id="P700049702700000000000000004492E" data-uri="chapter07.xhtml#P700049702700000000000000004492E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004492F" data-uri="chapter07.xhtml#P700049702700000000000000004492F" class="calibre10 pcalibre pcalibre1">
1	/* foo4.c */
2	#include &lt;stdio.h&gt;
3	void f(void);
4
5	int x;
6
7	int main()
8	{
9		x = 15213;
10		f();
11		printf(″x = %dn″, x);
12		return 0;
13	}
</code></pre>
<pre id="P7000497027000000000000000044930" data-uri="chapter07.xhtml#P7000497027000000000000000044930" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044931" data-uri="chapter07.xhtml#P7000497027000000000000000044931" class="calibre10 pcalibre pcalibre1">
1	/* bar4.c */
2	int x;
3
4	void f()
5	{
6		x = 15212;
7	}</code></pre>
<p id="P7000497027000000000000000044932" data-uri="chapter07.xhtml#P7000497027000000000000000044932" class="pcalibre1 pcalibre calibre2">The application of rules 2 and 3 can introduce some insidious run-time bugs that are incomprehensible to the unwary programmer, especially if the duplicate symbol definitions have different types. Consider the following example, in which <code id="P7000497027000000000000000044933" data-uri="chapter07.xhtml#P7000497027000000000000000044933" class="pcalibre1 calibre8 pcalibre">x</code> is inadvertently defined as an <code id="P7000497027000000000000000044934" data-uri="chapter07.xhtml#P7000497027000000000000000044934" class="pcalibre1 calibre8 pcalibre">int</code> in one module and a double in another:</p>
<pre id="P7000497027000000000000000044935" data-uri="chapter07.xhtml#P7000497027000000000000000044935" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044936" data-uri="chapter07.xhtml#P7000497027000000000000000044936" class="calibre10 pcalibre pcalibre1">
1	/* foo5.c */
2	#include &lt;stdio.h&gt;
3	void f(void);
4
5	int y = 15212;
6	int x = 15213;
7
8	int main()
9	{
10		f();
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000061A6" title="683" data-uri="chapter07.xhtml#P70004970270000000000000000061A6" epub:type="pagebreak"></span>11		printf(″x = 0x%x y = 0x%x n″,
12			x, y);
13		return 0;
14	}
</code></pre>
<pre id="P7000497027000000000000000044937" data-uri="chapter07.xhtml#P7000497027000000000000000044937" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044938" data-uri="chapter07.xhtml#P7000497027000000000000000044938" class="calibre10 pcalibre pcalibre1">
1	/* bar5.c */
2	double x;
3
4	void f()
5	{
6		x = -0.0;
7	}</code></pre>
<p id="P7000497027000000000000000044939" data-uri="chapter07.xhtml#P7000497027000000000000000044939" class="pcalibre1 pcalibre calibre2">On an x86-64/Linux machine, <code id="P700049702700000000000000004493A" data-uri="chapter07.xhtml#P700049702700000000000000004493A" class="pcalibre1 calibre8 pcalibre">doubles</code> are 8 bytes and <code id="P700049702700000000000000004493B" data-uri="chapter07.xhtml#P700049702700000000000000004493B" class="pcalibre1 calibre8 pcalibre">ints</code> are 4 bytes. On our system, the address of <code id="P700049702700000000000000004493C" data-uri="chapter07.xhtml#P700049702700000000000000004493C" class="pcalibre1 calibre8 pcalibre">x</code> is <code id="P700049702700000000000000004493D" data-uri="chapter07.xhtml#P700049702700000000000000004493D" class="pcalibre1 calibre8 pcalibre">0x601020</code> and the address of <code id="P700049702700000000000000004493E" data-uri="chapter07.xhtml#P700049702700000000000000004493E" class="pcalibre1 calibre8 pcalibre">y</code> is <code id="P700049702700000000000000004493F" data-uri="chapter07.xhtml#P700049702700000000000000004493F" class="pcalibre1 calibre8 pcalibre">0x601024</code>. Thus, the assignment <code id="P7000497027000000000000000044940" data-uri="chapter07.xhtml#P7000497027000000000000000044940" class="pcalibre1 calibre8 pcalibre">x</code> = <code id="P7000497027000000000000000044941" data-uri="chapter07.xhtml#P7000497027000000000000000044941" class="pcalibre1 calibre8 pcalibre">-0.0</code> in line 6 of <code id="P7000497027000000000000000044942" data-uri="chapter07.xhtml#P7000497027000000000000000044942" class="pcalibre1 calibre8 pcalibre">bar5.c</code> will overwrite the memory locations for <code id="P7000497027000000000000000044943" data-uri="chapter07.xhtml#P7000497027000000000000000044943" class="pcalibre1 calibre8 pcalibre">x</code> and <code id="P7000497027000000000000000044944" data-uri="chapter07.xhtml#P7000497027000000000000000044944" class="pcalibre1 calibre8 pcalibre">y</code> (lines 5 and 6 in <code id="P7000497027000000000000000044945" data-uri="chapter07.xhtml#P7000497027000000000000000044945" class="pcalibre1 calibre8 pcalibre">foo5.c</code>) with the double-precision floating-point representation of negative zero!</p>
<pre id="P7000497027000000000000000044946" data-uri="chapter07.xhtml#P7000497027000000000000000044946" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044947" data-uri="chapter07.xhtml#P7000497027000000000000000044947" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -Wall -0g -o foobar5 foo5.c bar5.c</i>
/usr/bin/ld: Warning: alignment 4 of symbol `x' in /tmp/cclUFK5g.o
is smaller than 8 in /tmp/ccbTLcb9.o
linux&gt; <i class="calibre5 pcalibre pcalibre1">./foobar5</i>
x = 0x0 y = 0x80000000</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044948" data-uri="chapter07.xhtml#P7000497027000000000000000044948">This is a subtle and nasty bug, especially because it triggers only a warning from the linker, and because it typically manifests itself much later in the execution of the program, far away from where the error occurred. In a large system with hundreds of modules, a bug of this kind is extremely hard to fix, especially because many programmers are not aware of how linkers work, and because they often ignore compiler warnings. When in doubt, invoke the linker with a flag such as the <span class="smallcaps pcalibre pcalibre1">gcc </span><code id="P7000497027000000000000000044949" data-uri="chapter07.xhtml#P7000497027000000000000000044949" class="pcalibre1 calibre8 pcalibre">-fno-common</code> flag, which triggers an error if it encounters multiply-defined global symbols. Or use the <code id="P700049702700000000000000004494A" data-uri="chapter07.xhtml#P700049702700000000000000004494A" class="pcalibre1 calibre8 pcalibre">-Werror</code> option, which turns all warnings into errors.</p>
<p id="P700049702700000000000000004494B" data-uri="chapter07.xhtml#P700049702700000000000000004494B" class="pcalibre1 pcalibre calibre2">In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000608B.xhtml#P700049702700000000000000000608B"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">7.5</span></a>, we saw how the compiler assigns symbols to COMMON and <code id="P700049702700000000000000004494C" data-uri="chapter07.xhtml#P700049702700000000000000004494C" class="pcalibre1 calibre8 pcalibre">.bss</code> using a seemingly arbitrary convention. Actually, this convention is due to the fact that in some cases the linker allows multiple modules to define global symbols with the same name. When the compiler is translating some module and encounters a weak global symbol, say, <code id="P700049702700000000000000004494D" data-uri="chapter07.xhtml#P700049702700000000000000004494D" class="pcalibre1 calibre8 pcalibre">x</code>, it does not know if other modules also define <code id="P700049702700000000000000004494E" data-uri="chapter07.xhtml#P700049702700000000000000004494E" class="pcalibre1 calibre8 pcalibre">x</code>, and if so, it cannot predict which of the multiple instances of <code id="P700049702700000000000000004494F" data-uri="chapter07.xhtml#P700049702700000000000000004494F" class="pcalibre1 calibre8 pcalibre">x</code> the linker might choose. So the compiler defers the decision to the linker by assigning <code id="P7000497027000000000000000044950" data-uri="chapter07.xhtml#P7000497027000000000000000044950" class="pcalibre1 calibre8 pcalibre">x</code> to COMMON. On the other hand, if <code id="P7000497027000000000000000044951" data-uri="chapter07.xhtml#P7000497027000000000000000044951" class="pcalibre1 calibre8 pcalibre">x</code> is initialized to zero, then it is a strong symbol (and thus must be unique by rule 2), so the compiler can confidently assign it to <code id="P7000497027000000000000000044952" data-uri="chapter07.xhtml#P7000497027000000000000000044952" class="pcalibre1 calibre8 pcalibre">.bss</code>. Similarly, static symbols are unique by construction, so the compiler can confidently assign them to either <code id="P7000497027000000000000000044953" data-uri="chapter07.xhtml#P7000497027000000000000000044953" class="pcalibre1 calibre8 pcalibre">.data</code> or <code id="P7000497027000000000000000044954" data-uri="chapter07.xhtml#P7000497027000000000000000044954" class="pcalibre1 calibre8 pcalibre">.bss</code>.</p>
<section id="P70004970270000000000000000061C5" data-uri="chapter07.xhtml#P70004970270000000000000000061C5" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000044955" data-uri="chapter07.xhtml#P7000497027000000000000000044955" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000061C7" title="684" data-uri="chapter07.xhtml#P70004970270000000000000000061C7" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">7.2 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000065E7.xhtml#P70004970270000000000000000065EF">718</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000044956" data-uri="chapter07.xhtml#P7000497027000000000000000044956">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000044957" data-uri="chapter07.xhtml#P7000497027000000000000000044957">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000044958" data-uri="chapter07.xhtml#P7000497027000000000000000044958"><p id="P7000497027000000000000000044959" data-uri="chapter07.xhtml#P7000497027000000000000000044959" class="pcalibre calibre3 pcalibre1">In this problem, let <code id="P700049702700000000000000004495A" data-uri="chapter07.xhtml#P700049702700000000000000004495A" class="pcalibre1 calibre8 pcalibre">REF(x.i) → DEF(x.k)</code> denote that the linker will associate an arbitrary reference to symbol <code id="P700049702700000000000000004495B" data-uri="chapter07.xhtml#P700049702700000000000000004495B" class="pcalibre1 calibre8 pcalibre">x</code> in module <code id="P700049702700000000000000004495C" data-uri="chapter07.xhtml#P700049702700000000000000004495C" class="pcalibre1 calibre8 pcalibre">i</code> to the definition of <code id="P700049702700000000000000004495D" data-uri="chapter07.xhtml#P700049702700000000000000004495D" class="pcalibre1 calibre8 pcalibre">x</code> in module <code id="P700049702700000000000000004495E" data-uri="chapter07.xhtml#P700049702700000000000000004495E" class="pcalibre1 calibre8 pcalibre">k</code>. For each example that follows, use this notation to indicate how the linker would resolve references to the multiply-defined symbol in each module. If there is a link-time error (rule 1), write "<span class="smallcaps pcalibre pcalibre1">error</span>". If the linker arbitrarily chooses one of the definitions (rule 3), write "<span class="smallcaps pcalibre pcalibre1">unknown</span>".</p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P700049702700000000000000004495F" data-uri="chapter07.xhtml#P700049702700000000000000004495F">
<li id="P7000497027000000000000000044960" data-uri="chapter07.xhtml#P7000497027000000000000000044960" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044961" data-uri="chapter07.xhtml#P7000497027000000000000000044961" class="pcalibre calibre3 pcalibre1"></p>
<pre id="P7000497027000000000000000044962" data-uri="chapter07.xhtml#P7000497027000000000000000044962" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044963" data-uri="chapter07.xhtml#P7000497027000000000000000044963" class="calibre10 pcalibre pcalibre1">/* Module 1 */		/* Module 2 */
int main()		int main;
{			int p2()
}			{
			}
(a) REF(main.1) → DEF(_____._____)
(b) REF(main.2) → DEF(_____._____)</code></pre></li>
<li id="P7000497027000000000000000044964" data-uri="chapter07.xhtml#P7000497027000000000000000044964" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044965" data-uri="chapter07.xhtml#P7000497027000000000000000044965" class="pcalibre calibre3 pcalibre1"></p>
<pre id="P7000497027000000000000000044966" data-uri="chapter07.xhtml#P7000497027000000000000000044966" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044967" data-uri="chapter07.xhtml#P7000497027000000000000000044967" class="calibre10 pcalibre pcalibre1">/* Module 1 */		/* Module 2 */
void main()		int main = 1;
{			int p2()
}			{
			}
(a) REF(main.1) → DEF(_____._____)
(b) REF(main.2) → DEF(_____._____)</code></pre></li>
<li id="P7000497027000000000000000044968" data-uri="chapter07.xhtml#P7000497027000000000000000044968" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044969" data-uri="chapter07.xhtml#P7000497027000000000000000044969" class="pcalibre calibre3 pcalibre1"></p>
<pre id="P700049702700000000000000004496A" data-uri="chapter07.xhtml#P700049702700000000000000004496A" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004496B" data-uri="chapter07.xhtml#P700049702700000000000000004496B" class="calibre10 pcalibre pcalibre1">/* Module 1 */		/* Module 2 */
intx;			doublex=1.0;
void main()		int p2()
{			{
}			}
(a) REF(x.1) → DEF(_____._____)
(b) REF(x.2) → DEF(_____._____)</code></pre>
</li></ol></div></li>
</ol>
</section>
</section>
<section id="P70004970270000000000000000061DE" data-uri="chapter07.xhtml#P70004970270000000000000000061DE" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004496C" data-uri="chapter07.xhtml#P700049702700000000000000004496C" epub:type="title"><span class="pcalibre label pcalibre1">7.6.2 </span>Linking with Static Libraries</h1></header>
<p id="P700049702700000000000000004496D" data-uri="chapter07.xhtml#P700049702700000000000000004496D" class="pcalibre1 pcalibre calibre2">So far, we have assumed that the linker reads a collection of relocatable object files and links them together into an output executable file. In practice, all compilation systems provide a mechanism for packaging related object modules into a single file called a <i class="calibre5 pcalibre pcalibre1">static library</i>, which can then be supplied as input to the linker. When it builds the output executable, the linker copies only the object modules in the library that are referenced by the application program.</p>
<p id="P700049702700000000000000004496E" data-uri="chapter07.xhtml#P700049702700000000000000004496E" class="pcalibre1 pcalibre calibre2">Why do systems support the notion of libraries? Consider ISO C99, which defines an extensive collection of standard I/O, string manipulation, and integer math functions such as <code id="P700049702700000000000000004496F" data-uri="chapter07.xhtml#P700049702700000000000000004496F" class="pcalibre1 calibre8 pcalibre">atoi, printf, scanf, strcpy</code>, and <code id="P7000497027000000000000000044970" data-uri="chapter07.xhtml#P7000497027000000000000000044970" class="pcalibre1 calibre8 pcalibre">rand</code>. They are available <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000061E4" title="685" data-uri="chapter07.xhtml#P70004970270000000000000000061E4" epub:type="pagebreak"></span>to every C program in the <code id="P7000497027000000000000000044971" data-uri="chapter07.xhtml#P7000497027000000000000000044971" class="pcalibre1 calibre8 pcalibre">libc.a</code> library. ISO C99 also defines an extensive collection of floating-point math functions such as <code id="P7000497027000000000000000044972" data-uri="chapter07.xhtml#P7000497027000000000000000044972" class="pcalibre1 calibre8 pcalibre">sin, cos</code>, and <code id="P7000497027000000000000000044973" data-uri="chapter07.xhtml#P7000497027000000000000000044973" class="pcalibre1 calibre8 pcalibre">sqrt</code> in the <code id="P7000497027000000000000000044974" data-uri="chapter07.xhtml#P7000497027000000000000000044974" class="pcalibre1 calibre8 pcalibre">libm.a</code> library.</p>
<p id="P7000497027000000000000000044975" data-uri="chapter07.xhtml#P7000497027000000000000000044975" class="pcalibre1 pcalibre calibre2">Consider the different approaches that compiler developers might use to provide these functions to users without the benefit of static libraries. One approach would be to have the compiler recognize calls to the standard functions and to generate the appropriate code directly. Pascal, which provides a small set of standard functions, takes this approach, but it is not feasible for C, because of the large number of standard functions defined by the C standard. It would add significant complexity to the compiler and would require a new compiler version each time a function was added, deleted, or modified. To application programmers, however, this approach would be quite convenient because the standard functions would always be available.</p>
<p id="P7000497027000000000000000044976" data-uri="chapter07.xhtml#P7000497027000000000000000044976" class="pcalibre1 pcalibre calibre2">Another approach would be to put all of the standard C functions in a single relocatable object module, say, <code id="P7000497027000000000000000044977" data-uri="chapter07.xhtml#P7000497027000000000000000044977" class="pcalibre1 calibre8 pcalibre">libc.o</code>, that application programmers could link into their executables:</p>
<pre id="P7000497027000000000000000044978" data-uri="chapter07.xhtml#P7000497027000000000000000044978" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044979" data-uri="chapter07.xhtml#P7000497027000000000000000044979" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc main.c /usr/lib/libc.o</i></code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004497A" data-uri="chapter07.xhtml#P700049702700000000000000004497A">This approach has the advantage that it would decouple the implementation of the standard functions from the implementation of the compiler, and would still be reasonably convenient for programmers. However, a big disadvantage is that every executable file in a system would now contain a complete copy of the collection of standard functions, which would be extremely wasteful of disk space. (On our system, <code id="P700049702700000000000000004497B" data-uri="chapter07.xhtml#P700049702700000000000000004497B" class="pcalibre1 calibre8 pcalibre">libc.a</code> is about 5 MB and <code id="P700049702700000000000000004497C" data-uri="chapter07.xhtml#P700049702700000000000000004497C" class="pcalibre1 calibre8 pcalibre">libm.a</code> is about 2 MB.) Worse, each running program would now contain its own copy of these functions in memory, which would be extremely wasteful of memory. Another big disadvantage is that any change to any standard function, no matter how small, would require the library developer to recompile the entire source file, a time-consuming operation that would complicate the development and maintenance of the standard functions.</p>
<p id="P700049702700000000000000004497D" data-uri="chapter07.xhtml#P700049702700000000000000004497D" class="pcalibre1 pcalibre calibre2">We could address some of these problems by creating a separate relocatable file for each standard function and storing them in a well-known directory. However, this approach would require application programmers to explicitly link the appropriate object modules into their executables, a process that would be error prone and time consuming:</p>
<pre id="P700049702700000000000000004497E" data-uri="chapter07.xhtml#P700049702700000000000000004497E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004497F" data-uri="chapter07.xhtml#P700049702700000000000000004497F" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc main.c /usr/lib/printf.o /usr/lib/scanf.o . . .</i></code></pre>
<p id="P7000497027000000000000000044980" data-uri="chapter07.xhtml#P7000497027000000000000000044980" class="pcalibre1 pcalibre calibre2">The notion of a static library was developed to resolve the disadvantages of these various approaches. Related functions can be compiled into separate object modules and then packaged in a single static library file. Application programs can then use any of the functions defined in the library by specifying a single filename on the command line. For example, a program that uses functions from the C standard library and the math library could be compiled and linked with a command of the form</p>
<pre id="P7000497027000000000000000044981" data-uri="chapter07.xhtml#P7000497027000000000000000044981" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044982" data-uri="chapter07.xhtml#P7000497027000000000000000044982" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc main.c /usr/lib/libm.a /usr/lib/libc.a</i></code></pre>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000061F7" data-uri="chapter07.xhtml#P70004970270000000000000000061F7">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000061F8" title="686" data-uri="chapter07.xhtml#P70004970270000000000000000061F8" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000044983" data-uri="chapter07.xhtml#P7000497027000000000000000044983" class="pcalibre1 pcalibre calibre2">(a) <code id="P7000497027000000000000000044984" data-uri="chapter07.xhtml#P7000497027000000000000000044984" class="pcalibre1 calibre8 pcalibre">addvec.o</code></p>
<p id="P7000497027000000000000000044985" data-uri="chapter07.xhtml#P7000497027000000000000000044985" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/link/addvec.c</i></p>
<pre id="P7000497027000000000000000044986" data-uri="chapter07.xhtml#P7000497027000000000000000044986" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044987" data-uri="chapter07.xhtml#P7000497027000000000000000044987" class="calibre10 pcalibre pcalibre1">
1	int addcnt = 0; 2
3	void addvec(int *x, int *y,
4				int *z, int n)
5	{
6		int i;
7
8		addcnt++;
9
10		for (i = 0; i &lt; n; i++)
11			z[i] = x[i] + y[i];
12	}
</code></pre>
<p id="P7000497027000000000000000044988" data-uri="chapter07.xhtml#P7000497027000000000000000044988" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/link/addvec.c</i></p>
<p id="P7000497027000000000000000044989" data-uri="chapter07.xhtml#P7000497027000000000000000044989" class="pcalibre1 pcalibre calibre2">(b) <code id="P700049702700000000000000004498A" data-uri="chapter07.xhtml#P700049702700000000000000004498A" class="pcalibre1 calibre8 pcalibre">multvec.o</code></p>
<p id="P700049702700000000000000004498B" data-uri="chapter07.xhtml#P700049702700000000000000004498B" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/link/multvec.c</i></p>
<pre id="P700049702700000000000000004498C" data-uri="chapter07.xhtml#P700049702700000000000000004498C" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004498D" data-uri="chapter07.xhtml#P700049702700000000000000004498D" class="calibre10 pcalibre pcalibre1">
1	int multcnt = 0;
2
3	void multvec(int *x, int *y,
4			int *z, int n)
5	{
6		int i;
7
8		multcnt++;
9
10		for (i = 0; i &lt; n; i++)
11			z[i] = x[i] * y[i];
12	}
</code></pre>
<p id="P700049702700000000000000004498E" data-uri="chapter07.xhtml#P700049702700000000000000004498E" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/link/multvec.c</i></p>
<figcaption id="P700049702700000000000000004498F" data-uri="chapter07.xhtml#P700049702700000000000000004498F" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000044990" data-uri="chapter07.xhtml#P7000497027000000000000000044990" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">7.6 </span>Member object files in the <code id="P7000497027000000000000000044991" data-uri="chapter07.xhtml#P7000497027000000000000000044991" class="pcalibre1 calibre8 pcalibre">libvector</code> library.</h1></header>
</figcaption>
</figure>
<p id="P7000497027000000000000000044992" data-uri="chapter07.xhtml#P7000497027000000000000000044992" class="pcalibre1 pcalibre calibre2">At link time, the linker will only copy the object modules that are referenced by the program, which reduces the size of the executable on disk and in memory. On the other hand, the application programmer only needs to include the names of a few library files. (In fact, C compiler drivers always pass <code id="P7000497027000000000000000044993" data-uri="chapter07.xhtml#P7000497027000000000000000044993" class="pcalibre1 calibre8 pcalibre">libc.a</code> to the linker, so the reference to <code id="P7000497027000000000000000044994" data-uri="chapter07.xhtml#P7000497027000000000000000044994" class="pcalibre1 calibre8 pcalibre">libc.a</code> mentioned previously is unnecessary.)</p>
<p id="P7000497027000000000000000044995" data-uri="chapter07.xhtml#P7000497027000000000000000044995" class="pcalibre1 pcalibre calibre2">On Linux systems, static libraries are stored on disk in a particular file format known as an <i class="calibre5 pcalibre pcalibre1">archive</i>. An archive is a collection of concatenated relocatable object files, with a header that describes the size and location of each member object file. Archive filenames are denoted with the <code id="P7000497027000000000000000044996" data-uri="chapter07.xhtml#P7000497027000000000000000044996" class="pcalibre1 calibre8 pcalibre">.a suffix.</code></p>
<p id="P7000497027000000000000000044997" data-uri="chapter07.xhtml#P7000497027000000000000000044997" class="pcalibre1 pcalibre calibre2">To make our discussion of libraries concrete, consider the pair of vector routines in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000061F7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">7.6</span></a>. Each routine, defined in its own object module, performs a vector operation on a pair of input vectors and stores the result in an output vector. As a side effect, each routine records the number of times it has been called by incrementing a global variable. (This will be useful when we explain the idea of position-independent code in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006428.xhtml#P7000497027000000000000000006428"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">7.12</span></a>.)</p>
<p id="P7000497027000000000000000044998" data-uri="chapter07.xhtml#P7000497027000000000000000044998" class="pcalibre1 pcalibre calibre2">To create a static library of these functions, we would use the <code id="P7000497027000000000000000044999" data-uri="chapter07.xhtml#P7000497027000000000000000044999" class="pcalibre1 calibre8 pcalibre"><span class="smallcaps pcalibre pcalibre1">ar</span></code> tool as follows:</p>
<p id="P700049702700000000000000004499A" data-uri="chapter07.xhtml#P700049702700000000000000004499A" class="pcalibre1 pcalibre calibre2"><code id="P700049702700000000000000004499B" data-uri="chapter07.xhtml#P700049702700000000000000004499B" class="pcalibre1 calibre8 pcalibre">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -c addvec.c multvec.c</i></code></p>
<p id="P700049702700000000000000004499C" data-uri="chapter07.xhtml#P700049702700000000000000004499C" class="pcalibre1 pcalibre calibre2"><code id="P700049702700000000000000004499D" data-uri="chapter07.xhtml#P700049702700000000000000004499D" class="pcalibre1 calibre8 pcalibre">linux&gt; <i class="calibre5 pcalibre pcalibre1">ar rcs libvector.a addvec.o multvec.o</i></code></p>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004499E" data-uri="chapter07.xhtml#P700049702700000000000000004499E">To use the library, we might write an application such as <code id="P700049702700000000000000004499F" data-uri="chapter07.xhtml#P700049702700000000000000004499F" class="pcalibre1 calibre8 pcalibre">main2.c</code> in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000621E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">7.7</span></a>, which invokes the <code id="P70004970270000000000000000449A0" data-uri="chapter07.xhtml#P70004970270000000000000000449A0" class="pcalibre1 calibre8 pcalibre">addvec</code> library routine. The include (or header) file <code id="P70004970270000000000000000449A1" data-uri="chapter07.xhtml#P70004970270000000000000000449A1" class="pcalibre1 calibre8 pcalibre">vector.h</code> defines the function prototypes for the routines in <code id="P70004970270000000000000000449A2" data-uri="chapter07.xhtml#P70004970270000000000000000449A2" class="pcalibre1 calibre8 pcalibre">libvector.a</code>,</p>
<p id="P70004970270000000000000000449A3" data-uri="chapter07.xhtml#P70004970270000000000000000449A3" class="pcalibre1 pcalibre calibre2">To build the executable, we would compile and link the input files <code id="P70004970270000000000000000449A4" data-uri="chapter07.xhtml#P70004970270000000000000000449A4" class="pcalibre1 calibre8 pcalibre">main2.o</code> and <code id="P70004970270000000000000000449A5" data-uri="chapter07.xhtml#P70004970270000000000000000449A5" class="pcalibre1 calibre8 pcalibre">libvector.a</code>:</p>
<pre id="P70004970270000000000000000449A6" data-uri="chapter07.xhtml#P70004970270000000000000000449A6" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000449A7" data-uri="chapter07.xhtml#P70004970270000000000000000449A7" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -c main2.c</i>
linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -static -o prog2c main2.o . /libvector.a</i></code></pre>
<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000621E" data-uri="chapter07.xhtml#P700049702700000000000000000621E">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000621F" title="687" data-uri="chapter07.xhtml#P700049702700000000000000000621F" epub:type="pagebreak"></span>
<p id="P70004970270000000000000000449A8" data-uri="chapter07.xhtml#P70004970270000000000000000449A8" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/link/main2.c</i></p>
<pre id="P70004970270000000000000000449A9" data-uri="chapter07.xhtml#P70004970270000000000000000449A9" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000449AA" data-uri="chapter07.xhtml#P70004970270000000000000000449AA" class="calibre10 pcalibre pcalibre1">
1	#include &lt;stdio.h&gt;
2	#include "vector.h"
3
4	int x[2] = {1, 2};
5	int y[2] = {3, 4};
6	int z[2];
7
8	int main()
9	{
10		addvec(x, y, z, 2);
11		printf("z = [%d %d] n", z[0], z[1]);
12		return 0;
13	}
</code></pre>
<p id="P70004970270000000000000000449AB" data-uri="chapter07.xhtml#P70004970270000000000000000449AB" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/link/main2.c</i></p>
<figcaption id="P70004970270000000000000000449AC" data-uri="chapter07.xhtml#P70004970270000000000000000449AC" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000449AD" data-uri="chapter07.xhtml#P70004970270000000000000000449AD" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">7.7 </span>Example program 2.</h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000449AE" data-uri="chapter07.xhtml#P70004970270000000000000000449AE"><p id="P70004970270000000000000000449AF" data-uri="chapter07.xhtml#P70004970270000000000000000449AF" class="pcalibre calibre3 pcalibre1">This program invokes a function in the <code id="P70004970270000000000000000449B0" data-uri="chapter07.xhtml#P70004970270000000000000000449B0" class="pcalibre1 calibre8 pcalibre">libvector</code> library.</p></div></figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000006229" data-uri="chapter07.xhtml#P7000497027000000000000000006229">
<img alt="A diagram illustrates linking with static libraries." id="P70004970270000000000000000449B1" data-uri="P700049702700000000000000000B75A" src="../images/p687-1.png" class="pcalibre calibre232 pcalibre1"/>
<figcaption id="P70004970270000000000000000449B2" data-uri="chapter07.xhtml#P70004970270000000000000000449B2" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000449B3" data-uri="chapter07.xhtml#P70004970270000000000000000449B3" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">7.8 </span>Linking with static libraries.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000024CC5" data-uri="chapter07.xhtml#P7000497027000000000000000024CC5">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000449B4" data-uri="chapter07.xhtml#P70004970270000000000000000449B4" class="pcalibre1 pcalibre calibre2">A diagram shows a flow of files, as listed in order below.</p>
<ul id="P70004970270000000000000000449B5" data-uri="chapter07.xhtml#P70004970270000000000000000449B5" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000449B6" data-uri="chapter07.xhtml#P70004970270000000000000000449B6" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449B7" data-uri="chapter07.xhtml#P70004970270000000000000000449B7" class="pcalibre calibre3 pcalibre1">Source files: main2.c and vector.h</p></li>
<li id="P70004970270000000000000000449B8" data-uri="chapter07.xhtml#P70004970270000000000000000449B8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449B9" data-uri="chapter07.xhtml#P70004970270000000000000000449B9" class="pcalibre calibre3 pcalibre1">Translators (cpp, cc1, as)</p></li>
<li id="P70004970270000000000000000449BA" data-uri="chapter07.xhtml#P70004970270000000000000000449BA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449BB" data-uri="chapter07.xhtml#P70004970270000000000000000449BB" class="pcalibre calibre3 pcalibre1">Three relocatable object files:</p>
<ul id="P70004970270000000000000000449BC" data-uri="chapter07.xhtml#P70004970270000000000000000449BC" class="pcalibre calibre39 pcalibre1">
<li id="P70004970270000000000000000449BD" data-uri="chapter07.xhtml#P70004970270000000000000000449BD" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449BE" data-uri="chapter07.xhtml#P70004970270000000000000000449BE" class="pcalibre calibre3 pcalibre1">Main2.o from translators</p></li>
<li id="P70004970270000000000000000449BF" data-uri="chapter07.xhtml#P70004970270000000000000000449BF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449C0" data-uri="chapter07.xhtml#P70004970270000000000000000449C0" class="pcalibre calibre3 pcalibre1">Addvec.o from libvector.a</p></li>
<li id="P70004970270000000000000000449C1" data-uri="chapter07.xhtml#P70004970270000000000000000449C1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449C2" data-uri="chapter07.xhtml#P70004970270000000000000000449C2" class="pcalibre calibre3 pcalibre1">Printf.o and any other modules called by printf.o from libc.a Static libraries</p></li>
</ul></li>
<li id="P70004970270000000000000000449C3" data-uri="chapter07.xhtml#P70004970270000000000000000449C3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449C4" data-uri="chapter07.xhtml#P70004970270000000000000000449C4" class="pcalibre calibre3 pcalibre1">Linter (ld)</p></li>
<li id="P70004970270000000000000000449C5" data-uri="chapter07.xhtml#P70004970270000000000000000449C5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449C6" data-uri="chapter07.xhtml#P70004970270000000000000000449C6" class="pcalibre calibre3 pcalibre1">Fully linked executable object file prog2c</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000449C7" data-uri="chapter07.xhtml#P70004970270000000000000000449C7">or equivalently,</p>
<pre id="P70004970270000000000000000449C8" data-uri="chapter07.xhtml#P70004970270000000000000000449C8" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000449C9" data-uri="chapter07.xhtml#P70004970270000000000000000449C9" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -c main2.c</i>
linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -static -o prog2c main2.o -L. -lvector</i></code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000449CA" data-uri="chapter07.xhtml#P70004970270000000000000000449CA"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006229"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">7.8</span></a> summarizes the activity of the linker. The <code id="P70004970270000000000000000449CB" data-uri="chapter07.xhtml#P70004970270000000000000000449CB" class="pcalibre1 calibre8 pcalibre">-static</code> argument tells the compiler driver that the linker should build a fully linked executable object file that can be loaded into memory and run without any further linking at load time. The <code id="P70004970270000000000000000449CC" data-uri="chapter07.xhtml#P70004970270000000000000000449CC" class="pcalibre1 calibre8 pcalibre">-lvector</code> argument is a shorthand for <code id="P70004970270000000000000000449CD" data-uri="chapter07.xhtml#P70004970270000000000000000449CD" class="pcalibre1 calibre8 pcalibre">libvector.a</code>, and the <code id="P70004970270000000000000000449CE" data-uri="chapter07.xhtml#P70004970270000000000000000449CE" class="pcalibre1 calibre8 pcalibre">-L</code>. argument tells the linker to look for <code id="P70004970270000000000000000449CF" data-uri="chapter07.xhtml#P70004970270000000000000000449CF" class="pcalibre1 calibre8 pcalibre">libvector.a</code> in the current directory.</p>
<p id="P70004970270000000000000000449D0" data-uri="chapter07.xhtml#P70004970270000000000000000449D0" class="pcalibre1 pcalibre calibre2">When the linker runs, it determines that the <code id="P70004970270000000000000000449D1" data-uri="chapter07.xhtml#P70004970270000000000000000449D1" class="pcalibre1 calibre8 pcalibre">addvec</code> symbol defined by <code id="P70004970270000000000000000449D2" data-uri="chapter07.xhtml#P70004970270000000000000000449D2" class="pcalibre1 calibre8 pcalibre">addvec.o</code> is referenced by <code id="P70004970270000000000000000449D3" data-uri="chapter07.xhtml#P70004970270000000000000000449D3" class="pcalibre1 calibre8 pcalibre">main2.o</code>, so it copies <code id="P70004970270000000000000000449D4" data-uri="chapter07.xhtml#P70004970270000000000000000449D4" class="pcalibre1 calibre8 pcalibre">addvec.o</code> into the executable. <span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000623B" title="688" data-uri="chapter07.xhtml#P700049702700000000000000000623B" epub:type="pagebreak"></span>Since the program doesn't reference any symbols defined by <code id="P70004970270000000000000000449D5" data-uri="chapter07.xhtml#P70004970270000000000000000449D5" class="pcalibre1 calibre8 pcalibre">multvec.o</code>, the linker does <i class="calibre5 pcalibre pcalibre1">not</i> copy this module into the executable. The linker also copies the <code id="P70004970270000000000000000449D6" data-uri="chapter07.xhtml#P70004970270000000000000000449D6" class="pcalibre1 calibre8 pcalibre">printf.o</code> module from <code id="P70004970270000000000000000449D7" data-uri="chapter07.xhtml#P70004970270000000000000000449D7" class="pcalibre1 calibre8 pcalibre">libc.a</code>, along with a number of other modules from the C run-time system.</p>
</section>
<section id="P700049702700000000000000000623F" data-uri="chapter07.xhtml#P700049702700000000000000000623F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000449D8" data-uri="chapter07.xhtml#P70004970270000000000000000449D8" epub:type="title"><span class="pcalibre label pcalibre1">7.6.3 </span>How Linkers Use Static Libraries to Resolve References</h1></header>
<p id="P70004970270000000000000000449D9" data-uri="chapter07.xhtml#P70004970270000000000000000449D9" class="pcalibre1 pcalibre calibre2">While static libraries are useful, they are also a source of confusion to programmers because of the way the Linux linker uses them to resolve external references. During the symbol resolution phase, the linker scans the relocatable object files and archives left to right in the same sequential order that they appear on the compiler driver's command line. (The driver automatically translates any <code id="P70004970270000000000000000449DA" data-uri="chapter07.xhtml#P70004970270000000000000000449DA" class="pcalibre1 calibre8 pcalibre">.c files</code> on the command line into <code id="P70004970270000000000000000449DB" data-uri="chapter07.xhtml#P70004970270000000000000000449DB" class="pcalibre1 calibre8 pcalibre">.o files</code>.) During this scan, the linker maintains a set <var class="calibre5 pcalibre pcalibre1">E</var> of relocatable object files that will be merged to form the executable, a set <var class="calibre5 pcalibre pcalibre1">U</var> of unresolved symbols (i.e., symbols referred to but not yet defined), and a set <var class="calibre5 pcalibre pcalibre1">D</var> of symbols that have been defined in previous input files. Initially, <var class="calibre5 pcalibre pcalibre1">E</var>, <var class="calibre5 pcalibre pcalibre1">U</var>, and <var class="calibre5 pcalibre pcalibre1">D</var> are empty.</p>
<ul id="P70004970270000000000000000449DC" data-uri="chapter07.xhtml#P70004970270000000000000000449DC" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000449DD" data-uri="chapter07.xhtml#P70004970270000000000000000449DD" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449DE" data-uri="chapter07.xhtml#P70004970270000000000000000449DE" class="pcalibre calibre3 pcalibre1">For each input file <var class="calibre5 pcalibre pcalibre1">f</var> on the command line, the linker determines if <var class="calibre5 pcalibre pcalibre1">f</var> is an object file or an archive. If <var class="calibre5 pcalibre pcalibre1">f</var> is an object file, the linker adds <var class="calibre5 pcalibre pcalibre1">f</var> to <var class="calibre5 pcalibre pcalibre1">E</var>, updates <var class="calibre5 pcalibre pcalibre1">U</var> and <var class="calibre5 pcalibre pcalibre1">D</var> to reflect the symbol definitions and references in <var class="calibre5 pcalibre pcalibre1">f</var>, and proceeds to the next input file.</p></li>
<li id="P70004970270000000000000000449DF" data-uri="chapter07.xhtml#P70004970270000000000000000449DF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449E0" data-uri="chapter07.xhtml#P70004970270000000000000000449E0" class="pcalibre calibre3 pcalibre1">If <var class="calibre5 pcalibre pcalibre1">f</var> is an archive, the linker attempts to match the unresolved symbols in <var class="calibre5 pcalibre pcalibre1">U</var> against the symbols defined by the members of the archive. If some archive member <var class="calibre5 pcalibre pcalibre1">m</var> defines a symbol that resolves a reference in <var class="calibre5 pcalibre pcalibre1">U</var>, then <var class="calibre5 pcalibre pcalibre1">m</var> is added to <var class="calibre5 pcalibre pcalibre1">E</var>, and the linker updates <var class="calibre5 pcalibre pcalibre1">U</var> and <var class="calibre5 pcalibre pcalibre1">D</var> to reflect the symbol definitions and references in <var class="calibre5 pcalibre pcalibre1">m</var>. This process iterates over the member object files in the archive until a fixed point is reached where <var class="calibre5 pcalibre pcalibre1">U</var> and <var class="calibre5 pcalibre pcalibre1">D</var> no longer change. At this point, any member object files not contained in <var class="calibre5 pcalibre pcalibre1">E</var> are simply discarded and the linker proceeds to the next input file.</p></li>
<li id="P70004970270000000000000000449E1" data-uri="chapter07.xhtml#P70004970270000000000000000449E1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000449E2" data-uri="chapter07.xhtml#P70004970270000000000000000449E2" class="pcalibre calibre3 pcalibre1">If <var class="calibre5 pcalibre pcalibre1">U</var> is nonempty when the linker finishes scanning the input files on the command line, it prints an error and terminates. Otherwise, it merges and relocates the object files in <var class="calibre5 pcalibre pcalibre1">E</var> to build the output executable file.</p></li>
</ul>
<p id="P70004970270000000000000000449E3" data-uri="chapter07.xhtml#P70004970270000000000000000449E3" class="pcalibre1 pcalibre calibre2">Unfortunately, this algorithm can result in some baffling link-time errors because the ordering of libraries and object files on the command line is significant. If the library that defines a symbol appears on the command line before the object file that references that symbol, then the reference will not be resolved and linking will fail. For example, consider the following:</p>
<pre id="P70004970270000000000000000449E4" data-uri="chapter07.xhtml#P70004970270000000000000000449E4" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000449E5" data-uri="chapter07.xhtml#P70004970270000000000000000449E5" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -static . /libvector.a main2.c</i>
/tmp/cc9XH6Rp.o: In function `main':
/tmp/cc9XH6Rp.o(.text+0x18): undefined reference to `addvec'</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000449E6" data-uri="chapter07.xhtml#P70004970270000000000000000449E6">What happened? When <code id="P70004970270000000000000000449E7" data-uri="chapter07.xhtml#P70004970270000000000000000449E7" class="pcalibre1 calibre8 pcalibre">libvector.a</code> is processed, <var class="calibre5 pcalibre pcalibre1">U</var> is empty, so no member object files from <code id="P70004970270000000000000000449E8" data-uri="chapter07.xhtml#P70004970270000000000000000449E8" class="pcalibre1 calibre8 pcalibre">libvector.a</code> are added to <var class="calibre5 pcalibre pcalibre1">E</var>. Thus, the reference to <code id="P70004970270000000000000000449E9" data-uri="chapter07.xhtml#P70004970270000000000000000449E9" class="pcalibre1 calibre8 pcalibre">addvec</code> is never resolved and the linker emits an error message and terminates.</p>
<p id="P70004970270000000000000000449EA" data-uri="chapter07.xhtml#P70004970270000000000000000449EA" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006253" title="689" data-uri="chapter07.xhtml#P7000497027000000000000000006253" epub:type="pagebreak"></span>The general rule for libraries is to place them at the end of the command line. If the members of the different libraries are independent, in that no member references a symbol defined by another member, then the libraries can be placed at the end of the command line in any order. If, on the other hand, the libraries are not independent, then they must be ordered so that for each symbol <var class="calibre5 pcalibre pcalibre1">s</var> that is referenced externally by a member of an archive, at least one definition of <var class="calibre5 pcalibre pcalibre1">s</var> follows a reference to <var class="calibre5 pcalibre pcalibre1">s</var> on the command line. For example, suppose <code id="P70004970270000000000000000449EB" data-uri="chapter07.xhtml#P70004970270000000000000000449EB" class="pcalibre1 calibre8 pcalibre">foo.c</code> calls functions in <code id="P70004970270000000000000000449EC" data-uri="chapter07.xhtml#P70004970270000000000000000449EC" class="pcalibre1 calibre8 pcalibre">libx.a</code> and <code id="P70004970270000000000000000449ED" data-uri="chapter07.xhtml#P70004970270000000000000000449ED" class="pcalibre1 calibre8 pcalibre">libz.a</code> that call functions in <code id="P70004970270000000000000000449EE" data-uri="chapter07.xhtml#P70004970270000000000000000449EE" class="pcalibre1 calibre8 pcalibre">liby.a</code>. Then <code id="P70004970270000000000000000449EF" data-uri="chapter07.xhtml#P70004970270000000000000000449EF" class="pcalibre1 calibre8 pcalibre">libx.a</code> and <code id="P70004970270000000000000000449F0" data-uri="chapter07.xhtml#P70004970270000000000000000449F0" class="pcalibre1 calibre8 pcalibre">libz.a</code> must precede <code id="P70004970270000000000000000449F1" data-uri="chapter07.xhtml#P70004970270000000000000000449F1" class="pcalibre1 calibre8 pcalibre">liby.a</code> on the command line:</p>
<pre id="P70004970270000000000000000449F2" data-uri="chapter07.xhtml#P70004970270000000000000000449F2" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000449F3" data-uri="chapter07.xhtml#P70004970270000000000000000449F3" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc foo.c libx.a libz.a liby.a</i></code></pre>
<p id="P70004970270000000000000000449F4" data-uri="chapter07.xhtml#P70004970270000000000000000449F4" class="pcalibre1 pcalibre calibre2">Libraries can be repeated on the command line if necessary to satisfy the dependence requirements. For example, suppose <code id="P70004970270000000000000000449F5" data-uri="chapter07.xhtml#P70004970270000000000000000449F5" class="pcalibre1 calibre8 pcalibre">foo.c</code> calls a function in <code id="P70004970270000000000000000449F6" data-uri="chapter07.xhtml#P70004970270000000000000000449F6" class="pcalibre1 calibre8 pcalibre">libx.a</code> that calls a function in <code id="P70004970270000000000000000449F7" data-uri="chapter07.xhtml#P70004970270000000000000000449F7" class="pcalibre1 calibre8 pcalibre">liby.a</code> that calls a function in <code id="P70004970270000000000000000449F8" data-uri="chapter07.xhtml#P70004970270000000000000000449F8" class="pcalibre1 calibre8 pcalibre">libx.a</code>. Then <code id="P70004970270000000000000000449F9" data-uri="chapter07.xhtml#P70004970270000000000000000449F9" class="pcalibre1 calibre8 pcalibre">libx.a</code> must be repeated on the command line:</p>
<pre id="P70004970270000000000000000449FA" data-uri="chapter07.xhtml#P70004970270000000000000000449FA" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000449FB" data-uri="chapter07.xhtml#P70004970270000000000000000449FB" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc foo.c libx.a liby.a libx.a</i></code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000449FC" data-uri="chapter07.xhtml#P70004970270000000000000000449FC">Alternatively, we could combine <code id="P70004970270000000000000000449FD" data-uri="chapter07.xhtml#P70004970270000000000000000449FD" class="pcalibre1 calibre8 pcalibre">libx.a</code> and <code id="P70004970270000000000000000449FE" data-uri="chapter07.xhtml#P70004970270000000000000000449FE" class="pcalibre1 calibre8 pcalibre">liby.a</code> into a single archive.</p>
<section id="P7000497027000000000000000006268" data-uri="chapter07.xhtml#P7000497027000000000000000006268" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000449FF" data-uri="chapter07.xhtml#P70004970270000000000000000449FF" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">7.3 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000065E7.xhtml#P70004970270000000000000000065EF">718</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000044A00" data-uri="chapter07.xhtml#P7000497027000000000000000044A00">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000044A01" data-uri="chapter07.xhtml#P7000497027000000000000000044A01">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000044A02" data-uri="chapter07.xhtml#P7000497027000000000000000044A02"><p id="P7000497027000000000000000044A03" data-uri="chapter07.xhtml#P7000497027000000000000000044A03" class="pcalibre calibre3 pcalibre1">Let <code id="P7000497027000000000000000044A04" data-uri="chapter07.xhtml#P7000497027000000000000000044A04" class="pcalibre1 calibre8 pcalibre">a</code> and <code id="P7000497027000000000000000044A05" data-uri="chapter07.xhtml#P7000497027000000000000000044A05" class="pcalibre1 calibre8 pcalibre">b</code> denote object modules or static libraries in the current directory, and let <code id="P7000497027000000000000000044A06" data-uri="chapter07.xhtml#P7000497027000000000000000044A06" class="pcalibre1 calibre8 pcalibre">a→b</code> denote that <var class="calibre5 pcalibre pcalibre1">a</var> depends on <var class="calibre5 pcalibre pcalibre1">b</var>, in the sense that <var class="calibre5 pcalibre pcalibre1">b</var> defines a symbol that is referenced by <var class="calibre5 pcalibre pcalibre1">a</var>. For each of the following scenarios, show the minimal command line (i.e., one with the least number of object file and library arguments) that will allow the static linker to resolve all symbol references.</p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P7000497027000000000000000044A07" data-uri="chapter07.xhtml#P7000497027000000000000000044A07">
<li id="P7000497027000000000000000044A08" data-uri="chapter07.xhtml#P7000497027000000000000000044A08" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044A09" data-uri="chapter07.xhtml#P7000497027000000000000000044A09" class="pcalibre calibre3 pcalibre1"></p>
<pre id="P7000497027000000000000000044A0A" data-uri="chapter07.xhtml#P7000497027000000000000000044A0A" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044A0B" data-uri="chapter07.xhtml#P7000497027000000000000000044A0B" class="calibre10 pcalibre pcalibre1">p.o → libx.a</code></pre></li>
<li id="P7000497027000000000000000044A0C" data-uri="chapter07.xhtml#P7000497027000000000000000044A0C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044A0D" data-uri="chapter07.xhtml#P7000497027000000000000000044A0D" class="pcalibre calibre3 pcalibre1"></p>
<pre id="P7000497027000000000000000044A0E" data-uri="chapter07.xhtml#P7000497027000000000000000044A0E" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044A0F" data-uri="chapter07.xhtml#P7000497027000000000000000044A0F" class="calibre10 pcalibre pcalibre1">p.o → libx.a → liby.a</code></pre></li>
<li id="P7000497027000000000000000044A10" data-uri="chapter07.xhtml#P7000497027000000000000000044A10" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044A11" data-uri="chapter07.xhtml#P7000497027000000000000000044A11" class="pcalibre calibre3 pcalibre1"></p>
<pre id="P7000497027000000000000000044A12" data-uri="chapter07.xhtml#P7000497027000000000000000044A12" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044A13" data-uri="chapter07.xhtml#P7000497027000000000000000044A13" class="calibre10 pcalibre pcalibre1">p.o → libx.a → liby.a <i class="calibre5 pcalibre pcalibre1">and</i> liby.a → libx.a → p.o</code></pre>
</li>
</ol></div>
</li></ol>
</section>
</section>
</section></body></html>
