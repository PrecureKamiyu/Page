<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>21.2  Data Partitioning</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part384.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part386.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark462">21.2  </a><span style=" color: #00AEEF;">Data Partitioning</span><a name="bookmark508">&zwnj;</a></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In its simplest form, <span class="s64">I/O </span><span class="s84">parallelism </span>refers to reducing the time required to retrieve data from disk by partitioning the data over multiple disks.<span class="s76">1</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">At the lowest level, <span class="s44">RAID </span>systems allow blocks to be partitioned across multiple disks, allowing them to be accessed in parallel. Blocks are usually allocated to diﬀerent disks in a round-robin fashion, as we saw in Section 12.5. For example, if there are <i>n </i>disks numbered 0 to <i>n </i><span class="s15">− </span>1, round-robin allocation assigns block <i>i </i>to disk <i>i </i>mod <i>n</i>. However, the block-level partitioning techniques supported by <span class="s44">RAID </span>systems do not oﬀer any control in terms of which tuples of a relation are stored on which disk or node. Therefore, parallel database systems typically do not use block-level partitioning and instead perform partitioning at the level of tuples.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In systems with multiple nodes (computers), each with multiple disks, partitioning can potentially be speciﬁed to the level of individual disks. However, parallel database systems typically focus on partitioning data across nodes and leave it to the operating system on each node to decide on assigning blocks to disks within the node.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In a parallel storage system, the tuples of a relation are partitioned (divided) among many nodes, so that each tuple resides on one node; such partitioning is referred to as <span class="s63">horizontal partitioning</span>. Several partitioning strategies have been proposed for horizon- tal partitioning, which we study next.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We note that <i>vertical partitioning</i>, discussed in Section 13.6 in the context of colum- nar storage, is orthogonal to horizontal partitioning. (As an example of vertical parti- tioning, a relation <i>r</i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>D</i>) where <i>A </i>is a primary key, may be vertically partitioned into <i>r</i>(<i>A</i>, <i>B</i>) and <i>r</i>(<i>A</i>, <i>C</i>, <i>D</i>), if many queries require <i>B </i>values, while <i>C </i>and <i>D </i>values are large in size and not required for many queries.) Once tuples are horizontally parti- tioned, they may be stored in a vertically partitioned manner at each node.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We also note that several database vendors use the term <i>partitioning </i>to denote the partitioning of tuples of a relation <i>r </i>into multiple physical relations <i>r</i><span class="s98">1</span>, <i>r</i><span class="s98">2</span>, <span class="s15">… </span>, <i>r</i><span class="s145">n</span>, where all the physical relations <i>r</i><span class="s145">i </span>are stored in a single node. The relation <i>r </i>is not stored, but treated as a view deﬁned by the query <i>r</i><span class="s98">1</span> <span class="s15">∪ </span><i>r</i><span class="s98">2</span> <span class="s15">∪…∪ </span><i>r</i><span class="s97">n</span>. Such <i>intra-node partitioning </i>of a relation is typically used to ensure that frequently accessed tuples are stored separately from infrequently accessed tuples and is diﬀerent from horizontal partitioning across nodes. Intra-node partitioning is described in more detail in Section 25.1.4.3.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In the rest of this chapter, as well as in subsequent chapters, we use the term <i>par- titioning </i>to refer to <i>horizontal partitioning </i>across multiple nodes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">21.2.1 Partitioning Strategies</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We present three basic <i>data-partitioning strategies </i>for partitioning tuples. Assume that there are <i>n </i>nodes, <i>N</i><span class="s98">1</span>, <i>N</i><span class="s98">1</span>, <span class="s15">… </span>, <i>N</i><span class="s145">n</span>, across which the data are to be partitioned.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_3139.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">1<span class="s78">As in earlier chapters, we use the term </span><span class="s111">disk </span><span class="s80">to refer to persistent storage devices, such as magnetic hard disks and solid-state drives.</span></p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">21.2 <span style=" color: #00AEEF;">Data Partitioning  </span><span class="s164">1005</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 204pt;text-indent: -24pt;text-align: left;">Range partitioning vector</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">Node</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 42pt;text-indent: -6pt;text-align: left;">Range associated with the node</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="125" height="142" alt="image" src="Image_3140.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">15</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">40</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">75</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 10pt;text-indent: 0pt;text-align: left;">Node 4</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 10pt;text-indent: 0pt;text-align: left;">Node 3</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 10pt;text-indent: 0pt;text-align: left;">Node 2</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 10pt;text-indent: 0pt;text-align: left;">Node 1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s118" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">[–∞, 15)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">[15, 40)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">[40, 75)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">[ 75, +∞]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-left: 196pt;text-indent: 0pt;text-align: left;">Figure 21.1 <span class="s74">Example of range partitioning vector.</span></p><p class="s130" style="padding-top: 6pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Round-robin</span><span class="p">. This strategy scans the relation in any order and sends the </span><span class="s13">i</span><span class="p">th tuple fetched during the scan to node number </span><span class="s13">N</span>((<i>i</i><span class="s136">−</span>1) <i>mod n</i>)<span class="s136">+</span>1<span class="s94">. The round-robin scheme ensures an even distribution of tuples across nodes; that is, each node has approx- imately the same number of tuples as the others.</span></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Hash partitioning</span>. This declustering strategy designates one or more attributes from the given relation’s schema as the partitioning attributes. A hash function is chosen whose range is <span class="s15">{</span>1, 2, <span class="s15">… </span>, <i>n</i><span class="s15">}</span>. Each tuple of the original relation is hashed on the partitioning attributes. If the hash function returns <i>i</i>, then the tuple is placed on node <i>N</i><span class="s97">i</span>.<span class="s76">2</span></p><p class="s13" style="padding-top: 2pt;padding-left: 139pt;text-indent: -16pt;line-height: 90%;text-align: justify;"><span class="s39">• </span><span class="s63">Range partitioning</span><span class="p">. This strategy distributes tuples by assigning contiguous attribute-value ranges to each node. It chooses a partitioning attribute, </span>A<span class="p">, and a </span><span class="s63">partitioning vector </span><span class="p">[</span>v<span class="s130">1</span><span class="s94">, </span>v<span class="s130">2</span><span class="s94">, </span><span class="s15">… </span><span class="p">, </span>v<span class="s97">n</span><span class="s136">−</span><span class="s130">1</span><span class="s94">], such that, if </span>i <span class="s83">&lt; </span>j<span class="p">, then </span>v<span class="s97">i </span><span class="s83">&lt; </span>v<span class="s97">j </span><span class="p">. The relation is</span></p><p class="s13" style="padding-left: 139pt;text-indent: 0pt;line-height: 10pt;text-align: justify;"><span class="p">partitioned as follows: Consider a tuple </span>t <span class="p">such that </span>t<span class="p">[</span>A<span class="p">] </span><span class="s15">= </span>x<span class="p">. If </span>x <span class="s83">&lt; </span>v<span class="s98">1</span><span class="p">, then </span>t <span class="p">goes</span></p><p class="s13" style="padding-left: 139pt;text-indent: 0pt;line-height: 70%;text-align: justify;"><span class="p">on node </span>N<span class="s130">1</span><span class="s94">. If </span>x <span class="s86">≥ </span>v<span class="s97">n</span><span class="s136">−</span><span class="s130">1</span><span class="s94">, then </span>t <span class="p">goes on node </span>N<span class="s97">n</span><span class="p">. If </span>v<span class="s97">i </span><span class="s86">≤ </span>x <span class="s83">&lt; </span>v<span class="s97">i</span><span class="s136">+</span><span class="s130">1</span><span class="s94">, then </span>t <span class="p">goes on node </span>N<span class="s145">i</span><span class="s171">+</span><span class="s93">1</span><span class="s94">.</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;line-height: 92%;text-align: justify;">Figure 21.1 shows an example of a range partitioning vector. In the example in the ﬁgure, values less than 15 are mapped to Node 1. Values in the range [15, 40), i.e., values <span class="s86">≥ </span>15 but <span class="s83">&lt; </span>40. are mapped to Node 2; Values in the range [40, 75), i.e., values</p><p style="padding-left: 87pt;text-indent: 0pt;line-height: 11pt;text-align: right;"><span class="s86">≥ </span>40 but <span class="s83">&lt; </span>75, are mapped to Node 3, while values <span class="s83">&gt; </span>75 are mapped to Node 4.</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 10pt;text-align: right;">We now consider how partitioning is maintained when a relation is updated.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span class="p">When a tuple is inserted into a relation, it is sent to the appropriate node based on the partitioning strategy.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_3141.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">2<span class="s78">Hash-function design is discussed in Section 24.5.1.1.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-top: 4pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">2. <span class="p">If a tuple is deleted, its location is ﬁrst found based on the value of its partitioning attribute (for round-robin, all partitions are searched). The tuple is then deleted from wherever it is located.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">3. <span class="p">If a tuple is updated, its location is not aﬀected if either round-robin partitioning is used or if the update does not aﬀect a partitioning attribute.</span></p><p style="padding-left: 113pt;text-indent: 0pt;text-align: justify;">However, if range partitioning or hash partitioning is used, and the update aﬀects a partitioning attribute, the location of the tuple may be aﬀected. In this case:</p><p style="padding-top: 7pt;padding-left: 123pt;text-indent: 0pt;text-align: left;">a. The original tuple is deleted from the original location, and</p><p style="padding-top: 6pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">b. The updated tuple is inserted and sent to the appropriate node based on the partitioning strategy used.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">21.2.2 Comparison of Partitioning Techniques</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Once a relation has been partitioned among several nodes, we can retrieve it in parallel, using all the nodes. Similarly, when a relation is being partitioned, it can be written to multiple nodes in parallel. Thus, the transfer rates for reading or writing an entire relation are much faster with <span class="s44">I/O </span>parallelism than without it. However, reading an entire relation, or <i>scanning a relation</i>, is only one kind of access to data. Access to data can be classiﬁed as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 97pt;text-indent: 0pt;text-align: left;">1. <span class="p">Scanning the entire relation.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3142.png"/></span></p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;"><span class="s63">2. </span>Locating a tuple associatively (e.g., <i>employee name </i>= “Campbell”); these queries, called <span class="s63">point queries</span>, seek tuples that have a speciﬁed value for a speciﬁc attribute.</p><p style="padding-top: 7pt;padding-left: 113pt;text-indent: -17pt;line-height: 84%;text-align: justify;"><span class="s63">3. </span>Locating all tuples for which the value of a given attribute lies within a speciﬁed range (e.g., 10000 <span class="s83">&lt; </span><i>salary </i><span class="s83">&lt; </span>20000); these queries are called <span class="s63">range queries</span>.</p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The diﬀerent partitioning techniques support these types of access at diﬀerent levels of eﬃciency:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Round-robin. </b>The scheme is ideally suited for applications that wish to read the entire relation sequentially for each query. With this scheme, both point queries and range queries are complicated to process, since each of the <i>n </i>nodes must be used for the search.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3143.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3144.png"/></span></p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Hash partitioning. </b>This scheme is best suited for point queries based on the parti- tioning attribute. For example, if a relation is partitioned on the <i>telephone number </i>attribute, then we can answer the query “Find the record of the employee with <i>telephone number </i>= 555-3333” by applying the partitioning hash function to 555- 3333 and then searching that node. Directing a query to a single node saves the start-up cost of initiating a query on multiple nodes and leaves the other nodes free to process other queries.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 15pt;text-align: justify;"><a name="bookmark463">Hash partitioning is also useful for sequential scans of the entire relation. If the hash function is a good randomizing function, and the partitioning attributes form a key of the relation, then the number of tuples in each of the nodes is ap- proximately the same, without much variance. Hence, the time taken to scan the relation is approximately 1</a><span class="s15">∕</span><i>n </i>of the time required to scan the relation in a single node system.<a name="bookmark509">&zwnj;</a></p><p style="padding-left: 139pt;text-indent: 16pt;text-align: justify;">The scheme, however, is not well suited for point queries on nonpartition- ing attributes. Hash-based partitioning is also not well suited for answering range queries, since, typically, hash functions do not preserve proximity within a range. Therefore, all the nodes need to be scanned for range queries to be answered.</p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s46">Range partitioning. </span><span class="p">This scheme is well suited for point and range queries on the partitioning attribute. For point queries, we can consult the partitioning vector to locate the node where the tuple resides. For range queries, we consult the partition- ing vector to ﬁnd the range of nodes on which the tuples may reside. In both cases, the search narrows to exactly those nodes that might have any tuples of interest.</span></p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">An advantage of this feature is that, if there are only a few tuples in the queried range, then the query is typically sent to one node, as opposed to all the nodes. Since other nodes can be used to answer other queries, range partitioning results in higher throughput while maintaining good response time. On the other hand, if there are many tuples in the queried range (as there are when the queried range is a larger fraction of the domain of the relation), many tuples have to be retrieved from a few nodes, resulting in an <span class="s44">I/O </span>bottleneck (hot spot) at those nodes. In this example of <span class="s63">execution skew</span>, all processing occurs in one — or only a few— partitions. In contrast, hash partitioning and round-robin partitioning would engage all the nodes for such queries, giving a faster response time for approximately the same throughput.</p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The type of partitioning also aﬀects other relational operations, such as joins, as we shall see in Section 22.3 and Section 22.4.1.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Thus, the choice of partitioning technique also depends on the operations that need to be executed. In general, hash partitioning or range partitioning are preferred to round-robin partitioning.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Partitioning is important for large relations. Large databases that beneﬁt from par- allel storage often have some small relations. Partitioning is not a good idea for such small relations, since each node would end up with just a few tuples. Partitioning is worthwhile only if each node would contain at least a few disk blocks worth of data. Small relations are best left unpartitioned, while medium-sized relations could be par- titioned across some of the nodes, rather than across all the nodes, in a large system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part384.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part386.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
