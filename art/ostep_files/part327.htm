<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>31.5 Reader-Writer Locks</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part326.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part328.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">31.5 Reader-Writer Locks</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Another classic problem stems from the desire for a more flexible lock- ing primitive that admits that different data structure accesses might re- quire different kinds of locking. For example, imagine a number of con- current list operations, including inserts and simple lookups. While in- serts change the state of the list (and thus a traditional critical section makes sense), lookups simply <i>read </i>the data structure; as long as we can guarantee that no insert is on-going, we can allow many lookups to pro- ceed concurrently. The special type of lock we will now develop to sup- port this type of operation is known as a <b>reader-writer lock </b>[CHP71]. The code for such a lock is available in Figure <span style=" color: #00AEEF;">31.9</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_464.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_465.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_466.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_467.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">The code is pretty simple. If some thread wants to update the data structure in question, it should call the new pair of synchronization op- erations: <span class="s41">rwlock acquire writelock()</span>, to acquire a write lock, and <span class="s41">rwlock release writelock()</span>, to release it. Internally, these simply use the <span class="s41">writelock </span>semaphore to ensure that only a single writer can ac-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">typedef struct _rwlock_t {</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2    <span class="s38">sem_t lock;   // binary semaphore (basic lock)</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3   <span class="s38">sem_t writelock; // used to allow ONE writer or MANY readers</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4    <span class="s38">int  readers;  // count of readers reading in critical section</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">} rwlock_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">6</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">7  </span>void rwlock_init(rwlock_t <span class="s39">*</span>rw) {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;">8   <span class="s38">rw-&gt;readers = 0;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">9   <span class="s38">sem_init(&amp;rw-&gt;lock, 0, 1);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10   <span class="s38">sem_init(&amp;rw-&gt;writelock, 0, 1);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">12</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">13  </span>void rwlock_acquire_readlock(rwlock_t <span class="s39">*</span>rw) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">14   <span class="s38">sem_wait(&amp;rw-&gt;lock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15   <span class="s38">rw-&gt;readers++;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16   <span class="s38">if (rw-&gt;readers == 1)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">17    <span class="s38">sem_wait(&amp;rw-&gt;writelock); // first reader acquires writelock</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">18   <span class="s38">sem_post(&amp;rw-&gt;lock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">20</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">21  </span>void rwlock_release_readlock(rwlock_t <span class="s39">*</span>rw) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">22   <span class="s38">sem_wait(&amp;rw-&gt;lock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">23   <span class="s38">rw-&gt;readers--;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">24   <span class="s38">if (rw-&gt;readers == 0)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">25    <span class="s38">sem_post(&amp;rw-&gt;writelock); // last reader releases writelock</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">26   <span class="s38">sem_post(&amp;rw-&gt;lock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">27  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">28</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">29  </span>void rwlock_acquire_writelock(rwlock_t <span class="s39">*</span>rw) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">30   <span class="s38">sem_wait(&amp;rw-&gt;writelock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">31  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">32</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">33  </span>void rwlock_release_writelock(rwlock_t <span class="s39">*</span>rw) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">34   <span class="s38">sem_post(&amp;rw-&gt;writelock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">35  <span class="s38">}</span></p><p style="padding-top: 5pt;padding-left: 100pt;text-indent: 0pt;text-align: left;">Figure 31.9: <b>A Simple Reader-Writer Lock</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">quire the lock and thus enter the critical section to update the data struc- ture in question.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_468.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_469.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_470.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_471.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">More interesting is the pair of routines to acquire and release read locks. When acquiring a read lock, the reader first acquires <span class="s41">lock </span>and then increments the <span class="s41">readers </span>variable to track how many readers are currently inside the data structure. The important step then taken within <span class="s41">rwlock acquire readlock() </span>occurs when the first reader acquires the lock; in that case, the reader also acquires the write lock by calling <span class="s41">sem wait() </span>on the <span class="s41">writelock </span>semaphore, and then finally releasing the <span class="s41">lock </span>by calling <span class="s41">sem post()</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_472.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus, once a reader has acquired a read lock, more readers will be allowed to acquire the read lock too; however, any thread that wishes to acquire the write lock will have to wait until <i>all </i>readers are finished; the last one to exit the critical section calls <span class="s41">sem post() </span>on “writelock” and thus enables a waiting writer to acquire the lock.</p><p style="padding-left: 52pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">This approach works (as desired), but does have some negatives, espe-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: S<span class="s7">IMPLE </span>A<span class="s7">ND </span>D<span class="s7">UMB </span>C<span class="s7">AN </span>B<span class="s7">E </span>B<span class="s7">ETTER </span>(H<span class="s7">ILL</span>’<span class="s7">S </span>L<span class="s7">AW</span>)</p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">You should never underestimate the notion that the simple and dumb approach can be the best one. With locking, sometimes a simple spin lock works best, because it is easy to implement and fast. Although something like reader/writer locks sounds cool, they are complex, and complex can mean slow. Thus, always try the simple and dumb approach first.</p><p style="padding-top: 2pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">This idea, of appealing to simplicity, is found in many places. One early source is Mark Hill’s dissertation [H87], which studied how to design caches for CPUs. Hill found that simple direct-mapped caches worked better than fancy set-associative designs (one reason is that in caching, simpler designs enable faster lookups). As Hill succinctly summarized his work: “Big and dumb is better.” And thus we call this similar advice <b>Hill’s Law</b>.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">cially when it comes to fairness. In particular, it would be relatively easy for readers to starve writers. More sophisticated solutions to this prob- lem exist; perhaps you can think of a better implementation? Hint: think about what you would need to do to prevent more readers from entering the lock once a writer is waiting.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Finally, it should be noted that reader-writer locks should be used with some caution. They often add more overhead (especially with more sophisticated implementations), and thus do not end up speeding up performance as compared to just using simple and fast locking primi- tives [CB08]. Either way, they showcase once again how we can use semaphores in an interesting and useful way.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part326.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part328.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
