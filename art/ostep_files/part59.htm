<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Table 6.3: Limited Direction Execution Protocol (Timer Interrupt)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part58.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part60.htm">下一个 &gt;</a></p><p style="padding-top: 2pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">Table 6.3: <b>Limited Direction Execution Protocol (Timer Interrupt)</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">call to the switch code in the context of one process (the one that was in- terrupted) and returns in the context of another (the soon-to-be-executing one). When the OS then finally executes a return-from-trap instruction, the soon-to-be-executing process becomes the currently-running process. And thus the context switch is complete.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A timeline of the entire process is shown in Table <span style=" color: #00AEEF;">6.3</span>. In this exam- ple, Process A is running and then is interrupted by the timer interrupt. The hardware saves its state (onto its kernel stack) and enters the kernel (switching to kernel mode). In the timer interrupt handler, the OS decides to switch from running Process A to Process B. At that point, it calls the <span class="s41">switch() </span>routine, which carefully saves current register values (into the process structure of A), restores the registers of Process B (from its process structure entry), and then <b>switches contexts</b>, specifically by changing the stack pointer to use B’s kernel stack (and not A’s). Finally, the OS returns- from-trap, which restores B’s register state and starts running it.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Note that there are two types of register saves/restores that happen during this protocol. The first is when the timer interrupt occurs; in this case, the <i>user register state </i>of the running process is implicitly saved by the <i>hardware</i>, using the kernel stack of that process. The second is when the OS decides to switch from A to B; in this case, the <i>kernel register state</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">1  </span># void swtch(struct context <span class="s39">**</span>old, struct context <span class="s39">*</span>new);</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">2  <span class="s38">#</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38"># Save current register context in old</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38"># and then load register context from new.</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5  <span class="s38">.globl swtch</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6  <span class="s38">swtch:</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7   <span class="s38"># Save old registers</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8   <span class="s38">movl 4(%esp), %eax # put old ptr into eax</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9    <span class="s38">popl 0(%eax)   # save the old IP</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">10   <span class="s38">movl %esp, 4(%eax) # and stack</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">11   <span class="s38">movl %ebx, 8(%eax) # and other registers</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">12   <span class="s38">movl %ecx, 12(%eax)</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">13   <span class="s38">movl %edx, 16(%eax)</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">14   <span class="s38">movl %esi, 20(%eax)</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">15   <span class="s38">movl %edi, 24(%eax)</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">16   <span class="s38">movl %ebp, 28(%eax)</span></p><p class="s37" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">17</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">18   <span class="s38"># Load new registers</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">19   <span class="s38">movl 4(%esp), %eax # put new ptr into eax</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">20   <span class="s38">movl 28(%eax), %ebp # restore other registers</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">21   <span class="s38">movl 24(%eax), %edi</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">22   <span class="s38">movl 20(%eax), %esi</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">23   <span class="s38">movl 16(%eax), %edx</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">24   <span class="s38">movl 12(%eax), %ecx</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">25   <span class="s38">movl 8(%eax), %ebx</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">26   <span class="s38">movl 4(%eax), %esp # stack is switched here</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">27    <span class="s38">pushl 0(%eax)   # return addr put in place</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">28    <span class="s38">ret       # finally return into new ctxt</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 130pt;text-indent: 0pt;text-align: left;">Figure 6.1: <b>The xv6 Context Switch Code</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">is explicitly saved by the <i>software </i>(i.e., the OS), but this time into memory in the process structure of the process. The latter action moves the system from running as if it just trapped into the kernel from A to as if it just trapped into the kernel from B.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To give you a better sense of how such a switch is enacted, Figure <span style=" color: #00AEEF;">6.1 </span>shows the context switch code for xv6. See if you can make sense of it (you’ll have to know a bit of x86, as well as some xv6, to do so). The <span class="s41">context </span>structures <span class="s41">old </span>and <span class="s41">new </span>are found the old and new process’s process structures, respectively.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part58.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part60.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
