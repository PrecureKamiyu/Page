<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>No Preemption</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part345.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part347.htm">下一个 &gt;</a></p><p class="s27" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">No Preemption</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Because we generally view locks as held until unlock is called, multiple lock acquisition often gets us into trouble because when waiting for one lock we are holding another. Many thread libraries provide a more flexi- ble set of interfaces to help avoid this situation. Specifically, a <span class="s41">trylock() </span>routine will grab the lock (if it is available) or return -1 indicating that the lock is held right now and that you should try again later if you want to grab that lock.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Such an interface could be used as follows to build a deadlock-free, ordering-robust lock acquisition protocol:</p><p class="s37" style="padding-top: 6pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">top:</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2   <span class="s38">lock(L1);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3   <span class="s38">if (trylock(L2) == -1) {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4    <span class="s38">unlock(L1);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5    <span class="s38">goto top;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6   <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Note that another thread could follow the same protocol but grab the locks in the other order (L2 then L1) and the program would still be dead- lock free. One new problem does arise, however: <b>livelock</b>. It is possible (though perhaps unlikely) that two threads could both be repeatedly at- tempting this sequence and repeatedly failing to acquire both locks. In this case, both systems are running through this code sequence over and over again (and thus it is not a deadlock), but progress is not being made, hence the name livelock. There are solutions to the livelock problem, too: for example, one could add a random delay before looping back and try- ing the entire thing over again, thus decreasing the odds of repeated in- terference among competing threads.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One final point about this solution: it skirts around the hard parts of using a trylock approach. The first problem that would likely exist again arises due to encapsulation: if one of these locks is buried in some routine that is getting called, the jump back to the beginning becomes more com- plex to implement. If the code had acquired some resources (other than</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">L1) along the way, it must make sure to carefully release them as well; for example, if after acquiring L1, the code had allocated some memory, it would have to release that memory upon failure to acquire L2, before jumping back to the top to try the entire sequence again. However, in limited circumstances (e.g., the Java vector method above), this type of approach could work well.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part345.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part347.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
