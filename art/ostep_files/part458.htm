<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>41.6 The Large-File Exception</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part457.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part459.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">41.6 The Large-File Exception</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In FFS, there is one important exception to the general policy of file placement, and it arises for large files. Without a different rule, a large file would entirely fill the block group it is first placed within (and maybe others). Filling a block group in this manner is undesirable, as it prevents subsequent “related” files from being placed within this block group, and thus may hurt file-access locality.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">Thus, for large files, FFS does the following. After some number of blocks are allocated into the first block group (e.g., 12 blocks, or the num- ber of direct pointers available within an inode), FFS places the next “large” chunk of the file (e.g., those pointed to by the first indirect block) in an- other block group (perhaps chosen for its low utilization). Then, the next chunk of the file is placed in yet another different block group, and so on.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let’s look at some pictures to understand this policy better. Without the large-file exception, a single large file would place all of its blocks into one part of the disk. We use a small example of a file with 10 blocks to illustrate the behavior visually.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Here is the depiction of FFS without the large-file exception:</p><p class="s48" style="padding-top: 1pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">G0  G1  G2  G3  G4  G5  G6  G7  G8  G9</p><p style="padding-top: 2pt;padding-left: 118pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s215" style=" background-color: #D3D3D3;">0</span><span class="s47"> </span><span class="s215" style=" background-color: #D3D3D3;">1</span><span class="s47"> </span><span class="s215" style=" background-color: #D3D3D3;">2</span><span class="s47"> </span><span class="s215" style=" background-color: #D3D3D3;">3</span><span class="s47"> </span><span class="s215" style=" background-color: #D3D3D3;">4</span></p><p style="padding-left: 118pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s215" style=" background-color: #D3D3D3;">5</span><span class="s47"> </span><span class="s215" style=" background-color: #D3D3D3;">6</span><span class="s47"> </span><span class="s215" style=" background-color: #D3D3D3;">7</span><span class="s47"> </span><span class="s215" style=" background-color: #D3D3D3;">8</span><span class="s47"> </span><span class="s215" style=" background-color: #D3D3D3;">9</span></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: left;">With the large-file exception, we might see something more like this, with the file spread across the disk in chunks:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="14" height="12" alt="image" src="Image_597.png"/></span></p><p class="s47" style="text-indent: 0pt;text-align: left;">0 1</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="14" height="12" alt="image" src="Image_598.png"/></span></p><p class="s47" style="text-indent: 0pt;text-align: left;">2 3</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="14" height="12" alt="image" src="Image_599.png"/></span></p><p class="s47" style="text-indent: 0pt;text-align: left;">4 5</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="14" height="12" alt="image" src="Image_600.png"/></span></p><p class="s47" style="text-indent: 0pt;text-align: left;">6 7</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="14" height="12" alt="image" src="Image_601.png"/></span></p><p class="s47" style="text-indent: 0pt;text-align: left;">8 9</p><p style="text-indent: 0pt;text-align: left;"/><p class="s48" style="padding-top: 4pt;padding-bottom: 4pt;padding-left: 82pt;text-indent: 0pt;text-align: left;">G0  G1  G2  G3  G4  G5  G6  G7  G8  G9</p><p style="padding-left: 82pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span style=" color: black; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: -1pt;">				</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The astute reader will note that spreading blocks of a file across the disk will hurt performance, particularly in the relatively common case of sequential file access (e.g., when a user or application reads chunks 0 through 9 in order). And you are right! It will. We can help this a little, by choosing our chunk size carefully.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Specifically, if the chunk size is large enough, we will still spend most of our time transferring data from disk and just a relatively little time seeking between chunks of the block. This process of reducing an over- head by doing more work per overhead paid is called <b>amortization </b>and is a common technique in computer systems.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let’s do an example: assume that the average positioning time (i.e., seek and rotation) for a disk is 10 ms. Assume further that the disk trans- fers data at 40 MB/s. If our goal was to spend half our time seeking be- tween chunks and half our time transferring data (and thus achieve 50% of peak disk performance), we would thus need to spend 10 ms transfer- ring data for every 10 ms positioning. So the question becomes: how big does a chunk have to be in order to spend 10 ms in transfer? Easy, just use our old friend, math, in particular the dimensional analysis we spoke of in the chapter on disks:</p><p class="s161" style="text-indent: 0pt;line-height: 10pt;text-align: left;">---</p><p style="text-indent: 0pt;text-align: left;"/><p class="s161" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;line-height: 8pt;text-align: right;">---</p><p class="s216" style="padding-left: 116pt;text-indent: 0pt;line-height: 7pt;text-align: center;">40 <span class="s125">MB</span></p><p class="s43" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: center;"><span class="s163"> </span>s<span class="s161"> </span>ec</p><p class="s44" style="padding-top: 6pt;padding-left: 44pt;text-indent: 0pt;line-height: 8pt;text-align: center;">1024 <span class="s43">KB</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="49" height="1" alt="image" src="Image_602.png"/></span></p><p class="s4" style="text-indent: 0pt;line-height: 9pt;text-align: left;">·</p><p style="text-indent: 0pt;text-align: left;"/><p class="s161" style="text-indent: 0pt;line-height: 10pt;text-align: left;">---</p><p style="text-indent: 0pt;text-align: left;"/><p class="s175" style="padding-left: 27pt;text-indent: 0pt;line-height: 7pt;text-align: left;">--- <span class="s217">·</span></p><p class="s44" style="padding-left: 44pt;text-indent: 0pt;line-height: 7pt;text-align: center;">1 <span class="s43">MB</span></p><p class="s43" style="padding-top: 6pt;padding-left: 1pt;text-indent: 6pt;line-height: 110%;text-align: left;"><span class="s44">1</span><span class="s163"> </span>s<span class="s161"> </span>ec <span class="s44">1000</span><span class="s160"> </span>m<span class="s161"> </span>s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="1" alt="image" src="Image_603.png"/></span></p><p class="s43" style="padding-left: 1pt;text-indent: 0pt;text-align: left;"><span class="s4">· </span><span class="s44">10</span><span class="s160"> </span>m<span class="s161"> </span>s <span class="s44">= 409</span>.<span class="s44">6 </span>KB    <span class="p">(41.1)</span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Basically, what this equation says is this: if you transfer data at 40 MB/s, you need to transfer only 409.6 KB every time you seek in order to spend half your time seeking and half your time transferring. Similarly, you can compute the size of the chunk you would need to achieve 90% of peak bandwidth (turns out it is about 3.69 MB), or even 99% of peak bandwidth (40.6 MB!). As you can see, the closer you want to get to peak, the bigger these chunks get (see Figure <span style=" color: #00AEEF;">41.2 </span>for a plot of these values).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">FFS did not use this type of calculation in order to spread large files across groups, however. Instead, it took a simple approach, based on the structure of the inode itself. The first twelve direct blocks were placed in the same group as the inode; each subsequent indirect block, and all the blocks it pointed to, was placed in a different group. With a block size of 4-KB, and 32-bit disk addresses, this strategy implies that every 1024 blocks of the file (4 MB) were placed in separate groups, the lone exception being the first 48-KB of the file as pointed to by direct pointers.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s80" style="padding-top: 3pt;padding-left: 158pt;text-indent: 0pt;text-align: left;">The Challenges of Amortization</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="183" height="187" alt="image" src="Image_604.png"/></span></p><p class="s77" style="text-indent: 0pt;line-height: 7pt;text-align: left;">90%, 3.69M</p><p style="text-indent: 0pt;text-align: left;"/><p class="s77" style="text-indent: 0pt;line-height: 7pt;text-align: left;">50%, 409.6K</p><p style="text-indent: 0pt;text-align: left;"/><p class="s80" style="padding-left: 1pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Log(Chunk Size Needed)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s80" style="padding-top: 3pt;padding-left: 50pt;text-indent: 0pt;text-align: center;">10M</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s80" style="padding-top: 3pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">1M</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s80" style="padding-left: 51pt;text-indent: 0pt;text-align: center;">32K</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s80" style="padding-left: 54pt;text-indent: 0pt;line-height: 10pt;text-align: center;">1K</p><p class="s80" style="padding-left: 149pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0%  25%  50%  75%  100%</p><p class="s80" style="padding-top: 1pt;padding-left: 164pt;text-indent: 0pt;text-align: left;">Percent Bandwidth (Desired)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 89pt;text-indent: 0pt;text-align: left;">Figure 41.2: <b>Amortization: How Big Do Chunks Have To Be?</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We should note that the trend in disk drives is that transfer rate im- proves fairly rapidly, as disk manufacturers are good at cramming more bits into the same surface, but the mechanical aspects of drives related to seeks (disk arm speed and the rate of rotation) improve rather slowly [P98]. The implication is that over time, mechanical costs become rel- atively more expensive, and thus, to amortize said costs, you have to transfer more data between seeks.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part457.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part459.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
