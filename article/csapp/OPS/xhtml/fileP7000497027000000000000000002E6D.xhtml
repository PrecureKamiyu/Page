<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>3.10 Combining Control and Data in Machine-Level Programs</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000002E6D" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P70004970270000000000000000410B2" data-uri="chapter03.xhtml#P70004970270000000000000000410B2" epub:type="title"><span class="pcalibre label pcalibre1">3.10 </span>Combining Control and Data in Machine-Level Programs</h1></header>
<p id="P70004970270000000000000000410B3" data-uri="chapter03.xhtml#P70004970270000000000000000410B3" class="pcalibre1 pcalibre calibre2">So far, we have looked separately at how machine-level code implements the control aspects of a program and how it implements different data structures. In this section, we look at ways in which data and control interact with each other. We start by taking a deep look into pointers, one of the most important concepts in the C programming language, but one for which many programmers only have a shallow understanding. We review the use of the symbolic debugger <span class="smallcaps pcalibre pcalibre1">gdb</span> for examining the detailed operation of machine-level programs. Next, we see how understanding machine-level programs enables us to study buffer overflow, an important security vulnerability in many real-world systems. Finally, we examine <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002E70" title="277" data-uri="chapter03.xhtml#P7000497027000000000000000002E70" epub:type="pagebreak"></span>how machine-level programs implement cases where the amount of stack storage required by a function can vary from one execution to another.</p>
<section id="P7000497027000000000000000002E71" data-uri="chapter03.xhtml#P7000497027000000000000000002E71" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000410B4" data-uri="chapter03.xhtml#P70004970270000000000000000410B4" epub:type="title"><span class="pcalibre label pcalibre1">3.10.1 </span>Understanding Pointers</h1></header>
<p id="P70004970270000000000000000410B5" data-uri="chapter03.xhtml#P70004970270000000000000000410B5" class="pcalibre1 pcalibre calibre2">Pointers are a central feature of the C programming language. They serve as a uniform way to generate references to elements within different data structures. Pointers are a source of confusion for novice programmers, but the underlying concepts are fairly simple. Here we highlight some key principles of pointers and their mapping into machine code.</p>
<ul id="P70004970270000000000000000410B6" data-uri="chapter03.xhtml#P70004970270000000000000000410B6" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000410B7" data-uri="chapter03.xhtml#P70004970270000000000000000410B7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410B8" data-uri="chapter03.xhtml#P70004970270000000000000000410B8" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Every pointer has an associated type. </span>This type indicates what kind of object the pointer points to. Using the following pointer declarations as illustrations</p>
<pre id="P70004970270000000000000000410B9" data-uri="chapter03.xhtml#P70004970270000000000000000410B9" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000410BA" data-uri="chapter03.xhtml#P70004970270000000000000000410BA" class="calibre10 pcalibre pcalibre1">
int *ip; char **cpp;
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000410BB" data-uri="chapter03.xhtml#P70004970270000000000000000410BB">variable <code id="P70004970270000000000000000410BC" data-uri="chapter03.xhtml#P70004970270000000000000000410BC" class="pcalibre1 calibre8 pcalibre">ip</code> is a pointer to an object of type <code id="P70004970270000000000000000410BD" data-uri="chapter03.xhtml#P70004970270000000000000000410BD" class="pcalibre1 calibre8 pcalibre">int</code>, while <code id="P70004970270000000000000000410BE" data-uri="chapter03.xhtml#P70004970270000000000000000410BE" class="pcalibre1 calibre8 pcalibre">cpp</code> is a pointer to an object that itself is a pointer to an object of type <code id="P70004970270000000000000000410BF" data-uri="chapter03.xhtml#P70004970270000000000000000410BF" class="pcalibre1 calibre8 pcalibre">char</code>. In general, if the object has type <var class="calibre5 pcalibre pcalibre1">T</var>, then the pointer has type *<var class="calibre5 pcalibre pcalibre1">T</var>. The special <code id="P70004970270000000000000000410C0" data-uri="chapter03.xhtml#P70004970270000000000000000410C0" class="pcalibre1 calibre8 pcalibre">void</code> * type represents a generic pointer. For example, the <code id="P70004970270000000000000000410C1" data-uri="chapter03.xhtml#P70004970270000000000000000410C1" class="pcalibre1 calibre8 pcalibre">malloc</code> function returns a generic pointer, which is converted to a typed pointer via either an explicit cast or by the implicit casting of the assignment operation. Pointer types are not part of machine code; they are an abstraction provided by C to help programmers avoid addressing errors.</p></li>
<li id="P70004970270000000000000000410C2" data-uri="chapter03.xhtml#P70004970270000000000000000410C2" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410C3" data-uri="chapter03.xhtml#P70004970270000000000000000410C3" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Every pointer has a value. </span>This value is an address of some object of the designated type. The special <code id="P70004970270000000000000000410C4" data-uri="chapter03.xhtml#P70004970270000000000000000410C4" class="pcalibre1 calibre8 pcalibre">NULL (0)</code> value indicates that the pointer does not point anywhere.</p></li>
<li id="P70004970270000000000000000410C5" data-uri="chapter03.xhtml#P70004970270000000000000000410C5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410C6" data-uri="chapter03.xhtml#P70004970270000000000000000410C6" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Pointers are created with the `&amp;' operator. </span>This operator can be applied to any C expression that is categorized as an <i class="calibre5 pcalibre pcalibre1">lvalue</i>, meaning an expression that can appear on the left side of an assignment. Examples include variables and the elements of structures, unions, and arrays. We have seen that the machine-code realization of the `&amp;' operator often uses the <code id="P70004970270000000000000000410C7" data-uri="chapter03.xhtml#P70004970270000000000000000410C7" class="pcalibre1 calibre8 pcalibre">leaq</code> instruction to compute the expression value, since this instruction is designed to compute the address of a memory reference.</p></li>
<li id="P70004970270000000000000000410C8" data-uri="chapter03.xhtml#P70004970270000000000000000410C8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410C9" data-uri="chapter03.xhtml#P70004970270000000000000000410C9" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Pointers are dereferenced with the `*' operator. </span>The result is a value having the type associated with the pointer. Dereferencing is implemented by a memory reference, either storing to or retrieving from the specified address.</p></li>
<li id="P70004970270000000000000000410CA" data-uri="chapter03.xhtml#P70004970270000000000000000410CA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410CB" data-uri="chapter03.xhtml#P70004970270000000000000000410CB" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Arrays and pointers are closely related. </span>The name of an array canbe referenced (but not updated) as if it were a pointer variable. Array referencing (e.g., <code id="P70004970270000000000000000410CC" data-uri="chapter03.xhtml#P70004970270000000000000000410CC" class="pcalibre1 calibre8 pcalibre">a[3]</code>) has the exact same effect as pointer arithmetic and dereferencing (e.g., <code id="P70004970270000000000000000410CD" data-uri="chapter03.xhtml#P70004970270000000000000000410CD" class="pcalibre1 calibre8 pcalibre">*(a+3)</code>). Both array referencing and pointer arithmetic require scaling the offsets by the object size. When we write an expression <code id="P70004970270000000000000000410CE" data-uri="chapter03.xhtml#P70004970270000000000000000410CE" class="pcalibre1 calibre8 pcalibre">p+i</code> for pointer <code id="P70004970270000000000000000410CF" data-uri="chapter03.xhtml#P70004970270000000000000000410CF" class="pcalibre1 calibre8 pcalibre">p</code> with value <code id="P70004970270000000000000000410D0" data-uri="chapter03.xhtml#P70004970270000000000000000410D0" class="pcalibre1 calibre8 pcalibre"><var class="calibre5 pcalibre pcalibre1">p</var></code>, the resulting address is computed as <i class="calibre5 pcalibre pcalibre1"><code id="P70004970270000000000000000410D1" data-uri="chapter03.xhtml#P70004970270000000000000000410D1" class="pcalibre1 calibre8 pcalibre">p</code></i> + <var class="calibre5 pcalibre pcalibre1">L</var> · <var class="calibre5 pcalibre pcalibre1">i</var>, where <var class="calibre5 pcalibre pcalibre1">L</var> is the size of the data type associated with <code id="P70004970270000000000000000410D2" data-uri="chapter03.xhtml#P70004970270000000000000000410D2" class="pcalibre1 calibre8 pcalibre">p</code>.</p></li>
<li id="P70004970270000000000000000410D3" data-uri="chapter03.xhtml#P70004970270000000000000000410D3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410D4" data-uri="chapter03.xhtml#P70004970270000000000000000410D4" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002E93" title="278" data-uri="chapter03.xhtml#P7000497027000000000000000002E93" epub:type="pagebreak"></span><span class="pcalibre leadin pcalibre1">Casting from one type of pointer to another changes its type but not its value. </span>One effect of casting is to change any scaling of pointer arithmetic. So, for example, if <code id="P70004970270000000000000000410D5" data-uri="chapter03.xhtml#P70004970270000000000000000410D5" class="pcalibre1 calibre8 pcalibre">p</code> is a pointer of type <code id="P70004970270000000000000000410D6" data-uri="chapter03.xhtml#P70004970270000000000000000410D6" class="pcalibre1 calibre8 pcalibre">char</code> * having value <i class="calibre5 pcalibre pcalibre1"><code id="P70004970270000000000000000410D7" data-uri="chapter03.xhtml#P70004970270000000000000000410D7" class="pcalibre1 calibre8 pcalibre">p</code></i>, then the expression (<code id="P70004970270000000000000000410D8" data-uri="chapter03.xhtml#P70004970270000000000000000410D8" class="pcalibre1 calibre8 pcalibre">int *) p+7</code> computes <code id="P70004970270000000000000000410D9" data-uri="chapter03.xhtml#P70004970270000000000000000410D9" class="pcalibre1 calibre8 pcalibre"><var class="calibre5 pcalibre pcalibre1">p</var></code> + 28, while <code id="P70004970270000000000000000410DA" data-uri="chapter03.xhtml#P70004970270000000000000000410DA" class="pcalibre1 calibre8 pcalibre">(int *) (p+7)</code> computes <code id="P70004970270000000000000000410DB" data-uri="chapter03.xhtml#P70004970270000000000000000410DB" class="pcalibre1 calibre8 pcalibre"><var class="calibre5 pcalibre pcalibre1">p</var> + 7</code>. (Recall that casting has higher precedence than addition.)</p></li>
<li id="P70004970270000000000000000410DC" data-uri="chapter03.xhtml#P70004970270000000000000000410DC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410DD" data-uri="chapter03.xhtml#P70004970270000000000000000410DD" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Pointers can also point to functions. </span>This provides a powerful capability for storing and passing references to code, which can be invoked in some other part of the program. For example, if we have a function defined by the prototype</p>
<pre id="P70004970270000000000000000410DE" data-uri="chapter03.xhtml#P70004970270000000000000000410DE" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000410DF" data-uri="chapter03.xhtml#P70004970270000000000000000410DF" class="calibre10 pcalibre pcalibre1">
int fun(int x, int *p);
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000410E0" data-uri="chapter03.xhtml#P70004970270000000000000000410E0">then we can declare and assign a pointer <code id="P70004970270000000000000000410E1" data-uri="chapter03.xhtml#P70004970270000000000000000410E1" class="pcalibre1 calibre8 pcalibre">fp</code> to this function by the following code sequence:</p>
<pre id="P70004970270000000000000000410E2" data-uri="chapter03.xhtml#P70004970270000000000000000410E2" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000410E3" data-uri="chapter03.xhtml#P70004970270000000000000000410E3" class="calibre10 pcalibre pcalibre1">int (*fp)(int, int *); fp = fun;
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000410E4" data-uri="chapter03.xhtml#P70004970270000000000000000410E4">We can then invoke the function using this pointer:</p>
<pre id="P70004970270000000000000000410E5" data-uri="chapter03.xhtml#P70004970270000000000000000410E5" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000410E6" data-uri="chapter03.xhtml#P70004970270000000000000000410E6" class="calibre10 pcalibre pcalibre1">
int y = 1;
int result = fp(3, &amp;y);
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000410E7" data-uri="chapter03.xhtml#P70004970270000000000000000410E7">The value of a function pointer is the address of the first instruction in the machine-code representation of the function.</p></li>
</ul>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000002EA7" data-uri="chapter03.xhtml#P7000497027000000000000000002EA7"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P70004970270000000000000000410E8" data-uri="chapter03.xhtml#P70004970270000000000000000410E8" epub:type="title"><span class="pcalibre label1 pcalibre1">New to C? </span>Function pointers</h1></header>
<p id="P70004970270000000000000000410E9" data-uri="chapter03.xhtml#P70004970270000000000000000410E9" class="calibre13 pcalibre pcalibre1">The syntax for declaring function pointers is especially difficult for novice programmers to understand. For a declaration such as</p>
<pre id="P70004970270000000000000000410EA" data-uri="chapter03.xhtml#P70004970270000000000000000410EA" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000410EB" data-uri="chapter03.xhtml#P70004970270000000000000000410EB" class="calibre10 pcalibre pcalibre1">
int (*f)(int*);
</code></pre>
<p class="calibre13 pcalibre pcalibre1" id="P70004970270000000000000000410EC" data-uri="chapter03.xhtml#P70004970270000000000000000410EC">it helps to read it starting from the inside (starting with `<code id="P70004970270000000000000000410ED" data-uri="chapter03.xhtml#P70004970270000000000000000410ED" class="pcalibre1 calibre8 pcalibre">f</code>') and working outward. Thus, we see that <code id="P70004970270000000000000000410EE" data-uri="chapter03.xhtml#P70004970270000000000000000410EE" class="pcalibre1 calibre8 pcalibre">f</code> is a pointer, as indicated by (<code id="P70004970270000000000000000410EF" data-uri="chapter03.xhtml#P70004970270000000000000000410EF" class="pcalibre1 calibre8 pcalibre">*f</code>). It is a pointer to a function that has a single <code id="P70004970270000000000000000410F0" data-uri="chapter03.xhtml#P70004970270000000000000000410F0" class="pcalibre1 calibre8 pcalibre">int</code> * as an argument, as indicated by <code id="P70004970270000000000000000410F1" data-uri="chapter03.xhtml#P70004970270000000000000000410F1" class="pcalibre1 calibre8 pcalibre">(*f)(int*)</code>. Finally, we see that it is a pointer to a function that takes an <code id="P70004970270000000000000000410F2" data-uri="chapter03.xhtml#P70004970270000000000000000410F2" class="pcalibre1 calibre8 pcalibre">int</code> * as an argument and returns <code id="P70004970270000000000000000410F3" data-uri="chapter03.xhtml#P70004970270000000000000000410F3" class="pcalibre1 calibre8 pcalibre">int</code>.</p>
<p id="P70004970270000000000000000410F4" data-uri="chapter03.xhtml#P70004970270000000000000000410F4" class="calibre13 pcalibre pcalibre1">The parentheses around *<code id="P70004970270000000000000000410F5" data-uri="chapter03.xhtml#P70004970270000000000000000410F5" class="pcalibre1 calibre8 pcalibre">f</code> are required, because otherwise the declaration</p>
<pre id="P70004970270000000000000000410F6" data-uri="chapter03.xhtml#P70004970270000000000000000410F6" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000410F7" data-uri="chapter03.xhtml#P70004970270000000000000000410F7" class="calibre10 pcalibre pcalibre1">
int *f(int*);
</code></pre>
<p class="calibre13 pcalibre pcalibre1" id="P70004970270000000000000000410F8" data-uri="chapter03.xhtml#P70004970270000000000000000410F8">would be read as</p>
<pre id="P70004970270000000000000000410F9" data-uri="chapter03.xhtml#P70004970270000000000000000410F9" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000410FA" data-uri="chapter03.xhtml#P70004970270000000000000000410FA" class="calibre10 pcalibre pcalibre1">
(int *) f(int*);
</code></pre>
<p class="calibre13 pcalibre pcalibre1" id="P70004970270000000000000000410FB" data-uri="chapter03.xhtml#P70004970270000000000000000410FB">That is, it would be interpreted as a function prototype, declaring a function <code id="P70004970270000000000000000410FC" data-uri="chapter03.xhtml#P70004970270000000000000000410FC" class="pcalibre1 calibre8 pcalibre">f</code> that has an <code id="P70004970270000000000000000410FD" data-uri="chapter03.xhtml#P70004970270000000000000000410FD" class="pcalibre1 calibre8 pcalibre">int</code> * as its argument and returns an <code id="P70004970270000000000000000410FE" data-uri="chapter03.xhtml#P70004970270000000000000000410FE" class="pcalibre1 calibre8 pcalibre">int</code> *.</p>
<p id="P70004970270000000000000000410FF" data-uri="chapter03.xhtml#P70004970270000000000000000410FF" class="pcalibre calibre3 pcalibre1">Kernighan and Ritchie <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41C">[61,</a> Sect. 5.12] present a helpful tutorial on reading C declarations.</p>
</aside>
</section>
<section id="P7000497027000000000000000002EC0" data-uri="chapter03.xhtml#P7000497027000000000000000002EC0" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000041100" data-uri="chapter03.xhtml#P7000497027000000000000000041100" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002EC2" title="279" data-uri="chapter03.xhtml#P7000497027000000000000000002EC2" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">3.10.2 </span>Life in the Real World: Using the <span class="smallcaps pcalibre pcalibre1">gdb </span>Debugger</h1></header>
<p id="P7000497027000000000000000041101" data-uri="chapter03.xhtml#P7000497027000000000000000041101" class="pcalibre1 pcalibre calibre2">The GNU debugger <span class="smallcaps pcalibre pcalibre1">gdb </span>provides a number of useful features to support the run-time evaluation and analysis of machine-level programs. With the examples and exercises in this book, we attempt to infer the behavior of a program by just looking at the code. Using <span class="smallcaps pcalibre pcalibre1">gdb</span>, it becomes possible to study the behavior by watching the program in action while having considerable control over its execution.</p>
<p id="P7000497027000000000000000041102" data-uri="chapter03.xhtml#P7000497027000000000000000041102" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000002ED2"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.39</span></a> shows examples of some <span class="smallcaps pcalibre pcalibre1">gdb </span>commands that help when working with machine-level x86-64 programs. It is very helpful to first run <span class="smallcaps pcalibre pcalibre1">objdump </span>to get a disassembled version of the program. Our examples are based on running <span class="smallcaps pcalibre pcalibre1">gdb </span>on the file <code id="P7000497027000000000000000041103" data-uri="chapter03.xhtml#P7000497027000000000000000041103" class="pcalibre1 calibre8 pcalibre">prog</code>, described and disassembled on page 175. We start <span class="smallcaps pcalibre pcalibre1">gdb </span>with the following command line:</p>
<pre id="P7000497027000000000000000041104" data-uri="chapter03.xhtml#P7000497027000000000000000041104" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041105" data-uri="chapter03.xhtml#P7000497027000000000000000041105" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">gdb prog</i>
</code></pre>
<p id="P7000497027000000000000000041106" data-uri="chapter03.xhtml#P7000497027000000000000000041106" class="pcalibre1 pcalibre calibre2">The general scheme is to set breakpoints near points of interest in the program. These can be set to just after the entry of a function or at a program address. When one of the breakpoints is hit during program execution, the program will halt and return control to the user. From a breakpoint, we can examine different registers and memory locations in various formats. We can also single-step the program, running just a few instructions at a time, or we can proceed to the next breakpoint.</p>
<p id="P7000497027000000000000000041107" data-uri="chapter03.xhtml#P7000497027000000000000000041107" class="pcalibre1 pcalibre calibre2">As our examples suggest, <span class="smallcaps pcalibre pcalibre1">gdb </span>has an obscure command syntax, but the online help information (invoked within <span class="smallcaps pcalibre pcalibre1">gdb </span>with the <code id="P7000497027000000000000000041108" data-uri="chapter03.xhtml#P7000497027000000000000000041108" class="pcalibre1 calibre8 pcalibre">help</code> command) overcomes this shortcoming. Rather than using the command-line interface to <span class="smallcaps pcalibre pcalibre1">gdb</span>, many programmers prefer using <span class="smallcaps pcalibre pcalibre1">ddd</span>, an extension to <span class="smallcaps pcalibre pcalibre1">gdb </span>that provides a graphical user interface.</p>
</section>
<section id="P7000497027000000000000000002ECB" data-uri="chapter03.xhtml#P7000497027000000000000000002ECB" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000041109" data-uri="chapter03.xhtml#P7000497027000000000000000041109" epub:type="title"><span class="pcalibre label pcalibre1">3.10.3 </span>Out-of-Bounds Memory References and Buffer Overflow</h1></header>
<p id="P700049702700000000000000004110A" data-uri="chapter03.xhtml#P700049702700000000000000004110A" class="pcalibre1 pcalibre calibre2">We have seen that C does not perform any bounds checking for array references, and that local variables are stored on the stack along with state information such as saved register values and return addresses. This combination can lead to serious program errors, where the state stored on the stack gets corrupted by a write to an out-of-bounds array element. When the program then tries to reload the register or execute a <code id="P700049702700000000000000004110B" data-uri="chapter03.xhtml#P700049702700000000000000004110B" class="pcalibre1 calibre8 pcalibre">ret</code> instruction with this corrupted state, things can go seriously wrong.</p>
<p id="P700049702700000000000000004110C" data-uri="chapter03.xhtml#P700049702700000000000000004110C" class="pcalibre1 pcalibre calibre2">A particularly common source of state corruption is known as <i class="calibre5 pcalibre pcalibre1">buffer overflow</i>. Typically, some character array is allocated on the stack to hold a string, but the size of the string exceeds the space allocated for the array. This is demonstrated by the following program example:</p>
<pre id="P700049702700000000000000004110D" data-uri="chapter03.xhtml#P700049702700000000000000004110D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004110E" data-uri="chapter03.xhtml#P700049702700000000000000004110E" class="calibre10 pcalibre pcalibre1">
/* Implementation of library function gets() */
char *gets(char *s)
{
	int c;
	char *dest = s;
</code></pre>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002ED2" data-uri="chapter03.xhtml#P7000497027000000000000000002ED2">
<table class="pcalibre largetable pcalibre1" id="P700049702700000000000000004110F" data-uri="chapter03.xhtml#P700049702700000000000000004110F">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000041110" data-uri="chapter03.xhtml#P7000497027000000000000000041110" class="calibre18 pcalibre pcalibre1"><span class="pcalibre pagebreak1 pcalibre1" id="P7000497027000000000000000002ED5" title="280" data-uri="chapter03.xhtml#P7000497027000000000000000002ED5" epub:type="pagebreak"></span>Command</th>
<th id="P7000497027000000000000000041111" data-uri="chapter03.xhtml#P7000497027000000000000000041111" class="calibre18 pcalibre pcalibre1">Effect</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="2" id="P7000497027000000000000000041112" data-uri="chapter03.xhtml#P7000497027000000000000000041112" class="calibre20 pcalibre pcalibre1">Starting and stopping</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041113" data-uri="chapter03.xhtml#P7000497027000000000000000041113" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041114" data-uri="chapter03.xhtml#P7000497027000000000000000041114" class="calibre10 pcalibre pcalibre1">quit</code></td>
<td id="P7000497027000000000000000041115" data-uri="chapter03.xhtml#P7000497027000000000000000041115" class="calibre20 pcalibre pcalibre1">Exit <span class="smallcaps1 pcalibre pcalibre1">gdb</span></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041116" data-uri="chapter03.xhtml#P7000497027000000000000000041116" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041117" data-uri="chapter03.xhtml#P7000497027000000000000000041117" class="calibre10 pcalibre pcalibre1">run</code></td>
<td id="P7000497027000000000000000041118" data-uri="chapter03.xhtml#P7000497027000000000000000041118" class="calibre20 pcalibre pcalibre1">Run your program (give command-line arguments here)</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041119" data-uri="chapter03.xhtml#P7000497027000000000000000041119" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004111A" data-uri="chapter03.xhtml#P700049702700000000000000004111A" class="calibre10 pcalibre pcalibre1">kill</code></td>
<td id="P700049702700000000000000004111B" data-uri="chapter03.xhtml#P700049702700000000000000004111B" class="calibre20 pcalibre pcalibre1">Stop your program</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="2" id="P700049702700000000000000004111C" data-uri="chapter03.xhtml#P700049702700000000000000004111C" class="calibre20 pcalibre pcalibre1">Breakpoints</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004111D" data-uri="chapter03.xhtml#P700049702700000000000000004111D" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004111E" data-uri="chapter03.xhtml#P700049702700000000000000004111E" class="calibre10 pcalibre pcalibre1">break multstore</code></td>
<td id="P700049702700000000000000004111F" data-uri="chapter03.xhtml#P700049702700000000000000004111F" class="calibre20 pcalibre pcalibre1">Set breakpoint at entry to function multstore</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041120" data-uri="chapter03.xhtml#P7000497027000000000000000041120" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041121" data-uri="chapter03.xhtml#P7000497027000000000000000041121" class="calibre10 pcalibre pcalibre1">break *0x400540</code></td>
<td id="P7000497027000000000000000041122" data-uri="chapter03.xhtml#P7000497027000000000000000041122" class="calibre20 pcalibre pcalibre1">Set breakpoint at address <code id="P7000497027000000000000000041123" data-uri="chapter03.xhtml#P7000497027000000000000000041123" class="calibre10 pcalibre pcalibre1">0x400540</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041124" data-uri="chapter03.xhtml#P7000497027000000000000000041124" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041125" data-uri="chapter03.xhtml#P7000497027000000000000000041125" class="calibre10 pcalibre pcalibre1">delete 1</code></td>
<td id="P7000497027000000000000000041126" data-uri="chapter03.xhtml#P7000497027000000000000000041126" class="calibre20 pcalibre pcalibre1">Delete breakpoint 1</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041127" data-uri="chapter03.xhtml#P7000497027000000000000000041127" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041128" data-uri="chapter03.xhtml#P7000497027000000000000000041128" class="calibre10 pcalibre pcalibre1">delete</code></td>
<td id="P7000497027000000000000000041129" data-uri="chapter03.xhtml#P7000497027000000000000000041129" class="calibre20 pcalibre pcalibre1">Delete all breakpoints</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="2" id="P700049702700000000000000004112A" data-uri="chapter03.xhtml#P700049702700000000000000004112A" class="calibre20 pcalibre pcalibre1">Execution</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004112B" data-uri="chapter03.xhtml#P700049702700000000000000004112B" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004112C" data-uri="chapter03.xhtml#P700049702700000000000000004112C" class="calibre10 pcalibre pcalibre1">stepi</code></td>
<td id="P700049702700000000000000004112D" data-uri="chapter03.xhtml#P700049702700000000000000004112D" class="calibre20 pcalibre pcalibre1">Execute one instruction</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004112E" data-uri="chapter03.xhtml#P700049702700000000000000004112E" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004112F" data-uri="chapter03.xhtml#P700049702700000000000000004112F" class="calibre10 pcalibre pcalibre1">stepi 4</code></td>
<td id="P7000497027000000000000000041130" data-uri="chapter03.xhtml#P7000497027000000000000000041130" class="calibre20 pcalibre pcalibre1">Execute four instructions</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041131" data-uri="chapter03.xhtml#P7000497027000000000000000041131" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041132" data-uri="chapter03.xhtml#P7000497027000000000000000041132" class="calibre10 pcalibre pcalibre1">nexti</code></td>
<td id="P7000497027000000000000000041133" data-uri="chapter03.xhtml#P7000497027000000000000000041133" class="calibre20 pcalibre pcalibre1">Like <code id="P7000497027000000000000000041134" data-uri="chapter03.xhtml#P7000497027000000000000000041134" class="calibre10 pcalibre pcalibre1">stepi</code>, but proceed through function calls</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041135" data-uri="chapter03.xhtml#P7000497027000000000000000041135" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041136" data-uri="chapter03.xhtml#P7000497027000000000000000041136" class="calibre10 pcalibre pcalibre1">continue</code></td>
<td id="P7000497027000000000000000041137" data-uri="chapter03.xhtml#P7000497027000000000000000041137" class="calibre20 pcalibre pcalibre1">Resume execution</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041138" data-uri="chapter03.xhtml#P7000497027000000000000000041138" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041139" data-uri="chapter03.xhtml#P7000497027000000000000000041139" class="calibre10 pcalibre pcalibre1">finish</code></td>
<td id="P700049702700000000000000004113A" data-uri="chapter03.xhtml#P700049702700000000000000004113A" class="calibre20 pcalibre pcalibre1">Run until current function returns</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="2" id="P700049702700000000000000004113B" data-uri="chapter03.xhtml#P700049702700000000000000004113B" class="calibre20 pcalibre pcalibre1">Examining code</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004113C" data-uri="chapter03.xhtml#P700049702700000000000000004113C" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004113D" data-uri="chapter03.xhtml#P700049702700000000000000004113D" class="calibre10 pcalibre pcalibre1">disas</code></td>
<td id="P700049702700000000000000004113E" data-uri="chapter03.xhtml#P700049702700000000000000004113E" class="calibre20 pcalibre pcalibre1">Disassemble current function</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004113F" data-uri="chapter03.xhtml#P700049702700000000000000004113F" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041140" data-uri="chapter03.xhtml#P7000497027000000000000000041140" class="calibre10 pcalibre pcalibre1">disas multstore</code></td>
<td id="P7000497027000000000000000041141" data-uri="chapter03.xhtml#P7000497027000000000000000041141" class="calibre20 pcalibre pcalibre1">Disassemble function <code id="P7000497027000000000000000041142" data-uri="chapter03.xhtml#P7000497027000000000000000041142" class="calibre10 pcalibre pcalibre1">multstore</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041143" data-uri="chapter03.xhtml#P7000497027000000000000000041143" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041144" data-uri="chapter03.xhtml#P7000497027000000000000000041144" class="calibre10 pcalibre pcalibre1">disas 0x400544</code></td>
<td id="P7000497027000000000000000041145" data-uri="chapter03.xhtml#P7000497027000000000000000041145" class="calibre20 pcalibre pcalibre1">Disassemble function around address <code id="P7000497027000000000000000041146" data-uri="chapter03.xhtml#P7000497027000000000000000041146" class="calibre10 pcalibre pcalibre1">0x400544</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041147" data-uri="chapter03.xhtml#P7000497027000000000000000041147" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041148" data-uri="chapter03.xhtml#P7000497027000000000000000041148" class="calibre10 pcalibre pcalibre1">disas 0x400540, 0x40054d</code></td>
<td id="P7000497027000000000000000041149" data-uri="chapter03.xhtml#P7000497027000000000000000041149" class="calibre20 pcalibre pcalibre1">Disassemble code within specified address range</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004114A" data-uri="chapter03.xhtml#P700049702700000000000000004114A" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004114B" data-uri="chapter03.xhtml#P700049702700000000000000004114B" class="calibre10 pcalibre pcalibre1">print /x $rip</code></td>
<td id="P700049702700000000000000004114C" data-uri="chapter03.xhtml#P700049702700000000000000004114C" class="calibre20 pcalibre pcalibre1">Print program counter in hex</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="2" id="P700049702700000000000000004114D" data-uri="chapter03.xhtml#P700049702700000000000000004114D" class="calibre20 pcalibre pcalibre1">Examining data</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004114E" data-uri="chapter03.xhtml#P700049702700000000000000004114E" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004114F" data-uri="chapter03.xhtml#P700049702700000000000000004114F" class="calibre10 pcalibre pcalibre1">print $rax</code></td>
<td id="P7000497027000000000000000041150" data-uri="chapter03.xhtml#P7000497027000000000000000041150" class="calibre20 pcalibre pcalibre1">Print contents of <code id="P7000497027000000000000000041151" data-uri="chapter03.xhtml#P7000497027000000000000000041151" class="calibre10 pcalibre pcalibre1">%rax</code> in decimal</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041152" data-uri="chapter03.xhtml#P7000497027000000000000000041152" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041153" data-uri="chapter03.xhtml#P7000497027000000000000000041153" class="calibre10 pcalibre pcalibre1">print /x $rax</code></td>
<td id="P7000497027000000000000000041154" data-uri="chapter03.xhtml#P7000497027000000000000000041154" class="calibre20 pcalibre pcalibre1">Print contents of <code id="P7000497027000000000000000041155" data-uri="chapter03.xhtml#P7000497027000000000000000041155" class="calibre10 pcalibre pcalibre1">%rax</code> in hex</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041156" data-uri="chapter03.xhtml#P7000497027000000000000000041156" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041157" data-uri="chapter03.xhtml#P7000497027000000000000000041157" class="calibre10 pcalibre pcalibre1">print /t $rax</code></td>
<td id="P7000497027000000000000000041158" data-uri="chapter03.xhtml#P7000497027000000000000000041158" class="calibre20 pcalibre pcalibre1">Print contents of <code id="P7000497027000000000000000041159" data-uri="chapter03.xhtml#P7000497027000000000000000041159" class="calibre10 pcalibre pcalibre1">%rax</code> in binary</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004115A" data-uri="chapter03.xhtml#P700049702700000000000000004115A" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004115B" data-uri="chapter03.xhtml#P700049702700000000000000004115B" class="calibre10 pcalibre pcalibre1">print 0x100</code></td>
<td id="P700049702700000000000000004115C" data-uri="chapter03.xhtml#P700049702700000000000000004115C" class="calibre20 pcalibre pcalibre1">Print decimal representation of <code id="P700049702700000000000000004115D" data-uri="chapter03.xhtml#P700049702700000000000000004115D" class="calibre10 pcalibre pcalibre1">0x100</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004115E" data-uri="chapter03.xhtml#P700049702700000000000000004115E" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004115F" data-uri="chapter03.xhtml#P700049702700000000000000004115F" class="calibre10 pcalibre pcalibre1">print /x 555</code></td>
<td id="P7000497027000000000000000041160" data-uri="chapter03.xhtml#P7000497027000000000000000041160" class="calibre20 pcalibre pcalibre1">Print hex representation of 555</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041161" data-uri="chapter03.xhtml#P7000497027000000000000000041161" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041162" data-uri="chapter03.xhtml#P7000497027000000000000000041162" class="calibre10 pcalibre pcalibre1">print /x ($rsp+8)</code></td>
<td id="P7000497027000000000000000041163" data-uri="chapter03.xhtml#P7000497027000000000000000041163" class="calibre20 pcalibre pcalibre1">Print contents of <code id="P7000497027000000000000000041164" data-uri="chapter03.xhtml#P7000497027000000000000000041164" class="calibre10 pcalibre pcalibre1">%rsp</code> plus 8 in hex</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041165" data-uri="chapter03.xhtml#P7000497027000000000000000041165" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041166" data-uri="chapter03.xhtml#P7000497027000000000000000041166" class="calibre10 pcalibre pcalibre1">print *(long *) 0x7fffffffe818</code></td>
<td id="P7000497027000000000000000041167" data-uri="chapter03.xhtml#P7000497027000000000000000041167" class="calibre20 pcalibre pcalibre1">Print long integer at address <code id="P7000497027000000000000000041168" data-uri="chapter03.xhtml#P7000497027000000000000000041168" class="calibre10 pcalibre pcalibre1">0x7fffffffe818</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041169" data-uri="chapter03.xhtml#P7000497027000000000000000041169" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004116A" data-uri="chapter03.xhtml#P700049702700000000000000004116A" class="calibre10 pcalibre pcalibre1">print *(long *) ($rsp+8)</code></td>
<td id="P700049702700000000000000004116B" data-uri="chapter03.xhtml#P700049702700000000000000004116B" class="calibre20 pcalibre pcalibre1">Print long integer at address <code id="P700049702700000000000000004116C" data-uri="chapter03.xhtml#P700049702700000000000000004116C" class="calibre10 pcalibre pcalibre1">%rsp</code> + 8</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004116D" data-uri="chapter03.xhtml#P700049702700000000000000004116D" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004116E" data-uri="chapter03.xhtml#P700049702700000000000000004116E" class="calibre10 pcalibre pcalibre1">x/2g 0x7fffffffe818</code></td>
<td id="P700049702700000000000000004116F" data-uri="chapter03.xhtml#P700049702700000000000000004116F" class="calibre20 pcalibre pcalibre1">Examine two (8-byte) words starting at address <code id="P7000497027000000000000000041170" data-uri="chapter03.xhtml#P7000497027000000000000000041170" class="calibre10 pcalibre pcalibre1">0x7fffffffe818</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041171" data-uri="chapter03.xhtml#P7000497027000000000000000041171" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041172" data-uri="chapter03.xhtml#P7000497027000000000000000041172" class="calibre10 pcalibre pcalibre1">x/20b multstore</code></td>
<td id="P7000497027000000000000000041173" data-uri="chapter03.xhtml#P7000497027000000000000000041173" class="calibre20 pcalibre pcalibre1">Examine first 20 bytes of function <code id="P7000497027000000000000000041174" data-uri="chapter03.xhtml#P7000497027000000000000000041174" class="calibre10 pcalibre pcalibre1">multstore</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="2" id="P7000497027000000000000000041175" data-uri="chapter03.xhtml#P7000497027000000000000000041175" class="calibre20 pcalibre pcalibre1">Useful information</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041176" data-uri="chapter03.xhtml#P7000497027000000000000000041176" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041177" data-uri="chapter03.xhtml#P7000497027000000000000000041177" class="calibre10 pcalibre pcalibre1">info frame</code></td>
<td id="P7000497027000000000000000041178" data-uri="chapter03.xhtml#P7000497027000000000000000041178" class="calibre20 pcalibre pcalibre1">Information about current stack frame</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041179" data-uri="chapter03.xhtml#P7000497027000000000000000041179" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004117A" data-uri="chapter03.xhtml#P700049702700000000000000004117A" class="calibre10 pcalibre pcalibre1">info registers</code></td>
<td id="P700049702700000000000000004117B" data-uri="chapter03.xhtml#P700049702700000000000000004117B" class="calibre20 pcalibre pcalibre1">Values of all the registers</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004117C" data-uri="chapter03.xhtml#P700049702700000000000000004117C" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004117D" data-uri="chapter03.xhtml#P700049702700000000000000004117D" class="calibre10 pcalibre pcalibre1">help</code></td>
<td id="P700049702700000000000000004117E" data-uri="chapter03.xhtml#P700049702700000000000000004117E" class="calibre20 pcalibre pcalibre1">Get information about <span class="smallcaps1 pcalibre pcalibre1">gdb</span></td>
</tr>
</tbody>
</table>
<figcaption id="P700049702700000000000000004117F" data-uri="chapter03.xhtml#P700049702700000000000000004117F" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041180" data-uri="chapter03.xhtml#P7000497027000000000000000041180" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">3.39 </span>Example <span class="smallcaps1 pcalibre pcalibre1">gdb </span>commands.</h1></header><div class="caption pcalibre pcalibre1" id="P7000497027000000000000000041181" data-uri="chapter03.xhtml#P7000497027000000000000000041181"><p id="P7000497027000000000000000041182" data-uri="chapter03.xhtml#P7000497027000000000000000041182" class="pcalibre calibre3 pcalibre1">These examples illustrate some of the ways <span class="smallcaps1 pcalibre pcalibre1">gdb </span>supports debugging of machine-level programs.</p></div></figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002F48" data-uri="chapter03.xhtml#P7000497027000000000000000002F48">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002F49" title="281" data-uri="chapter03.xhtml#P7000497027000000000000000002F49" epub:type="pagebreak"></span>
<img alt="A diagram illustrates a stack organization for echo function." id="P7000497027000000000000000041183" data-uri="P700049702700000000000000000B6C1" src="../images/p281-1.png" class="pcalibre1 pcalibre calibre96"/>
<figcaption id="P7000497027000000000000000041184" data-uri="chapter03.xhtml#P7000497027000000000000000041184" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041185" data-uri="chapter03.xhtml#P7000497027000000000000000041185" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">3.40 </span>Stack organization for <code id="P7000497027000000000000000041186" data-uri="chapter03.xhtml#P7000497027000000000000000041186" class="pcalibre1 calibre8 pcalibre">echo</code> function.</h1></header><div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041187" data-uri="chapter03.xhtml#P7000497027000000000000000041187"><p id="P7000497027000000000000000041188" data-uri="chapter03.xhtml#P7000497027000000000000000041188" class="pcalibre calibre3 pcalibre1">Character array <code id="P7000497027000000000000000041189" data-uri="chapter03.xhtml#P7000497027000000000000000041189" class="pcalibre1 calibre8 pcalibre">buf</code> is just part of the saved state. An out-of-bounds write to <code id="P700049702700000000000000004118A" data-uri="chapter03.xhtml#P700049702700000000000000004118A" class="pcalibre1 calibre8 pcalibre">buf</code> can corrupt the program state.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000021461" data-uri="chapter03.xhtml#P7000497027000000000000000021461">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P700049702700000000000000004118B" data-uri="chapter03.xhtml#P700049702700000000000000004118B" class="pcalibre1 pcalibre calibre2">A diagram has two parts, from bottom to top:</p>
<p id="P700049702700000000000000004118C" data-uri="chapter03.xhtml#P700049702700000000000000004118C" class="pcalibre1 pcalibre calibre2">Stack frame for echo with buf = %rsp at the bottom containing [7][6][5][4][3][2][1][0]</p>
<p id="P700049702700000000000000004118D" data-uri="chapter03.xhtml#P700049702700000000000000004118D" class="pcalibre calibre3 pcalibre1">Stack frame for caller with %rsp+24 on bottom containing Return address</p>
</details>
</figcaption></figure>
<pre id="P700049702700000000000000004118E" data-uri="chapter03.xhtml#P700049702700000000000000004118E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004118F" data-uri="chapter03.xhtml#P700049702700000000000000004118F" class="calibre10 pcalibre pcalibre1">
while ((c = getchar()) != `n' &amp;&amp; c != EOF)
	*dest++ = c;
if (c == EOF &amp;&amp; dest == s)
	/* No characters read */
	return NULL;
*dest++ = `0'; /* Terminate string */
return s;
}
/* Read input line and write it back */
void echo()
{
	char buf[8]; /* Way too small! */
	gets(buf);
	puts(buf);
}
</code></pre>
<p id="P7000497027000000000000000041190" data-uri="chapter03.xhtml#P7000497027000000000000000041190" class="pcalibre1 pcalibre calibre2">The preceding code shows an implementation of the library function gets to demonstrate a serious problem with this function. It reads a line from the standard input, stopping when either a terminating newline character or some error condition is encountered. It copies this string to the location designated by argument <code id="P7000497027000000000000000041191" data-uri="chapter03.xhtml#P7000497027000000000000000041191" class="pcalibre1 calibre8 pcalibre">s</code> and terminates the string with a null character. We show the use of gets in the function <code id="P7000497027000000000000000041192" data-uri="chapter03.xhtml#P7000497027000000000000000041192" class="pcalibre1 calibre8 pcalibre">echo</code>, which simply reads a line from standard input and echos it back to standard output.</p>
<p id="P7000497027000000000000000041193" data-uri="chapter03.xhtml#P7000497027000000000000000041193" class="pcalibre1 pcalibre calibre2">The problem with gets is that it has no way to determine whether sufficient space has been allocated to hold the entire string. In our <code id="P7000497027000000000000000041194" data-uri="chapter03.xhtml#P7000497027000000000000000041194" class="pcalibre1 calibre8 pcalibre">echo</code> example, we have purposely made the buffer very small—just eight characters long. Any string longer than seven characters will cause an out-of-bounds write.</p>
<p id="P7000497027000000000000000041195" data-uri="chapter03.xhtml#P7000497027000000000000000041195" class="pcalibre1 pcalibre calibre2">By examining the assembly code generated by <span class="smallcaps pcalibre pcalibre1">gcc </span>for <code id="P7000497027000000000000000041196" data-uri="chapter03.xhtml#P7000497027000000000000000041196" class="pcalibre1 calibre8 pcalibre">echo</code>, we can infer how the stack is organized:</p>
<pre id="P7000497027000000000000000041197" data-uri="chapter03.xhtml#P7000497027000000000000000041197" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041198" data-uri="chapter03.xhtml#P7000497027000000000000000041198" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">void echo()</i>
1	echo:
2	subq	$24, %rsp	<i class="calibre5 pcalibre pcalibre1">Allocate 24 bytes on stack</i>
3	movq	%rsp, %rdi	<i class="calibre5 pcalibre pcalibre1">Compute buf as %rsp</i>
4	call	gets		<i class="calibre5 pcalibre pcalibre1">Call gets</i>
5	movq	%rsp, %rdi	<i class="calibre5 pcalibre pcalibre1">Compute buf as %rsp</i>
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002F5D" title="282" data-uri="chapter03.xhtml#P7000497027000000000000000002F5D" epub:type="pagebreak"></span>6	call	puts		<i class="calibre5 pcalibre pcalibre1">Call puts</i>
7	addq	$24, %rsp	<i class="calibre5 pcalibre pcalibre1">Deallocate stack space</i>
8	ret			<i class="calibre5 pcalibre pcalibre1">Return</i>
</code></pre>
<p id="P7000497027000000000000000041199" data-uri="chapter03.xhtml#P7000497027000000000000000041199" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000002F48"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.40</span></a> illustrates the stack organization during the execution of <code id="P700049702700000000000000004119A" data-uri="chapter03.xhtml#P700049702700000000000000004119A" class="pcalibre1 calibre8 pcalibre">echo</code>. The program allocates 24 bytes on the stack by subtracting 24 from the stack pointer (line 2). Character <code id="P700049702700000000000000004119B" data-uri="chapter03.xhtml#P700049702700000000000000004119B" class="pcalibre1 calibre8 pcalibre">buf</code> is positioned at the top of the stack, as can be seen by the fact that <code id="P700049702700000000000000004119C" data-uri="chapter03.xhtml#P700049702700000000000000004119C" class="pcalibre1 calibre8 pcalibre">%rsp</code> is copied to <code id="P700049702700000000000000004119D" data-uri="chapter03.xhtml#P700049702700000000000000004119D" class="pcalibre1 calibre8 pcalibre">%rdi</code> to be used as the argument to the calls to both gets and <code id="P700049702700000000000000004119E" data-uri="chapter03.xhtml#P700049702700000000000000004119E" class="pcalibre1 calibre8 pcalibre">puts</code>. The 16 bytes between <code id="P700049702700000000000000004119F" data-uri="chapter03.xhtml#P700049702700000000000000004119F" class="pcalibre1 calibre8 pcalibre">buf</code> and the stored return pointer are not used. As long as the user types at most seven characters, the string returned by gets (including the terminating null) will fit within the space allocated for <code id="P70004970270000000000000000411A0" data-uri="chapter03.xhtml#P70004970270000000000000000411A0" class="pcalibre1 calibre8 pcalibre">buf</code>. A longer string, however, will cause gets to overwrite some of the information stored on the stack. As the string gets longer, the following information will get corrupted:</p>
<table id="P70004970270000000000000000411A1" data-uri="chapter03.xhtml#P70004970270000000000000000411A1" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P70004970270000000000000000411A2" data-uri="chapter03.xhtml#P70004970270000000000000000411A2" class="calibre18 pcalibre pcalibre1">Characters typed</th>
<th id="P70004970270000000000000000411A3" data-uri="chapter03.xhtml#P70004970270000000000000000411A3" class="calibre18 pcalibre pcalibre1">Additional corrupted state</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P70004970270000000000000000411A4" data-uri="chapter03.xhtml#P70004970270000000000000000411A4" class="calibre20 pcalibre pcalibre1">0–7</td>
<td id="P70004970270000000000000000411A5" data-uri="chapter03.xhtml#P70004970270000000000000000411A5" class="calibre20 pcalibre pcalibre1">None</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P70004970270000000000000000411A6" data-uri="chapter03.xhtml#P70004970270000000000000000411A6" class="calibre20 pcalibre pcalibre1">9–23</td>
<td id="P70004970270000000000000000411A7" data-uri="chapter03.xhtml#P70004970270000000000000000411A7" class="calibre20 pcalibre pcalibre1">Unused stack space</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P70004970270000000000000000411A8" data-uri="chapter03.xhtml#P70004970270000000000000000411A8" class="calibre20 pcalibre pcalibre1">24–31</td>
<td id="P70004970270000000000000000411A9" data-uri="chapter03.xhtml#P70004970270000000000000000411A9" class="calibre20 pcalibre pcalibre1">Return address</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P70004970270000000000000000411AA" data-uri="chapter03.xhtml#P70004970270000000000000000411AA" class="calibre20 pcalibre pcalibre1">32+</td>
<td id="P70004970270000000000000000411AB" data-uri="chapter03.xhtml#P70004970270000000000000000411AB" class="calibre20 pcalibre pcalibre1">Saved state in caller</td>
</tr>
</tbody>
</table>
<p id="P70004970270000000000000000411AC" data-uri="chapter03.xhtml#P70004970270000000000000000411AC" class="pcalibre1 pcalibre calibre2">No serious consequence occurs for strings of up to 23 characters, but beyond that, the value of the return pointer, and possibly additional saved state, will be corrupted. If the stored value of the return address is corrupted, then the <code id="P70004970270000000000000000411AD" data-uri="chapter03.xhtml#P70004970270000000000000000411AD" class="pcalibre1 calibre8 pcalibre">ret</code> instruction (line 8) will cause the program to jump to a totally unexpected location. None of these behaviors would seem possible based on the C code. The impact of out-of-bounds writing to memory by functions such as <code id="P70004970270000000000000000411AE" data-uri="chapter03.xhtml#P70004970270000000000000000411AE" class="pcalibre1 calibre8 pcalibre">gets</code> can only be understood by studying the program at the machine-code level.</p>
<p id="P70004970270000000000000000411AF" data-uri="chapter03.xhtml#P70004970270000000000000000411AF" class="pcalibre1 pcalibre calibre2">Our code for <code id="P70004970270000000000000000411B0" data-uri="chapter03.xhtml#P70004970270000000000000000411B0" class="pcalibre1 calibre8 pcalibre">echo</code> is simple but sloppy. A better version involves using the function <code id="P70004970270000000000000000411B1" data-uri="chapter03.xhtml#P70004970270000000000000000411B1" class="pcalibre1 calibre8 pcalibre">fgets</code>, which includes as an argument a count on the maximum number of bytes to read. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000032E1.xhtml#P70004970270000000000000000033FE"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">3.71</span></a> asks you to write an echo function that can handle an input string of arbitrary length. In general, using <code id="P70004970270000000000000000411B2" data-uri="chapter03.xhtml#P70004970270000000000000000411B2" class="pcalibre1 calibre8 pcalibre">gets</code> or any function that can overflow storage is considered a bad programming practice. Unfortunately, a number of commonly used library functions, including <code id="P70004970270000000000000000411B3" data-uri="chapter03.xhtml#P70004970270000000000000000411B3" class="pcalibre1 calibre8 pcalibre">strcpy, strcat</code>, and <code id="P70004970270000000000000000411B4" data-uri="chapter03.xhtml#P70004970270000000000000000411B4" class="pcalibre1 calibre8 pcalibre">sprintf</code>, have the property that they can generate a byte sequence without being given any indication of the size of the destination buffer <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B466">[97]</a>. Such conditions can lead to vulnerabilities to buffer overflow.</p>
<section id="P7000497027000000000000000002F7A" data-uri="chapter03.xhtml#P7000497027000000000000000002F7A" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000411B5" data-uri="chapter03.xhtml#P70004970270000000000000000411B5" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.46 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003928">346</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000411B6" data-uri="chapter03.xhtml#P70004970270000000000000000411B6">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000411B7" data-uri="chapter03.xhtml#P70004970270000000000000000411B7">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000411B8" data-uri="chapter03.xhtml#P70004970270000000000000000411B8"><p id="P70004970270000000000000000411B9" data-uri="chapter03.xhtml#P70004970270000000000000000411B9" class="pcalibre calibre3 pcalibre1"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000002F87"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.41</span></a> shows a (low-quality) implementation of a function that reads a line from standard input, copies the string to newly allocated storage, and returns a pointer to the result.</p>
<p id="P70004970270000000000000000411BA" data-uri="chapter03.xhtml#P70004970270000000000000000411BA" class="pcalibre calibre3 pcalibre1">Consider the following scenario. Procedure <code id="P70004970270000000000000000411BB" data-uri="chapter03.xhtml#P70004970270000000000000000411BB" class="pcalibre1 calibre8 pcalibre">get_line</code> is called with the return address equal to <code id="P70004970270000000000000000411BC" data-uri="chapter03.xhtml#P70004970270000000000000000411BC" class="pcalibre1 calibre8 pcalibre">0x400776</code> and register <code id="P70004970270000000000000000411BD" data-uri="chapter03.xhtml#P70004970270000000000000000411BD" class="pcalibre1 calibre8 pcalibre">%rbx</code> equal to <code id="P70004970270000000000000000411BE" data-uri="chapter03.xhtml#P70004970270000000000000000411BE" class="pcalibre1 calibre8 pcalibre">0x0123456789ABCDEF</code>. You type in the string</p>
<pre id="P70004970270000000000000000411BF" data-uri="chapter03.xhtml#P70004970270000000000000000411BF" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000411C0" data-uri="chapter03.xhtml#P70004970270000000000000000411C0" class="calibre10 pcalibre pcalibre1">
0123456789012345678901234
</code></pre>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002F87" data-uri="chapter03.xhtml#P7000497027000000000000000002F87">
<p id="P70004970270000000000000000411C1" data-uri="chapter03.xhtml#P70004970270000000000000000411C1" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak1 pcalibre1" id="P7000497027000000000000000002F89" title="283" data-uri="chapter03.xhtml#P7000497027000000000000000002F89" epub:type="pagebreak"></span>(a) C code</p>
<pre id="P70004970270000000000000000411C2" data-uri="chapter03.xhtml#P70004970270000000000000000411C2" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000411C3" data-uri="chapter03.xhtml#P70004970270000000000000000411C3" class="calibre10 pcalibre pcalibre1">
/* This is very low-quality code.
	It is intended to illustrate bad programming practices.
	See Practice <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000002F7A"><span class="pcalibre label pcalibre1">Problem </span><span class="number pcalibre pcalibre1">3.46</span></a>. */
char *get_line()
{
	char buf[4];
	char *result;
	gets(buf);
	result = malloc(strlen(buf));
	strcpy(result, buf);
	return result;
}
</code></pre>
<p id="P70004970270000000000000000411C4" data-uri="chapter03.xhtml#P70004970270000000000000000411C4" class="pcalibre calibre3 pcalibre1">(b) Disassembly up through call to gets</p>
<pre id="P70004970270000000000000000411C5" data-uri="chapter03.xhtml#P70004970270000000000000000411C5" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000411C6" data-uri="chapter03.xhtml#P70004970270000000000000000411C6" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">char *get_line()</i>
1	0000000000400720 &lt;get_line&gt;:
2	400720:	53			push	%rbx
3	400721:	48 83 ec 10		sub	$0x10,%rsp
	<i class="calibre5 pcalibre pcalibre1">Diagram stack at this point</i>
4	400725:	48 89 e7		mov	%rsp,%rdi
5	400728:	e8 73 ff ff ff		callq	4006a0 &lt;gets&gt;
<i class="calibre5 pcalibre pcalibre1">Modify diagram to show stack contents at this point</i>
</code></pre>
<figcaption id="P70004970270000000000000000411C7" data-uri="chapter03.xhtml#P70004970270000000000000000411C7" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000411C8" data-uri="chapter03.xhtml#P70004970270000000000000000411C8" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">3.41 </span>C and disassembled code for Practice <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000002F7A"><span class="pcalibre1 label2 pcalibre">Problem </span><span class="number pcalibre pcalibre1">3.46</span></a>.</h1></header></figcaption>
</figure>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000411C9" data-uri="chapter03.xhtml#P70004970270000000000000000411C9">The program terminates with a segmentation fault. You run <span class="smallcaps pcalibre pcalibre1">gdb </span>and determine that the error occurs during the execution of the <code id="P70004970270000000000000000411CA" data-uri="chapter03.xhtml#P70004970270000000000000000411CA" class="pcalibre1 calibre8 pcalibre">ret</code> instruction of <code id="P70004970270000000000000000411CB" data-uri="chapter03.xhtml#P70004970270000000000000000411CB" class="pcalibre1 calibre8 pcalibre">get_line.</code></p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P70004970270000000000000000411CC" data-uri="chapter03.xhtml#P70004970270000000000000000411CC">
<li id="P70004970270000000000000000411CD" data-uri="chapter03.xhtml#P70004970270000000000000000411CD" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000411CE" data-uri="chapter03.xhtml#P70004970270000000000000000411CE" class="pcalibre calibre3 pcalibre1">Fill in the diagram that follows, indicating as much as you can about the stack just after executing the instruction at line 3 in the disassembly. Label the quantities stored on the stack (e.g., "Return address") on the right, and their hexadecimal values (if known) within the box. Each box represents 8 bytes. Indicate the position of <code id="P70004970270000000000000000411CF" data-uri="chapter03.xhtml#P70004970270000000000000000411CF" class="pcalibre1 calibre8 pcalibre">%rsp</code>. Recall that the ASCII codes for characters 0–9 are <code id="P70004970270000000000000000411D0" data-uri="chapter03.xhtml#P70004970270000000000000000411D0" class="pcalibre1 calibre8 pcalibre">0x30–0x39.</code></p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002F99" data-uri="chapter03.xhtml#P7000497027000000000000000002F99">
<img alt="A diagram shows a stack with four black sections below a Return address section on top, containing 00 00 00 00 00 40 00 76." id="P70004970270000000000000000411D1" data-uri="P700049702700000000000000000B6C2" src="../images/p283-1.png" class="pcalibre calibre97 pcalibre1"/>
</figure>
</li>
<li id="P70004970270000000000000000411D2" data-uri="chapter03.xhtml#P70004970270000000000000000411D2" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000411D3" data-uri="chapter03.xhtml#P70004970270000000000000000411D3" class="pcalibre calibre3 pcalibre1">Modify your diagram to show the effect of the call to <code id="P70004970270000000000000000411D4" data-uri="chapter03.xhtml#P70004970270000000000000000411D4" class="pcalibre1 calibre8 pcalibre">gets</code> (line 5).</p></li>
<li id="P70004970270000000000000000411D5" data-uri="chapter03.xhtml#P70004970270000000000000000411D5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000411D6" data-uri="chapter03.xhtml#P70004970270000000000000000411D6" class="pcalibre calibre3 pcalibre1">To what address does the program attempt to return?</p></li>
<li id="P70004970270000000000000000411D7" data-uri="chapter03.xhtml#P70004970270000000000000000411D7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000411D8" data-uri="chapter03.xhtml#P70004970270000000000000000411D8" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002FA2" title="284" data-uri="chapter03.xhtml#P7000497027000000000000000002FA2" epub:type="pagebreak"></span>What register(s) have corrupted value(s) when <code id="P70004970270000000000000000411D9" data-uri="chapter03.xhtml#P70004970270000000000000000411D9" class="pcalibre1 calibre8 pcalibre">get_line</code> returns?</p></li>
<li id="P70004970270000000000000000411DA" data-uri="chapter03.xhtml#P70004970270000000000000000411DA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000411DB" data-uri="chapter03.xhtml#P70004970270000000000000000411DB" class="pcalibre calibre3 pcalibre1">Besides the potential for buffer overflow, what two other things are wrong with the code for <code id="P70004970270000000000000000411DC" data-uri="chapter03.xhtml#P70004970270000000000000000411DC" class="pcalibre1 calibre8 pcalibre">get_line?</code></p></li>
</ol>
</div></li></ol>
</section>
<p id="P70004970270000000000000000411DD" data-uri="chapter03.xhtml#P70004970270000000000000000411DD" class="pcalibre1 pcalibre calibre2">A more pernicious use of buffer overflow is to get a program to perform a function that it would otherwise be unwilling to do. This is one of the most common methods to attack the security of a system over a computer network. Typically, the program is fed with a string that contains the byte encoding of some executable code, called the <i class="calibre5 pcalibre pcalibre1">exploit code</i>, plus some extra bytes that overwrite the return address with a pointer to the exploit code. The effect of executing the <code id="P70004970270000000000000000411DE" data-uri="chapter03.xhtml#P70004970270000000000000000411DE" class="pcalibre1 calibre8 pcalibre">ret</code> instruction is then to jump to the exploit code.</p>
<p id="P70004970270000000000000000411DF" data-uri="chapter03.xhtml#P70004970270000000000000000411DF" class="pcalibre1 pcalibre calibre2">In one form of attack, the exploit code then uses a system call to start up a shell program, providing the attacker with a range of operating system functions. In another form, the exploit code performs some otherwise unauthorized task, repairs the damage to the stack, and then executes <code id="P70004970270000000000000000411E0" data-uri="chapter03.xhtml#P70004970270000000000000000411E0" class="pcalibre1 calibre8 pcalibre">ret</code> a second time, causing an (apparently) normal return to the caller.</p>
<p id="P70004970270000000000000000411E1" data-uri="chapter03.xhtml#P70004970270000000000000000411E1" class="pcalibre1 pcalibre calibre2">As an example, the famous Internet worm of November 1988 used four different ways to gain access to many of the computers across the Internet. One was a buffer overflow attack on the finger daemon <code id="P70004970270000000000000000411E2" data-uri="chapter03.xhtml#P70004970270000000000000000411E2" class="pcalibre1 calibre8 pcalibre">fingerd</code>, which serves requests by the <span class="smallcaps pcalibre pcalibre1">finger </span>command. By invoking <span class="smallcaps pcalibre pcalibre1">finger </span>with an appropriate string, the worm could make the daemon at a remote site have a buffer overflow and execute code that gave the worm access to the remote system. Once the worm gained access to a system, it would replicate itself and consume virtually all of the machine's computing resources. As a consequence, hundreds of machines were effectively paralyzed until security experts could determine how to eliminate the worm. The author of the worm was caught and prosecuted. He was sentenced to 3 years probation, 400 hours of community service, and a $10,500 fine. Even to this day, however, people continue to find security leaks in systems that leave them vulnerable to buffer overflow attacks. This highlights the need for careful programming. Any interface to the external environment should be made "bulletproof" so that no behavior by an external agent can cause the system to misbehave.</p>
</section>
<section id="P7000497027000000000000000002FAD" data-uri="chapter03.xhtml#P7000497027000000000000000002FAD" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000411E3" data-uri="chapter03.xhtml#P70004970270000000000000000411E3" epub:type="title"><span class="pcalibre label pcalibre1">3.10.4 </span>Thwarting Buffer Overflow Attacks</h1></header>
<p id="P70004970270000000000000000411E4" data-uri="chapter03.xhtml#P70004970270000000000000000411E4" class="pcalibre1 pcalibre calibre2">Buffer overflow attacks have become so pervasive and have caused so many problems with computer systems that modern compilers and operating systems have implemented mechanisms to make it more difficult to mount these attacks and to limit the ways by which an intruder can seize control of a system via a buffer overflow attack. In this section, we will present mechanisms that are provided by recent versions of <span class="smallcaps pcalibre pcalibre1">gcc </span>for Linux.</p>
<section id="P7000497027000000000000000002FB0" data-uri="chapter03.xhtml#P7000497027000000000000000002FB0" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000411E5" data-uri="chapter03.xhtml#P70004970270000000000000000411E5" epub:type="title">Stack Randomization</h1></header>
<p id="P70004970270000000000000000411E6" data-uri="chapter03.xhtml#P70004970270000000000000000411E6" class="pcalibre1 pcalibre calibre2">In order to insert exploit code into a system, the attacker needs to inject both the code as well as a pointer to this code as part of the attack string. Generating</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000002FB3" data-uri="chapter03.xhtml#P7000497027000000000000000002FB3"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P70004970270000000000000000411E7" data-uri="chapter03.xhtml#P70004970270000000000000000411E7" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002FB5" title="285" data-uri="chapter03.xhtml#P7000497027000000000000000002FB5" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Worms and viruses</h1></header>
<p id="P70004970270000000000000000411E8" data-uri="chapter03.xhtml#P70004970270000000000000000411E8" class="pcalibre calibre3 pcalibre1">Both worms and viruses are pieces of code that attempt to spread themselves among computers. As described by Spafford <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B476">[105],</a> a <i class="calibre5 pcalibre pcalibre1">worm</i> is a program that can run by itself and can propagate a fully working version of itself to other machines. A <i class="calibre5 pcalibre pcalibre1">virus</i> is a piece of code that adds itself to other programs, including operating systems. It cannot run independently. In the popular press, the term "virus" is used to refer to a variety of different strategies for spreading attacking code among systems, and so you will hear people saying "virus" for what more properly should be called a "worm."</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000411E9" data-uri="chapter03.xhtml#P70004970270000000000000000411E9">this pointer requires knowing the stack address where the string will be located. Historically, the stack addresses for a program were highly predictable. For all systems running the same combination of program and operating system version, the stack locations were fairly stable across many machines. So, for example, if an attacker could determine the stack addresses used by a common Web server, it could devise an attack that would work on many machines. Using infectious disease as an analogy, many systems were vulnerable to the exact same strain of a virus, a phenomenon often referred to as a <i class="calibre5 pcalibre pcalibre1">security monoculture</i> <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B464">[96]</a>.</p>
<p id="P70004970270000000000000000411EA" data-uri="chapter03.xhtml#P70004970270000000000000000411EA" class="pcalibre1 pcalibre calibre2">The idea of <i class="calibre5 pcalibre pcalibre1">stack randomization</i> is to make the position of the stack vary from one run of a program to another. Thus, even if many machines are running identical code, they would all be using different stack addresses. This is implemented by allocating a random amount of space between 0 and <var class="calibre5 pcalibre pcalibre1">n</var> bytes on the stack at the start of a program, for example, by using the allocation function <code id="P70004970270000000000000000411EB" data-uri="chapter03.xhtml#P70004970270000000000000000411EB" class="pcalibre1 calibre8 pcalibre">alloca</code>, which allocates space for a specified number of bytes on the stack. This allocated space is not used by the program, but it causes all subsequent stack locations to vary from one execution of a program to another. The allocation range <var class="calibre5 pcalibre pcalibre1">n</var> needs to be large enough to get sufficient variations in the stack addresses, yet small enough that it does not waste too much space in the program.</p>
<p id="P70004970270000000000000000411EC" data-uri="chapter03.xhtml#P70004970270000000000000000411EC" class="pcalibre1 pcalibre calibre2">The following code shows a simple way to determine a "typical" stack address:</p>
<pre id="P70004970270000000000000000411ED" data-uri="chapter03.xhtml#P70004970270000000000000000411ED" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000411EE" data-uri="chapter03.xhtml#P70004970270000000000000000411EE" class="calibre10 pcalibre pcalibre1">
int main(){
	long local;
	printf("local at %p\n", &amp;local);
	return 0;
}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000411EF" data-uri="chapter03.xhtml#P70004970270000000000000000411EF">This code simply prints the address of a local variable in the main function. Running the code 10,000 times on a Linux machine in 32-bit mode, the addresses ranged from <code id="P70004970270000000000000000411F0" data-uri="chapter03.xhtml#P70004970270000000000000000411F0" class="pcalibre1 calibre8 pcalibre">0xff7fc59c</code> to <code id="P70004970270000000000000000411F1" data-uri="chapter03.xhtml#P70004970270000000000000000411F1" class="pcalibre1 calibre8 pcalibre">0xffffd09c</code>, a range of around 2<sup class="calibre51 pcalibre pcalibre1">23</sup>. Running in 64-bit mode on the newer machine, the addresses ranged from <code id="P70004970270000000000000000411F2" data-uri="chapter03.xhtml#P70004970270000000000000000411F2" class="pcalibre1 calibre8 pcalibre">0x7fff0001b698</code> to <code id="P70004970270000000000000000411F3" data-uri="chapter03.xhtml#P70004970270000000000000000411F3" class="pcalibre1 calibre8 pcalibre">0x7ffffffaa4a8</code>, a range of nearly 2<sup class="calibre51 pcalibre pcalibre1">32</sup>.</p>
<p id="P70004970270000000000000000411F4" data-uri="chapter03.xhtml#P70004970270000000000000000411F4" class="pcalibre1 pcalibre calibre2">Stack randomization has become standard practice in Linux systems. It is one of a larger class of techniques known as <i class="calibre5 pcalibre pcalibre1">address-space layout randomization</i>, or ASLR <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B46A">[99]</a>. With ASLR, different parts of the program, including program code, library code, stack, global variables, and heap data, are loaded into different <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002FC3" title="286" data-uri="chapter03.xhtml#P7000497027000000000000000002FC3" epub:type="pagebreak"></span>regions of memory each time a program is run. That means that a program running on one machine will have very different address mappings than the same program running on other machines. This can thwart some forms of attack.</p>
<p id="P70004970270000000000000000411F5" data-uri="chapter03.xhtml#P70004970270000000000000000411F5" class="pcalibre1 pcalibre calibre2">Overall, however, a persistent attacker can overcome randomization by brute force, repeatedly attempting attacks with different addresses. A common trick is to include a long sequence of <code id="P70004970270000000000000000411F6" data-uri="chapter03.xhtml#P70004970270000000000000000411F6" class="pcalibre1 calibre8 pcalibre">nop</code> (pronounced "no op," short for "no operation") instructions before the actual exploit code. Executing this instruction has no effect, other than incrementing the program counter to the next instruction. As long as the attacker can guess an address somewhere within this sequence, the program will run through the sequence and then hit the exploit code. The common term for this sequence is a "nop sled" <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B466">[97]</a>, expressing the idea that the program "slides" through the sequence. If we set up a 256-byte nop sled, then the randomization over <var class="calibre5 pcalibre pcalibre1">n</var> = 2<sup class="calibre51 pcalibre pcalibre1">23</sup> can be cracked by enumerating 2<sup class="calibre51 pcalibre pcalibre1">15</sup> = 32,768 starting addresses, which is entirely feasible for a determined attacker. For the 64-bit case, trying to enumerate 2<sup class="calibre51 pcalibre pcalibre1">24</sup> = 16,777,216 is a bit more daunting. We can see that stack randomization and other aspects of ASLR can increase the effort required to successfully attack a system, and therefore greatly reduce the rate at which a virus or worm can spread, but it cannot provide a complete safeguard.</p>
<section id="P7000497027000000000000000002FC6" data-uri="chapter03.xhtml#P7000497027000000000000000002FC6" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P70004970270000000000000000411F7" data-uri="chapter03.xhtml#P70004970270000000000000000411F7" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.47 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003968">347</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000411F8" data-uri="chapter03.xhtml#P70004970270000000000000000411F8">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000411F9" data-uri="chapter03.xhtml#P70004970270000000000000000411F9">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000411FA" data-uri="chapter03.xhtml#P70004970270000000000000000411FA"><p id="P70004970270000000000000000411FB" data-uri="chapter03.xhtml#P70004970270000000000000000411FB" class="pcalibre calibre3 pcalibre1">Running our stack-checking code 10,000 times on a system running Linux version 2.6.16, we obtained addresses ranging from a minimum of <code id="P70004970270000000000000000411FC" data-uri="chapter03.xhtml#P70004970270000000000000000411FC" class="pcalibre1 calibre8 pcalibre">0xffffb754</code> to a maximum of <code id="P70004970270000000000000000411FD" data-uri="chapter03.xhtml#P70004970270000000000000000411FD" class="pcalibre1 calibre8 pcalibre">0xffffd754</code>.</p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P70004970270000000000000000411FE" data-uri="chapter03.xhtml#P70004970270000000000000000411FE">
<li id="P70004970270000000000000000411FF" data-uri="chapter03.xhtml#P70004970270000000000000000411FF" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041200" data-uri="chapter03.xhtml#P7000497027000000000000000041200" class="pcalibre calibre3 pcalibre1">What is the approximate range of addresses?</p></li>
<li id="P7000497027000000000000000041201" data-uri="chapter03.xhtml#P7000497027000000000000000041201" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041202" data-uri="chapter03.xhtml#P7000497027000000000000000041202" class="pcalibre calibre3 pcalibre1">If we attempted a buffer overrun with a 128-byte nop sled, about how many attempts would it take to test all starting addresses?</p></li>
</ol>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000002FD3" data-uri="chapter03.xhtml#P7000497027000000000000000002FD3" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041203" data-uri="chapter03.xhtml#P7000497027000000000000000041203" epub:type="title">Stack Corruption Detection</h1></header>
<p id="P7000497027000000000000000041204" data-uri="chapter03.xhtml#P7000497027000000000000000041204" class="pcalibre1 pcalibre calibre2">A second line of defense is to be able to detect when a stack has been corrupted. We saw in the example of the echo function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000002F48"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.40</span></a>) that the corruption typically occurs when the program overruns the bounds of a local buffer. In C, there is no reliable way to prevent writing beyond the bounds of an array. Instead, the program can attempt to detect when such a write has occurred before it can have any harmful effects.</p>
<p id="P7000497027000000000000000041205" data-uri="chapter03.xhtml#P7000497027000000000000000041205" class="pcalibre1 pcalibre calibre2">Recent versions of <span class="smallcaps pcalibre pcalibre1">gcc </span>incorporate a mechanism known as a <i class="calibre5 pcalibre pcalibre1">stack protector</i> into the generated code to detect buffer overruns. The idea is to store a special <i class="calibre5 pcalibre pcalibre1">canary</i> value<a class="noteref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" id="r__P7000497027000000000000000003A70" epub:type="noteref" href="#P7000497027000000000000000003A70"><sup class="pcalibre1 calibre21 pcalibre">4</sup></a> in the stack frame between any local buffer and the rest of the stack state, as illustrated in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000002FD7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.42</span></a> <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3D5">[26,</a> <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B466">97]</a>. This canary value, also referred to as a <i class="calibre5 pcalibre pcalibre1">guard value</i>, is generated randomly each time the program runs, and so there is no</p><aside class="footnote pcalibre5 pcalibre" id="P7000497027000000000000000003A70" data-uri="chapter03.xhtml#P7000497027000000000000000003A70" epub:type="footnote"><p class="pcalibre calibre3 pcalibre1"><span class="pcalibre1 number2 pcalibre"><a href="#r__P7000497027000000000000000003A70" class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1">4. </a></span>The term "canary" refers to the historic use of these birds to detect the presence of dangerous gases in coal mines.</p></aside>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002FD7" data-uri="chapter03.xhtml#P7000497027000000000000000002FD7">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002FD8" title="287" data-uri="chapter03.xhtml#P7000497027000000000000000002FD8" epub:type="pagebreak"></span>
<img alt="A diagram illustrates a stack organization for echo function with stack protector enabled." id="P7000497027000000000000000041206" data-uri="P700049702700000000000000000B6C3" src="../images/p287-1.png" class="calibre98 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000041207" data-uri="chapter03.xhtml#P7000497027000000000000000041207" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041208" data-uri="chapter03.xhtml#P7000497027000000000000000041208" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">3.42 </span>Stack organization for <code id="P7000497027000000000000000041209" data-uri="chapter03.xhtml#P7000497027000000000000000041209" class="pcalibre1 calibre8 pcalibre">echo</code> function with stack protector enabled.</h1></header><div class="edition pcalibre pcalibre1" id="P700049702700000000000000004120A" data-uri="chapter03.xhtml#P700049702700000000000000004120A"><p id="P700049702700000000000000004120B" data-uri="chapter03.xhtml#P700049702700000000000000004120B" class="pcalibre calibre3 pcalibre1">A special "canary" value is positioned between array <code id="P700049702700000000000000004120C" data-uri="chapter03.xhtml#P700049702700000000000000004120C" class="pcalibre1 calibre8 pcalibre">buf</code> and the saved state. The code checks the canary value to determine whether or not the stack state has been corrupted.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000214E4" data-uri="chapter03.xhtml#P70004970270000000000000000214E4">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P700049702700000000000000004120D" data-uri="chapter03.xhtml#P700049702700000000000000004120D" class="pcalibre1 pcalibre calibre2">A diagram has two parts, from bottom to top:</p>
<p id="P700049702700000000000000004120E" data-uri="chapter03.xhtml#P700049702700000000000000004120E" class="pcalibre1 pcalibre calibre2">Stack frame for echo with buf = %rsp at the bottom containing [7][6][5][4][3][2][1][0] and a section above containing Canary</p>
<p id="P700049702700000000000000004120F" data-uri="chapter03.xhtml#P700049702700000000000000004120F" class="pcalibre calibre3 pcalibre1">Stack frame for caller with %rsp+24 on bottom containing Return address</p>
</details>
</figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041210" data-uri="chapter03.xhtml#P7000497027000000000000000041210">easy way for an attacker to determine what it is. Before restoring the register state and returning from the function, the program checks if the canary has been altered by some operation of this function or one that it has called. If so, the program aborts with an error.</p>
<p id="P7000497027000000000000000041211" data-uri="chapter03.xhtml#P7000497027000000000000000041211" class="pcalibre1 pcalibre calibre2">Recent versions of <span class="smallcaps pcalibre pcalibre1">gcc </span>try to determine whether a function is vulnerable to a stack overflow and insert this type of overflow detection automatically. In fact, for our earlier demonstration of stack overflow, we had to give the command-line option <code id="P7000497027000000000000000041212" data-uri="chapter03.xhtml#P7000497027000000000000000041212" class="pcalibre1 calibre8 pcalibre">-fno-stack-protector</code> to prevent <span class="smallcaps pcalibre pcalibre1">gcc </span>from inserting this code. Compiling the function <code id="P7000497027000000000000000041213" data-uri="chapter03.xhtml#P7000497027000000000000000041213" class="pcalibre1 calibre8 pcalibre">echo</code> without this option, and hence with the stack protector enabled, gives the following assembly code:</p>
<pre id="P7000497027000000000000000041214" data-uri="chapter03.xhtml#P7000497027000000000000000041214" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041215" data-uri="chapter03.xhtml#P7000497027000000000000000041215" class="calibre10 pcalibre pcalibre1">
<i class="calibre5 pcalibre pcalibre1">void echo()</i>
1	echo:
2	subq	$24, %rsp	<i class="calibre5 pcalibre pcalibre1">Allocate 24 bytes on stack</i>
3	movq	%fs:40, %rax	<i class="calibre5 pcalibre pcalibre1">Retrieve canary</i>
4	movq	%rax, 8(%rsp)	<i class="calibre5 pcalibre pcalibre1">Store on stack</i>
5	xorl	%eax, %eax	<i class="calibre5 pcalibre pcalibre1">Zero out register</i>
6	movq	%rsp, %rdi	<i class="calibre5 pcalibre pcalibre1">Compute buf as %rsp</i>
7	call	gets		<i class="calibre5 pcalibre pcalibre1">Call gets</i>
8	movq	%rsp, %rdi	<i class="calibre5 pcalibre pcalibre1">Compute buf as %rsp</i>
9	call	puts		<i class="calibre5 pcalibre pcalibre1">Call puts</i>
10	movq	8(%rsp), %rax	<i class="calibre5 pcalibre pcalibre1">Retrieve canary</i>
11	xorq	%fs:40, %rax	<i class="calibre5 pcalibre pcalibre1">Compare to stored value</i>
12	je	.L9		<i class="calibre5 pcalibre pcalibre1">If =, goto</i> ok
13	call	__stack_chk_fail <i class="calibre5 pcalibre pcalibre1">Stack corrupted!</i>
14	.L9:		     <b class="calibre4 pcalibre pcalibre1">ok:</b>
15	addq	$24, %rsp	<i class="calibre5 pcalibre pcalibre1">Deallocate stack space</i>
16	ret
</code></pre>
<p id="P7000497027000000000000000041216" data-uri="chapter03.xhtml#P7000497027000000000000000041216" class="pcalibre1 pcalibre calibre2">We see that this version of the function retrieves a value from memory (line 3) and stores it on the stack at offset 8 from <code id="P7000497027000000000000000041217" data-uri="chapter03.xhtml#P7000497027000000000000000041217" class="pcalibre1 calibre8 pcalibre">%rsp</code>, just beyond the region allocated for <code id="P7000497027000000000000000041218" data-uri="chapter03.xhtml#P7000497027000000000000000041218" class="pcalibre1 calibre8 pcalibre">buf</code>. The instruction argument <code id="P7000497027000000000000000041219" data-uri="chapter03.xhtml#P7000497027000000000000000041219" class="pcalibre1 calibre8 pcalibre">%fs:40</code> is an indication that the canary value is read from memory using <i class="calibre5 pcalibre pcalibre1">segmented addressing</i>, an addressing mechanism that dates <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002FEA" title="288" data-uri="chapter03.xhtml#P7000497027000000000000000002FEA" epub:type="pagebreak"></span>back to the 80286 and is seldom found in programs running on modern systems. By storing the canary in a special segment, it can be marked as "read only," so that an attacker cannot overwrite the stored canary value. Before restoring the register state and returning, the function compares the value stored at the stack location with the canary value (via the <code id="P700049702700000000000000004121A" data-uri="chapter03.xhtml#P700049702700000000000000004121A" class="pcalibre1 calibre8 pcalibre">xorq</code> instruction on line 11). If the two are identical, the <code id="P700049702700000000000000004121B" data-uri="chapter03.xhtml#P700049702700000000000000004121B" class="pcalibre1 calibre8 pcalibre">xorq</code> instruction will yield zero, and the function will complete in the normal fashion. A nonzero value indicates that the canary on the stack has been modified, and so the code will call an error routine.</p>
<p id="P700049702700000000000000004121C" data-uri="chapter03.xhtml#P700049702700000000000000004121C" class="pcalibre1 pcalibre calibre2">Stack protection does a good job of preventing a buffer overflow attack from corrupting state stored on the program stack. It incurs only a small performance penalty, especially because <span class="smallcaps pcalibre pcalibre1">gcc </span>only inserts it when there is a local buffer of type <code id="P700049702700000000000000004121D" data-uri="chapter03.xhtml#P700049702700000000000000004121D" class="pcalibre1 calibre8 pcalibre">char</code> in the function. Of course, there are other ways to corrupt the state of an executing program, but reducing the vulnerability of the stack thwarts many common attack strategies.</p>
<section id="P7000497027000000000000000002FEF" data-uri="chapter03.xhtml#P7000497027000000000000000002FEF" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P700049702700000000000000004121E" data-uri="chapter03.xhtml#P700049702700000000000000004121E" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.48 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003968">347</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P700049702700000000000000004121F" data-uri="chapter03.xhtml#P700049702700000000000000004121F">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000041220" data-uri="chapter03.xhtml#P7000497027000000000000000041220">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041221" data-uri="chapter03.xhtml#P7000497027000000000000000041221"><p id="P7000497027000000000000000041222" data-uri="chapter03.xhtml#P7000497027000000000000000041222" class="pcalibre calibre3 pcalibre1">The functions <code id="P7000497027000000000000000041223" data-uri="chapter03.xhtml#P7000497027000000000000000041223" class="pcalibre1 calibre8 pcalibre">intlen, len</code>, and <code id="P7000497027000000000000000041224" data-uri="chapter03.xhtml#P7000497027000000000000000041224" class="pcalibre1 calibre8 pcalibre">iptoa</code> provide a very convoluted way to compute the number of decimal digits required to represent an integer. We will use this as a way to study some aspects of the <span class="smallcaps pcalibre pcalibre1">gcc </span>stack protector facility.</p>
<pre id="P7000497027000000000000000041225" data-uri="chapter03.xhtml#P7000497027000000000000000041225" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041226" data-uri="chapter03.xhtml#P7000497027000000000000000041226" class="calibre10 pcalibre pcalibre1">
int len(char *s) {
	return strlen(s);
}
void iptoa(char *s, long *p) {
	long val = *p;
	sprintf(s, "%ld", val);
}
int intlen(long x) {
	long v;
	char buf[12];
	v = x;
	iptoa(buf, &amp;v);
	return len(buf);
}
</code></pre>
<p id="P7000497027000000000000000041227" data-uri="chapter03.xhtml#P7000497027000000000000000041227" class="pcalibre calibre3 pcalibre1">The following show portions of the code for <code id="P7000497027000000000000000041228" data-uri="chapter03.xhtml#P7000497027000000000000000041228" class="pcalibre1 calibre8 pcalibre">intlen</code>, compiled both with and without stack protector:</p>
<p id="P7000497027000000000000000041229" data-uri="chapter03.xhtml#P7000497027000000000000000041229" class="pcalibre calibre3 pcalibre1">(a) Without protector</p>
<pre id="P700049702700000000000000004122A" data-uri="chapter03.xhtml#P700049702700000000000000004122A" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004122B" data-uri="chapter03.xhtml#P700049702700000000000000004122B" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">int intlen(long x)</i>
	<i class="calibre5 pcalibre pcalibre1">x in %rdi</i>
1	intlen:
2	subq	$40, %rsp
3	movq	%rdi, 24(%rsp)
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002FFE" title="289" data-uri="chapter03.xhtml#P7000497027000000000000000002FFE" epub:type="pagebreak"></span>4	leaq	24(%rsp), %rsi
5	movq	%rsp, %rdi
6	call	iptoa
</code></pre>
<p id="P700049702700000000000000004122C" data-uri="chapter03.xhtml#P700049702700000000000000004122C" class="pcalibre calibre3 pcalibre1">(b) With protector</p>
<pre id="P700049702700000000000000004122D" data-uri="chapter03.xhtml#P700049702700000000000000004122D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004122E" data-uri="chapter03.xhtml#P700049702700000000000000004122E" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">int intlen(long x)</i>
	<i class="calibre5 pcalibre pcalibre1">x in %rdi</i>
1	intlen:
2	subq	$56, %rsp
3	movq	%fs:40, %rax
4	movq	%rax, 40(%rsp)
5	xorl	%eax, %eax
6	movq	%rdi, 8(%rsp)
7	leaq	8(%rsp), %rsi
8	leaq	16(%rsp), %rdi
9	call	iptoa
</code></pre>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P700049702700000000000000004122F" data-uri="chapter03.xhtml#P700049702700000000000000004122F">
<li id="P7000497027000000000000000041230" data-uri="chapter03.xhtml#P7000497027000000000000000041230" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041231" data-uri="chapter03.xhtml#P7000497027000000000000000041231" class="pcalibre calibre3 pcalibre1">For both versions: What are the positions in the stack frame for <code id="P7000497027000000000000000041232" data-uri="chapter03.xhtml#P7000497027000000000000000041232" class="pcalibre1 calibre8 pcalibre">buf, v</code>, and (when present) the canary value?</p></li>
<li id="P7000497027000000000000000041233" data-uri="chapter03.xhtml#P7000497027000000000000000041233" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041234" data-uri="chapter03.xhtml#P7000497027000000000000000041234" class="pcalibre calibre3 pcalibre1">How does the rearranged ordering of the local variables in the protected code provide greater security against a buffer overrun attack?</p></li>
</ol>
</div></li></ol></section>
</section>
<section id="P7000497027000000000000000003008" data-uri="chapter03.xhtml#P7000497027000000000000000003008" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041235" data-uri="chapter03.xhtml#P7000497027000000000000000041235" epub:type="title">Limiting Executable Code Regions</h1></header>
<p id="P7000497027000000000000000041236" data-uri="chapter03.xhtml#P7000497027000000000000000041236" class="pcalibre1 pcalibre calibre2">A final step is to eliminate the ability of an attacker to insert executable code into a system. One method is to limit which memory regions hold executable code. In typical programs, only the portion of memory holding the code generated by the compiler need be executable. The other portions can be restricted to allow just reading and writing. As we will see in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">9</span></a>, the virtual memory space is logically divided into <i class="calibre5 pcalibre pcalibre1">pages</i>, typically with 2,048 or 4,096 bytes per page. The hardware supports different forms of <i class="calibre5 pcalibre pcalibre1">memory protection</i>, indicating the forms of access allowed by both user programs and the operating system kernel. Many systems allow control over three forms of access: read (reading data from memory), write (storing data into memory), and execute (treating the memory contents as machine-level code). Historically, the x86 architecture merged the read and execute access controls into a single 1-bit flag, so that any page marked as readable was also executable. The stack had to be kept both readable and writable, and therefore the bytes on the stack were also executable. Various schemes were implemented to be able to limit some pages to being readable but not executable, but these generally introduced significant inefficiencies.</p>
<p id="P7000497027000000000000000041237" data-uri="chapter03.xhtml#P7000497027000000000000000041237" class="pcalibre1 pcalibre calibre2">More recently, AMD introduced an NX (for "no-execute") bit into the memory protection for its 64-bit processors, separating the read and execute access modes, and Intel followed suit. With this feature, the stack can be marked as being readable and writable, but not executable, and the checking of whether a page is executable is performed in hardware, with no penalty in efficiency.</p>
<p id="P7000497027000000000000000041238" data-uri="chapter03.xhtml#P7000497027000000000000000041238" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000300D" title="290" data-uri="chapter03.xhtml#P700049702700000000000000000300D" epub:type="pagebreak"></span>Some types of programs require the ability to dynamically generate and execute code. For example, "just-in-time" compilation techniques dynamically generate code for programs written in interpreted languages, such as Java, to improve execution performance. Whether or not the run-time system can restrict the executable code to just that part generated by the compiler in creating the original program depends on the language and the operating system.</p>
<p id="P7000497027000000000000000041239" data-uri="chapter03.xhtml#P7000497027000000000000000041239" class="pcalibre1 pcalibre calibre2">The techniques we have outlined—randomization, stack protection, and limiting which portions of memory can hold executable code—are three of the most common mechanisms used to minimize the vulnerability of programs to buffer overflow attacks. They all have the properties that they require no special effort on the part of the programmer and incur very little or no performance penalty. Each separately reduces the level of vulnerability, and in combination they become even more effective. Unfortunately, there are still ways to attack computers <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B44D">[85,</a> <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B466">97]</a>, and so worms and viruses continue to compromise the integrity of many machines.</p>
</section>
</section>
<section id="P700049702700000000000000000300F" data-uri="chapter03.xhtml#P700049702700000000000000000300F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004123A" data-uri="chapter03.xhtml#P700049702700000000000000004123A" epub:type="title"><span class="pcalibre label pcalibre1">3.10.5 </span>Supporting Variable-Size Stack Frames</h1></header>
<p id="P700049702700000000000000004123B" data-uri="chapter03.xhtml#P700049702700000000000000004123B" class="pcalibre1 pcalibre calibre2">We have examined the machine-level code for a variety of functions so far, but they all have the property that the compiler can determine in advance the amount of space that must be allocated for their stack frames. Some functions, however, require a variable amount of local storage. This can occur, for example, when the function calls <code id="P700049702700000000000000004123C" data-uri="chapter03.xhtml#P700049702700000000000000004123C" class="pcalibre1 calibre8 pcalibre">alloca</code>, a standard library function that can allocate an arbitrary number of bytes of storage on the stack. It can also occur when the code declares a local array of variable size.</p>
<p id="P700049702700000000000000004123D" data-uri="chapter03.xhtml#P700049702700000000000000004123D" class="pcalibre1 pcalibre calibre2">Although the information presented in this section should rightfully be considered an aspect of how procedures are implemented, we have deferred the presentation to this point, since it requires an understanding of arrays and alignment.</p>
<p id="P700049702700000000000000004123E" data-uri="chapter03.xhtml#P700049702700000000000000004123E" class="pcalibre1 pcalibre calibre2">The code of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003022"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.43(a)</span></a> gives an example of a function containing a variable-size array. The function declares local array <code id="P700049702700000000000000004123F" data-uri="chapter03.xhtml#P700049702700000000000000004123F" class="pcalibre1 calibre8 pcalibre">p</code> of <var class="calibre5 pcalibre pcalibre1">n</var> pointers, where <var class="calibre5 pcalibre pcalibre1">n</var> is given by the first argument. This requires allocating 8<var class="calibre5 pcalibre pcalibre1">n</var> bytes on the stack, where the value of <var class="calibre5 pcalibre pcalibre1">n</var> may vary from one call of the function to another. The compiler therefore cannot determine how much space it must allocate for the function's stack frame. In addition, the program generates a reference to the address of local variable <code id="P7000497027000000000000000041240" data-uri="chapter03.xhtml#P7000497027000000000000000041240" class="pcalibre1 calibre8 pcalibre">i</code>, and so this variable must also be stored on the stack. During execution, the program must be able to access both local variable <code id="P7000497027000000000000000041241" data-uri="chapter03.xhtml#P7000497027000000000000000041241" class="pcalibre1 calibre8 pcalibre">i</code> and the elements of array <code id="P7000497027000000000000000041242" data-uri="chapter03.xhtml#P7000497027000000000000000041242" class="pcalibre1 calibre8 pcalibre">p</code>. On returning, the function must deallocate the stack frame and set the stack pointer to the position of the stored return address.</p>
<p id="P7000497027000000000000000041243" data-uri="chapter03.xhtml#P7000497027000000000000000041243" class="pcalibre1 pcalibre calibre2">To manage a variable-size stack frame, x86-64 code uses register <code id="P7000497027000000000000000041244" data-uri="chapter03.xhtml#P7000497027000000000000000041244" class="pcalibre1 calibre8 pcalibre">%rbp</code> to serve as a <i class="calibre5 pcalibre pcalibre1">frame pointer</i> (sometimes referred to as a <i class="calibre5 pcalibre pcalibre1">base pointer</i>, and hence the letters <code id="P7000497027000000000000000041245" data-uri="chapter03.xhtml#P7000497027000000000000000041245" class="pcalibre1 calibre8 pcalibre">bp</code> in <code id="P7000497027000000000000000041246" data-uri="chapter03.xhtml#P7000497027000000000000000041246" class="pcalibre1 calibre8 pcalibre">%rbp</code>). When using a frame pointer, the stack frame is organized as shown for the case of function <code id="P7000497027000000000000000041247" data-uri="chapter03.xhtml#P7000497027000000000000000041247" class="pcalibre1 calibre8 pcalibre">vframe</code> in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000302E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.44</span></a>. We see that the code must save the previous version of <code id="P7000497027000000000000000041248" data-uri="chapter03.xhtml#P7000497027000000000000000041248" class="pcalibre1 calibre8 pcalibre">%rbp</code> on the stack, since it is a callee-saved register. It then keeps <code id="P7000497027000000000000000041249" data-uri="chapter03.xhtml#P7000497027000000000000000041249" class="pcalibre1 calibre8 pcalibre">%rbp</code> pointing to this position throughout the execution of the function, and it references fixed-length local variables, such as <code id="P700049702700000000000000004124A" data-uri="chapter03.xhtml#P700049702700000000000000004124A" class="pcalibre1 calibre8 pcalibre">i</code>, at offsets relative to <code id="P700049702700000000000000004124B" data-uri="chapter03.xhtml#P700049702700000000000000004124B" class="pcalibre1 calibre8 pcalibre">%rbp.</code></p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003022" data-uri="chapter03.xhtml#P7000497027000000000000000003022">
<p id="P700049702700000000000000004124C" data-uri="chapter03.xhtml#P700049702700000000000000004124C" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak1 pcalibre1" id="P7000497027000000000000000003024" title="291" data-uri="chapter03.xhtml#P7000497027000000000000000003024" epub:type="pagebreak"></span>(a) C code</p>
<pre id="P700049702700000000000000004124D" data-uri="chapter03.xhtml#P700049702700000000000000004124D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004124E" data-uri="chapter03.xhtml#P700049702700000000000000004124E" class="calibre10 pcalibre pcalibre1">
long vframe(long n, long idx, long *q) {
	long i;
	long *p[n];
	p[0] = &amp;i;
	for (i = 1; i &lt; n; i++)
	  p[i] = q;
	return *p[idx];
}
</code></pre>
<p id="P700049702700000000000000004124F" data-uri="chapter03.xhtml#P700049702700000000000000004124F" class="pcalibre1 pcalibre calibre2">(b) Portions of generated assembly code</p>
<pre id="P7000497027000000000000000041250" data-uri="chapter03.xhtml#P7000497027000000000000000041250" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041251" data-uri="chapter03.xhtml#P7000497027000000000000000041251" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">long vframe(long n, long idx, long *q)</i>
	<i class="calibre5 pcalibre pcalibre1">n in %rdi, idx in %rsi, q in %rdx</i>
	<i class="calibre5 pcalibre pcalibre1">Only portions of code shown</i>
1	vframe:
2	pushq	%rbp			<i class="calibre5 pcalibre pcalibre1">Save old %rbp</i>
3	movq	%rsp, %rbp		<i class="calibre5 pcalibre pcalibre1">Set frame pointer</i>
4	subq	$16, %rsp		<i class="calibre5 pcalibre pcalibre1">Allocate space for i (%rsp = s</i><sub class="calibre85 pcalibre pcalibre1">1</sub>)
5	leaq	22(,%rdi,8), %rax
6	andq	$-16, %rax
7	subq	%rax, %rsp		<i class="calibre5 pcalibre pcalibre1">Allocate space for array p (%rsp = s</i><sub class="calibre85 pcalibre pcalibre1">2</sub>)
8	leaq	7(%rsp), %rax
9	shrq	$3, %rax
10	leaq	0(,%rax,8), %r8		<i class="calibre5 pcalibre pcalibre1">Set %r8 to &amp;p[0]</i>
11	movq	%r8, %rcx		<i class="calibre5 pcalibre pcalibre1">Set %rcx to &amp;p[0] (%rcx = p)</i>
	<i class="calibre5 pcalibre pcalibre1">...</i>
	<i class="calibre5 pcalibre pcalibre1">Code for initialization loop</i>
	<i class="calibre5 pcalibre pcalibre1">i in %rax and on stack, n in %rdi, p in %rcx, q in %rdx</i>
12	.L3:			      <b class="calibre4 pcalibre pcalibre1">loop:</b>
13	movq	%rdx, (%rcx,%rax,8)	<i class="calibre5 pcalibre pcalibre1">Set p[i] to q</i>
14	addq	$1, %rax		<i class="calibre5 pcalibre pcalibre1">Increment i</i>
15	movq	%rax, -8(%rbp)		<i class="calibre5 pcalibre pcalibre1">Store on stack</i>
16	.L2:
17	movq	-8(%rbp), %rax		<i class="calibre5 pcalibre pcalibre1">Retrieve i from stack</i>
18	cmpq	%rdi, %rax		<i class="calibre5 pcalibre pcalibre1">Compare i:n</i>
19	jl	.L3			<i class="calibre5 pcalibre pcalibre1">If &lt;, goto</i> loop
	<i class="calibre5 pcalibre pcalibre1">...</i>
	<i class="calibre5 pcalibre pcalibre1">Code for function exit</i>
20	leave				<i class="calibre5 pcalibre pcalibre1">Restore %rbp and %rsp</i>
21	ret				<i class="calibre5 pcalibre pcalibre1">Return</i>
</code></pre>
<figcaption id="P7000497027000000000000000041252" data-uri="chapter03.xhtml#P7000497027000000000000000041252" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041253" data-uri="chapter03.xhtml#P7000497027000000000000000041253" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">3.43 </span>Function requiring the use of a frame pointer.</h1></header><div class="caption pcalibre pcalibre1" id="P7000497027000000000000000041254" data-uri="chapter03.xhtml#P7000497027000000000000000041254"><p id="P7000497027000000000000000041255" data-uri="chapter03.xhtml#P7000497027000000000000000041255" class="pcalibre calibre3 pcalibre1">The variable-size array implies that the size of the stack frame cannot be determined at compile time.</p></div></figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000302E" data-uri="chapter03.xhtml#P700049702700000000000000000302E">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000302F" title="292" data-uri="chapter03.xhtml#P700049702700000000000000000302F" epub:type="pagebreak"></span>
<img alt="A diagram illustrates a stack frame for function vframe." id="P7000497027000000000000000041256" data-uri="P700049702700000000000000000B6C4" src="../images/p292-1.png" class="calibre99 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000041257" data-uri="chapter03.xhtml#P7000497027000000000000000041257" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041258" data-uri="chapter03.xhtml#P7000497027000000000000000041258" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">3.44 </span>Stack frame structure for function <code id="P7000497027000000000000000041259" data-uri="chapter03.xhtml#P7000497027000000000000000041259" class="pcalibre1 calibre8 pcalibre">vframe</code>.</h1></header><div class="edition pcalibre pcalibre1" id="P700049702700000000000000004125A" data-uri="chapter03.xhtml#P700049702700000000000000004125A"><p id="P700049702700000000000000004125B" data-uri="chapter03.xhtml#P700049702700000000000000004125B" class="pcalibre calibre3 pcalibre1">The function uses register <code id="P700049702700000000000000004125C" data-uri="chapter03.xhtml#P700049702700000000000000004125C" class="pcalibre1 calibre8 pcalibre">%rbp</code> as a frame pointer. The annotations along the right-hand side are in reference to Practice <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003055"><span class="pcalibre label pcalibre1">Problem </span><span class="number pcalibre pcalibre1">3.49</span></a>.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000021535" data-uri="chapter03.xhtml#P7000497027000000000000000021535">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P700049702700000000000000004125D" data-uri="chapter03.xhtml#P700049702700000000000000004125D" class="pcalibre1 pcalibre calibre2">The sections of the stack are summarized below from bottom to top:</p>
<ul class="ul_none1 pcalibre pcalibre1" id="P700049702700000000000000004125E" data-uri="chapter03.xhtml#P700049702700000000000000004125E">
<li id="P700049702700000000000000004125F" data-uri="chapter03.xhtml#P700049702700000000000000004125F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041260" data-uri="chapter03.xhtml#P7000497027000000000000000041260" class="calibre13 pcalibre pcalibre1">e2 from s2 (Stack point %rsp) at the bottom to p.</p></li>
<li id="P7000497027000000000000000041261" data-uri="chapter03.xhtml#P7000497027000000000000000041261" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041262" data-uri="chapter03.xhtml#P7000497027000000000000000041262" class="calibre13 pcalibre pcalibre1">8n bytes containing p</p></li>
<li id="P7000497027000000000000000041263" data-uri="chapter03.xhtml#P7000497027000000000000000041263" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041264" data-uri="chapter03.xhtml#P7000497027000000000000000041264" class="calibre13 pcalibre pcalibre1">e1 to s1, numbered negative 16</p></li>
<li id="P7000497027000000000000000041265" data-uri="chapter03.xhtml#P7000497027000000000000000041265" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041266" data-uri="chapter03.xhtml#P7000497027000000000000000041266" class="calibre13 pcalibre pcalibre1">from negative 16 to negative 8 containing (Unused)</p></li>
<li id="P7000497027000000000000000041267" data-uri="chapter03.xhtml#P7000497027000000000000000041267" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041268" data-uri="chapter03.xhtml#P7000497027000000000000000041268" class="calibre13 pcalibre pcalibre1">from negative 8 to 0 (frame pointer %rbp) containing i</p></li>
<li id="P7000497027000000000000000041269" data-uri="chapter03.xhtml#P7000497027000000000000000041269" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004126A" data-uri="chapter03.xhtml#P700049702700000000000000004126A" class="calibre13 pcalibre pcalibre1">from 0 to 8 containing Saved %rbp</p></li>
<li id="P700049702700000000000000004126B" data-uri="chapter03.xhtml#P700049702700000000000000004126B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004126C" data-uri="chapter03.xhtml#P700049702700000000000000004126C" class="calibre13 pcalibre pcalibre1">above 8 containing Return address</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P700049702700000000000000004126D" data-uri="chapter03.xhtml#P700049702700000000000000004126D" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003022"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.43(b)</span></a> shows portions of the code <span class="smallcaps pcalibre pcalibre1">gcc </span>generates for function <code id="P700049702700000000000000004126E" data-uri="chapter03.xhtml#P700049702700000000000000004126E" class="pcalibre1 calibre8 pcalibre">vframe</code>. At the beginning of the function, we see code that sets up the stack frame and allocates space for array <code id="P700049702700000000000000004126F" data-uri="chapter03.xhtml#P700049702700000000000000004126F" class="pcalibre1 calibre8 pcalibre">p</code>. The code starts by pushing the current value of <code id="P7000497027000000000000000041270" data-uri="chapter03.xhtml#P7000497027000000000000000041270" class="pcalibre1 calibre8 pcalibre">%rbp</code> onto the stack and setting <code id="P7000497027000000000000000041271" data-uri="chapter03.xhtml#P7000497027000000000000000041271" class="pcalibre1 calibre8 pcalibre">%rbp</code> to point to this stack position (lines 2–3). Next, it allocates 16 bytes on the stack, the first 8 of which are used to store local variable <code id="P7000497027000000000000000041272" data-uri="chapter03.xhtml#P7000497027000000000000000041272" class="pcalibre1 calibre8 pcalibre">i</code>, and the second 8 of which are unused. Then it allocates space for array <code id="P7000497027000000000000000041273" data-uri="chapter03.xhtml#P7000497027000000000000000041273" class="pcalibre1 calibre8 pcalibre">p</code> (lines 5–11). The details of how much space it allocates and where it positions <code id="P7000497027000000000000000041274" data-uri="chapter03.xhtml#P7000497027000000000000000041274" class="pcalibre1 calibre8 pcalibre">p</code> within this space are explored in Practice <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003055"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">3.49</span></a>. Suffice it to say that by the time the program reaches line 11, it has (1) allocated at least 8<var class="calibre5 pcalibre pcalibre1">n</var> bytes on the stack and (2) positioned array <code id="P7000497027000000000000000041275" data-uri="chapter03.xhtml#P7000497027000000000000000041275" class="pcalibre1 calibre8 pcalibre">p</code> within the allocated region such that at least 8<var class="calibre5 pcalibre pcalibre1">n</var> bytes are available for its use.</p>
<p id="P7000497027000000000000000041276" data-uri="chapter03.xhtml#P7000497027000000000000000041276" class="pcalibre1 pcalibre calibre2">The code for the initialization loop shows examples of how local variables <code id="P7000497027000000000000000041277" data-uri="chapter03.xhtml#P7000497027000000000000000041277" class="pcalibre1 calibre8 pcalibre">i</code> and <code id="P7000497027000000000000000041278" data-uri="chapter03.xhtml#P7000497027000000000000000041278" class="pcalibre1 calibre8 pcalibre">p</code> are referenced. Line 13 shows array element <code id="P7000497027000000000000000041279" data-uri="chapter03.xhtml#P7000497027000000000000000041279" class="pcalibre1 calibre8 pcalibre">p[i]</code> being set to <code id="P700049702700000000000000004127A" data-uri="chapter03.xhtml#P700049702700000000000000004127A" class="pcalibre1 calibre8 pcalibre">q</code>. This instruction uses the value in register <code id="P700049702700000000000000004127B" data-uri="chapter03.xhtml#P700049702700000000000000004127B" class="pcalibre1 calibre8 pcalibre">%rcx</code> as the address for the start of <code id="P700049702700000000000000004127C" data-uri="chapter03.xhtml#P700049702700000000000000004127C" class="pcalibre1 calibre8 pcalibre">p</code>. We can see instances where local variable <code id="P700049702700000000000000004127D" data-uri="chapter03.xhtml#P700049702700000000000000004127D" class="pcalibre1 calibre8 pcalibre">i</code> is updated (line 15) and read (line 17). The address of <code id="P700049702700000000000000004127E" data-uri="chapter03.xhtml#P700049702700000000000000004127E" class="pcalibre1 calibre8 pcalibre">i</code> is given by reference <code id="P700049702700000000000000004127F" data-uri="chapter03.xhtml#P700049702700000000000000004127F" class="pcalibre1 calibre8 pcalibre">-8(%rbp)</code>—that is, at offset -8 relative to the frame pointer.</p>
<p id="P7000497027000000000000000041280" data-uri="chapter03.xhtml#P7000497027000000000000000041280" class="pcalibre1 pcalibre calibre2">At the end of the function, the frame pointer is restored to its previous value using the <code id="P7000497027000000000000000041281" data-uri="chapter03.xhtml#P7000497027000000000000000041281" class="pcalibre1 calibre8 pcalibre">leave</code> instruction (line 20). This instruction takes no arguments. It is equivalent to executing the following two instructions:</p>
<pre id="P7000497027000000000000000041282" data-uri="chapter03.xhtml#P7000497027000000000000000041282" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041283" data-uri="chapter03.xhtml#P7000497027000000000000000041283" class="calibre10 pcalibre pcalibre1">
movq %rbp, %rsp		<i class="calibre5 pcalibre pcalibre1">Set stack pointer to beginning of frame</i>
popq %rbp		<i class="calibre5 pcalibre pcalibre1">Restore saved %rbp and set stack ptr to end of caller's frame</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041284" data-uri="chapter03.xhtml#P7000497027000000000000000041284">That is, the stack pointer is first set to the position of the saved value of <code id="P7000497027000000000000000041285" data-uri="chapter03.xhtml#P7000497027000000000000000041285" class="pcalibre1 calibre8 pcalibre">%rbp</code>, and then this value is popped from the stack into <code id="P7000497027000000000000000041286" data-uri="chapter03.xhtml#P7000497027000000000000000041286" class="pcalibre1 calibre8 pcalibre">%rbp</code>. This instruction combination has the effect of deallocating the entire stack frame.</p>
<p id="P7000497027000000000000000041287" data-uri="chapter03.xhtml#P7000497027000000000000000041287" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003052" title="293" data-uri="chapter03.xhtml#P7000497027000000000000000003052" epub:type="pagebreak"></span>In earlier versions of x86 code, the frame pointer was used with every function call. With x86-64 code, it is used only in cases where the stack frame may be of variable size, as is the case for function <code id="P7000497027000000000000000041288" data-uri="chapter03.xhtml#P7000497027000000000000000041288" class="pcalibre1 calibre8 pcalibre">vframe</code>. Historically, most compilers used frame pointers when generating IA32 code. Recent versions of <span class="smallcaps pcalibre pcalibre1">gcc </span>have dropped this convention. Observe that it is acceptable to mix code that uses frame pointers with code that does not, as long as all functions treat <code id="P7000497027000000000000000041289" data-uri="chapter03.xhtml#P7000497027000000000000000041289" class="pcalibre1 calibre8 pcalibre">%rbp</code> as a callee-saved register.</p>
<section id="P7000497027000000000000000003055" data-uri="chapter03.xhtml#P7000497027000000000000000003055" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004128A" data-uri="chapter03.xhtml#P700049702700000000000000004128A" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.49 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003968">347</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P700049702700000000000000004128B" data-uri="chapter03.xhtml#P700049702700000000000000004128B">
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004128C" data-uri="chapter03.xhtml#P700049702700000000000000004128C">
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000004128D" data-uri="chapter03.xhtml#P700049702700000000000000004128D"><p id="P700049702700000000000000004128E" data-uri="chapter03.xhtml#P700049702700000000000000004128E" class="pcalibre calibre3 pcalibre1">In this problem, we will explore the logic behind the code in lines 5–11 of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003022"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.43(b)</span></a>, where space is allocated for variable-size array p. As the annotations of the code indicate, let us let <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">1</sub> denote the address of the stack pointer after executing the <code id="P700049702700000000000000004128F" data-uri="chapter03.xhtml#P700049702700000000000000004128F" class="pcalibre1 calibre8 pcalibre">subq</code> instruction of line 4. This instruction allocates the space for local variable i. Let <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">2</sub> denote the value of the stack pointer after executing the <code id="P7000497027000000000000000041290" data-uri="chapter03.xhtml#P7000497027000000000000000041290" class="pcalibre1 calibre8 pcalibre">subq</code> instruction of line 7. This instruction allocates the storage for local array <code id="P7000497027000000000000000041291" data-uri="chapter03.xhtml#P7000497027000000000000000041291" class="pcalibre1 calibre8 pcalibre">p</code>. Finally, let <var class="calibre5 pcalibre pcalibre1">p</var> denote the value assigned to registers <code id="P7000497027000000000000000041292" data-uri="chapter03.xhtml#P7000497027000000000000000041292" class="pcalibre1 calibre8 pcalibre">%r8</code> and <code id="P7000497027000000000000000041293" data-uri="chapter03.xhtml#P7000497027000000000000000041293" class="pcalibre1 calibre8 pcalibre">%rcx</code> in the instructions of lines 10–11. Both of these registers are used to reference array <code id="P7000497027000000000000000041294" data-uri="chapter03.xhtml#P7000497027000000000000000041294" class="pcalibre1 calibre8 pcalibre">p</code>.</p>
<p id="P7000497027000000000000000041295" data-uri="chapter03.xhtml#P7000497027000000000000000041295" class="pcalibre calibre3 pcalibre1">The right-hand side of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000302E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">3.44</span></a> diagrams the positions of the locations indicated by <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">1</sub>, <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">2</sub>, and <var class="calibre5 pcalibre pcalibre1">p</var>. It also shows that there may be an offset of <var class="calibre5 pcalibre pcalibre1">e</var><sub class="pcalibre1 calibre47 pcalibre">2</sub> bytes between the values of <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">1</sub> and <var class="calibre5 pcalibre pcalibre1">p</var>. This space will not be used. There may also be an offset of <var class="calibre5 pcalibre pcalibre1">e</var><sub class="pcalibre1 calibre47 pcalibre">1</sub> bytes between the end of array <code id="P7000497027000000000000000041296" data-uri="chapter03.xhtml#P7000497027000000000000000041296" class="pcalibre1 calibre8 pcalibre">p</code> and the position indicated by <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">1</sub>.</p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P7000497027000000000000000041297" data-uri="chapter03.xhtml#P7000497027000000000000000041297">
<li id="P7000497027000000000000000041298" data-uri="chapter03.xhtml#P7000497027000000000000000041298" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041299" data-uri="chapter03.xhtml#P7000497027000000000000000041299" class="pcalibre calibre3 pcalibre1">Explain, in mathematical terms, the logic in the computation of <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">2</sub> on lines 5–7. <i class="calibre5 pcalibre pcalibre1">Hint:</i> Think about the bit-level representation of –16 and its effect in the <code id="P700049702700000000000000004129A" data-uri="chapter03.xhtml#P700049702700000000000000004129A" class="pcalibre1 calibre8 pcalibre">andq</code> instruction of line 6.</p></li>
<li id="P700049702700000000000000004129B" data-uri="chapter03.xhtml#P700049702700000000000000004129B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004129C" data-uri="chapter03.xhtml#P700049702700000000000000004129C" class="pcalibre calibre3 pcalibre1">Explain, in mathematical terms, the logic in the computation of <var class="calibre5 pcalibre pcalibre1">p</var> on lines 8–10. <i class="calibre5 pcalibre pcalibre1">Hint:</i> You may want to refer to the discussion on division by powers of 2 in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000000CB3_split_001.xhtml#P7000497027000000000000000000FF6"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">2.3.7</span></a>.</p></li>
<li id="P700049702700000000000000004129D" data-uri="chapter03.xhtml#P700049702700000000000000004129D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004129E" data-uri="chapter03.xhtml#P700049702700000000000000004129E" class="pcalibre calibre3 pcalibre1">For the following values of <var class="calibre5 pcalibre pcalibre1">n</var> and <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">1</sub>, trace the execution of the code to determine what the resulting values would be for <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">2</sub>, <var class="calibre5 pcalibre pcalibre1">p</var>, <var class="calibre5 pcalibre pcalibre1">e</var><sub class="pcalibre1 calibre47 pcalibre">1</sub>, and <var class="calibre5 pcalibre pcalibre1">e</var><sub class="pcalibre1 calibre47 pcalibre">2</sub>.</p>
<table id="P700049702700000000000000004129F" data-uri="chapter03.xhtml#P700049702700000000000000004129F" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P70004970270000000000000000412A0" data-uri="chapter03.xhtml#P70004970270000000000000000412A0" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">n</var></th>
<th id="P70004970270000000000000000412A1" data-uri="chapter03.xhtml#P70004970270000000000000000412A1" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">s</var><sub class="calibre59 pcalibre pcalibre1">1</sub></th>
<th id="P70004970270000000000000000412A2" data-uri="chapter03.xhtml#P70004970270000000000000000412A2" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">s</var><sub class="calibre59 pcalibre pcalibre1">2</sub></th>
<th id="P70004970270000000000000000412A3" data-uri="chapter03.xhtml#P70004970270000000000000000412A3" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">p</var></th>
<th id="P70004970270000000000000000412A4" data-uri="chapter03.xhtml#P70004970270000000000000000412A4" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">e</var><sub class="calibre59 pcalibre pcalibre1">1</sub></th>
<th id="P70004970270000000000000000412A5" data-uri="chapter03.xhtml#P70004970270000000000000000412A5" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">e</var><sub class="calibre59 pcalibre pcalibre1">2</sub></th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P70004970270000000000000000412A6" data-uri="chapter03.xhtml#P70004970270000000000000000412A6" class="calibre20 pcalibre pcalibre1">5</td>
<td id="P70004970270000000000000000412A7" data-uri="chapter03.xhtml#P70004970270000000000000000412A7" class="calibre20 pcalibre pcalibre1">2,065</td>
<td id="P70004970270000000000000000412A8" data-uri="chapter03.xhtml#P70004970270000000000000000412A8" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P70004970270000000000000000412A9" data-uri="chapter03.xhtml#P70004970270000000000000000412A9" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P70004970270000000000000000412AA" data-uri="chapter03.xhtml#P70004970270000000000000000412AA" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P70004970270000000000000000412AB" data-uri="chapter03.xhtml#P70004970270000000000000000412AB" class="calibre20 pcalibre pcalibre1">__________</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P70004970270000000000000000412AC" data-uri="chapter03.xhtml#P70004970270000000000000000412AC" class="calibre20 pcalibre pcalibre1">6</td>
<td id="P70004970270000000000000000412AD" data-uri="chapter03.xhtml#P70004970270000000000000000412AD" class="calibre20 pcalibre pcalibre1">2,064</td>
<td id="P70004970270000000000000000412AE" data-uri="chapter03.xhtml#P70004970270000000000000000412AE" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P70004970270000000000000000412AF" data-uri="chapter03.xhtml#P70004970270000000000000000412AF" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P70004970270000000000000000412B0" data-uri="chapter03.xhtml#P70004970270000000000000000412B0" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P70004970270000000000000000412B1" data-uri="chapter03.xhtml#P70004970270000000000000000412B1" class="calibre20 pcalibre pcalibre1">__________</td>
</tr>
</tbody>
</table></li>
<li id="P70004970270000000000000000412B2" data-uri="chapter03.xhtml#P70004970270000000000000000412B2" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000412B3" data-uri="chapter03.xhtml#P70004970270000000000000000412B3" class="pcalibre calibre3 pcalibre1">What alignment properties does this code guarantee for the values of <var class="calibre5 pcalibre pcalibre1">s</var><sub class="pcalibre1 calibre47 pcalibre">2</sub> and <var class="calibre5 pcalibre pcalibre1">p</var>?</p></li>
</ol></div></li></ol>
</section>
</section>
</section></body></html>
