<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>26.7  Performance Enhancement</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part467.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part469.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark567">26.7  </a><span style=" color: #00AEEF;">Performance Enhancement</span><a name="bookmark597">&zwnj;</a></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">At a high level, a blockchain system may be viewed as having three major components:</p><p class="s63" style="padding-top: 8pt;padding-left: 113pt;text-indent: -16pt;text-align: justify;">1. <span style=" color: #231F20;">Consensus management: </span><span class="p">Proof-of-work, proof-of-stake, Byzantine consensus, or some hybrid approach. Transaction processing performance is dominated by the performance of consensus management.</span></p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;"><span class="s63">2. </span><b>State-access management: </b>Access methods to retrieve current blockchain state, ranging from a simple index to locate transactions from a speciﬁc account-id or user <span class="s44">ID</span>, to key-value store systems, to a full <span class="s44">SQL </span>interface.</p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">3. <span style=" color: #231F20;">Smart contract execution: </span><span class="p">The environment that runs the (possibly compiled) smart-contract code, typically in a virtualized environment for security and safety.</span></p><p style="padding-top: 8pt;padding-left: 88pt;text-indent: 17pt;text-align: right;">The rate of transaction processing, referred to as throughput, in blockchain systems is signiﬁcantly lower than in traditional database systems. Traditional database systems are able to process simple funds-transfer transactions at peak rates on the order of tens of thousands of transactions per second. Blockchain systems’ rates are less; Bitcoin processes less than 10 per second, and Ethereum, at present, only slightly more than 10 per second.<span class="s76">8</span> The reason is that techniques such as proof-of-work limit the number of blocks that can be added to the chain per unit time, with Bitcoin targeting one block every 10 minutes. A block may contain multiple transactions, so the transaction processing rate is signiﬁcantly more than 1 in 10 minutes, but is nevertheless limited. In most applications, transaction throughput is not the only performance metric. A second and often more important metric is transaction latency, or response time. Here, the distributed consensus required by blockchain systems presents a serious problem. As an example, we consider Bitcoin’s design in which the mining rate is maintained close to 1 block every 10 minutes. That alone creates signiﬁcant latency, but added to that is the need to wait for several subsequent blocks to be mined so as to reduce the probability that a fork will cause the transaction’s block to be orphaned. Using the usual recommendation of waiting for 6 blocks, we get a true latency of 1 hour. Such response times are unacceptable for interactive, real-time transaction processing. In contrast, traditional database systems commit individual transactions and can easily</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">achieve millisecond response time.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">These transaction processing performance issues are primarily issues due to con- sensus overhead with public blockchains. Permissioned blockchains are able to use faster message-based Byzantine consensus algorithms, but other performance issues still remain, and are continuing to be addressed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_3471.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">8<span class="s78">At the time of publication, Ethereum’s architects are contemplating advocating a fork to allow faster, lower-overhead mining.</span></p><p class="s66" style="padding-top: 3pt;padding-left: 328pt;text-indent: 0pt;text-align: left;">26.7 <span style=" color: #00AEEF;">Performance Enhancement  </span><span class="s164">1275</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">26.7.1 Enhancing Consensus Performance</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">There are two primary approaches to improve the performance of blockchain consen- sus:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span style=" color: #231F20;">Sharding: </span><span class="p">distributing the task of mining new blocks to enable parallelism among nodes.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span style=" color: #231F20;">Oﬀ-chain transaction processing: </span><span class="p">Trusted systems that process transactions inter- nally without putting them on the blockchain. These transactions are grouped into a single transaction that is then placed on the blockchain. This grouping may occur with some agreed-upon periodicity or occur only at the termination of the agreement.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Sharding is the partitioning of the accounts in a blockchain into shards that are mined separately in parallel. In the case where a transaction spans shards, a separate transaction is run on each shard with a special system-internal cross-shard transaction recorded to ensure that both parts of the given transaction are committed. The over- head of the cross-shard transaction is low. There are some risks resulting from the fact that splitting the mining nodes up by shard results in smaller sets of miners that are then more vulnerable to attack since the cost to attack a smaller set of miners is less. However, there are ways to mitigate this risk.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Oﬀ-chain transactions require deployment of a separate system to manage those transactions. The best known of these is the Lightning network, which not only speeds blockchain transactions via oﬀ-chain processing but also can process certain cross-chain transactions. Lightning promises transaction throughput and latency at traditional database-system rates, but provides this at the cost of some degree of anonymity and immutability (i.e., transactions that commit oﬀ-chain, but are rejected at the blockchain). By increasing the frequency of transaction conﬁrmations to the blockchain, one can decrease the loss of immutability at the price of reduced perfor- mance improvement.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">26.7.2 Enhancing Query Performance</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Some blockchain systems oﬀer little more than an index on user or account identiﬁers to facilitate looking up unspent transactions. This suﬃces for a simple funds-transfer transaction. Complex smart contracts, however, may need to execute general-purpose queries against the stored current state of the blockchain. Such queries may perform the equivalent of join queries, whose optimization we studied at length in Chapter</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">16. However, the structure of blockchain systems, in which state-access management may be separate from the execution engine may limit the use of database-style query optimization. Furthermore, the data structures used for state representation, such as the Merkle-Patricia tree structure we saw in Section 26.5.2, may limit the choice of algorithms to implement join-style queries.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;"><a name="bookmark568">Blockchain systems built on a traditional or a </a><span class="s44">NoSQL </span>database keep state informa- tion within that database and allow smart contracts to run higher-level database-style queries against that state. Those advantages come at the cost of using a database-storage format that may lack the rigorous cryptographic protection of a true blockchain. A good compromise is for the database to be hosted by a trusted provider with updates going not only to the database but also to the blockchain, thus enabling any user who so wishes to validate the database against the secure blockchain.<a name="bookmark598">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">26.7.3 Fault-Tolerance and Scalability</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Performance in the presence of failures is a critical aspect of a blockchain system. In traditional database systems, this is measured by the performance of the recovery manager and, as we saw in Section 19.9, the <span class="s44">ARIES </span>recovery algorithm is designed to optimize recovery time. A blockchain system, in contrast, uses a consensus mechanism and a replication strategy designed for continuous operation during failures and mali- cious attacks, though perhaps with lower performance during such periods. Therefore, besides measuring throughput and latency, one must also measure how these perfor- mance statistics change in times of failure or attack.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Scalability is a performance concern in any distributed system as we saw in Chap- ter 20. The architectural diﬀerences between blockchain systems and parallel or dis- tributed database systems introduce challenges in both the measure of scaleup and its optimization. We illustrate the diﬀerences by considering the relative scalability of <span class="s44">2PC </span>and Byzantine consensus. In <span class="s44">2PC</span>, a transaction accessing a ﬁxed number of nodes, say ﬁve, needs only the agreement of these ﬁve nodes, regardless of the number of nodes in the system. If we scale the system up to more nodes, that transaction still needs only those ﬁve nodes to agree (unless the scaling added a replica site). Under Byzantine con- sensus, every transaction needs the agreement of a majority of the non-failed nodes, and so, the number of nodes that must agree not only starts much larger but also grows faster as the network scales.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The Further Reading section at the end of the chapter provides references that deal with the emerging issue of blockchain performance measurement and optimization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part467.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part469.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
