<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos167044" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_32"><span class="bold">3. Process Management</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos167207"> </div>
<p class="calibre_2">This chapter introduces the concept of the <em class="calibre4">process</em>, one of the fundamental abstractions in Unix operating systems. It defines the process, as well as related concepts such as threads, and then discusses how the Linux kernel manages each process: how they are enumerated within the kernel, how they are created, and how they ultimately die. Because running user applications is the reason we have operating systems, the process management is a crucial part of any operating system kernel, including Linux.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos167822"> </div>
<h3 class="calibre_21"><span class="bold">The Process</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">A <em class="calibre4">process</em> is a program (object code stored on some media) in the midst of execution. Processes are, however, more than just the executing program code (often called the <em class="calibre4">text section</em> in Unix). They also include a set of resources such as open files and pending signals, internal kernel data, processor state, a memory address space with one or more memory mappings, one or more <em class="calibre4">threads of execution</em>, and a <em class="calibre4">data section</em> containing global variables. Processes, in effect, are the living result of running program code. The kernel needs to manage all these details efficiently and transparently.</p><div class="calibre_3"> </div>
<p class="calibre_2">Threads of execution, often shortened to <em class="calibre4">threads</em>, are the objects of activity within the process. Each thread includes a unique program counter, process stack, and set of processor registers. The kernel schedules individual threads, not processes. In traditional Unix systems, each process consists of one thread. In modern systems, however, multithreaded programs—those that consist of more than one thread—are common. As you will see later, Linux has a unique implementation of threads: It does not differentiate between threads and processes. To Linux, a thread is just a special kind of process.</p><div class="calibre_3"> </div>
<p class="calibre_2">On modern operating systems, processes provide two virtualizations: a virtualized processor and virtual memory. The virtual processor gives the process the illusion that it alone monopolizes the system, despite possibly sharing the processor among hundreds of other processes. <a href="index_split_013.html#filepos223287">Chapter 4</a>, “Process Scheduling,” discusses this virtualization. Virtual memory lets the process allocate and manage memory as if it alone owned all the memory in the system. Virtual memory is covered in <a href="index_split_021.html#filepos778361">Chapter 12</a>, “Memory Management.” <a id="filepos169876"></a>Interestingly, note that threads share the virtual memory abstraction, whereas each receives its own virtualized processor.</p><div class="calibre_3"> </div>
<p class="calibre_2">A program itself is not a process; a process is an <em class="calibre4">active</em> program and related resources. Indeed, two or more processes can exist that are executing the <em class="calibre4">same</em> program. In fact, two or more processes can exist that share various resources, such as open files or an address space.</p><div class="calibre_3"> </div>
<p class="calibre_2">A process begins its life when, not surprisingly, it is created. In Linux, this occurs by means of the <code class="calibre6"><span class="calibre7">fork()</span></code> system call, which creates a new process by duplicating an existing one. The process that calls <code class="calibre6"><span class="calibre7">fork()</span></code> is the <em class="calibre4">parent</em>, whereas the new process is the <em class="calibre4">child</em>. The parent resumes execution and the child starts execution at the same place: where the call to <code class="calibre6"><span class="calibre7">fork()</span></code> returns. The <code class="calibre6"><span class="calibre7">fork()</span></code> system call returns from the kernel twice: once in the parent process and again in the newborn child.</p><div class="calibre_3"> </div>
<p class="calibre_2">Often, immediately after a fork it is desirable to execute a new, different program. The <code class="calibre6"><span class="calibre7">exec()</span></code> family of function calls creates a new address space and loads a new program into it. In contemporary Linux kernels, <code class="calibre6"><span class="calibre7">fork()</span></code> is actually implemented via the <code class="calibre6"><span class="calibre7">clone()</span></code> system call, which is discussed in a following section.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, a program exits via the <code class="calibre6"><span class="calibre7">exit()</span></code> system call. This function terminates the process and frees all its resources. A parent process can inquire about the status of a terminated child via the <code class="calibre6"><span class="calibre7">wait4()</span></code><sup class="calibre8"><a id="filepos171843" href="#filepos172248">1</a></sup> system call, which enables a process to wait for the termination of a specific process. When a process exits, it is placed into a special zombie state that represents terminated processes until the parent calls <code class="calibre6"><span class="calibre7">wait()</span></code> or <code class="calibre6"><span class="calibre7">waitpid()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos172248" href="#filepos171843">1</a></sup>
<em class="calibre4">The kernel implements the <code class="calibre6"><span class="calibre7">wait4()</span></code> system call. Linux systems, via the C library, typically provide the <code class="calibre6"><span class="calibre7">wait()</span></code>, <code class="calibre6"><span class="calibre7">waitpid()</span></code>, <code class="calibre6"><span class="calibre7">wait3()</span></code>, and <code class="calibre6"><span class="calibre7">wait4()</span></code> functions. All these functions return status about a terminated process, albeit with slightly different semantics.</em></p><div class="calibre_3"> </div>
<div class="calibre_30"><blockquote class="calibre10">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<h3 class="calibre_21"><span class="bold">Note</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Another name for a process is a <em class="calibre4">task</em>. The Linux kernel internally refers to processes as tasks. In this book, I use the terms interchangeably, although when I say <em class="calibre4">task</em> I am generally referring to a process from the kernel’s point of view.</p><div class="calibre_3"> </div>
</blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos173284"> </div>
<h3 class="calibre_21"><span class="bold">Process Descriptor and the Task Structure</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The kernel stores the list of processes in a circular doubly linked list called the <em class="calibre4">task list</em>.<sup class="calibre8"><a id="filepos173536" href="#filepos173925">2</a></sup> Each element in the task list is a <em class="calibre4">process descriptor</em> of the type <code class="calibre6"><span class="calibre7">struct task_struct</span></code>, which is defined in <code class="calibre6"><span class="calibre7">&lt;linux/sched.h&gt;</span></code>. The process descriptor contains all the information about a specific process.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos173925" href="#filepos173536">2</a></sup>
<em class="calibre4">Some texts on operating system design call this list the</em> task array. <em class="calibre4">Because the Linux implementation is a linked list and not a static array, in Linux it is called the</em> task list.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">task_struct</span></code> is a relatively large data structure, at around 1.7 kilobytes on a 32-bit machine. This size, however, is quite small considering that the structure contains all the information that the kernel has and needs about a process. The process descriptor contains <a id="filepos174533"></a>the data that describes the executing program—open files, the process’s address space, pending signals, the process’s state, and much more (see <a href="#filepos174785">Figure 3.1</a>).</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos174785"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 3.1. The process descriptor and task list.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00006.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos175084"> </div>
<h4 class="calibre_27"><span class="calibre3">Allocating the Process Descriptor</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">task_struct</span></code> structure is allocated via the <em class="calibre4">slab allocator</em> to provide object reuse and cache coloring (see <a href="index_split_021.html#filepos778361">Chapter 12</a>). Prior to the 2.6 kernel series, <code class="calibre6"><span class="calibre7">struct task_struct</span></code> was stored at the end of the kernel stack of each process. This allowed architectures with few registers, such as x86, to calculate the location of the process descriptor via the <em class="calibre4">stack pointer</em> without using an extra register to store the location. With the process descriptor now dynamically created via the slab allocator, a new structure, <code class="calibre6"><span class="calibre7">struct thread_info</span></code>, was created that again lives at the bottom of the stack (for stacks that grow down) and at the top of the stack (for stacks that grow up).<sup class="calibre8"><a id="filepos176047" href="#filepos176193">3</a></sup> See <a href="#filepos176534">Figure 3.2</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos176193" href="#filepos176047">3</a></sup>
<em class="calibre4">Register-impaired architectures were not the only reason for creating <code class="calibre6"><span class="calibre7">struct thread_info</span></code>. The new structure also makes it rather easy to calculate offsets of its values for use in assembly code.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos176534"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 3.2. The process descriptor and kernel stack.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00007.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">thread_info</span></code> structure is defined on x86 in <code class="calibre6"><span class="calibre7">&lt;asm/thread_info.h&gt;</span></code> as</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00008.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos177120"></a>Each task’s <code class="calibre6"><span class="calibre7">thread_info</span></code> structure is allocated at the end of its stack. The <code class="calibre6"><span class="calibre7">task</span></code> element of the structure is a pointer to the task’s actual <code class="calibre6"><span class="calibre7">task_struct</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos177440"> </div>
<h4 class="calibre_27"><span class="calibre3">Storing the Process Descriptor</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The system identifies processes by a unique <em class="calibre4">process identification</em> value or <em class="calibre4">PID</em>. The PID is a numerical value represented by the opaque type<sup class="calibre8"><a id="filepos177735" href="#filepos178379">4</a></sup>
<code class="calibre6"><span class="calibre7">pid_t</span></code>, which is typically an <code class="calibre6"><span class="calibre7">int</span></code>. Because of backward compatibility with earlier Unix and Linux versions, however, the default maximum value is only 32,768 (that of a <code class="calibre6"><span class="calibre7">short int</span></code>), although the value optionally can be increased as high as four million (this is controlled in <code class="calibre6"><span class="calibre7">&lt;linux/threads.h&gt;</span></code>. The kernel stores this value as <code class="calibre6"><span class="calibre7">pid</span></code> inside each process descriptor.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos178379" href="#filepos177735">4</a></sup>
<em class="calibre4">An opaque type is a data type whose physical representation is unknown or irrelevant.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">This maximum value is important because it is essentially the maximum number of processes that may exist concurrently on the system. Although 32,768 might be sufficient for a desktop system, large servers may require many more processes. Moreover, the lower the value, the sooner the values will wrap around, destroying the useful notion that higher <a id="filepos178926"></a>values indicate later-run processes than lower values. If the system is willing to break compatibility with old applications, the administrator may increase the maximum value via <code class="calibre6"><span class="calibre7">/proc/sys/kernel/pid_max</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Inside the kernel, tasks are typically referenced directly by a pointer to their <code class="calibre6"><span class="calibre7">task_struct</span></code> structure. In fact, most kernel code that deals with processes works directly with <code class="calibre6"><span class="calibre7">struct task_struct</span></code>. Consequently, it is useful to be able to quickly look up the process descriptor of the currently executing task, which is done via the <code class="calibre6"><span class="calibre7">current</span></code> macro. This macro must be independently implemented by each architecture. Some architectures save a pointer to the <code class="calibre6"><span class="calibre7">task_struct</span></code> structure of the currently running process in a register, enabling for efficient access. Other architectures, such as x86 (which has few registers to waste), make use of the fact that <code class="calibre6"><span class="calibre7">struct thread_info</span></code> is stored on the kernel stack to calculate the location of <code class="calibre6"><span class="calibre7">thread_info</span></code> and subsequently the <code class="calibre6"><span class="calibre7">task_struct</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">On x86, <code class="calibre6"><span class="calibre7">current</span></code> is calculated by masking out the 13 least-significant bits of the stack pointer to obtain the <code class="calibre6"><span class="calibre7">thread_info</span></code> structure. This is done by the <code class="calibre6"><span class="calibre7">current_thread_info()</span></code> function. The assembly is shown here:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">movl $-8192, %eax<br class="calibre1"/>andl %esp, %eax</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This assumes that the stack size is 8KB. When 4KB stacks are enabled, 4096 is used in lieu of 8192.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, <code class="calibre6"><span class="calibre7">current</span></code> dereferences the <code class="calibre6"><span class="calibre7">task</span></code> member of <code class="calibre6"><span class="calibre7">thread_info</span></code> to return the <code class="calibre6"><span class="calibre7">task_struct</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">current_thread_info()-&gt;task;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Contrast this approach with that taken by PowerPC (IBM’s modern RISC-based microprocessor), which stores the current <code class="calibre6"><span class="calibre7">task_struct</span></code> in a register. Thus, <code class="calibre6"><span class="calibre7">current</span></code> on PPC merely returns the value stored in the register <code class="calibre6"><span class="calibre7">r2</span></code>. PPC can take this approach because, unlike x86, it has plenty of registers. Because accessing the process descriptor is a common and important job, the PPC kernel developers deem using a register worthy for the task.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos181950"> </div>
<h4 class="calibre_27"><span class="calibre3">Process State</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">state</span></code> field of the process descriptor describes the current condition of the process (see <a href="#filepos185265">Figure 3.3</a>). Each process on the system is in exactly one of five different states. This value is represented by one of five flags:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">TASK_RUNNING</span></code>—The process is runnable; it is either currently running or on a runqueue waiting to run (runqueues are discussed in <a href="index_split_013.html#filepos223287">Chapter 4</a>). This is the only possible state for a process executing in user-space; it can also apply to a process in kernel-space that is actively running.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">TASK_INTERRUPTIBLE</span></code>—The process is sleeping (that is, it is blocked), waiting for some condition to exist. When this condition exists, the kernel sets the process’s state to <code class="calibre6"><span class="calibre7">TASK_RUNNING</span></code>. The process also awakes prematurely and becomes runnable if it receives a signal.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code id="filepos183299" class="calibre6"><span class="calibre7">TASK_UNINTERRUPTIBLE</span></code>—This state is identical to <code class="calibre6"><span class="calibre7">TASK_INTERRUPTIBLE</span></code> except that it does <em class="calibre4">not</em> wake up and become runnable if it receives a signal. This is used in situations where the process must wait without interruption or when the event is expected to occur quite quickly. Because the task does not respond to signals in this state, <code class="calibre6"><span class="calibre7">TASK_UNINTERRUPTIBLE</span></code> is less often used than <code class="calibre6"><span class="calibre7">TASK_INTERRUPTIBLE</span></code>.<sup class="calibre8"><a id="filepos183857" href="#filepos183973">5</a></sup></p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos183973" href="#filepos183857">5</a></sup>
<em class="calibre4">This is why you have those dreaded unkillable processes with state <code class="calibre6"><span class="calibre7">D</span></code> in <code class="calibre6"><span class="calibre7">ps(1)</span></code>. Because the task will not respond to signals, you cannot send it a <code class="calibre6"><span class="calibre7">SIGKILL</span></code> signal. Further, even if you could terminate the task, it would not be wise because the task is supposedly in the middle of an important operation and may hold a semaphore.</em></p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">__TASK_TRACED</span></code>—The process is being <em class="calibre4">traced</em> by another process, such as a debugger, via <em class="calibre4">ptrace</em>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">__TASK_STOPPED</span></code>—Process execution has stopped; the task is not running nor is it eligible to run. This occurs if the task receives the <code class="calibre6"><span class="calibre7">SIGSTOP</span></code>, <code class="calibre6"><span class="calibre7">SIGTSTP</span></code>, <code class="calibre6"><span class="calibre7">SIGTTIN</span></code>, or <code class="calibre6"><span class="calibre7">SIGTTOU</span></code> signal or if it receives <em class="calibre4">any</em> signal while it is being debugged.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos185265"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 3.3. Flow chart of process states.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00009.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos185556"> </div>
<h4 class="calibre_27"><span class="calibre3">Manipulating the Current Process State</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos185696"> </div>
<p class="calibre_2">Kernel code often needs to change a process’s state. The preferred mechanism is using</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">set_task_state(task, state);        /* set task 'task' to state 'state' */</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function sets the given task to the given state. If applicable, it also provides a memory barrier to force ordering on other processors. (This is only needed on SMP systems.) Otherwise, it is equivalent to</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">task-&gt;state = state;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The method <code class="calibre6"><span class="calibre7">set_current_state(state)</span></code> is synonymous to <code class="calibre6"><span class="calibre7">set_task_state(current, state)</span></code>. See <code class="calibre6"><span class="calibre7">&lt;linux/sched.h&gt;</span></code> for the implementation of these and related functions.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos186814"> </div>
<h4 class="calibre_27"><span class="calibre3">Process Context</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">One of the most important parts of a process is the executing program code. This code is read in from an <em class="calibre4">executable file</em> and executed within the program’s address space. Normal program execution occurs in <em class="calibre4">user-space</em>. When a program executes a system call (see <a href="index_split_014.html#filepos301917">Chapter 5</a>, “System Calls”) or triggers an exception, it enters <em class="calibre4">kernel-space</em>. At this point, the kernel is said to be “executing on behalf of the process” and is in <em class="calibre4">process context</em>. When in process context, the <code class="calibre6"><span class="calibre7">current</span></code> macro is valid.<sup class="calibre8"><a id="filepos187557" href="#filepos187877">6</a></sup> Upon exiting the kernel, the process resumes execution in user-space, unless a higher-priority process has become runnable in the interim, in which case the scheduler is invoked to select the higher priority process.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos187877" href="#filepos187557">6</a></sup>
<em class="calibre4">Other than process context there is interrupt context, which we discuss in <a href="index_split_016.html#filepos426370">Chapter 7</a>, “Interrupts and Interrupt Handlers.” In interrupt context, the system is not running on behalf of a process but is executing an interrupt handler. No process is tied to interrupt handlers.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">System calls and exception handlers are well-defined interfaces into the kernel. A process can begin executing in kernel-space only through one of these interfaces—<em class="calibre4">all</em> access to the kernel is through these interfaces.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos188585"> </div>
<h4 class="calibre_27"><span class="calibre3">The Process Family Tree</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">A distinct hierarchy exists between processes in Unix systems, and Linux is no exception. All processes are descendants of the <code class="calibre6"><span class="calibre7">init</span></code> process, whose PID is one. The kernel starts <code class="calibre6"><span class="calibre7">init</span></code> in the last step of the boot process. The <code class="calibre6"><span class="calibre7">init</span></code> process, in turn, reads the system <em class="calibre4">initscripts</em> and executes more programs, eventually completing the boot process.</p><div class="calibre_3"> </div>
<p class="calibre_2">Every process on the system has exactly one parent. Likewise, every process has zero or more children. Processes that are all direct children of the same parent are called <em class="calibre4">siblings</em>. The relationship between processes is stored in the process descriptor. Each <code class="calibre6"><span class="calibre7">task_struct</span></code> has a pointer to the parent’s <code class="calibre6"><span class="calibre7">task_struct</span></code>, named <code class="calibre6"><span class="calibre7">parent</span></code>, and a list of children, named <code class="calibre6"><span class="calibre7">children</span></code>. Consequently, given the current process, it is possible to obtain the process descriptor of its parent with the following code:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct task_struct *my_parent = current-&gt;parent;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Similarly, it is possible to iterate over a process’s children with</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00010.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">init</span></code> task’s process descriptor is statically allocated as <code class="calibre6"><span class="calibre7">init_task</span></code>. A good example of the relationship between all processes is the fact that this code will always succeed:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00011.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">In fact, you can follow the process hierarchy from any one process in the system to <em class="calibre4">any</em> other. Oftentimes, however, it is desirable simply to iterate over <em class="calibre4">all</em> processes in the system. This is easy because the task list is a circular, doubly linked list. To obtain the next task in the list, given any valid task, use</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_entry(task-&gt;tasks.next, struct task_struct, tasks)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Obtaining the previous task works the same way:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">list_entry(task-&gt;tasks.prev, struct task_struct, tasks)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">These two routines are provided by the macros <code class="calibre6"><span class="calibre7">next_task(task)</span></code> and <code class="calibre6"><span class="calibre7">prev_task(task)</span></code>, respectively. Finally, the macro <code class="calibre6"><span class="calibre7">for_each_process(task)</span></code> is provided, which iterates over the entire task list. On each iteration, <code class="calibre6"><span class="calibre7">task</span></code> points to the next task in the list:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00012.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<div class="calibre_30"><blockquote class="calibre10">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<h3 class="calibre_21"><span class="bold">Caution</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">It is expensive to iterate over every task in a system with many processes; code should have good reason (and no alternative) before doing so.</p><div class="calibre_3"> </div>
</blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos192390"> </div>
<h3 class="calibre_21"><span class="bold">Process Creation</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos192509"> </div>
<p class="calibre_2">Process creation in Unix is unique. Most operating systems implement a <em class="calibre4">spawn</em> mechanism to create a new process in a new address space, read in an executable, and begin executing it. Unix takes the unusual approach of separating these steps into two distinct functions: <code class="calibre6"><span class="calibre7">fork()</span></code> and <code class="calibre6"><span class="calibre7">exec()</span></code>.<sup class="calibre8"><a id="filepos192931" href="#filepos193683">7</a></sup> The first, <code class="calibre6"><span class="calibre7">fork()</span></code>, creates a child process that is a copy of the current task. It differs from the parent only in its PID (which is unique), its PPID (parent’s PID, which is set to the original process), and certain resources and statistics, such as pending signals, which are not inherited. The second function, <code class="calibre6"><span class="calibre7">exec()</span></code>, loads a new executable into the address space and begins executing it. The combination of <code class="calibre6"><span class="calibre7">fork()</span></code> followed by <code class="calibre6"><span class="calibre7">exec()</span></code> is similar to the single function most operating systems provide.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos193683" href="#filepos192931">7</a></sup>
<em class="calibre4">By <code class="calibre6"><span class="calibre7">exec()</span></code> I mean any member of the <code class="calibre6"><span class="calibre7">exec()</span></code> family of functions. The kernel implements the <code class="calibre6"><span class="calibre7">execve()</span></code> system call on top of which <code class="calibre6"><span class="calibre7">execlp()</span></code>, <code class="calibre6"><span class="calibre7">execle()</span></code>, <code class="calibre6"><span class="calibre7">execv()</span></code>, and <code class="calibre6"><span class="calibre7">execvp()</span></code> are implemented.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos194224"> </div>
<h4 class="calibre_27"><span class="calibre3">Copy-on-Write</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Traditionally, upon <code class="calibre6"><span class="calibre7">fork()</span></code>, all resources owned by the parent are duplicated and the copy is given to the child. This approach is naive and inefficient in that it copies much data that might otherwise be shared. Worse still, if the new process were to immediately execute a new image, all that copying would go to waste. In Linux, <code class="calibre6"><span class="calibre7">fork()</span></code> is implemented through the use of <em class="calibre4">copy-on-write</em> pages. Copy-on-write (or <em class="calibre4">COW</em>) is a technique to delay or altogether prevent copying of the data. Rather than duplicate the process address space, the parent and the child can share a single copy.</p><div class="calibre_3"> </div>
<p class="calibre_2">The data, however, is marked in such a way that if it is written to, a duplicate is made and each process receives a unique copy. Consequently, the duplication of resources occurs only when they are written; until then, they are shared read-only. This technique delays the copying of each page in the address space until it is actually written to. In the case that the pages are never written—for example, if <code class="calibre6"><span class="calibre7">exec()</span></code> is called immediately after <code class="calibre6"><span class="calibre7">fork()</span></code>—they never need to be copied.</p><div class="calibre_3"> </div>
<p class="calibre_2">The only overhead incurred by <code class="calibre6"><span class="calibre7">fork()</span></code> is the duplication of the parent’s page tables and the creation of a unique process descriptor for the child. In the common case that a process executes a new executable image immediately after forking, this optimization prevents the wasted copying of large amounts of data (with the address space, easily tens of megabytes). This is an important optimization because the Unix philosophy encourages quick process execution.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos196224"> </div>
<h4 class="calibre_27"><span class="calibre3">Forking</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos196333"> </div>
<p class="calibre_2">Linux implements <code class="calibre6"><span class="calibre7">fork()</span></code> via the <code class="calibre6"><span class="calibre7">clone()</span></code> system call. This call takes a series of flags that specify which resources, if any, the parent and child process should share. (See “<a href="#filepos203880">The Linux Implementation of Threads</a>” section later in this chapter for more about the flags.) The <code class="calibre6"><span class="calibre7">fork()</span></code>, <code class="calibre6"><span class="calibre7">vfork()</span></code>, and <code class="calibre6"><span class="calibre7">__clone()</span></code> library calls all invoke the <code class="calibre6"><span class="calibre7">clone()</span></code> system call with the requisite flags. The <code class="calibre6"><span class="calibre7">clone()</span></code> system call, in turn, calls <code class="calibre6"><span class="calibre7">do_fork()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The bulk of the work in forking is handled by <code class="calibre6"><span class="calibre7">do_fork()</span></code>, which is defined in <code class="calibre6"><span class="calibre7">kernel/fork.c</span></code>. This function calls <code class="calibre6"><span class="calibre7">copy_process()</span></code> and then starts the process running. The interesting work is done by <code class="calibre6"><span class="calibre7">copy_process()</span></code>:</p><div class="calibre_3"> </div>
<ol class="calibre13">
<li value="1" class="calibre14">It calls <code class="calibre6"><span class="calibre7">dup_task_struct()</span></code>, which creates a new kernel stack, <code class="calibre6"><span class="calibre7">thread_info</span></code> structure, and <code class="calibre6"><span class="calibre7">task_struct</span></code> for the new process. The new values are identical to those of the current task. At this point, the child and parent process descriptors are identical.</li>
<li value="2" class="calibre14">It then checks that the new child will not exceed the resource limits on the number of processes for the current user.</li>
<li value="3" class="calibre14">The child needs to differentiate itself from its parent. Various members of the process descriptor are cleared or set to initial values. Members of the process descriptor not inherited are primarily statistically information. The bulk of the values in <code class="calibre6"><span class="calibre7">task_struct</span></code> remain unchanged.</li>
<li value="4" class="calibre14">The child’s state is set to <code class="calibre6"><span class="calibre7">TASK_UNINTERRUPTIBLE</span></code> to ensure that it does not yet run.</li>
<li value="5" class="calibre14"><code class="calibre6"><span class="calibre7">copy_process()</span></code> calls <code class="calibre6"><span class="calibre7">copy_flags()</span></code> to update the <code class="calibre6"><span class="calibre7">flags</span></code> member of the <code class="calibre6"><span class="calibre7">task_struct</span></code>. The <code class="calibre6"><span class="calibre7">PF_SUPERPRIV</span></code> flag, which denotes whether a task used superuser privileges, is cleared. The <code class="calibre6"><span class="calibre7">PF_FORKNOEXEC</span></code> flag, which denotes a process that has not called <code class="calibre6"><span class="calibre7">exec()</span></code>, is set.</li>
<li value="6" class="calibre14">It calls <code class="calibre6"><span class="calibre7">alloc_pid()</span></code> to assign an available PID to the new task.</li>
<li value="7" class="calibre14">Depending on the flags passed to <code class="calibre6"><span class="calibre7">clone()</span></code>, <code class="calibre6"><span class="calibre7">copy_process()</span></code> either duplicates or shares open files, filesystem information, signal handlers, process address space, and namespace. These resources are typically shared between threads in a given process; otherwise they are unique and thus copied here.</li>
<li value="8" class="calibre14">Finally, <code class="calibre6"><span class="calibre7">copy_process()</span></code> cleans up and returns to the caller a pointer to the new child.</li>
</ol>
<p class="calibre_2">Back in <code class="calibre6"><span class="calibre7">do_fork()</span></code>, if <code class="calibre6"><span class="calibre7">copy_process()</span></code> returns successfully, the new child is woken up and run. Deliberately, the kernel runs the child process first.<sup class="calibre8"><a id="filepos199980" href="#filepos200309">8</a></sup> In the common case of the child simply calling <code class="calibre6"><span class="calibre7">exec()</span></code> immediately, this eliminates any copy-on-write overhead that would occur if the parent ran first and began writing to the address space.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos200309" href="#filepos199980">8</a></sup>
<em class="calibre4">This does not currently function correctly, although the goal is for the child to run first.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos200513"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">vfork()</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos200657"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">vfork()</span></code> system call has the same effect as <code class="calibre6"><span class="calibre7">fork()</span></code>, except that the page table entries of the parent process are not copied. Instead, the child executes as the sole thread in the parent’s address space, and the parent is blocked until the child either calls <code class="calibre6"><span class="calibre7">exec()</span></code> or exits. The child is <em class="calibre4">not</em> allowed to write to the address space. This was a welcome optimization in the old days of 3BSD when the call was introduced because at the time copy-on-write pages were not used to implement <code class="calibre6"><span class="calibre7">fork()</span></code>. Today, with copy-on-write and child-runs-first semantics, the only benefit to <code class="calibre6"><span class="calibre7">vfork()</span></code> is not copying the parent page tables entries. If Linux one day gains copy-on-write page table entries, there will no longer be any benefit.<sup class="calibre8"><a id="filepos201623" href="#filepos202186">9</a></sup> Because the semantics of <code class="calibre6"><span class="calibre7">vfork()</span></code> are tricky (what, for example, happens if the <code class="calibre6"><span class="calibre7">exec()</span></code> fails?), ideally systems would not need <code class="calibre6"><span class="calibre7">vfork()</span></code> and the kernel would not implement it. It is entirely possible to implement <code class="calibre6"><span class="calibre7">vfork()</span></code> as a normal <code class="calibre6"><span class="calibre7">fork()</span></code>—this is what Linux did until version 2.2.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos202186" href="#filepos201623">9</a></sup>
<em class="calibre4">Patches are available to add this functionality to Linux. In time, this feature will most likely find its way into the mainline Linux kernel.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">vfork()</span></code> system call is implemented via a special flag to the <code class="calibre6"><span class="calibre7">clone()</span></code> system call:</p><div class="calibre_3"> </div>
<ol class="calibre13">
<li value="1" class="calibre14">In <code class="calibre6"><span class="calibre7">copy_process()</span></code>, the <code class="calibre6"><span class="calibre7">task_struct</span></code> member <code class="calibre6"><span class="calibre7">vfork_done</span></code> is set to NULL.</li>
<li value="2" class="calibre14">In <code class="calibre6"><span class="calibre7">do_fork()</span></code>, if the special flag was given, <code class="calibre6"><span class="calibre7">vfork_done</span></code> is pointed at a specific address.</li>
<li value="3" class="calibre14">After the child is first run, the parent—instead of returning—waits for the child to signal it through the <code class="calibre6"><span class="calibre7">vfork_done</span></code> pointer.</li>
<li value="4" class="calibre14">In the <code class="calibre6"><span class="calibre7">mm_release()</span></code> function, which is used when a task exits a memory address space, <code class="calibre6"><span class="calibre7">vfork_done</span></code> is checked to see whether it is <code class="calibre6"><span class="calibre7">NULL</span></code>. If it is not, the parent is signaled.</li>
<li value="5" class="calibre14">Back in <code class="calibre6"><span class="calibre7">do_fork()</span></code>, the parent wakes up and returns.</li>
</ol>
<p class="calibre_2">If this all goes as planned, the child is now executing in a new address space, and the parent is again executing in its original address space. The overhead is lower, but the implementation is not pretty.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos203880"> </div>
<h3 class="calibre_21"><span class="bold">The Linux Implementation of Threads</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Threads are a popular modern programming abstraction. They provide multiple threads of execution within the same program in a shared memory address space. They can also share open files and other resources. Threads enable <em class="calibre4">concurrent programming</em> and, on multiple processor systems, true <em class="calibre4">parallelism</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Linux has a unique implementation of threads. To the Linux kernel, there is no concept of a thread. Linux implements all threads as standard processes. The Linux kernel <a id="filepos204554"></a>does not provide any special scheduling semantics or data structures to represent threads. Instead, a thread is merely a process that shares certain resources with other processes. Each thread has a unique <code class="calibre6"><span class="calibre7">task_struct</span></code> and appears to the kernel as a normal process—threads just happen to share resources, such as an address space, with other processes.</p><div class="calibre_3"> </div>
<p class="calibre_2">This approach to threads contrasts greatly with operating systems such as Microsoft Windows or Sun Solaris, which have <em class="calibre4">explicit</em> kernel support for threads (and sometimes call threads <em class="calibre4">lightweight processes</em>). The name “lightweight process” sums up the difference in philosophies between Linux and other systems. To these other operating systems, threads are an abstraction to provide a lighter, quicker execution unit than the heavy process. To Linux, threads are simply a manner of sharing resources between processes (which are already quite lightweight).<sup class="calibre8"><a id="filepos205587" href="#filepos206267">10</a></sup> For example, assume you have a process that consists of four threads. On systems with explicit thread support, one process descriptor might exist that, in turn, points to the four different threads. The process descriptor describes the shared resources, such as an address space or open files. The threads then describe the resources they alone possess. Conversely, in Linux, there are simply four processes and thus four normal <code class="calibre6"><span class="calibre7">task_struct</span></code> structures. The four processes are set up to share certain resources. The result is quite elegant.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos206267" href="#filepos205587">10</a></sup>
<em class="calibre4">As an example, benchmark process creation time in Linux versus process (or even thread!) creation time in these other operating systems. The results are favorable for Linux.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos206554"> </div>
<h4 class="calibre_27"><span class="calibre3">Creating Threads</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Threads are created the same as normal tasks, with the exception that the <code class="calibre6"><span class="calibre7">clone()</span></code> system call is passed flags corresponding to the specific resources to be shared:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The previous code results in behavior identical to a normal <code class="calibre6"><span class="calibre7">fork()</span></code>, except that the address space, filesystem resources, file descriptors, and signal handlers are shared. In other words, the new task and its parent are what are popularly called <em class="calibre4">threads</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">In contrast, a normal <code class="calibre6"><span class="calibre7">fork()</span></code> can be implemented as</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">clone(SIGCHLD, 0);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">And <code class="calibre6"><span class="calibre7">vfork()</span></code> is implemented as</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The flags provided to <code class="calibre6"><span class="calibre7">clone()</span></code> help specify the behavior of the new process and detail what resources the parent and child will share. <a href="#filepos208377">Table 3.1</a> lists the clone flags, which are defined in <code class="calibre6"><span class="calibre7">&lt;linux/sched.h&gt;</span></code>, and their effect.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos208326"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos208377"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 3.1. <code class="calibre6"><span class="calibre15">clone()</span></code> Flags</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00013.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos208686"> </div>
<h4 class="calibre_27"><span class="calibre3">Kernel Threads</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">It is often useful for the kernel to perform some operations in the background. The kernel accomplishes this via <em class="calibre4">kernel threads</em>—standard processes that exist solely in kernel-space. The significant difference between kernel threads and normal processes is that kernel threads do not have an address space. (Their <code class="calibre6"><span class="calibre7">mm</span></code> pointer, which points at their address space, is <code class="calibre6"><span class="calibre7">NULL</span></code>.) They operate only in kernel-space and do not context switch into user-space. Kernel threads, however, are schedulable and preemptable, the same as normal processes.</p><div class="calibre_3"> </div>
<p class="calibre_2">Linux delegates several tasks to kernel threads, most notably the <em class="calibre4">flush</em> tasks and the <em class="calibre4">ksoftirqd</em> task. You can see the kernel threads on your Linux system by running the command <code class="calibre6"><span class="calibre7">ps -ef</span></code>. There are a lot of them! Kernel threads are created on system boot by other kernel threads. Indeed, a kernel thread can be created only by another kernel thread. The kernel handles this automatically by forking all new kernel threads off of the <em id="filepos209957" class="calibre4">kthreadd</em> kernel process. The interface, declared in <code class="calibre6"><span class="calibre7">&lt;linux/kthread.h&gt;</span></code>, for spawning a new kernel thread from an existing one is</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00014.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The new task is created via the <code class="calibre6"><span class="calibre7">clone()</span></code> system call by the <em class="calibre4">kthread</em> kernel process. The new process will run the <code class="calibre6"><span class="calibre7">threadfn</span></code> function, which is passed the <code class="calibre6"><span class="calibre7">data</span></code> argument. The process will be named <code class="calibre6"><span class="calibre7">namefmt</span></code>, which takes <em class="calibre4">printf</em>-style formatting arguments in the variable argument list. The process is created in an unrunnable state; it will not start running until explicitly woken up via <code class="calibre6"><span class="calibre7">wake_up_process()</span></code>. A process can be created and made runnable with a single function, <code class="calibre6"><span class="calibre7">kthread_run()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00015.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This routine, implemented as a macro, simply calls both <code class="calibre6"><span class="calibre7">kthread_create()</span></code> and <code class="calibre6"><span class="calibre7">wake_up_process()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00016.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">When started, a kernel thread continues to exist until it calls <code class="calibre6"><span class="calibre7">do_exit()</span></code> or another part of the kernel calls <code class="calibre6"><span class="calibre7">kthread_stop()</span></code>, passing in the address of the <code class="calibre6"><span class="calibre7">task_struct</span></code> structure returned by <code class="calibre6"><span class="calibre7">kthread_create()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int kthread_stop(struct task_struct *k)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">We discuss specific kernel threads in more detail in later chapters.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos212084"> </div>
<h3 class="calibre_21"><span class="bold">Process Termination</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">It is sad, but eventually processes must die. When a process terminates, the kernel releases the resources owned by the process and notifies the child’s parent of its demise.</p><div class="calibre_3"> </div>
<p class="calibre_2">Generally, process destruction is self-induced. It occurs when the process calls the <code class="calibre6"><span class="calibre7">exit()</span></code> system call, either explicitly when it is ready to terminate or implicitly on return from the main subroutine of any program. (That is, the C compiler places a call to <code class="calibre6"><span class="calibre7">exit()</span></code> after <code class="calibre6"><span class="calibre7">main()</span></code> returns.) A process can also terminate involuntarily. This occurs when the process receives a signal or exception it cannot handle or ignore. Regardless of how a process terminates, the bulk of the work is handled by <code class="calibre6"><span class="calibre7">do_exit()</span></code>, defined in <code class="calibre6"><span class="calibre7">kernel/exit.c</span></code>, which completes a number of chores:</p><div class="calibre_3"> </div>
<ol class="calibre13">
<li value="1" class="calibre14">It sets the <code class="calibre6"><span class="calibre7">PF_EXITING</span></code> flag in the <code class="calibre6"><span class="calibre7">flags</span></code> member of the <code class="calibre6"><span class="calibre7">task_struct</span></code>.</li>
<li value="2" class="calibre14">It calls <code class="calibre6"><span class="calibre7">del_timer_sync()</span></code> to remove any kernel timers. Upon return, it is guaranteed that no timer is queued and that no timer handler is running.</li>
<li value="3" class="calibre14">If BSD process accounting is enabled, <code class="calibre6"><span class="calibre7">do_exit()</span></code> calls <code class="calibre6"><span class="calibre7">acct_update_integrals()</span></code> to write out accounting information.</li>
<li value="4" class="calibre14">It calls <code class="calibre6"><span class="calibre7">exit_mm()</span></code> to release the <code class="calibre6"><span class="calibre7">mm_struct</span></code> held by this process. If no other process is using this address space—that it, if the address space is not shared—the kernel then destroys it.</li>
<li value="5" class="calibre14">It calls <code class="calibre6"><span class="calibre7">exit_sem()</span></code>. If the process is queued waiting for an IPC semaphore, it is dequeued here.</li>
<li value="6" class="calibre14">It then calls <code class="calibre6"><span class="calibre7">exit_files()</span></code> and <code class="calibre6"><span class="calibre7">exit_fs()</span></code> to decrement the usage count of objects related to file descriptors and filesystem data, respectively. If either usage counts reach zero, the object is no longer in use by any process, and it is destroyed.</li>
<li value="7" class="calibre14">It sets the task’s exit code, stored in the <code class="calibre6"><span class="calibre7">exit_code</span></code> member of the <code class="calibre6"><span class="calibre7">task_struct</span></code>, to the code provided by <code class="calibre6"><span class="calibre7">exit()</span></code> or whatever kernel mechanism forced the termination. The exit code is stored here for optional retrieval by the parent.</li>
<li value="8" class="calibre14">It calls <code class="calibre6"><span class="calibre7">exit_notify()</span></code> to send signals to the task’s parent, reparents any of the task’s children to another thread in their thread group or the init process, and sets the task’s exit state, stored in <code class="calibre6"><span class="calibre7">exit_state</span></code> in the <code class="calibre6"><span class="calibre7">task_struct</span></code> structure, to <code class="calibre6"><span class="calibre7">EXIT_ZOMBIE</span></code>.</li>
<li value="9" class="calibre14"><code class="calibre6"><span class="calibre7">do_exit()</span></code> calls <code class="calibre6"><span class="calibre7">schedule()</span></code> to switch to a new process (see <a href="index_split_013.html#filepos223287">Chapter 4</a>). Because the process is now not schedulable, this is the last code the task will ever execute. <code class="calibre6"><span class="calibre7">do_exit()</span></code> never returns.</li>
</ol>
<p class="calibre_2">At this point, all objects associated with the task (assuming the task was the sole user) are freed. The task is not runnable (and no longer has an address space in which to run) and is in the <code class="calibre6"><span class="calibre7">EXIT_ZOMBIE</span></code> exit state. The only memory it occupies is its kernel stack, the <code class="calibre6"><span class="calibre7">thread_info</span></code> structure, and the <code class="calibre6"><span class="calibre7">task_struct</span></code> structure. The task exists solely to provide information to its parent. After the parent retrieves the information, or notifies the kernel that it is uninterested, the remaining memory held by the process is freed and returned to the system for use.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos216471"> </div>
<h4 class="calibre_27"><span class="calibre3">Removing the Process Descriptor</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">After <code class="calibre6"><span class="calibre7">do_exit()</span></code> completes, the process descriptor for the terminated process still exists, but the process is a zombie and is unable to run. As discussed, this enables the system to obtain information about a child process after it has terminated. Consequently, the acts of <a id="filepos216913"></a>cleaning up after a process and removing its process descriptor are separate. After the parent has obtained information on its terminated child, or signified to the kernel that it does not care, the child’s <code class="calibre6"><span class="calibre7">task_struct</span></code> is deallocated.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">wait()</span></code> family of functions are implemented via a single (and complicated) system call, <code class="calibre6"><span class="calibre7">wait4()</span></code>. The standard behavior is to suspend execution of the calling task until one of its children exits, at which time the function returns with the PID of the exited child. Additionally, a pointer is provided to the function that on return holds the exit code of the terminated child.</p><div class="calibre_3"> </div>
<p class="calibre_2">When it is time to finally deallocate the process descriptor, <code class="calibre6"><span class="calibre7">release_task()</span></code> is invoked. It does the following:</p><div class="calibre_3"> </div>
<ol class="calibre13">
<li value="1" class="calibre14">It calls <code class="calibre6"><span class="calibre7">__exit_signal()</span></code>, which calls <code class="calibre6"><span class="calibre7">__unhash_process()</span></code>, which in turns calls <code class="calibre6"><span class="calibre7">detach_pid()</span></code> to remove the process from the pidhash and remove the process from the task list.</li>
<li value="2" class="calibre14"><code class="calibre6"><span class="calibre7">__exit_signal()</span></code> releases any remaining resources used by the now dead process and finalizes statistics and bookkeeping.</li>
<li value="3" class="calibre14">If the task was the last member of a thread group, and the leader is a zombie, then <code class="calibre6"><span class="calibre7">release_task()</span></code> notifies the zombie leader’s parent.</li>
<li value="4" class="calibre14"><code class="calibre6"><span class="calibre7">release_task()</span></code> calls <code class="calibre6"><span class="calibre7">put_task_struct()</span></code> to free the pages containing the process’s kernel stack and <code class="calibre6"><span class="calibre7">thread_info</span></code> structure and deallocate the slab cache containing the <code class="calibre6"><span class="calibre7">task_struct</span></code>.</li>
</ol>
<p class="calibre_2">At this point, the process descriptor and all resources belonging solely to the process have been freed.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos219114"> </div>
<h4 class="calibre_27"><span class="calibre3">The Dilemma of the Parentless Task</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">If a parent exits before its children, some mechanism must exist to <em class="calibre4">reparent</em> any child tasks to a new process, or else parentless terminated processes would forever remain zombies, wasting system memory. The solution is to reparent a task’s children on exit to either another process in the current thread group or, if that fails, the <code class="calibre6"><span class="calibre7">init</span></code> process. <code class="calibre6"><span class="calibre7">do_exit()</span></code> calls <code class="calibre6"><span class="calibre7">exit_notify()</span></code>, which calls <code class="calibre6"><span class="calibre7">forget_original_parent()</span></code>, which, in turn, calls <code class="calibre6"><span class="calibre7">find_new_reaper()</span></code> to perform the reparenting:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00017.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This code attempts to find and return another task in the process’s thread group. If another task is not in the thread group, it finds and returns the <code class="calibre6"><span class="calibre7">init</span></code> process. Now that a suitable new parent for the children is found, each child needs to be located and reparented to <code class="calibre6"><span class="calibre7">reaper</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00018.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><code class="calibre6"><span class="calibre7">ptrace_exit_finish()</span></code> is then called to do the same reparenting but to a list of <em class="calibre4">ptraced</em> children:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00019.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The rationale behind having both a child list and a ptraced list is interesting; it is a new feature in the 2.6 kernel. When a task is <em class="calibre4">ptraced</em>, it is temporarily reparented to the debugging process. When the task’s parent exits, however, it must be reparented along with its other siblings. In previous kernels, this resulted in a loop over <em class="calibre4">every process in the system</em> looking for children. The solution is simply to keep a separate list of a process’s children being ptraced—reducing the search for one’s children from every process to just two relatively small lists.</p><div class="calibre_3"> </div>
<p class="calibre_2">With the process successfully reparented, there is no risk of stray zombie processes. The <code class="calibre6"><span class="calibre7">init</span></code> process routinely calls <code class="calibre6"><span class="calibre7">wait()</span></code> on its children, cleaning up any zombies assigned to it.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos221803"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">In this chapter, we looked at the core operating system abstraction of the <em class="calibre4">process</em>. We discussed the generalities of the process, why it is important, and the relationship between processes and threads. We then discussed how Linux stores and represents processes (with <code class="calibre6"><span class="calibre7">task_struct</span></code> and <code class="calibre6"><span class="calibre7">thread_info</span></code>), how processes are created (via <code class="calibre6"><span class="calibre7">fork()</span></code> and ultimately <code class="calibre6"><span class="calibre7">clone()</span></code>), how new executable images are loaded into address spaces (via the <code class="calibre6"><span class="calibre7">exec()</span></code> family of system calls), the hierarchy of processes, how parents glean information about their deceased children (via the <code class="calibre6"><span class="calibre7">wait()</span></code> family of system calls), and how processes ultimately die (forcefully or intentionally via <code class="calibre6"><span class="calibre7">exit()</span></code>). The process is a fundamental and crucial abstraction, at the heart of every modern operating system, and ultimately the reason we have operating systems altogether (to run programs).</p><div class="calibre_3"> </div>
<p class="calibre_2">The next chapter discusses process scheduling, which is the delicate and interesting manner in which the kernel decides which processes to run, at what time, and in what order.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_33"></div>
</body></html>
