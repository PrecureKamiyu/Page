<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 63. Alternative I/O Models</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch62.html" title="Chapter 62. Terminals"/><link rel="next" href="ch64.html" title="Chapter 64. Pseudoterminals"/></head><body><section class="chapter" title="Chapter 63. Alternative I/O Models" epub:type="chapter" id="alternative_i_solidus_o_models"><div class="titlepage"><div><div><h2 class="title">Chapter 63. Alternative I/O Models</h2></div></div></div><p>This chapter discusses three alternatives to the conventional file I/O model that we
            have employed in most programs shown in this book:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>I/O multiplexing (the <span class="emphasis"><em>select()</em></span> and
                        <span class="emphasis"><em>poll()</em></span> system calls);</p></li><li class="listitem"><p>signal-driven I/O; and</p></li><li class="listitem"><p>the Linux-specific <span class="emphasis"><em>epoll</em></span> API.</p></li></ul></div><div class="sect1" title="Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="overview-id21">Overview</h2></div></div></div><p>Most of the programs that we have presented so far in this book employ an I/O
                model under which a process performs I/O on just one file descriptor at a time, and
                each I/O system call blocks until the data is transferred. For example, when reading
                from a pipe, a <span class="emphasis"><em>read()</em></span> call normally blocks if no data is
                currently present in the pipe, and a <span class="emphasis"><em>write()</em></span> call blocks if
                there is insufficient space in the pipe to hold the data to be written. Similar
                behavior occurs when performing I/O on various other types of files, including FIFOs
                and sockets.<a id="IDX-CHP-63-8538" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Disk files are a special case. As described in <a class="xref" href="ch13.html" title="Chapter 13. File I/O Buffering">Chapter 13</a>, the kernel employs the buffer cache
                    to speed disk I/O requests. Thus, a <span class="emphasis"><em>write()</em></span> to a disk
                    returns as soon as the requested data has been transferred to the kernel buffer
                    cache, rather than waiting until the data is written to disk (unless the
                        <code class="literal">O_SYNC</code> flag was specified when opening
                    the file). Correspondingly, a <span class="emphasis"><em>read()</em></span> transfers data from
                    the buffer cache to a user buffer, and if the required data is not in the buffer
                    cache, then the kernel puts the process to sleep while a disk read is
                    performed.</p></div><p>The traditional blocking I/O model is sufficient for many applications, but not
                all. In particular, some applications need to able to do one or both of the
                following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Check whether I/O is possible on a file descriptor without blocking if it
                        is not possible.</p></li><li class="listitem"><p>Monitor multiple file descriptors to see if I/O is possible on any of
                        them.</p></li></ul></div><p>We have already encountered two techniques that can be used to partially address
                these needs: nonblocking I/O and the use of multiple processes or threads.<a id="IDX-CHP-63-8539" class="indexterm"/></p><p>We described nonblocking I/O in some detail in <a class="xref" href="ch05.html#nonblocking_i_solidus_o" title="Nonblocking I/O">Nonblocking I/O</a> and <a class="xref" href="ch44.html#nonblocking_i_solidus_o-id1" title="Nonblocking I/O">Nonblocking I/O</a>. If we place a file descriptor in
                nonblocking mode by enabling the <code class="literal">O_NONBLOCK</code> open
                file status flag, then an I/O system call that can’t be immediately completed
                returns an error instead of blocking. Nonblocking I/O can be employed with pipes,
                FIFOs, sockets, terminals, pseudoterminals, and some other types of
                    devices.<a id="IDX-CHP-63-8540" class="indexterm"/></p><p>Nonblocking I/O allows us to periodically check (“poll”) whether I/O is possible
                on a file descriptor. For example, we can make an input file descriptor nonblocking,
                and then periodically perform nonblocking reads. If we need to monitor multiple file
                descriptors, then we mark them all nonblocking, and poll each of them in turn.
                However, polling in this manner is usually undesirable. If polling is done only
                infrequently, then the latency before an application responds to an I/O event may be
                unacceptably long; on the other hand, polling in a tight loop wastes CPU
                    time.<a id="IDX-CHP-63-8541" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In this chapter, we use the word <span class="emphasis"><em>poll</em></span> in two distinct
                    ways. One of these is as the name of the I/O multiplexing system call,
                        <span class="emphasis"><em>poll()</em></span>. In the other use, we mean “performing a
                    nonblocking check on the status of a file descriptor.”</p></div><p>If we don’t want a process to block when performing I/O on a file descriptor, we
                can instead create a new process to perform the I/O. The parent process can then
                carry on to perform other tasks, while the child process blocks until the I/O is
                complete. If we need to handle I/O on multiple file descriptors, we can create one
                child for each descriptor. The problems with this approach are expense and
                complexity. Creating and maintaining processes places a load on the system, and,
                typically, the child processes will need to use some form of IPC to inform the
                parent about the status of I/O operations.</p><p>Using multiple threads instead of processes is less demanding of resources, but
                the threads will probably still need to communicate information to one another about
                the status of I/O operations, and the programming can be complex, especially if we
                are using thread pools to minimize the number of threads used to handle large
                numbers of simultaneous clients. (One place where threads can be particularly useful
                is if the application needs to call a third-party library that performs blocking
                I/O. An application can avoid blocking in this case by making the library call in a
                separate thread.)</p><p>Because of the limitations of both nonblocking I/O and the use of multiple threads
                or processes, one of the following alternatives is often preferable:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>I/O multiplexing</em></span> allows a process to simultaneously
                        monitor multiple file descriptors to find out whether I/O is possible on any
                        of them. The <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                        system calls perform I/O multiplexing.<a id="IDX-CHP-63-8542" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Signal-driven I/O</em></span> is a technique whereby a process
                        requests that the kernel send it a signal when input is available or data
                        can be written on a specified file descriptor. The process can then carry on
                        performing other activities, and is notified when I/O becomes possible via
                        receipt of the signal. When monitoring large numbers of file descriptors,
                        signal-driven I/O provides significantly better performance than
                            <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>.<a id="IDX-CHP-63-8543" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>epoll</em></span> API is a Linux-specific feature that first
                        appeared in Linux 2.6. Like the I/O multiplexing APIs, the
                            <span class="emphasis"><em>epoll</em></span> API allows a process to monitor multiple file
                        descriptors to see if I/O is possible on any of them. Like signal-driven
                        I/O, the <span class="emphasis"><em>epoll</em></span> API provides much better performance
                        when monitoring large numbers of file descriptors.<a id="IDX-CHP-63-8544" class="indexterm"/><a id="IDX-CHP-63-8545" class="indexterm"/></p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>In the remainder of this chapter, we’ll generally frame the discussion of the
                    above techniques in terms of processes. However, these techniques can also be
                    employed in multithreaded applications.</p></div><p>In effect, I/O multiplexing, signal-driven I/O, and <span class="emphasis"><em>epoll</em></span> are
                all methods of achieving the same result—monitoring one or, commonly, several file
                descriptors simultaneously to see if they are <span class="emphasis"><em>ready</em></span> to perform
                I/O (to be precise, to see whether an I/O system call could be performed without
                blocking). The transition of a file descriptor into a ready state is triggered by
                some type of I/O <span class="emphasis"><em>event</em></span>, such as the arrival of input, the
                completion of a socket connection, or the availability of space in a previously full
                socket send buffer after TCP transmits queued data to the socket peer. Monitoring
                multiple file descriptors is useful in applications such as network servers that
                must simultaneously monitor multiple client sockets, or applications that must
                simultaneously monitor input from a terminal and a pipe or socket.<a id="IDX-CHP-63-8546" class="indexterm"/><a id="IDX-CHP-63-8547" class="indexterm"/></p><p>Note that none of these techniques performs I/O. They merely tell us that a file
                descriptor is ready. Some other system call must then be used to actually perform
                the I/O.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>One I/O model that we don’t describe in this chapter is POSIX asynchronous I/O
                    (AIO). POSIX AIO allows a process to queue an I/O operation to a file and then
                    later be notified when the operation is complete. The advantage of POSIX AIO is
                    that the initial I/O call returns immediately, so that the process is not tied
                    up waiting for data to be transferred to the kernel or for the operation to
                    complete. This allows the process to perform other tasks in parallel with the
                    I/O (which may include queuing further I/O requests). For certain types of
                    applications, POSIX AIO can provide useful performance benefits. Currently,
                    Linux provides a threads-based implementation of POSIX AIO within
                        <span class="emphasis"><em>glibc</em></span>. At the time of writing, work is ongoing toward
                    providing an in-kernel implementation of POSIX AIO, which should provide better
                    scaling performance. POSIX AIO is described in [Gallmeister, 1995], [Robbins
                    &amp; Robbins, 2003], and the <span class="emphasis"><em>aio(7)</em></span> manual
                        page.<a id="IDX-CHP-63-8548" class="indexterm"/></p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="which_technique_question"/></div></div></div><div class="sect3" title="Which technique?"><div class="titlepage"><div><div><h4 class="title" id="which_technique_question-id1">Which technique?</h4></div></div></div><p>During the course of this chapter, we’ll consider the reasons we may
                        choose one of these techniques rather than another. In the meantime, we
                        summarize a few points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                                system calls are long-standing interfaces that have been present on
                                UNIX systems for many years. Compared to the other techniques, their
                                primary advantage is portability. Their main disadvantage is that
                                they don’t scale well when monitoring large numbers (hundreds or
                                thousands) of file descriptors.</p></li><li class="listitem"><p>The key advantage of the <span class="emphasis"><em>epoll</em></span> API is that it
                                allows an application to efficiently monitor large numbers of file
                                descriptors. Its primary disadvantage is that it is a Linux-specific
                                API.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some other UNIX implementations provide (nonstandard)
                                    mechanisms similar to <span class="emphasis"><em>epoll</em></span>. For example,
                                    Solaris provides the special <code class="literal">/dev/poll</code> file (described in the Solaris
                                        <span class="emphasis"><em>poll(7d)</em></span> manual page), and some of the
                                    BSDs provide the <span class="emphasis"><em>kqueue</em></span> API (which provides
                                    a more general-purpose monitoring facility than
                                        <span class="emphasis"><em>epoll</em></span>). [Stevens et al., 2004] briefly
                                    describes these two mechanisms; a longer discussion of
                                        <span class="emphasis"><em>kqueue</em></span> can be found in [Lemon,
                                    2001].</p></div></li><li class="listitem"><p>Like <span class="emphasis"><em>epoll</em></span>, signal-driven I/O allows an
                                application to efficiently monitor large numbers of file
                                descriptors. However, <span class="emphasis"><em>epoll</em></span> provides a number
                                of advantages over signal-driven I/O:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>We avoid the complexities of dealing with signals.</p></li><li class="listitem"><p>We can specify the kind of monitoring that we want to
                                        perform (e.g., ready for reading or ready for
                                        writing).</p></li><li class="listitem"><p>We can select either level-triggered or edge-triggered
                                        notification (described in <a class="xref" href="ch63.html#which_technique_question-id1" title="Which technique?">Which technique?</a>).</p></li></ul></div><p>Furthermore, taking full advantage of signal-driven I/O requires
                                the use of nonportable, Linux-specific features, and if we do this,
                                signal-driven I/O is no more portable than
                                    <span class="emphasis"><em>epoll</em></span>.</p></li></ul></div><p>Because, on the one hand, <span class="emphasis"><em>select()</em></span> and
                            <span class="emphasis"><em>poll()</em></span> are more portable, while signal-driven I/O
                        and <span class="emphasis"><em>epoll</em></span> deliver better performance, for some
                        applications, it can be worthwhile writing an abstract software layer for
                        monitoring file descriptor events. With such a layer, portable programs can
                        employ <span class="emphasis"><em>epoll</em></span> (or a similar API) on systems that provide
                        it, and fall back to the use of <span class="emphasis"><em>select()</em></span> or
                            <span class="emphasis"><em>poll()</em></span> on other systems.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>libevent</em></span> library is a software layer that
                            provides an abstraction for monitoring file descriptor events. It has
                            been ported to a number of UNIX systems. As its underlying mechanism,
                                <span class="emphasis"><em>libevent</em></span> can (transparently) employ any of the
                            techniques described in this chapter: <span class="emphasis"><em>select()</em></span>,
                                <span class="emphasis"><em>poll()</em></span>, signal-driven I/O, or
                                <span class="emphasis"><em>epoll</em></span>, as well as the Solaris specific <code class="literal">/dev/poll</code> interface or the BSD
                                <span class="emphasis"><em>kqueue</em></span> interface. (Thus,
                                <span class="emphasis"><em>libevent</em></span> also serves as an example of how to
                            use each of these techniques.) Written by Niels Provos,
                                <span class="emphasis"><em>libevent</em></span> is available at <a class="ulink" href="http://monkey.org/~provos/libevent/" target="_top">http://monkey.org/~provos/libevent/</a>.<a id="IDX-CHP-63-8549" class="indexterm"/></p></div></div></div><div class="sect2" title="Level-Triggered and Edge-Triggered Notification"><div class="titlepage"><div><div><h3 class="title" id="level-triggered_and_edge-triggered_notif">Level-Triggered and Edge-Triggered Notification</h3></div></div></div><p>Before discussing the various alternative I/O mechanisms in detail, we need to
                    distinguish two models of readiness notification for a file descriptor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Level-triggered notification</em></span>: A file descriptor
                            is considered to be ready if it is possible to perform an I/O system
                            call without blocking.</p></li><li class="listitem"><p><span class="emphasis"><em>Edge-triggered notification</em></span>: Notification is
                            provided if there is I/O activity (e.g., new input) on a file descriptor
                            since it was last monitored.</p></li></ul></div><p><a class="xref" href="ch63.html#use_of_level-triggered_and_edge-triggere" title="Table 63-1. Use of level-triggered and edge-triggered notification models">Table 63-1</a> summarizes the
                    notification models employed by I/O multiplexing, signal-driven I/O, and
                        <span class="emphasis"><em>epoll</em></span>. The <span class="emphasis"><em>epoll</em></span> API differs from
                    the other two I/O models in that it can employ both level-triggered notification
                    (the default) and edge-triggered notification.<a id="IDX-CHP-63-8550" class="indexterm"/><a id="IDX-CHP-63-8551" class="indexterm"/></p><div class="table"><a id="use_of_level-triggered_and_edge-triggere"/><div class="table-title">Table 63-1. Use of level-triggered and edge-triggered notification models</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>I/O model</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Level-triggered?</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                    <p>Edge-triggered?</p>
                                </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p><span class="emphasis"><em>select()</em></span>,
                                        <span class="emphasis"><em>poll()</em></span></p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>•</p>
                                </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Signal-driven I/O</p>
                                </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>•</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>
                                        <span class="emphasis"><em>epoll</em></span>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>•</p>
                                </td><td style="text-align: left; vertical-align: top; ">
                                    <p>•</p>
                                </td></tr></tbody></table></div></div><p>Details of the differences between these two notification models will become
                    clearer during the course of the chapter. For now, we describe how the choice of
                    notification model affects the way we design a program.</p><p>When we employ level-triggered notification, we can check the readiness of a
                    file descriptor at any time. This means that when we determine that a file
                    descriptor is ready (e.g., it has input available), we can perform some I/O on
                    the descriptor, and then repeat the monitoring operation to check if the
                    descriptor is still ready (e.g., it still has more input available), in which
                    case we can perform more I/O, and so on. In other words, because the
                    level-triggered model allows us to repeat the I/O monitoring operation at any
                    time, it is not necessary to perform as much I/O as possible (e.g., read as many
                    bytes as possible) on the file descriptor (or even perform any I/O at all) each
                    time we are notified that a file descriptor is ready.</p><p>By contrast, when we employ edge-triggered notification, we receive
                    notification only when an I/O event occurs. We don’t receive any further
                    notification until another I/O event occurs. Furthermore, when an I/O event is
                    notified for a file descriptor, we usually don’t know how much I/O is possible
                    (e.g., how many bytes are available for reading). Therefore, programs that
                    employ edge-triggered notification are usually designed according to the
                    following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>After notification of an I/O event, the program should—at some
                            point—perform as much I/O as possible (e.g., read as many bytes as
                            possible) on the corresponding file descriptor. If the program fails to
                            do this, then it might miss the opportunity to perform some I/O, because
                            it would not be aware of the need to operate on the file descriptor
                            until another I/O event occurred. This could lead to spurious data loss
                            or blockages in a program. We said “at some point,” because sometimes it
                            may not be desirable to perform all of the I/O immediately after we
                            determine that the file descriptor is ready. The problem is that we may
                            starve other file descriptors of attention if we perform a large amount
                            of I/O on one file descriptor. We consider this point in more detail
                            when we describe the edge-triggered notification model for
                                <span class="emphasis"><em>epoll</em></span> in <a class="xref" href="ch63.html#edge-triggered_notification" title="Edge-Triggered Notification">Edge-Triggered Notification</a>.</p></li><li class="listitem"><p>If the program employs a loop to perform as much I/O as possible on
                            the file descriptor, and the descriptor is marked as blocking, then
                            eventually an I/O system call will block when no more I/O is possible.
                            For this reason, each monitored file descriptor is normally placed in
                            nonblocking mode, and after notification of an I/O event, I/O operations
                            are performed repeatedly until the relevant system call (e.g.,
                                <span class="emphasis"><em>read()</em></span> or <span class="emphasis"><em>write()</em></span>) fails
                            with the error <code class="literal">EAGAIN</code> or <code class="literal">EWOULDBLOCK</code>.<a id="IDX-CHP-63-8552" class="indexterm"/></p></li></ul></div></div><div class="sect2" title="Employing Nonblocking I/O with Alternative I/O Models"><div class="titlepage"><div><div><h3 class="title" id="employing_nonblocking_i_solidus_o_with_a">Employing Nonblocking I/O with Alternative I/O Models</h3></div></div></div><p>Nonblocking I/O (the <code class="literal">O_NONBLOCK</code> flag) is
                    often used in conjunction with the I/O models described in this chapter. Some
                    examples of why this can be useful are the following:<a id="IDX-CHP-63-8553" class="indexterm"/><a id="IDX-CHP-63-8554" class="indexterm"/><a id="IDX-CHP-63-8555" class="indexterm"/><a id="IDX-CHP-63-8556" class="indexterm"/><a id="IDX-CHP-63-8557" class="indexterm"/><a id="IDX-CHP-63-8558" class="indexterm"/><a id="IDX-CHP-63-8559" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>As explained in the previous section, nonblocking I/O is usually
                            employed in conjunction with I/O models that provide edge-triggered
                            notification of I/O events.<a id="IDX-CHP-63-8560" class="indexterm"/></p></li><li class="listitem"><p>If multiple processes (or threads) are performing I/O on the same open
                            file descriptions, then, from a particular process’s point of view, a
                            descriptor’s readiness may change between the time the descriptor was
                            notified as being ready and the time of the subsequent I/O call.
                            Consequently, a blocking I/O call could block, thus preventing the
                            process from monitoring other file descriptors. (This can occur for all
                            of the I/O models that we describe in this chapter, regardless of
                            whether they employ level-triggered or edge-triggered
                            notification.)</p></li><li class="listitem"><p>Even after a level-triggered API such as <span class="emphasis"><em>select()</em></span>
                            or <span class="emphasis"><em>poll()</em></span> informs us that a file descriptor for a
                            stream socket is ready for writing, if we write a large enough block of
                            data in a single <span class="emphasis"><em>write()</em></span> or
                                <span class="emphasis"><em>send()</em></span>, then the call will nevertheless
                            block.</p></li><li class="listitem"><p>In rare cases, level-triggered APIs such as
                                <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> can
                            return spurious readiness notifications—they can falsely inform us that
                            a file descriptor is ready. This could be caused by a kernel bug or be
                            expected behavior in an uncommon scenario.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Section 16.6 of [Stevens et al., 2004] describes one example of spurious
                        readiness notifications on BSD systems for a listening socket. If a client
                        connects to a server’s listening socket and then resets the connection, a
                            <span class="emphasis"><em>select()</em></span> performed by the server between these two
                        events will indicate the listening socket as being readable, but a
                        subsequent <span class="emphasis"><em>accept()</em></span> that is performed after the
                        client’s reset will block.</p></div></div></div><div class="sect1" title="I/O Multiplexing"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="i_solidus_o_multiplexing">I/O Multiplexing</h2></div></div></div><p>I/O multiplexing allows us to simultaneously monitor multiple file descriptors to
                see if I/O is possible on any of them. We can perform I/O multiplexing using either
                of two system calls with essentially the same functionality. The first of these,
                    <span class="emphasis"><em>select()</em></span>, appeared along with the sockets API in BSD. This
                was historically the more widespread of the two system calls. The other system call,
                    <span class="emphasis"><em>poll()</em></span>, appeared in System V. Both
                    <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> are nowadays
                required by SUSv3.<a id="IDX-CHP-63-8561" class="indexterm"/></p><p>We can use <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> to
                monitor file descriptors for regular files, terminals, pseudoterminals, pipes,
                FIFOs, sockets, and some types of character devices. Both system calls allow a
                process either to block indefinitely waiting for file descriptors to become ready or
                to specify a timeout on the call.<a id="IDX-CHP-63-8562" class="indexterm"/></p><div class="sect2" title="The select() System Call"><div class="titlepage"><div><div><h3 class="title" id="the_select_open_parenthesis_close_parent">The <span class="emphasis"><em>select()</em></span> System Call</h3></div></div></div><p>The <span class="emphasis"><em>select()</em></span> system call blocks until one or more of a
                    set of file descriptors becomes ready.<a id="IDX-CHP-63-8563" class="indexterm"/><a id="IDX-CHP-63-8564" class="indexterm"/><a id="IDX-CHP-63-8565" class="indexterm"/><a id="IDX-CHP-63-8566" class="indexterm"/><a id="IDX-CHP-63-8567" class="indexterm"/></p><a id="I_programlisting63_d1e167166"/><pre class="programlisting">#include &lt;sys/time.h&gt;         /* For portability */
#include &lt;sys/select.h&gt;

int <strong class="userinput"><code>select</code></strong>(int <span class="emphasis"><em>nfds</em></span>, fd_set *<span class="emphasis"><em>readfds</em></span>, fd_set *<span class="emphasis"><em>writefds</em></span>, fd_set *<span class="emphasis"><em>exceptfds</em></span>,
           struct timeval *<span class="emphasis"><em>timeout</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of ready file descriptors, 0 on timeout, or -1 on
                        error</p></div><p>The <span class="emphasis"><em>nfds</em></span>, <span class="emphasis"><em>readfds</em></span>,
                        <span class="emphasis"><em>writefds</em></span>, and <span class="emphasis"><em>exceptfds</em></span> arguments
                    specify the file descriptors that <span class="emphasis"><em>select()</em></span> is to monitor.
                    The <span class="emphasis"><em>timeout</em></span> argument can be used to set an upper limit on
                    the time for which <span class="emphasis"><em>select()</em></span> will block. We describe each of
                    these arguments in detail below.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In the prototype for <span class="emphasis"><em>select()</em></span> shown above, we include
                            <code class="literal">&lt;sys/time.h&gt;</code> because
                        that was the header specified in SUSv2, and some UNIX implementations
                        require this header. (The <code class="literal">&lt;sys/time.h&gt;</code> header is present on Linux, and
                        including it does no harm.)</p></div><div class="sect3" title="File descriptor sets"><div class="titlepage"><div><div><h4 class="title" id="file_descriptor_sets">File descriptor sets</h4></div></div></div><p>The <span class="emphasis"><em>readfds</em></span>, <span class="emphasis"><em>writefds</em></span>, and
                            <span class="emphasis"><em>exceptfds</em></span> arguments are pointers to <span class="emphasis"><em>file
                            descriptor sets</em></span>, represented using the data type
                            <span class="emphasis"><em>fd_set</em></span>. These arguments are used as
                            follows:<a id="IDX-CHP-63-8568" class="indexterm"/><a id="IDX-CHP-63-8569" class="indexterm"/><a id="IDX-CHP-63-8570" class="indexterm"/><a id="IDX-CHP-63-8571" class="indexterm"/><a id="IDX-CHP-63-8572" class="indexterm"/><a id="IDX-CHP-63-8573" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>readfds</em></span> is the set of file descriptors to be
                                tested to see if input is possible;</p></li><li class="listitem"><p><span class="emphasis"><em>writefds</em></span> is the set of file descriptors to be
                                tested to see if output is possible; and</p></li><li class="listitem"><p><span class="emphasis"><em>exceptfds</em></span> is the set of file descriptors to
                                be tested to see if an exceptional condition has occurred.</p></li></ul></div><p>The term <span class="emphasis"><em>exceptional condition</em></span> is often misunderstood
                        to mean that some sort of error condition has arisen on the file descriptor.
                        This is not the case. An exceptional condition occurs in just two
                        circumstances on Linux (other UNIX implementations are similar):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A state change occurs on a pseudoterminal slave connected to a
                                master that is in packet mode (Section 64.5).</p></li><li class="listitem"><p>Out-of-band data is received on a stream socket (<a class="xref" href="ch61.html#out-of-band_data" title="Out-of-Band Data">Out-of-Band Data</a>).</p></li></ul></div><p>Typically, the <span class="emphasis"><em>fd_set</em></span> data type is implemented as a
                        bit mask. However, we don’t need to know the details, since all manipulation
                        of file descriptor sets is done via four macros: <code class="literal">FD_ZERO()</code>, <code class="literal">FD_SET()</code>,
                            <code class="literal">FD_CLR()</code>, and <code class="literal">FD_ISSET()</code>.<a id="IDX-CHP-63-8574" class="indexterm"/><a id="IDX-CHP-63-8575" class="indexterm"/><a id="IDX-CHP-63-8576" class="indexterm"/><a id="IDX-CHP-63-8577" class="indexterm"/><a id="IDX-CHP-63-8578" class="indexterm"/></p><a id="I_programlisting63_d1e167354"/><pre class="programlisting">#include &lt;sys/select.h&gt;

void <strong class="userinput"><code>FD_ZERO</code></strong>(fd_set *<span class="emphasis"><em>fdset</em></span>);
void <strong class="userinput"><code>FD_SET</code></strong>(int <span class="emphasis"><em>fd</em></span>, fd_set *<span class="emphasis"><em>fdset</em></span>);
void <strong class="userinput"><code>FD_CLR</code></strong>(int <span class="emphasis"><em>fd</em></span>, fd_set *<span class="emphasis"><em>fdset</em></span>);

int <strong class="userinput"><code>FD_ISSET</code></strong>(int <span class="emphasis"><em>fd</em></span>, fd_set *<span class="emphasis"><em>fdset</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns true (1) if <span class="emphasis"><em>fd</em></span> is in
                                <span class="emphasis"><em>fdset</em></span>, or false (0) otherwise</p></div><p>These macros operate as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">FD_ZERO()</code> initializes the set
                                pointed to by <span class="emphasis"><em>fdset</em></span> to be empty.</p></li><li class="listitem"><p><code class="literal">FD_SET()</code> adds the file
                                descriptor <span class="emphasis"><em>fd</em></span> to the set pointed to by
                                    <span class="emphasis"><em>fdset</em></span>.</p></li><li class="listitem"><p><code class="literal">FD_CLR()</code> removes the file
                                descriptor <span class="emphasis"><em>fd</em></span> from the set pointed to by
                                    <span class="emphasis"><em>fdset</em></span>.</p></li><li class="listitem"><p><code class="literal">FD_ISSET()</code> returns true if the
                                file descriptor <span class="emphasis"><em>fd</em></span> is a member of the set
                                pointed to by <span class="emphasis"><em>fdset</em></span>.</p></li></ul></div><p>A file descriptor set has a maximum size, defined by the constant <code class="literal">FD_SETSIZE</code>. On Linux, this constant has the
                        value 1024. (Other UNIX implementations have similar values for this
                        limit.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Even though the <code class="literal">FD_*</code> macros are
                            operating on user-space data structures, and the kernel implementation
                            of <span class="emphasis"><em>select()</em></span> can handle descriptor sets with larger
                            sizes, <span class="emphasis"><em>glibc</em></span> provides no simple way of modifying
                            the definition of <code class="literal">FD_SETSIZE</code>. If we
                            want to change this limit, we must modify the definition in the
                                <span class="emphasis"><em>glibc</em></span> header files. However, for reasons that
                            we describe later in this chapter, if we need to monitor large numbers
                            of descriptors, then using <span class="emphasis"><em>epoll</em></span> is probably
                            preferable to the use of <span class="emphasis"><em>select()</em></span>.</p></div><p>The <span class="emphasis"><em>readfds</em></span>, <span class="emphasis"><em>writefds</em></span>, and
                            <span class="emphasis"><em>exceptfds</em></span> arguments are all value-result. Before
                        the call to <span class="emphasis"><em>select()</em></span>, the <span class="emphasis"><em>fd_set</em></span>
                        structures pointed to by these arguments must be initialized (using <code class="literal">FD_ZERO()</code> and <code class="literal">FD_SET()</code>) to contain the set of file descriptors of interest.
                        The <span class="emphasis"><em>select()</em></span> call modifies each of these structures so
                        that, on return, they contain the set of file descriptors that are ready.
                        (Since these structures are modified by the call, we must ensure that we
                        reinitialize them if we are repeatedly calling <span class="emphasis"><em>select()</em></span>
                        from within a loop.) The structures can then be examined using <code class="literal">FD_ISSET()</code>.</p><p>If we are not interested in a particular class of events, then the
                        corresponding <span class="emphasis"><em>fd_set</em></span> argument can be specified as
                            <code class="literal">NULL</code>. We say more about the precise
                        meaning of each of the three event types in <a class="xref" href="ch63.html#when_is_a_file_descriptor_ready_question" title="When Is a File Descriptor Ready?">When Is a File Descriptor Ready?</a>.</p><p>The <span class="emphasis"><em>nfds</em></span> argument must be set one greater than the
                        highest file descriptor number included in any of the three file descriptor
                        sets. This argument allows <span class="emphasis"><em>select()</em></span> to be more
                        efficient, since the kernel then knows not to check whether file descriptor
                        numbers higher than this value are part of each file descriptor set.</p></div><div class="sect3" title="The timeout argument"><div class="titlepage"><div><div><h4 class="title" id="the_timeout_argument">The <span class="emphasis"><em>timeout</em></span> argument</h4></div></div></div><p>The <span class="emphasis"><em>timeout</em></span> argument controls the blocking behavior
                        of <span class="emphasis"><em>select()</em></span>. It can be specified either as <code class="literal">NULL</code>, in which case
                            <span class="emphasis"><em>select()</em></span> blocks indefinitely, or as a pointer to a
                            <span class="emphasis"><em>timeval</em></span> structure:<a id="IDX-CHP-63-8579" class="indexterm"/><a id="IDX-CHP-63-8580" class="indexterm"/><a id="IDX-CHP-63-8581" class="indexterm"/><a id="IDX-CHP-63-8582" class="indexterm"/></p><a id="I_programlisting63_d1e167572"/><pre class="programlisting">struct timeval {
    time_t      tv_sec;         /* Seconds */
    suseconds_t tv_usec;        /* Microseconds (long int) */
};</pre><p>If both fields of <span class="emphasis"><em>timeout</em></span> are 0, then
                            <span class="emphasis"><em>select()</em></span> doesn’t block; it simply polls the
                        specified file descriptors to see which ones are ready and returns
                        immediately. Otherwise, <span class="emphasis"><em>timeout</em></span> specifies an upper
                        limit on the time for which <span class="emphasis"><em>select()</em></span> is to wait.</p><p>Although the <span class="emphasis"><em>timeval</em></span> structure affords microsecond
                        precision, the accuracy of the call is limited by the granularity of the
                        software clock (Section 10.6). SUSv3 specifies that the timeout is rounded
                        upward if it is not an exact multiple of this granularity.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 requires that the maximum permissible timeout interval be at
                            least 31 days. Most UNIX implementations allow a considerably higher
                            limit. Since Linux/x86-32 uses a 32-bit integer for the
                                <span class="emphasis"><em>time_t</em></span> type, the upper limit is many
                            years.</p></div><p>When <span class="emphasis"><em>timeout</em></span> is <code class="literal">NULL</code>, or points to a structure containing nonzero fields,
                            <span class="emphasis"><em>select()</em></span> blocks until one of the following
                        occurs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>at least one of the file descriptors specified in
                                    <span class="emphasis"><em>readfds</em></span>, <span class="emphasis"><em>writefds</em></span>, or
                                    <span class="emphasis"><em>exceptfds</em></span> becomes ready;</p></li><li class="listitem"><p>the call is interrupted by a signal handler; or</p></li><li class="listitem"><p>the amount of time specified by <span class="emphasis"><em>timeout</em></span> has
                                passed.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>In older UNIX implementations that lacked a sleep call with subsecond
                            precision (e.g., <span class="emphasis"><em>nanosleep()</em></span>),
                                <span class="emphasis"><em>select()</em></span> was used to emulate this functionality
                            by specifying <span class="emphasis"><em>nfds</em></span> as 0;
                                <span class="emphasis"><em>readfds</em></span>, <span class="emphasis"><em>writefds</em></span>, and
                                <span class="emphasis"><em>exceptfds</em></span> as <code class="literal">NULL</code>; and the desired sleep interval in
                                <span class="emphasis"><em>timeout</em></span>.</p></div><p>On Linux, if <span class="emphasis"><em>select()</em></span> returns because one or more
                        file descriptors became ready, and if <span class="emphasis"><em>timeout</em></span> was
                            non-<code class="literal">NULL</code>, then
                            <span class="emphasis"><em>select()</em></span> updates the structure to which
                            <span class="emphasis"><em>timeout</em></span> points to indicate how much time remained
                        until the call would have timed out. However, this behavior is
                        implementation-specific. SUSv3 also allows the possibility that an
                        implementation leaves the structure pointed to by
                            <span class="emphasis"><em>timeout</em></span> unchanged, and most other UNIX
                        implementations <span class="emphasis"><em>don’t</em></span> modify this structure. Portable
                        applications that employ <span class="emphasis"><em>select()</em></span> within a loop should
                        always ensure that the structure pointed to by <span class="emphasis"><em>timeout</em></span>
                        is initialized before each <span class="emphasis"><em>select()</em></span> call, and should
                        ignore the information returned in the structure after the call.</p><p>SUSv3 states that the structure pointed to by <span class="emphasis"><em>timeout</em></span>
                        may be modified only on a successful return from
                            <span class="emphasis"><em>select()</em></span>. However, on Linux, if
                            <span class="emphasis"><em>select()</em></span> is interrupted by a signal handler (so
                        that it fails with the error <code class="literal">EINTR</code>), then
                        the structure is modified to indicate the time remaining until a timeout
                        would have occurred (i.e., like a successful return).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If we use the Linux-specific <span class="emphasis"><em>personality()</em></span> system
                            call to set a personality that includes the <code class="literal">STICKY_TIMEOUTS</code> personality bit, then
                                <span class="emphasis"><em>select()</em></span> doesn’t modify the structure pointed
                            to by <span class="emphasis"><em>timeout</em></span>.<a id="IDX-CHP-63-8583" class="indexterm"/></p></div></div><div class="sect3" title="Return value from select()"><div class="titlepage"><div><div><h4 class="title" id="return_value_from_select_open_parenthesi">Return value from <span class="emphasis"><em>select()</em></span></h4></div></div></div><p>As its function result, <span class="emphasis"><em>select()</em></span> returns one of the
                            following:<a id="IDX-CHP-63-8584" class="indexterm"/><a id="IDX-CHP-63-8585" class="indexterm"/><a id="IDX-CHP-63-8586" class="indexterm"/><a id="IDX-CHP-63-8587" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A return value of -1 indicates that an error occurred. Possible
                                errors include <code class="literal">EBADF</code> and <code class="literal">EINTR</code>. <code class="literal">EBADF</code> indicates that one of the file descriptors in
                                    <code class="literal">readfds</code>,
                                    <span class="emphasis"><em>writefds</em></span>, or <span class="emphasis"><em>exceptfds</em></span>
                                is invalid (e.g., not currently open). <code class="literal">EINTR</code>, indicates that the call was interrupted by a
                                signal handler. (As noted in Section 21.5,
                                    <span class="emphasis"><em>select()</em></span> is never automatically restarted
                                if interrupted by a signal handler.)</p></li><li class="listitem"><p>A return value of 0 means that the call timed out before any file
                                descriptor became ready. In this case, each of the returned file
                                descriptor sets will be empty.</p></li><li class="listitem"><p>A positive return value indicates that one or more file
                                descriptors is ready. The return value is the number of ready
                                descriptors. In this case, each of the returned file descriptor sets
                                must be examined (using <code class="literal">FD_ISSET()</code>) in order to find out which I/O events
                                occurred. If the same file descriptor is specified in more than one
                                of <span class="emphasis"><em>readfds</em></span>, <span class="emphasis"><em>writefds</em></span>, and
                                    <span class="emphasis"><em>exceptfds</em></span>, it is counted multiple times if
                                it is ready for more than one event. In other words,
                                    <span class="emphasis"><em>select()</em></span> returns the total number of file
                                descriptors marked as ready in all three returned sets.</p></li></ul></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id77">Example program</h4></div></div></div><p>The program in <a class="xref" href="ch63.html#using_select_open_parenthesis_close_pare" title="Example 63-1. Using select() to monitor multiple file descriptors">Example 63-1</a>
                        demonstrates the use of <span class="emphasis"><em>select()</em></span>. Using command-line
                        arguments, we can specify the <span class="emphasis"><em>timeout</em></span> and the file
                        descriptors that we wish to monitor. The first command-line argument
                        specifies the <span class="emphasis"><em>timeout</em></span> for
                        <span class="emphasis"><em>select()</em></span>, in seconds. If a hyphen (-) is specified
                        here, then <span class="emphasis"><em>select()</em></span> is called with a timeout of
                            <code class="literal">NULL</code>, meaning block indefinitely.
                        Each of the remaining command-line arguments specifies the number of a file
                        descriptor to be monitored, followed by letters indicating the operations
                        for which the descriptor is to be checked. The letters we can specify here
                        are <span class="emphasis"><em>r</em></span> (ready for read) and <span class="emphasis"><em>w</em></span>
                        (ready for write).<a id="IDX-CHP-63-8588" class="indexterm"/><a id="IDX-CHP-63-8589" class="indexterm"/><a id="IDX-CHP-63-8590" class="indexterm"/></p><div class="example"><a id="using_select_open_parenthesis_close_pare"/><div class="example-title">Example 63-1. Using <span class="emphasis"><em>select()</em></span> to monitor multiple file
                            descriptors</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>altio/t_select.c</code></strong>
#include &lt;sys/time.h&gt;
#include &lt;sys/select.h&gt;
#include "tlpi_hdr.h"

static void
usageError(const char *progName)
{
    fprintf(stderr, "Usage: %s {timeout|-} fd-num[rw]...\n", progName);
    fprintf(stderr, "    - means infinite timeout; \n");
    fprintf(stderr, "    r = monitor for read\n");
    fprintf(stderr, "    w = monitor for write\n\n");
    fprintf(stderr, "    e.g.: %s - 0rw 1w\n", progName);
    exit(EXIT_FAILURE);
}
int
main(int argc, char *argv[])
{
    fd_set readfds, writefds;
    int ready, nfds, fd, numRead, j;
    struct timeval timeout;
    struct timeval *pto;
    char buf[10];                       /* Large enough to hold "rw\0" */

    if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
        usageError(argv[0]);

    /* Timeout for select() is specified in argv[1] */

    if (strcmp(argv[1], "-") == 0) {
        pto = NULL;                     /* Infinite timeout */
    } else {
        pto = &amp;timeout;
        timeout.tv_sec = getLong(argv[1], 0, "timeout");
        timeout.tv_usec = 0;            /* No microseconds */
    }

    /* Process remaining arguments to build file descriptor sets */

    nfds = 0;
    FD_ZERO(&amp;readfds);
    FD_ZERO(&amp;writefds);

    for (j = 2; j &lt; argc; j++) {
        numRead = sscanf(argv[j], "%d%2[rw]", &amp;fd, buf);
        if (numRead != 2)
            usageError(argv[0]);
        if (fd &gt;= FD_SETSIZE)
            cmdLineErr("file descriptor exceeds limit (%d)\n", FD_SETSIZE);

        if (fd &gt;= nfds)
            nfds = fd + 1;              /* Record maximum fd + 1 */
        if (strchr(buf, 'r') != NULL)
            FD_SET(fd, &amp;readfds);
        if (strchr(buf, 'w') != NULL)
            FD_SET(fd, &amp;writefds);
    }

    /* We've built all of the arguments; now call select() */

    ready = select(nfds, &amp;readfds, &amp;writefds, NULL, pto);
                                        /* Ignore exceptional events */
    if (ready == -1)
        errExit("select");

    /* Display results of select() */

    printf("ready = %d\n", ready);
for (fd = 0; fd &lt; nfds; fd++)
        printf("%d: %s%s\n", fd, FD_ISSET(fd, &amp;readfds) ? "r" : "",
                FD_ISSET(fd, &amp;writefds) ? "w" : "");

    if (pto != NULL)
        printf("timeout after select(): %ld.%03ld\n",
               (long) timeout.tv_sec, (long) timeout.tv_usec / 10000);
    exit(EXIT_SUCCESS);
}
           <strong class="userinput"><code>altio/t_select.c</code></strong></pre></div></div><p>In the following shell session log, we demonstrate the use of the program
                        in <a class="xref" href="ch63.html#using_select_open_parenthesis_close_pare" title="Example 63-1. Using select() to monitor multiple file descriptors">Example 63-1</a>. In the first
                        example, we make a request to monitor file descriptor 0 for input with a
                        10-second <span class="emphasis"><em>timeout</em></span>:</p><a id="I_programlisting63_d1e167878"/><pre class="programlisting">$ <strong class="userinput"><code>./t_select 10 0r</code></strong>
<em class="lineannotation"><span class="lineannotation">Press Enter, so that a line of input is available on file descriptor 0</span></em>
ready = 1
0: r
timeout after select(): 8.003
$                                         <em class="lineannotation"><span class="lineannotation">Next shell prompt is displayed</span></em></pre><p>The above output shows us that <span class="emphasis"><em>select()</em></span> determined
                        that one file descriptor was ready. This was file descriptor 0, which was
                        ready for reading. We can also see that the <span class="emphasis"><em>timeout</em></span> was
                        modified. The final line of output, consisting of just the shell <code class="literal">$</code> prompt, appeared because the
                            <span class="emphasis"><em>t_select</em></span> program didn’t read the newline character
                        that made file descriptor 0 ready, and so that character was read by the
                        shell, which responded by printing another prompt.</p><p>In the next example, we again monitor file descriptor 0 for input, but
                        this time with a <span class="emphasis"><em>timeout</em></span> of 0 seconds:</p><a id="I_programlisting63_d1e167907"/><pre class="programlisting">$ <strong class="userinput"><code>./t_select 0 0r</code></strong>
ready = 0
timeout after select(): 0.000</pre><p>The <span class="emphasis"><em>select()</em></span> call returned immediately, and found no
                        file descriptor was ready.</p><p>In the next example, we monitor two file descriptors: descriptor 0, to see
                        if input is available, and descriptor 1, to see if output is possible. In
                        this case, we specify the <span class="emphasis"><em>timeout</em></span> as <code class="literal">NULL</code> (the first command-line argument is a
                        hyphen), meaning infinity:</p><a id="I_programlisting63_d1e167925"/><pre class="programlisting">$ <strong class="userinput"><code>./t_select - 0r 1w</code></strong>
ready = 1
0:
1: w</pre><p>The <span class="emphasis"><em>select()</em></span> call returned immediately, informing us
                        that output was possible on file descriptor 1.</p></div></div><div class="sect2" title="The poll() System Call"><div class="titlepage"><div><div><h3 class="title" id="the_poll_open_parenthesis_close_parenthe">The <span class="emphasis"><em>poll()</em></span> System Call</h3></div></div></div><p>The <span class="emphasis"><em>poll()</em></span> system call performs a similar task to
                        <span class="emphasis"><em>select()</em></span>. The major difference between the two system
                    calls lies in how we specify the file descriptors to be monitored. With
                        <span class="emphasis"><em>select()</em></span>, we provide three sets, each marked to
                    indicate the file descriptors of interest. With <span class="emphasis"><em>poll()</em></span>, we
                    provide a list of file descriptors, each marked with the set of events of
                        interest.<a id="IDX-CHP-63-8591" class="indexterm"/></p><a id="I_programlisting63_d1e167960"/><pre class="programlisting">#include &lt;poll.h&gt;

int <strong class="userinput"><code>poll</code></strong>(struct pollfd <span class="emphasis"><em>fds</em></span>[], nfds_t <span class="emphasis"><em>nfds</em></span>, int <span class="emphasis"><em>timeout</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of ready file descriptors, 0 on timeout, or -1 on
                        error</p></div><p>The <span class="emphasis"><em>fds</em></span> argument and the <span class="emphasis"><em>pollfd</em></span>
                    array (<span class="emphasis"><em>nfds</em></span>) specify the file descriptors that
                        <span class="emphasis"><em>poll()</em></span> is to monitor. The <span class="emphasis"><em>timeout</em></span>
                    argument can be used to set an upper limit on the time for which
                        <span class="emphasis"><em>poll()</em></span> will block. We describe each of these arguments
                    in detail below.</p><div class="sect3" title="The pollfd array"><div class="titlepage"><div><div><h4 class="title" id="the_pollfd_array">The <span class="emphasis"><em>pollfd</em></span> array</h4></div></div></div><p>The <span class="emphasis"><em>fds</em></span> argument lists the file descriptors to be
                        monitored by <span class="emphasis"><em>poll()</em></span>. This argument is an array of
                            <span class="emphasis"><em>pollfd</em></span> structures, defined as follows:<a id="IDX-CHP-63-8592" class="indexterm"/><a id="IDX-CHP-63-8593" class="indexterm"/><a id="IDX-CHP-63-8594" class="indexterm"/><a id="IDX-CHP-63-8595" class="indexterm"/><a id="IDX-CHP-63-8596" class="indexterm"/><a id="IDX-CHP-63-8597" class="indexterm"/><a id="IDX-CHP-63-8598" class="indexterm"/><a id="IDX-CHP-63-8599" class="indexterm"/><a id="IDX-CHP-63-8600" class="indexterm"/><a id="IDX-CHP-63-8601" class="indexterm"/><a id="IDX-CHP-63-8602" class="indexterm"/><a id="IDX-CHP-63-8603" class="indexterm"/><a id="IDX-CHP-63-8604" class="indexterm"/><a id="IDX-CHP-63-8605" class="indexterm"/><a id="IDX-CHP-63-8606" class="indexterm"/><a id="IDX-CHP-63-8607" class="indexterm"/><a id="IDX-CHP-63-8608" class="indexterm"/><a id="IDX-CHP-63-8609" class="indexterm"/><a id="IDX-CHP-63-8610" class="indexterm"/><a id="IDX-CHP-63-8611" class="indexterm"/><a id="IDX-CHP-63-8612" class="indexterm"/><a id="IDX-CHP-63-8613" class="indexterm"/><a id="IDX-CHP-63-8614" class="indexterm"/><a id="IDX-CHP-63-8615" class="indexterm"/><a id="IDX-CHP-63-8616" class="indexterm"/><a id="IDX-CHP-63-8617" class="indexterm"/><a id="IDX-CHP-63-8618" class="indexterm"/></p><a id="I_programlisting63_d1e168156"/><pre class="programlisting">struct pollfd {
    int   fd;               /* File descriptor */
    short events;           /* Requested events bit mask */
    short revents;          /* Returned events bit mask */
};</pre><p>The <span class="emphasis"><em>nfds</em></span> arguments specifies the number of items in
                        the <span class="emphasis"><em>fds</em></span> array. The <span class="emphasis"><em>nfds_t</em></span> data
                        type used to type the <span class="emphasis"><em>nfds</em></span> argument is an unsigned
                        integer type.<a id="IDX-CHP-63-8619" class="indexterm"/></p><p>The <span class="emphasis"><em>events</em></span> and <span class="emphasis"><em>revents</em></span> fields of
                        the <span class="emphasis"><em>pollfd</em></span> structure are bit masks. The caller
                        initializes <span class="emphasis"><em>events</em></span> to specify the events to be
                        monitored for the file descriptor <span class="emphasis"><em>fd</em></span>. Upon return from
                            <span class="emphasis"><em>poll()</em></span>, <span class="emphasis"><em>revents</em></span> is set to
                        indicate which of those events actually occurred for this file
                            descriptor.<a id="IDX-CHP-63-8620" class="indexterm"/></p><p><a class="xref" href="ch63.html#bit-mask_values_for_events_and_revents_f" title="Table 63-2. Bit-mask values for events and revents fields of the pollfd structure">Table 63-2</a> lists the bits
                        that may appear in the <span class="emphasis"><em>events</em></span> and
                            <span class="emphasis"><em>revents</em></span> fields. The first group of bits in this
                        table (<code class="literal">POLLIN</code>, <code class="literal">POLLRDNORM</code>, <code class="literal">POLLRDBAND</code>,
                            <code class="literal">POLLPRI</code>, and <code class="literal">POLLRDHUP</code>) are concerned with input events. The next group of
                        bits (<code class="literal">POLLOUT</code>, <code class="literal">POLLWRNORM</code>, and <code class="literal">POLLWRBAND</code>) are concerned with output events. The third group of
                        bits (<code class="literal">POLLERR</code>, <code class="literal">POLLHUP</code>, and <code class="literal">POLLNVAL</code>) are
                        set in the <span class="emphasis"><em>revents</em></span> field to return additional
                        information about the file descriptor. If specified in the
                            <span class="emphasis"><em>events</em></span> field, these three bits are ignored. The
                        final bit (<code class="literal">POLLMSG</code>) is unused by
                            <span class="emphasis"><em>poll()</em></span> on Linux.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On UNIX implementations providing STREAMS devices, <code class="literal">POLLMSG</code> indicates that a message
                            containing a <code class="literal">SIGPOLL</code> signal has
                            reached the head of the stream. <code class="literal">POLLMSG</code> is unused on Linux, because Linux doesn’t
                            implement STREAMS.</p></div><div class="table"><a id="bit-mask_values_for_events_and_revents_f"/><div class="table-title">Table 63-2. Bit-mask values for <span class="emphasis"><em>events</em></span> and
                                <span class="emphasis"><em>revents</em></span> fields of the
                                <span class="emphasis"><em>pollfd</em></span> structure</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Bit</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Input in <span class="emphasis"><em>events</em></span>?</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Returned in <span class="emphasis"><em>revents</em></span>?</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                        <p>Description</p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLIN</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Data other than high-priority data can be read</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLRDNORM</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Equivalent to <code class="literal">POLLIN</code></p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLRDBAND</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Priority data can be read (unused on Linux)</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLPRI</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>High-priority data can be read</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLRDHUP</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Shutdown on peer socket</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLOUT</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Normal data can be written</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLWRNORM</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Equivalent to <code class="literal">POLLOUT</code></p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLWRBAND</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Priority data can be written</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLERR</code>
                                        </p>
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>An error has occurred</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLHUP</code>
                                        </p>
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>A hangup has occurred</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLNVAL</code>
                                        </p>
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>File descriptor is not open</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLMSG</code>
                                        </p>
                                    </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; ">
                                        <p>Unused on Linux (and unspecified in SUSv3)</p>
                                    </td></tr></tbody></table></div></div><p>It is permissible to specify <span class="emphasis"><em>events</em></span> as 0 if we are
                        not interested in events on a particular file descriptor. Furthermore,
                        specifying a negative value for the <span class="emphasis"><em>fd</em></span> field (e.g.,
                        negating its value if nonzero) causes the corresponding
                            <span class="emphasis"><em>events</em></span> field to be ignored and the
                            <span class="emphasis"><em>revents</em></span> field always to be returned as 0. Either of
                        these techniques can be used to (perhaps temporarily) disable monitoring of
                        a single file descriptor, without needing to rebuild the entire
                            <span class="emphasis"><em>fds</em></span> list.</p><p>Note the following further points regarding the Linux implementation of
                            <span class="emphasis"><em>poll()</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Although defined as separate bits, <code class="literal">POLLIN</code> and <code class="literal">POLLRDNORM</code> are synonymous.</p></li><li class="listitem"><p>Although defined as separate bits, <code class="literal">POLLOUT</code> and <code class="literal">POLLWRNORM</code> are synonymous.</p></li><li class="listitem"><p><code class="literal">POLLRDBAND</code> is generally unused;
                                that is, it is ignored in the <span class="emphasis"><em>events</em></span> field and
                                not set in <span class="emphasis"><em>revents</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The only place where <code class="literal">POLLRDBAND</code> is set is in code implementing the
                                    (obsolete) DECnet networking protocol.</p></div></li><li class="listitem"><p>Although set for sockets in certain circumstances, <code class="literal">POLLWRBAND</code> conveys no useful
                                information. (There are no circumstances in which <code class="literal">POLLWRBAND</code> is set when <code class="literal">POLLOUT</code> and <code class="literal">POLLWRNORM</code> are not also set.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p><code class="literal">POLLRDBAND</code> and <code class="literal">POLLWRBAND</code> are meaningful on
                                    implementations that provide System V STREAMS (which Linux does
                                    not). Under STREAMS, a message can be assigned a nonzero
                                    priority, and such messages are queued to the receiver in
                                    decreasing order of priority, in a band ahead of normal
                                    (priority 0) messages.</p></div></li><li class="listitem"><p>The <code class="literal">_XOPEN_SOURCE</code> feature test
                                macro must be defined in order to obtain the definitions of the
                                constants <code class="literal">POLLRDNORM</code>, <code class="literal">POLLRDBAND</code>, <code class="literal">POLLWRNORM</code>, and <code class="literal">POLLWRBAND</code> from <code class="literal">&lt;poll.h&gt;</code>.</p></li><li class="listitem"><p><code class="literal">POLLRDHUP</code> is a Linux-specific
                                flag available since kernel 2.6.17. In order to obtain this
                                definition from <code class="literal">&lt;poll.h&gt;</code>, the <code class="literal">_GNU_SOURCE</code> feature test macro must be
                                defined.</p></li><li class="listitem"><p><code class="literal">POLLNVAL</code> is returned if the
                                specified file descriptor was closed at the time of the
                                    <span class="emphasis"><em>poll()</em></span> call.</p></li></ul></div><p>Summarizing the above points, the <span class="emphasis"><em>poll()</em></span> flags of
                        real interest are <code class="literal">POLLIN</code>, <code class="literal">POLLOUT</code>, <code class="literal">POLLPRI</code>, <code class="literal">POLLRDHUP</code>,
                            <code class="literal">POLLHUP</code>, and <code class="literal">POLLERR</code>. We consider the meanings of these flags in greater
                        detail in <a class="xref" href="ch63.html#when_is_a_file_descriptor_ready_question" title="When Is a File Descriptor Ready?">When Is a File Descriptor Ready?</a>.</p></div><div class="sect3" title="The timeout argument"><div class="titlepage"><div><div><h4 class="title" id="the_timeout_argument-id1">The <span class="emphasis"><em>timeout</em></span> argument</h4></div></div></div><p>The <span class="emphasis"><em>timeout</em></span> argument determines the blocking behavior
                        of <span class="emphasis"><em>poll()</em></span> as follows:<a id="IDX-CHP-63-8621" class="indexterm"/><a id="IDX-CHP-63-8622" class="indexterm"/><a id="IDX-CHP-63-8623" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>timeout</em></span> equals -1, block until one of the
                                file descriptors listed in the <span class="emphasis"><em>fds</em></span> array is
                                ready (as defined by the corresponding <span class="emphasis"><em>events</em></span>
                                field) or a signal is caught.</p></li><li class="listitem"><p>If <span class="emphasis"><em>timeout</em></span> equals 0, do not block—just
                                perform a check to see which file descriptors are ready.</p></li><li class="listitem"><p>If <span class="emphasis"><em>timeout</em></span> is greater than 0, block for up to
                                    <span class="emphasis"><em>timeout</em></span> milliseconds, until one of the file
                                descriptors in <span class="emphasis"><em>fds</em></span> is ready, or until a signal
                                is caught.</p></li></ul></div><p>As with <span class="emphasis"><em>select()</em></span>, the accuracy of
                            <span class="emphasis"><em>timeout</em></span> is limited by the granularity of the
                        software clock (Section 10.6), and SUSv3 specifies that
                            <span class="emphasis"><em>timeout</em></span> is always rounded upward if it is not an
                        exact multiple of the clock granularity.</p></div><div class="sect3" title="Return value from poll()"><div class="titlepage"><div><div><h4 class="title" id="return_value_from_poll_open_parenthesis">Return value from <span class="emphasis"><em>poll()</em></span></h4></div></div></div><p>As its function result, <span class="emphasis"><em>poll()</em></span> returns one of the
                        following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A return value of -1 indicates that an error occurred. One
                                possible error is <code class="literal">EINTR</code>,
                                indicating that the call was interrupted by a signal handler. (As
                                noted in Section 21.5, <span class="emphasis"><em>poll()</em></span> is never
                                automatically restarted if interrupted by a signal handler.)</p></li><li class="listitem"><p>A return of 0 means that the call timed out before any file
                                descriptor became ready.</p></li><li class="listitem"><p>A positive return value indicates that one or more file
                                descriptors are ready. The returned value is the number of
                                    <span class="emphasis"><em>pollfd</em></span> structures in the
                                    <span class="emphasis"><em>fds</em></span> array that have a nonzero
                                    <span class="emphasis"><em>revents</em></span> field.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Note the slightly different meaning of a positive return value from
                                <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>. The
                                <span class="emphasis"><em>select()</em></span> system call counts a file descriptor
                            multiple times if it occurs in more than one returned file descriptor
                            set. The <span class="emphasis"><em>poll()</em></span> system call returns a count of
                            ready file descriptors, and a file descriptor is counted only once, even
                            if multiple bits are set in the corresponding
                                <span class="emphasis"><em>revents</em></span> field.</p></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id78">Example program</h4></div></div></div><p><a class="xref" href="ch63.html#using_poll_open_parenthesis_close_parent" title="Example 63-2. Using poll() to monitor multiple file descriptors">Example 63-2</a> provides a
                        simple demonstration of the use of <span class="emphasis"><em>poll()</em></span>. This program
                        creates a number of pipes (each pipe uses a consecutive pair of file
                        descriptors), writes bytes to the write ends of randomly selected pipes, and
                        then performs a <span class="emphasis"><em>poll()</em></span> to see which pipes have data
                        available for reading.<a id="IDX-CHP-63-8624" class="indexterm"/></p><p>The following shell session shows an example of what we see when running
                        this program. The command-line arguments to the program specify that ten
                        pipes should be created, and writes should be made to three randomly
                        selected pipes.</p><a id="I_programlisting63_d1e168766"/><pre class="programlisting">$ <strong class="userinput"><code>./poll_pipes 10 3</code></strong>
Writing to fd:   4 (read fd:   3)
Writing to fd:  14 (read fd:  13)
Writing to fd:  14 (read fd:  13)
poll() returned: 2
Readable:   3
Readable:  13</pre><p>From the above output, we can see that <span class="emphasis"><em>poll()</em></span> found
                        two pipes had data available for reading.</p><div class="example"><a id="using_poll_open_parenthesis_close_parent"/><div class="example-title">Example 63-2. Using <span class="emphasis"><em>poll()</em></span> to monitor multiple file
                            descriptors</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>altio/poll_pipes.c</code></strong>
#include &lt;time.h&gt;
#include &lt;poll.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int numPipes, j, ready, randPipe, numWrites;
    int (*pfds)[2];                     /* File descriptors for all pipes */
    struct pollfd *pollFd;

    if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s num-pipes [num-writes]\n", argv[0]);

    /* Allocate the arrays that we use. The arrays are sized according
       to the number of pipes specified on command line */

    numPipes = getInt(argv[1], GN_GT_0, "num-pipes");

    pfds = calloc(numPipes, sizeof(int [2]));
    if (pfds == NULL)
        errExit("malloc");
    pollFd = calloc(numPipes, sizeof(struct pollfd));
    if (pollFd == NULL)
        errExit("malloc");

    /* Create the number of pipes specified on command line */

    for (j = 0; j &lt; numPipes; j++)
        if (pipe(pfds[j]) == -1)
            errExit("pipe %d", j);

    /* Perform specified number of writes to random pipes */

    numWrites = (argc &gt; 2) ? getInt(argv[2], GN_GT_0, "num-writes") : 1;

    srandom((int) time(NULL));
    for (j = 0; j &lt; numWrites; j++) {
        randPipe = random() % numPipes;
        printf("Writing to fd: %3d (read fd: %3d)\n",
                pfds[randPipe][1], pfds[randPipe][0]);
        if (write(pfds[randPipe][1], "a", 1) == -1)
            errExit("write %d", pfds[randPipe][1]);
    }

    /* Build the file descriptor list to be supplied to poll(). This list
       is set to contain the file descriptors for the read ends of all of
       the pipes. */

    for (j = 0; j &lt; numPipes; j++) {
        pollFd[j].fd = pfds[j][0];
        pollFd[j].events = POLLIN;
    }

    ready = poll(pollFd, numPipes, -1);         /* Nonblocking */
    if (ready == -1)
        errExit("poll");

    printf("poll() returned: %d\n", ready);

    /* Check which pipes have data available for reading */

    for (j = 0; j &lt; numPipes; j++)
        if (pollFd[j].revents &amp; POLLIN)
            printf("Readable: %d %3d\n", j, pollFd[j].fd);

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>altio/poll_pipes.c</code></strong></pre></div></div></div></div><div class="sect2" title="When Is a File Descriptor Ready?"><div class="titlepage"><div><div><h3 class="title" id="when_is_a_file_descriptor_ready_question">When Is a File Descriptor Ready?</h3></div></div></div><p>Correctly using <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                    requires an understanding of the conditions under which a file descriptor
                    indicates as being ready. SUSv3 says that a file descriptor (with <code class="literal">O_NONBLOCK</code> clear) is considered to be ready if a
                    call to an I/O function would not block, <span class="emphasis"><em>regardless of whether the
                        function would actually transfer data</em></span>. The key point is
                    italicized: <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> tell
                    us whether an I/O operation would not block, rather than whether it would
                    successfully transfer data. In this light, let us consider how these system
                    calls operate for different types of file descriptors. We show this information
                    in tables containing two columns:<a id="IDX-CHP-63-8625" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>select()</em></span> column indicates whether a file
                            descriptor is marked as readable (<code class="literal">r</code>),
                            writable (<code class="literal">w</code>), or having an
                            exceptional condition (<code class="literal">x</code>).</p></li><li class="listitem"><p>The <span class="emphasis"><em>poll()</em></span> column indicates the bit(s) returned
                            in the <span class="emphasis"><em>revents</em></span> field. In these tables, we omit
                            mention of <code class="literal">POLLRDNORM</code>, <code class="literal">POLLWRNORM</code>, <code class="literal">POLLRDBAND</code>, and <code class="literal">POLLWRBAND</code>. Although some of these flags may be returned
                            in <span class="emphasis"><em>revents</em></span> in various circumstances (if they are
                            specified in <span class="emphasis"><em>events</em></span>), they convey no useful
                            information beyond that provided by <code class="literal">POLLIN</code>, <code class="literal">POLLOUT</code>,
                                <code class="literal">POLLHUP</code>, and <code class="literal">POLLERR</code>.</p></li></ul></div><div class="sect3" title="Regular files"><div class="titlepage"><div><div><h4 class="title" id="regular_files">Regular files</h4></div></div></div><p>File descriptors that refer to regular files are always marked as readable
                        and writable by <span class="emphasis"><em>select()</em></span>, and returned with <code class="literal">POLLIN</code> and <code class="literal">POLLOUT</code> set in <span class="emphasis"><em>revents</em></span> for
                            <span class="emphasis"><em>poll()</em></span>, for the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="emphasis"><em>read()</em></span> will always immediately return data,
                                end-of-file, or an error (e.g., the file was not opened for
                                reading).</p></li><li class="listitem"><p>A <span class="emphasis"><em>write()</em></span> will always immediately transfer
                                data or fail with some error.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 says that <span class="emphasis"><em>select()</em></span> should also mark a
                            descriptor for a regular file as having an exceptional condition (though
                            this has no obvious meaning for regular files). Only some
                            implementations do this; Linux is one of those that do not.</p></div></div><div class="sect3" title="Terminals and pseudoterminals"><div class="titlepage"><div><div><h4 class="title" id="terminals_and_pseudoterminals">Terminals and pseudoterminals</h4></div></div></div><p><a class="xref" href="ch63.html#select_open_parenthesis_close_parenthesi" title="Table 63-3. select() and poll() indications for terminals and pseudoterminals">Table 63-3</a> summarizes the
                        behavior of <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                        for terminals and pseudoterminals (<a class="xref" href="ch64.html" title="Chapter 64. Pseudoterminals">Chapter 64</a>).<a id="IDX-CHP-63-8626" class="indexterm"/><a id="IDX-CHP-63-8627" class="indexterm"/><a id="IDX-CHP-63-8628" class="indexterm"/><a id="IDX-CHP-63-8629" class="indexterm"/><a id="IDX-CHP-63-8630" class="indexterm"/><a id="IDX-CHP-63-8631" class="indexterm"/><a id="IDX-CHP-63-8632" class="indexterm"/><a id="IDX-CHP-63-8633" class="indexterm"/><a id="IDX-CHP-63-8634" class="indexterm"/><a id="IDX-CHP-63-8635" class="indexterm"/><a id="IDX-CHP-63-8636" class="indexterm"/><a id="IDX-CHP-63-8637" class="indexterm"/><a id="IDX-CHP-63-8638" class="indexterm"/><a id="IDX-CHP-63-8639" class="indexterm"/><a id="IDX-CHP-63-8640" class="indexterm"/></p><p>When one half of a pseudoterminal pair is closed, the
                            <span class="emphasis"><em>revents</em></span> setting returned by
                            <span class="emphasis"><em>poll()</em></span> for the other half of the pair depends on
                        the implementation. On Linux, at least the <code class="literal">POLLHUP</code> flag is set. However, other implementations return
                        various flags to indicate this event—for example, <code class="literal">POLLHUP</code>, <code class="literal">POLLERR</code>, or
                            <code class="literal">POLLIN</code>. Furthermore, on some
                        implementations, the flags that are set depend on whether it is the master
                        or the slave device that is being monitored.</p><div class="table"><a id="select_open_parenthesis_close_parenthesi"/><div class="table-title">Table 63-3. <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                            indications for terminals and pseudoterminals</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Condition or event</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>select()</em></span>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>poll()</em></span>
                                        </p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Input available</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">r</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLIN</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Output possible</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">w</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLOUT</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>After <span class="emphasis"><em>close()</em></span> by pseudoterminal
                                            peer</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">rw</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>See text</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>Pseudoterminal master in packet mode detects slave
                                            state change<a id="IDX-CHP-63-8641" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">x</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>
                                            <code class="literal">POLLPRI</code>
                                        </p>
                                    </td></tr></tbody></table></div></div></div><div class="sect3" title="Pipes and FIFOs"><div class="titlepage"><div><div><h4 class="title" id="pipes_and_fifos-id1">Pipes and FIFOs</h4></div></div></div><p><a class="xref" href="ch63.html#select_open_parenthesis_close_parent" title="Table 63-4. select() and poll() indications for the read end of a pipe or FIFO">Table 63-4</a> summarizes the
                        details for the read end of a pipe or FIFO. The <span class="emphasis"><em>Data in
                            pipe?</em></span> column indicates whether the pipe has at least 1 byte
                        of data available for reading. In this table, we assume that <code class="literal">POLLIN</code> was specified in the
                            <span class="emphasis"><em>events</em></span> field for
                        <span class="emphasis"><em>poll()</em></span>.</p><p>On some other UNIX implementations, if the write end of a pipe is closed,
                        then, instead of returning with <code class="literal">POLLHUP</code>
                        set, <span class="emphasis"><em>poll()</em></span> returns with the <code class="literal">POLLIN</code> bit set (since a <span class="emphasis"><em>read()</em></span> will
                        return immediately with end-of-file). Portable applications should check to
                        see if either bit is set in order to know if a <span class="emphasis"><em>read()</em></span>
                        will block.</p><p><a class="xref" href="ch63.html#select_open_parenthesis_close_paren" title="Table 63-5. select() and poll() indications for the write end of a pipe or FIFO">Table 63-5</a> summarizes the
                        details for the write end of a pipe. In this table, we assume that <code class="literal">POLLOUT</code> was specified in the
                            <span class="emphasis"><em>events</em></span> field for <span class="emphasis"><em>poll()</em></span>. The
                            <span class="emphasis"><em>Space for PIPE_BUF bytes?</em></span> column indicates whether
                        the pipe has room to atomically write <code class="literal">PIPE_BUF</code> bytes without blocking. This is the criterion on
                        which Linux considers a pipe ready for writing. Some other UNIX
                        implementations use the same criterion; others consider a pipe writable if
                        even a single byte can be written. (In Linux 2.6.10 and earlier, the
                        capacity of a pipe is the same as <code class="literal">PIPE_BUF</code>. This means that a pipe is considered unwritable if
                        it contains even a single byte of data.)</p><p>On some other UNIX implementations, if the read end of a pipe is closed,
                        then, instead of returning with <code class="literal">POLLERR</code>
                        set, <span class="emphasis"><em>poll()</em></span> returns with either the <code class="literal">POLLOUT</code> bit or the <code class="literal">POLLHUP</code> bit set. Portable applications need to check to see
                        if any of these bits is set to determine if a <span class="emphasis"><em>write()</em></span>
                        will block.</p><div class="table"><a id="select_open_parenthesis_close_parent"/><div class="table-title">Table 63-4. <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                            indications for the read end of a pipe or FIFO</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " colspan="2">
                                        <p>Condition or event</p>
                                    </td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; " rowspan="2">
                                        <p>
                                            <span class="emphasis"><em>select()</em></span>
                                        </p>
                                    </td><td style="text-align: center; vertical-align: bottom; " rowspan="2">
                                        <p>
                                            <span class="emphasis"><em>poll()</em></span>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Data in pipe?</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Write end open?</p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>no</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>no</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">r</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLHUP</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>yes</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>yes</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">r</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLIN</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>yes</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>no</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">r</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>
                                            <code class="literal">POLLIN | POLLHUP</code>
                                        </p>
                                    </td></tr></tbody></table></div></div><div class="table"><a id="select_open_parenthesis_close_paren"/><div class="table-title">Table 63-5. <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                            indications for the write end of a pipe or FIFO</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " colspan="2">
                                        <p>Condition or event</p>
                                    </td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; " rowspan="2">
                                        <p>
                                            <span class="emphasis"><em>select()</em></span>
                                        </p>
                                    </td><td style="text-align: center; vertical-align: bottom; " rowspan="2">
                                        <p>
                                            <span class="emphasis"><em>poll()</em></span>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Space for <code class="literal">PIPE_BUF</code>
                                            bytes?</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Read end open?</p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>no</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>no</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">w</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLERR</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>yes</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>yes</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">w</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLOUT</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>yes</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>no</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">w</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>
                                            <code class="literal">POLLOUT | POLLERR</code>
                                        </p>
                                    </td></tr></tbody></table></div></div></div><div class="sect3" title="Sockets"><div class="titlepage"><div><div><h4 class="title" id="sockets">Sockets</h4></div></div></div><p><a class="xref" href="ch63.html#select_open_parenthesis_close_paren-id1" title="Table 63-6. select() and poll() indications for sockets">Table 63-6</a> summarizes the
                        behavior of <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                        for sockets. For the <span class="emphasis"><em>poll()</em></span> column, we assume that
                            <span class="emphasis"><em>events</em></span> was specified as <code class="literal">(POLLIN | POLLOUT | POLLPRI)</code>. For the
                            <span class="emphasis"><em>select()</em></span> column, we assume that the file descriptor
                        is being tested to see if input is possible, output is possible, or an
                        exceptional condition occurred (i.e., the file descriptor is specified in
                        all three sets passed to <span class="emphasis"><em>select()</em></span>). This table covers
                        just the common cases, not all possible scenarios.<a id="IDX-CHP-63-8642" class="indexterm"/><a id="IDX-CHP-63-8643" class="indexterm"/><a id="IDX-CHP-63-8644" class="indexterm"/><a id="IDX-CHP-63-8645" class="indexterm"/><a id="IDX-CHP-63-8646" class="indexterm"/><a id="IDX-CHP-63-8647" class="indexterm"/><a id="IDX-CHP-63-8648" class="indexterm"/><a id="IDX-CHP-63-8649" class="indexterm"/><a id="IDX-CHP-63-8650" class="indexterm"/><a id="IDX-CHP-63-8651" class="indexterm"/><a id="IDX-CHP-63-8652" class="indexterm"/><a id="IDX-CHP-63-8653" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The Linux <span class="emphasis"><em>poll()</em></span> behavior for UNIX domain sockets
                            after a peer <span class="emphasis"><em>close()</em></span> differs from that shown in
                                <a class="xref" href="ch63.html#select_open_parenthesis_close_paren-id1" title="Table 63-6. select() and poll() indications for sockets">Table 63-6</a>. As well
                            as the other flags, <span class="emphasis"><em>poll()</em></span> additionally returns
                                <code class="literal">POLLHUP</code> in
                                <span class="emphasis"><em>revents</em></span>.</p></div><div class="table"><a id="select_open_parenthesis_close_paren-id1"/><div class="table-title">Table 63-6. <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                            indications for sockets</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Condition or event</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>select()</em></span>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>poll()</em></span>
                                        </p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Input available</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">r</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLIN</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Output possible</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">w</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLOUT</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Incoming connection established on listening
                                            socket</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">r</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLIN</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Out-of-band data received (TCP only)</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">x</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">POLLPRI</code>
                                        </p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>Stream socket peer closed connection or executed
                                                <span class="emphasis"><em>shutdown(SHUT_WR)</em></span></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">rw</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>
                                            <code class="literal">POLLIN | POLLOUT |
                                                POLLRDHUP</code>
                                        </p>
                                    </td></tr></tbody></table></div></div><p>The Linux-specific <code class="literal">POLLRDHUP</code> flag
                        (available since Linux 2.6.17) needs a little further explanation. This
                        flag—actually in the form of <code class="literal">EPOLLRDHUP</code>—is designed primarily for use with the edge-triggered
                        mode of the <span class="emphasis"><em>epoll</em></span> API (Section 63.4). It is returned
                        when the remote end of a stream socket connection has shut down the writing
                        half of the connection. The use of this flag allows an application that uses
                        the <span class="emphasis"><em>epoll</em></span> edge-triggered interface to employ simpler
                        code to recognize a remote shutdown. (The alternative is for the application
                        to note that the <code class="literal">POLLIN</code> flag is set and
                        then perform a <span class="emphasis"><em>read()</em></span>, which indicates the remote
                        shutdown with a return of 0.)</p></div></div><div class="sect2" title="Comparison of select() and poll()"><div class="titlepage"><div><div><h3 class="title" id="comparison_of_select_open_parenthesis_cl">Comparison of <span class="emphasis"><em>select()</em></span> and
                    <span class="emphasis"><em>poll()</em></span></h3></div></div></div><p>In this section, we consider some similarities and differences between
                        <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>.<a id="IDX-CHP-63-8654" class="indexterm"/><a id="IDX-CHP-63-8655" class="indexterm"/><a id="IDX-CHP-63-8656" class="indexterm"/></p><div class="sect3" title="Implementation details"><div class="titlepage"><div><div><h4 class="title" id="implementation_details">Implementation details</h4></div></div></div><p>Within the Linux kernel, <span class="emphasis"><em>select()</em></span> and
                            <span class="emphasis"><em>poll()</em></span> both employ the same set of kernel-internal
                            <span class="emphasis"><em>poll</em></span> routines. These <span class="emphasis"><em>poll</em></span>
                        routines are distinct from the <span class="emphasis"><em>poll()</em></span> system call
                        itself. Each routine returns information about the readiness of a single
                        file descriptor. This readiness information takes the form of a bit mask
                        whose values correspond to the bits returned in the
                            <span class="emphasis"><em>revents</em></span> field by the <span class="emphasis"><em>poll()</em></span>
                        system call (<a class="xref" href="ch63.html#bit-mask_values_for_events_and_revents_f" title="Table 63-2. Bit-mask values for events and revents fields of the pollfd structure">Table 63-2</a>).
                        The implementation of the <span class="emphasis"><em>poll()</em></span> system call involves
                        calling the kernel <span class="emphasis"><em>poll</em></span> routine for each file
                        descriptor and placing the resulting information in the corresponding
                            <span class="emphasis"><em>revents</em></span> field.</p><p>To implement <span class="emphasis"><em>select()</em></span>, a set of macros is used to
                        convert the information returned by the kernel <span class="emphasis"><em>poll</em></span>
                        routines into the corresponding event types returned by
                            <span class="emphasis"><em>select()</em></span>:</p><a id="I_programlisting63_d1e169668"/><pre class="programlisting">#define POLLIN_SET  (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)
                                     /* Ready for reading */
#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)
                                     /* Ready for writing */
#define POLLEX_SET  (POLLPRI)        /* Exceptional condition */</pre><p>These macro definitions reveal the semantic correspondence between the
                        information returned by <span class="emphasis"><em>select()</em></span> and
                            <span class="emphasis"><em>poll()</em></span>. (If we look at the
                            <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> columns in
                        the tables in <a class="xref" href="ch63.html#when_is_a_file_descriptor_ready_question" title="When Is a File Descriptor Ready?">When Is a File Descriptor Ready?</a>, we
                        see that the indications provided by each system call are consistent with
                        the above macros.) The only additional information we need to complete the
                        picture is that <span class="emphasis"><em>poll()</em></span> returns <code class="literal">POLLNVAL</code> in the <span class="emphasis"><em>revents</em></span> field if one of
                        the monitored file descriptors was closed at the time of the call, while
                            <span class="emphasis"><em>select()</em></span> returns -1 with <span class="emphasis"><em>errno</em></span>
                        set to <code class="literal">EBADF</code>.</p></div><div class="sect3" title="API differences"><div class="titlepage"><div><div><h4 class="title" id="api_differences">API differences</h4></div></div></div><p>The following are some differences between the
                            <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>
                        APIs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The use of the <span class="emphasis"><em>fd_set</em></span> data type places an
                                upper limit (<code class="literal">FD_SETSIZE</code>) on the
                                range of file descriptors that can be monitored by
                                    <span class="emphasis"><em>select()</em></span>. By default, this limit is 1024 on
                                Linux, and changing it requires recompiling the application. By
                                contrast, <span class="emphasis"><em>poll()</em></span> places no intrinsic limit on
                                the range of file descriptors that can be monitored.<a id="IDX-CHP-63-8657" class="indexterm"/></p></li><li class="listitem"><p>Because the <span class="emphasis"><em>fd_set</em></span> arguments of
                                    <span class="emphasis"><em>select()</em></span> are value-result, we must
                                reinitialize them if making repeated <span class="emphasis"><em>select()</em></span>
                                calls from within a loop. By using separate
                                    <span class="emphasis"><em>events</em></span> (input) and
                                    <span class="emphasis"><em>revents</em></span> (output) fields,
                                    <span class="emphasis"><em>poll()</em></span> avoids this requirement.</p></li><li class="listitem"><p>The <span class="emphasis"><em>timeout</em></span> precision afforded by
                                    <span class="emphasis"><em>select()</em></span> (microseconds) is greater than
                                that afforded by <span class="emphasis"><em>poll()</em></span> (milliseconds). (The
                                accuracy of the timeouts of both of these system calls is
                                nevertheless limited by the software clock granularity.)</p></li><li class="listitem"><p>If one of the file descriptors being monitored was closed, then
                                    <span class="emphasis"><em>poll()</em></span> informs us exactly which one, via
                                the <code class="literal">POLLNVAL</code> bit in the
                                corresponding <span class="emphasis"><em>revents</em></span> field. By contrast,
                                    <span class="emphasis"><em>select()</em></span> merely returns -1 with
                                    <span class="emphasis"><em>errno</em></span> set to <code class="literal">EBADF</code>, leaving us to determine which file descriptor
                                is closed by checking for an error when performing an I/O system
                                call on the descriptor. However, this is typically not an important
                                difference, since an application can usually keep track of which
                                file descriptors it has closed.</p></li></ul></div></div><div class="sect3" title="Portability"><div class="titlepage"><div><div><h4 class="title" id="portability-id1">Portability</h4></div></div></div><p>Historically, <span class="emphasis"><em>select()</em></span> was more widely available than
                            <span class="emphasis"><em>poll()</em></span>. Nowadays, both interfaces are standardized
                        by SUSv3 and widely available on contemporary implementations. However,
                        there is some variation in the behavior of <span class="emphasis"><em>poll()</em></span>
                        across implementations, as noted in <a class="xref" href="ch63.html#when_is_a_file_descriptor_ready_question" title="When Is a File Descriptor Ready?">When Is a File Descriptor Ready?</a>.<a id="IDX-CHP-63-8658" class="indexterm"/></p></div><div class="sect3" title="Performance"><div class="titlepage"><div><div><h4 class="title" id="performance-id1">Performance</h4></div></div></div><p>The performance of <span class="emphasis"><em>poll()</em></span> and
                            <span class="emphasis"><em>select()</em></span> is similar if either of the following is
                        true:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The range of file descriptors to be monitored is small (i.e., the
                                maximum file descriptor number is low).</p></li><li class="listitem"><p>A large number of file descriptors are being monitored, but they
                                are densely packed (i.e., most or all of the file descriptors from 0
                                up to some limit are being monitored).</p></li></ul></div><p>However, the performance of <span class="emphasis"><em>select()</em></span> and
                            <span class="emphasis"><em>poll()</em></span> can differ noticeably if the set of file
                        descriptors to be monitored is sparse; that is, the maximum file descriptor
                        number, N, is large, but only one or a few descriptors in the range 0 to
                            <span class="emphasis"><em>N</em></span> are being monitored. In this case,
                            <span class="emphasis"><em>poll()</em></span> can perform better than
                            <span class="emphasis"><em>select()</em></span>. We can understand the reasons for this by
                        considering the arguments passed to the two system calls. With
                            <span class="emphasis"><em>select()</em></span>, we pass one or more file descriptor sets
                        and an integer, <span class="emphasis"><em>nfds</em></span>, which is one greater than the
                        maximum file descriptor to be examined in each set. The
                            <span class="emphasis"><em>nfds</em></span> argument has the same value, regardless of
                        whether we are monitoring all file descriptors in the range 0 to
                            <span class="emphasis"><em>(nfds - 1)</em></span> or only the descriptor <span class="emphasis"><em>(nfds -
                            1)</em></span>. In both cases, the kernel must examine
                            <span class="emphasis"><em>nfds</em></span> elements in each set in order to check exactly
                        which file descriptors are to be monitored. By contrast, when using
                            <span class="emphasis"><em>poll()</em></span>, we specify only the file descriptors of
                        interest to us, and the kernel checks only those descriptors.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The difference in performance for <span class="emphasis"><em>poll()</em></span> and
                                <span class="emphasis"><em>select()</em></span> with sparse descriptor sets was quite
                            significant in Linux 2.4. Some optimizations in Linux 2.6 have narrowed
                            the performance gap considerably.</p></div><p>We consider the performance of <span class="emphasis"><em>select()</em></span> and
                            <span class="emphasis"><em>poll()</em></span> further in <a class="xref" href="ch63.html#performance_of_epoll_versus_i_solidus_o" title="Performance of epoll Versus I/O Multiplexing">Performance of <span class="emphasis"><em>epoll</em></span> Versus I/O Multiplexing</a>, where we compare
                        the performance of these system calls against
                        <span class="emphasis"><em>epoll</em></span>.</p></div></div><div class="sect2" title="Problems with select() and poll()"><div class="titlepage"><div><div><h3 class="title" id="problems_with_select_open_parenthesis_cl">Problems with <span class="emphasis"><em>select()</em></span> and
                    <span class="emphasis"><em>poll()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> system calls
                    are the portable, long-standing, and widely used methods of monitoring multiple
                    file descriptors for readiness. However, these APIs suffer some problems when
                    monitoring a large number of file descriptors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On each call to <span class="emphasis"><em>select()</em></span> or
                                <span class="emphasis"><em>poll()</em></span>, the kernel must check all of the
                            specified file descriptors to see if they are ready. When monitoring a
                            large number of file descriptors that are in a densely packed range, the
                            time required for this operation greatly outweighs the time required for
                            the next two operations.</p></li><li class="listitem"><p>In each call to <span class="emphasis"><em>select()</em></span> or
                                <span class="emphasis"><em>poll()</em></span>, the program must pass a data structure
                            to the kernel describing all of the file descriptors to be monitored,
                            and, after checking the descriptors, the kernel returns a modified
                            version of this data structure to the program. (Furthermore, for
                                <span class="emphasis"><em>select()</em></span>, we must initialize the data structure
                            before each call.) For <span class="emphasis"><em>poll()</em></span>, the size of the data
                            structure increases with the number of file descriptors being monitored,
                            and the task of copying it from user to kernel space and back again
                            consumes a noticeable amount of CPU time when monitoring many file
                            descriptors. For <span class="emphasis"><em>select()</em></span>, the size of the data
                            structure is fixed by <code class="literal">FD_SETSIZE</code>,
                            regardless of the number of file descriptors being monitored.</p></li><li class="listitem"><p>After the call to <span class="emphasis"><em>select()</em></span> or
                                <span class="emphasis"><em>poll()</em></span>, the program must inspect every element
                            of the returned data structure to see which file descriptors are
                            ready.</p></li></ul></div><p>The consequence of the above points is that the CPU time required by
                        <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> increases with
                    the number of file descriptors being monitored (see <a class="xref" href="ch63.html#performance_of_epoll_versus_i_solidus_o" title="Performance of epoll Versus I/O Multiplexing">Performance of <span class="emphasis"><em>epoll</em></span> Versus I/O Multiplexing</a> for more details). This
                    creates problems for programs that monitor large numbers of file
                    descriptors.</p><p>The poor scaling performance of <span class="emphasis"><em>select()</em></span> and
                        <span class="emphasis"><em>poll()</em></span> stems from a simple limitation of these APIs:
                    typically, a program makes repeated calls to monitor the same set of file
                    descriptors; however, the kernel doesn’t remember the list of file descriptors
                    to be monitored between successive calls.</p><p>Signal-driven I/O and <span class="emphasis"><em>epoll</em></span>, which we examine in the
                    following sections, are both mechanisms that allow the kernel to record a
                    persistent list of file descriptors in which a process is interested. Doing this
                    eliminates the performance scaling problems of <span class="emphasis"><em>select()</em></span> and
                        <span class="emphasis"><em>poll()</em></span>, yielding solutions that scale according to the
                    number of I/O events that occur, rather than according to the number of file
                    descriptors being monitored. Consequently, signal-driven I/O and
                        <span class="emphasis"><em>epoll</em></span> provide superior performance when monitoring
                    large numbers of file descriptors.<a id="IDX-CHP-63-8659" class="indexterm"/></p></div></div><div class="sect1" title="Signal-Driven I/O"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="signal-driven_i_solidus_o">Signal-Driven I/O</h2></div></div></div><p>With I/O multiplexing, a process makes a system call
                    (<span class="emphasis"><em>select()</em></span> or <span class="emphasis"><em>poll()</em></span>) in order to check
                whether I/O is possible on a file descriptor. With signal-driven I/O, a process
                requests that the kernel send it a signal when I/O is possible on a file descriptor.
                The process can then perform any other activity until I/O is possible, at which time
                the signal is delivered to the process. To use signal-driven I/O, a program performs
                the following steps:<a id="IDX-CHP-63-8660" class="indexterm"/><a id="IDX-CHP-63-8661" class="indexterm"/><a id="IDX-CHP-63-8662" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Establish a handler for the signal delivered by the signal-driven I/O
                        mechanism. By default, this notification signal is <code class="literal">SIGIO</code>.</p></li><li class="listitem"><p>Set the <span class="emphasis"><em>owner</em></span> of the file descriptor—that is, the
                        process or process group that is to receive signals when I/O is possible on
                        the file descriptor. Typically, we make the calling process the owner. The
                        owner is set using an <span class="emphasis"><em>fcntl()</em></span>
                        <code class="literal">F_SETOWN</code> operation of the following
                        form:</p><a id="I_programlisting63_d1e170033"/><pre class="programlisting">fcntl(fd, F_SETOWN, pid);</pre></li><li class="listitem"><p>Enable nonblocking I/O by setting the <code class="literal">O_NONBLOCK</code> open file status flag.</p></li><li class="listitem"><p>Enable signal-driven I/O by turning on the <code class="literal">O_ASYNC</code> open file status flag. This can be combined with the
                        previous step, since they both require the use of the
                            <span class="emphasis"><em>fcntl()</em></span>
                        <code class="literal">F_SETFL</code> operation (Section 5.3), as in
                        the following example:</p><a id="I_programlisting63_d1e170053"/><pre class="programlisting">flags = fcntl(fd, F_GETFL);                 /* Get current flags */
fcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);</pre></li><li class="listitem"><p>The calling process can now perform other tasks. When I/O becomes
                        possible, the kernel generates a signal for the process and invokes the
                        signal handler established in step 1.</p></li><li class="listitem"><p>Signal-driven I/O provides edge-triggered notification (<a class="xref" href="ch63.html#which_technique_question-id1" title="Which technique?">Which technique?</a>). This means that once the process
                        has been notified that I/O is possible, it should perform as much I/O (e.g.,
                        read as many bytes) as possible. Assuming a nonblocking file descriptor,
                        this means executing a loop that performs I/O system calls until a call
                        fails with the error <code class="literal">EAGAIN</code> or <code class="literal">EWOULDBLOCK</code>.</p></li></ol></div><p>On Linux 2.4 and earlier, signal-driven I/O can be employed with file descriptors
                for sockets, terminals, pseudoterminals, and certain other types of devices. Linux
                2.6 additionally allows signal-driven I/O to be employed with pipes and FIFOs. Since
                Linux 2.6.25, signal-driven I/O can also be used with <span class="emphasis"><em>inotify</em></span>
                file descriptors.</p><p>In the following pages, we first present an example of the use of signal-driven
                I/O, and then explain some of the above steps in greater detail.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Historically, signal-driven I/O was sometimes referred to as
                        <span class="emphasis"><em>asynchronous I/O</em></span>, and this is reflected in the name
                        (<code class="literal">O_ASYNC</code>) of the associated open file
                    status flag. However, nowadays, the term <span class="emphasis"><em>asynchronous I/O</em></span>
                    is used to refer to the type of functionality provided by the POSIX AIO
                    specification. Using POSIX AIO, a process requests the kernel to perform an I/O
                    operation, and the kernel <span class="emphasis"><em>initiates</em></span> the operation, but
                    immediately passes control back to the calling process; the process is then
                    later notified when the I/O operation completes or an error occurs.</p><p><code class="literal">O_ASYNC</code> was specified in POSIX.1g, but was
                    not included in SUSv3 because the specification of the required behavior for
                    this flag was deemed insufficient.</p><p>Several UNIX implementations, especially older ones, don’t define the <code class="literal">O_ASYNC</code> constant for use with
                        <span class="emphasis"><em>fcntl()</em></span>. Instead, the constant is named <code class="literal">FASYNC</code>, and <span class="emphasis"><em>glibc</em></span> defines
                    this latter name as a synonym for <code class="literal">O_ASYNC</code>.<a id="IDX-CHP-63-8663" class="indexterm"/></p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_program-id79"/></div></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id80">Example program</h4></div></div></div><p><a class="xref" href="ch63.html#using_signal-driven_i_solidus_o_on_a_ter" title="Example 63-3. Using signal-driven I/O on a terminal">Example 63-3</a> provides a
                        simple example of the use of signal-driven I/O. This program performs the
                        steps described above for enabling signal-driven I/O on standard input, and
                        then places the terminal in cbreak mode (<a class="xref" href="ch62.html#cooked_comma_cbreak_comma_and_raw_modes" title="Cooked, Cbreak, and Raw Modes">Cooked, Cbreak, and Raw Modes</a>), so that input is
                        available a character at a time. The program then enters an infinite loop,
                        performing the “work” of incrementing a variable, <span class="emphasis"><em>cnt</em></span>,
                        while waiting for input to become available. Whenever input becomes
                        available, the <code class="literal">SIGIO</code> handler sets a flag,
                            <span class="emphasis"><em>gotSigio</em></span>, that is monitored by the main program.
                        When the main program sees that this flag is set, it reads all available
                        input characters and prints them along with the current value of
                            <span class="emphasis"><em>cnt</em></span>. If a hash character (<code class="literal">#</code>) is read in the input, the program terminates.<a id="IDX-CHP-63-8664" class="indexterm"/></p><p>Here is an example of what we see when we run this program and type the
                            <span class="emphasis"><em>x</em></span> character a number of times, followed by a hash
                            (<code class="literal">#</code>) character:</p><a id="I_programlisting63_d1e170156"/><pre class="programlisting">$ <strong class="userinput"><code>./demo_sigio</code></strong>
cnt=37; read x
cnt=100; read x
cnt=159; read x
cnt=223; read x
cnt=288; read x
cnt=333; read #</pre><div class="example"><a id="using_signal-driven_i_solidus_o_on_a_ter"/><div class="example-title">Example 63-3. Using signal-driven I/O on a terminal</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>altio/demo_sigio.c</code></strong>
#include &lt;signal.h&gt;
#include &lt;ctype.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;termios.h&gt;
#include "tty_functions.h"      /* Declaration of ttySetCbreak() */
#include "tlpi_hdr.h"

static volatile sig_atomic_t gotSigio = 0;
                                /* Set nonzero on receipt of SIGIO */

static void
sigioHandler(int sig)
{
    gotSigio = 1;
}

int
main(int argc, char *argv[])
{
    int flags, j, cnt;
    struct termios origTermios;
    char ch;
    struct sigaction sa;
    Boolean done;

    /* Establish handler for "I/O possible" signal */

    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = sigioHandler;
    if (sigaction(SIGIO, &amp;sa, NULL) == -1)
        errExit("sigaction");

    /* Set owner process that is to receive "I/O possible" signal */

    if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1)
        errExit("fcntl(F_SETOWN)");

    /* Enable "I/O possible" signaling and make I/O nonblocking
       for file descriptor */

    flags = fcntl(STDIN_FILENO, F_GETFL);
    if (fcntl(STDIN_FILENO, F_SETFL, flags | O_ASYNC | O_NONBLOCK) == -1)
        errExit("fcntl(F_SETFL)");

    /* Place terminal in cbreak mode */

    if (ttySetCbreak(STDIN_FILENO, &amp;origTermios) == -1)
        errExit("ttySetCbreak");

    for (done = FALSE, cnt = 0; !done ; cnt++) {
        for (j = 0; j &lt; 100000000; j++)
            continue;                   /* Slow main loop down a little */

        if (gotSigio) {                 /* Is input available? */

            /* Read all available input until error (probably EAGAIN)
               or EOF (not actually possible in cbreak mode) or a
               hash (#) character is read */

            while (read(STDIN_FILENO, &amp;ch, 1) &gt; 0 &amp;&amp; !done) {
                printf("cnt=%d; read %c\n", cnt, ch);
                done = ch == '#';
            }

            gotSigio = 0;
        }
    }

    /* Restore original terminal settings */

    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;origTermios) == -1)
        errExit("tcsetattr");
    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>altio/demo_sigio.c</code></strong></pre></div></div></div><div class="sect3" title="Establish the signal handler before enabling signal-driven I/O"><div class="titlepage"><div><div><h4 class="title" id="establish_the_signal_handler_before_enab">Establish the signal handler before enabling signal-driven I/O</h4></div></div></div><p>Because the default action of <code class="literal">SIGIO</code> is
                        to terminate the process, we should enable the handler for <code class="literal">SIGIO</code> before enabling signal-driven I/O on a
                        file descriptor. If we enable signal-driven I/O before establishing the
                            <code class="literal">SIGIO</code> handler, then there is a time
                        window during which, if I/O becomes possible, delivery of <code class="literal">SIGIO</code> will terminate the process.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On some UNIX implementations, <code class="literal">SIGIO</code>
                            is ignored by default.</p></div></div><div class="sect3" title="Setting the file descriptor owner"><div class="titlepage"><div><div><h4 class="title" id="setting_the_file_descriptor_owner">Setting the file descriptor owner</h4></div></div></div><p>We set the file descriptor owner using an <span class="emphasis"><em>fcntl()</em></span>
                        operation of the following form:<a id="IDX-CHP-63-8665" class="indexterm"/><a id="IDX-CHP-63-8666" class="indexterm"/><a id="IDX-CHP-63-8667" class="indexterm"/><a id="IDX-CHP-63-8668" class="indexterm"/><a id="IDX-CHP-63-8669" class="indexterm"/><a id="IDX-CHP-63-8670" class="indexterm"/><a id="IDX-CHP-63-8671" class="indexterm"/></p><a id="I_programlisting63_d1e170236"/><pre class="programlisting">fcntl(fd, F_SETOWN, pid);</pre><p>We may specify that either a single process or all of the processes in a
                        process group are to be signaled when I/O is possible on the file
                        descriptor. If <span class="emphasis"><em>pid</em></span> is positive, it is interpreted as a
                        process ID. If <span class="emphasis"><em>pid</em></span> is negative, its absolute value
                        specifies a process group ID.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On older UNIX implementations, an <span class="emphasis"><em>ioctl()</em></span>
                            operation—either <code class="literal">FIOSETOWN</code> or
                                <code class="literal">SIOCSPGRP</code>—was used to achieve the
                            same effect as <code class="literal">F_SETOWN</code>. For
                            compatibility, these <span class="emphasis"><em>ioctl()</em></span> operations are also
                            provided on Linux.</p></div><p>Typically, <span class="emphasis"><em>pid</em></span> is specified as the process ID of the
                        calling process (so that the signal is sent to the process that has the file
                        descriptor open). However, it is possible to specify another process or a
                        process group (e.g., the caller’s process group), and signals will be sent
                        to that target, subject to the permission checks described in Section 20.5,
                        where the sending process is considered to be the process that does the
                            <code class="literal">F_SETOWN</code>.</p><p>The <span class="emphasis"><em>fcntl()</em></span>
                        <code class="literal">F_GETOWN</code> operation returns the ID of the
                        process or process group that is to receive signals when I/O is possible on
                        a specified file descriptor:</p><a id="I_programlisting63_d1e170280"/><pre class="programlisting">id = fcntl(fd, F_GETOWN);
if (id == -1)
    errExit("fcntl");</pre><p>A process group ID is returned as a negative number by this call.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>ioctl()</em></span> operation that corresponds to
                                <code class="literal">F_GETOWN</code> on older UNIX
                            implementations was <code class="literal">FIOGETOWN</code> or
                                <code class="literal">SIOCGPGRP</code>. Both of these
                                <span class="emphasis"><em>ioctl()</em></span> operations are also provided on
                            Linux.</p></div><p>A limitation in the system call convention employed on some Linux
                        architectures (notably, x86) means that if a file descriptor is owned by a
                        process group ID less than 4096, then, instead of returning that ID as a
                        negative function result from the <span class="emphasis"><em>fcntl()</em></span>
                        <code class="literal">F_GETOWN</code> operation,
                            <span class="emphasis"><em>glibc</em></span> misinterprets it as a system call error.
                        Consequently, the <span class="emphasis"><em>fcntl()</em></span> wrapper function returns -1,
                        and <span class="emphasis"><em>errno</em></span> contains the (positive) process group ID.
                        This is a consequence of the fact that the kernel system call interface
                        indicates errors by returning a negative <span class="emphasis"><em>errno</em></span> value as
                        a function result, and there are a few cases where it is necessary to
                        distinguish such results from a successful call that returns a valid
                        negative value. To make this distinction, <span class="emphasis"><em>glibc</em></span>
                        interprets negative system call returns in the range -1 to -4095 as
                        indicating an error, copies this (absolute) value into
                            <span class="emphasis"><em>errno</em></span>, and returns -1 as the function result for
                        the application program. This technique is generally sufficient for dealing
                        with the few system call service routines that can return a valid negative
                        result; the <span class="emphasis"><em>fcntl()</em></span>
                        <code class="literal">F_GETOWN</code> operation is the only practical
                        case where it fails. This limitation means that an application that uses
                        process groups to receive “I/O possible” signals (which is unusual) can’t
                        reliably use <code class="literal">F_GETOWN</code> to discover which
                        process group owns a file descriptor.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since <span class="emphasis"><em>glibc</em></span> version 2.11, the
                                <span class="emphasis"><em>fcntl()</em></span> wrapper function fixes the problem of
                                <code class="literal">F_GETOWN</code> with process group IDs
                            less than 4096. It does this by implementing <code class="literal">F_GETOWN</code> in user space using the <code class="literal">F_GETOWN_EX</code> operation (<a class="xref" href="ch63.html#when_is_quotation_mark_i_solidus" title="When Is “I/O Possible” Signaled?">When Is “I/O Possible” Signaled?</a>), which is provided by
                            Linux 2.6.32 and later.</p></div></div></div><div class="sect2" title="When Is “I/O Possible” Signaled?"><div class="titlepage"><div><div><h3 class="title" id="when_is_quotation_mark_i_solidus">When Is “I/O Possible” Signaled?</h3></div></div></div><p>We now consider the details of when “I/O possible” is signaled for various
                    file types.<a id="IDX-CHP-63-8672" class="indexterm"/><a id="IDX-CHP-63-8673" class="indexterm"/></p><div class="sect3" title="Terminals and pseudoterminals"><div class="titlepage"><div><div><h4 class="title" id="terminals_and_pseudoterminals-id1">Terminals and pseudoterminals</h4></div></div></div><p>For terminals and pseudoterminals, a signal is generated whenever new
                        input becomes available, even if previous input has not yet been read.
                        “Input possible” is also signaled if an end-of-file condition occurs on a
                        terminal (but not on a pseudoterminal).</p><p>There is no “output possible” signaling for terminals. A terminal
                        disconnect is also not signaled.</p><p>Starting with kernel 2.4.19, Linux provides “output possible” signaling
                        for the slave side of a pseudoterminal. This signal is generated whenever
                        input is consumed on the master side of the pseudoterminal.</p></div><div class="sect3" title="Pipes and FIFOs"><div class="titlepage"><div><div><h4 class="title" id="pipes_and_fifos-id2">Pipes and FIFOs</h4></div></div></div><p>For the read end of a pipe or FIFO, a signal is generated in these
                        circumstances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Data is written to the pipe (even if there was already unread
                                input available).</p></li><li class="listitem"><p>The write end of the pipe is closed.</p></li></ul></div><p>For the write end of a pipe or FIFO, a signal is generated in these
                        circumstances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A read from the pipe increases the amount of free space in the
                                pipe so that it is now possible to write <code class="literal">PIPE_BUF</code> bytes without blocking.</p></li><li class="listitem"><p>The read end of the pipe is closed.</p></li></ul></div></div><div class="sect3" title="Sockets"><div class="titlepage"><div><div><h4 class="title" id="sockets-id1">Sockets</h4></div></div></div><p>Signal-driven I/O works for datagram sockets in both the UNIX and the
                        Internet domains. A signal is generated in the following
                        circumstances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An input datagram arrives on the socket (even if there were
                                already unread datagrams waiting to be read).</p></li><li class="listitem"><p>An asynchronous error occurs on the socket.<a id="IDX-CHP-63-8674" class="indexterm"/></p></li></ul></div><p>Signal-driven I/O works for stream sockets in both the UNIX and the
                        Internet domains. A signal is generated in the following
                        circumstances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A new connection is received on a listening socket.</p></li><li class="listitem"><p>A TCP <span class="emphasis"><em>connect()</em></span> request completes; that is,
                                the active end of a TCP connection entered the ESTABLISHED state, as
                                shown in <a class="xref" href="ch61.html#three-way_handshake_for_tcp_connection_e" title="Figure 61-5. Three-way handshake for TCP connection establishment">Figure 61-5</a>
                                (page 1272). The analogous condition is not signaled for UNIX domain
                                sockets.</p></li><li class="listitem"><p>New input is received on the socket (even if there was already
                                unread input available).</p></li><li class="listitem"><p>The peer closes its writing half of the connection using
                                    <span class="emphasis"><em>shutdown()</em></span>, or closes its socket altogether
                                using <span class="emphasis"><em>close()</em></span>.</p></li><li class="listitem"><p>Output is possible on the socket (e.g., space has become available
                                in the socket send buffer).</p></li><li class="listitem"><p>An asynchronous error occurs on the socket.<a id="IDX-CHP-63-8675" class="indexterm"/></p></li></ul></div></div><div class="sect3" title="inotify file descriptors"><div class="titlepage"><div><div><h4 class="title" id="inotify_file_descriptors"><span class="emphasis"><em>inotify</em></span> file descriptors</h4></div></div></div><p>A signal is generated when the <span class="emphasis"><em>inotify</em></span> file
                        descriptor becomes readable—that is, when an event occurs for one of the
                        files monitored by the <span class="emphasis"><em>inotify</em></span> file
                            descriptor.<a id="IDX-CHP-63-8676" class="indexterm"/><a id="IDX-CHP-63-8677" class="indexterm"/><a id="IDX-CHP-63-8678" class="indexterm"/><a id="IDX-CHP-63-8679" class="indexterm"/></p></div></div><div class="sect2" title="Refining the Use of Signal-Driven I/O"><div class="titlepage"><div><div><h3 class="title" id="refining_the_use_of_signal-driven_i_soli">Refining the Use of Signal-Driven I/O</h3></div></div></div><p>In applications that need to simultaneously monitor very large numbers (i.e.,
                    thousands) of file descriptors—for example, certain types of network
                    servers—signal-driven I/O can provide significant performance advantages by
                    comparison with <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>.
                    Signal-driven I/O offers superior performance because the kernel “remembers” the
                    list of file descriptors to be monitored, and signals the program only when I/O
                    events actually occur on those descriptors. As a result, the performance of a
                    program employing signal-driven I/O scales according to the number of I/O events
                    that occur, rather than the number of file descriptors being
                        monitored.<a id="IDX-CHP-63-8680" class="indexterm"/><a id="IDX-CHP-63-8681" class="indexterm"/><a id="IDX-CHP-63-8682" class="indexterm"/><a id="IDX-CHP-63-8683" class="indexterm"/><a id="IDX-CHP-63-8684" class="indexterm"/><a id="IDX-CHP-63-8685" class="indexterm"/><a id="IDX-CHP-63-8686" class="indexterm"/><a id="IDX-CHP-63-8687" class="indexterm"/><a id="IDX-CHP-63-8688" class="indexterm"/><a id="IDX-CHP-63-8689" class="indexterm"/><a id="IDX-CHP-63-8690" class="indexterm"/><a id="IDX-CHP-63-8691" class="indexterm"/><a id="IDX-CHP-63-8692" class="indexterm"/><a id="IDX-CHP-63-8693" class="indexterm"/><a id="IDX-CHP-63-8694" class="indexterm"/><a id="IDX-CHP-63-8695" class="indexterm"/><a id="IDX-CHP-63-8696" class="indexterm"/></p><p>To take full advantage of signal-driven I/O, we must perform two steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Employ a Linux-specific <span class="emphasis"><em>fcntl()</em></span> operation,
                                <code class="literal">F_SETSIG</code>, to specify a realtime
                            signal that should be delivered instead of <code class="literal">SIGIO</code> when I/O is possible on a file descriptor.</p></li><li class="listitem"><p>Specify the <code class="literal">SA_SIGINFO</code> flag when
                            using <span class="emphasis"><em>sigaction()</em></span> to establish the handler for the
                            realtime signal employed in the previous step (see Section 21.4).</p></li></ul></div><p>The <span class="emphasis"><em>fcntl()</em></span>
                    <code class="literal">F_SETSIG</code> operation specifies an alternative
                    signal that should be delivered instead of <code class="literal">SIGIO</code> when I/O is possible on a file descriptor:</p><a id="I_programlisting63_d1e170628"/><pre class="programlisting">if (fcntl(fd, F_SETSIG, sig) == -1)
    errExit("fcntl");</pre><p>The <code class="literal">F_GETSIG</code> operation performs the
                    converse of <code class="literal">F_SETSIG</code>, retrieving the signal
                    currently set for a file descriptor:</p><a id="I_programlisting63_d1e170638"/><pre class="programlisting">sig = fcntl(fd, F_GETSIG);
if (sig == -1)
    errExit("fcntl");</pre><p>(In order to obtain the definitions of the <code class="literal">F_SETSIG</code> and <code class="literal">F_GETSIG</code>
                    constants from <code class="literal">&lt;fcntl.h&gt;</code>, we
                    must define the <code class="literal">_GNU_SOURCE</code> feature test
                    macro.)</p><p>Using <code class="literal">F_SETSIG</code> to change the signal used
                    for “I/O possible” notification serves two purposes, both of which are needed if
                    we are monitoring large numbers of I/O events on multiple file
                    descriptors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The default “I/O possible” signal, <code class="literal">SIGIO</code>, is one of the standard, nonqueuing signals. If
                            multiple I/O events are signaled while <code class="literal">SIGIO</code> is blocked—perhaps because the <code class="literal">SIGIO</code> handler is already invoked—all
                            notifications except the first will be lost. If we use <code class="literal">F_SETSIG</code> to specify a realtime signal as
                            the “I/O possible” signal, multiple notifications can be queued.</p></li><li class="listitem"><p>If the handler for the signal is established using a
                                <span class="emphasis"><em>sigaction()</em></span> call in which the <code class="literal">SA_SIGINFO</code> flag is specified in the
                                <span class="emphasis"><em>sa.sa_flags</em></span> field, then a
                                <span class="emphasis"><em>siginfo_t</em></span> structure is passed as the second
                            argument to the signal handler (Section 21.4). This structure contains
                            fields identifying the file descriptor on which the event occurred, as
                            well as the type of event.<a id="IDX-CHP-63-8697" class="indexterm"/></p></li></ul></div><p>Note that the use of <span class="emphasis"><em>both</em></span>
                    <code class="literal">F_SETSIG</code> and <code class="literal">SA_SIGINFO</code> is required in order for a valid
                        <span class="emphasis"><em>siginfo_t</em></span> structure to be passed to the signal
                    handler.</p><p>If we perform an <code class="literal">F_SETSIG</code> operation
                    specifying <span class="emphasis"><em>sig</em></span> as 0, then we return to the default
                    behavior: <code class="literal">SIGIO</code> is delivered, and a
                        <span class="emphasis"><em>siginfo_t</em></span> argument is not supplied to the
                    handler.</p><p>For an “I/O possible” event, the fields of interest in the
                        <span class="emphasis"><em>siginfo_t</em></span> structure passed to the signal handler are as
                    follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>si_signo</em></span>: the number of the signal that caused
                            the invocation of the handler. This value is the same as the first
                            argument to the signal handler.</p></li><li class="listitem"><p><span class="emphasis"><em>si_fd</em></span>: the file descriptor for which the I/O
                            event occurred.</p></li><li class="listitem"><p><span class="emphasis"><em>si_code</em></span>: a code indicating the type of event that
                            occurred. The values that can appear in this field, along with their
                            general descriptions, are shown in <a class="xref" href="ch63.html#si_underscore_code_and_si_underscore_ban" title="Table 63-7. si_code and si_band values in the siginfo_t structure for “I/O possible” events">Table 63-7</a>.</p></li><li class="listitem"><p><span class="emphasis"><em>si_band</em></span>: a bit mask containing the same bits as
                            are returned in the <span class="emphasis"><em>revents</em></span> field by the
                                <span class="emphasis"><em>poll()</em></span> system call. The value set in
                                <span class="emphasis"><em>si_code</em></span> has a one-to-one correspondence with
                            the bit-mask setting in <span class="emphasis"><em>si_band</em></span>, as shown in <a class="xref" href="ch63.html#si_underscore_code_and_si_underscore_ban" title="Table 63-7. si_code and si_band values in the siginfo_t structure for “I/O possible” events">Table 63-7</a>.</p><div class="table"><a id="si_underscore_code_and_si_underscore_ban"/><div class="table-title">Table 63-7. <span class="emphasis"><em>si_code</em></span> and <span class="emphasis"><em>si_band</em></span>
                                values in the <span class="emphasis"><em>siginfo_t</em></span> structure for “I/O
                                possible” events</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <span class="emphasis"><em>si_code</em></span>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p><span class="emphasis"><em>si_band</em></span> mask value</p>
                                        </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                            <p>Description</p>
                                        </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLL_IN</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLLIN |
                                                  POLLRDNORM</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                            <p>Input available; end-of-file condition</p>
                                        </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLL_OUT</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLLOUT | POLLWRNORM |
                                                  POLLWRBAND</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                            <p>Output possible</p>
                                        </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLL_MSG</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLLIN | POLLRDNORM |
                                                  POLLMSG</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                            <p>Input message available (unused)</p>
                                        </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLL_ERR</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLLERR</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                            <p>I/O error</p>
                                        </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLL_PRI</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLLPRI |
                                                  POLLRDNORM</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                            <p>High-priority input available</p>
                                        </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLL_HUP</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                            <p>
                                                <code class="literal">POLLHUP | POLLERR</code>
                                            </p>
                                        </td><td style="text-align: left; vertical-align: top; ">
                                            <p>Hangup occurred</p>
                                        </td></tr></tbody></table></div></div></li></ul></div><p>In an application that is purely input-driven, we can further refine the use
                    of <code class="literal">F_SETSIG</code>. Instead of monitoring I/O events
                    via a signal handler, we can block the nominated “I/O possible” signal, and then
                    accept the queued signals via calls to <span class="emphasis"><em>sigwaitinfo()</em></span> or
                        <span class="emphasis"><em>sigtimedwait()</em></span> (Section 22.10). These system calls
                    return a <span class="emphasis"><em>siginfo_t</em></span> structure that contains the same
                    information as is passed to a signal handler established with <code class="literal">SA_SIGINFO</code>. Accepting signals in this manner
                    returns us to a synchronous model of event processing, but with the advantage
                    that we are much more efficiently notified about the file descriptors on which
                    I/O events have occurred than if we use <span class="emphasis"><em>select()</em></span> or
                        <span class="emphasis"><em>poll()</em></span>.</p><div class="sect3" title="Handling signal-queue overflow"><div class="titlepage"><div><div><h4 class="title" id="handling_signal-queue_overflow">Handling signal-queue overflow</h4></div></div></div><p>We saw in Section 22.8 that there is a limit on the number of realtime
                        signals that may be queued. If this limit is reached, the kernel reverts to
                        delivering the default <code class="literal">SIGIO</code> signal for
                        “I/O possible” notifications. This informs the process that a signal-queue
                        overflow occurred. When this happens, we lose information about which file
                        descriptors have I/O events, because <code class="literal">SIGIO</code> is not queued. (Furthermore, the <code class="literal">SIGIO</code> handler doesn’t receive a
                            <span class="emphasis"><em>siginfo_t</em></span> argument, which means that the signal
                        handler can’t determine the file descriptor that generated the
                            signal.)<a id="IDX-CHP-63-8698" class="indexterm"/><a id="IDX-CHP-63-8699" class="indexterm"/><a id="IDX-CHP-63-8700" class="indexterm"/><a id="IDX-CHP-63-8701" class="indexterm"/><a id="IDX-CHP-63-8702" class="indexterm"/><a id="IDX-CHP-63-8703" class="indexterm"/><a id="IDX-CHP-63-8704" class="indexterm"/></p><p>We can reduce the likelihood of signal-queue overflows by increasing the
                        limit on the number of realtime signals that can be queued, as described in
                        Section 22.8. However, this doesn’t eliminate the need to handle the
                        possibility of an overflow. A properly designed application using <code class="literal">F_SETSIG</code> to establish a realtime signal as the
                        “I/O possible” notification mechanism must also establish a handler for
                            <code class="literal">SIGIO</code>. If <code class="literal">SIGIO</code> is delivered, then the application can drain the queue
                        of realtime signals using <span class="emphasis"><em>sigwaitinfo()</em></span> and temporarily
                        revert to the use of <span class="emphasis"><em>select()</em></span> or
                            <span class="emphasis"><em>poll()</em></span> to obtain a complete list of file
                        descriptors with outstanding I/O events.</p></div><div class="sect3" title="Using signal-driven I/O with multithreaded applications"><div class="titlepage"><div><div><h4 class="title" id="using_signal-driven_i_solidus_o_with_mul">Using signal-driven I/O with multithreaded applications</h4></div></div></div><p>Starting with kernel 2.6.32, Linux provides two new, nonstandard
                            <span class="emphasis"><em>fcntl()</em></span> operations that can be used to set the
                        target for “I/O possible” signals: <code class="literal">F_SETOWN_EX</code> and <code class="literal">F_GETOWN_EX</code>.</p><p>The <code class="literal">F_SETOWN_EX</code> operation is like
                            <code class="literal">F_SETOWN</code>, but as well as allowing the
                        target to be specified as a process or process group, it also permits a
                        thread to be specified as the target for “I/O possible” signals. For this
                        operation, the third argument of <span class="emphasis"><em>fcntl()</em></span> is a pointer
                        to a structure of the following form:</p><a id="I_programlisting63_d1e170994"/><pre class="programlisting">struct f_owner_ex {
    int   type;
    pid_t pid;
};</pre><p>The <span class="emphasis"><em>type</em></span> field defines the meaning of the
                            <span class="emphasis"><em>pid</em></span> field, and has one of the following
                        values:</p><div class="variablelist"><dl><dt><span class="term">
                                <code class="literal">F_OWNER_PGRP</code>
                            </span></dt><dd><p>The <span class="emphasis"><em>pid</em></span> field specifies the ID of a
                                    process group that is to be the target of “I/O possible”
                                    signals. Unlike with <code class="literal">F_SETOWN</code>, a process group ID is specified as a
                                    positive value.</p></dd><dt><span class="term">
                                <code class="literal">F_OWNER_PID</code>
                            </span></dt><dd><p>The <span class="emphasis"><em>pid</em></span> field specifies the ID of a
                                    process that is to be the target of “I/O possible”
                                    signals.</p></dd><dt><span class="term">
                                <code class="literal">F_OWNER_TID</code>
                            </span></dt><dd><p>The <span class="emphasis"><em>pid</em></span> field specifies the ID of a
                                    thread that is to be the target of “I/O possible” signals. The
                                    ID specified in <span class="emphasis"><em>pid</em></span> is a value returned by
                                        <span class="emphasis"><em>clone()</em></span> or
                                        <span class="emphasis"><em>gettid()</em></span>.<a id="IDX-CHP-63-8705" class="indexterm"/></p></dd></dl></div><p>The <code class="literal">F_GETOWN_EX</code> operation is the
                        converse of the <code class="literal">F_GETOWN_EX</code> operation. It
                        uses the <span class="emphasis"><em>f_owner_ex</em></span> structure pointed to by the third
                        argument of <span class="emphasis"><em>fcntl()</em></span> to return the settings defined by a
                        previous <code class="literal">F_SETOWN_EX</code> operation.<a id="IDX-CHP-63-8706" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Because the <code class="literal">F_SETOWN_EX</code> and
                                <code class="literal">F_GETOWN_EX</code> operations represent
                            process group IDs as positive values, <code class="literal">F_GETOWN_EX</code> doesn’t suffer the problem described earlier
                            for <code class="literal">F_GETOWN</code> when using process group
                            IDs less than 4096.</p></div></div></div></div><div class="sect1" title="The epoll API"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_epoll_api">The <span class="emphasis"><em>epoll</em></span> API</h2></div></div></div><p>Like the I/O multiplexing system calls and signal-driven I/O, the Linux
                    <span class="emphasis"><em>epoll</em></span> (event poll) API is used to monitor multiple file
                descriptors to see if they are ready for I/O. The primary advantages of the
                    <span class="emphasis"><em>epoll</em></span> API are the following:<a id="IDX-CHP-63-8708" class="indexterm"/><a id="IDX-CHP-63-8709" class="indexterm"/><a id="IDX-CHP-63-8707" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The performance of <span class="emphasis"><em>epoll</em></span> scales much better than
                            <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> when
                        monitoring large numbers of file descriptors.</p></li><li class="listitem"><p>The <span class="emphasis"><em>epoll</em></span> API permits either level-triggered or
                        edge-triggered notification. By contrast, <span class="emphasis"><em>select()</em></span> and
                            <span class="emphasis"><em>poll()</em></span> provide only level-triggered notification,
                        and signal-driven I/O provides only edge-triggered notification.</p></li></ul></div><p>The performance of <span class="emphasis"><em>epoll</em></span> and signal-driven I/O is similar.
                However, <span class="emphasis"><em>epoll</em></span> has some advantages over signal-driven
                I/O:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>We avoid the complexities of signal handling (e.g., signal-queue
                        overflow).</p></li><li class="listitem"><p>We have greater flexibility in specifying what kind of monitoring we want
                        to perform (e.g., checking to see if a file descriptor for a socket is ready
                        for reading, writing, or both).</p></li></ul></div><p>The <span class="emphasis"><em>epoll</em></span> API is Linux-specific, and is new in Linux
                2.6.</p><p>The central data structure of the <span class="emphasis"><em>epoll</em></span> API is an
                    <span class="emphasis"><em>epoll instance</em></span>, which is referred to via an open file
                descriptor. This file descriptor is not used for I/O. Instead, it is a handle for
                kernel data structures that serve two purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>recording a list of file descriptors that this process has declared an
                        interest in monitoring—the <span class="emphasis"><em>interest list</em></span>; and<a id="IDX-CHP-63-8710" class="indexterm"/></p></li><li class="listitem"><p>maintaining a list of file descriptors that are ready for I/O—the
                            <span class="emphasis"><em>ready list</em></span>.<a id="IDX-CHP-63-8711" class="indexterm"/></p></li></ul></div><p>The membership of the ready list is a subset of the interest list.</p><p>For each file descriptor monitored by <span class="emphasis"><em>epoll</em></span>, we can specify a
                bit mask indicating events that we are interested in knowing about. These bit masks
                correspond closely to the bit masks used with <span class="emphasis"><em>poll()</em></span>.</p><p>The <span class="emphasis"><em>epoll</em></span> API consists of three system calls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>epoll_create()</em></span> system call creates an
                            <span class="emphasis"><em>epoll</em></span> instance and returns a file descriptor
                        referring to the instance.<a id="IDX-CHP-63-8712" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>epoll_ctl()</em></span> system call manipulates the interest
                        list associated with an <span class="emphasis"><em>epoll</em></span> instance. Using
                            <span class="emphasis"><em>epoll_ctl()</em></span>, we can add a new file descriptor to
                        the list, remove an existing descriptor from the list, and modify the mask
                        that determines which events are to be monitored for a descriptor.<a id="IDX-CHP-63-8713" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>epoll_wait()</em></span> system call returns items from the
                        ready list associated with an <span class="emphasis"><em>epoll</em></span> instance.<a id="IDX-CHP-63-8714" class="indexterm"/></p></li></ul></div><div class="sect2" title="Creating an epoll Instance: epoll_create()"><div class="titlepage"><div><div><h3 class="title" id="creating_an_epoll_instance_colon_epoll_u">Creating an <span class="emphasis"><em>epoll</em></span> Instance:
                        <span class="emphasis"><em>epoll_create()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>epoll_create()</em></span> system call creates a new
                        <span class="emphasis"><em>epoll</em></span> instance whose interest list is initially
                        empty.<a id="IDX-CHP-63-8716" class="indexterm"/><a id="IDX-CHP-63-8717" class="indexterm"/><a id="IDX-CHP-63-8718" class="indexterm"/><a id="IDX-CHP-63-8719" class="indexterm"/><a id="IDX-CHP-63-8720" class="indexterm"/><a id="IDX-CHP-63-8721" class="indexterm"/><a id="IDX-CHP-63-8715" class="indexterm"/></p><a id="I_programlisting63_d1e171316"/><pre class="programlisting">#include &lt;sys/epoll.h&gt;

int <strong class="userinput"><code>epoll_create</code></strong>(int <span class="emphasis"><em>size</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns file descriptor on success, or -1 on error</p></div><p>The <span class="emphasis"><em>size</em></span> argument specifies the number of file
                    descriptors that we expect to monitor via the <span class="emphasis"><em>epoll</em></span>
                    instance. This argument is not an upper limit, but rather a hint to the kernel
                    about how to initially dimension internal data structures. (Since Linux 2.6.8,
                    the <span class="emphasis"><em>size</em></span> argument must be greater than zero but is
                    otherwise ignored, because changes in the implementation meant that the
                    information it provided is no longer required.)</p><p>As its function result, <span class="emphasis"><em>epoll_create()</em></span> returns a file
                    descriptor referring to the new <span class="emphasis"><em>epoll</em></span> instance. This file
                    descriptor is used to refer to the <span class="emphasis"><em>epoll</em></span> instance in other
                        <span class="emphasis"><em>epoll</em></span> system calls. When the file descriptor is no
                    longer required, it should be closed in the usual way, using
                        <span class="emphasis"><em>close()</em></span>. When all file descriptors referring to an
                        <span class="emphasis"><em>epoll</em></span> instance are closed, the instance is destroyed
                    and its associated resources are released back to the system. (Multiple file
                    descriptors may refer to the same <span class="emphasis"><em>epoll</em></span> instance as a
                    consequence of calls to <span class="emphasis"><em>fork()</em></span> or descriptor duplication
                    using <span class="emphasis"><em>dup()</em></span> or similar.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Starting with kernel 2.6.27, Linux supports a new system call,
                            <span class="emphasis"><em>epoll_create1()</em></span>. This system call performs the same
                        task as <span class="emphasis"><em>epoll_create()</em></span>, but drops the obsolete
                            <span class="emphasis"><em>size</em></span> argument and adds a flags argument that can be
                        used to modify the behavior of the system call. One flag is currently
                        supported: <code class="literal">EPOLL_CLOEXEC</code>, which causes
                        the kernel to enable the close-on-exec flag <code class="literal">(FD_CLOEXEC)</code> for the new file descriptor. This flag is useful
                        for the same reasons as the <span class="emphasis"><em>open()</em></span>
                        <code class="literal">O_CLOEXEC</code> flag described in <a class="xref" href="ch04.html#file_descriptor_number_returned_by-id1" title="File descriptor number returned by open()">File descriptor number returned by <span class="emphasis"><em>open()</em></span></a>.<a id="IDX-CHP-63-8722" class="indexterm"/></p></div></div><div class="sect2" title="Modifying the epoll Interest List: epoll_ctl()"><div class="titlepage"><div><div><h3 class="title" id="modifying_the_epoll_interest_list_colon">Modifying the <span class="emphasis"><em>epoll</em></span> Interest List:
                        <span class="emphasis"><em>epoll_ctl()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>epoll_ctl()</em></span> system call modifies the interest list of
                    the <span class="emphasis"><em>epoll</em></span> instance referred to by the file descriptor
                        <span class="emphasis"><em>epfd</em></span>.<a id="IDX-CHP-63-8723" class="indexterm"/><a id="IDX-CHP-63-8724" class="indexterm"/><a id="IDX-CHP-63-8725" class="indexterm"/><a id="IDX-CHP-63-8726" class="indexterm"/><a id="IDX-CHP-63-8727" class="indexterm"/><a id="IDX-CHP-63-8728" class="indexterm"/><a id="IDX-CHP-63-8729" class="indexterm"/><a id="IDX-CHP-63-8730" class="indexterm"/></p><a id="I_programlisting63_d1e171461"/><pre class="programlisting">#include &lt;sys/epoll.h&gt;

int <strong class="userinput"><code>epoll_ctl</code></strong>(int <span class="emphasis"><em>epfd</em></span>, int <span class="emphasis"><em>op</em></span>, int <span class="emphasis"><em>fd</em></span>, struct epoll_event *<span class="emphasis"><em>ev</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>fd</em></span> argument identifies which of the file descriptors
                    in the interest list is to have its settings modified. This argument can be a
                    file descriptor for a pipe, FIFO, socket, POSIX message queue,
                        <span class="emphasis"><em>inotify</em></span> instance, terminal, device, or even another
                        <span class="emphasis"><em>epoll</em></span> descriptor (i.e., we can build a kind of
                    hierarchy of monitored descriptors). However, <span class="emphasis"><em>fd</em></span> can’t be a
                    file descriptor for a regular file or a directory (the error <code class="literal">EPERM</code> results).</p><p>The <span class="emphasis"><em>op</em></span> argument specifies the operation to be performed,
                    and has one of the following values:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">EPOLL_CTL_ADD</code>
                        </span></dt><dd><p>Add the file descriptor <span class="emphasis"><em>fd</em></span> to the interest
                                list for <span class="emphasis"><em>epfd</em></span>. The set of events that we are
                                interested in monitoring for <span class="emphasis"><em>fd</em></span> is specified in
                                the buffer pointed to by <span class="emphasis"><em>ev</em></span>, as described
                                below. If we attempt to add a file descriptor that is already in the
                                interest list, <span class="emphasis"><em>epoll_ctl()</em></span> fails with the error
                                    <code class="literal">EEXIST</code>.</p></dd><dt><span class="term">
                            <code class="literal">EPOLL_CTL_MOD</code>
                        </span></dt><dd><p>Modify the events setting for the file descriptor
                                    <span class="emphasis"><em>fd</em></span>, using the information specified in the
                                buffer pointed to by <span class="emphasis"><em>ev</em></span>. If we attempt to
                                modify the settings of a file descriptor that is not in the interest
                                list for <span class="emphasis"><em>epfd</em></span>, <span class="emphasis"><em>epoll_ctl()</em></span>
                                fails with the error <code class="literal">ENOENT</code>.</p></dd><dt><span class="term">
                            <code class="literal">EPOLL_CTL_DEL</code>
                        </span></dt><dd><p>Remove the file descriptor <span class="emphasis"><em>fd</em></span> from the
                                interest list for <span class="emphasis"><em>epfd</em></span>. The
                                    <span class="emphasis"><em>ev</em></span> argument is ignored for this operation.
                                If we attempt to remove a file descriptor that is not in the
                                interest list for <span class="emphasis"><em>epfd</em></span>,
                                    <span class="emphasis"><em>epoll_ctl()</em></span> fails with the error <code class="literal">ENOENT</code>. Closing a file descriptor
                                automatically removes it from all of the epoll interest lists of
                                which it is a member.</p></dd></dl></div><p>The <span class="emphasis"><em>ev</em></span> argument is a pointer to a structure of type
                        <span class="emphasis"><em>epoll_event</em></span>, defined as follows:</p><a id="I_programlisting63_d1e171586"/><pre class="programlisting">struct epoll_event {
    uint32_t     events;        /* epoll events (bit mask) */
    epoll_data_t data;          /* User data */
};</pre><p>The <span class="emphasis"><em>data</em></span> field of the <span class="emphasis"><em>epoll_event</em></span>
                    structure is typed as follows:<a id="IDX-CHP-63-8731" class="indexterm"/></p><a id="I_programlisting63_d1e171601"/><pre class="programlisting">typedef union epoll_data {
    void        *ptr;           /* Pointer to user-defined data */
    int          fd;            /* File descriptor */
    uint32_t     u32;           /* 32-bit integer */
    uint64_t     u64;           /* 64-bit integer */
} epoll_data_t;</pre><p>The <span class="emphasis"><em>ev</em></span> argument specifies settings for the file
                    descriptor <span class="emphasis"><em>fd</em></span>, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>events</em></span> subfield is a bit mask specifying the
                            set of events that we are interested in monitoring for
                                <span class="emphasis"><em>fd</em></span>. We say more about the bit values that can
                            be used in this field in the next section.</p></li><li class="listitem"><p>The <span class="emphasis"><em>data</em></span> subfield is a union, one of whose
                            members can be used to specify information that is passed back to the
                            calling process (via <span class="emphasis"><em>epoll_wait()</em></span>) if
                                <span class="emphasis"><em>fd</em></span> later becomes ready.</p></li></ul></div><p><a class="xref" href="ch63.html#using_epoll_underscore_create_open_paren" title="Example 63-4. Using epoll_create() and epoll_ctl()">Example 63-4</a> shows an example of
                    the use of <span class="emphasis"><em>epoll_create()</em></span> and
                        <span class="emphasis"><em>epoll_ctl()</em></span>.</p><div class="example"><a id="using_epoll_underscore_create_open_paren"/><div class="example-title">Example 63-4. Using <span class="emphasis"><em>epoll_create()</em></span> and
                            <span class="emphasis"><em>epoll_ctl()</em></span></div><div class="example-contents"><pre class="programlisting">int epfd;
    struct epoll_event ev;

    epfd = epoll_create(5);
    if (epfd == -1)
        errExit("epoll_create");

    ev.data.fd = fd;
    ev.events = EPOLLIN;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)
        errExit("epoll_ctl");</pre></div></div><div class="sect3" title="The max_user_watches limit"><div class="titlepage"><div><div><h4 class="title" id="the_max_underscore_user_underscore_watch">The <code class="literal">max_user_watches</code> limit</h4></div></div></div><p>Because each file descriptor registered in an <span class="emphasis"><em>epoll</em></span>
                        interest list requires a small amount of nonswappable kernel memory, the
                        kernel provides an interface that defines a limit on the total number of
                        file descriptors that each user can register in all
                            <span class="emphasis"><em>epoll</em></span> interest lists. The value of this limit can
                        be viewed and modified via <code class="literal">max_user_watches</code>, a Linux-specific file in the <code class="literal">/proc/sys/fs/epoll</code> directory. The default
                        value of this limit is calculated based on available system memory (see the
                            <span class="emphasis"><em>epoll(7)</em></span> manual page).<a id="IDX-CHP-63-8732" class="indexterm"/><a id="IDX-CHP-63-8733" class="indexterm"/><a id="IDX-CHP-63-8734" class="indexterm"/><a id="IDX-CHP-63-8735" class="indexterm"/><a id="IDX-CHP-63-8736" class="indexterm"/></p></div></div><div class="sect2" title="Waiting for Events: epoll_wait()"><div class="titlepage"><div><div><h3 class="title" id="waiting_for_events_colon_epoll_underscor">Waiting for Events: <span class="emphasis"><em>epoll_wait()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>epoll_wait()</em></span> system call returns information about
                    ready file descriptors from the <span class="emphasis"><em>epoll</em></span> instance referred to
                    by the file descriptor <span class="emphasis"><em>epfd</em></span>. A single
                        <span class="emphasis"><em>epoll_wait()</em></span> call can return information about multiple
                    ready file descriptors.<a id="IDX-CHP-63-8737" class="indexterm"/></p><a id="I_programlisting63_d1e171734"/><pre class="programlisting">#include &lt;sys/epoll.h&gt;

int <strong class="userinput"><code>epoll_wait</code></strong>(int <span class="emphasis"><em>epfd</em></span>, struct epoll_event *<span class="emphasis"><em>evlist</em></span>, int
 <span class="emphasis"><em>maxevents</em></span>, int <span class="emphasis"><em>timeout</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of ready file descriptors, 0 on timeout, or -1 on
                        error</p></div><p>The information about ready file descriptors is returned in the array of
                        <span class="emphasis"><em>epoll_event</em></span> structures pointed to by
                        <span class="emphasis"><em>evlist</em></span>. (The <span class="emphasis"><em>epoll_event</em></span> structure
                    was described in the previous section.) The <span class="emphasis"><em>evlist</em></span> array is
                    allocated by the caller, and the number of elements it contains is specified in
                        <span class="emphasis"><em>maxevents</em></span>.<a id="IDX-CHP-63-8738" class="indexterm"/></p><p>Each item in the array <span class="emphasis"><em>evlist</em></span> returns information about a
                    single ready file descriptor. The <span class="emphasis"><em>events</em></span> subfield returns a
                    mask of the events that have occurred on this descriptor. The
                        <span class="emphasis"><em>data</em></span> subfield returns whatever value was specified in
                        <span class="emphasis"><em>ev.data</em></span> when we registered interest in this file
                    descriptor using <span class="emphasis"><em>epoll_ctl()</em></span>. Note that the
                        <span class="emphasis"><em>data</em></span> field provides the only mechanism for finding out
                    the number of the file descriptor associated with this event. Thus, when we make
                    the <span class="emphasis"><em>epoll_ctl()</em></span> call that places a file descriptor in the
                    interest list, we should either set <span class="emphasis"><em>ev.data.fd</em></span> to the file
                    descriptor number (as shown in <a class="xref" href="ch63.html#using_epoll_underscore_create_open_paren" title="Example 63-4. Using epoll_create() and epoll_ctl()">Example 63-4</a>) or set
                        <span class="emphasis"><em>ev.data.ptr</em></span> to point to a structure that contains the
                    file descriptor number.</p><p>The <span class="emphasis"><em>timeout</em></span> argument determines the blocking behavior of
                        <span class="emphasis"><em>epoll_wait()</em></span>, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>timeout</em></span> equals -1, block until an event occurs
                            for one of the file descriptors in the interest list for
                                <span class="emphasis"><em>epfd</em></span> or until a signal is caught.</p></li><li class="listitem"><p>If <span class="emphasis"><em>timeout</em></span> equals 0, perform a nonblocking check
                            to see which events are currently available on the file descriptors in
                            the interest list for <span class="emphasis"><em>epfd</em></span>.<a id="IDX-CHP-63-8739" class="indexterm"/></p></li><li class="listitem"><p>If <span class="emphasis"><em>timeout</em></span> is greater than 0, block for up to
                                <span class="emphasis"><em>timeout</em></span> milliseconds, until an event occurs on
                            one of the file descriptors in the interest list for
                                <span class="emphasis"><em>epfd</em></span>, or until a signal is caught.</p></li></ul></div><p>On success, <span class="emphasis"><em>epoll_wait()</em></span> returns the number of items that
                    have been placed in the array <span class="emphasis"><em>evlist</em></span>, or 0 if no file
                    descriptors were ready within the interval specified by
                        <span class="emphasis"><em>timeout</em></span>. On error, <span class="emphasis"><em>epoll_wait()</em></span>
                    returns -1, with <span class="emphasis"><em>errno</em></span> set to indicate the error.</p><p>In a multithreaded program, it is possible for one thread to use
                        <span class="emphasis"><em>epoll_ctl()</em></span> to add file descriptors to the interest
                    list of an epoll instance that is already being monitored by
                        <span class="emphasis"><em>epoll_wait()</em></span> in another thread. These changes to the
                    interest list will be taken into account immediately, and the
                        <span class="emphasis"><em>epoll_wait()</em></span> call will return readiness information
                    about the newly added file descriptors.</p><div class="sect3" title="epoll events"><div class="titlepage"><div><div><h4 class="title" id="epoll_events"><span class="emphasis"><em>epoll</em></span> events</h4></div></div></div><p>The bit values that can be specified in <span class="emphasis"><em>ev.events</em></span>
                        when we call <span class="emphasis"><em>epoll_ctl()</em></span> and that are placed in the
                            <span class="emphasis"><em>evlist[].events</em></span> fields returned by
                            <span class="emphasis"><em>epoll_wait()</em></span> are shown in <a class="xref" href="ch63.html#bit-mask_values_for_the_epoll_events_fie" title="Table 63-8. Bit-mask values for the epoll events field">Table 63-8</a>. With the addition
                        of an <code class="literal">E</code> prefix, most of these bits have
                        names that are the same as the corresponding event bits used with
                            <span class="emphasis"><em>poll()</em></span>. (The exceptions are <code class="literal">EPOLLET</code> and <code class="literal">EPOLLONESHOT</code>, which we describe in more detail below.) The
                        reason for this correspondence is that, when specified as input to
                            <span class="emphasis"><em>epoll_ctl()</em></span> or returned as output via
                            <span class="emphasis"><em>epoll_wait()</em></span>, these bits convey exactly the same
                        meaning as the corresponding <span class="emphasis"><em>poll()</em></span> event
                            bits.<a id="IDX-CHP-63-8740" class="indexterm"/><a id="IDX-CHP-63-8741" class="indexterm"/><a id="IDX-CHP-63-8742" class="indexterm"/><a id="IDX-CHP-63-8743" class="indexterm"/><a id="IDX-CHP-63-8744" class="indexterm"/><a id="IDX-CHP-63-8745" class="indexterm"/><a id="IDX-CHP-63-8746" class="indexterm"/><a id="IDX-CHP-63-8747" class="indexterm"/></p><div class="table"><a id="bit-mask_values_for_the_epoll_events_fie"/><div class="table-title">Table 63-8. Bit-mask values for the <span class="emphasis"><em>epoll events</em></span>
                            field</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Bit</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Input to <span class="emphasis"><em>epoll_ctl()?</em></span></p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Returned by <span class="emphasis"><em>epoll_wait()?</em></span></p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                        <p>Description</p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">EPOLLIN</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Data other than high-priority data can be read</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">EPOLLPRI</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>High-priority data can be read</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">EPOLLRDHUP</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Shutdown on peer socket (since Linux 2.6.17)</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">EPOLLOUT</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Normal data can be written</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">EPOLLET</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Employ edge-triggered event notification</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">EPOLLONESHOT</code>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>Disable monitoring after event notification</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">EPOLLERR</code>
                                        </p>
                                    </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>An error has occurred</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <code class="literal">EPOLLHUP</code>
                                        </p>
                                    </td><td style="border-right: 0.5pt solid ; "> </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>•</p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>A hangup has occurred</p>
                                    </td></tr></tbody></table></div></div></div><div class="sect3" title="The EPOLLONESHOT flag"><div class="titlepage"><div><div><h4 class="title" id="the_epolloneshot_flag">The EPOLLONESHOT flag</h4></div></div></div><p>By default, once a file descriptor is added to an
                            <span class="emphasis"><em>epoll</em></span> interest list using the
                            <span class="emphasis"><em>epoll_ctl()</em></span>
                        <code class="literal">EPOLL_CTL_ADD</code> operation, it remains
                        active (i.e., subsequent calls to <span class="emphasis"><em>epoll_wait()</em></span> will
                        inform us whenever the file descriptor is ready) until we explicitly remove
                        it from the list using the <span class="emphasis"><em>epoll_ctl()</em></span>
                        <code class="literal">EPOLL_CTL_DEL</code> operation. If we want to be
                        notified only once about a particular file descriptor, then we can specify
                        the <code class="literal">EPOLLONESHOT</code> flag (available since
                        Linux 2.6.2) in the <span class="emphasis"><em>ev.events</em></span> value passed in
                            <span class="emphasis"><em>epoll_ctl()</em></span>. If this flag is specified, then, after
                        the next <span class="emphasis"><em>epoll_wait()</em></span> call that informs us that the
                        corresponding file descriptor is ready, the file descriptor is marked
                        inactive in the interest list, and we won’t be informed about its state by
                        future <span class="emphasis"><em>epoll_wait()</em></span> calls. If desired, we can
                        subsequently reenable monitoring of this file descriptor using the
                            <span class="emphasis"><em>epoll_ctl()</em></span>
                        <code class="literal">EPOLL_CTL_MOD</code> operation. (We can’t use
                        the <code class="literal">EPOLL_CTL_ADD</code> operation for this
                        purpose, because the inactive file descriptor is still part of the
                            <span class="emphasis"><em>epoll</em></span> interest list.)</p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id81">Example program</h4></div></div></div><p><a class="xref" href="ch63.html#using_the_epoll_api" title="Example 63-5. Using the epoll API">Example 63-5</a> demonstrates the use of the
                            <span class="emphasis"><em>epoll</em></span> API. As command-line arguments, this program
                        expects the pathnames of one or more terminals or FIFOs. The program
                        performs the following steps:<a id="IDX-CHP-63-8748" class="indexterm"/><a id="IDX-CHP-63-8749" class="indexterm"/><a id="IDX-CHP-63-8750" class="indexterm"/><a id="IDX-CHP-63-8751" class="indexterm"/><a id="IDX-CHP-63-8752" class="indexterm"/><a id="IDX-CHP-63-8753" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Create an <span class="emphasis"><em>epoll</em></span> instance <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172207"/><img src="figs/web/U001.png" alt=""/></span>.</p></li><li class="listitem"><p>Open each of the files named on the command line for input
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172216"/><img src="figs/web/U002.png" alt=""/></span> and add the resulting file descriptor to the
                                interest list of the <span class="emphasis"><em>epoll</em></span> instance
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172225"/><img src="figs/web/U003.png" alt=""/></span>, specifying the set of events to be monitored
                                as <code class="literal">EPOLLIN</code>.</p></li><li class="listitem"><p>Execute a loop <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172237"/><img src="figs/web/U004.png" alt=""/></span> that calls <span class="emphasis"><em>epoll_wait()</em></span>
                                <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172246"/><img src="figs/web/U005.png" alt=""/></span> to monitor the interest list of the
                                    <span class="emphasis"><em>epoll</em></span> instance and handles the returned
                                events from each call. Note the following points about this
                                loop:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>After the <span class="emphasis"><em>epoll_wait()</em></span> call, the
                                        program checks for an <code class="literal">EINTR</code> return <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172265"/><img src="figs/web/U006.png" alt=""/></span>, which may occur if the program was
                                        stopped by a signal in the middle of the
                                            <span class="emphasis"><em>epoll_wait()</em></span> call and then resumed
                                        by <code class="literal">SIGCONT</code>. (Refer to
                                        Section 21.5.) If this occurs, the program restarts the
                                            <span class="emphasis"><em>epoll_wait()</em></span> call.</p></li><li class="listitem"><p>It the <span class="emphasis"><em>epoll_wait()</em></span> call was
                                        successful, the program uses a further loop to check each of
                                        the ready items in <span class="emphasis"><em>evlist</em></span>
                                        <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172290"/><img src="figs/web/U007.png" alt=""/></span>. For each item in
                                            <span class="emphasis"><em>evlist</em></span>, the program checks the
                                            <span class="emphasis"><em>events</em></span> field for the presence of
                                        not just <code class="literal">EPOLLIN</code>
                                        <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172306"/><img src="figs/web/U008.png" alt=""/></span>, but also <code class="literal">EPOLLHUP</code> and <code class="literal">EPOLLERR</code>
                                        <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172318"/><img src="figs/web/U009.png" alt=""/></span>. These latter events can occur if the
                                        other end of a FIFO was closed or a terminal hangup
                                        occurred. If <code class="literal">EPOLLIN</code> was
                                        returned, then the program reads some input from the
                                        corresponding file descriptor and displays it on standard
                                        output. Otherwise, if either <code class="literal">EPOLLHUP</code> or <code class="literal">EPOLLERR</code> occurred, the program closes the
                                        corresponding file descriptor <span class="inlinemediaobject"><a id="I_inlinemediaobject63_d1e172334"/><img src="figs/web/U010.png" alt=""/></span> and decrements the counter of open
                                        files (<span class="emphasis"><em>numOpenFds</em></span>).</p></li><li class="listitem"><p>The loop terminates when all open file descriptors have
                                        been closed (i.e., when <span class="emphasis"><em>numOpenFds</em></span>
                                        equals 0).</p></li></ul></div></li></ul></div><p>The following shell session logs demonstrate the use of the program in
                            <a class="xref" href="ch63.html#using_the_epoll_api" title="Example 63-5. Using the epoll API">Example 63-5</a>. We use two terminal windows. In
                        one window, we use the program in <a class="xref" href="ch63.html#using_the_epoll_api" title="Example 63-5. Using the epoll API">Example 63-5</a> to
                        monitor two FIFOs for input. (Each open of a FIFO for reading by this
                        program will complete only after another process has opened the FIFO for
                        writing, as described in Section 44.7.) In the other window, we run
                        instances of <span class="emphasis"><em>cat(1)</em></span> that write data to these
                        FIFOs.</p><a id="I_programlisting63_d1e172358"/><pre class="programlisting"><strong class="userinput"><code>Terminal window 1</code></strong>                   <strong class="userinput"><code>Terminal window 2</code></strong>
$ <strong class="userinput"><code>mkfifo p q</code></strong>
$ <strong class="userinput"><code>./epoll_input p q</code></strong>
                                    $ <strong class="userinput"><code>cat &gt; p</code></strong>
Opened "p" on fd 4
                                    <em class="lineannotation"><span class="lineannotation">Type Control-Z to suspend cat</span></em>
                                    [1]+  Stopped      cat &gt;p
                                    $ <strong class="userinput"><code>cat &gt; q</code></strong>
Opened "q" on fd 5
About to epoll_wait()
<em class="lineannotation"><span class="lineannotation">Type Control-Z to suspend the epoll_input program</span></em>
[1]+  Stopped     ./epoll_input p q</pre><p>Above, we suspended our monitoring program so that we can now generate
                        input on both FIFOs, and close the write end of one of them:</p><a id="I_programlisting63_d1e172386"/><pre class="programlisting"><strong class="userinput"><code>qqq</code></strong>
                                    <em class="lineannotation"><span class="lineannotation">Type Control-D to terminate “cat &gt; q”</span></em>
                                    $ <strong class="userinput"><code>fg %1</code></strong>
                                    cat &gt;p
                                    <strong class="userinput"><code>ppp</code></strong></pre><p>Now we resume our monitoring program by bringing it into the foreground,
                        at which point <span class="emphasis"><em>epoll_wait()</em></span> returns two events:</p><a id="I_programlisting63_d1e172403"/><pre class="programlisting">$ <strong class="userinput"><code>fg</code></strong>
./epoll_input p q
About to epoll_wait()
Ready: 2
  fd=4; events: EPOLLIN
    read 4 bytes: ppp

  fd=5; events: EPOLLIN EPOLLHUP
    read 4 bytes: qqq

    closing fd 5
About to epoll_wait()</pre><p>The two blank lines in the above output are the newlines that were read by
                        the instances of <span class="emphasis"><em>cat</em></span>, written to the FIFOs, and then
                        read and echoed by our monitoring program.</p><p>Now we type <span class="emphasis"><em>Control-D</em></span> in the second terminal window
                        in order to terminate the remaining instance of <span class="emphasis"><em>cat</em></span>,
                        which causes <span class="emphasis"><em>epoll_wait()</em></span> to once more return, this
                        time with a single event:</p><a id="I_programlisting63_d1e172425"/><pre class="programlisting"><em class="lineannotation"><span class="lineannotation">Type Control-D to terminate “cat &gt;p”</span></em>
Ready: 1
  fd=4; events: EPOLLHUP
    closing fd 4
All file descriptors closed; bye</pre><div class="example"><a id="using_the_epoll_api"/><div class="example-title">Example 63-5. Using the <span class="emphasis"><em>epoll</em></span> API</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>altio/epoll_input.c</code></strong>
    #include &lt;sys/epoll.h&gt;
    #include &lt;fcntl.h&gt;
    #include "tlpi_hdr.h"

    #define MAX_BUF     1000        /* Maximum bytes fetched by a single read() */
    #define MAX_EVENTS     5        /* Maximum number of events to be returned from
                                       a single epoll_wait() call */

    int
    main(int argc, char *argv[])
    {
        int epfd, ready, fd, s, j, num0penFds;
        struct epoll_event ev;
        struct epoll_event evlist[MAX_EVENTS];
        char buf[MAX_BUF];

        if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
            usageErr("%s file...\n", argv[0]);

<img src="figs/web/U001.png" alt=""/>    epfd = epoll_create(argc - 1);
        if (epfd == -1)
            errExit("epoll_create");

        /* Open each file on command line, and add it to the "interest
           list" for the epoll instance */

<img src="figs/web/U002.png" alt=""/>    for (j = 1; j &lt; argc; j++) {
            fd = open(argv[j], O_RDONLY);
            if (fd == -1)
                errExit("open");
            printf("Opened \"%s\" on fd %d\n", argv[j], fd);

            ev.events = EPOLLIN;            /* Only interested in input events */
            ev.data.fd = fd;
<img src="figs/web/U003.png" alt=""/>        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev) == -1)
                errExit("epoll_ctl");
        }

        numOpenFds = argc - 1;

<img src="figs/web/U004.png" alt=""/>    while (numOpenFds &gt; 0) {

            /* Fetch up to MAX_EVENTS items from the ready list */

            printf("About to epoll_wait()\n");
<img src="figs/web/U005.png" alt=""/>        ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);
            if (ready == -1) {
<img src="figs/web/U006.png" alt=""/>            if (errno == EINTR)
                    continue;               /* Restart if interrupted by signal */
                else
                    errExit("epoll_wait");
            }

                printf("Ready: %d\n", ready);

            /* Deal with returned list of events */

<img src="figs/web/U007.png" alt=""/>        for (j = 0; j &lt; ready; j++) {
                printf("  fd=%d; events: %s%s%s\n", evlist[j].data.fd,
                        (evlist[j].events &amp; EPOLLIN)  ? "EPOLLIN "  : "",
                        (evlist[j].events &amp; EPOLLHUP) ? "EPOLLHUP " : "",
                        (evlist[j].events &amp; EPOLLERR) ? "EPOLLERR " : "");

<img src="figs/web/U008.png" alt=""/>            if (evlist[j].events &amp; EPOLLIN) {
                    s = read(evlist[j].data.fd, buf, MAX_BUF);
                    if (s == -1)
                        errExit("read");
                    printf("    read %d bytes: %.*s\n", s, s, buf);

<img src="figs/web/U009.png" alt=""/>            } else if (evlist[j].events &amp; (EPOLLHUP | EPOLLERR)) {

                    /* If EPOLLIN and EPOLLHUP were both set, then there might
                       be more than MAX_BUF bytes to read. Therefore, we close
                       the file descriptor only if EPOLLIN was not set.
                       We'll read further bytes after the next epoll_wait(). */

                    printf("    closing fd %d\n", evlist[j].data.fd);
<img src="figs/web/U010.png" alt=""/>                if (close(evlist[j].data.fd) == -1)
                        errExit("close");
                    numOpenFds--;
                }
            }
        }

        printf("All file descriptors closed; bye\n");
        exit(EXIT_SUCCESS);
    }

          <strong class="userinput"><code>altio/epoll_input.c</code></strong></pre></div></div></div></div><div class="sect2" title="A Closer Look at epoll Semantics"><div class="titlepage"><div><div><h3 class="title" id="a_closer_look_at_epoll_semantics">A Closer Look at <span class="emphasis"><em>epoll</em></span> Semantics</h3></div></div></div><p>We now look at some subtleties of the interaction of open files, file
                    descriptors, and <span class="emphasis"><em>epoll</em></span>. For the purposes of this
                    discussion, it is worth reviewing <a class="xref" href="ch05.html#relationship_between_file_descriptors_co" title="Figure 5-2. Relationship between file descriptors, open file descriptions, and i-nodes">Figure 5-2</a> (page 95), which shows
                    the relationship between file descriptors, open file descriptions, and the
                    system-wide file i-node table.<a id="IDX-CHP-63-8754" class="indexterm"/></p><p>When we create an <span class="emphasis"><em>epoll</em></span> instance using
                        <span class="emphasis"><em>epoll_create()</em></span>, the kernel creates a new in-memory
                    i-node and open file description, and allocates a new file descriptor in the
                    calling process that refers to the open file description. The interest list for
                    an <span class="emphasis"><em>epoll</em></span> instance is associated with the open file
                    description, not with the <span class="emphasis"><em>epoll</em></span> file descriptor. This has
                    the following consequences:<a id="IDX-CHP-63-8755" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If we duplicate an <span class="emphasis"><em>epoll</em></span> file descriptor using
                                <span class="emphasis"><em>dup()</em></span> (or similar), then the duplicated
                            descriptor refers to the same <span class="emphasis"><em>epoll</em></span> interest and
                            ready lists as the original descriptor. We may modify the interest list
                            by specifying either file descriptor as the <span class="emphasis"><em>epfd</em></span>
                            argument in a call to <span class="emphasis"><em>epoll_ctl()</em></span>. Similarly, we
                            can retrieve items from the ready list by specifying either file
                            descriptor as the <span class="emphasis"><em>epfd</em></span> argument in a call to
                                <span class="emphasis"><em>epoll_wait()</em></span>.<a id="IDX-CHP-63-8756" class="indexterm"/><a id="IDX-CHP-63-8757" class="indexterm"/></p></li><li class="listitem"><p>The preceding point also applies after a call to
                                <span class="emphasis"><em>fork()</em></span>. The child inherits a duplicate of the
                            parent’s <span class="emphasis"><em>epoll</em></span> file descriptor, and this duplicate
                            descriptor refers to the same <span class="emphasis"><em>epoll</em></span> data
                            structures.</p></li></ul></div><p>When we perform an <span class="emphasis"><em>epoll_ctl()</em></span>
                    <code class="literal">EPOLL_CTL_ADD</code> operation, the kernel adds an
                    item to the <span class="emphasis"><em>epoll</em></span> interest list that records both the
                    number of the monitored file descriptor and a reference to the corresponding
                    open file description. For the purpose of <span class="emphasis"><em>epoll_wait()</em></span>
                    calls, the kernel monitors the open file description. This means that we must
                    refine our earlier statement that when a file descriptor is closed, it is
                    automatically removed from any <span class="emphasis"><em>epoll</em></span> interest lists of
                    which it is a member. The refinement is this: an open file description is
                    removed from the <span class="emphasis"><em>epoll</em></span> interest list once all file
                    descriptors that refer to it have been closed. This means that if we create
                    duplicate descriptors referring to an open file—using <span class="emphasis"><em>dup()</em></span>
                    (or similar) or <span class="emphasis"><em>fork()</em></span>—then the open file will be removed
                    only after the original descriptor and all of the duplicates have been
                    closed.</p><p>These semantics can lead to some behavior that at first appears surprising.
                    Suppose that we execute the code shown in <a class="xref" href="ch63.html#semantics_of_epoll_with_duplicate_file_d" title="Example 63-6. Semantics of epoll with duplicate file descriptors">Example 63-6</a>. The
                        <span class="emphasis"><em>epoll_wait()</em></span> call in this code will tell us that the
                    file descriptor <span class="emphasis"><em>fd1</em></span> is ready (in other words,
                        <span class="emphasis"><em>evlist[0].data.fd</em></span> will be equal to
                        <span class="emphasis"><em>fd1</em></span>), even though <span class="emphasis"><em>fd1</em></span> has been
                    closed. This is because there is still one open file descriptor,
                        <span class="emphasis"><em>fd2</em></span>, referring to the open file description contained
                    in the <span class="emphasis"><em>epoll</em></span> interest list. A similar scenario occurs when
                    two processes hold duplicate descriptors for the same open file description
                    (typically, as a result of a <span class="emphasis"><em>fork()</em></span>), and the process
                    performing the <span class="emphasis"><em>epoll_wait()</em></span> has closed its file descriptor,
                    but the other process still holds the duplicate descriptor open.</p><div class="example"><a id="semantics_of_epoll_with_duplicate_file_d"/><div class="example-title">Example 63-6. Semantics of <span class="emphasis"><em>epoll</em></span> with duplicate file
                        descriptors</div><div class="example-contents"><pre class="programlisting">int epfd, fd1, fd2;
    struct epoll_event ev;
    struct epoll_event evlist[MAX_EVENTS];

    /* Omitted: code to open 'fd1' and create epoll file descriptor 'epfd' ... */

    ev.data.fd = fd1
    ev.events = EPOLLIN;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, ev) == -1)
        errExit("epoll_ctl");

    /* Suppose that 'fd1' now happens to become ready for input */

    fd2 = dup(fd1);
    close(fd1);
    ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);
    if (ready == -1)
        errExit("epoll_wait");</pre></div></div></div><div class="sect2" title="Performance of epoll Versus I/O Multiplexing"><div class="titlepage"><div><div><h3 class="title" id="performance_of_epoll_versus_i_solidus_o">Performance of <span class="emphasis"><em>epoll</em></span> Versus I/O Multiplexing</h3></div></div></div><p><a class="xref" href="ch63.html#times_taken_by_poll_open_parenthesis_clo" title="Table 63-9. Times taken by poll(), select(), and epoll for 100,000 monitoring operations">Table 63-9</a> shows the results
                    (on Linux 2.6.25) when we monitor <span class="emphasis"><em>N</em></span> contiguous file
                    descriptors in the range <span class="emphasis"><em>0</em></span> to <span class="emphasis"><em>N - 1</em></span>
                    using <span class="emphasis"><em>poll()</em></span>, <span class="emphasis"><em>select()</em></span>, and
                        <span class="emphasis"><em>epoll</em></span>. (The test was arranged such that during each
                    monitoring operation, exactly one randomly selected file descriptor is ready.)
                    From this table, we see that as the number of file descriptors to be monitored
                    grows large, <span class="emphasis"><em>poll()</em></span> and <span class="emphasis"><em>select()</em></span>
                    perform poorly. By contrast, the performance of <span class="emphasis"><em>epoll</em></span>
                    hardly declines as <span class="emphasis"><em>N</em></span> grows large. (The small decline in
                    performance as <span class="emphasis"><em>N</em></span> increases is possibly a result of reaching
                    CPU caching limits on the test system.)<a id="IDX-CHP-63-8758" class="indexterm"/><a id="IDX-CHP-63-8759" class="indexterm"/><a id="IDX-CHP-63-8760" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>For the purposes of this test, <code class="literal">FD_SETSIZE</code> was changed to 16,384 in the
                            <span class="emphasis"><em>glibc</em></span> header files to allow the test program to
                        monitor large numbers of file descriptors using
                            <span class="emphasis"><em>select()</em></span>.</p></div><div class="table"><a id="times_taken_by_poll_open_parenthesis_clo"/><div class="table-title">Table 63-9. Times taken by <span class="emphasis"><em>poll()</em></span>,
                        <span class="emphasis"><em>select()</em></span>, and <span class="emphasis"><em>epoll</em></span> for 100,000
                        monitoring operations</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Number of descriptors monitored
                                        (<span class="emphasis"><em>N</em></span>)</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p><span class="emphasis"><em>poll()</em></span> CPU time (seconds)</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p><span class="emphasis"><em>select()</em></span> CPU time (seconds)</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                    <p><span class="emphasis"><em>epoll</em></span> CPU time (seconds)</p>
                                </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">10</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">0.61</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">0.73</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">0.41</code>
                                    </p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">100</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">2.9</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">3.0</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">0.42</code>
                                    </p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">1000</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">35</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">35</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">0.53</code>
                                    </p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">10000</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">990</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">930</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; ">
                                    <p>
                                        <code class="literal">0.66</code>
                                    </p>
                                </td></tr></tbody></table></div></div><p>In <a class="xref" href="ch63.html#problems_with_select_open_parenthesis_cl" title="Problems with select() and poll()">Problems with <span class="emphasis"><em>select()</em></span> and
                    <span class="emphasis"><em>poll()</em></span></a>, we saw why
                        <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> perform poorly
                    when monitoring large numbers of file descriptors. We now look at the reasons
                    why <span class="emphasis"><em>epoll</em></span> performs better:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On each call to <span class="emphasis"><em>select()</em></span> or
                                <span class="emphasis"><em>poll()</em></span>, the kernel must check all of the file
                            descriptors specified in the call. By contrast, when we mark a
                            descriptor to be monitored with <span class="emphasis"><em>epoll_ctl()</em></span>, the
                            kernel records this fact in a list associated with the underlying open
                            file description, and whenever an I/O operation that makes the file
                            descriptor ready is performed, the kernel adds an item to the ready list
                            for the <span class="emphasis"><em>epoll</em></span> descriptor. (An I/O event on a single
                            open file description may cause multiple file descriptors associated
                            with that description to become ready.) Subsequent
                                <span class="emphasis"><em>epoll_wait()</em></span> calls simply fetch items from the
                            ready list.</p></li><li class="listitem"><p>Each time we call <span class="emphasis"><em>select()</em></span> or
                                <span class="emphasis"><em>poll()</em></span>, we pass a data structure to the kernel
                            that identifies all of the file descriptors that are to be monitored,
                            and, on return, the kernel passes back a data structure describing the
                            readiness of all of these descriptors. By contrast, with
                                <span class="emphasis"><em>epoll</em></span>, we use <span class="emphasis"><em>epoll_ctl()</em></span>
                            to build up a data structure <span class="emphasis"><em>in kernel space</em></span> that
                            lists the set of file descriptors to be monitored. Once this data
                            structure has been built, each later call to
                                <span class="emphasis"><em>epoll_wait()</em></span> doesn’t need to pass any
                            information about file descriptors to the kernel, and the call returns
                            information about only those descriptors that are ready.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>In addition to the above points, for <span class="emphasis"><em>select()</em></span>, we
                        must initialize the input data structure prior to each call, and for both
                            <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>, we must
                        inspect the returned data structure to find out which of the
                            <span class="emphasis"><em>N</em></span> file descriptors are ready. However, some testing
                        showed that the time required for these other steps was insignificant
                        compared to the time required for the system call to monitor
                            <span class="emphasis"><em>N</em></span> descriptors. <a class="xref" href="ch63.html#times_taken_by_poll_open_parenthesis_clo" title="Table 63-9. Times taken by poll(), select(), and epoll for 100,000 monitoring operations">Table 63-9</a> doesn’t include the
                        times for the inspection step.</p></div><p>Very roughly, we can say that for large values of <span class="emphasis"><em>N</em></span> (the
                    number of file descriptors being monitored), the performance of
                        <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> scales
                    linearly with <span class="emphasis"><em>N</em></span>. We start to see this behavior for the
                        <span class="emphasis"><em>N = 100</em></span> and <span class="emphasis"><em>N = 1000</em></span> cases in
                        <a class="xref" href="ch63.html#times_taken_by_poll_open_parenthesis_clo" title="Table 63-9. Times taken by poll(), select(), and epoll for 100,000 monitoring operations">Table 63-9</a>. By the time we
                    reach <span class="emphasis"><em>N = 10000</em></span>, the scaling has actually become worse than
                    linear.</p><p>By contrast, <span class="emphasis"><em>epoll</em></span> scales (linearly) according to the
                    number of I/O events that occur. The <span class="emphasis"><em>epoll</em></span> API is thus
                    particularly efficient in a scenario that is common in servers that handle many
                    simultaneous clients: of the many file descriptors being monitored, most are
                    idle; only a few descriptors are ready.</p></div><div class="sect2" title="Edge-Triggered Notification"><div class="titlepage"><div><div><h3 class="title" id="edge-triggered_notification">Edge-Triggered Notification</h3></div></div></div><p>By default, the <span class="emphasis"><em>epoll</em></span> mechanism provides
                        <span class="emphasis"><em>level-triggered</em></span> notification. By this, we mean that
                        <span class="emphasis"><em>epoll</em></span> tells us whether an I/O operation can be
                    performed on a file descriptor without blocking. This is the same type of
                    notification as is provided by <span class="emphasis"><em>poll()</em></span> and
                        <span class="emphasis"><em>select()</em></span>.<a id="IDX-CHP-63-8761" class="indexterm"/></p><p>The <span class="emphasis"><em>epoll</em></span> API also allows for
                        <span class="emphasis"><em>edge-triggered</em></span> notification—that is, a call to
                        <span class="emphasis"><em>epoll_wait()</em></span> tells us if there has been I/O activity on
                    a file descriptor since the previous call to <span class="emphasis"><em>epoll_wait()</em></span>
                    (or since the descriptor was opened, if there was no previous call). Using
                        <span class="emphasis"><em>epoll</em></span> with edge-triggered notification is semantically
                    similar to signal-driven I/O, except that if multiple I/O events occur,
                        <span class="emphasis"><em>epoll</em></span> coalesces them into a single notification
                    returned via <span class="emphasis"><em>epoll_wait()</em></span>; with signal-driven I/O, multiple
                    signals may be generated.<a id="IDX-CHP-63-8762" class="indexterm"/><a id="IDX-CHP-63-8763" class="indexterm"/><a id="IDX-CHP-63-8764" class="indexterm"/></p><p>To employ edge-triggered notification, we specify the <code class="literal">EPOLLET</code> flag in <span class="emphasis"><em>ev.events</em></span> when calling
                        <span class="emphasis"><em>epoll_ctl()</em></span>:</p><a id="I_programlisting63_d1e173018"/><pre class="programlisting">struct epoll_event ev;

ev.data.fd = fd
ev.events = EPOLLIN | EPOLLET;
if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)
    errExit("epoll_ctl");</pre><p>We illustrate the difference between level-triggered and edge-triggered
                        <span class="emphasis"><em>epoll</em></span> notification using an example. Suppose that we
                    are using <span class="emphasis"><em>epoll</em></span> to monitor a socket for input (<code class="literal">EPOLLIN</code>), and the following steps occur:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Input arrives on the socket.</p></li><li class="listitem"><p>We perform an <span class="emphasis"><em>epoll_wait()</em></span>. This call will tell
                            us that the socket is ready, regardless of whether we are employing
                            level-triggered or edge-triggered notification.</p></li><li class="listitem"><p>We perform a second call to <span class="emphasis"><em>epoll_wait()</em></span>.</p></li></ol></div><p>If we are employing level-triggered notification, then the second
                        <span class="emphasis"><em>epoll_wait()</em></span> call will inform us that the socket is
                    ready. If we are employing edge-triggered notification, then the second call to
                        <span class="emphasis"><em>epoll_wait()</em></span> will block, because no new input has
                    arrived since the previous call to <span class="emphasis"><em>epoll_wait()</em></span>.</p><p>As we noted in <a class="xref" href="ch63.html#which_technique_question"/>, edge-triggered
                    notification is usually employed in conjunction with nonblocking file
                    descriptors. Thus, the general framework for using edge-triggered
                        <span class="emphasis"><em>epoll</em></span> notification is as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Make all file descriptors that are to be monitored nonblocking.</p></li><li class="listitem"><p>Build the <span class="emphasis"><em>epoll</em></span> interest list using
                                <span class="emphasis"><em>epoll_ctl()</em></span>.</p></li><li class="listitem"><p>Handle I/O events using the following loop:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Retrieve a list of ready descriptors using
                                        <span class="emphasis"><em>epoll_wait()</em></span>.</p></li><li class="listitem"><p>For each file descriptor that is ready, process I/O until the
                                    relevant system call (e.g., <span class="emphasis"><em>read()</em></span>,
                                        <span class="emphasis"><em>write()</em></span>, <span class="emphasis"><em>recv()</em></span>,
                                        <span class="emphasis"><em>send()</em></span>, or
                                        <span class="emphasis"><em>accept()</em></span>) returns with the error
                                        <span class="emphasis"><em>EAGAIN</em></span> or <code class="literal">EWOULDBLOCK</code>.</p></li></ol></div></li></ol></div><div class="sect3" title="Preventing file-descriptor starvation when using edge-triggered notification"><div class="titlepage"><div><div><h4 class="title" id="preventing_file-descriptor_starvation_wh">Preventing file-descriptor starvation when using edge-triggered
                        notification</h4></div></div></div><p>Suppose that we are monitoring multiple file descriptors using
                        edge-triggered notification, and that a ready file descriptor has a large
                        amount (perhaps an endless stream) of input available. If, after detecting
                        that this file descriptor is ready, we attempt to consume all of the input
                        using nonblocking reads, then we risk starving the other file descriptors of
                        attention (i.e., it may be a long time before we again check them for
                        readiness and perform I/O on them). One solution to this problem is for the
                        application to maintain a list of file descriptors that have been notified
                        as being ready, and execute a loop that continuously performs the following
                            actions:<a id="IDX-CHP-63-8765" class="indexterm"/><a id="IDX-CHP-63-8766" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Monitor the file descriptors using
                                    <span class="emphasis"><em>epoll_wait()</em></span> and add ready descriptors to
                                the application list. If any file descriptors are already registered
                                as being ready in the application list, then the timeout for this
                                monitoring step should be small or 0, so that if no new file
                                descriptors are ready, the application can quickly proceed to the
                                next step and service any file descriptors that are already known to
                                be ready.</p></li><li class="listitem"><p>Perform a limited amount of I/O on those file descriptors
                                registered as being ready in the application list (perhaps cycling
                                through them in round-robin fashion, rather than always starting
                                from the beginning of the list after each call to
                                    <span class="emphasis"><em>epoll_wait()</em></span>). A file descriptor can be
                                removed from the application list when the relevant nonblocking I/O
                                system call fails with the <code class="literal">EAGAIN</code>
                                or <code class="literal">EWOULDBLOCK</code> error.<a id="IDX-CHP-63-8767" class="indexterm"/></p></li></ol></div><p>Although it requires extra programming work, this approach offers other
                        benefits in addition to preventing file-descriptor starvation. For example,
                        we can include other steps in the above loop, such as handling timers and
                        accepting signals with <span class="emphasis"><em>sigwaitinfo()</em></span> (or
                            similar).<a id="IDX-CHP-63-8768" class="indexterm"/></p><p>Starvation considerations can also apply when using signal-driven I/O,
                        since it also presents an edge-triggered notification mechanism. By
                        contrast, starvation considerations don’t necessarily apply in applications
                        employing a level-triggered notification mechanism. This is because we can
                        employ blocking file descriptors with level-triggered notification and use a
                        loop that continuously checks descriptors for readiness, and then performs
                            <span class="emphasis"><em>some</em></span> I/O on the ready descriptors before once more
                        checking for ready file descriptors.<a id="IDX-CHP-63-8769" class="indexterm"/></p></div></div></div><div class="sect1" title="Waiting on Signals and File Descriptors"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="waiting_on_signals_and_file_descriptors">Waiting on Signals and File Descriptors</h2></div></div></div><p>Sometimes, a process needs to simultaneously wait for I/O to become possible on
                one of a set of file descriptors or for the delivery of a signal. We might attempt
                to perform such an operation using <span class="emphasis"><em>select()</em></span>, as shown in <a class="xref" href="ch63.html#incorrect_method_of_unblocking_signals_a" title="Example 63-7. Incorrect method of unblocking signals and calling select()">Example 63-7</a>.</p><div class="example"><a id="incorrect_method_of_unblocking_signals_a"/><div class="example-title">Example 63-7. Incorrect method of unblocking signals and calling
                        <span class="emphasis"><em>select()</em></span></div><div class="example-contents"><pre class="programlisting">sig_atomic_t gotSig = 0;

void
handler(int sig)
{
    gotSig = 1;
}

int
main(int argc, char *argv[])
{
    struct sigaction sa;
    ...

    sa.sa_sigaction = handler;
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = 0;
    if (sigaction(SIGUSR1, &amp;sa, NULL) == -1)
        errExit("sigaction");

    /* What if the signal is delivered now? */

    ready = select(nfds, &amp;readfds, NULL, NULL, NULL);
    if (ready &gt; 0) {
        printf("%d file descriptors ready\n", ready);
    } else if (ready == -1 &amp;&amp; errno == EINTR) {
        if (gotSig)
            printf("Got signal\n");
    } else {
        /* Some other error */
    }

    ...
}</pre></div></div><p>The problem with this code is that if the signal (<code class="literal">SIGUSR1</code> in this example) arrives after establishing the handler but
                before <span class="emphasis"><em>select()</em></span> is called, then the
                    <span class="emphasis"><em>select()</em></span> call will nevertheless block. (This is a form of
                race condition.) We now look at some solutions to this problem.<a id="IDX-CHP-63-8770" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since version 2.6.27, Linux provides a further technique that can be used to
                    simultaneously wait on signals and file descriptors: the
                        <span class="emphasis"><em>signalfd</em></span> mechanism described in Section 22.11. Using
                    this mechanism, we can receive signals via a file descriptor that is monitored
                    (along with other file descriptors) using <span class="emphasis"><em>select()</em></span>,
                        <span class="emphasis"><em>poll()</em></span>, or <span class="emphasis"><em>epoll_wait()</em></span>.</p></div><div class="sect2" title="The pselect() System Call"><div class="titlepage"><div><div><h3 class="title" id="the_pselect_open_parenthesis_close_paren">The <span class="emphasis"><em>pselect()</em></span> System Call</h3></div></div></div><p>The <span class="emphasis"><em>pselect()</em></span> system call performs a similar task to
                        <span class="emphasis"><em>select()</em></span>. The main semantic difference is an additional
                    argument, <span class="emphasis"><em>sigmask</em></span>, that specifies a set of signals to be
                    unmasked while the call is blocked.<a id="IDX-CHP-63-8772" class="indexterm"/><a id="IDX-CHP-63-8773" class="indexterm"/><a id="IDX-CHP-63-8774" class="indexterm"/><a id="IDX-CHP-63-8775" class="indexterm"/><a id="IDX-CHP-63-8771" class="indexterm"/></p><a id="I_programlisting63_d1e173258"/><pre class="programlisting">#include &lt;sys/select.h&gt;

int <strong class="userinput"><code>pselect</code></strong>(int <span class="emphasis"><em>nfds</em></span>, fd_set *<span class="emphasis"><em>readfds</em></span>, fd_set *<span class="emphasis"><em>writefds</em></span>, fd_set *<span class="emphasis"><em>exceptfds</em></span>,
            struct timespec *<span class="emphasis"><em>timeout</em></span>, const sigset_t *<span class="emphasis"><em>sigmask</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of ready file descriptors, 0 on timeout, or -1 on
                        error</p></div><p>More precisely, suppose we have the following <span class="emphasis"><em>pselect()</em></span>
                    call:</p><a id="I_programlisting63_d1e173290"/><pre class="programlisting">ready = pselect(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds, timeout, &amp;sigmask);</pre><p>This call is equivalent to <span class="emphasis"><em>atomically</em></span> performing the
                    following steps:</p><a id="I_programlisting63_d1e173297"/><pre class="programlisting">sigset_t origmask;

sigprocmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);
ready = select(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds, timeout);
sigprocmask(SIG_SETMASK, &amp;origmask, NULL);        /* Restore signal mask */</pre><p>Using <span class="emphasis"><em>pselect()</em></span>, we can recode the first part of the body
                    of our main program in <a class="xref" href="ch63.html#incorrect_method_of_unblocking_signals_a" title="Example 63-7. Incorrect method of unblocking signals and calling select()">Example 63-7</a> as shown in <a class="xref" href="ch63.html#using_pselect_open_parenthesis_close_par" title="Example 63-8. Using pselect()">Example 63-8</a>.</p><p>Aside from the <span class="emphasis"><em>sigmask</em></span> argument,
                        <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>pselect()</em></span> differ in
                    the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>timeout</em></span> argument to
                                <span class="emphasis"><em>pselect()</em></span> is a <span class="emphasis"><em>timespec</em></span>
                            structure (<a class="xref" href="ch23.html#high-resolution_sleeping_colon_nanosleep" title="High-Resolution Sleeping: nanosleep()">High-Resolution Sleeping: <span class="emphasis"><em>nanosleep()</em></span></a>),
                            which allows the timeout to be specified with nanosecond (instead of
                            microsecond) precision.<a id="IDX-CHP-63-8776" class="indexterm"/></p></li><li class="listitem"><p>SUSv3 explicitly states that <span class="emphasis"><em>pselect()</em></span> doesn’t
                            modify the <span class="emphasis"><em>timeout</em></span> argument on return.</p></li></ul></div><p>If we specify the <span class="emphasis"><em>sigmask</em></span> argument of
                        <span class="emphasis"><em>pselect()</em></span> as <code class="literal">NULL</code>,
                    then <span class="emphasis"><em>pselect()</em></span> is equivalent to
                        <span class="emphasis"><em>select()</em></span> (i.e., it performs no manipulation of the
                    process signal mask), except for the differences just noted.</p><p>The <span class="emphasis"><em>pselect()</em></span> interface is an invention of POSIX.1g, and
                    is nowadays incorporated in SUSv3. It is not available on all UNIX
                    implementations, and was added to Linux only in kernel 2.6.16.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Previously, a <span class="emphasis"><em>pselect()</em></span> library function was provided
                        by <span class="emphasis"><em>glibc</em></span>, but this implementation didn’t provide the
                        atomicity guarantees that are required for the correct operation of the
                        call. Such guarantees can be provided only by a kernel implementation of
                            <span class="emphasis"><em>pselect()</em></span>.</p></div><div class="example"><a id="using_pselect_open_parenthesis_close_par"/><div class="example-title">Example 63-8. Using <span class="emphasis"><em>pselect()</em></span></div><div class="example-contents"><pre class="programlisting">sigset_t emptyset, blockset;
    struct sigaction sa;

    sigemptyset(&amp;blockset);
    sigaddset(&amp;blockset, SIGUSR1);

    if (sigprocmask(SIG_BLOCK, &amp;blockset, NULL) == -1)
        errExit("sigprocmask");

    sa.sa_sigaction = handler;
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGUSR1, &amp;sa, NULL) == -1)
        errExit("sigaction");

    sigemptyset(&amp;emptyset);
    ready = pselect(nfds, &amp;readfds, NULL, NULL, NULL, &amp;emptyset);
    if (ready == -1)
        errExit("pselect");</pre></div></div><div class="sect3" title="The ppoll() and epoll_pwait() system calls"><div class="titlepage"><div><div><h4 class="title" id="the_ppoll_open_parenthesis_close_parenth">The <span class="emphasis"><em>ppoll()</em></span> and <span class="emphasis"><em>epoll_pwait()</em></span>
                        system calls</h4></div></div></div><p>Linux 2.6.16 also added a new, nonstandard system call,
                            <span class="emphasis"><em>ppoll()</em></span>, whose relationship to
                            <span class="emphasis"><em>poll()</em></span> is analogous to the relationship of
                            <span class="emphasis"><em>pselect()</em></span> to <span class="emphasis"><em>select()</em></span>.
                        Similarly, starting with kernel 2.6.19, Linux also includes
                            <span class="emphasis"><em>epoll_pwait()</em></span>, providing an analogous extension to
                            <span class="emphasis"><em>epoll_wait()</em></span>. See the <span class="emphasis"><em>ppoll(2)</em></span>
                        and <span class="emphasis"><em>epoll_pwait(2)</em></span> manual pages for details.<a id="IDX-CHP-63-8779" class="indexterm"/><a id="IDX-CHP-63-8780" class="indexterm"/><a id="IDX-CHP-63-8777" class="indexterm"/><a id="IDX-CHP-63-8778" class="indexterm"/></p></div></div><div class="sect2" title="The Self-Pipe Trick"><div class="titlepage"><div><div><h3 class="title" id="the_self-pipe_trick">The Self-Pipe Trick</h3></div></div></div><p>Since <span class="emphasis"><em>pselect()</em></span> is not widely implemented, portable
                    applications must employ other strategies to avoid race conditions when
                    simultaneously waiting for signals and calling <span class="emphasis"><em>select()</em></span> on
                    a set of file descriptors. One common solution is the following:<a id="IDX-CHP-63-8781" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Create a pipe, and mark its read and write ends as nonblocking.</p></li><li class="listitem"><p>As well as monitoring all of the other file descriptors that are of
                            interest, include the read end of the pipe in the
                                <span class="emphasis"><em>readfds</em></span> set given to
                                <span class="emphasis"><em>select()</em></span>.</p></li><li class="listitem"><p>Install a handler for the signal that is of interest. When this signal
                            handler is called, it writes a byte of data to the pipe. Note the
                            following points about the signal handler:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The write end of the pipe was marked as nonblocking in the
                                    first step to prevent the possibility that signals arrive so
                                    rapidly that repeated invocations of the signal handler fill the
                                    pipe, with the result that the signal handler’s
                                        <span class="emphasis"><em>write()</em></span> (and thus the process itself)
                                    is blocked. (It doesn’t matter if a write to a full pipe fails,
                                    since the previous writes will already have indicated the
                                    delivery of the signal.)</p></li><li class="listitem"><p>The signal handler is installed after creating the pipe, in
                                    order to prevent the race condition that would occur if a signal
                                    was delivered before the pipe was created.</p></li><li class="listitem"><p>It is safe to use <span class="emphasis"><em>write()</em></span> inside the
                                    signal handler, because it is one of the async-signal-safe
                                    functions listed in <a class="xref" href="ch21.html#functions_required_to_be_async-signal-sa" title="Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3">Table 21-1</a>, in
                                        <a class="xref" href="ch21.html#standard_async-signal-safe_functions" title="Standard async-signal-safe functions">Standard async-signal-safe functions</a>.</p></li></ul></div></li><li class="listitem"><p>Place the <span class="emphasis"><em>select()</em></span> call in a loop, so that it is
                            restarted if interrupted by a signal handler. (Restarting in this
                            fashion is not strictly necessary; it merely means that we can check for
                            the arrival of a signal by inspecting <span class="emphasis"><em>readfds</em></span>,
                            rather than checking for an <code class="literal">EINTR</code>
                            error return.)</p></li><li class="listitem"><p>On successful completion of the <span class="emphasis"><em>select()</em></span> call, we
                            can determine whether a signal arrived by checking if the file
                            descriptor for the read end of the pipe is set in
                                <span class="emphasis"><em>readfds</em></span>.</p></li><li class="listitem"><p>Whenever a signal has arrived, read all bytes that are in the pipe.
                            Since multiple signals may arrive, employ a loop that reads bytes until
                            the (nonblocking) <span class="emphasis"><em>read()</em></span> fails with the error
                                <code class="literal">EAGAIN</code>. After draining the pipe,
                            perform whatever actions must be taken in response to delivery of the
                            signal.</p></li></ol></div><p>This technique is commonly known as the <span class="emphasis"><em>self-pipe trick</em></span>,
                    and code demonstrating this technique is shown in <a class="xref" href="ch63.html#using_the_self-pipe_trick" title="Example 63-9. Using the self-pipe trick">Example 63-9</a>.</p><p>Variations on this technique can equally be employed with
                        <span class="emphasis"><em>poll()</em></span> and <span class="emphasis"><em>epoll_wait()</em></span>.</p><div class="example"><a id="using_the_self-pipe_trick"/><div class="example-title">Example 63-9. Using the self-pipe trick</div><div class="example-contents"><pre class="programlisting"><span class="emphasis"><em>from</em></span> <strong class="userinput"><code>altio/self_pipe.c</code></strong>
static int pfd[2];                      /* File descriptors for pipe */

static void
handler(int sig)
{
    int savedErrno;                     /* In case we change 'errno' */

    savedErrno = errno;
    if (write(pfd[1], "x", 1) == -1 &amp;&amp; errno != EAGAIN)
        errExit("write");
    errno = savedErrno;
}

int
main(int argc, char *argv[])
{
    fd_set readfds;
    int ready, nfds, flags;
    struct timeval timeout;
    struct timeval *pto;
    struct sigaction sa;
    char ch;

    /* ... Initialize 'timeout', 'readfds', and 'nfds' for select() */

    if (pipe(pfd) == -1)
        errExit("pipe");

    FD_SET(pfd[0], &amp;readfds);           /* Add read end of pipe to 'readfds' */
    nfds = max(nfds, pfd[0] + 1);       /* And adjust 'nfds' if required */

    flags = fcntl(pfd[0], F_GETFL);
    if (flags == -1)
        errExit("fcntl-F_GETFL");
    flags |= O_NONBLOCK;                /* Make read end nonblocking */
    if (fcntl(pfd[0], F_SETFL, flags) == -1)
        errExit("fcntl-F_SETFL");

    flags = fcntl(pfd[1], F_GETFL);
    if (flags == -1)
        errExit("fcntl-F_GETFL");
    flags |= O_NONBLOCK;                /* Make write end nonblocking */
    if (fcntl(pfd[1], F_SETFL, flags) == -1)
        errExit("fcntl-F_SETFL");

    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;           /* Restart interrupted read()s */
    sa.sa_handler = handler;
    if (sigaction(SIGINT, &amp;sa, NULL) == -1)
        errExit("sigaction");

    while ((ready = select(nfds, &amp;readfds, NULL, NULL, pto)) == -1 &amp;&amp;
            errno == EINTR)
        continue;                       /* Restart if interrupted by signal */
    if (ready == -1)                    /* Unexpected error */
        errExit("select");

    if (FD_ISSET(pfd[0], &amp;readfds)) {   /* Handler was called */
        printf("A signal was caught\n");

        for (;;) {                      /* Consume bytes from pipe */
            if (read(pfd[0], &amp;ch, 1) == -1) {
                if (errno == EAGAIN)
                    break;              /* No more bytes */
                else
                    errExit("read");    /* Some other error */
            }

            /* Perform any actions that should be taken in response to signal */
        }
    }

    /* Examine file descriptor sets returned by select() to see
       which other file descriptors are ready */

}
      <span class="emphasis"><em>from</em></span> <strong class="userinput"><code>altio/self_pipe.c</code></strong></pre></div></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id62">Summary</h2></div></div></div><p>In this chapter, we explored various alternatives to the standard model for
                performing I/O: I/O multiplexing (<span class="emphasis"><em>select()</em></span> and
                    <span class="emphasis"><em>poll()</em></span>), signal-driven I/O, and the Linux-specific
                    <span class="emphasis"><em>epoll</em></span> API. All of these mechanisms allow us to monitor
                multiple file descriptors to see if I/O is possible on any of them. None of these
                mechanisms actually performs I/O. Instead, once we have determined that a file
                descriptor is ready, we use the traditional I/O system calls to perform the
                I/O.</p><p>The <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> I/O multiplexing
                calls simultaneously monitor multiple file descriptors to see if I/O is possible on
                any of the descriptors. With both system calls, we pass a complete list of
                to-be-checked file descriptors to the kernel on each system call, and the kernel
                returns a modified list indicating which descriptors are ready. The fact that
                complete file descriptor lists are passed and checked on each call means that
                    <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span> perform poorly
                when monitoring large numbers of file descriptors.</p><p>Signal-driven I/O allows a process to receive a signal when I/O is possible on a
                file descriptor. To enable signal-driven I/O, we must establish a handler for the
                    <code class="literal">SIGIO</code> signal, set the owner process that is
                to receive the signal, and enable signal generation by setting the <code class="literal">O_ASYNC</code> open file status flag. This mechanism offers
                significant performance benefits over I/O multiplexing when monitoring large numbers
                of file descriptors. Linux allows us to change the signal used for notification, and
                if we instead employ a realtime signal, then multiple notifications can be queued,
                and the signal handler can use its <span class="emphasis"><em>siginfo_t</em></span> argument to
                determine the file descriptor and event type that generated the signal.</p><p>Like signal-driven I/O, <span class="emphasis"><em>epoll</em></span> offers superior performance
                when monitoring large numbers of file descriptors. The performance advantage of
                    <span class="emphasis"><em>epoll</em></span> (and signal-driven I/O) derives from the fact that
                the kernel “remembers” the list of file descriptors that a process is monitoring (by
                contrast with <span class="emphasis"><em>select()</em></span> and <span class="emphasis"><em>poll()</em></span>, where
                each system call must again tell the kernel which file descriptors to check). The
                    <span class="emphasis"><em>epoll</em></span> API has some notable advantages over the use of
                signal-driven I/O: we avoid the complexities of dealing with signals and can specify
                which types of I/O events (e.g., input or output) are to be monitored.</p><p>In the course of this chapter, we drew a distinction between level-triggered and
                edge-triggered readiness notification. With a level-triggered notification model, we
                are informed whether I/O is currently possible on a file descriptor. By contrast,
                edge-triggered notification informs us whether I/O activity has occurred on a file
                descriptor since it was last monitored. The I/O multiplexing system calls offer a
                level-triggered notification model; signal-driven I/O approximates to an
                edge-triggered model; and <span class="emphasis"><em>epoll</em></span> is capable of operating under
                either model (level-triggered is the default). Edge-triggered notification is
                usually employed in conjunction with nonblocking I/O.</p><p>We concluded the chapter by looking at a problem that sometimes faces programs
                that monitor multiple file descriptors: how to simultaneously also wait for the
                delivery of a signal. The usual solution to this problem is the so-called self-pipe
                trick, whereby a handler for the signal writes a byte to a pipe whose read end is
                included among the set of monitored file descriptors. SUSv3 specifies
                    <span class="emphasis"><em>pselect()</em></span>, a variation of <span class="emphasis"><em>select()</em></span>
                that provides another solution to this problem. However,
                    <span class="emphasis"><em>pselect()</em></span> is not available on all UNIX implementations.
                Linux also provides the analogous (but nonstandard) <span class="emphasis"><em>ppoll()</em></span> and
                    <span class="emphasis"><em>epoll_pwait()</em></span>.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id88"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id89">Further information</h4></div></div></div><p>[Stevens et al., 2004] describes I/O multiplexing and signal-driven I/O,
                        with particular emphasis on the use of these mechanisms with sockets. [Gammo
                        et al, 2004] is a paper comparing the performance of
                            <span class="emphasis"><em>select()</em></span>, <span class="emphasis"><em>poll()</em></span>, and
                            <span class="emphasis"><em>epoll</em></span>.</p><p>A particularly interesting online resource is at <a class="ulink" href="http://www.kegel.com/c10k.html" target="_top">http://www.kegel.com/c10k.html</a>. Written by Dan Kegel, and
                        entitled “The C10K problem,” this web page explores the issues facing
                        developers of web servers designed to simultaneously serve tens of thousands
                        of clients. The web page includes a host of links to related
                        information.</p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id44">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Modify the program in <a class="xref" href="ch63.html#using_poll_open_parenthesis_close_parent" title="Example 63-2. Using poll() to monitor multiple file descriptors">Example 63-2</a>
                        <code class="literal">(poll_pipes.c)</code> to use
                            <span class="emphasis"><em>select()</em></span> instead of
                            <span class="emphasis"><em>poll()</em></span>.<a id="IDX-CHP-63-8782" class="indexterm"/><a id="IDX-CHP-63-8783" class="indexterm"/><a id="IDX-CHP-63-8784" class="indexterm"/></p></li><li class="listitem"><p>Write an <span class="emphasis"><em>echo</em></span> server (see <a class="xref" href="ch60.html#an_iterative_udp_echo_server" title="An Iterative UDP echo Server">An Iterative UDP <span class="emphasis"><em>echo</em></span> Server</a> and <a class="xref" href="ch60.html#a_concurrent_tcp_echo_server" title="A Concurrent TCP echo Server">A Concurrent TCP <span class="emphasis"><em>echo</em></span> Server</a>) that handles both TCP and UDP
                        clients. To do this, the server must create both a listening TCP socket and
                        a UDP socket, and then monitor both sockets using one of the techniques
                        described in this chapter.</p></li><li class="listitem"><p>Section 63.5 noted that <span class="emphasis"><em>select()</em></span> can’t be used to
                        wait on both signals and file descriptors, and described a solution using a
                        signal handler and a pipe. A related problem exists when a program needs to
                        wait for input on both a file descriptor and a System V message queue (since
                        System V message queues don’t use file descriptors). One solution is to fork
                        a separate child process that copies each message from the queue to a pipe
                        included among the file descriptors monitored by the parent. Write a program
                        that uses this scheme with <span class="emphasis"><em>select()</em></span> to monitor input
                        from both the terminal and a message queue.</p></li><li class="listitem"><p>The last step of the description of the self-pipe technique in <a class="xref" href="ch63.html#the_self-pipe_trick" title="The Self-Pipe Trick">The Self-Pipe Trick</a> stated that the program should first
                        drain the pipe, and then perform any actions that should be taken in
                        response to the signal. What might happen if these substeps were
                        reversed?</p></li><li class="listitem"><p>Modify the program in <a class="xref" href="ch63.html#using_the_self-pipe_trick" title="Example 63-9. Using the self-pipe trick">Example 63-9</a>
                            (<code class="literal">self_pipe.c</code>) to use
                            <span class="emphasis"><em>poll()</em></span> instead of
                        <span class="emphasis"><em>select()</em></span>.</p></li><li class="listitem"><p>Write a program that uses <span class="emphasis"><em>epoll_create()</em></span> to create an
                            <span class="emphasis"><em>epoll</em></span> instance and then immediately waits on the
                        returned file descriptor using <span class="emphasis"><em>epoll_wait()</em></span>. When, as
                        in this case, <span class="emphasis"><em>epoll_wait()</em></span> is given an
                            <span class="emphasis"><em>epoll</em></span> file descriptor with an empty interest list,
                        what happens? Why might this be useful?</p></li><li class="listitem"><p>Suppose we have an <span class="emphasis"><em>epoll</em></span> file descriptor that is
                        monitoring multiple file descriptors, all of which are always ready. If we
                        perform a series of <span class="emphasis"><em>epoll_wait()</em></span> calls in which
                            <span class="emphasis"><em>maxevents</em></span> is much smaller than the number of ready
                        file descriptors (e.g., <span class="emphasis"><em>maxevents</em></span> is 1), without
                        performing all possible I/O on the ready descriptors between calls, what
                        descriptor(s) does <span class="emphasis"><em>epoll_wait()</em></span> return in each call?
                        Write a program to determine the answer. (For the purposes of this
                        experiment, it suffices to perform no I/O between the
                            <span class="emphasis"><em>epoll_wait()</em></span> system calls.) Why might this behavior
                        be useful?</p></li><li class="listitem"><p>Modify the program in <a class="xref" href="ch63.html#using_signal-driven_i_solidus_o_on_a_ter" title="Example 63-3. Using signal-driven I/O on a terminal">Example 63-3</a> (<code class="literal">demo_sigio.c</code>) to use a realtime signal instead
                        of <code class="literal">SIGIO</code>. Modify the signal handler to
                        accept a <span class="emphasis"><em>siginfo_t</em></span> argument and display the values of
                        the <span class="emphasis"><em>si_fd</em></span> and <span class="emphasis"><em>si_code</em></span> fields of
                        this structure.</p></li></ol></div></div></section></body></html>
