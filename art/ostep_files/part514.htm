<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Stub Generator</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part513.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part515.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Stub Generator</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The stub generator’s job is simple: to remove some of the pain of packing function arguments and results into messages by automating it. Numer- ous benefits arise: one avoids, by design, the simple mistakes that occur in writing such code by hand; further, a stub compiler can perhaps opti- mize such code and thus improve performance.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The input to such a compiler is simply the set of calls a server wishes to export to clients. Conceptually, it could be something as simple as this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">interface {</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">int func1(int arg1);</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">int func2(int arg1, int arg2);</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The stub generator takes an interface like this and generates a few dif- ferent pieces of code. For the client, a <b>client stub </b>is generated, which contains each of the functions specified in the interface; a client program wishing to use this RPC service would link with this client stub and call into it in order to make RPCs.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Internally, each of these functions in the client stub do all of the work needed to perform the remote procedure call. To the client, the code just</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_663.png"/></span></p><p class="s11" style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;line-height: 8pt;text-align: center;">1<span class="s12">In modern programming languages, we might instead say </span><b>remote method invocation</b></p><p class="s12" style="padding-left: 41pt;text-indent: 0pt;line-height: 8pt;text-align: left;">(<b>RMI</b>), but who likes these languages anyhow, with all of their fancy objects?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: left;">appears as a function call (e.g., the client calls <span class="s41">func1(x)</span>); internally, the code in the client stub for <span class="s41">func1() </span>does this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Create a message buffer. </span><span class="p">A message buffer is usually just a con- tiguous array of bytes of some size.</span></p><p style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><b>Pack the needed information into the message buffer. </b>This infor- mation includes some kind of identifier for the function to be called, as well as all of the arguments that the function needs (e.g., in our example above, one integer for <span class="s41">func1</span>). The process of putting all of this information into a single contiguous buffer is sometimes re- ferred to as the <b>marshaling </b>of arguments or the <b>serialization </b>of the message.</p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Send the message to the destination RPC server. </span><span class="p">The communi- cation with the RPC server, and all of the details required to make it operate correctly, are handled by the RPC run-time library, de- scribed further below.</span></p><p class="s27" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>Wait for the reply. <span class="p">Because function calls are usually </span>synchronous<span class="p">, the call will wait for its completion.</span></p><p class="s27" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>Unpack return code and other arguments. <span class="p">If the function just re- turns a single return code, this process is straightforward; however, more complex functions might return more complex results (e.g., a list), and thus the stub might need to unpack those as well. This step is also known as </span>unmarshaling <span class="p">or </span>deserialization<span class="p">.</span></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Return to the caller. </span><span class="p">Finally, just return from the client stub back into the client code.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">For the server, code is also generated. The steps taken on the server are as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>Unpack the message. <span class="p">This step, called </span>unmarshaling <span class="p">or </span>deserial- ization<span class="p">, takes the information out of the incoming message. The function identifier and arguments are extracted.</span></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Call into the actual function. </span><span class="p">Finally! We have reached the point where the remote function is actually executed. The RPC runtime calls into the function specified by the ID and passes in the desired arguments.</span></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Package the results. </span><span class="p">The return argument(s) are marshaled back into a single reply buffer.</span></p><p class="s4" style="padding-left: 82pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">• <span class="s27">Send the reply. </span><span class="p">The reply is finally sent to the caller.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">There are a few other important issues to consider in a stub compiler. The first is complex arguments, i.e., how does one package and send a complex data structure? For example, when one calls the <span class="s41">write() </span>system call, one passes in three arguments: an integer file descriptor, a pointer to a buffer, and a size indicating how many bytes (starting at the pointer) are to be written. If an RPC package is passed a pointer, it needs to be able to figure out how to interpret that pointer, and perform the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_664.png"/></span></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">correct action. Usually this is accomplished through either well-known types (e.g., a <span class="s41">buffer t </span>that is used to pass chunks of data given a size, which the RPC compiler understands), or by annotating the data struc- tures with more information, enabling the compiler to know which bytes need to be serialized.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Another important issue is the organization of the server with regards to concurrency. A simple server just waits for requests in a simple loop, and handles each request one at a time. However, as you might have guessed, this can be grossly inefficient; if one RPC call blocks (e.g., on I/O), server resources are wasted. Thus, most servers are constructed in some sort of concurrent fashion. A common organization is a <b>thread pool</b>. In this organization, a finite set of threads are created when the server starts; when a message arrives, it is dispatched to one of these worker threads, which then does the work of the RPC call, eventually replying; during this time, a main thread keeps receiving other requests, and per- haps dispatching them to other workers. Such an organization enables concurrent execution within the server, thus increasing its utilization; the standard costs arise as well, mostly in programming complexity, as the RPC calls may now need to use locks and other synchronization primi- tives in order to ensure their correct operation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part513.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part515.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
