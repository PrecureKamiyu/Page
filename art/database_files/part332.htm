<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.4  Insert Operations, Delete Operations, and Predicate Reads</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part331.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part333.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 8pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">18.4  <span style=" color: #00AEEF;">Insert Operations, Delete Operations, and Predicate Reads</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Until now, we have restricted our attention to <span class="s49">read </span>and <span class="s49">write </span>operations. This restric- tion limits transactions to data items already in the database. Some transactions require not only access to existing data items, but also the ability to create new data items. Oth- ers require the ability to delete data items. To examine how such transactions aﬀect concurrency control, we introduce these additional operations:</p><p style="padding-top: 10pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><b>delete</b>(<i>Q</i>) deletes data item <i>Q </i>from the database.</p><p style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><b>insert</b>(<i>Q</i>) inserts a new data item <i>Q </i>into the database and assigns <i>Q </i>an initial value.</p><p style="padding-top: 13pt;padding-left: 119pt;text-indent: 0pt;line-height: 90%;text-align: justify;">An attempt by a transaction <i>T</i><span class="s145">i </span>to perform a <span class="s49">read</span>(<i>Q</i>) operation after <i>Q </i>has been deleted results in a logical error in <i>T</i><span class="s145">i</span>. Likewise, an attempt by a transaction <i>T</i><span class="s145">i </span>to perform a <span class="s49">read</span>(<i>Q</i>) operation before <i>Q </i>has been inserted results in a logical error in <i>T</i><span class="s145">i</span>. It is also a logical error to attempt to delete a nonexistent data item.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">18.4.1 Deletion</p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;line-height: 93%;text-align: justify;">To understand how the presence of <b>delete </b>instructions aﬀects concurrency control, we must decide when a <b>delete </b>instruction conﬂicts with another instruction. Let <i>I</i><span class="s145">i </span>and <i>I</i><span class="s97">j </span>be instructions of <i>T</i><span class="s97">i </span>and <i>T</i><span class="s97">j </span>, respectively, that appear in schedule <i>S </i>in consecutive order. Let <i>I</i><span class="s97">i </span>= <b>delete</b>(<i>Q</i>). We consider several instructions <i>I</i><span class="s97">j </span>.</p><p style="padding-top: 8pt;padding-left: 123pt;text-indent: 0pt;line-height: 16pt;text-align: left;"><span class="s39">• </span><i>I</i><span class="s145">j </span>= <span class="s49">read</span>(<i>Q</i>). <i>I</i><span class="s145">i </span>and <i>I</i><span class="s145">j </span>conﬂict. If <i>I</i><span class="s145">i </span>comes before <i>I</i><span class="s145">j </span>, <i>T</i><span class="s145">j </span>will have a logical error. If</p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>I</i><span class="s145">j </span>comes before <i>I</i><span class="s145">i</span>, <i>T</i><span class="s145">j </span>can execute the <span class="s49">read </span>operation successfully.</p><p style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;line-height: 16pt;text-align: left;"><span class="s39">• </span><i>I</i><span class="s97">j </span>= <span class="s49">write</span>(<i>Q</i>). <i>I</i><span class="s97">i </span>and <i>I</i><span class="s97">j </span>conﬂict. If <i>I</i><span class="s97">i </span>comes before <i>I</i><span class="s97">j </span>, <i>T</i><span class="s97">j </span>will have a logical error. If</p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>I</i><span class="s97">j </span>comes before <i>I</i><span class="s97">i</span>, <i>T</i><span class="s97">j </span>can execute the <span class="s49">write </span>operation successfully.</p><p style="padding-top: 1pt;padding-left: 123pt;text-indent: 0pt;line-height: 16pt;text-align: left;"><span class="s39">• </span><i>I</i><span class="s97">j </span>= <b>delete</b>(<i>Q</i>). <i>I</i><span class="s97">i </span>and <i>I</i><span class="s97">j </span>conﬂict. If <i>I</i><span class="s97">i </span>comes before <i>I</i><span class="s97">j </span>, <i>T</i><span class="s97">j </span>will have a logical error. If</p><p class="s13" style="padding-left: 139pt;text-indent: 0pt;line-height: 14pt;text-align: left;">I<span class="s97">j </span><span class="p">comes before </span>I<span class="s97">i</span><span class="p">, </span>T<span class="s97">i </span><span class="p">will have a logical error.</span></p><p style="padding-top: 2pt;padding-left: 139pt;text-indent: -16pt;line-height: 90%;text-align: left;"><span class="s39">• </span><i>I</i><span class="s145">j </span>= <b>insert</b>(<i>Q</i>). <i>I</i><span class="s145">i </span>and <i>I</i><span class="s145">j </span>conﬂict. Suppose that data item <i>Q </i>did not exist prior to the execution of <i>I</i><span class="s145">i </span>and <i>I</i><span class="s145">j </span>. Then, if <i>I</i><span class="s145">i </span>comes before <i>I</i><span class="s145">j </span>, a logical error results for <i>T</i><span class="s145">i</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 107pt;text-indent: 0pt;line-height: 88%;text-align: justify;">If <i>I</i><span class="s145">j </span>comes before <i>I</i><span class="s145">i</span>, then no logical error results. Likewise, if <i>Q </i>existed prior to the execution of <i>I</i><span class="s97">i </span>and <i>I</i><span class="s97">j </span>, then a logical error results if <i>I</i><span class="s97">j </span>comes before <i>I</i><span class="s97">i</span>, but not otherwise.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">We can conclude the following:</p><p class="s39" style="padding-top: 10pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Under the two-phase locking protocol, an exclusive lock is required on a data item before that item can be deleted.</span></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">Under the timestamp-ordering protocol, a test similar to that for a </span><span class="s49">write </span>must be performed. Suppose that transaction <i>T</i><span class="s145">i </span>issues <b>delete</b>(<i>Q</i>).</p><p style="padding-top: 6pt;padding-left: 122pt;text-indent: -8pt;line-height: 65%;text-align: justify;"><span class="s50">° </span><span class="s51">If TS(</span><i>T</i><span class="s97">i</span>) <span class="s83">&lt; </span>R-timestamp(<i>Q</i>), then the value of <i>Q </i>that <i>T</i><span class="s97">i </span>was to delete has al- ready been read by a transaction <i>T</i><span class="s97">j </span>with TS(<i>T</i><span class="s97">j </span>) <span class="s83">&gt; </span>TS(<i>T</i><span class="s97">i</span>). Hence, the <b>delete </b>operation is rejected, and <i>T</i><span class="s97">i </span>is rolled back.</p><p style="padding-top: 5pt;padding-left: 122pt;text-indent: -8pt;line-height: 70%;text-align: justify;"><span class="s50">° </span><span class="s51">If TS(</span><i>T</i><span class="s97">i</span>) <span class="s83">&lt; </span>W-timestamp(<i>Q</i>), then a transaction <i>T</i><span class="s97">j </span>with TS(<i>T</i><span class="s97">j </span>) <span class="s83">&gt; </span>TS(<i>T</i><span class="s97">i</span>) has written <i>Q</i>. Hence, this <b>delete </b>operation is rejected, and <i>T</i><span class="s97">i </span>is rolled back.</p><p class="s50" style="padding-top: 4pt;padding-left: 113pt;text-indent: 0pt;text-align: justify;">° <span class="s51">Otherwise, the </span><span class="s46">delete </span><span class="p">is executed.</span></p><p class="s68" style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">18.4.2 Insertion</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We have already seen that an <b>insert</b>(<i>Q</i>) operation conﬂicts with a <b>delete</b>(<i>Q</i>) operation. Similarly, <b>insert</b>(<i>Q</i>) conﬂicts with a <span class="s49">read</span>(<i>Q</i>) operation or a <span class="s49">write</span>(<i>Q</i>) operation; no <span class="s49">read </span>or <span class="s49">write </span>can be performed on a data item before it exists.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">Since an <b>insert</b>(<i>Q</i>) assigns a value to data item <i>Q</i>, an <b>insert </b>is treated similarly to a</p><p class="s49" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">write <span class="p">for concurrency-control purposes:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 107pt;text-indent: -16pt;line-height: 87%;text-align: justify;"><span class="s39">• </span><span class="s40">Under the two-phase locking protocol, if </span><i>T</i><span class="s97">i </span>performs an <b>insert</b>(<i>Q</i>) operation, <i>T</i><span class="s97">i </span>is given an exclusive lock on the newly created data item <i>Q</i>.</p><p style="padding-top: 5pt;padding-left: 107pt;text-indent: -16pt;line-height: 90%;text-align: justify;"><span class="s39">• </span><span class="s40">Under the timestamp-ordering protocol, if </span><i>T</i><span class="s145">i </span>performs an <b>insert</b>(<i>Q</i>) operation, the values R-timestamp(<i>Q</i>) and W-timestamp(<i>Q</i>) are set to TS(<i>T</i><span class="s97">i</span>).</p><p class="s68" style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">18.4.3 Predicate Reads and The Phantom Phenomenon</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Consider transaction <i>T</i><span class="s98">30</span> that executes the following <span class="s44">SQL </span>query on the university database:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 213pt;text-indent: 0pt;text-align: left;">select count<span class="p">(*) </span>from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3013.png"/></span></p><p class="s46" style="padding-left: 213pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="p">= &#39;Physics&#39; ;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">Transaction <i>T</i><span class="s98">30</span> requires access to all tuples of the <i>instructor </i>relation pertaining to the Physics department.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 137pt;text-indent: 0pt;text-align: left;">Let <i>T</i><span class="s98">31</span> be a transaction that executes the following <span class="s44">SQL </span>insertion:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">insert into <i>instructor</i></p><p class="s46" style="padding-left: 153pt;text-indent: 0pt;text-align: center;">values <span class="p">(11111, &#39;Feynman&#39;, &#39;Physics&#39;, 94000);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;line-height: 87%;text-align: justify;"><span class="p">Let </span>S <span class="p">be a schedule involving </span>T<span class="s130">30 </span><span class="s94">and </span>T<span class="s130">31</span><span class="s94">. We expect there to be potential for a conﬂict for the following reasons:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 139pt;text-indent: -16pt;line-height: 90%;text-align: justify;"><span class="s39">• </span><span class="s40">If </span>T<span class="s93">30 </span><span class="s94">uses the tuple newly inserted by </span>T<span class="s93">31 </span><span class="s94">in computing </span><b>count</b><span class="p">(*), then </span>T<span class="s93">30 </span><span class="s94">reads a value written by </span>T<span class="s93">31</span><span class="s94">. Thus, in a serial schedule equivalent to </span>S<span class="p">, </span>T<span class="s93">31 </span><span class="s94">must come before </span>T<span class="s98">30</span><span class="p">.</span></p><p class="s13" style="padding-top: 5pt;padding-left: 139pt;text-indent: -16pt;line-height: 87%;text-align: justify;"><span class="s39">• </span><span class="s40">If </span>T<span class="s130">30 </span><span class="s94">does not use the tuple newly inserted by </span>T<span class="s130">31 </span><span class="s94">in computing </span><b>count</b><span class="p">(*), then in a serial schedule equivalent to </span>S<span class="p">, </span>T<span class="s93">30 </span><span class="s94">must come before </span>T<span class="s93">31</span><span class="s94">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="p">The second of these two cases is curious. </span>T<span class="s93">30 </span><span class="s94">and </span>T<span class="s93">31 </span><span class="s94">do not access any tuple in com- mon, yet they conﬂict with each other! In eﬀect, </span>T<span class="s130">30 </span><span class="s94">and </span>T<span class="s130">31 </span><span class="s94">conﬂict on a phantom tuple. If concurrency control is performed at the tuple granularity, this conﬂict would go undetected. As a result, the system could fail to prevent a nonserializable schedule. This problem is an instance of the </span><span class="s63">phantom phenomenon</span><span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3014.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Phantom phenomena can occur not just with inserts, but also with updates. Con- sider the situation we saw in Section 17.10, where a transaction <i>T</i><span class="s145">i </span>used an index to ﬁnd only tuples with <i>dept name </i>= “Physics”, and as a result did not read any tuples with other department names. If another transaction <i>T</i><span class="s97">j </span>updates one of these tuples, changing its department name to Physics, a problem similar to the above problem oc-</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">curs: even though <i>T</i><span class="s97">i </span>and <i>T</i><span class="s97">j </span>have not accessed any tuples in common, they do conﬂict with each other. This problem too is an instance of the phantom phenomenon. In gen- eral, the phantom phenomenon is rooted in predicate reads that conﬂict with inserts or updates that result in new/updated tuples that satisfy the predicate.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3015.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We can prevent these problems by allowing transaction <i>T</i><span class="s98">30</span> to prevent other trans- actions from creating new tuples in the <i>instructor </i>relation with <i>dept name </i>= “Physics”, and from updating the department name of an existing <i>instructor </i>tuple to Physics.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3016.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To ﬁnd all <i>instructor </i>tuples with <i>dept name </i>= “Physics”, <i>T</i><span class="s98">30</span> must search either the whole <i>instructor </i>relation, or at least an index on the relation. Up to now, we have as- sumed implicitly that the only data items accessed by a transaction are tuples. However, <i>T</i><span class="s98">30</span> is an example of a transaction that reads information about what tuples are in a relation, and <i>T</i><span class="s98">31</span> is an example of a transaction that updates that information.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Clearly, it is not suﬃcient merely to lock the tuples that are accessed; the informa- tion used to ﬁnd the tuples that are accessed by the transaction must also be locked.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Locking of information used to ﬁnd tuples can be implemented by associating a data item with the relation; the data item represents the information used to ﬁnd the tuples in the relation. Transactions, such as <i>T</i><span class="s98">30</span>, that read the information about what tuples are in a relation would then have to lock the data item corresponding to the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="p">relation in shared mode. Transactions, such as </span>T<span class="s98">31</span><span class="p">, that update the information about what tuples are in a relation would have to lock the data item in exclusive mode. Thus, </span>T<span class="s130">30 </span><span class="s94">and </span>T<span class="s130">31 </span><span class="s94">would conﬂict on a real data item, rather than on a phantom. Similarly,</span></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">transactions that use an index to retrieve tuples must lock the index itself.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Do not confuse the locking of an entire relation, as in multiple-granularity locking, with the locking of the data item corresponding to the relation. By locking the data item, a transaction only prevents other transactions from updating information about what tuples are in the relation. Locking is still required on tuples. A transaction that directly accesses a tuple can be granted a lock on the tuples even when another transaction has an exclusive lock on the data item corresponding to the relation itself.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The major disadvantage of locking a data item corresponding to the relation, or locking an entire index, is the low degree of concurrency— two transactions that insert diﬀerent tuples into a relation are prevented from executing concurrently.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A better solution is an <span class="s63">index-locking </span>technique that avoids locking the whole index. Any transaction that inserts a tuple into a relation must insert information into every index maintained on the relation. We eliminate the phantom phenomenon by imposing a locking protocol for indices. For simplicity we shall consider only B<span class="s181">+</span>-tree indices.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3017.png"/></span></p><p class="s13" style="padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="p">As we saw in Chapter 14, every search-key value is associated with an index leaf node. A query will usually use one or more indices to access a relation. An insert must insert the new tuple in all indices on the relation. In our example, we assume that there is an index on </span>instructor <span class="p">for attribute </span>dept name<span class="p">. Then, </span>T<span class="s98">31</span><span class="p"> must modify the leaf containing the key “Physics”. If </span>T<span class="s98">30</span><span class="p"> reads the same leaf node to locate all tuples pertaining to the Physics department, then </span>T<span class="s130">30 </span><span class="s94">and </span>T<span class="s130">31 </span><span class="s94">conﬂict on that leaf node.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">The <span class="s63">index-locking protocol </span>takes advantage of the availability of indices on a rela-</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">tion, by turning instances of the phantom phenomenon into conﬂicts on locks on index leaf nodes. The protocol operates as follows:</p><p class="s39" style="padding-top: 8pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">Every relation must have at least one index.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;line-height: 87%;text-align: justify;">• <span class="s40">A transaction </span><span class="s13">T</span><span class="s97">i </span><span class="p">can access tuples of a relation only after ﬁrst ﬁnding them through one or more of the indices on the relation. For the purpose of the index-locking</span></p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">protocol, a relation scan is treated as a scan through all the leaves of one of the indices.</p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;line-height: 87%;text-align: justify;">• <span class="s40">A transaction </span><span class="s13">T</span><span class="s97">i </span><span class="p">that performs a lookup (whether a range lookup or a point lookup) must acquire a shared lock on all the index leaf nodes that it accesses.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">A transaction </span>T<span class="s145">i </span><span class="p">may not insert, delete, or update a tuple </span>t<span class="s145">i </span><span class="p">in a relation </span>r <span class="p">without updating all indices on </span>r<span class="p">. The transaction must obtain exclusive locks on all index leaf nodes that are aﬀected by the insertion, deletion, or update. For insertion and deletion, the leaf nodes aﬀected are those that contain (after insertion) or contained (before deletion) the search-key value of the tuple. For updates, the leaf</span></p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">nodes aﬀected are those that (before the modiﬁcation) contained the old value of the search key, and nodes that (after the modiﬁcation) contain the new value of the search key.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><a name="bookmark385">• </a><span class="s40">Locks are obtained on tuples as usual.</span><a name="bookmark426">&zwnj;</a></p><p class="s39" style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: left;">• <span class="s40">The rules of the two-phase locking protocol must be observed.</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that the index-locking protocol does not address concurrency control on inter- nal nodes of an index; techniques for concurrency control on indices, which minimize lock conﬂicts, are presented in Section 18.10.2.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Locking an index leaf node prevents any update to the node, even if the update did not actually conﬂict with the predicate. A variant called key-value locking, which minimizes such false lock conﬂicts, is presented in Section 18.10.2 as part of index concurrency control.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As noted in Section 17.10, it would appear that the existence of a conﬂict between transactions depends on a low-level query-processing decision by the system that is unrelated to a user-level view of the meaning of the two transactions. An alternative approach to concurrency control acquires shared locks on predicates in a query, such</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 70%;text-align: justify;">as the predicate “<i>salary </i><span class="s83">&gt; </span>90000” on the <i>instructor </i>relation. Inserts and deletes of the relation must then be checked to see if they satisfy the predicate; if they do, there is a</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">lock conﬂict, forcing the insert or delete to wait till the predicate lock is released. For updates, both the initial value and the ﬁnal value of the tuple must be checked against the predicate. Such conﬂicting inserts, deletes, and updates aﬀect the set of tuples se- lected by the predicate, and they cannot be allowed to execute concurrently with the query that acquired the (shared) predicate lock. We call this protocol <span class="s63">predicate lock- ing</span>;<span class="s76">1</span> predicate locking is not used in practice since it is more expensive to implement than the index-locking protocol and does not give signiﬁcant additional beneﬁts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part331.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part333.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
