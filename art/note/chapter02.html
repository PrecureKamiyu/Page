<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-06-20 Tue 17:24 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style>body {font-family: serif, 宋体;font-size: 200%;} a {color: black; text-decoration: none;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6b2d92b">1. chapter 2</a>
<ul>
<li><a href="#org2cb87ea">1.1. ISA 是什么?</a>
<ul>
<li><a href="#org136912b">1.1.1. 原则</a></li>
<li><a href="#org09c756d">1.1.2. <span class="todo TODO">TODO</span> 汇编语言的优缺点</a></li>
</ul>
</li>
<li><a href="#orgec1161f">1.2. risc-v ISA</a>
<ul>
<li><a href="#org53ed015">1.2.1. 指令格式</a></li>
<li><a href="#org1db4147">1.2.2. 寄存器</a></li>
<li><a href="#orgd1d9d0a">1.2.3. 内存</a></li>
</ul>
</li>
<li><a href="#org42907b4">1.3. Instructions introduction</a>
<ul>
<li><a href="#org3517b1c">1.3.1. imm</a></li>
<li><a href="#org43342d8">1.3.2. <span class="todo TODO">TODO</span> mul &amp; mul</a></li>
<li><a href="#org5d3e4ce">1.3.3. <span class="todo TODO">TODO</span> div</a></li>
<li><a href="#orgf23873d">1.3.4. or and and</a></li>
<li><a href="#orgfe560ef">1.3.5. shift</a></li>
<li><a href="#orgb1c6b43">1.3.6. save load</a></li>
<li><a href="#orgbbaa899">1.3.7. sign extension</a></li>
<li><a href="#org9d8586d">1.3.8. <span class="todo TODO">TODO</span> 涉及掩码的数据传输</a></li>
<li><a href="#org0ea197f">1.3.9. add</a></li>
<li><a href="#org8da54ad">1.3.10. sub</a></li>
<li><a href="#org3d50864">1.3.11. div rem</a></li>
<li><a href="#org4b52847">1.3.12. xor</a></li>
<li><a href="#orgb565b68">1.3.13. shift</a></li>
<li><a href="#orge96712e">1.3.14. shamt</a></li>
<li><a href="#org52a1ccb">1.3.15. shift left arithmetic</a></li>
<li><a href="#org26dcefa">1.3.16. save / load</a></li>
<li><a href="#orgab01b25">1.3.17. slt</a></li>
<li><a href="#org46eec04">1.3.18. bne beq blt bltu</a></li>
<li><a href="#org97a3e38">1.3.19. jalr jal</a></li>
<li><a href="#org7c926f1">1.3.20. pseudo instruction</a></li>
</ul>
</li>
<li><a href="#orgd963c7b">1.4. How to write a function using assembly</a>
<ul>
<li><a href="#orgc1f1d88">1.4.1. How to write a loop</a></li>
<li><a href="#orgf535685">1.4.2. the concept of basic</a></li>
<li><a href="#org7ea47fd">1.4.3. Function and stack</a></li>
</ul>
</li>
<li><a href="#orgbf2fc06">1.5. The expression of an instruction</a>
<ul>
<li><a href="#org8a3cf34">1.5.1. the field of an instruction code</a></li>
<li><a href="#org338b144">1.5.2. the type of the instruction code</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org6b2d92b" class="outline-2">
<h2 id="org6b2d92b"><span class="section-number-2">1</span> chapter 2</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org2cb87ea" class="outline-3">
<h3 id="org2cb87ea"><span class="section-number-3">1.1</span> ISA 是什么?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
risc-v 是一种指令集架构: ISA (instruction set architecture). 也称为处理器架构
</p>

<p>
使用同一个指令集架构的计算机就是这种 ISA 的系列机, 比如说 risc-v 系列机, Arm 系列机.  
</p>

<p>
一个 ISA 有很多参数, 最基本的参数就是通用寄存器的位宽, 一般有32bit和64 bit之分. 位宽, 指定了通用寄存器的宽度. 其决定了决定了寻址范围的大小, 数据运算能力的强弱. 地址长度为寄存器的长度, 64 bit 的地址范围当然是比 32 bit 的要长的多. 
</p>

<p>
其需要和指令编码长度分开, 指令的编码长度是越小越好的. 因为这样效率更高.
</p>
</div>

<div id="outline-container-org136912b" class="outline-4">
<h4 id="org136912b"><span class="section-number-4">1.1.1</span> 原则</h4>
<div class="outline-text-4" id="text-1-1-1">
<ol class="org-ol">
<li>简单性来自于规则性</li>
<li>越小越快</li>
<li>加速经常性时间.  经常使用的指令尽量短.</li>
<li>需要良好的折衷.</li>
</ol>
</div>
</div>


<div id="outline-container-org09c756d" class="outline-4">
<h4 id="org09c756d"><span class="section-number-4">1.1.2</span> <span class="todo TODO">TODO</span> 汇编语言的优缺点</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
废话吧这是
</p>
</div>
</div>
</div>

<div id="outline-container-orgec1161f" class="outline-3">
<h3 id="orgec1161f"><span class="section-number-3">1.2</span> risc-v ISA</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org53ed015" class="outline-4">
<h4 id="org53ed015"><span class="section-number-4">1.2.1</span> 指令格式</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
For example, 汇编指令的格式为 
</p>

<pre class="example">
op dst src1 src2
</pre>

<p>
这是最一般的指令格式, 其中有 dst(destination), 两个来源 src. 一个指令
对应一个操作. 一行最多一条指令. C语言之中的操作会被分解为一条或者是多
条指令. 来源可以是 imm 也可以是寄存器的值. 
</p>

<p>
And for example, we have 
</p>
<pre class="example">
add x1 x2 x3
</pre>
<p>
that is to say we add the values of <code>x2</code> and <code>x3</code>, and the sum goes to <code>x1</code>
</p>
</div>
</div>

<div id="outline-container-org1db4147" class="outline-4">
<h4 id="org1db4147"><span class="section-number-4">1.2.2</span> 寄存器</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
32个通用寄存器, <code>x0--x31</code>. 注意这里仅仅涉及 RV32I 或者是 RV64I 的寄存器, 这两个是 risc-v 指令的子集, 其他子集会用到其他的寄存器. 这算 dark side. For float point manipulation, we employ some processor that does the job, that is there is chip that is for float point manipulation, and there are corresponding register and instructions.
</p>

<p>
算术逻辑运算所操作的数据必须直接来自于寄存器<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>. 涉及内存的操作只有 load 指令和 save 指令. 其中 <code>x0</code> 是一个特殊的寄存器, 其值恒为 0. RV32I 指令集通用寄存器的长度为 32 位, 而RV64I指令集对应的长度是 64 位
</p>

<p>
汇编是相对原始的<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>, 汇编语言之中没有变量的概念. 直接使用寄存器操作. 直接
使用寄存器能够最大化速度. 缺点在于寄存器的数量非常有限, 需要好好规划. 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">寄存器</th>
<th scope="col" class="org-left">符号</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>x0</code></td>
<td class="org-left">zero</td>
<td class="org-left">值为0</td>
</tr>

<tr>
<td class="org-left"><code>x1</code></td>
<td class="org-left">ra</td>
<td class="org-left">return address</td>
</tr>

<tr>
<td class="org-left"><code>x2</code></td>
<td class="org-left">sp</td>
<td class="org-left">stack pointer</td>
</tr>

<tr>
<td class="org-left"><code>x3</code></td>
<td class="org-left">gp</td>
<td class="org-left">global pointer</td>
</tr>

<tr>
<td class="org-left"><code>x4</code></td>
<td class="org-left">tp</td>
<td class="org-left">thread pointer</td>
</tr>

<tr>
<td class="org-left"><code>x5-x7</code></td>
<td class="org-left">t0-t2</td>
<td class="org-left">temporary register</td>
</tr>

<tr>
<td class="org-left"><code>x8</code></td>
<td class="org-left">s0/fp</td>
<td class="org-left">save register/frame pointer</td>
</tr>

<tr>
<td class="org-left"><code>x9</code></td>
<td class="org-left">s1</td>
<td class="org-left">save register</td>
</tr>

<tr>
<td class="org-left"><code>x10-x11</code></td>
<td class="org-left">a0-a1</td>
<td class="org-left">return value</td>
</tr>

<tr>
<td class="org-left"><code>x12-x17</code></td>
<td class="org-left">a2-a7</td>
<td class="org-left">function argument</td>
</tr>

<tr>
<td class="org-left"><code>x18-x27</code></td>
<td class="org-left">s2-s11</td>
<td class="org-left">save register</td>
</tr>

<tr>
<td class="org-left"><code>x28-x31</code></td>
<td class="org-left">t3-t6</td>
<td class="org-left">temporary register</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd1d9d0a" class="outline-4">
<h4 id="orgd1d9d0a"><span class="section-number-4">1.2.3</span> 内存</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
Save Load instructions 实现寄存器和内存之间的读写. 这里我们再次细明一下存储单元和地址. 
</p>


<p>
一个地址单元是一个 byte, 一个 byte 是 8 个 bit. 我们常常用十六进制表示,那么一个 Byte 可以使用两个字符表示. 比如说 0xFF. 一个 word 表示的是 32 个 bit, 也就是 4 个 Byte. 也有 double word (简写为 dword) 表示的是两个 word, 也就是 8 个 Byte. 还有 half word, 表示的是半个 word, 那就是 2 个 bytes. 这些单位常常以后缀的方式出现在 save load 指令之中. 
</p>

<p>
For example, <code>sw</code> means to save a word; <code>sh</code> means to save a half.
</p>
</div>
</div>
</div>

<div id="outline-container-org42907b4" class="outline-3">
<h3 id="org42907b4"><span class="section-number-3">1.3</span> Instructions introduction</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org3517b1c" class="outline-4">
<h4 id="org3517b1c"><span class="section-number-4">1.3.1</span> imm</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
操作名后面加上了一个 <code>i</code>, 那么这个操作是立即数操作. 其将第二个操作数当作是立即数. 需要知道的是, 立即数会进行一个符号扩展, 扩展为一个补码表示的 number.
</p>

<p>
e.g. <code>addi x1, x1, 5</code>
</p>

<p>
随后, 更值得注意的是, 存在 <code>addi</code>, 但是不存在 <code>subi</code>. this is because that we use <code>addi</code> to express <code>subi</code> 
</p>
</div>
</div>

<div id="outline-container-org43342d8" class="outline-4">
<h4 id="org43342d8"><span class="section-number-4">1.3.2</span> <span class="todo TODO">TODO</span> mul &amp; mul</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
mulh 取高位指令. 详情请看 ppt 
</p>
</div>
</div>

<div id="outline-container-org5d3e4ce" class="outline-4">
<h4 id="org5d3e4ce"><span class="section-number-4">1.3.3</span> <span class="todo TODO">TODO</span> div</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
详情请看 ppt. 
</p>
</div>
</div>

<div id="outline-container-orgf23873d" class="outline-4">
<h4 id="orgf23873d"><span class="section-number-4">1.3.4</span> or and and</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
值得注意的是, risc-v 之中并没有取非操作. 但是我们可以使用前面的知识, 进行代替, oh really?
</p>
</div>
</div>

<div id="outline-container-orgfe560ef" class="outline-4">
<h4 id="orgfe560ef"><span class="section-number-4">1.3.5</span> shift</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
值得注意的是, 没有算术左移对应的指令. this is because 在一定范围内, 也就是算术左移没有发生错误的时候, 算术左移和逻辑左移是等价的. 这一点看以前的记录. 
</p>

<p>
我们复习一下, 什么时候算术位移会发生错误. 我们有这样一个判断标准: 对于左移, 如果左移之后再右移, 不能回到原本的数字的话, 那么这个左移就出错了. 于是说, 对于左移, 正数丢弃了 1, 或者是负数丢弃了 0, 就会出错.
</p>
</div>
</div>

<div id="outline-container-orgb1c6b43" class="outline-4">
<h4 id="orgb1c6b43"><span class="section-number-4">1.3.6</span> save load</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
我们可以将寄存器之中东西塞到内存之中. 我们通过内存地址进行内存的访问. 
</p>

<p>
需要注意的是, 其他指令的操作数均是寄存器之中的数, 仅有 save load 指令能够对内存进行 access. 格式如下: 
</p>
<pre class="example">
memop reg offset(bAddrReg)
</pre>
<p>
<code>memop</code> 指的是内存相关的操作, <code>reg</code> 指的是目标寄存器, 第二个操作数是 
<code>offset(bAddrReg)</code>, 一其中 <code>offset</code> 是一个 imm 偏移量; <code>bAddrReg</code> 是寄存器 which holds some address, 将寄存器里的值当作是地址. 整体的地址便是 <code>offset + bAddrReg</code>.
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> 为命令指定大小</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>sw</code></td>
<td class="org-left">取word</td>
</tr>

<tr>
<td class="org-left"><code>sd</code></td>
<td class="org-left">取double word</td>
</tr>

<tr>
<td class="org-left"><code>sh</code></td>
<td class="org-left">取half word</td>
</tr>

<tr>
<td class="org-left"><code>sb</code></td>
<td class="org-left">取byte</td>
</tr>
</tbody>
</table>

<p>
For load instruction <code>lw ld lh lb</code>, they are the same.
</p>
</div>
</div>
<div id="outline-container-orgbbaa899" class="outline-4">
<h4 id="orgbbaa899"><span class="section-number-4">1.3.7</span> sign extension</h4>
<div class="outline-text-4" id="text-1-3-7">
<p>
我们进行 <code>load</code> 命令的时候, 要指定大小. 我们要将一个长度为 32/64/16/8 的数据, 送到 32 或者是 64 位的寄存器里面. 这个时候, 计算机会对传输的数据进行 <b>符号扩展</b>. 将这一小串数据, 看作是补码, 扩展为 32 或者64位的补码. 
</p>

<p>
比如说一个传入了一个字节 <code>0x80</code>, 写为二进制为 <code>10000000</code>. 也就是有符号位 1, 是一个负数, 于是扩展为 32 位的补码的时候就变为 <code>0xFF80</code>. The procedure here is simple, if the highest bit is 1, then we fill in the 1's. If the highest bit is 0, then we fill in the 0's.
</p>

<p>
默认读写数据的时候, 会将数据扩展, 看作是有符号的 若是需要写入无符号数的话, 需要加上 <code>u</code>. 
</p>

<p>
e.g. 传输数据的举例. 见 ppt 实际上不是很难. 
</p>
</div>
</div>

<div id="outline-container-org9d8586d" class="outline-4">
<h4 id="org9d8586d"><span class="section-number-4">1.3.8</span> <span class="todo TODO">TODO</span> 涉及掩码的数据传输</h4>
<div class="outline-text-4" id="text-1-3-8">
<p>
holy shit this part is empty.
</p>

<p>
Logical operations can do thing likes 掩码. To achieve this we can use <code>and</code> and <code>0xFFFFFFFF</code>. Let us assume that the length of register is 32. A number <code>and 0xFFFFFFFF</code> is the number itself. But when <code>and 0x0FFFFFFF</code> , the number loose it first four bits.
</p>
</div>
</div>

<div id="outline-container-org0ea197f" class="outline-4">
<h4 id="org0ea197f"><span class="section-number-4">1.3.9</span> add</h4>
<div class="outline-text-4" id="text-1-3-9">
<p>
add 指令的表示为 
</p>
<pre class="example">
add rd, rst1, rst2
</pre>

<p>
<code>rd</code> is register of destination. The command tell computer to do the computation---<code>rd = rst1 + rst2</code>. Note that rst1 rst2 are treated as signed numbers. Additionally, <code>addi</code> tells computer to do <code>rd = rst1 + imm</code>, where <code>rst2</code> is replaced by an immediate number.
</p>
</div>
</div>

<div id="outline-container-org8da54ad" class="outline-4">
<h4 id="org8da54ad"><span class="section-number-4">1.3.10</span> sub</h4>
<div class="outline-text-4" id="text-1-3-10">
<pre class="example">
sub, rd, rst1, rst2
</pre>
<p>
is the form of the instruction, telling that <code>rd = rst1 - rst2</code>.
</p>

<p>
It is worth noting that there is no such thing as <code>subi</code>, cause <code>addi</code> can do the same thing.
</p>
</div>
</div>

<div id="outline-container-org3d50864" class="outline-4">
<h4 id="org3d50864"><span class="section-number-4">1.3.11</span> div rem</h4>
<div class="outline-text-4" id="text-1-3-11">
<p>
What the fuck this place is empty.
</p>

<p>
Forget about it my friend. 
</p>

<p>
I don't have time for this.
</p>
</div>
</div>

<div id="outline-container-org4b52847" class="outline-4">
<h4 id="org4b52847"><span class="section-number-4">1.3.12</span> xor</h4>
<div class="outline-text-4" id="text-1-3-12">
<p>
Fuck it!
</p>
</div>
</div>

<div id="outline-container-orgb565b68" class="outline-4">
<h4 id="orgb565b68"><span class="section-number-4">1.3.13</span> shift</h4>
<div class="outline-text-4" id="text-1-3-13">
<pre class="example">
op = s + l/r + a/l + [i]
</pre>
<p>
is the decompostion of an instruction,
where <code>s</code> is for shift, <code>l/r</code> is for left or right, <code>a/l</code> is for arithmetic or logical, <code>[]</code> means that <code>i</code> is optional, <code>i</code> is for imm.
</p>

<p>
About the arithmetic shift, you check 01.pdf out.
</p>
</div>
</div>

<div id="outline-container-orge96712e" class="outline-4">
<h4 id="orge96712e"><span class="section-number-4">1.3.14</span> shamt</h4>
<div class="outline-text-4" id="text-1-3-14">
<p>
Indeed, for a 64-bits data store in a register. It would be of no use to shift of 64-bits, which resulting that in <code>slai</code> or other shifting command ending with <code>i</code>, only the lowest 6-bits of immediate number are useful. Other bits are abandoned. The remaining part is called <code>shamt</code>.
</p>
</div>
</div>

<div id="outline-container-org52a1ccb" class="outline-4">
<h4 id="org52a1ccb"><span class="section-number-4">1.3.15</span> shift left arithmetic</h4>
<div class="outline-text-4" id="text-1-3-15">
<p>
There is not such thing as <code>sla[i]</code>. We already know when the shift cause ailment. Exactly when the number is starting with \texttt{10} or \texttt{01} the result of <code>sla</code> is not what we want. 
</p>

<p>
However, you may check that when there is no ailment, \texttt{sla} works just like \texttt{sll}. So \texttt{sla} become less needed. 
</p>
</div>
</div>

<div id="outline-container-org26dcefa" class="outline-4">
<h4 id="org26dcefa"><span class="section-number-4">1.3.16</span> save / load</h4>
<div class="outline-text-4" id="text-1-3-16">
<pre class="example">
s/l r offset(bAddrReg)
</pre>
<p>
where bAddrReg is a register. The command tells computer to load data from address offset + AddR to r, or to save the data in <code>r</code> to address <code>offset + AddR</code>.
</p>

<p>
<b>Address and Word and Byte</b> \subsubsectio
A word in risc-v has 32 bits. There arouses an interesting question: how to load 32-bit data to a 64-bit register? 
</p>

<p>
No, what I am saying is that you need to care for whether the data is unsigned type or not. You need to expand a number when it is treated as a negative number. 
</p>
</div>
</div>

<div id="outline-container-orgab01b25" class="outline-4">
<h4 id="orgab01b25"><span class="section-number-4">1.3.17</span> slt</h4>
<div class="outline-text-4" id="text-1-3-17">
<p>
<code>slt</code> for set less than. <code>slt</code> is an instruction to compare the value of some data. 
</p>

<pre class="example">
slt rd, rst1, rst2
</pre>
<p>
means that <code>rd = whether rst1 &lt; rst2</code>
</p>
</div>
</div>

<div id="outline-container-org46eec04" class="outline-4">
<h4 id="org46eec04"><span class="section-number-4">1.3.18</span> bne beq blt bltu</h4>
<div class="outline-text-4" id="text-1-3-18">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">b</td>
<td class="org-left">break</td>
</tr>

<tr>
<td class="org-left">eq</td>
<td class="org-left">equal</td>
</tr>

<tr>
<td class="org-left">ne</td>
<td class="org-left">not equal</td>
</tr>

<tr>
<td class="org-left">lt</td>
<td class="org-left">less than</td>
</tr>

<tr>
<td class="org-left">ge</td>
<td class="org-left">greater or equal</td>
</tr>
</tbody>
</table>


<p>
Use this set of command to jump which is used to achieve if-else structure. Note that for <code>blt, bge</code>, there exists unsigned type of commands.  You just add <code>u</code>.
</p>
</div>
</div>

<div id="outline-container-org97a3e38" class="outline-4">
<h4 id="org97a3e38"><span class="section-number-4">1.3.19</span> jalr jal</h4>
<div class="outline-text-4" id="text-1-3-19">
<pre class="example">
jal rd offset
</pre>
<p>
称为无条件跳转. PC+4 存贮在 rd 之中. 并且 PC 赋值为 Label.
</p>

<p>
<code>Label</code> 是一个写在程序行首的标签, 比如说 <code>Exit</code> 或者 <code>Loop</code> 等. 程序运行的时候此标签会翻译为一个指令的地址. Remember to add a colon to the label.
</p>

<p>
The actual operation it takes is <code>PC = PC + \texttt{offSet}</code>, where <code>offSet</code> is translated from <code>Label</code>.
</p>

<pre class="example">
jalr rd offset(AddrReg)
</pre>
<p>
是 <code>jalr</code> 的格式. 其表示, rd = PC + 4. 将 PC 的值赋为 offset + AddrReg.
</p>
</div>
</div>

<div id="outline-container-org7c926f1" class="outline-4">
<h4 id="org7c926f1"><span class="section-number-4">1.3.20</span> pseudo instruction</h4>
<div class="outline-text-4" id="text-1-3-20">
<p>
伪指令有简单理解的, 比如说 <code>mv, sw, lw</code> (sw, lw 不是伪指令, 但其能作为伪指令). 
</p>

<p>
也有比较难搞的, 比如说 <code>la li</code> 伪指令. 意思是将 Label 所在的指令的地址传输到 rd 上. 其中 Label 表示的是当前 PC 的值和目标指令的差值, 记为 delta, 长度为 32 位. 
</p>
</div>
</div>
</div>

<div id="outline-container-orgd963c7b" class="outline-3">
<h3 id="orgd963c7b"><span class="section-number-3">1.4</span> How to write a function using assembly</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orgc1f1d88" class="outline-4">
<h4 id="orgc1f1d88"><span class="section-number-4">1.4.1</span> How to write a loop</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
我们需要分支跳转的指令来实现这点, 比如说, 我们要实现一个简单的语句: 
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #859900;">for</span> (<span style="color: #268bd2;">int</span> <span style="color: #6c71c4;">i</span> = 0 ; i &lt; 2 ; i++) {
    ans = ans + i;
}                 
</pre>
</div>

<p>
分析一下就是
</p>
<ol class="org-ol">
<li>写下一个 Label</li>
<li>ans = ans + i;</li>
<li>i++</li>
<li>分支跳转的判断</li>
</ol>

<pre class="example">
    add t0, x0, x0
    add t1, x0, x0
    li  t2, 2
Loop:
    add t1, t1, t0
    addi t0, t0, 1
    bne t0, t2, Loop
</pre>

<p>
大概这样, t0 是 i; t1 是 ans; t2 是 2. 当然啦, bne 换为 bge 或许更好. Anyway, 上面就是一个简单的 Loop. 
</p>
</div>
</div>

<div id="outline-container-orgf535685" class="outline-4">
<h4 id="orgf535685"><span class="section-number-4">1.4.2</span> the concept of basic</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
一段经常性执行的代码便是一个 basic block. 由于加速经常性时间的构想, 这段代码实际上会被特地的优化, 使得其运行速度变得更快. 
</p>
</div>
</div>

<div id="outline-container-org7ea47fd" class="outline-4">
<h4 id="org7ea47fd"><span class="section-number-4">1.4.3</span> Function and stack</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
我们有的时候要将数据存入 stack, 而 stack 是位于内存里面的. 我们在手动进行汇编程序的编写的时候, 要初始化数据, 这个时候我们可以手动地为这些数据分配空间, 放在 stack 里面. 我们接下来给出一个 bing 的例子:
</p>

<pre class="example">
factorial:
    addi sp, sp, -16  # Allocate space on stack
    sw ra, 12(sp)     # Save return address
    sw a0, 8(sp)      # Save argument n
    addi a1, x0, 1    # Initialize result to 1
    beq a0, x0, end   # If n == 0, jump to end
loop:
    mul a1, a1, a0    # result *= n
    addi a0, a0, -1   # n--
    bne a0, x0, loop  # If n != 0, jump to loop
end:
    mv a0, a1         # Return result in a0
    lw ra, 12(sp)     # Restore return address
    addi sp, sp, 16   # Deallocate space on stack
    ret               # Return from function
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf2fc06" class="outline-3">
<h3 id="orgbf2fc06"><span class="section-number-3">1.5</span> The expression of an instruction</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org8a3cf34" class="outline-4">
<h4 id="org8a3cf34"><span class="section-number-4">1.5.1</span> the field of an instruction code</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
一个 instruction code 是32位. 一般来说会划分出大约5到6个field, 这些
field有它们自己的功能. 对于不同类型的指令码, 这些field各有不同. 我们这
里用 add 指令为例子.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">field</th>
<th scope="col" class="org-left">funct7</th>
<th scope="col" class="org-left">rst2</th>
<th scope="col" class="org-left">rst1</th>
<th scope="col" class="org-left">funct3</th>
<th scope="col" class="org-left">rd</th>
<th scope="col" class="org-left">opcode</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">code</td>
<td class="org-left"><code>xxxxxxx</code></td>
<td class="org-left"><code>xxxxx</code></td>
<td class="org-left"><code>xxxxx</code></td>
<td class="org-left"><code>xxx</code></td>
<td class="org-left"><code>xxxxx</code></td>
<td class="org-left"><code>xxxxxxx</code></td>
</tr>

<tr>
<td class="org-left">bits</td>
<td class="org-left">7</td>
<td class="org-left">5</td>
<td class="org-left">5</td>
<td class="org-left">3</td>
<td class="org-left">5</td>
<td class="org-left">7</td>
</tr>
</tbody>
</table>

<p>
这是 R-type 指令.  R for register.
</p>
</div>
</div>

<div id="outline-container-org338b144" class="outline-4">
<h4 id="org338b144"><span class="section-number-4">1.5.2</span> the type of the instruction code</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
共有很多类型, 常见的有 R, I, J, S, SB, U 型指令. I for immediate. One of the operand is a imm. J is for jump. I-type instructions are jump instruction (conditionally). S is for what? I can't remember well. I remember U-type is used for very long immediate number.
</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
在 x86 之中并非如此, 大部分指令都可以对内存之中的数据进行操作.
比如说我们有一个 add 指令. 写为 
</p>

<pre class="example">
add x1, x1, Imm(x2)
</pre>

<p class="footpara">
<code>x1</code> 并不是 x86 之中寄存器的名字 it's just a symbol, 这是说, 我们找到 <code>Imm + x2</code> 为地址的内存数据, 加上 <code>x1</code> 之后再加到 <code>x1</code> 上.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Knuth may also think that the assembly is a little annoying, but he employed assembly to express algorithm in his book. Cool!
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2023-06-20 Tue 17:24</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>