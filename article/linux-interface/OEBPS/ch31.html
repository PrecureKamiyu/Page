<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 31. Threads: Thread Safety and Per-Thread Storage</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch30.html" title="Chapter 30. Threads: Thread Synchronization"/><link rel="next" href="ch32.html" title="Chapter 32. Threads: Thread Cancellation"/></head><body><section class="chapter" title="Chapter 31. Threads: Thread Safety and Per-Thread Storage" epub:type="chapter" id="threads_colon_thread_safety_and_per-thre"><div class="titlepage"><div><div><h2 class="title">Chapter 31. Threads: Thread Safety and Per-Thread Storage</h2></div></div></div><p>This chapter extends the discussion of the POSIX threads API, providing a description
            of thread-safe functions and one-time initialization. We also discuss how to use
            thread-specific data or thread-local storage to make an existing function thread-safe
            without changing the function’s interface.</p><div class="sect1" title="Thread Safety (and Reentrancy Revisited)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="thread_safety_open_parenthesis_and_reent">Thread Safety (and Reentrancy Revisited)</h2></div></div></div><p>A function is said to be <span class="emphasis"><em>thread-safe</em></span> if it can safely be
                invoked by multiple threads at the same time; put conversely, if a function is not
                thread-safe, then we can’t call it from one thread while it is being executed in
                another thread. For example, the following function (similar to code that we looked
                at in <a class="xref" href="ch30.html#protecting_accesses_to_shared_variables" title="Protecting Accesses to Shared Variables: Mutexes">Protecting Accesses to Shared Variables: Mutexes</a>) is not
                    thread-safe:<a id="IDX-CHP-31-4559" class="indexterm"/></p><a id="I_programlisting31_d1e87421"/><pre class="programlisting">static int glob = 0;

static void
incr(int loops)
{
    int loc, j;
    for (j = 0; j &lt; loops; j++) {
     loc = glob;
     loc++;
     glob = loc;
   }
}</pre><p>If multiple threads invoke this function concurrently, the final value in
                    <span class="emphasis"><em>glob</em></span> is unpredictable. This function illustrates the
                typical reason that a function is not thread-safe: it employs global or static
                variables that are shared by all threads.</p><p>There are various methods of rendering a function thread-safe. One way is to
                associate a mutex with the function (or perhaps with all of the functions in a
                library, if they all share the same global variables), lock that mutex when the
                function is called, and unlock it when the mutex returns. This approach has the
                virtue of simplicity. On the other hand, it means that only one thread at a time can
                execute the function—we say that access to the function is
                    <span class="emphasis"><em>serialized</em></span>. If the threads spend a significant amount of
                time executing this function, then this serialization results in a loss of
                concurrency, because the threads of a program can no longer execute in
                parallel.</p><p>A more sophisticated solution is to associate the mutex with a shared variable. We
                then determine which parts of the function are critical sections that access the
                shared variable, and acquire and release the mutex only during the execution of
                these critical sections. This allows multiple threads to execute the function at the
                same time and to operate in parallel, except when more than one thread needs to
                execute a critical section.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="non-thread-safe_functions"/></div></div></div><div class="sect3" title="Non-thread-safe functions"><div class="titlepage"><div><div><h4 class="title" id="non-thread-safe_functions-id1">Non-thread-safe functions</h4></div></div></div><p>To facilitate the development of threaded applications, all of the
                        functions specified in SUSv3 are required to be implemented in a thread-safe
                        manner, except those listed in <a class="xref" href="ch31.html#functions_that_susv3_does_not_require_to" title="Table 31-1. Functions that SUSv3 does not require to be thread-safe">Table 31-1</a>. (Many of these
                        functions are not discussed in this book.)</p><p>In addition to the functions listed in <a class="xref" href="ch31.html#functions_that_susv3_does_not_require_to" title="Table 31-1. Functions that SUSv3 does not require to be thread-safe">Table 31-1</a>, SUSv3 specifies
                        the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>ctermid()</em></span> and
                                    <span class="emphasis"><em>tmpnam()</em></span> functions need not be thread-safe
                                if passed a <code class="literal">NULL</code>
                                    argument.<a id="IDX-CHP-31-4560" class="indexterm"/><a id="IDX-CHP-31-4561" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>wcrtomb()</em></span> and
                                    <span class="emphasis"><em>wcsrtombs()</em></span> functions need not be
                                thread-safe if their final argument (<span class="emphasis"><em>ps</em></span>) is
                                    <code class="literal">NULL</code>.<a id="IDX-CHP-31-4562" class="indexterm"/><a id="IDX-CHP-31-4563" class="indexterm"/></p></li></ul></div><p>SUSv4 modifies the list of functions in <a class="xref" href="ch31.html#functions_that_susv3_does_not_require_to" title="Table 31-1. Functions that SUSv3 does not require to be thread-safe">Table 31-1</a> as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>ecvt()</em></span>, <span class="emphasis"><em>fcvt()</em></span>,
                                    <span class="emphasis"><em>gcvt()</em></span>,
                                    <span class="emphasis"><em>gethostbyname()</em></span>, and
                                    <span class="emphasis"><em>gethostbyaddr()</em></span> are removed, since these
                                functions have been removed from the standard.<a id="IDX-CHP-31-4564" class="indexterm"/><a id="IDX-CHP-31-4565" class="indexterm"/><a id="IDX-CHP-31-4566" class="indexterm"/><a id="IDX-CHP-31-4567" class="indexterm"/><a id="IDX-CHP-31-4568" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>strsignal()</em></span> and
                                    <span class="emphasis"><em>system()</em></span> functions are added. The
                                    <span class="emphasis"><em>system()</em></span> function is nonreentrant because
                                the manipulations that it must make to signal dispositions have a
                                process-wide effect.<a id="IDX-CHP-31-4569" class="indexterm"/><a id="IDX-CHP-31-4570" class="indexterm"/></p></li></ul></div><p>The standards do not prohibit an implementation from making the functions
                        in <a class="xref" href="ch31.html#functions_that_susv3_does_not_require_to" title="Table 31-1. Functions that SUSv3 does not require to be thread-safe">Table 31-1</a> thread-safe.
                        However, even if some of these functions are thread-safe on some
                        implementations, a portable application can’t rely on this to be the case on
                        all implementations.</p><div class="table"><a id="functions_that_susv3_does_not_require_to"/><div class="table-title">Table 31-1. Functions that SUSv3 does not require to be thread-safe</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>asctime()</em></span>
                                            <a id="IDX-CHP-31-4571" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>basename()</em></span>
                                            <a id="IDX-CHP-31-4572" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>catgets()</em></span>
                                            <a id="IDX-CHP-31-4573" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>crypt()</em></span>
                                            <a id="IDX-CHP-31-4574" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>ctime()</em></span>
                                            <a id="IDX-CHP-31-4575" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_clearerr()</em></span>
                                            <a id="IDX-CHP-31-4576" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_close()</em></span>
                                            <a id="IDX-CHP-31-4577" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_delete()</em></span>
                                            <a id="IDX-CHP-31-4578" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_error()</em></span>
                                            <a id="IDX-CHP-31-4579" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_fetch()</em></span>
                                            <a id="IDX-CHP-31-4580" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_firstkey()</em></span>
                                            <a id="IDX-CHP-31-4581" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_nextkey()</em></span>
                                            <a id="IDX-CHP-31-4582" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_open()</em></span>
                                            <a id="IDX-CHP-31-4583" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dbm_store()</em></span>
                                            <a id="IDX-CHP-31-4584" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dirname()</em></span>
                                            <a id="IDX-CHP-31-4585" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>dlerror()</em></span>
                                            <a id="IDX-CHP-31-4586" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>drand48()</em></span>
                                            <a id="IDX-CHP-31-4587" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>ecvt()</em></span>
                                            <a id="IDX-CHP-31-4588" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>encrypt()</em></span>
                                            <a id="IDX-CHP-31-4589" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>endgrent()</em></span>
                                            <a id="IDX-CHP-31-4590" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>endpwent()</em></span>
                                            <a id="IDX-CHP-31-4591" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>endutxent()</em></span>
                                            <a id="IDX-CHP-31-4592" class="indexterm"/>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>fcvt()</em></span>
                                            <a id="IDX-CHP-31-4593" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>ftw()</em></span>
                                            <a id="IDX-CHP-31-4594" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>gcvt()</em></span>
                                            <a id="IDX-CHP-31-4595" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getc_unlocked()</em></span>
                                            <a id="IDX-CHP-31-4596" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getchar_unlocked()</em></span>
                                            <a id="IDX-CHP-31-4597" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getdate()</em></span>
                                            <a id="IDX-CHP-31-4598" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getenv()</em></span>
                                            <a id="IDX-CHP-31-4599" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getgrent()</em></span>
                                            <a id="IDX-CHP-31-4600" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getgrgid()</em></span>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getgrnam()</em></span>
                                            <a id="IDX-CHP-31-4601" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>gethostbyaddr()</em></span>
                                            <a id="IDX-CHP-31-4602" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>gethostbyname()</em></span>
                                            <a id="IDX-CHP-31-4603" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>gethostent()</em></span>
                                            <a id="IDX-CHP-31-4604" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getlogin()</em></span>
                                            <a id="IDX-CHP-31-4605" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getnetbyaddr()</em></span>
                                            <a id="IDX-CHP-31-4606" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getnetbyname()</em></span>
                                            <a id="IDX-CHP-31-4607" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getnetent()</em></span>
                                            <a id="IDX-CHP-31-4608" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getopt()</em></span>
                                            <a id="IDX-CHP-31-4609" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getprotobyname()</em></span>
                                            <a id="IDX-CHP-31-4610" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getprotobynumber()</em></span>
                                            <a id="IDX-CHP-31-4611" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getprotoent()</em></span>
                                            <a id="IDX-CHP-31-4612" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getpwent()</em></span>
                                            <a id="IDX-CHP-31-4613" class="indexterm"/>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>
                                            <span class="emphasis"><em>getpwnam()</em></span>
                                            <a id="IDX-CHP-31-4614" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getpwuid()</em></span>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getservbyname()</em></span>
                                            <a id="IDX-CHP-31-4615" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getservbyport()</em></span>
                                            <a id="IDX-CHP-31-4616" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getservent()</em></span>
                                            <a id="IDX-CHP-31-4617" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getutxent()</em></span>
                                            <a id="IDX-CHP-31-4618" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getutxid()</em></span>
                                            <a id="IDX-CHP-31-4619" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>getutxline()</em></span>
                                            <a id="IDX-CHP-31-4620" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>gmtime()</em></span>
                                            <a id="IDX-CHP-31-4621" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>hcreate()</em></span>
                                            <a id="IDX-CHP-31-4622" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>hdestroy()</em></span>
                                            <a id="IDX-CHP-31-4623" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>hsearch()</em></span>
                                            <a id="IDX-CHP-31-4624" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>inet_ntoa()</em></span>
                                            <a id="IDX-CHP-31-4625" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>l64a()</em></span>
                                            <a id="IDX-CHP-31-4626" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>lgamma()</em></span>
                                            <a id="IDX-CHP-31-4627" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>lgammaf()</em></span>
                                            <a id="IDX-CHP-31-4628" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>lgammal()</em></span>
                                            <a id="IDX-CHP-31-4629" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>localeconv()</em></span>
                                            <a id="IDX-CHP-31-4630" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>localtime()</em></span>
                                            <a id="IDX-CHP-31-4631" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>lrand48()</em></span>
                                            <a id="IDX-CHP-31-4632" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>mrand48()</em></span>
                                            <a id="IDX-CHP-31-4633" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>nftw()</em></span>
                                            <a id="IDX-CHP-31-4634" class="indexterm"/>
                                        </p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>
                                            <span class="emphasis"><em>nl_langinfo()</em></span>
                                            <a id="IDX-CHP-31-4635" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>ptsname()</em></span>
                                            <a id="IDX-CHP-31-4636" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>putc_unlocked()</em></span>
                                            <a id="IDX-CHP-31-4637" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>putchar_unlocked()</em></span>
                                            <a id="IDX-CHP-31-4638" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>putenv()</em></span>
                                            <a id="IDX-CHP-31-4639" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>pututxline()</em></span>
                                            <a id="IDX-CHP-31-4640" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>rand()</em></span>
                                            <a id="IDX-CHP-31-4641" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>readdir()</em></span>
                                            <a id="IDX-CHP-31-4642" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>setenv()</em></span>
                                            <a id="IDX-CHP-31-4643" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>setgrent()</em></span>
                                            <a id="IDX-CHP-31-4644" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>setkey()</em></span>
                                            <a id="IDX-CHP-31-4645" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>setpwent()</em></span>
                                            <a id="IDX-CHP-31-4646" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>setutxent()</em></span>
                                            <a id="IDX-CHP-31-4647" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>strerror()</em></span>
                                            <a id="IDX-CHP-31-4648" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>strtok()</em></span>
                                            <a id="IDX-CHP-31-4649" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>ttyname()</em></span>
                                            <a id="IDX-CHP-31-4650" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>unsetenv()</em></span>
                                            <a id="IDX-CHP-31-4651" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>wcstombs()</em></span>
                                            <a id="IDX-CHP-31-4652" class="indexterm"/>
                                        </p>
                                        <p>
                                            <span class="emphasis"><em>wctomb()</em></span>
                                            <a id="IDX-CHP-31-4653" class="indexterm"/>
                                        </p>
                                    </td></tr></tbody></table></div></div></div><div class="sect3" title="Reentrant and nonreentrant functions"><div class="titlepage"><div><div><h4 class="title" id="reentrant_and_nonreentrant_function">Reentrant and nonreentrant functions</h4></div></div></div><p>Although the use of critical sections to implement thread safety is a
                        significant improvement over the use of per-function mutexes, it is still
                        somewhat inefficient because there is a cost to locking and unlocking a
                        mutex. A <span class="emphasis"><em>reentrant function</em></span> achieves thread safety
                        without the use of mutexes. It does this by avoiding the use of global and
                        static variables. Any information that must be returned to the caller, or
                        maintained between calls to the function, is stored in buffers allocated by
                        the caller. (We first encountered reentrancy when discussing the treatment
                        of global variables within signal handlers in <a class="xref" href="ch21.html#reentrant_and_async-signal-safe_function" title="Reentrant and Async-Signal-Safe Functions">Reentrant and Async-Signal-Safe Functions</a>.) However, not all
                        functions can be made reentrant. The usual reasons are the
                            following:<a id="IDX-CHP-31-4654" class="indexterm"/><a id="IDX-CHP-31-4655" class="indexterm"/><a id="IDX-CHP-31-4656" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>By their nature, some functions must access global data
                                structures. The functions in the <span class="emphasis"><em>malloc</em></span> library
                                provide a good example. These functions maintain a global linked
                                list of free blocks on the heap. The functions of the
                                    <span class="emphasis"><em>malloc</em></span> library are made thread-safe through
                                the use of mutexes.</p></li><li class="listitem"><p>Some functions (defined before the invention of threads) have an
                                interface that by definition is nonreentrant, because they return
                                pointers to storage statically allocated by the function, or they
                                employ static storage to maintain information between successive
                                calls to the same (or a related) function. Most of the functions in
                                    <a class="xref" href="ch31.html#functions_that_susv3_does_not_require_to" title="Table 31-1. Functions that SUSv3 does not require to be thread-safe">Table 31-1</a> fall
                                into this category. For example, the <span class="emphasis"><em>asctime()</em></span>
                                function (<a class="xref" href="ch10.html#converting_between_broken-down_time_and" title="Converting Between Broken-Down Time and Printable Form">Converting Between Broken-Down Time and Printable Form</a>)
                                returns a pointer to a statically allocated buffer containing a
                                date-time string.</p></li></ul></div><p>For several of the functions that have nonreentrant interfaces, SUSv3
                        specifies reentrant equivalents with names ending with the suffix
                            <span class="emphasis"><em>_r</em></span>. These functions require the caller to allocate
                        a buffer whose address is then passed to the function and used to return the
                        result. This allows the calling thread to use a local (stack) variable for
                        the function result buffer. For this purpose, SUSv3 specifies
                            <span class="emphasis"><em>asctime_r()</em></span>, <span class="emphasis"><em>ctime_r()</em></span>,
                            <span class="emphasis"><em>getgrgid_r()</em></span>, <span class="emphasis"><em>getgrnam_r()</em></span>,
                            <span class="emphasis"><em>getlogin_r()</em></span>, <span class="emphasis"><em>getpwnam_r()</em></span>,
                            <span class="emphasis"><em>getpwuid_r()</em></span>, <span class="emphasis"><em>gmtime_r()</em></span>,
                            <span class="emphasis"><em>localtime_r()</em></span>, <span class="emphasis"><em>rand_r()</em></span>,
                            <span class="emphasis"><em>readdir_r()</em></span>, <span class="emphasis"><em>strerror_r()</em></span>,
                            <span class="emphasis"><em>strtok_r()</em></span>, and
                            <span class="emphasis"><em>ttyname_r()</em></span>.<a id="IDX-CHP-31-4657" class="indexterm"/><a id="IDX-CHP-31-4658" class="indexterm"/><a id="IDX-CHP-31-4659" class="indexterm"/><a id="IDX-CHP-31-4660" class="indexterm"/><a id="IDX-CHP-31-4661" class="indexterm"/><a id="IDX-CHP-31-4662" class="indexterm"/><a id="IDX-CHP-31-4663" class="indexterm"/><a id="IDX-CHP-31-4664" class="indexterm"/><a id="IDX-CHP-31-4665" class="indexterm"/><a id="IDX-CHP-31-4666" class="indexterm"/><a id="IDX-CHP-31-4667" class="indexterm"/><a id="IDX-CHP-31-4668" class="indexterm"/><a id="IDX-CHP-31-4669" class="indexterm"/><a id="IDX-CHP-31-4670" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some implementations also provide additional reentrant equivalents of
                            other traditional nonreentrant functions. For example,
                                <span class="emphasis"><em>glibc</em></span> provides <span class="emphasis"><em>crypt_r()</em></span>,
                                <span class="emphasis"><em>gethostbyname_r()</em></span>,
                                <span class="emphasis"><em>getservbyname_r()</em></span>,
                                <span class="emphasis"><em>getutent_r()</em></span>, <span class="emphasis"><em>getutid_r()</em></span>,
                                <span class="emphasis"><em>getutline_r()</em></span>, and
                                <span class="emphasis"><em>ptsname_r()</em></span>. However, a portable application
                            can’t rely on these functions being present on other implementations. In
                            some cases, SUSv3 doesn’t specify these reentrant equivalents because
                            alternatives to the traditional functions exist that are both superior
                            and reentrant. For example, <span class="emphasis"><em>getaddrinfo()</em></span> is the
                            modern, reentrant alternative to <span class="emphasis"><em>gethostbyname()</em></span>
                            and <span class="emphasis"><em>getservbyname()</em></span>.<a id="IDX-CHP-31-4671" class="indexterm"/><a id="IDX-CHP-31-4672" class="indexterm"/><a id="IDX-CHP-31-4673" class="indexterm"/><a id="IDX-CHP-31-4674" class="indexterm"/><a id="IDX-CHP-31-4675" class="indexterm"/><a id="IDX-CHP-31-4676" class="indexterm"/><a id="IDX-CHP-31-4677" class="indexterm"/></p></div></div></div></div><div class="sect1" title="One-Time Initialization"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="one-time_initialization">One-Time Initialization</h2></div></div></div><p>Sometimes, a threaded application needs to ensure that some initialization action
                occurs just once, regardless of how many threads are created. For example, a mutex
                may need to be initialized with special attributes using
                    <span class="emphasis"><em>pthread_mutex_init()</em></span>, and that initialization must occur
                just once. If we are creating the threads from the main program, then this is
                generally easy to achieve—we perform the initialization before creating any threads
                that depend on the initialization. However, in a library function, this is not
                possible, because the calling program may create the threads before the first call
                to the library function. Therefore, the library function needs a method of
                performing the initialization the first time that it is called from any
                    thread.<a id="IDX-CHP-31-4678" class="indexterm"/><a id="IDX-CHP-31-4679" class="indexterm"/></p><p>A library function can perform one-time initialization using the
                    <span class="emphasis"><em>pthread_once()</em></span> function.<a id="IDX-CHP-31-4680" class="indexterm"/><a id="IDX-CHP-31-4681" class="indexterm"/></p><a id="I_programlisting31_d1e88503"/><pre class="programlisting">#include &lt;pthread.h&gt;

int <strong class="userinput"><code>pthread_once</code></strong>(pthread_once_t *<span class="emphasis"><em>once_control</em></span>, void (*<span class="emphasis"><em>init</em></span>)(void));</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><p>The <span class="emphasis"><em>pthread_once()</em></span> function uses the state of the argument
                    <span class="emphasis"><em>once_control</em></span> to ensure that the caller-defined function
                pointed to by <span class="emphasis"><em>init</em></span> is called just once, no matter how many
                times or from how many different threads the <span class="emphasis"><em>pthread_once()</em></span>
                call is made.</p><p>The <span class="emphasis"><em>init</em></span> function is called without any arguments, and thus
                has the following form:</p><a id="I_programlisting31_d1e88536"/><pre class="programlisting">void
init(void)
{
    /* Function body */
}</pre><p>The <span class="emphasis"><em>once_control</em></span> argument is a pointer to a variable that
                must be statically initialized with the value <code class="literal">PTHREAD_ONCE_INIT</code>:</p><a id="I_programlisting31_d1e88546"/><pre class="programlisting">pthread_once_t once_var = PTHREAD_ONCE_INIT;</pre><p>The first call to <span class="emphasis"><em>pthread_once()</em></span> that specifies a pointer to
                a particular <span class="emphasis"><em>pthread_once_t</em></span> variable modifies the value of the
                variable pointed to by <span class="emphasis"><em>once_control</em></span> so that subsequent calls to
                    <span class="emphasis"><em>pthread_once()</em></span> don’t invoke
                <span class="emphasis"><em>init</em></span>.</p><p>One common use of <span class="emphasis"><em>pthread_once()</em></span> is in conjunction with
                thread-specific data, which we describe next.<a id="IDX-CHP-31-4682" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The main reason for the existence of <span class="emphasis"><em>pthread_once()</em></span> is
                    that in early versions of Pthreads, it was not possible to statically initialize
                    a mutex. Instead, the use of <span class="emphasis"><em>pthread_mutex_init()</em></span> was
                    required ([Butenhof, 1996]). Given the later addition of statically allocated
                    mutexes, it is possible for a library function to perform one-time
                    initialization using a statically allocated mutex and a static Boolean variable.
                    Nevertheless, <span class="emphasis"><em>pthread_once()</em></span> is retained as a
                    convenience.</p></div></div><div class="sect1" title="Thread-Specific Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="thread-specific_data">Thread-Specific Data</h2></div></div></div><p>The most efficient way of making a function thread-safe is to make it reentrant.
                All new library functions should be implemented in this way. However, for an
                existing nonreentrant library function (one that was perhaps designed before the use
                of threads became common), this approach usually requires changing the function’s
                interface, which means modifying all of the programs that use the
                    function.<a id="IDX-CHP-31-4683" class="indexterm"/><a id="IDX-CHP-31-4684" class="indexterm"/></p><p>Thread-specific data is a technique for making an existing function thread-safe
                without changing its interface. A function that uses thread-specific data may be
                slightly less efficient than a reentrant function, but allows us to leave the
                programs that call the function unchanged.</p><p>Thread-specific data allows a function to maintain a separate copy of a variable
                for each thread that calls the function, as illustrated in <a class="xref" href="ch31.html#thread-specific_data_open_parenthesis_ts" title="Figure 31-1. Thread-specific data (TSD) provides per-thread storage for a function">Figure 31-1</a>. Thread-specific data is
                persistent; each thread’s variable continues to exist between the thread’s
                invocations of the function. This allows the function to maintain per-thread
                information between calls to the function, and allows the function to pass distinct
                result buffers (if required) to each calling thread.</p><div class="figure"><a id="thread-specific_data_open_parenthesis_ts"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject31_d1e88608"/><img src="figs/web/31-1_THREADS-B1-TSD-scale90.png.jpg" alt="Thread-specific data (TSD) provides per-thread storage for a function"/></div></div><div class="figure-title">Figure 31-1. Thread-specific data (TSD) provides per-thread storage for a function</div></div><div class="sect2" title="Thread-Specific Data from the Library Function’s Perspective"><div class="titlepage"><div><div><h3 class="title" id="thread-specific_data_from_the_library_fu">Thread-Specific Data from the Library Function’s Perspective</h3></div></div></div><p>In order to understand the use of the thread-specific data API, we need to
                    consider things from the point of view of a library function that uses
                    thread-specific data:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The function must allocate a separate block of storage for each thread
                            that calls the function. This block needs to be allocated once, the
                            first time the thread calls the function.</p></li><li class="listitem"><p>On each subsequent call from the same thread, the function needs to be
                            able to obtain the address of the storage block that was allocated the
                            first time this thread called the function. The function can’t maintain
                            a pointer to the block in an automatic variable, since automatic
                            variables disappear when the function returns; nor can it store the
                            pointer in a static variable, since only one instance of each static
                            variable exists in the process. The Pthreads API provides functions to
                            handle this task.</p></li><li class="listitem"><p>Different (i.e., independent) functions may each need thread-specific
                            data. Each function needs a method of identifying its thread-specific
                            data (a key), as distinct from the thread-specific data used by other
                            functions.</p></li><li class="listitem"><p>The function has no direct control over what happens when the thread
                            terminates. When the thread terminates, it is probably executing code
                            outside the function. Nevertheless, there must be some mechanism (a
                            destructor) to ensure that the storage block allocated for this thread
                            is automatically deallocated when the thread terminates. If this is not
                            done, then a memory leak could occur as threads are continuously
                            created, call the function, and then terminate.</p></li></ul></div></div><div class="sect2" title="Overview of the Thread-Specific Data API"><div class="titlepage"><div><div><h3 class="title" id="overview_of_the_thread-specific_data_api">Overview of the Thread-Specific Data API</h3></div></div></div><p>The general steps that a library function performs in order to use
                    thread-specific data are as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The function creates a <span class="emphasis"><em>key</em></span>, which is the means of
                            differentiating the thread-specific data item used by this function from
                            the thread-specific data items used by other functions. The key is
                            created by calling the <span class="emphasis"><em>pthread_key_create()</em></span>
                            function. Creating a key needs to be done only once, when the first
                            thread calls the function. For this purpose,
                                <span class="emphasis"><em>pthread_once()</em></span> is employed. Creating a key
                            doesn’t allocate any blocks of thread-specific data.</p></li><li class="listitem"><p>The call to <span class="emphasis"><em>pthread_key_create()</em></span> serves a second
                            purpose: it allows the caller to specify the address of the
                            programmer-defined destructor function that is used to deallocate each
                            of the storage blocks allocated for this key (see the next step). When a
                            thread that has thread-specific data terminates, the Pthreads API
                            automatically invokes the destructor, passing it a pointer to the data
                            block for this thread.</p></li><li class="listitem"><p>The function allocates a thread-specific data block for each thread
                            from which it is called. This is done using
                                <span class="emphasis"><em>malloc()</em></span> (or a similar function). This
                            allocation is done once for each thread, the first time the thread calls
                            the function.</p></li><li class="listitem"><p>In order to save a pointer to the storage allocated in the previous
                            step, the function employs two Pthreads functions:
                                <span class="emphasis"><em>pthread_setspecific()</em></span> and
                                <span class="emphasis"><em>pthread_getspecific()</em></span>. A call to
                                <span class="emphasis"><em>pthread_setspecific()</em></span> is a request to the
                            Pthreads implementation to say “save this pointer, recording the fact
                            that it is associated with a particular key (the one for this function)
                            and a particular thread (the calling thread).” Calling
                                <span class="emphasis"><em>pthread_getspecific()</em></span> performs the
                            complementary task, returning the pointer previously associated with a
                            given key for the calling thread. If no pointer was previously
                            associated with a particular key and thread, then
                                <span class="emphasis"><em>pthread_getspecific()</em></span> returns <code class="literal">NULL</code>. This is how a function can determine
                            that it is being called for the first time by this thread, and thus must
                            allocate the storage block for the thread.</p></li></ol></div></div><div class="sect2" title="Details of the Thread-Specific Data API"><div class="titlepage"><div><div><h3 class="title" id="details_of_the_thread-specific_data_api">Details of the Thread-Specific Data API</h3></div></div></div><p>In this section, we provide details of each of the functions mentioned in the
                    previous section, and elucidate the operation of thread-specific data by
                    describing how it is typically implemented. The next section shows how to use
                    thread-specific data to write a thread-safe implementation of the standard C
                    library function <span class="emphasis"><em>strerror()</em></span>.<a id="IDX-CHP-31-4685" class="indexterm"/><a id="IDX-CHP-31-4686" class="indexterm"/><a id="IDX-CHP-31-4687" class="indexterm"/><a id="IDX-CHP-31-4688" class="indexterm"/><a id="IDX-CHP-31-4689" class="indexterm"/></p><p>Calling <span class="emphasis"><em>pthread_key_create()</em></span> creates a new
                    thread-specific data key that is returned to the caller in the buffer pointed to
                    by <span class="emphasis"><em>key</em></span>.<a id="IDX-CHP-31-4690" class="indexterm"/></p><a id="I_programlisting31_d1e88734"/><pre class="programlisting">#include &lt;pthread.h&gt;

int <strong class="userinput"><code>pthread_key_create</code></strong>(pthread_key_t *<span class="emphasis"><em>key</em></span>, void (*<span class="emphasis"><em>destructor</em></span>)(void *));</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><p>Because the returned key is used by all threads in the process,
                        <span class="emphasis"><em>key</em></span> should point to a global variable.</p><p>The <span class="emphasis"><em>destructor</em></span> argument points to a programmer-defined
                    function of the following form:</p><a id="I_programlisting31_d1e88758"/><pre class="programlisting">void
dest(void *value)
{
    /* Release storage pointed to by 'value' */
}</pre><p>Upon termination of a thread that has a non-<code class="literal">NULL</code> value associated with <span class="emphasis"><em>key</em></span>, the
                    destructor function is automatically invoked by the Pthreads API and given that
                    value as its argument. The passed value is normally a pointer to this thread’s
                    thread-specific data block for this key. If a destructor is not required, then
                        <span class="emphasis"><em>destructor</em></span> can be specified as <code class="literal">NULL</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If a thread has multiple thread-specific data blocks, then the order in
                        which the destructors are called is unspecified. Destructor functions should
                        be designed to operate independently of one another.</p></div><p>Looking at the implementation of thread-specific data helps us to understand
                    how it is used. A typical implementation (NPTL is typical), involves the
                    following arrays:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>a single global (i.e., process-wide) array of information about
                            thread-specific data keys; and</p></li><li class="listitem"><p>a set of per-thread arrays, each containing pointers to all of the
                            thread-specific data blocks allocated for a particular thread (i.e.,
                            this array contains the pointers stored by calls to
                                <span class="emphasis"><em>pthread_setspecific()</em></span>).<a id="IDX-CHP-31-4691" class="indexterm"/></p></li></ul></div><p>In this implementation, the <span class="emphasis"><em>pthread_key_t</em></span> value returned
                    by <span class="emphasis"><em>pthread_key_create()</em></span> is simply an index into the global
                    array, which we label <span class="emphasis"><em>pthread_keys</em></span>, whose form is shown in
                        <a class="xref" href="ch31.html#implementation_of_thread-specific_data_k" title="Figure 31-2. Implementation of thread-specific data keys">Figure 31-2</a>. Each element of
                    this array is a structure containing two fields. The first field indicates
                    whether this array element is in use (i.e., has been allocated by a previous
                    call to <span class="emphasis"><em>pthread_key_create()</em></span>). The second field is used to
                    store the pointer to the destructor function for the thread-specific data blocks
                    for this key (i.e., it is a copy of the <span class="emphasis"><em>destructor</em></span> argument
                    to <span class="emphasis"><em>pthread_key_create()</em></span>).<a id="IDX-CHP-31-4692" class="indexterm"/></p><div class="figure"><a id="implementation_of_thread-specific_data_k"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject31_d1e88825"/><img src="figs/web/31-2_THREADS-B1-TSD-key-scale90.png.jpg" alt="Implementation of thread-specific data keys"/></div></div><div class="figure-title">Figure 31-2. Implementation of thread-specific data keys</div></div><p>The <span class="emphasis"><em>pthread_setspecific()</em></span> function requests the Pthreads
                    API to save a copy of <span class="emphasis"><em>value</em></span> in a data structure that
                    associates it with the calling thread and with <span class="emphasis"><em>key</em></span>, a key
                    returned by a previous call to <span class="emphasis"><em>pthread_key_create()</em></span>. The
                        <span class="emphasis"><em>pthread_getspecific()</em></span> function performs the converse
                    operation, returning the value that was previously associated with the given
                        <span class="emphasis"><em>key</em></span> for this thread.<a id="IDX-CHP-31-4693" class="indexterm"/></p><a id="I_programlisting31_d1e88855"/><pre class="programlisting">#include &lt;pthread.h&gt;

int <strong class="userinput"><code>pthread_setspecific</code></strong>(pthread_key_t <span class="emphasis"><em>key</em></span>, const void *<span class="emphasis"><em>value</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><a id="I_programlisting31_d1e88869"/><pre class="programlisting">void <strong class="userinput"><code>*pthread_getspecific</code></strong>(pthread_key_t <span class="emphasis"><em>key</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer, or <code class="literal">NULL</code> if no
                        thread-specific data isassociated with <span class="emphasis"><em>key</em></span></p></div><p>The <span class="emphasis"><em>value</em></span> argument given to
                        <span class="emphasis"><em>pthread_setspecific()</em></span> is normally a pointer to a block
                    of memory that has previously been allocated by the caller. This pointer will be
                    passed as the argument for the destructor function for this
                        <span class="emphasis"><em>key</em></span> when the thread terminates.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>value</em></span> argument doesn’t need to be a pointer to a
                        block of memory. It could be some scalar value that can be assigned (with a
                        cast) to <span class="emphasis"><em>void *</em></span>. In this case, the earlier call to
                            <span class="emphasis"><em>pthread_key_create()</em></span> would specify
                            <span class="emphasis"><em>destructor</em></span> as <code class="literal">NULL</code>.</p></div><p><a class="xref" href="ch31.html#data_structure_used_to_implement_thread-" title="Figure 31-3. Data structure used to implement thread-specific data (TSD) pointers">Figure 31-3</a> shows a typical
                    implementation of the data structure used to store <span class="emphasis"><em>value</em></span>.
                    In this diagram, we assume that <span class="emphasis"><em>pthread_keys[1]</em></span> was
                    allocated to a function named <span class="emphasis"><em>myfunc()</em></span>. For each thread,
                    the Pthreads API maintains an array of pointers to thread-specific data blocks.
                    The elements of each of these thread-specific arrays have a one-to-one
                    correspondence with the elements of the global <span class="emphasis"><em>pthread_keys</em></span>
                    array shown in <a class="xref" href="ch31.html#implementation_of_thread-specific_data_k" title="Figure 31-2. Implementation of thread-specific data keys">Figure 31-2</a>. The
                        <span class="emphasis"><em>pthread_setspecific()</em></span> function sets the element
                    corresponding to <span class="emphasis"><em>key</em></span> in the array for the calling
                    thread.</p><div class="figure"><a id="data_structure_used_to_implement_thread-"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject31_d1e88942"/><img src="figs/web/31-3_THREADS-B1-TSD-specific-scale90.png.jpg" alt="Data structure used to implement thread-specific data (TSD) pointers"/></div></div><div class="figure-title">Figure 31-3. Data structure used to implement thread-specific data (TSD)
                        pointers</div></div><p>When a thread is first created, all of its thread-specific data pointers are
                    initialized to <code class="literal">NULL</code>. This means that when our
                    library function is called by a thread for the first time, it must begin by
                    using <span class="emphasis"><em>pthread_getspecific()</em></span> to check whether the thread
                    already has an associated value for <span class="emphasis"><em>key</em></span>. If it does not,
                    then the function allocates a block of memory and saves a pointer to the block
                    using <span class="emphasis"><em>pthread_setspecific()</em></span>. We show an example of this in
                    the thread-safe <span class="emphasis"><em>strerror()</em></span> implementation presented in the
                    next section.</p></div><div class="sect2" title="Employing the Thread-Specific Data API"><div class="titlepage"><div><div><h3 class="title" id="employing_the_thread-specific_data_api">Employing the Thread-Specific Data API</h3></div></div></div><p>When we first described the standard <span class="emphasis"><em>strerror()</em></span> function
                    in <a class="xref" href="ch03.html#handling_errors_from_system_calls_and_li" title="Handling Errors from System Calls and Library Functions">Handling Errors from System Calls and Library Functions</a>, we noted that it
                    may return a pointer to a statically allocated string as its function result.
                    This means that <span class="emphasis"><em>strerror()</em></span> may not be thread-safe. In the
                    next few pages, we look at a non-thread-safe implementation of
                        <span class="emphasis"><em>strerror()</em></span>, and then show how thread-specific data can
                    be used to make this function thread-safe.<a id="IDX-CHP-31-4694" class="indexterm"/><a id="IDX-CHP-31-4695" class="indexterm"/><a id="IDX-CHP-31-4696" class="indexterm"/><a id="IDX-CHP-31-4697" class="indexterm"/><a id="IDX-CHP-31-4698" class="indexterm"/><a id="IDX-CHP-31-4699" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>On many UNIX implementations, including Linux, the
                            <span class="emphasis"><em>strerror()</em></span> function provided by the standard C
                        library <span class="emphasis"><em>is</em></span> thread-safe. However, we use the example of
                            <span class="emphasis"><em>strerror()</em></span> anyway, because SUSv3 doesn’t require
                        this function to be thread-safe, and its implementation provides a simple
                        example of the use of thread-specific data.</p></div><p><a class="xref" href="ch31.html#an_implementation_of_strerror_open_paren" title="Example 31-1. An implementation of strerror() that is not thread-safe">Example 31-1</a> shows a simple
                    non-thread-safe implementation of <span class="emphasis"><em>strerror()</em></span>. This function
                    makes use of a pair of global variables defined by <span class="emphasis"><em>glibc</em></span>:
                        <span class="emphasis"><em>_sys_errlist</em></span> is an array of pointers to strings
                    corresponding to the error numbers in <span class="emphasis"><em>errno</em></span> (thus, for
                    example, <span class="emphasis"><em>_sys_errlist[EINVAL]</em></span> points to the string
                        <span class="emphasis"><em>Invalid operation</em></span>), and <span class="emphasis"><em>_sys_nerr</em></span>
                    specifies the number of elements in <span class="emphasis"><em>_sys_errlist</em></span>.</p><div class="example"><a id="an_implementation_of_strerror_open_paren"/><div class="example-title">Example 31-1. An implementation of <span class="emphasis"><em>strerror()</em></span> that is not
                        thread-safe</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>threads/strerror.c</code></strong>

#define _GNU_SOURCE                 /* Get '_sys_nerr' and '_sys_errlist'
                                       declarations from &lt;stdio.h&gt; */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;           /* Get declaration of strerror() */

#define MAX_ERROR_LEN 256            /* Maximum length of string
                                        returned by strerror() */

static char buf[MAX_ERROR_LEN];     /* Statically allocated return buffer */

char *
strerror(int err)
{
    if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) {
        snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
    } else {
        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);
        buf[MAX_ERROR_LEN - 1] = '\0';          /* Ensure null termination */
    }

    return buf;

}

      <strong class="userinput"><code>threads/strerror.c</code></strong></pre></div></div><p>We can use the program in <a class="xref" href="ch31.html#calling_strerror_open_parenthesis_close" title="Example 31-2. Calling strerror() from two different threads">Example 31-2</a> to demonstrate the
                    consequences of the fact that the <span class="emphasis"><em>strerror()</em></span> implementation
                    in <a class="xref" href="ch31.html#an_implementation_of_strerror_open_paren" title="Example 31-1. An implementation of strerror() that is not thread-safe">Example 31-1</a> is not
                    thread-safe. This program calls <span class="emphasis"><em>strerror()</em></span> from two
                    different threads, but displays the returned value only after both threads have
                    called <span class="emphasis"><em>strerror()</em></span>. Even though each thread specifies a
                    different value (<code class="literal">EINVAL</code> and <code class="literal">EPERM</code>) as the argument to
                        <span class="emphasis"><em>strerror()</em></span>, this is what we see when we compile and
                    link this program with the version of <span class="emphasis"><em>strerror()</em></span> shown in
                        <a class="xref" href="ch31.html#an_implementation_of_strerror_open_paren" title="Example 31-1. An implementation of strerror() that is not thread-safe">Example 31-1</a>:</p><a id="I_programlisting31_d1e89092"/><pre class="programlisting">$ <strong class="userinput"><code>./strerror_test</code></strong>
Main thread has called strerror()
Other thread about to call strerror()
Other thread: str (0x804a7c0) = Operation not permitted
Main thread:  str (0x804a7c0) = Operation not permitted</pre><p>Both threads displayed the <span class="emphasis"><em>errno</em></span> string corresponding to
                        <code class="literal">EPERM</code>, because the call to
                        <span class="emphasis"><em>strerror()</em></span> by the second thread (in
                        <span class="emphasis"><em>threadFunc</em></span>) overwrote the buffer that was written by
                    the call to <span class="emphasis"><em>strerror()</em></span> in the main thread. Inspection of
                    the output shows that the local variable <span class="emphasis"><em>str</em></span> in the two
                    threads points to the same memory address.</p><div class="example"><a id="calling_strerror_open_parenthesis_close"/><div class="example-title">Example 31-2. Calling <span class="emphasis"><em>strerror()</em></span> from two different
                        threads</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>threads/strerror_test.c</code></strong>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;                 /* Get declaration of strerror() */
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"

static void *
threadFunc(void *arg)
{
    char *str;

    printf("Other thread about to call strerror()\n");
    str = strerror(EPERM);
    printf("Other thread: str (%p) = %s\n", str, str);

    return NULL;
}

int
main(int argc, char *argv[])
{
    pthread_t t;
    int s;
    char *str;

    str = strerror(EINVAL);
    printf("Main thread has called strerror()\n");

    s = pthread_create(&amp;t, NULL, threadFunc, NULL);
    if (s != 0)
        errExitEN(s, "pthread_create");

    s = pthread_join(t, NULL);
    if (s != 0)
        errExitEN(s, "pthread_join");

    printf("Main thread:  str (%p) = %s\n", str, str);

    exit(EXIT_SUCCESS);
}

      <strong class="userinput"><code>threads/strerror_test.c</code></strong></pre></div></div><p><a class="xref" href="ch31.html#a_thread-safe_implementation_of_strerror" title="Example 31-3. A thread-safe implementation of strerror() using thread-specific data">Example 31-3</a> shows a
                    reimplementation of <span class="emphasis"><em>strerror()</em></span> that uses thread-specific
                    data to ensure thread safety.</p><p>The first step performed by the revised <span class="emphasis"><em>strerror()</em></span> is to
                    call <span class="emphasis"><em>pthread_once()</em></span>
                    <span class="inlinemediaobject"><a id="I_inlinemediaobject31_d1e89144"/><img src="figs/web/U004.png" alt=""/></span> to ensure that the first invocation of this function (from
                    any thread) calls <span class="emphasis"><em>createKey()</em></span>
                    <span class="inlinemediaobject"><a id="I_inlinemediaobject31_d1e89153"/><img src="figs/web/U002.png" alt=""/></span> . The <span class="emphasis"><em>createKey()</em></span> function calls
                        <span class="emphasis"><em>pthread_key_create()</em></span> to allocate a thread-specific data
                    key that is stored in the global variable <span class="emphasis"><em>strerrorKey</em></span>
                    <span class="inlinemediaobject"><a id="I_inlinemediaobject31_d1e89169"/><img src="figs/web/U003.png" alt=""/></span>. The call to <span class="emphasis"><em>pthread_key_create()</em></span> also
                    records the address of the destructor <span class="inlinemediaobject"><a id="I_inlinemediaobject31_d1e89178"/><img src="figs/web/U001.png" alt=""/></span> that will be used to free the thread-specific buffers
                    corresponding to this key.</p><p>The <span class="emphasis"><em>strerror()</em></span> function then calls
                        <span class="emphasis"><em>pthread_getspecific()</em></span>
                    <span class="inlinemediaobject"><a id="I_inlinemediaobject31_d1e89193"/><img src="figs/web/U005.png" alt=""/></span> to retrieve the address of this thread’s unique buffer
                    corresponding to <span class="emphasis"><em>strerrorKey</em></span>. If
                        <span class="emphasis"><em>pthread_getspecific()</em></span> returns <code class="literal">NULL</code>, then this thread is calling <span class="emphasis"><em>strerror()</em></span>
                    for the first time, and so the function allocates a new buffer using
                        <span class="emphasis"><em>malloc()</em></span>
                    <span class="inlinemediaobject"><a id="I_inlinemediaobject31_d1e89215"/><img src="figs/web/U006.png" alt=""/></span>, and saves the address of the buffer using
                        <span class="emphasis"><em>pthread_setspecific()</em></span>
                    <span class="inlinemediaobject"><a id="I_inlinemediaobject31_d1e89224"/><img src="figs/web/U007.png" alt=""/></span>. If the <span class="emphasis"><em>pthread_getspecific()</em></span> call
                    returns a non-<code class="literal">NULL</code> value, then that pointer
                    refers to an existing buffer that was allocated when this thread previously
                    called <span class="emphasis"><em>strerror()</em></span>.</p><p>The remainder of this <span class="emphasis"><em>strerror()</em></span> implementation is
                    similar to the implementation that we showed earlier, with the difference that
                        <span class="emphasis"><em>buf</em></span> is the address of a thread-specific data buffer,
                    rather than a static variable.</p><div class="example"><a id="a_thread-safe_implementation_of_strerror"/><div class="example-title">Example 31-3. A thread-safe implementation of <span class="emphasis"><em>strerror()</em></span> using
                        thread-specific data</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>threads/strerror_tsd.c</code></strong>
    #define _GNU_SOURCE             /* Get '_sys_nerr' and '_sys_errlist'
                                   declarations from &lt;stdio.h&gt; */
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;             /* Get declaration of strerror() */
    #include &lt;pthread.h&gt;
    #include "tlpi_hdr.h"

    static pthread_once_t once = PTHREAD_ONCE_INIT;
    static pthread_key_t strerrorKey;

    #define MAX_ERROR_LEN 256       /* Maximum length of string in per-thread
                                 buffer returned by strerror() */

    static void                     /* Free thread-specific data buffer */
<img src="figs/web/U001.png" alt=""/>  destructor(void *buf)
    {
        free(buf);
    }

    static void                     /* One-time key creation function */
<img src="figs/web/U002.png" alt=""/>  createKey(void)
    {
        int s;

        /* Allocate a unique thread-specific data key and save the address
           of the destructor for thread-specific data buffers */

<img src="figs/web/U003.png" alt=""/>    s = pthread_key_create(&amp;strerrorKey, destructor);
        if (s != 0)
            errExitEN(s, "pthread_key_create");
    }
        char *
    strerror(int err)
    {
        int s;
        char *buf;

        /* Make first caller allocate key for thread-specific data */

<img src="figs/web/U004.png" alt=""/>    s = pthread_once(&amp;once, createKey);
      if (s != 0)
            errExitEN(s, "pthread_once");

<img src="figs/web/U005.png" alt=""/>    buf = pthread_getspecific(strerrorKey);
      if (buf == NULL) {          /* If first call from this thread, allocate
                                       buffer for thread, and save its location */
<img src="figs/web/U006.png" alt=""/>        buf = malloc(MAX_ERROR_LEN);
          if (buf == NULL)
              errExit("malloc");

<img src="figs/web/U007.png" alt=""/>     s = pthread_setspecific(strerrorKey, buf);
       if (s != 0)
          errExitEN(s, "pthread_setspecific");
        }

        if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) {
            snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
        } else {
            strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);
            buf[MAX_ERROR_LEN - 1] = '\0';          /* Ensure null termination */
        }

        return buf;
    }

        <strong class="userinput"><code>threads/strerror_tsd.c</code></strong></pre></div></div><p>If we compile and link our test program (<a class="xref" href="ch31.html#calling_strerror_open_parenthesis_close" title="Example 31-2. Calling strerror() from two different threads">Example 31-2</a>) with the new version of
                        <span class="emphasis"><em>strerror()</em></span> (<a class="xref" href="ch31.html#a_thread-safe_implementation_of_strerror" title="Example 31-3. A thread-safe implementation of strerror() using thread-specific data">Example 31-3</a>) to create an
                    executable file, <code class="literal">strerror_test_tsd</code>, then we
                    see the following results when running the program:</p><a id="I_programlisting31_d1e89315"/><pre class="programlisting">$ <strong class="userinput"><code>./strerror_test_tsd</code></strong>
Main thread has called strerror()
Other thread about to call strerror()
Other thread: str (0x804b158) = Operation not permitted
Main thread:  str (0x804b008) = Invalid argument</pre><p>From this output, we see that the new version of
                        <span class="emphasis"><em>strerror()</em></span> is thread-safe. We also see that the address
                    pointed to by the local variable <span class="emphasis"><em>str</em></span> in the two threads is
                    different.</p></div><div class="sect2" title="Thread-Specific Data Implementation Limits"><div class="titlepage"><div><div><h3 class="title" id="thread-specific_data_implementation_limi">Thread-Specific Data Implementation Limits</h3></div></div></div><p>As implied by our description of how thread-specific data is typically
                    implemented, an implementation may need to impose limits on the number of
                    thread-specific data keys that it supports. SUSv3 requires that an
                    implementation support at least 128 (<code class="literal">_POSIX_THREAD_KEYS_MAX</code>) keys. An application can determine how
                    many keys an implementation actually supports either via the definition of
                        <code class="literal">PTHREAD_KEYS_MAX</code> (defined in <code class="literal">&lt;limits.h&gt;</code>) or by calling
                        <span class="emphasis"><em>sysconf(_SC_THREAD_KEYS_MAX)</em></span>. Linux supports up to 1024
                    keys.</p><p>Even 128 keys should be more than sufficient for most applications. This is
                    because each library function should employ only a small number of keys—often
                    just one. If a function requires multiple thread-specific data values, these can
                    usually be placed in a single structure that has just one associated
                    thread-specific data key.</p></div></div><div class="sect1" title="Thread-Local Storage"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="thread-local_storage">Thread-Local Storage</h2></div></div></div><p>Like thread-specific data, thread-local storage provides persistent per-thread
                storage. This feature is nonstandard, but it is provided in the same or a similar
                form on many other UNIX implementations (e.g., Solaris and FreeBSD).<a id="IDX-CHP-31-4700" class="indexterm"/><a id="IDX-CHP-31-4701" class="indexterm"/><a id="IDX-CHP-31-4702" class="indexterm"/><a id="IDX-CHP-31-4703" class="indexterm"/><a id="IDX-CHP-31-4704" class="indexterm"/></p><p>The main advantage of thread-local storage is that it is much simpler to use than
                thread-specific data. To create a thread-local variable, we simply include the
                    <code class="literal">__thread</code> specifier in the declaration of a
                global or static variable:</p><a id="I_programlisting31_d1e89378"/><pre class="programlisting">static __thread buf[MAX_ERROR_LEN];</pre><p>Each thread has its own copy of the variables declared with this specifier. The
                variables in a thread’s thread-local storage persist until the thread terminates, at
                which time the storage is automatically deallocated.</p><p>Note the following points about the declaration and use of thread-local
                variables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">__thread</code> keyword must immediately
                        follow the <code class="literal">static</code> or <code class="literal">extern</code> keyword, if either of these is
                        specified in the variable’s declaration.</p></li><li class="listitem"><p>The declaration of a thread-local variable can include an initializer, in
                        the same manner as a normal global or static variable declaration.</p></li><li class="listitem"><p>The C address (<code class="literal">&amp;</code>) operator can
                        be used to obtain the address of a thread-local variable.</p></li></ul></div><p>Thread-local storage requires support from the kernel (provided in Linux 2.6), the
                Pthreads implementation (provided in NPTL), and the C compiler (provided on x86-32
                with <span class="emphasis"><em>gcc</em></span> 3.3 and later).</p><p><a class="xref" href="ch31.html#a_thread-safe_implementation_of_stre" title="Example 31-4. A thread-safe implementation of strerror() using thread-local storage">Example 31-4</a> shows a thread-safe
                implementation of <span class="emphasis"><em>strerror()</em></span> using thread-local storage. If we
                compile and link our test program (<a class="xref" href="ch31.html#calling_strerror_open_parenthesis_close" title="Example 31-2. Calling strerror() from two different threads">Example 31-2</a>) with this version of
                    <span class="emphasis"><em>strerror()</em></span> to create an executable file, <code class="literal">strerror_test_tls</code>, then we see the following results
                when running the program:</p><a id="I_programlisting31_d1e89425"/><pre class="programlisting">$ <strong class="userinput"><code>./strerror_test_tls</code></strong>
Main thread has called strerror()
Other thread about to call strerror()
Other thread: str (0x40376ab0) = Operation not permitted
Main thread:  str (0x40175080) = Invalid argument</pre><div class="example"><a id="a_thread-safe_implementation_of_stre"/><div class="example-title">Example 31-4. A thread-safe implementation of <span class="emphasis"><em>strerror()</em></span> using
                    thread-local storage</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>threads/strerror_tls.c</code></strong>
#define _GNU_SOURCE                 /* Get '_sys_nerr' and '_sys_errlist'
                                       declarations from &lt;stdio.h&gt; */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;           /* Get declaration of strerror() */
#include &lt;pthread.h&gt;

#define MAX_ERROR_LEN 256           /* Maximum length of string in per-thread
                                       buffer returned by strerror() */

static __thread char buf[MAX_ERROR_LEN];
                                    /* Thread-local return buffer */

char *
strerror(int err)
{
    if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) {
        snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
    } else {
        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);
        buf[MAX_ERROR_LEN - 1] = '\0';          /* Ensure null termination */
    }

    return buf;
}
     <strong class="userinput"><code>threads/strerror_tls.c</code></strong></pre></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id30">Summary</h2></div></div></div><p>A function is said to be thread-safe if it can safely be invoked from multiple
                threads at the same time. The usual reason a function is not thread-safe is that it
                makes use of global or static variables. One way to render a non-thread-safe
                function safe in a multithreaded application is to guard all calls to the function
                with a mutex lock. This approach suffers the problem that it reduces concurrency,
                because only one thread can be in the function at any time. An approach that allows
                greater concurrency is to add mutex locks around just those parts of the function
                that manipulate shared variables (the critical sections).<a id="IDX-CHP-31-4705" class="indexterm"/></p><p>Mutexes can be used to render most functions thread-safe, but they carry a
                performance penalty because there is a cost to locking and unlocking a mutex. By
                avoiding the use of global and static variables, a reentrant function achieves
                thread-safety without the use of mutexes.</p><p>Most of the functions specified in SUSv3 are required to be thread-safe. SUSv3
                also lists a small set of functions that are not required to be thread-safe.
                Typically, these are functions that employ static storage to return information to
                the caller or to maintain information between successive calls. By definition, such
                functions are not reentrant, and mutexes can’t be used to make them thread-safe. We
                considered two roughly equivalent coding techniques—thread-specific data and
                thread-local storage—that can be used to render an unsafe function thread-safe
                without needing to change its interface. Both of these techniques allow a function
                to allocate persistent, per-thread storage.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id39"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id40">Further information</h4></div></div></div><p>Refer to the sources of further information listed in <a class="xref" href="ch29.html#summary-id28" title="Summary">Summary</a>.</p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id20">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Implement a function, <span class="emphasis"><em>one_time_init(control, init)</em></span>,
                        that performs the equivalent of <span class="emphasis"><em>pthread_once()</em></span>. The
                            <span class="emphasis"><em>control</em></span> argument should be a pointer to a
                        statically allocated structure containing a Boolean variable and a mutex.
                        The Boolean variable indicates whether the function
                            <span class="emphasis"><em>init</em></span> has already been called, and the mutex
                        controls access to that variable. To keep the implementation simple, you can
                        ignore possibilities such as <span class="emphasis"><em>init()</em></span> failing or being
                        canceled when first called from a thread (i.e., it is not necessary to
                        devise a scheme whereby, if such an event occurs, the next thread that calls
                            <span class="emphasis"><em>one_time_init()</em></span> reattempts the call to
                            <span class="emphasis"><em>init()</em></span>).</p></li><li class="listitem"><p>Use thread-specific data to write thread-safe versions of
                            <span class="emphasis"><em>dirname()</em></span> and <span class="emphasis"><em>basename()</em></span>
                            (<a class="xref" href="ch18.html#parsing_pathname_strings_colon_dirname_o" title="Parsing Pathname Strings: dirname() and basename()">Parsing Pathname Strings: <span class="emphasis"><em>dirname()</em></span> and
                    <span class="emphasis"><em>basename()</em></span></a>).</p></li></ol></div></div></section></body></html>
