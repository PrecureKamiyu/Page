<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos126872" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_29"><span class="bold">2. Getting Started with the Kernel</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos127048"> </div>
<p class="calibre_2">In this chapter, we introduce some of the basics of the Linux kernel: where to get its source, how to compile it, and how to install the new kernel. We then go over the differences between the kernel and user-space programs and common programming constructs used in the kernel. Although the kernel certainly is unique in many ways, at the end of the day it is little different from any other large software project.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos127565"> </div>
<h3 class="calibre_21"><span class="bold">Obtaining the Kernel Source</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The current Linux source code is always available in both a complete <em class="calibre4">tarball</em> (an archive created with the <em class="calibre4">tar</em> command) and an incremental patch from the official home of the Linux kernel, <a href="http://www.kernel.org">http://www.kernel.org</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Unless you have a specific reason to work with an older version of the Linux source, you <em class="calibre4">always</em> want the latest code. The repository at <a href="http://kernel.org">kernel.org</a> is the place to get it, along with additional patches from a number of leading kernel developers.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos128346"> </div>
<h4 class="calibre_27"><span class="calibre3">Using Git</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Over the last couple of years, the kernel hackers, led by Linus himself, have begun using a new version control system to manage the Linux kernel source. Linus created this system, called <em class="calibre4">Git</em>, with speed in mind. Unlike traditional systems such as <em class="calibre4">CVS</em>, Git is distributed, and its usage and workflow is consequently unfamiliar to many developers. I strongly recommend using Git to download and manage the Linux kernel source.</p><div class="calibre_3"> </div>
<p class="calibre_2">You can use Git to obtain a copy of the latest “pushed” version of Linus’s tree:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">When checked out, you can update your tree to Linus’s latest:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git pull</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">With these two commands, you can obtain and subsequently keep up to date with the official kernel tree. To commit and manage your own changes, see <a href="index_split_029.html#filepos1300073">Chapter 20</a>, “Patches, Hacking, and the Community.” <a id="filepos129751"></a>A complete discussion of Git is outside the scope of this book; many online resources provide excellent guides.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos129913"> </div>
<h4 class="calibre_27"><span class="calibre3">Installing the Kernel Source</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The kernel tarball is distributed in both GNU zip (gzip) and bzip2 format. Bzip2 is the default and preferred format because it generally compresses quite a bit better than gzip. The Linux kernel tarball in bzip2 format is named <code class="calibre6"><span class="calibre7">linux-</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">x</span></code></em><code class="calibre6"><span class="calibre7">.</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">y</span></code></em><code class="calibre6"><span class="calibre7">.</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">z</span></code></em><code class="calibre6"><span class="calibre7">.tar.bz2</span></code>, where <em class="calibre4"><code class="calibre6"><span class="calibre7">x.y.z</span></code></em> is the version of that particular release of the kernel source. After downloading the source, uncompressing and untarring it is simple. If your tarball is compressed with bzip2, run</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ tar xvjf linux-x.y.z.tar.bz2</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If it is compressed with GNU zip, run</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ tar xvzf linux-x.y.z.tar.gz</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This uncompresses and untars the source to the directory <code class="calibre6"><span class="calibre7">linux-x.y.z</span></code>. If you use git to obtain and manage the kernel source, you do not need to download the tarball. Just run the <em class="calibre4">git clone</em> command as described and git downloads and unpacks the latest source.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Where to Install and Hack on the Source</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">The kernel source is typically installed in <code class="calibre6"><span class="calibre7">/usr/src/linux</span></code>. You should not use this source tree for development because the kernel version against which your C library is compiled is often linked to this tree. Moreover, you should not require root in order to make changes to the kernel—instead, work out of your home directory and use root only to install new kernels. Even when installing a new kernel, <code class="calibre6"><span class="calibre7">/usr/src/linux</span></code> should remain untouched.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos132439"> </div>
<h4 class="calibre_27"><span class="calibre3">Using Patches</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Throughout the Linux kernel community, patches are the <em class="calibre4">lingua franca</em> of communication. You will distribute your code changes in patches and receive code from others as patches. <em class="calibre4">Incremental patches</em> provide an easy way to move from one kernel tree to the next. Instead of downloading each large tarball of the kernel source, you can simply apply an incremental patch to go from one version to the next. This saves everyone bandwidth and you time. To apply an incremental patch, from <em class="calibre4">inside</em> your kernel source tree, simply run</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ patch –p1 &lt; ../patch-x.y.z</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Generally, a patch to a given version of the kernel is applied against the previous version.</p><div class="calibre_3"> </div>
<p class="calibre_2">Generating and applying patches is discussed in much more depth in later chapters.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos133571"> </div>
<h3 class="calibre_21"><span class="bold">The Kernel Source Tree</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The kernel source tree is divided into a number of directories, most of which contain many more subdirectories. The directories in the root of the source tree, along with their descriptions, are listed in <a href="#filepos134040">Table 2.1</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos133989"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos134040"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 2.1. Directories in the Root of the Kernel Source Tree</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00005.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">A number of files in the root of the source tree deserve mention. The file <code class="calibre6"><span class="calibre7">COPYING</span></code> is the kernel license (the GNU GPL v2). <code class="calibre6"><span class="calibre7">CREDITS</span></code> is a listing of developers with more than a trivial amount of code in the kernel. <code class="calibre6"><span class="calibre7">MAINTAINERS</span></code> lists the names of the individuals who maintain subsystems and drivers in the kernel. <code class="calibre6"><span class="calibre7">Makefile</span></code> is the base kernel Makefile.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos134889"> </div>
<h3 class="calibre_21"><span class="bold">Building the Kernel</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Building the kernel is easy. It is surprisingly easier than compiling and installing other system-level components, such as glibc. The 2.6 kernel series introduced a new configuration and build system, which made the job even easier and is a welcome improvement over earlier releases.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos135346"> </div>
<h4 class="calibre_27"><span class="calibre3">Configuring the Kernel</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos135470"> </div>
<p class="calibre_2">Because the Linux source code is available, it follows that you can configure and custom tailor it before compiling. Indeed, it is possible to compile support into your kernel for only the specific features and drivers you want. Configuring the kernel is a required step before building it. Because the kernel offers myriad features and supports a varied basket of hardware, there is a <em class="calibre4">lot</em> to configure. Kernel configuration is controlled by configuration options, which are prefixed by <code class="calibre6"><span class="calibre7">CONFIG</span></code> in the form <code class="calibre6"><span class="calibre7">CONFIG_FEATURE</span></code>. For example, symmetrical multiprocessing (SMP) is controlled by the configuration option <code class="calibre6"><span class="calibre7">CONFIG_SMP</span></code>. If this option is set, SMP is enabled; if unset, SMP is disabled. The configure options are used both to decide which files to build and to manipulate code via preprocessor directives.</p><div class="calibre_3"> </div>
<p class="calibre_2">Configuration options that control the build process are either <em class="calibre4">Booleans</em> or <em class="calibre4">tristates</em>. A Boolean option is either <em class="calibre4">yes</em> or <em class="calibre4">no</em>. Kernel features, such as <code class="calibre6"><span class="calibre7">CONFIG_PREEMPT</span></code>, are usually Booleans. A tristate option is one of <em class="calibre4">yes</em>, <em class="calibre4">no</em>, or <em class="calibre4">module</em>. The <em class="calibre4">module</em> setting represents a configuration option that is set but is to be compiled as a module (that is, a separate dynamically loadable object). In the case of tristates, a <em class="calibre4">yes</em> option explicitly means to compile the code into the main kernel image and not as a module. Drivers are usually represented by tristates.</p><div class="calibre_3"> </div>
<p class="calibre_2">Configuration options can also be strings or integers. These options do not control the build process but instead specify values that kernel source can access as a preprocessor macro. For example, a configuration option can specify the size of a statically allocated array.</p><div class="calibre_3"> </div>
<p class="calibre_2">Vendor kernels, such as those provided by Canonical for Ubuntu or Red Hat for Fedora, are precompiled as part of the distribution. Such kernels typically enable a good cross section of the needed kernel features and compile nearly all the drivers as modules. This provides for a great base kernel with support for a wide range of hardware as separate modules. For better or worse, as a kernel hacker, you need to compile your own kernels and learn what modules to include on your own.</p><div class="calibre_3"> </div>
<p class="calibre_2">Thankfully, the kernel provides multiple tools to facilitate configuration. The simplest tool is a text-based command-line utility:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make config</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This utility goes through each option, one by one, and asks the user to interactively select <em class="calibre4">yes</em>, <em class="calibre4">no</em>, or (for tristates) <em class="calibre4">module</em>. Because this takes a <em class="calibre4">long</em> time, unless you are paid by the hour, you should use an ncurses-based graphical utility:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make menuconfig</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Or a gtk+-based graphical utility:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make gconfig</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">These three utilities divide the various configuration options into categories, such as “Processor Type and Features.” You can move through the categories, view the kernel options, and of course change their values.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos139303"></a>This command creates a configuration based on the defaults for your architecture:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make defconfig</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Although these defaults are somewhat arbitrary (on i386, they are rumored to be Linus’s configuration!), they provide a good start if you have never configured the kernel. To get off and running quickly, run this command and then go back and ensure that configuration options for your hardware are enabled.</p><div class="calibre_3"> </div>
<p class="calibre_2">The configuration options are stored in the root of the kernel source tree in a file named <code class="calibre6"><span class="calibre7">.config</span></code>. You may find it easier (as most of the kernel developers do) to just edit this file directly. It is quite easy to search for and change the value of the configuration options. After making changes to your configuration file, or when using an existing configuration file on a new kernel tree, you can validate and update the configuration:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make oldconfig</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">You should always run this before building a kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2">The configuration option <code class="calibre6"><span class="calibre7">CONFIG_IKCONFIG_PROC</span></code> places the complete kernel configuration file, compressed, at <code class="calibre6"><span class="calibre7">/proc/config.gz</span></code>. This makes it easy to clone your current configuration when building a new kernel. If your current kernel has this option enabled, you can copy the configuration out of <code class="calibre6"><span class="calibre7">/proc</span></code> and use it to build a new kernel:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ zcat /proc/config.gz &gt; .config<br class="calibre1"/>$ make oldconfig</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">After the kernel configuration is set—however you do it—you can build it with a single command:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Unlike kernels before 2.6, you no longer need to run <code class="calibre6"><span class="calibre7">make dep</span></code> before building the kernel—the dependency tree is maintained automatically. You also do not need to specify a specific build type, such as bzImage, or build modules separately, as you did in old versions. The default Makefile rule will handle everything.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos141986"> </div>
<h4 class="calibre_27"><span class="calibre3">Minimizing Build Noise</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">A trick to minimize build noise, but still see warnings and errors, is to redirect the output from <code class="calibre6"><span class="calibre7">make</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make &gt; ../detritus</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If you need to see the build output, you can read the file. Because the warnings and errors are output to standard error, however, you normally do not need to. In fact, I just do</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make &gt; /dev/null</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This redirects all the worthless output to that big, ominous sink of no return, <code class="calibre6"><span class="calibre7">/dev/null</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos142955"> </div>
<h4 class="calibre_27"><span class="calibre3">Spawning Multiple Build Jobs</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos143085"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">make</span></code> program provides a feature to split the build process into a number of parallel <em class="calibre4">jobs</em>. Each of these jobs then runs separately and concurrently, significantly speeding up the build process on multiprocessing systems. It also improves processor utilization because the time to build a large source tree includes significant time in I/O wait (time in which the process is idle waiting for an I/O request to complete).</p><div class="calibre_3"> </div>
<p class="calibre_2">By default, <code class="calibre6"><span class="calibre7">make</span></code> spawns only a single job because Makefiles all too often have incorrect dependency information. With incorrect dependencies, multiple jobs can step on each other’s toes, resulting in errors in the build process. The kernel’s Makefiles have correct dependency information, so spawning multiple jobs does not result in failures. To build the kernel with multiple make jobs, use</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make -jn</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Here, <em class="calibre4"><code class="calibre6"><span class="calibre7">n</span></code></em> is the number of jobs to spawn. Usual practice is to spawn one or two jobs per processor. For example, on a 16-core machine, you might do</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ make -j32 &gt; /dev/null</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Using utilities such as the excellent <code class="calibre6"><span class="calibre7">distcc</span></code> or <code class="calibre6"><span class="calibre7">ccache</span></code> can also dramatically improve kernel build time.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos144850"> </div>
<h4 class="calibre_27"><span class="calibre3">Installing the New Kernel</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">After the kernel is built, you need to install it. How it is installed is architecture- and boot loader-dependent—consult the directions for your boot loader on where to copy the kernel image and how to set it up to boot. Always keep a known-safe kernel or two around in case your new kernel has problems!</p><div class="calibre_3"> </div>
<p class="calibre_2">As an example, on an x86 system using grub, you would copy <code class="calibre6"><span class="calibre7">arch/i386/boot/bzImage</span></code> to <code class="calibre6"><span class="calibre7">/boot</span></code>, name it something like <code class="calibre6"><span class="calibre7">vmlinuz-</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">version</span></code></em>, and edit <code class="calibre6"><span class="calibre7">/boot/grub/grub.conf</span></code>, adding a new entry for the new kernel. Systems using LILO to boot would instead edit <code class="calibre6"><span class="calibre7">/etc/lilo.conf</span></code> and then rerun <code class="calibre6"><span class="calibre7">lilo</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Installing modules, thankfully, is automated and architecture-independent. As root, simply run</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">% make modules_install</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This installs all the compiled modules to their correct home under <code class="calibre6"><span class="calibre7">/lib/modules</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The build process also creates the file <code class="calibre6"><span class="calibre7">System.map</span></code> in the root of the kernel source tree. It contains a symbol lookup table, mapping kernel symbols to their start addresses. This is used during debugging to translate memory addresses to function and variable names.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos146714"> </div>
<h3 class="calibre_21"><span class="bold">A Beast of a Different Nature</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The Linux kernel has several unique attributes as compared to a normal user-space application. Although these differences do not necessarily make developing kernel code <em class="calibre4">harder</em> than developing user-space code, they certainly make doing so <em class="calibre4">different</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos147163"></a>These characteristics make the kernel a beast of a different nature. Some of the usual rules are bent; other rules are entirely new. Although some of the differences are obvious (we all know the kernel can do anything it wants), others are not so obvious. The most important of these differences are</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The kernel has access to neither the C library nor the standard C headers.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The kernel is coded in GNU C.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The kernel lacks the memory protection afforded to user-space.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The kernel cannot easily execute floating-point operations.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The kernel has a small per-process fixed-size stack.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Because the kernel has asynchronous interrupts, is preemptive, and supports SMP, synchronization and concurrency are major concerns within the kernel.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Portability is important.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Let’s briefly look at each of these issues because all kernel developers must keep them in mind.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos148719"> </div>
<h4 class="calibre_27"><span class="calibre3">No libc or Standard Headers</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Unlike a user-space application, the kernel is not linked against the standard C library—or any other library, for that matter. There are multiple reasons for this, including a chicken-and-the-egg situation, but the primary reason is speed and size. The full C library—or even a decent subset of it—is too large and too inefficient for the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2">Do not fret: Many of the usual libc functions are implemented inside the kernel. For example, the common string manipulation functions are in <code class="calibre6"><span class="calibre7">lib/string.c</span></code>. Just include the header file <code class="calibre6"><span class="calibre7">&lt;linux/string.h&gt;</span></code> and have at them.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Header Files</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">When I talk about header files in this book, I am referring to the kernel header files that are part of the kernel source tree. Kernel source files cannot include outside headers, just as they cannot use outside libraries.</p><div class="calibre_3"> </div>
<p class="calibre_2">The base files are located in the <code class="calibre6"><span class="calibre7">include/</span></code> directory in the root of the kernel source tree. For example, the header file <code class="calibre6"><span class="calibre7">&lt;linux/inotify.h&gt;</span></code> is located at <code class="calibre6"><span class="calibre7">include/linux/inotify.h</span></code> in the kernel source tree.</p><div class="calibre_3"> </div>
<p class="calibre_2">A set of architecture-specific header files are located in <code class="calibre6"><span class="calibre7">arch/&lt;architecture&gt;/include/asm</span></code> in the kernel source tree. For example, if compiling for the x86 architecture, your architecture-specific headers are in <code class="calibre6"><span class="calibre7">arch/x86/include/asm</span></code>. Source code includes these headers via just the <code class="calibre6"><span class="calibre7">asm/</span></code> prefix, for example <code class="calibre6"><span class="calibre7">&lt;asm/ioctl.h&gt;</span></code>.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2">Of the missing functions, the most familiar is <code class="calibre6"><span class="calibre7">printf()</span></code>. The kernel does not have access to <code class="calibre6"><span class="calibre7">printf()</span></code>, but it does provide <code class="calibre6"><span class="calibre7">printk()</span></code>, which works pretty much the same as its more familiar cousin. The <code class="calibre6"><span class="calibre7">printk()</span></code> function copies the formatted string into the kernel log buffer, which is normally read by the syslog program. Usage is similar to <code class="calibre6"><span class="calibre7">printf()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos151627"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">printk("Hello world! A string '%s' and an integer '%d'\n", str, i);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">One notable difference between <code class="calibre6"><span class="calibre7">printf()</span></code> and <code class="calibre6"><span class="calibre7">printk()</span></code> is that <code class="calibre6"><span class="calibre7">printk()</span></code> enables you to specify a priority flag. This flag is used by <code class="calibre6"><span class="calibre7">syslogd</span></code> to decide where to display kernel messages. Here is an example of these priorities:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">printk(KERN_ERR "this is an error!\n");</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Note there is no comma between <code class="calibre6"><span class="calibre7">KERN_ERR</span></code> and the printed message. This is intentional; the priority flag is a preprocessor-define representing a string literal, which is concatenated onto the printed message during compilation. We use <code class="calibre6"><span class="calibre7">printk()</span></code> throughout this book.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos152788"> </div>
<h4 class="calibre_27"><span class="calibre3">GNU C</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Like any self-respecting Unix kernel, the Linux kernel is programmed in C. Perhaps surprisingly, the kernel is not programmed in strict ANSI C. Instead, where applicable, the kernel developers make use of various language extensions available in <em class="calibre4">gcc</em> (the GNU Compiler Collection, which contains the C compiler used to compile the kernel and most everything else written in C on a Linux system).</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel developers use both ISO C99<sup class="calibre8"><a id="filepos153392" href="#filepos154252">1</a></sup> and GNU C extensions to the C language. These changes wed the Linux kernel to gcc, although recently one other compiler, the Intel C compiler, has sufficiently supported enough gcc features that it, too, can compile the Linux kernel. The earliest supported gcc version is 3.2; gcc version 4.4 or later is recommended. The ISO C99 extensions that the kernel uses are nothing special and, because C99 is an official revision of the C language, are slowly cropping up in a lot of other code. The more unfamiliar deviations from standard ANSI C are those provided by GNU C. Let’s look at some of the more interesting extensions that you will see in the kernel; these changes differentiate kernel code from other projects with which you might be familiar.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos154252" href="#filepos153392">1</a></sup>
<em class="calibre4">ISO C99 is the latest major revision to the ISO C standard. C99 adds numerous enhancements to the previous major revision, ISO C90, including designated initializers, variable length arrays, C++-style comments, and the <code class="calibre6"><span class="calibre7">long long</span></code> and <code class="calibre6"><span class="calibre7">complex</span></code> types. The Linux kernel, however, employs only a subset of C99 features.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos154747"> </div>
<h5 class="calibre_29"><span class="calibre3">Inline Functions</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">Both C99 and GNU C support <em class="calibre4">inline functions</em>. An inline function is, as its name suggests, inserted inline into each function call site. This eliminates the overhead of function invocation and return (register saving and restore) and allows for potentially greater optimization as the compiler can optimize both the caller and the called function as one. As a downside (nothing in life is free), code size increases because the contents of the function are copied into all the callers, which increases memory consumption and instruction cache footprint. Kernel developers use inline functions for small time-critical functions. <a id="filepos155501"></a>Making large functions inline, especially those used more than once or that are not exceedingly time critical, is frowned upon.</p><div class="calibre_3"> </div>
<p class="calibre_2">An inline function is declared when the keywords <code class="calibre6"><span class="calibre7">static</span></code> and <code class="calibre6"><span class="calibre7">inline</span></code> are used as part of the function definition. For example</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static inline void wolf(unsigned long tail_size)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The function declaration must precede any usage, or else the compiler cannot make the function inline. Common practice is to place inline functions in header files. Because they are marked <code class="calibre6"><span class="calibre7">static</span></code>, an exported function is not created. If an inline function is used by only one file, it can instead be placed toward the top of just that file.</p><div class="calibre_3"> </div>
<p class="calibre_2">In the kernel, using inline functions is preferred over complicated macros for reasons of type safety and readability.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos156669"> </div>
<h5 class="calibre_29"><span class="calibre3">Inline Assembly</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The gcc C compiler enables the embedding of assembly instructions in otherwise normal C functions. This feature, of course, is used in only those parts of the kernel that are unique to a given system architecture.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">asm()</span></code> compiler directive is used to inline assembly code. For example, this inline assembly directive executes the x86 processor’s <code class="calibre6"><span class="calibre7">rdtsc</span></code> instruction, which returns the value of the timestamp (<code class="calibre6"><span class="calibre7">tsc</span></code>) register:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">unsigned int low, high;<br class="calibre1"/>asm volatile("rdtsc" : "=a" (low), "=d" (high));<br class="calibre1"/>/* low and high now contain the lower and upper 32-bits of the 64-bit tsc */</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The Linux kernel is written in a mixture of C and assembly, with assembly relegated to low-level architecture and fast path code. The vast majority of kernel code is programmed in straight C.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos157924"> </div>
<h5 class="calibre_29"><span class="calibre3">Branch Annotation</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The gcc C compiler has a built-in directive that optimizes conditional branches as either very likely taken or very unlikely taken. The compiler uses the directive to appropriately optimize the branch. The kernel wraps the directive in easy-to-use macros, <code class="calibre6"><span class="calibre7">likely()</span></code> and <code class="calibre6"><span class="calibre7">unlikely()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">For example, consider an <code class="calibre6"><span class="calibre7">if</span></code> statement such as the following:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">if (error) {<br class="calibre1"/>        /* ... */<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">To mark this branch as very unlikely taken (that is, likely not taken):</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">/* we predict 'error' is nearly always zero ... */<br class="calibre1"/>if (unlikely(error)) {<br class="calibre1"/>        /* ... */<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos159143"></a>Conversely, to mark a branch as very likely taken:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">/* we predict 'success' is nearly always nonzero ... */<br class="calibre1"/>if (likely(success)) {<br class="calibre1"/>        /* ... */<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">You should only use these directives when the branch direction is overwhelmingly known <em class="calibre4">a priori</em> or when you want to optimize a specific case at the cost of the other case. This is an important point: These directives result in a performance boost when the branch is correctly marked, but a performance <em class="calibre4">loss</em> when the branch is mismarked. A common usage, as shown in these examples, for <code class="calibre6"><span class="calibre7">unlikely()</span></code> and <code class="calibre6"><span class="calibre7">likely()</span></code> is error conditions. As you might expect, <code class="calibre6"><span class="calibre7">unlikely()</span></code> finds much more use in the kernel because <code class="calibre6"><span class="calibre7">if</span></code> statements tend to indicate a special case.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos160256"> </div>
<h4 class="calibre_27"><span class="calibre3">No Memory Protection</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When a user-space application attempts an illegal memory access, the kernel can trap the error, send the <code class="calibre6"><span class="calibre7">SIGSEGV</span></code> signal, and kill the process. If the kernel attempts an illegal memory access, however, the results are less controlled. (After all, who is going to look after the kernel?) Memory violations in the kernel result in an <em class="calibre4">oops</em>, which is a major kernel error. It should go without saying that you must not illegally access memory, such as dereferencing a <code class="calibre6"><span class="calibre7">NULL</span></code> pointer—but within the kernel, the stakes are much higher!</p><div class="calibre_3"> </div>
<p class="calibre_2">Additionally, kernel memory is not pageable. Therefore, every byte of memory you consume is one less byte of available physical memory. Keep that in mind the next time you need to add <em class="calibre4">one more feature</em> to the kernel!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos161315"> </div>
<h4 class="calibre_27"><span class="calibre3">No (Easy) Use of Floating Point</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When a user-space process uses floating-point instructions, the kernel manages the transition from integer to floating point mode. What the kernel has to do when using floating-point instructions varies by architecture, but the kernel normally catches a trap and then initiates the transition from integer to floating point mode.</p><div class="calibre_3"> </div>
<p class="calibre_2">Unlike user-space, the kernel does not have the luxury of seamless support for floating point because it cannot easily trap itself. Using a floating point inside the kernel requires manually saving and restoring the floating point registers, among other possible chores. The short answer is: <em class="calibre4">Don’t do it</em>! Except in the rare cases, no floating-point operations are in the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos162272"> </div>
<h4 class="calibre_27"><span class="calibre3">Small, Fixed-Size Stack</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">User-space can get away with statically allocating many variables on the stack, including huge structures and thousand-element arrays. This behavior is legal because user-space has a large stack that can dynamically grow. (Developers on older, less advanced operating systems—say, DOS—might recall a time when even user-space had a fixed-sized stack.)</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos162811"></a>The kernel stack is neither large nor dynamic; it is small and fixed in size. The exact size of the kernel’s stack varies by architecture. On x86, the stack size is configurable at compile-time and can be either 4KB or 8KB. Historically, the kernel stack is two pages, which generally implies that it is 8KB on 32-bit architectures and 16KB on 64-bit architectures—this size is fixed and absolute. Each process receives its own stack.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel stack is discussed in much greater detail in later chapters.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos163430"> </div>
<h4 class="calibre_27"><span class="calibre3">Synchronization and Concurrency</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The kernel is susceptible to race conditions. Unlike a single-threaded user-space application, a number of properties of the kernel allow for concurrent access of shared resources and thus require synchronization to prevent races. Specifically</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Linux is a preemptive multitasking operating system. Processes are scheduled and rescheduled at the whim of the kernel’s process scheduler. The kernel must synchronize between these tasks.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Linux supports symmetrical multiprocessing (SMP). Therefore, without proper protection, kernel code executing simultaneously on two or more processors can concurrently access the same resource.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Interrupts occur asynchronously with respect to the currently executing code. Therefore, without proper protection, an interrupt can occur in the midst of accessing a resource, and the interrupt handler can then access the same resource.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The Linux kernel is preemptive. Therefore, without protection, kernel code can be preempted in favor of different code that then accesses the same resource.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Typical solutions to race conditions include spinlocks and semaphores. Later chapters provide a thorough discussion of synchronization and concurrency.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos165183"> </div>
<h4 class="calibre_27"><span class="calibre3">Importance of Portability</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Although user-space applications do not <em class="calibre4">have</em> to aim for portability, Linux is a portable operating system and should remain one. This means that architecture-independent C code must correctly compile and run on a wide range of systems, and that architecture-dependent code must be properly segregated in system-specific directories in the kernel source tree.</p><div class="calibre_3"> </div>
<p class="calibre_2">A handful of rules—such as remain endian neutral, be 64-bit clean, do not assume the word or page size, and so on—go a long way. Portability is discussed in depth in a later chapter.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos165973"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">To be sure, the kernel has unique qualities. It enforces its own rules and the stakes, managing the entire system as the kernel does, are certainly higher. That said, the Linux kernel’s complexity and barrier-to-entry is not qualitatively different from any other large software project. The most important step on the road to Linux development is the realization that the kernel is not something to fear. Unfamiliar, sure. Insurmountable? Not at all.</p><div class="calibre_3"> </div>
<p class="calibre_2">This and the previous chapter lay the foundation for the topics we cover through this book’s remaining chapters. In each subsequent chapter, we cover a specific kernel concept or subsystem. Along the way, it is imperative that you read and modify the kernel source. Only through actually reading and experimenting with the code can you ever understand it. The source is freely available—use it!</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_30"></div>
</body></html>
