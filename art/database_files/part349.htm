<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.3  Recovery and Atomicity</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part348.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part350.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">19.3  <span style=" color: #00AEEF;">Recovery and Atomicity</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;line-height: 94%;text-align: justify;">Consider again our simpliﬁed banking system and a transaction <i>T</i><span class="s97">i </span>that transfers $50 from account <i>A </i>to account <i>B</i>, with initial values of <i>A </i>and <i>B </i>being $1000 and $2000, respectively. Suppose that a system crash has occurred during the execution of <i>T</i><span class="s145">i</span>, after <span class="s49">output</span>(<i>B</i><span class="s145">A</span>) has taken place, but before <span class="s49">output</span>(<i>B</i><span class="s145">B</span>) was executed, where <i>B</i><span class="s145">A </span>and <i>B</i><span class="s145">B </span>denote the buﬀer blocks on which <i>A </i>and <i>B </i>reside. Since the memory contents were lost, we do not know the fate of the transaction.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">When the system restarts, the value of <i>A </i>would be $950, while that of <i>B </i>would be</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">$2000, which is clearly inconsistent with the atomicity requirement for transaction <i>T</i><span class="s97">i</span>. Unfortunately, there is no way to ﬁnd out by examining the database state what blocks had been output and what had not before the crash. It is possible that the transaction completed, updating the database on stable storage from an initial state with the values</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">of <i>A </i>and <i>B </i>being $1000 and $1950; it is also possible that the transaction did not aﬀect the stable storage at all, and the values of <i>A </i>and <i>B </i>were $950 and $2000 initially; or that the updated <i>B </i>was output but not the updated <i>A</i>; or that the updated <i>A </i>was output but the updated <i>B </i>was not.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 93%;text-align: justify;">Our goal is to perform either all or no database modiﬁcations made by <i>T</i><span class="s97">i</span>. How- ever, if <i>T</i><span class="s145">i </span>performed multiple database modiﬁcations, several output operations may be required, and a failure may occur after some of these modiﬁcations have been made, but before all of them are made.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To achieve our goal of atomicity, we must ﬁrst output to stable storage informa- tion describing the modiﬁcations, without modifying the database itself. As we shall see, this information can help us ensure that all modiﬁcations performed by commit- ted transactions are reﬂected in the database (perhaps during the course of recovery actions after a crash). We also need to store information about the old value of any item updated by a modiﬁcation in case the transaction performing the modiﬁcation</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">fails (aborts). This information can help us undo the modiﬁcations made by the failed transaction.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The most commonly used technique for recovery is based on log records, and we study <span class="s63">log-based recovery </span>in detail in this chapter. An alternative, called shadow copying, is used by text editors but is not used in database systems; this approach is summarized in Note 19.1 on page 914.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">19.3.1 Log Records</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The most widely used structure for recording database modiﬁcations is the <span class="s63">log</span>. The log is a sequence of <span class="s63">log records</span>, recording all the update activities in the database.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">There are several types of log records. An <span class="s63">update log record </span>describes a single data- base write. It has these ﬁelds:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Transaction identiﬁer</span>, which is the unique identiﬁer of the transaction that per- formed the <span class="s49">write </span>operation.</p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Data-item identiﬁer</span><span class="p">, which is the unique identiﬁer of the data item written. Typi- cally, it is the location on disk of the data item, consisting of the block identiﬁer of the block on which the data item resides and an oﬀset within the block.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: justify;">• <span class="s63">Old value</span><span class="p">, which is the value of the data item prior to the write.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;text-align: justify;">• <span class="s63">New value</span><span class="p">, which is the value that the data item will have after the write.</span></p><p class="s13" style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;line-height: 19pt;text-align: left;"><span class="p">We represent an update log record as </span><span class="s83">&lt;</span>T<span class="s97">i</span><span class="p">, </span>X<span class="s97">j </span><span class="p">, </span>V<span class="s130">1</span><span class="s94">, </span>V<span class="s130">2</span><span class="s83">&gt;</span><span class="p">, indicating that transaction </span>T<span class="s97">i</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: left;">has performed a write on data item <i>X</i><span class="s145">j </span>. <i>X</i><span class="s145">j </span>had value <i>V</i><span class="s98">1</span> before the write and has value</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: left;">V<span class="s98">2</span><span class="p"> after the write. Other special log records exist to record signiﬁcant events during</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">transaction processing, such as the start of a transaction and the commit or abort of a transaction. Among the types of log records are:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s83" style="padding-left: 123pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><span class="s39">• </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">start</span>&gt;<span class="p">. Transaction </span><span class="s13">T</span><span class="s97">i </span><span class="p">has started.</span></p><p class="s83" style="padding-left: 123pt;text-indent: 0pt;line-height: 19pt;text-align: left;"><span class="s39">• </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">commit</span>&gt;<span class="p">. Transaction </span><span class="s13">T</span><span class="s97">i </span><span class="p">has committed.</span></p><p class="s83" style="padding-left: 123pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><span class="s39">• </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt;<span class="p">. Transaction </span><span class="s13">T</span><span class="s97">i </span><span class="p">has aborted.</span></p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We shall introduce several other types of log records later.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Whenever a transaction performs a write, it is essential that the log record for that write be created and added to the log, before the database is modiﬁed. Once a log record exists, we can output the modiﬁcation to the database if that is desirable. Also, we have the ability to <i>undo </i>a modiﬁcation that has already been output to the database. We undo it by using the old-value ﬁeld in log records.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For log records to be useful for recovery from system and disk failures, the log must reside in stable storage. For now, we assume that every log record is written to the end</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="493" height="616" alt="image" src="Image_3060.png"/></span></p><p class="s73" style="padding-left: 59pt;text-indent: 0pt;text-align: center;">Note 19.1 <span class="s146">SHADOW COPIES AND SHADOW PAGING</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 97pt;text-indent: 0pt;text-align: justify;">In the <span class="s63">shadow-copy </span>scheme, a transaction that wants to update the database ﬁrst creates a complete copy of the database. All updates are done on the new database copy, leaving the original copy, the shadow copy, untouched. If at any point the transaction has to be aborted, the system merely deletes the new copy. The old copy of the database has not been aﬀected. The current copy of the database is identiﬁed by a pointer, called db-pointer, which is stored on disk.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: right;">If the transaction partially commits (i.e., executes its ﬁnal statement) it is com- mitted as follows: First, the operating system is asked to make sure that all pages of the new copy of the database have been written out to disk. (Unix systems use the <span class="s95">fsync </span>command for this purpose.) After the operating system has written all the pages to disk, the database system updates the pointer db-pointer to point to the new copy of the database; the new copy then becomes the current copy of the database. The old copy of the database is then deleted. The transaction is said to have been <i>committed </i>at the point where the updated db-pointer is written to disk. The implementation actually depends on the write to db-pointer being atomic; that is, either all its bytes are written or none of its bytes are written. Disk systems provide atomic updates to entire blocks, or at least to a disk sector. In other words, the disk system guarantees that it will update db-pointer atomically, as long as we make sure that db-pointer lies entirely in a single sector, which we can ensure by</p><p style="padding-left: 97pt;text-indent: 0pt;text-align: justify;">storing db-pointer at the beginning of a block.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">Shadow-copy schemes are commonly used by text editors (saving the ﬁle is equivalent to transaction commit, while quitting without saving the ﬁle is equiva- lent to transaction abort). Shadow copying can be used for small databases, but copying a large database would be extremely expensive. A variant of shadow copy- ing, called <span class="s63">shadow paging</span>, reduces copying as follows: the scheme uses a page ta- ble containing pointers to all pages; the page table itself and all updated pages are copied to a new location. Any page which is not updated by a transaction is not copied, but instead the new page table just stores a pointer to the original page. When a transaction commits, it atomically updates the pointer to the page table, which acts as db-pointer to point to the new copy.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">Shadow paging unfortunately does not work well with concurrent transactions and is not widely used in databases.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">of the log on stable storage as soon as it is created. In Section 19.5, we shall see when it is safe to relax this requirement so as to reduce the overhead imposed by logging. Observe that the log contains a complete record of all database activity. As a result, the volume of data stored in the log may become unreasonably large. In Section 19.3.6, we shall show when it is safe to erase log information.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">19.3.2 Database Modification</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">As we noted earlier, a transaction creates a log record prior to modifying the database. The log records allow the system to undo changes made by a transaction in the event that the transaction must be aborted; they allow the system also to redo changes made by a transaction if the transaction has committed but the system crashed before those changes could be stored in the database on disk. In order for us to understand the role of these log records in recovery, we need to consider the steps a transaction takes in modifying a data item:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: left;">1. <span class="p">The transaction performs some computations in its own private part of main memory.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: left;">2. <span class="p">The transaction modiﬁes the data block in the disk buﬀer in main memory hold- ing the data item.</span></p><p style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: left;"><span class="s63">3. </span>The database system executes the <span class="s49">output </span>operation that writes the data block to disk.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We say a transaction <i>modifies the database </i>if it performs an update on a disk buﬀer, or on the disk itself; updates to the private part of main memory do not count as database modiﬁcations. If a transaction does not modify the database until it has com- mitted, it is said to use the <span class="s63">deferred-modiﬁcation </span>technique. If database modiﬁcations occur while the transaction is still active, the transaction is said to use the <span class="s63">immediate- modiﬁcation </span>technique. Deferred modiﬁcation has the overhead that transactions need to make local copies of all updated data items; further, if a transaction reads a data item that it has updated, it must read the value from its local copy.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The recovery algorithms we describe in this chapter support immediate modiﬁca- tion. As described, they work correctly even with deferred modiﬁcation, but they can be optimized to reduce overhead when used with deferred modiﬁcation; we leave details as an exercise.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">A recovery algorithm must take into account a variety of factors, including:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The possibility that a transaction may have committed although some of its database modiﬁcations exist only in the disk buﬀer in main memory and not in the database on disk.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The possibility that a transaction may have modiﬁed the database while in the active state and, as a result of a subsequent failure, may need to abort.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Because all database modiﬁcations must be preceded by the creation of a log record, the system has available both the old value prior to the modiﬁcation of the data item and the new value that is to be written for the data item. This allows the system to perform <i>undo </i>and <i>redo </i>operations as appropriate.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">The </span><span class="s63">undo </span><span class="p">operation usinga log record sets the data item speciﬁed in the log record to the old value contained in the log record.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">The </span><span class="s63">redo </span><span class="p">operation using a log record sets the data item speciﬁed in the log record to the new value contained in the log record.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">19.3.3 Concurrency Control and Recovery</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">If the concurrency control scheme allows a data item <i>X </i>that has been modiﬁed by a transaction <i>T</i><span class="s98">1</span> to be further modiﬁed by another transaction <i>T</i><span class="s98">2</span> before <i>T</i><span class="s98">1</span> commits, then undoing the eﬀects of <i>T</i><span class="s98">1</span> by restoring the old value of <i>X </i>(before <i>T</i><span class="s98">1</span> updated <i>X </i>) would also undo the eﬀects of <i>T</i><span class="s98">2</span>. To avoid such situations, recovery algorithms usually require that if a data item has been modiﬁed by a transaction, no other transaction can modify the data item until the ﬁrst transaction commits or aborts.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">This requirement can be ensured by acquiring an exclusive lock on any updated data item and holding the lock until the transaction commits; in other words, by using strict two-phase locking. Snapshot isolation and validation-based concurrency-control techniques also acquire exclusive locks on data items at the time of validation, before modifying the data items, and hold the locks until the transaction is committed; as a result the above requirement is satisﬁed even by these concurrency control protocols.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We discuss in Section 19.8 how the above requirement can be relaxed in certain cases.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When either snapshot isolation or validation is used for concurrency control, database updates of a transaction are (conceptually) deferred until the transaction is partially committed; the deferred-modiﬁcation technique is a natural ﬁt with these con- currency control schemes. However, it is worth noting that some implementations of snapshot isolation use immediate modiﬁcation but provide a logical snapshot on de- mand: when a transaction needs to read an item that a concurrent transaction has up- dated, a copy of the (already updated) item is made, and updates made by concurrent transactions are rolled back on the copy of the item. Similarly, immediate modiﬁcation of the database is a natural ﬁt with two-phase locking, but deferred modiﬁcation can also be used with two-phase locking.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="padding-left: 229pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><span class="s175">0</span> start&gt;</p><p class="s42" style="padding-left: 229pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><span class="s175">0</span> , <i>A</i>, 1000, 950&gt;</p><p class="s42" style="padding-left: 229pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><span class="s175">0</span> , <i>B</i>, 2000, 2050&gt;</p><p class="s42" style="padding-left: 229pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><span class="s175">0</span> commit&gt;</p><p class="s42" style="padding-left: 229pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><span class="s175">1</span> start&gt;</p><p class="s42" style="padding-left: 229pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><span class="s175">1</span> , <i>C</i>, 700, 600&gt;</p><p class="s42" style="padding-left: 229pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><span class="s175">1</span> commit&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s74" style="padding-left: 59pt;text-indent: 0pt;text-align: center;"><span class="s73">Figure 19.2 </span>Portion of the system log corresponding to <span class="s425">T</span><span class="s116">0</span> and <span class="s425">T</span><span class="s116">1</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">19.3.4 Transaction Commit</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We say that a transaction has <span class="s63">committed </span>when its commit log record, which is the last log record of the transaction, has been output to stable storage; at that point all earlier log records have already been output to stable storage. Thus, there is enough information in the log to ensure that even if there is a system crash, the updates of the</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 78%;text-align: justify;">transaction can be redone. If a system crash occurs before a log record <span class="s83">&lt;</span><i>T</i><span class="s97">i </span><span class="s49">commit</span><span class="s83">&gt; </span>is output to stable storage, transaction <i>T</i><span class="s97">i </span>will be rolled back. Thus, the output of the block containing the <span class="s49">commit </span>log record is the single atomic action that results in a</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">transaction getting committed.<span class="s76">1</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">With most log-based recovery techniques, including the ones we describe in this chapter, blocks containing the data items modiﬁed by a transaction do not have to be output to stable storage when the transaction commits but can be output some time later. We discuss this issue further in Section 19.5.2.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">19.3.5 Using the Log to Redo and Undo Transactions</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We now provide an overview of how the log can be used to recover from a system crash and to roll back transactions during normal operation. However, we postpone details of the procedures for failure recovery and rollback to Section 19.4.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Consider our simpliﬁed banking system. Let <i>T</i><span class="s98">0</span> be a transaction that transfers $50 from account <i>A </i>to account <i>B</i>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 271pt;text-indent: 0pt;text-align: left;"><i>T</i><span class="s98">0</span>: <span class="s49">read</span>(<i>A</i>);</p><p class="s13" style="padding-left: 144pt;text-indent: 0pt;text-align: center;">A <span class="p">:= </span>A <span class="s15">− </span><span class="p">50;</span></p><p style="padding-left: 290pt;text-indent: 0pt;text-align: left;"><span class="s49">write</span>(<i>A</i>);</p><p style="padding-left: 290pt;text-indent: 0pt;text-align: left;"><span class="s49">read</span>(<i>B</i>);</p><p class="s13" style="padding-left: 143pt;text-indent: 0pt;text-align: center;">B <span class="p">:= </span>B <span class="p">+ 50;</span></p><p style="padding-left: 290pt;text-indent: 0pt;text-align: left;"><span class="s49">write</span>(<i>B</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">Let <i>T</i><span class="s98">1</span> be a transaction that withdraws $100 from account <i>C</i>:</p><p style="padding-top: 12pt;padding-left: 268pt;text-indent: 0pt;text-align: left;"><i>T</i><span class="s98">1</span>: <span class="s49">read</span>(<i>C</i>);</p><p class="s13" style="padding-left: 144pt;text-indent: 0pt;text-align: center;">C <span class="p">:= </span>C <span class="s15">− </span><span class="p">100;</span></p><p style="padding-left: 287pt;text-indent: 0pt;text-align: left;"><span class="s49">write</span>(<i>C</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">The portion of the log containing the relevant information concerning these two trans- actions appears in Figure 19.2.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: left;">Figure 19.3 shows one possible order in which the actual outputs took place in both the database system and the log as a result of the execution of <i>T</i><span class="s98">0</span> and <i>T</i><span class="s98">1</span>.<span class="s76">2</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_3061.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">1<span class="s78">The output of a block can be made atomic by techniques for dealing with data-transfer failure, as described in Section 19.2.1.</span></p><p class="s77" style="padding-left: 119pt;text-indent: 0pt;line-height: 9pt;text-align: left;">2<span class="s78">Notice that this order could not be obtained using the deferred-modiﬁcation technique, because the database is mod-</span></p><p class="s80" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">iﬁed by <i>T</i><span class="s231">0</span> before it commits, and likewise for <i>T</i><span class="s231">1</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s257" style="padding-left: 79pt;text-indent: 0pt;text-align: center;">Log       Database</p><p class="s446" style="padding-left: 203pt;text-indent: 0pt;text-align: left;">&lt;<span class="s69">T</span><span class="s175">0</span><span class="s42"> </span>start&gt;</p><p class="s69" style="padding-left: 203pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s175">0</span><span class="s42"> , </span>A<span class="s42">, 1000, 950</span><span class="s446">&gt;</span></p><p class="s69" style="padding-left: 203pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s175">0</span><span class="s42"> , </span>B<span class="s42">, 2000, 2050</span><span class="s446">&gt;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s446" style="padding-left: 203pt;text-indent: 0pt;text-align: left;">&lt;<span class="s69">T</span><span class="s175">0</span><span class="s42"> </span>commit&gt;</p><p class="s446" style="padding-left: 203pt;text-indent: 0pt;text-align: left;">&lt;<span class="s69">T</span><span class="s175">1</span><span class="s42"> </span>start&gt;</p><p class="s69" style="padding-left: 203pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s175">1</span><span class="s42"> , </span>C<span class="s42">, 700, 600</span><span class="s446">&gt;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s446" style="padding-left: 203pt;text-indent: 0pt;text-align: left;">&lt;<span class="s69">T</span><span class="s175">1</span><span class="s42"> </span>commit&gt;</p><p class="s69" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">A <span class="s42">= 950</span></p><p class="s69" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">B <span class="s42">= 2050</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">C <span class="s42">= 600</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s74" style="padding-top: 4pt;padding-left: 111pt;text-indent: 0pt;text-align: justify;"><span class="s73">Figure 19.3 </span>State of system log and database corresponding to <span class="s425">T</span><span class="s116">0</span> and <span class="s425">T</span><span class="s116">1</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Using the log, the system can handle any failure that does not result in the loss of information in non-volatile storage. The recovery scheme uses two recovery procedures. Both these procedures make use of the log to ﬁnd the set of data items updated by each transaction <i>T</i><span class="s97">i </span>and their respective old and new values.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s49">redo</span>(<i>T</i><span class="s145">i</span>). The procedure sets the value of all data items updated by transaction <i>T</i><span class="s145">i </span>to the new values. The order in which updates are carried out by <span class="s49">redo </span>is impor- tant; when recovering from a system crash, if updates to a particular data item are applied in an order diﬀerent from the order in which they were applied originally,</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">the ﬁnal state of that data item will have a wrong value. Most recovery algorithms, including the one we describe in Section 19.4, do not perform redo of each trans- action separately; instead they perform a single scan of the log, during which redo actions are performed for each log record as it is encountered. This approach en- sures the order of updates is preserved, and it is more eﬃcient since the log needs to be read only once overall, instead of once per transaction.</p><p style="padding-top: 3pt;padding-left: 62pt;text-indent: 0pt;line-height: 16pt;text-align: center;"><span class="s39">• </span><span class="s49">undo</span>(<i>T</i><span class="s97">i </span>). The procedure restores the value of all data items updated by transaction</p><p class="s13" style="padding-left: 59pt;text-indent: 0pt;line-height: 13pt;text-align: center;">T<span class="s145">i </span><span class="p">to the old values. In the recovery scheme that we describe in Section 19.4:</span></p><p class="s50" style="padding-top: 10pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: justify;">° <span class="s51">The undo operation not only restores the data items to their old value, but also writes log records to record the updates performed as part of the undo</span></p><p style="padding-left: 122pt;text-indent: 0pt;text-align: justify;">process. These log records are special <span class="s63">redo-only </span>log records, since they do not need to contain the old value of the updated data item; note that when such log records are used during undo, the “old value” is actually the value written by the transaction that is being rolled back, and the “new value” is the original value that is being restored by the undo operation.</p><p style="padding-left: 122pt;text-indent: 15pt;text-align: justify;">As with the redo procedure, the order in which undo operations are per- formed is important; again we postpone details to Section 19.4.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 1pt;padding-left: 145pt;text-indent: 0pt;line-height: 19pt;text-align: left;"><span class="s50">° </span><span class="s51">When the undo operation for transaction </span>T<span class="s145">i </span><span class="p">completes, it writes a </span><span class="s83">&lt;</span>T<span class="s145">i </span><span class="s49">abort</span><span class="s83">&gt;</span></p><p style="padding-left: 153pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">log record, indicating that the undo has completed.</p><p style="padding-left: 153pt;text-indent: 15pt;text-align: justify;">As we shall see in Section 19.4, the <span class="s49">undo</span>(<i>T</i><span class="s97">i </span>) procedure is executed only once for a transaction, if the transaction is rolled back during normal process- ing or if on recovering from a system crash, neither a <span class="s49">commit </span>nor an <span class="s49">abort </span>record is found for transaction <i>T</i><span class="s145">i</span>. As a result, every transaction will eventually have either a <span class="s49">commit </span>or an <span class="s49">abort </span>record in the log.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">After a system crash has occurred, the system consults the log to determine which transactions need to be redone and which need to be undone so as to ensure atomicity.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s83" style="padding-left: 139pt;text-indent: -16pt;line-height: 61%;text-align: justify;"><span class="s39">• </span><span class="s40">Transaction </span><span class="s13">T</span><span class="s97">i </span><span class="p">needs to be undone if the log contains the record </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">start</span>&gt; <span class="p">but does not contain either the record </span>&lt;<span class="s13">T</span><span class="s145">i </span><span class="s49">commit</span>&gt; <span class="p">or the record </span>&lt;<span class="s13">T</span><span class="s145">i </span><span class="s49">abort</span>&gt;<span class="p">.</span></p><p class="s83" style="padding-top: 5pt;padding-left: 139pt;text-indent: -16pt;line-height: 63%;text-align: justify;"><span class="s39">• </span><span class="s40">Transaction </span><span class="s13">T</span><span class="s97">i </span><span class="p">needs to be redone if the log contains the record </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">start</span>&gt; <span class="p">and either the record </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">commit</span>&gt; <span class="p">or the record </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt;<span class="p">. It may seem strange to redo </span><span class="s13">T</span><span class="s97">i </span><span class="p">if the record </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt; <span class="p">is in the log. To see why this works, note that if </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt; <span class="p">is in the log, so are the redo-only records written by the undo operation. Thus, the end result will be to undo </span><span class="s13">T</span><span class="s145">i</span><span class="p">’s modiﬁcations in this case. This slight</span></p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 12pt;text-align: left;">redundancy simpliﬁes the recovery algorithm and enables faster overall recovery</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: left;">time.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As an illustration, return to our banking example, with transaction <i>T</i><span class="s98">0</span> and <i>T</i><span class="s98">1</span> ex- ecuted one after the other in the order <i>T</i><span class="s98">0</span> followed by <i>T</i><span class="s98">1</span>. Suppose that the system crashes before the completion of the transactions. We shall consider three cases. The state of the logs for each of these cases appears in Figure 19.4.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">First, let us assume that the crash occurs just after the log record for the step:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s49">write</span>(<i>B</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 84%;text-align: left;">of transaction <i>T</i><span class="s98">0</span> has been written to stable storage (Figure 19.4a). When the system comes back up, it ﬁnds the record <span class="s83">&lt;</span><i>T</i><span class="s98">0</span> <span class="s49">start</span><span class="s83">&gt; </span>in the log, but no corresponding <span class="s83">&lt;</span><i>T</i><span class="s98">0</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s49">commit</span><span class="s83">&gt; </span>or <span class="s83">&lt;</span><i>T</i><span class="s98">0</span> <span class="s49">abort</span><span class="s83">&gt; </span>record. Thus, transaction <i>T</i><span class="s98">0</span> must be undone, so an <span class="s49">undo</span>(<i>T</i><span class="s98">0</span>)</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 10pt;text-align: left;">is performed. As a result, the values in accounts <i>A </i>and <i>B </i>(on the disk) are restored to</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">$1000 and $2000, respectively.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: left;">Next, let us assume that the crash comes just after the log record for the step:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="s49">write</span>(<i>C</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 92%;text-align: justify;">of transaction <i>T</i><span class="s98">1</span> has been written to stable storage (Figure 19.4b). When the system comes back up, two recovery actions need to be taken. The operation <span class="s49">undo</span>(<i>T</i><span class="s98">1</span>) must be performed, since the record <span class="s83">&lt;</span><i>T</i><span class="s98">1</span> <span class="s49">start</span><span class="s83">&gt; </span>appears in the log, but there is no record</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 9pt;text-align: justify;"><span class="s83">&lt;</span><i>T</i><span class="s98">1</span> <span class="s49">commit</span><span class="s83">&gt; </span>or <span class="s83">&lt;</span><i>T</i><span class="s98">1</span> <span class="s49">abort</span><span class="s83">&gt;</span>. The operation <span class="s49">redo</span>(<i>T</i><span class="s98">0</span>) must be performed, since the</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 17pt;text-align: justify;">log contains both the record <span class="s83">&lt;</span><i>T</i><span class="s98">0</span> <span class="s49">start</span><span class="s83">&gt; </span>and the record <span class="s83">&lt;</span><i>T</i><span class="s98">0</span> <span class="s49">commit</span><span class="s83">&gt;</span>. At the end of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:126.2pt" cellspacing="0"><tr style="height:13pt"><td style="width:95pt"><p class="s447" style="padding-left: 2pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt;<span class="s70">T</span><span class="s448">0</span><span class="s154"> </span>start&gt;</p></td><td style="width:103pt"><p class="s447" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt; <span class="s70">T</span><span class="s448">0</span><span class="s154"> </span>start&gt;</p></td><td style="width:96pt"><p class="s447" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt; <span class="s70">T</span><span class="s448">0</span><span class="s154"> </span>start&gt;</p></td></tr><tr style="height:12pt"><td style="width:95pt"><p class="s70" style="padding-left: 2pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s447">&lt; </span>T<span class="s448">0</span><span class="s154">, </span>A<span class="s154">, 1000, 950</span><span class="s447">&gt;</span></p></td><td style="width:103pt"><p class="s70" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s447">&lt; </span>T<span class="s448">0</span><span class="s154">, </span>A<span class="s154">, 1000, 950</span><span class="s447">&gt;</span></p></td><td style="width:96pt"><p class="s70" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s447">&lt; </span>T<span class="s448">0</span><span class="s154">, </span>A<span class="s154">, 1000, 950</span><span class="s447">&gt;</span></p></td></tr><tr style="height:12pt"><td style="width:95pt"><p class="s70" style="padding-left: 2pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s447">&lt; </span>T<span class="s448">0</span><span class="s154">, </span>B<span class="s154">, 2000, 2050</span><span class="s447">&gt;</span></p></td><td style="width:103pt"><p class="s70" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s447">&lt; </span>T<span class="s448">0</span><span class="s154">, </span>B<span class="s154">, 2000, 2050</span><span class="s447">&gt;</span></p></td><td style="width:96pt"><p class="s70" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s447">&lt; </span>T<span class="s448">0</span><span class="s154">, </span>B<span class="s154">, 2000, 2050</span><span class="s447">&gt;</span></p></td></tr><tr style="height:12pt"><td style="width:95pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:103pt"><p class="s447" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt; <span class="s70">T</span><span class="s448">0</span><span class="s154"> </span>commit&gt;</p></td><td style="width:96pt"><p class="s447" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt; <span class="s70">T</span><span class="s448">0</span><span class="s154"> </span>commit&gt;</p></td></tr><tr style="height:12pt"><td style="width:95pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:103pt"><p class="s447" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt; <span class="s70">T</span><span class="s448">1</span><span class="s154"> </span>start&gt;</p></td><td style="width:96pt"><p class="s447" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt; <span class="s70">T</span><span class="s448">1</span><span class="s154"> </span>start&gt;</p></td></tr><tr style="height:12pt"><td style="width:95pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:103pt"><p class="s70" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s447">&lt; </span>T<span class="s448">1</span><span class="s154">, </span>C<span class="s154">, 700, 600</span><span class="s447">&gt;</span></p></td><td style="width:96pt"><p class="s70" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s447">&lt; </span>T<span class="s448">1</span><span class="s154">, </span>C<span class="s154">, 700, 600</span><span class="s447">&gt;</span></p></td></tr><tr style="height:13pt"><td style="width:95pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:103pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:96pt"><p class="s447" style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt; <span class="s70">T</span><span class="s448">1</span><span class="s154"> </span>commit&gt;</p></td></tr><tr style="height:12pt"><td style="width:95pt"><p class="s154" style="padding-left: 30pt;text-indent: 0pt;line-height: 10pt;text-align: left;">(a)</p></td><td style="width:103pt"><p class="s154" style="padding-left: 33pt;padding-right: 55pt;text-indent: 0pt;line-height: 10pt;text-align: center;">(b)</p></td><td style="width:96pt"><p class="s154" style="padding-left: 38pt;padding-right: 44pt;text-indent: 0pt;line-height: 10pt;text-align: center;">(c)</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 19.4 <span class="s74">The same log, shown at three different times.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">the entire recovery procedure, the values of accounts <i>A</i>, <i>B</i>, and <i>C </i>are $950, $2050, and</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">$700, respectively.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: left;">Finally, let us assume that the crash occurs just after the log record:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s83" style="padding-left: 63pt;text-indent: 0pt;text-align: center;">&lt;<span class="s13">T</span><span class="s98">1</span><span class="p"> </span><span class="s49">commit</span>&gt;</p><p class="s13" style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;line-height: 84%;text-align: left;"><span class="p">has been written to stable storage (Figure 19.4c). When the system comes back up, both </span>T<span class="s130">0 </span><span class="s94">and </span>T<span class="s130">1 </span><span class="s94">need to be redone, since the records </span><span class="s83">&lt;</span>T<span class="s130">0 </span><span class="s49">start</span><span class="s83">&gt; </span><span class="p">and </span><span class="s83">&lt;</span>T<span class="s130">0 </span><span class="s49">commit</span><span class="s83">&gt;</span></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: left;">appear in the log, as do the records <span class="s83">&lt;</span><i>T</i><span class="s98">1</span> <span class="s49">start</span><span class="s83">&gt; </span>and <span class="s83">&lt;</span><i>T</i><span class="s98">1</span> <span class="s49">commit</span><span class="s83">&gt;</span>. After the system</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 10pt;text-align: left;">performs the recovery procedures <span class="s49">redo</span>(<i>T</i><span class="s98">0</span>) and <span class="s49">redo</span>(<i>T</i><span class="s98">1</span>), the values in accounts <i>A</i>, <i>B</i>,</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">and <i>C </i>are $950, $2050, and $600, respectively.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">19.3.6 Checkpoints</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">When a system crash occurs, we must consult the log to determine those transactions that need to be redone and those that need to be undone. In principle, we need to search the entire log to determine this information. There are two major diﬃculties with this approach:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 97pt;text-indent: 0pt;text-align: justify;">1. <span class="p">The search process is time-consuming.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">2. <span class="p">Most of the transactions that, according to our algorithm, need to be redone have already written their updates into the database. Although redoing them will cause no harm, it will nevertheless cause recovery to take longer.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">To reduce these types of overhead, we introduce <span class="s63">checkpoints</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We describe below a simple checkpoint scheme that (a) does not permit any up- dates to be performed while the checkpoint operation is in progress, and (b) outputs all modiﬁed buﬀer blocks to disk when the checkpoint is performed. We discuss later how to modify the checkpointing and recovery procedures to provide more ﬂexibility by relaxing both these requirements.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">A checkpoint is performed as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-top: 4pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">1. <span class="p">Output onto stable storage all log records currently residing in main memory.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">2. <span class="p">Output to the disk all modiﬁed buﬀer blocks.</span></p><p style="padding-top: 7pt;padding-left: 145pt;text-indent: -17pt;line-height: 70%;text-align: left;"><span class="s63">3. </span>Output onto stable storage a log record of the form <span class="s83">&lt;</span><span class="s49">checkpoint </span><i>L</i><span class="s83">&gt;</span>, where <i>L </i>is a list of transactions active at the time of the checkpoint.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Transactions are not allowed to perform any update actions, such as writing to a buﬀer block or writing a log record, while a checkpoint is in progress. We discuss how this requirement can be enforced in Section 19.5.2.</p><p class="s83" style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 69%;text-align: justify;"><span class="p">The presence ofa </span>&lt;<span class="s49">checkpoint </span><span class="s13">L</span>&gt; <span class="p">record in the log allows the system to stream- line its recovery procedure. Consider a transaction </span><span class="s13">T</span><span class="s145">i </span><span class="p">that completed prior to the check- point. For such a transaction, the </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">commit</span>&gt; <span class="p">record (or </span>&lt; <span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt; <span class="p">record) ap- pears in the log before the </span>&lt;<span class="s49">checkpoint</span>&gt; <span class="p">record. Any database modiﬁcations made by </span><span class="s13">T</span><span class="s97">i </span><span class="p">must have been written to the database either prior to the checkpoint or as part</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">of the checkpoint itself. Thus, at recovery time, there is no need to perform a <span class="s49">redo</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">operation on <i>T</i><span class="s145">i</span>.</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">After a system crash has occurred, the system examines the log to ﬁnd the last</p><p class="s83" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;line-height: 60%;text-align: justify;">&lt;<span class="s49">checkpoint </span><span class="s13">L</span>&gt; <span class="p">record (this can be done by searching the log backward, from the end of the log, until the ﬁrst </span>&lt;<span class="s49">checkpoint </span><span class="s13">L</span>&gt; <span class="p">record is found).</span></p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 76%;text-align: justify;">The <span class="s49">redo </span>or <span class="s49">undo </span>operations need to be applied only to transactions in <i>L</i>, and to all transactions that started execution after the <span class="s83">&lt;</span><span class="s49">checkpoint </span><i>L</i><span class="s83">&gt; </span>record was written to the log. Let us denote this set of transactions as <i>T </i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 123pt;text-indent: 0pt;line-height: 19pt;text-align: left;"><span class="s39">• </span><span class="s40">For all transactions </span>T<span class="s97">k </span><span class="p">in </span>T <span class="p">that have no </span><span class="s83">&lt;</span>T<span class="s97">k </span><span class="s49">commit</span><span class="s83">&gt; </span><span class="p">record or </span><span class="s83">&lt;</span>T<span class="s97">k </span><span class="s49">abort</span><span class="s83">&gt;</span></p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 73%;text-align: left;">record in the log, execute <span class="s49">undo</span>(<i>T</i><span class="s97">k</span>).</p><p class="s13" style="padding-top: 1pt;padding-left: 123pt;text-indent: 0pt;line-height: 17pt;text-align: left;"><span class="s39">• </span><span class="s40">For all transactions </span>T<span class="s145">k </span><span class="p">in </span>T <span class="p">such that either the record </span><span class="s83">&lt;</span>T<span class="s145">k </span><span class="s49">commit</span><span class="s83">&gt; </span><span class="p">or the record</span></p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 17pt;text-align: left;"><span class="s83">&lt;</span><i>T</i><span class="s145">k </span><span class="s49">abort</span><span class="s83">&gt; </span>appears in the log, execute <span class="s49">redo</span>(<i>T</i><span class="s145">k</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Note that we need only examine the part of the log starting with the last <span class="s49">checkpoint </span>log record to ﬁnd the set of transactions <i>T </i>and to ﬁnd out whether a <span class="s49">commit </span>or <span class="s49">abort </span>record occurs in the log for each transaction in <i>T </i>.</p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;line-height: 92%;text-align: justify;"><span class="p">As an illustration, consider the set of transactions </span><span class="s15">{</span>T<span class="s93">0</span><span class="s94">, </span>T<span class="s93">1</span><span class="s94">, </span><span class="s15">… </span><span class="p">, </span>T<span class="s93">100</span><span class="s15">}</span><span class="p">. Suppose that the most recent checkpoint took place during the execution of transaction </span>T<span class="s98">67</span><span class="p"> and </span>T<span class="s130">69</span><span class="s94">, while </span>T<span class="s130">68 </span><span class="s94">and all transactions with subscripts lower than 67 completed before the checkpoint. Thus, only transactions </span>T<span class="s130">67</span><span class="s94">, </span>T<span class="s130">69</span><span class="s94">, </span><span class="s15">… </span><span class="p">, </span>T<span class="s130">100 </span><span class="s94">need to be considered during</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">the recovery scheme. Each of them needs to be redone if it has completed (i.e., either</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">committed or aborted); otherwise, it was incomplete and needs to be undone.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 91%;text-align: justify;">Consider the set of transactions <i>L </i>in a checkpoint log record. For each transaction <i>T</i><span class="s145">i </span>in <i>L</i>, log records of the transaction that occur prior to the checkpoint log record may be needed to undo the transaction, in case it does not commit. However, all log records prior to the earliest of the <span class="s83">&lt;</span><i>T</i><span class="s97">i </span><span class="s49">start</span><span class="s83">&gt; </span>log records, among transactions <i>T</i><span class="s97">i </span>in <i>L</i>,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><a name="bookmark398">are not needed once the checkpoint has completed. These log records can be erased whenever the database system needs to reclaim the space occupied by these records.</a><a name="bookmark438">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The requirement that transactions must not perform any updates to buﬀer blocks or to the log during checkpointing can be bothersome, since transaction processing has to halt while a checkpoint is in progress. A <span class="s63">fuzzy checkpoint </span>is a checkpoint where transactions are allowed to perform updates even while buﬀer blocks are being writ- ten out. Section 19.5.4 describes fuzzy-checkpointing schemes. Later in Section 19.9 we describe a checkpoint scheme that is not only fuzzy, but does not even require all modiﬁed buﬀer blocks to be output to disk at the time of the checkpoint.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part348.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part350.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
