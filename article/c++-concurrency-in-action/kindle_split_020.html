<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mbp="Kindle">
  <head>
    <title>C++ Concurrency in Action, Second Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="part" id="ch10">Chapter 10. <a id="ch10__title" class="calibre3"></a>Parallel algorithms
      </h2>
      
      <p class="noind"><a id="iddle1015" class="calibre4"></a><a id="iddle1349" class="calibre4"></a><a id="iddle1739" class="calibre4"></a><a id="iddle1751" class="calibre4"></a><a id="iddle1766" class="calibre4"></a><a id="iddle2118" class="calibre4"></a><i class="calibre6">This chapter covers</i></p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">Using the C++17 parallel algorithms</li>
         
      </ul>
      
      <p class="noind">In the last chapter we looked at advanced thread management and thread pools, and in <a href="kindle_split_018.html#ch08" class="calibre4">chapter 8</a> we looked at designing concurrent code, using parallel versions of some algorithms as examples. In this chapter, we’ll look
         at the parallel algorithms provided by the C++17 standard, so let’s start, without further ado.
      </p>
      
      
      <h3 id="ch10lev1sec1" class="chapter"><a id="ch10lev1sec1__title" class="calibre3"></a>10.1. Parallelizing the standard library algorithms
      </h3>
      
      <p class="noind">The C++17 standard added the concept of <i class="calibre6">parallel algorithms</i> to the C++ Standard Library. These are additional overloads of many of the functions that operate on ranges, such as <kbd class="calibre17">std::find</kbd>, <kbd class="calibre17">std::transform</kbd> and <kbd class="calibre17">std::reduce</kbd>. The parallel versions have the same signature as the “normal” single-threaded versions, except for the addition of a new
         first parameter, which specifies the <i class="calibre6">execution policy</i> to use. For example:
      </p>
      
      <pre id="PLd0e36039" class="calibre5">std::vector&lt;int&gt; my_data;
std::sort(<b class="calibre24">std::execution::par</b>,my_data.begin(),my_data.end());</pre>
      
      <p class="noind">The execution policy of <kbd class="calibre17">std::execution::par</kbd> indicates to the standard library that it is allowed to perform this call as a parallel algorithm, using multiple threads.
         Note <a id="iddle1012" class="calibre4"></a><a id="iddle1343" class="calibre4"></a><a id="iddle1345" class="calibre4"></a><a id="iddle1346" class="calibre4"></a><a id="iddle1743" class="calibre4"></a><a id="iddle1744" class="calibre4"></a><a id="iddle1929" class="calibre4"></a><a id="iddle2119" class="calibre4"></a><a id="iddle2121" class="calibre4"></a><a id="iddle2123" class="calibre4"></a><a id="iddle2125" class="calibre4"></a><a id="iddle2126" class="calibre4"></a>that this is <i class="calibre6">permission</i>, not a <i class="calibre6">requirement</i>—the library may still execute the code on a single thread if it wishes. It is also important to note that by specifying an
         execution policy, the requirements on the algorithm complexity have changed, and are usually slacker than the requirements
         for the normal serial algorithm. This is because parallel algorithms often do more total work in order to take advantage of
         the parallelism of the system — if you can divide the work across 100 processors, then you can still get an overall speed
         up to 50, even if the implementation does twice as much total work.
      </p>
      
      <p class="noind">Before we get onto the algorithms themselves, let’s take a look at the execution policies.</p>
      
      
      
      <h3 id="ch10lev1sec2" class="chapter"><a id="ch10lev1sec2__title" class="calibre3"></a>10.2. Execution policies
      </h3>
      
      <p class="noind">The standard specifies three execution policies:</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><kbd class="calibre17">std::execution::sequenced_policy</kbd></li>
         
         <li class="calibre22"><kbd class="calibre17">std::execution::parallel_policy</kbd></li>
         
         <li class="calibre22"><kbd class="calibre17">std::execution::parallel_unsequenced_policy</kbd></li>
         
      </ul>
      
      <p class="noind">These are classes defined in the <kbd class="calibre17">&lt;execution&gt;</kbd> header. The header also defines three corresponding policy objects to pass to the algorithms:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><kbd class="calibre17">std::execution::seq</kbd></li>
         
         <li class="calibre22"><kbd class="calibre17">std::execution::par</kbd></li>
         
         <li class="calibre22"><kbd class="calibre17">std::execution::par_unseq</kbd></li>
         
      </ul>
      
      <p class="noind">You cannot rely on being able to construct objects from these policy classes yourself, except by copying these three objects,
         because they might have special initialization requirements. Implementations may also define additional execution policies
         that have implementation-specific behavior. You cannot define your own execution policies.
      </p>
      
      <p class="noind">The consequences of these policies on the behavior of the algorithms are described in <a href="#ch10lev2sec1" class="calibre4">section 10.2.1</a>. Any given implementation is also allowed to provide additional execution policies, with whatever semantics they want. Let’s
         now take a look at the consequences of using one of the standard execution policies, starting with the general changes for
         all algorithm overloads that take an exception policy.
      </p>
      
      
      <h4 id="ch10lev2sec1" class="calibre23">10.2.1. <a id="ch10lev2sec1__title" class="calibre4"></a>General effects of specifying an execution policy
      </h4>
      
      <p class="noind">If you pass an execution policy to one of the standard library algorithms, then the behavior of that algorithm is now governed
         by the execution policy. This affects several aspects of the behavior:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">The algorithm’s complexity</li>
         
         <li class="calibre22">The behavior when an exception is thrown</li>
         
         <li class="calibre22">Where, how, and when the steps of the algorithm are executed</li>
         
      </ul>
      
      
      <h5 class="notetitle" id="ch10lev3sec1"><a id="ch10lev3sec1__title" class="calibre4"></a>Effects on algorithm complexity
      </h5>
      
      <p class="noind">If an execution policy is supplied to an algorithm, then that algorithm’s complexity may be changed: in addition to the scheduling
         overhead of managing the parallel <a id="iddle1016" class="calibre4"></a><a id="iddle1347" class="calibre4"></a><a id="iddle1348" class="calibre4"></a><a id="iddle2032" class="calibre4"></a>execution, many parallel algorithms will perform more of the core operations of the algorithm (whether <i class="calibre6">swaps</i>, <i class="calibre6">comparisons</i>, or <i class="calibre6">applications of a supplied function object</i>), with the intention that this provides an overall improvement in the performance in terms of total elapsed time.
      </p>
      
      <p class="noind">The precise details of the complexity change will vary with each algorithm, but the general policy is that if an algorithm
         specifies something will happen exactly <i class="calibre6">some-expression</i> times, or at most <i class="calibre6">some-expression</i> times, then the overload with an execution policy will slacken that requirement to <i class="calibre6">O(some-expression)</i>. This means that the overload with an execution policy may perform some multiple of the number of operations performed by
         its counterpart without an execution policy, where that multiple will depend on the internals of the library and the platform,
         rather than the data supplied to the algorithm.
      </p>
      
      
      
      <h5 class="notetitle" id="ch10lev3sec2"><a id="ch10lev3sec2__title" class="calibre4"></a>Exceptional behavior
      </h5>
      
      <p class="noind">If an exception is thrown during execution of an algorithm with an execution policy, then the consequences are determined
         by the execution policy. All the standard-supplied execution policies will call <kbd class="calibre17">std::terminate</kbd> if there are any uncaught exceptions. The only exception that may be thrown by a call to a standard library algorithm with
         one of the standard execution policies is <kbd class="calibre17">std::bad_alloc</kbd>, which is thrown if the library cannot obtain sufficient memory resources for its internal operations. For example, the following
         call to <kbd class="calibre17">std::for_each</kbd>, without an execution policy, will propagate the exception
      </p>
      
      <pre id="PLd0e36314" class="calibre5">std::for_each(v.begin(),v.end(),[](auto x){ throw my_exception(); });</pre>
      
      <p class="noind">whereas the corresponding call with an execution policy will terminate the program:</p>
      
      <pre id="PLd0e36323" class="calibre5">std::for_each(
    <b class="calibre24">std::execution::seq</b>,v.begin(),v.end(),
    [](auto x){ throw my_exception(); });</pre>
      
      <p class="noind">This is one of the key differences between using <kbd class="calibre17">std::execution::seq</kbd> and not providing an execution policy.
      </p>
      
      
      
      <h5 class="notetitle" id="ch10lev3sec3"><a id="ch10lev3sec3__title" class="calibre4"></a>Where and when algorithm steps are executed
      </h5>
      
      <p class="noind">This is the fundamental aspect of an execution policy, and is the only aspect that differs between the standard execution
         policies. The policy specifies which execution agents are used to perform the steps of the algorithm, be they “normal” threads,
         vector streams, GPU threads, or anything else. The execution policy will also specify whether there are any ordering constraints
         on how the algorithm steps are run: whether or not they are run in any particular order, whether or not parts of separate
         algorithm steps may be interleaved with each other, or run in parallel with each other, and so forth.
      </p>
      
      <p class="noind">The details for each of the standard execution policies are given in <a href="#ch10lev2sec2" class="calibre4">sections 10.2.2</a>, <a href="#ch10lev2sec3" class="calibre4">10.2.3</a>, and <a href="#ch10lev2sec4" class="calibre4">10.2.4</a>, starting with the most basic policy: <kbd class="calibre17">std::execution::sequenced_policy</kbd>.
      </p>
      
      
      
      
      
      <h4 id="ch10lev2sec2" class="calibre23">10.2.2. <a id="ch10lev2sec2__title" class="calibre4"></a>std::execution::sequenced_policy
      </h4>
      
      <p class="noind"><a id="iddle1350" class="calibre4"></a><a id="iddle1352" class="calibre4"></a><a id="iddle1745" class="calibre4"></a><a id="iddle1747" class="calibre4"></a><a id="iddle2120" class="calibre4"></a>The sequenced policy is not a policy for parallelism: using it forces the implementation to perform all operations on the
         thread that called the function, so there is no parallelism. But it is still an execution policy, and therefore has the same
         consequences on algorithmic complexity and the effect of exceptions as the other standard policies.
      </p>
      
      <p class="noind">Not only must all operations be performed on the same thread, but they must be performed in some definite order, so they are
         not interleaved. The precise order is unspecified, and may be different between different invocations of the function. In
         particular, the order of execution of the operations is not guaranteed to be the same as that of the corresponding overload
         without an execution policy. For example, the following call to <kbd class="calibre17">std::for_each</kbd> will populate the vector with the numbers 1-1,000, in an unspecified order. This is in contrast to the overload without an
         execution policy, which will store the numbers in order:
      </p>
      
      <pre id="PLd0e36423" class="calibre5">std::vector&lt;int&gt; v(1000);
int count=0;
std::for_each(<b class="calibre24">std::execution::seq</b>,v.begin(),v.end(),
    [&amp;](int&amp; x){ x=++count; });</pre>
      
      <p class="noind">The numbers may be stored in order, but you cannot rely on it.</p>
      
      <p class="noind">This means that the sequenced policy imposes few requirements on the iterators, values, and callable objects used with the
         algorithm: they may freely use synchronization mechanisms, and may rely on all operations being invoked on the same thread,
         though they cannot rely on the order of these operations.
      </p>
      
      
      
      <h4 id="ch10lev2sec3" class="calibre23">10.2.3. <a id="ch10lev2sec3__title" class="calibre4"></a>std::execution::parallel_policy
      </h4>
      
      <p class="noind">The parallel policy provides basic parallel execution across a number of threads. Operations may be performed either on the
         thread that invoked the algorithm, or on threads created by the library. Operations performed on a given thread must be performed
         in a definite order, and not interleaved, but the precise order is unspecified, and may vary between invocations. A given
         operation will run on a fixed thread for its entire duration.
      </p>
      
      <p class="noind">This imposes additional requirements on the iterators, values, and callable objects used with the algorithm over the sequenced
         policy: they must not cause data races if invoked in parallel, and must not rely on being run on the same thread as any other
         operation, or indeed rely on not being run on the same thread as any other operation.
      </p>
      
      <p class="noind">You can use the parallel execution policy for the vast majority of cases where you would have used a standard library algorithm
         without an execution policy. It’s only where there is specific ordering between elements that is required, or unsynchronized
         access to shared data, that is problematic. Incrementing all the values in a vector can be done in parallel:
      </p>
      
      <pre id="PLd0e36453" class="calibre5">std::for_each(std::execution::par,v.begin(),v.end(),[](auto&amp; x){++x;});</pre>
      
      <p class="noind"><a id="iddle1081" class="calibre4"></a><a id="iddle1351" class="calibre4"></a><a id="iddle1746" class="calibre4"></a><a id="iddle1748" class="calibre4"></a><a id="iddle2122" class="calibre4"></a><a id="iddle2604" class="calibre4"></a>The previous example of populating a vector is not OK if done with the parallel execution policy; specifically, it is undefined
         behavior:
      </p>
      
      <pre id="PLd0e36505" class="calibre5">std::for_each(<b class="calibre24">std::execution::par</b>,v.begin(),v.end(),
    [&amp;](int&amp; x){ x=++count; });</pre>
      
      <p class="noind">Here, the variable <kbd class="calibre17">count</kbd> is modified from every invocation of the lambda, so if the library were to execute the lambdas across multiple threads, this
         would be a data race, and thus undefined behavior. The requirements for <kbd class="calibre17">std::execution::parallel_policy</kbd> pre-empt this: it is undefined behavior to make the preceding call, even if the library doesn’t use multiple threads for
         this call. Whether or not something exhibits undefined behavior is a static property of the call, rather than dependent on
         implementation details of the library. Synchronization between the function invocations <b class="calibre24">is</b> permitted, however, so you could make this defined behavior again either by making <kbd class="calibre17">count</kbd> an <kbd class="calibre17">std::atomic&lt;int&gt;</kbd> rather than a plain <kbd class="calibre17">int</kbd>, or by using a mutex. In this case, that would likely defeat the point of using the parallel execution policy, because that
         would serialize all the calls, but in the general case it would allow for synchronized access to a shared state.
      </p>
      
      
      
      <h4 id="ch10lev2sec4" class="calibre23">10.2.4. <a id="ch10lev2sec4__title" class="calibre4"></a>std::execution::parallel_unsequenced_policy
      </h4>
      
      <p class="noind">The parallel unsequenced policy provides the library with the greatest scope for parallelizing the algorithm in exchange for
         imposing the strictest requirements on the iterators, values, and callable objects used with the algorithm.
      </p>
      
      <p class="noind">An algorithm invoked with the parallel unsequenced policy may perform the algorithm steps on unspecified threads of execution,
         unordered and unsequenced with respect to one another. This means that operations may now be interleaved with each other on
         a single thread, such that a second operation is started on the same thread before the first has finished, and may be migrated
         between threads, so a given operation may start on one thread, run further on a second thread, and complete on a third.
      </p>
      
      <p class="noind">If you use the parallel unsequenced policy, then the operations invoked on the iterators, values, and callable objects supplied
         to the algorithm must not use any form of synchronization or call any function that synchronizes with another, or any function
         such that some other code synchronizes with it.
      </p>
      
      <p class="noind">This means that the operations must only operate on the relevant element, or any data that can be accessed based on that element,
         and must not modify any state shared between threads, or between elements.
      </p>
      
      <p class="noind">We’ll flesh these out with some examples later. For now, let’s take a look at the parallel algorithms themselves.</p>
      
      
      
      
      <h3 id="ch10lev1sec3" class="chapter"><a id="ch10lev1sec3__title" class="calibre3"></a>10.3. The parallel algorithms from the C++ Standard Library
      </h3>
      
      <p class="noind">Most of the algorithms from the <kbd class="calibre17">&lt;algorithm&gt;</kbd> and <kbd class="calibre17">&lt;numeric&gt;</kbd> headers have overloads that take an execution policy. This comprises: <kbd class="calibre17">all_of</kbd>, <kbd class="calibre17">any_of</kbd>, <kbd class="calibre17">none_of</kbd>, <kbd class="calibre17">for_each</kbd>, <a id="iddle1469" class="calibre4"></a><a id="iddle1731" class="calibre4"></a><kbd class="calibre17">for_each_n</kbd>, <kbd class="calibre17">find</kbd>, <kbd class="calibre17">find_if</kbd>, <kbd class="calibre17">find_end</kbd>, <kbd class="calibre17">find_first_of</kbd>, <kbd class="calibre17">adjacent_find</kbd>, <kbd class="calibre17">count</kbd>, <kbd class="calibre17">count_if</kbd>, <kbd class="calibre17">mismatch</kbd>, <kbd class="calibre17">equal</kbd>, <kbd class="calibre17">search</kbd>, <kbd class="calibre17">search_n</kbd>, <kbd class="calibre17">copy</kbd>, <kbd class="calibre17">copy_n</kbd>, <kbd class="calibre17">copy_if</kbd>, <kbd class="calibre17">move</kbd>, <kbd class="calibre17">swap_ranges</kbd>, <kbd class="calibre17">transform</kbd>, <kbd class="calibre17">replace</kbd>, <kbd class="calibre17">replace_if</kbd>, <kbd class="calibre17">replace_copy</kbd>, <kbd class="calibre17">replace_copy_if</kbd>, <kbd class="calibre17">fill</kbd>, <kbd class="calibre17">fill_n</kbd>, <kbd class="calibre17">generate</kbd>, <kbd class="calibre17">generate_n</kbd>, <kbd class="calibre17">remove</kbd>, <kbd class="calibre17">remove_if</kbd>, <kbd class="calibre17">remove_copy</kbd>, <kbd class="calibre17">remove_copy_if</kbd>, <kbd class="calibre17">unique</kbd>, <kbd class="calibre17">unique_copy</kbd>, <kbd class="calibre17">reverse</kbd>, <kbd class="calibre17">reverse_copy</kbd>, <kbd class="calibre17">rotate</kbd>, <kbd class="calibre17">rotate_copy</kbd>, <kbd class="calibre17">is_partitioned</kbd>, <kbd class="calibre17">partition</kbd>, <kbd class="calibre17">stable_partition</kbd>, <kbd class="calibre17">partition_copy</kbd>, <kbd class="calibre17">sort</kbd>, <kbd class="calibre17">stable_sort</kbd>, <kbd class="calibre17">partial_sort</kbd>, <kbd class="calibre17">partial_sort_copy</kbd>, <kbd class="calibre17">is_sorted</kbd>, <kbd class="calibre17">is_sorted_until</kbd>, <kbd class="calibre17">nth_element</kbd>, <kbd class="calibre17">merge</kbd>, <kbd class="calibre17">inplace_merge</kbd>, <kbd class="calibre17">includes</kbd>, <kbd class="calibre17">set_union</kbd>, <kbd class="calibre17">set_intersection</kbd>, <kbd class="calibre17">set_difference</kbd>, <kbd class="calibre17">set_symmetric_difference</kbd>, <kbd class="calibre17">is_heap</kbd>, <kbd class="calibre17">is_heap_until</kbd>, <kbd class="calibre17">min_element</kbd>, <kbd class="calibre17">max_element</kbd>, <kbd class="calibre17">minmax_element</kbd>, <kbd class="calibre17">lexicographical_compare</kbd>, <kbd class="calibre17">reduce</kbd>, <kbd class="calibre17">transform_reduce</kbd>, <kbd class="calibre17">exclusive_scan</kbd>, <kbd class="calibre17">inclusive_scan</kbd>, <kbd class="calibre17">transform_exclusive_scan</kbd>, <kbd class="calibre17">transform_inclusive_scan</kbd>, and <kbd class="calibre17">adjacent_difference</kbd>.
      </p>
      
      <p class="noind">That’s quite a list; pretty much every algorithm in the C++ Standard Library that could be parallelized is in this list. Notable
         exceptions are things like <kbd class="calibre17">std::accumulate</kbd>, which is strictly a serial accumulation, but its generalized counterpart in <kbd class="calibre17">std::reduce</kbd> does appear in the list — with a suitable warning in the standard that if the reduction operation is not both associative
         and commutative, then the result may be nondeterministic due to the unspecified order of operations.
      </p>
      
      <p class="noind">For each of the algorithms in the list, every “normal” overload has a new variant which takes an execution policy as the first
         argument—the corresponding arguments for the “normal” overload then come after this execution policy. For example, <kbd class="calibre17">std::sort</kbd> has two “normal” overloads without an execution policy:
      </p>
      
      <pre id="PLd0e36812" class="calibre5">template&lt;class RandomAccessIterator&gt;
void sort(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
void sort(
    RandomAccessIterator first, RandomAccessIterator last, Compare comp);</pre>
      
      <p class="noind">It therefore also has two overloads with an execution policy:</p>
      
      <pre id="PLd0e36821" class="calibre5">template&lt;class ExecutionPolicy, class RandomAccessIterator&gt;
void sort(
    ExecutionPolicy&amp;&amp; exec,
    RandomAccessIterator first, RandomAccessIterator last);

template&lt;class ExecutionPolicy, class RandomAccessIterator, class Compare&gt;
void sort(
    ExecutionPolicy&amp;&amp; exec,
    RandomAccessIterator first, RandomAccessIterator last, Compare comp);</pre>
      
      <p class="noind">There is one important difference between the signatures with and without the execution policy argument, which only impacts
         some algorithms: if the “normal” algorithm allows <i class="calibre6">Input Iterators</i> or <i class="calibre6">Output Iterators</i>, then the overloads with an execution policy require <i class="calibre6">Forward Iterators</i> instead. This is because Input Iterators are fundamentally single-pass: you can only access the current element, and you
         cannot store iterators to <a id="iddle1065" class="calibre4"></a><a id="iddle1389" class="calibre4"></a><a id="iddle1842" class="calibre4"></a>previous elements. Similarly, Output Iterators only allow writing to the current element: you cannot advance them to write
         a later element, and then backtrack to write a previous one.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <div class="calibre15">
         
         <b id="ch10sb01" class="calibre24">Iterator categories in the C++ Standard Library</b>
         
         <p class="noind">The C++ Standard Library defines five categories of iterators: <i class="calibre6">Input Iterators</i>, <i class="calibre6">Output Iterators</i>, <i class="calibre6">Forward Iterators</i>, <i class="calibre6">Bidirectional Iterators</i>, and <i class="calibre6">Random Access Iterators</i>.
         </p>
         
         <p class="noind"><i class="calibre6">Input Iterators</i> are single-pass iterators for retrieving values. They are typically used for things like input from a console or network,
            or generated sequences. Advancing an Input Iterator invalidates any copies of that iterator.
         </p>
         
         <p class="noind"><i class="calibre6">Output Iterators</i> are single-pass iterators for writing values. They are typically used for output to files, or adding values to a container.
            Advancing an Output Iterator invalidates any copies of that iterator.
         </p>
         
         <p class="noind"><i class="calibre6">Forward Iterators</i> are multipass iterators for one-way iteration through persistent data. Though you can’t make an iterator go back to a previous
            element, you can store copies and use them to reference earlier elements. Forward Iterators return real references to the
            elements, and so can be used for both reading and writing (if the target is non-<kbd class="calibre17">const</kbd>).
         </p>
         
         <p class="noind"><i class="calibre6">Bidirectional Iterators</i> are multipass iterators like Forward Iterators, but they can also be made to go backward to access previous elements.
         </p>
         
         <p class="noind"><i class="calibre6">Random Access Iterators</i> are multipass iterators that can go forward and backward like Bidirectional Iterators, but they can go forward and backward
            in steps larger than a single element, and you can directly access elements at an offset, using the array index operator.
         </p>
         
      </div>
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="noind">Thus, given the “normal” signature for <kbd class="calibre17">std::copy</kbd></p>
      
      <pre id="PLd0e36913" class="calibre5">template&lt;class InputIterator, class OutputIterator&gt;
OutputIterator copy(
    InputIterator first, InputIterator last, OutputIterator result);</pre>
      
      <p class="noind">the overload with an execution policy is</p>
      
      <pre id="PLd0e36922" class="calibre5">template&lt;class ExecutionPolicy,
    class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator2 copy(
    ExecutionPolicy&amp;&amp; policy,
    ForwardIterator1 first, ForwardIterator1 last,
    ForwardIterator2 result);</pre>
      
      <p class="noind">Though the naming of the template parameters doesn’t carry any direct consequence from the compiler’s perspective, it does
         from the C++ Standard’s perspective: the names of the template parameters for Standard Library algorithms denote semantic
         constraints on the types, and the algorithms will rely on the operations implied by <a id="iddle1083" class="calibre4"></a><a id="iddle1344" class="calibre4"></a><a id="iddle1750" class="calibre4"></a><a id="iddle2124" class="calibre4"></a>those constraints existing, with the specified semantics. In the case of Input Iterators vs. Forward Iterators, the former
         allows dereferencing the iterator to return a proxy type, which is convertible to the value type of the iterator, whereas
         the latter requires that dereferencing the iterator returns a real reference to the value and that all equal iterators return
         a reference to the same value.
      </p>
      
      <p class="noind">This is important for parallelism: it means that the iterators can be freely copied around, and used equivalently. Also, the
         requirement that incrementing a Forward Iterator does not invalidate other copies is important, as it means that separate
         threads can operate on their own copies of the iterators, incrementing them when required, without concern about invalidating
         the iterators held by the other threads. If the overload with an execution policy allowed use of Input Iterators, this would
         force any threads to serialize access to the one and only iterator that was used for reading from the source sequence, which
         obviously limits the potential for parallelism.
      </p>
      
      <p class="noind">Let’s have a look at some concrete examples.</p>
      
      
      <h4 id="ch10lev2sec5" class="calibre23">10.3.1. <a id="ch10lev2sec5__title" class="calibre4"></a>Examples of using parallel algorithms
      </h4>
      
      <p class="noind">The simplest possible example surely has to be the parallel loop: do something for each element of a container. This is the
         classic example of an embarrassingly parallel scenario: each item is independent, so you have the maximum possibility of parallelism.
         With a compiler that supports OpenMP, you might write
      </p>
      
      <pre id="PLd0e36979" class="calibre5">#pragma omp parallel for
for(unsigned i=0;i&lt;v.size();++i){
    do_stuff(v[i]);
}</pre>
      
      <p class="noind">With the C++ Standard Library algorithms, you can instead write</p>
      
      <pre id="PLd0e36988" class="calibre5">std::for_each(std::execution::par,v.begin(),v.end(),do_stuff);</pre>
      
      <p class="noind">This will divide the elements of the range between the internal threads created by the library, and invoke <kbd class="calibre17">do_stuff(x)</kbd> on each element <kbd class="calibre17">x</kbd> in the range. How those elements are divided between the threads is an implementation detail.
      </p>
      
      
      <h5 class="notetitle" id="ch10lev3sec4"><a id="ch10lev3sec4__title" class="calibre4"></a>Choice of execution policy
      </h5>
      
      <p class="noind"><kbd class="calibre17">std::execution::par</kbd> is the policy that you’ll want to use most often, unless your implementation provides a nonstandard policy better suited
         to your needs. If your code is suitable for parallelization, then it should work with <kbd class="calibre17">std::execution::par</kbd>. In some circumstances, you may be able to use <kbd class="calibre17">std::execution::par_unseq</kbd> instead. This may do nothing at all (none of the standard execution policies make a guarantee about the level of parallelism
         that will be attained), but it may give the library additional scope to improve the performance of the code by reordering
         and interleaving the tasks, in exchange for the tighter requirements on your code. Most notable of these tighter requirements
         is that there is no synchronization used in accessing the elements, or performing the operations on the elements. This means
         that you cannot use mutexes or atomic variables, or any of the other mechanisms described in previous chapters, to ensure
         that accesses from multiple threads are safe; instead, you must rely on the algorithm itself not accessing the same element
         from multiple threads, and use external synchronization outside the call to the parallel algorithm to prevent other threads
         accessing the data.
      </p>
      
      <p class="noind">The example from <a href="#ch10ex01" class="calibre4">listing 10.1</a> shows some code that can be used with <kbd class="calibre17">std:: execution::par</kbd>, but not <kbd class="calibre17">std::execution::par_unseq</kbd>. The use of the internal mutex for synchronization means that attempting to use <kbd class="calibre17">std::execution::par_unseq</kbd> would be undefined behavior.
      </p>
      
      
      
      <h5 class="notetitle" id="ch10ex01">Listing 10.1. <a id="ch10ex01__title" class="calibre4"></a>Parallel algorithms on a class with internal synchronization
      </h5>
      <pre id="PLd0e37041" class="calibre5">class X{
    mutable std::mutex m;
    int data;
public:
    X():data(0){}
    int get_value() const{
        std::lock_guard guard(m);
        return data;
    }
    void increment(){
        std::lock_guard guard(m);
        ++data;
    }
};
void increment_all(std::vector&lt;X&gt;&amp; v){
    std::for_each(std::execution::par,v.begin(),v.end(),
        [](X&amp; x){
            x.increment();
        });
}</pre>
      
      <p class="noind">The next listing shows an alternative that can be used with <kbd class="calibre17">std::execution::par_unseq</kbd>. In this case, the internal per-element mutex has been replaced with a whole-container mutex.
      </p>
      
      
      
      <h5 class="notetitle" id="ch10ex02">Listing 10.2. <a id="ch10ex02__title" class="calibre4"></a>Parallel algorithms on a class without internal synchronization
      </h5>
      <pre id="PLd0e37059" class="calibre5">class Y{
    int data;
public:
    Y():data(0){}
    int get_value() const{
        return data;
    }
    void increment(){
        ++data;
    }
};
class ProtectedY{
    std::mutex m;
    std::vector&lt;Y&gt; v;
public:
   void lock(){
         m.lock();
     }
   void unlock(){
         m.unlock();
     }
     std::vector&lt;Y&gt;&amp; get_vec(){
         return v;
     }
};
void increment_all(ProtectedY&amp; data){
    std::lock_guard guard(data);
    auto&amp; v=data.get_vec();
    std::for_each(std::execution::par_unseq,v.begin(),v.end(),
        [](Y&amp; y){
            y.increment();
        });
}</pre>
      
      <p class="noind"><a id="iddle1082" class="calibre4"></a><a id="iddle1228" class="calibre4"></a><a id="iddle1749" class="calibre4"></a><a id="iddle2573" class="calibre4"></a><a id="iddle2618" class="calibre4"></a>The element accesses in <a href="#ch10ex02" class="calibre4">listing 10.2</a> now have no synchronization, and it is safe to use <kbd class="calibre17">std::execution::par_unseq</kbd>. The downside is that concurrent accesses from other threads outside the parallel algorithm invocation must now wait for
         the entire operation to complete, rather than the per-element granularity of <a href="#ch10ex01" class="calibre4">listing 10.1</a>.
      </p>
      
      <p class="noind">Let’s now take a look at a more realistic example of how the parallel algorithms might be used: counting visits to a website.</p>
      
      
      
      
      <h4 id="ch10lev2sec6" class="calibre23">10.3.2. <a id="ch10lev2sec6__title" class="calibre4"></a>Counting visits
      </h4>
      
      <p class="noind">Suppose you run a busy website, such that the logs contain millions of entries, and you want to process those logs to see
         aggregate data: how many visits per page, where do those visits come from, which browsers were used to access the website,
         and so forth. Analyzing these logs has two parts: processing each line to extract the relevant information, and aggregating
         the results together. This is an ideal scenario for using parallel algorithms, because processing each individual line is
         entirely independent of everything else, and aggregating the results can be done piecemeal, provided the final totals are
         correct.
      </p>
      
      <p class="noind">In particular, this is the sort of task that <kbd class="calibre17">transform_reduce</kbd> is designed for. The following listing shows how this could be used for this task.<a id="iddle1126" class="calibre4"></a><a id="iddle1229" class="calibre4"></a><a id="iddle1772" class="calibre4"></a></p>
      
      
      
      <h5 class="notetitle" id="ch10ex03">Listing 10.3. <a id="ch10ex03__title" class="calibre4"></a>Using <kbd class="calibre17">transform_reduce</kbd> to count visits to pages of a website
      </h5>
      <pre id="PLd0e37158" class="calibre5">#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;numeric&gt;

struct log_info {
    std::string page;
    time_t visit_time;
    std::string browser;
    // any other fields
};

extern log_info parse_log_line(std::string const &amp;line);                  <b class="calibre24"><i class="calibre6">1</i></b>

using visit_map_type= std::unordered_map&lt;std::string, unsigned long long&gt;;

visit_map_type
count_visits_per_page(std::vector&lt;std::string&gt; const &amp;log_lines) {

    struct combine_visits {
        visit_map_type
        operator()(visit_map_type lhs, visit_map_type rhs) const {        <b class="calibre24"><i class="calibre6">3</i></b>
            if(lhs.size() &lt; rhs.size())
                std::swap(lhs, rhs);
            for(auto const &amp;entry : rhs) {
                lhs[entry.first]+= entry.second;
            }
            return lhs;
        }

        visit_map_type operator()(log_info log,visit_map_type map) const{ <b class="calibre24"><i class="calibre6">4</i></b>
            ++map[log.page];
            return map;
        }
        visit_map_type operator()(visit_map_type map,log_info log) const{ <b class="calibre24"><i class="calibre6">5</i></b>
            ++map[log.page];
            return map;
        }
        visit_map_type operator()(log_info log1,log_info log2) const{     <b class="calibre24"><i class="calibre6">6</i></b>
            visit_map_type map;
            ++map[log1.page];
            ++map[log2.page];
            return map;
        }
    };

    return std::transform_reduce(                                         <b class="calibre24"><i class="calibre6">2</i></b>
        std::execution::par, log_lines.begin(), log_lines.end(),
        visit_map_type(), combine_visits(), parse_log_line);
}</pre>
      
      <p class="noind">Assuming you’ve got some function <kbd class="calibre17">parse_log_line</kbd> to extract the relevant information from a log entry <b class="calibre24"><i class="calibre6">1</i></b>, your <kbd class="calibre17">count_visits_per_page</kbd> function is a simple wrapper around a call to <kbd class="calibre17">std::transform_reduce</kbd> <b class="calibre24"><i class="calibre6">2</i></b>. The complexity comes from the <i class="calibre6">reduction</i> operation: you need to be able to combine two <kbd class="calibre17">log_info</kbd> structures to produce a map, a <kbd class="calibre17">log_info</kbd> structure and a map (either way around), and two maps. This therefore means that your <kbd class="calibre17">combine_visits</kbd> function object needs four overloads of the function call operator, <b class="calibre24"><i class="calibre6">3</i></b>, <b class="calibre24"><i class="calibre6">4</i></b>, <b class="calibre24"><i class="calibre6">5</i></b>, and <b class="calibre24"><i class="calibre6">6</i></b>, which precludes doing it with a simple lambda, even though the implementation of these four overloads is simple.
      </p>
      
      <p class="noind">The implementation of <kbd class="calibre17">std::transform_reduce</kbd> will therefore use the available hardware to perform this calculation in parallel (because you passed <kbd class="calibre17">std::execution::par</kbd>). Writing this algorithm manually is nontrivial, as we saw in the previous chapter, so this allows you to delegate the hard
         work of implementing the parallelism to the Standard Library implementers, so you can focus on the required outcome.
      </p>
      
      
      
      
      <h3 id="ch10lev1sec4" class="chapter"><a id="ch10lev1sec4__title" class="calibre3"></a>Summary
      </h3>
      
      <p class="noind">In this chapter we looked at the parallel algorithms available in the C++ Standard Library and how to use them. We looked
         at the various execution policies, the impact your choice of execution policy has on the behavior of the algorithm, and the
         restrictions it imposes on your code. We then looked at an example of how this algorithm might be used in real code.
      </p>
      
      
      
      
      <div class="calibre13" id="calibre_pb_32"></div>
</body></html>
