<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Common Checksum Functions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part496.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part498.htm">下一个 &gt;</a></p><p class="s32" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Common Checksum Functions</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">A number of different functions are used to compute checksums, and vary in strength (i.e., how good they are at protecting data integrity) and speed (i.e., how quickly can they be computed). A trade-off that is com- mon in systems arises here: usually, the more protection you get, the costlier it is. There is no such thing as a free lunch.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One simple checksum function that some use is based on exclusive or (XOR). With XOR-based checksums, the checksum is computed sim- ply by XOR’ing each chunk of the data block being checksummed, thus producing a single value that represents the XOR of the entire block.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To make this more concrete, imagine we are computing a 4-byte check- sum over a block of 16 bytes (this block is of course too small to really be a disk sector or block, but it will serve for the example). The 16 data bytes, in hex, look like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">365e c4cd ba14 8a92 ecef 2c3a 40be f666</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 52pt;text-indent: 0pt;text-align: justify;">If we view them in binary, we get the following:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:38.5799pt" cellspacing="0"><tr style="height:8pt"><td style="width:90pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">0011 0110 0101 1110</p></td><td style="width:91pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">1100 0100 1100 1101</p></td></tr><tr style="height:8pt"><td style="width:90pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">1011 1010 0001 0100</p></td><td style="width:91pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">1000 1010 1001 0010</p></td></tr><tr style="height:8pt"><td style="width:90pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">1110 1100 1110 1111</p></td><td style="width:91pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">0010 1100 0011 1010</p></td></tr><tr style="height:8pt"><td style="width:90pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">0100 0000 1011 1110</p></td><td style="width:91pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 6pt;text-align: right;">1111 0110 0110 0110</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Because we’ve lined up the data in groups of 4 bytes per row, it is easy to see what the resulting checksum will be: simply perform an XOR over each column to get the final checksum value:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">0010 0000 0001 1011  1001 0100 0000 0011</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 52pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">The result, in hex, is 0x201b9403.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">XOR is a reasonable checksum but has its limitations. If, for example, two bits in the same position within each checksummed unit change, the checksum will not detect the corruption. For this reason, people have investigated other checksum functions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Another simple checksum function is addition. This approach has the advantage of being fast; computing it just requires performing 2’s- complement addition over each chunk of the data, ignoring overflow. It can detect many changes in data, but is not good if the data, for example, is shifted.</p><p class="s57" style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;"><span class="p">A slightly more complex algorithm is known as the </span><span class="s27">Fletcher check- sum</span><span class="p">, named (as you might guess) for the inventor, John G. Fletcher [F82]. It is quite simple and involves the computation of two check bytes, </span><span class="s43">s</span><span class="s44">1 </span><span class="p">and </span><span class="s43">s</span><span class="s44">2</span><span class="p">. Specifically, assume a block </span><span class="s43">D </span><span class="p">consists of bytes </span><span class="s43">d</span><span class="s44">1 </span><span class="p">... </span><span class="s43">dn</span><span class="p">; </span><span class="s43">s</span><span class="s44">1 </span><span class="p">is </span><span class="s61">simply defined as follows: </span>s<span class="s59">1 = </span>s<span class="s59">1 + </span>d<span class="s58">i </span>mod <span class="s59">255 </span><span class="s61">(computed over all </span>d<span class="s58">i</span><span class="s61">); </span>s<span class="s59">2 </span><span class="s61">in turn is: </span>s<span class="s59">2 = </span>s<span class="s59">2 + </span>s<span class="s59">1 </span>mod <span class="s59">255 </span><span class="s61">(again over all </span>d<span class="s58">i</span><span class="s61">) [F04]. The fletcher </span><span class="p">checksum is known to be almost as strong as the CRC (described next), detecting all single-bit errors, all double-bit errors, and a large percentage of burst errors [F04].</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One final commonly-used checksum is known as a <b>cyclic redundancy check </b>(<b>CRC</b>). While this sounds fancy, the basic idea is quite simple. As- sume you wish to compute the checksum over a data block <span class="s43">D</span>. All you do is treat <span class="s43">D </span>as if it is a large binary number (it is just a string of bits after all) and divide it by an agreed upon value (<span class="s43">k</span>). The remainder of this division is the value of the CRC. As it turns out, one can implement this binary modulo operation rather efficiently, and hence the popularity of the CRC in networking as well. See elsewhere for more details [M13].</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Whatever the method used, it should be obvious that there is no per- fect checksum: it is possible two data blocks with non-identical contents will have identical checksums, something referred to as a <b>collision</b>. This fact should be intuitive: after all, computing a checksum is taking some- thing large (e.g., 4KB) and producing a summary that is much smaller (e.g., 4 or 8 bytes). In choosing a good checksum function, we are thus trying to find one that minimizes the chance of collisions while remain- ing easy to compute.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part496.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part498.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
