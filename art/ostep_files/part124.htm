<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>14.1 Types of Memory</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part123.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part125.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">14.1 Types of Memory</p><p style="padding-top: 4pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In running a C program, there are two types of memory that are allo- cated. The first is called <b>stack </b>memory, and allocations and deallocations of it are managed <i>implicitly </i>by the compiler for you, the programmer; for this reason it is sometimes called <b>automatic </b>memory.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">Declaring memory on the stack in C is easy. For example, let’s say you need some space in a function <span class="s41">func() </span>for an integer, called <span class="s41">x</span>. To declare such a piece of memory, you just do something like this:</p><p class="s38" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">void func() {</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">int x; // declares an integer on the stack</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">...</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The compiler does the rest, making sure to make space on the stack when you call into <span class="s41">func()</span>. When your return from the function, the compiler deallocates the memory for you; thus, if you want some infor- mation to live beyond the call invocation, you had better not leave that information on the stack.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">It is this need for long-lived memory that gets us to the second type of memory, called <b>heap </b>memory, where all allocations and deallocations</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_134.png"/></span></p><p class="s11" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1<span class="s12">Indeed, we hope all chapters are! But this one is shorter and pointier, we think.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">119</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">are <i>explicitly </i>handled by you, the programmer. A heavy responsibility, no doubt! And certainly the cause of many bugs. But if you are careful and pay attention, you will use such interfaces correctly and without too much trouble. Here is an example of how one might allocate a pointer to an integer on the heap:</p><p class="s38" style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">void func() {</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;line-height: 8pt;text-align: left;">int <span class="s39">*</span>x = (int <span class="s39">*</span>) malloc(sizeof(int));</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;line-height: 8pt;text-align: left;">...</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 4pt;padding-left: 80pt;text-indent: 0pt;text-align: left;">A couple of notes about this small code snippet. First, you might no-</p><p class="s41" style="padding-left: 68pt;text-indent: 0pt;line-height: 86%;text-align: justify;"><span class="p">tice that both stack and heap allocation occur on this line: first the com- piler knows to make room for a pointer to an integer when it sees your declaration of said pointer (</span>int <span class="s86">*</span>x<span class="p">); subsequently, when the program calls </span>malloc()<span class="p">, it requests space for an integer on the heap; the routine returns the address of such an integer (upon success, or </span>NULL <span class="p">on failure), which is then stored on the stack for use by the program.</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Because of its explicit nature, and because of its more varied usage, heap memory presents more challenges to both users and systems. Thus, it is the focus of the remainder of our discussion.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part123.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part125.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
