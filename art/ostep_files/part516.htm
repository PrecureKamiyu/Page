<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Other Issues</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part515.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part517.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">Other Issues</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">There are some other issues an RPC run-time must handle as well. For example, what happens when a remote call takes a long time to com- plete? Given our timeout machinery, a long-running remote call might appear as a failure to a client, thus triggering a retry, and thus the need for some care here. One solution is to use an explicit acknowledgment (from the receiver to sender) when the reply isn’t immediately generated; this lets the client know the server received the request. Then, after some time has passed, the client can periodically ask whether the server is still working on the request; if the server keeps saying “yes”, the client should be happy and continue to wait (after all, sometimes a procedure call can take a long time to finish executing).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The run-time must also handle procedure calls with large arguments, larger than what can fit into a single packet. Some lower-level network protocols provide such sender-side <b>fragmentation </b>(of larger packets into a set of smaller ones) and receiver-side <b>reassembly </b>(of smaller parts into one larger logical whole); if not, the RPC run-time may have to implement such functionality itself. See Birrell and Nelson’s excellent RPC paper for details [BN84].</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One issue that many systems handle is that of <b>byte ordering</b>. As you may know, some machines store values in what is known as <b>big endian </b>ordering, whereas others use <b>little endian </b>ordering. Big endian stores bytes (say, of an integer) from most significant to least significant bits, much like Arabic numerals; little endian does the opposite. Both are equally valid ways of storing numeric information; the question here is how to communicate between machines of <i>different </i>endianness.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="408" height="439" alt="image" src="Image_665.png"/></span></p><p style="padding-top: 2pt;padding-left: 116pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Aside: <b>The End-to-End Argument</b></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The <b>end-to-end argument </b>makes the case that the highest level in a system, i.e., usually the application at “the end”, is ultimately the only locale within a layered system where certain functionality can truly be implemented. In their landmark paper, Saltzer et al. argue this through an excellent example: reliable file transfer between two machines. If you want to transfer a file from machine <span class="s43">A </span>to machine <span class="s43">B</span>, and make sure that the bytes that end up on <span class="s43">B </span>are exactly the same as those that began on <span class="s43">A</span>, you must have an “end-to-end” check of this; lower-level reliable ma- chinery, e.g., in the network or disk, provides no such guarantee.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The contrast is an approach which tries to solve the reliable-file- transfer problem by adding reliability to lower layers of the system. For example, say we build a reliable communication protocol and use it to build our reliable file transfer. The communication protocol guarantees that every byte sent by a sender will be received in order by the receiver, say using timeout/retry, acknowledgments, and sequence numbers. Un- fortunately, using such a protocol does not a reliable file transfer make; imagine the bytes getting corrupted in sender memory before the com- munication even takes place, or something bad happening when the re- ceiver writes the data to disk. In those cases, even though the bytes were delivered reliably across the network, our file transfer was ultimately not reliable. To build a reliable file transfer, one must include end-to- end checks of reliability, e.g., after the entire transfer is complete, read back the file on the receiver disk, compute a checksum, and compare that checksum to that of the file on the sender.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The corollary to this maxim is that sometimes having lower layers pro- vide extra functionality can indeed improve system performance or oth- erwise optimize a system. Thus, you should not rule out having such machinery at a lower-level in a system; rather, you should carefully con- sider the utility of such machinery, given its eventual usage in an overall system or application.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">RPC packages often handle this by providing a well-defined endian- ness within their message formats. In Sun’s RPC package, the <b>XDR </b>(<b>eX- ternal Data Representation</b>) layer provides this functionality. If the ma- chine sending or receiving a message matches the endianness of XDR, messages are just sent and received as expected. If, however, the machine communicating has a different endianness, each piece of information in the message must be converted. Thus, the difference in endianness can have a small performance cost.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A final issue is whether to expose the asynchronous nature of com- munication to clients, thus enabling some performance optimizations. Specifically, typical RPCs are made <b>synchronously</b>, i.e., when a client issues the procedure call, it must wait for the procedure call to return before continuing. Because this wait can be long, and because the client</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">may have other work it could be doing, some RPC packages enable you to invoke an RPC <b>asynchronously</b>. When an asynchronous RPC is is- sued, the RPC package sends the request and returns immediately; the client is then free to do other work, such as call other RPCs or other use- ful computation. The client at some point will want to see the results of the asynchronous RPC; it thus calls back into the RPC layer, telling it to wait for outstanding RPCs to complete, at which point return arguments can be accessed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part515.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part517.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
