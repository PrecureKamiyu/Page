<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>24.2  Log-Structured Merge Tree and Variants</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part435.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part437.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">24.2  <span style=" color: #00AEEF;">Log-Structured Merge Tree and Variants</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">As we saw in Section 14.8, B<span class="s181">+</span>-tree indices are not eﬃcient for workloads with a very high number of writes, and alternative index structures have been proposed to han- dle such workloads. We saw a brief description of two such index structures, the <i>log- structured merge tree </i>or <span class="s44">LSM </span>tree and its variants, in Section 14.8.1, and the <i>buﬀer tree</i>, in Section 14.8.2. In this section we provide further details of the <span class="s44">LSM </span>tree and its vari- ants. To help with the discussions, we repeat some of the basic material we presented in Section 14.8.1.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The key idea of the <span class="s63">log-structured merge tree </span>(<span class="s64">LSM </span><span class="s84">tree</span>) is to replace random <span class="s44">I/O </span>operations during tree inserts, updates, and deletes with a smaller number of sequen- tial <span class="s44">I/O </span>operations. Our initial description focuses on index inserts and lookups; we describe how to handle updates and deletes later in the section.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">An <span class="s44">LSM </span>tree consists of several B<span class="s181">+</span>-trees, starting with an in-memory tree, called <i>L</i><span class="s93">0</span><span class="s94">, and on-disk trees </span><i>L</i><span class="s93">1</span><span class="s94">, </span><i>L</i><span class="s93">2</span><span class="s94">, </span><span class="s15">… </span>, <i>L</i><span class="s145">k </span>for some <i>k</i>, where <i>k </i>is called the level. Figure 24.1 depicts the structure of an <span class="s44">LSM </span>tree for <i>k </i><span class="s15">= </span>3.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 13pt;text-align: justify;">An index lookup is performed by using separate lookup operations on each of the trees <i>L</i><span class="s98">0</span>, <span class="s15">… </span>, <i>L</i><span class="s97">k</span>, and merging the results of the lookups. (We assume here that there are no updates or deletes; we will discuss how to perform lookups in the presence of updates/deletes later.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="240" height="34" alt="image" src="Image_3324.png"/></span></p><p class="s109" style="text-indent: 0pt;line-height: 8pt;text-align: left;">L<span class="s358">0</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s119" style="text-indent: 0pt;line-height: 8pt;text-align: left;">Memory</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="29" alt="image" src="Image_3325.png"/></span></p><p class="s109" style="padding-top: 5pt;padding-left: 45pt;text-indent: 0pt;text-align: center;">L<span class="s358">1</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="47" height="48" alt="image" src="Image_3326.png"/></span></p><p class="s119" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">Disk</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s109" style="padding-left: 46pt;text-indent: 0pt;text-align: center;">L<span class="s358">2</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="69" height="73" alt="image" src="Image_3327.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s109" style="padding-top: 7pt;text-indent: 0pt;text-align: left;">L<span class="s358">3</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 24.1 <span class="s74">Log-structured merge tree with three levels.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">24.2.1 Insertion into LSM Trees</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">When a record is ﬁrst inserted into an <span class="s44">LSM </span>tree, it is inserted into the in-memory B<span class="s181">+</span>- tree structure <i>L</i><span class="s98">0</span>. A fairly large amount of memory space is allocated for this tree. As the tree grows to ﬁll the memory allocated to it, we need to move data from the in-memory structure to a B<span class="s181">+</span>-tree on disk.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If tree <i>L</i><span class="s98">1</span> is empty, the entire in-memory tree <i>L</i><span class="s98">0</span> is written to disk to create the initial tree <i>L</i><span class="s98">1</span>. However, if <i>L</i><span class="s98">1</span> is not empty, the leaf level of <i>L</i><span class="s98">0</span> is scanned in increasing key order, and entries are merged with the leaf level entries of <i>L</i><span class="s98">1</span> (also scanned in increasing key order). The merged entries are used to create a new B<span class="s181">+</span>-tree using the bottom-up build process. The new tree with the merged entries then replaces the old <i>L</i><span class="s98">1</span>. In either case, after entries of <i>L</i><span class="s98">0</span> have been moved to <i>L</i><span class="s98">1</span>, all entries in <i>L</i><span class="s98">0</span> are deleted. Inserts can then be made to the now empty <i>L</i><span class="s98">0</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that all entries in the leaf level of the old <i>L</i><span class="s98">1</span> tree, including those in leaf nodes that do not have any updates, are copied to the new tree instead of being inserted into the existing <i>L</i><span class="s98">1</span> tree node. This gives the following beneﬁts:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 139pt;text-indent: -16pt;text-align: left;"><span class="s39">• </span>The leaves of the new tree are sequentially located, avoiding random <span class="s41">I/O </span>during subsequent merges.</p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s40">The leaves are full, avoiding the overhead of partially occupied leaves that can occur with page splits.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">There is, however, a cost to using the <span class="s44">LSM </span>structure: the entire contents of the tree are copied each time a set of entries from <i>L</i><span class="s98">0</span> are copied into <i>L</i><span class="s98">1</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If the tree structure is implemented on top of a distributed ﬁle system (Section 21.6), copying data to a new tree is often unavoidable, since most distributed ﬁle sys- tems do not support updates to an already created block.</p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;line-height: 94%;text-align: justify;"><span class="p">To ensure we get a beneﬁt for cases where the index size on disk is much bigger than the in-memory index, the maximum size of </span>L<span class="s98">1</span><span class="p"> is chosen as </span>k <span class="p">times the target size of </span>L<span class="s130">0</span><span class="s94">, for some </span>k<span class="p">. Similarly, the maximum size of each </span>L<span class="s97">i</span><span class="s136">+</span><span class="s130">1 </span><span class="s94">is set to </span>k <span class="p">times the target size of </span>L<span class="s145">i</span><span class="p">. Oncea particular </span>L<span class="s145">i </span><span class="p">reaches its maximum size, its entries are merged into the next component </span>L<span class="s145">i</span><span class="s171">+</span><span class="s93">1</span><span class="s94">. When </span>L<span class="s145">i</span><span class="s171">+</span><span class="s93">1 </span><span class="s94">reaches its target size, its entries are in turn merged into </span>L<span class="s97">i</span><span class="s136">+</span><span class="s130">2</span><span class="s94">, and so on.</span></p><p class="s13" style="padding-left: 137pt;text-indent: 0pt;line-height: 75%;text-align: justify;"><span class="p">Note that if each leaf of </span>L<span class="s97">i </span><span class="p">has </span>m <span class="p">entries, </span>m<span class="s15">∕</span>k <span class="p">entries would map to a single leaf</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 87%;text-align: justify;"><span class="p">node of </span>L<span class="s97">i</span><span class="s136">+</span><span class="s130">1</span><span class="s94">. The value of </span>k <span class="p">is chosen to ensure that </span>m<span class="s15">∕</span>k <span class="p">is some reasonable number, say 10. Let </span>M <span class="p">denote the size of </span>L<span class="s98">0</span><span class="p">. Then, the size of a tree at level </span>L<span class="s97">i </span><span class="p">is </span>k<span class="s238">i</span>M <span class="p">. The total number of levels </span>r <span class="p">is thus roughly </span>log<span class="s97">k</span><span class="p">(</span>I <span class="s15">∕</span>M <span class="p">) where </span>I <span class="p">is the total size of the index entries.</span></p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 91%;text-align: justify;">Let us now consider the number of <span class="s44">I/O </span>operations required with a multiple-level <span class="s44">LSM </span>tree. At each <i>L</i><span class="s97">i</span>, <i>m</i><span class="s15">∕</span><i>k </i>inserts are performed using only one <span class="s44">I/O </span>operation. On the other hand, each entry gets inserted once at each level <i>L</i><span class="s97">i</span>. Thus, the total number of <span class="s44">I/O </span>operations for each insert is (<i>k</i><span class="s15">∕</span><i>m</i>)<i>log</i><span class="s97">k</span>(<i>I </i><span class="s15">∕</span><i>M </i>). Thus, as long as the number of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;line-height: 89%;text-align: justify;">levels <i>r </i><span class="s15">= </span><i>log</i><span class="s145">k</span>(<i>I </i><span class="s15">∕</span><i>M </i>) is less than <i>m</i><span class="s15">∕</span><i>k</i>, the overall number of <span class="s44">I/O </span>operations per insert is reduced by using an <span class="s44">LSM </span>tree as compared to direct insertion into a B<span class="s181">+</span>-tree.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If, for example, <i>r </i><span class="s15">= </span>10 and <i>k </i><span class="s15">= </span>10, the in-memory index needs to be greater than 1% of the total index size to get a beneﬁt in terms of the number of <span class="s44">I/O </span>operations required for inserts. (As before, the beneﬁt of reduced seeks is available even if the <i>L</i><span class="s98">0</span> is signiﬁcantly smaller.)</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If the number of levels is greater than <i>m</i><span class="s15">∕</span><i>k</i>, even if there is no beneﬁt in terms of number of <span class="s44">I/O </span>operations, there can still be savings since sequential <span class="s44">I/O </span>is used instead of random <span class="s44">I/O</span>. In Section 24.2.4 we describe a variant of the <span class="s44">LSM </span>tree which further reduces the overhead on write operations, at the cost of adding overhead on read operations.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">One way to avoid creating large <span class="s44">LSM </span>trees with many levels is to <i>range partition </i>the relation and create separate <span class="s44">LSM </span>trees on each partition. Such partitioning is natural in a parallel environment, as we saw earlier in Section 21.2. In particular, in such en- vironments, a partition can be dynamically repartitioned into smaller pieces whenever it becomes too large, as we saw in Section 21.3.3. With such repartitioning, the size of each <span class="s44">LSM </span>tree can be kept small enough to avoid having a large number of levels. There is a price for such partitioning: each partition requires its own <i>L</i><span class="s98">0</span> tree in memory. As a result, although it can be used in a centralized setting, the partitioning approach best ﬁts a parallel environment where resources such as processing nodes can be added as the load increases.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">24.2.2 Rolling Merges</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We assumed for simplicity that when a particular level is full, its entries are entirely merged with the next level. This would result in more <span class="s44">I/O </span>load during merges with an unused <span class="s44">I/O </span>capacity between merges. To avoid this problem, merging is done on a continuous basis; this is called rolling merge.</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 88%;text-align: justify;">With <span class="s63">rolling merge</span>,a few pages of <i>L</i><span class="s145">i </span>are merged into corresponding pages of <i>L</i><span class="s145">i</span><span class="s171">+</span><span class="s93">1 </span><span class="s94">at a time, and removed from </span><i>L</i><span class="s145">i</span>. This is done whenever <i>L</i><span class="s145">i </span>becomes close to its target size, and it results in <i>L</i><span class="s97">i </span>shrinking a bit to return to its target size. When <i>L</i><span class="s97">i </span>grows again, the rolling merge restarts from a point at the leaf level of <i>L</i><span class="s97">i </span>just after where the earlier rolling merge stopped, so the scan is sequential. When the end of the <i>L</i><span class="s97">i </span>tree is reached, the scan starts again at the beginning of the tree. Such a merge is called a rolling merge</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">since records are moved from one level to another on a continuous basis.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The number of leaves merged at a time is kept high enough to ensure that the seek time is small compared to the time to transfer data from and to disk.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">24.2.3 Handling Deletes and Updates</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">So far we have only described inserts and lookups. Deletes are handled in an interesting manner. Instead of directly ﬁnding an index entry and deleting it, deletion results in insertion of a new <span class="s63">deletion entry </span>that indicates which index entry is to be deleted. The</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="290" height="75" alt="image" src="Image_3328.png"/></span></p><p class="s528" style="padding-top: 1pt;text-indent: 0pt;text-align: left;">L<span class="s529">0</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s530" style="padding-top: 1pt;text-indent: 0pt;text-align: left;">Memory</p><p style="text-indent: 0pt;text-align: left;"/><p class="s531" style="text-indent: 0pt;text-align: left;">L <span class="s532">1</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s532" style="text-indent: 0pt;text-align: left;">0</p><p style="text-indent: 0pt;text-align: left;"/><p class="s531" style="text-indent: 0pt;text-align: left;">L<span class="s533">k</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s532" style="text-indent: 0pt;text-align: left;">0</p><p style="text-indent: 0pt;text-align: left;"/><p class="s530" style="padding-top: 1pt;text-indent: 0pt;text-align: left;">Disk</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="149" height="55" alt="image" src="Image_3329.png"/></span></p><p class="s531" style="padding-top: 1pt;text-indent: 0pt;line-height: 66%;text-align: left;">L <span class="s532">1</span></p><p class="s532" style="padding-left: 4pt;text-indent: 0pt;line-height: 4pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s531" style="text-indent: 0pt;text-align: left;">L<span class="s533">k</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s532" style="text-indent: 0pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="208" height="84" alt="image" src="Image_3330.png"/></span></p><p class="s531" style="padding-top: 1pt;text-indent: 0pt;line-height: 66%;text-align: left;">L <span class="s532">1</span></p><p class="s532" style="padding-left: 4pt;text-indent: 0pt;line-height: 4pt;text-align: left;">2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s531" style="text-indent: 0pt;text-align: left;">L<span class="s533">k</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s532" style="text-indent: 0pt;text-align: left;">2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s73" style="padding-top: 4pt;padding-left: 229pt;text-indent: 0pt;text-align: left;">Figure 24.2 <span class="s74">stepped-merge index</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">process of inserting a deletion entry is identical to the process of inserting a normal index entry.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">However, lookups have to carry out an extra step. As mentioned earlier, lookups retrieve entries from all the trees and merge them in sorted order of key value. If there is a deletion entry for some entry, both of them would have the same key value. Thus, a lookup would ﬁnd both the deletion entry and the original entry for that key, which is to be deleted. If a deletion entry is found, the to-be-deleted entry should be ﬁltered out and not returned as part of the lookup result.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">When trees are merged, if one of the trees contains an entry, and the other had a matching deletion entry, the entries get matched up during the merge (both would have the same key), and are both discarded.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Updates are handled in a manner similar to deletes, by inserting an update entry. Lookups need to match update entries with the original entries and return the latest value. The update is actually applied during a merge, when one tree has an entry and another has its matching update entry; the update is applied during the merge, and the update entry is discarded.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">24.2.4 The Stepped-Merge Index</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We now consider a variant of the <span class="s44">LSM </span>tree, which has multiple trees at each level instead of one tree per level and performs inserts in a slightly diﬀerent manner. This structure is shown in Figure 24.2. We call the structure a <span class="s63">stepped-merge index</span>, following the terminology in an early paper that introduced it. In the developer community, the basic <span class="s44">LSM </span>tree, the stepped-merge index, and several other variants are all referred to as <span class="s44">LSM </span>trees. We use the terms <i>stepped-merge index </i>and <i>basic </i><span class="s101">LSM </span><i>tree </i>to clearly identify which variant we are referring to.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">24.2.4.1 Insertion Algorithm</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In the stepped-merge index, incoming data are initially stored in memory, in an <i>L</i><span class="s98">0</span> tree, in a manner similar to the <span class="s44">LSM </span>tree. However, when the tree reaches its maximum size, instead of merging it into an <i>L</i><span class="s98">1</span> tree, the in-memory <i>L</i><span class="s98">0</span> tree is written to disk. When the in-memory tree again reaches its maximum size, it is again written to disk. Thus,</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">we may have multiple <i>L</i><span class="s98">0</span> trees on disk, which we shall refer to as <i>L</i><span class="s76">1</span>, <i>L</i><span class="s76">2</span> and so forth.</p><p class="s13" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span class="p">Each of the </span>L<span class="s238">i</span>      <span class="s181">+</span></p><p class="s119" style="text-indent: 0pt;line-height: 8pt;text-align: center;">0  0</p><p class="s42" style="padding-left: 153pt;text-indent: 0pt;line-height: 1pt;text-align: left;">I/O</p><p style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">operations.</p><p class="s359" style="padding-left: 10pt;text-indent: 0pt;line-height: 77%;text-align: left;">0 <span class="s94">trees is a B</span></p><p style="padding-left: 3pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-tree and can be written to disk using only sequential</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If this process is repeated, after a while we would have a large number of trees, each as large as memory, stored on disk. Lookups would then have to pay a high price, since they would have to search through each of the tree structures, incurring separate <span class="s44">I/O </span>costs on each search.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">To limit the overhead on lookups, once the number of on-disk trees at a level <i>L</i><span class="s97">i </span>reaches some limit <i>k</i>, all the trees at a level are merged together into one combined new tree structure at the next level <i>L</i><span class="s97">i</span><span class="s136">+</span><span class="s130">1</span><span class="s94">. The leaves of the trees at level </span><i>L</i><span class="s97">i </span>are read sequentially, and the keys merged in sorted order, and the level <i>L</i><span class="s97">i</span><span class="s136">+</span><span class="s130">1 </span><span class="s94">tree is constructed using standard techniques for bottom-up construction of B</span><span class="s181">+</span>-trees. As before, the merge operation avoids random <span class="s44">I/O </span>operations, since it reads the individual tree structures sequentially and writes the resultant merged tree also sequentially.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Once a set of trees are merged into a single new tree, future queries can search the merged tree; the original trees can then be deleted (after ensuring any ongoing searches have completed).</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The beneﬁt of the stepped-merge index scheme as compared to the basic <span class="s44">LSM </span>tree is that index entries are written out only once per level. With the basic <span class="s44">LSM </span>tree, each time a tree at level <i>L</i><span class="s145">i </span>is merged into a tree at level <i>L</i><span class="s145">i</span><span class="s171">+</span><span class="s93">1</span><span class="s94">, the entire contents of the </span><i>L</i><span class="s145">i</span><span class="s171">+</span><span class="s93">1 </span><span class="s94">tree is read and written back to disk. Thus, on average, each record is read and written back </span><i>k</i><span class="s15">∕</span>2 times at each level of an <span class="s44">LSM </span>tree for a total of <i>klog</i><span class="s97">k</span>(<i>I </i><span class="s15">∕</span><i>M </i>) <span class="s44">I/O </span>operations. In contrast, with stepped-merge index, each record is written to disk once per layer, and</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 94%;text-align: right;">read again when merging into the next layer, for a total of approximately 2<i>log</i><span class="s97">k </span>(<i>I </i><span class="s15">∕</span><i>M </i>) <span class="s44">I/O </span>operations. Thus, the stepped-merge index incurs signiﬁcantly less cost for updates. The total number of bytes written (across all levels) on account of inserting an</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">entry, divided by the size of entry, is called the <span class="s63">write ampliﬁcation</span>. To calculate the write ampliﬁcation of the <span class="s44">LSM </span>trees and the stepped-merge index, we can modify the above formulae for <span class="s44">I/O </span>operations by ignoring the reads. For a B<span class="s181">+</span>-tree where each leaf gets on average only one update before it is written back, the write ampliﬁcation would be the size of the page divided by the size of the index entry.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">For a B<span class="s181">+</span>-tree, if a page has 100 entries, the write ampliﬁcation would be 100. With</p><p style="padding-top: 2pt;padding-left: 88pt;text-indent: 0pt;line-height: 76%;text-align: justify;"><i>k </i><span class="s15">= </span>5, and <i>I </i><span class="s15">= </span>100<i>M </i>, we would have <i>log</i><span class="s98">5</span>(100) <span class="s15">= </span>3 levels. The write ampliﬁcation of an <span class="s44">LSM </span>tree would then be 5<span class="s15">∕</span>2<span class="s15">×</span>3 <span class="s15">= </span>7<span class="s83">.</span>5. The write ampliﬁcation of the stepped-merge index would be 3. With <i>k </i><span class="s15">= </span>10, the tree would have <i>log</i><span class="s98">10</span>(100) <span class="s15">= </span>2 levels, leading to a</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">write ampliﬁcation of 2 for stepped-merge index, and 10 for an <span class="s44">LSM </span>tree.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that like the basic <span class="s44">LSM </span>tree, the stepped-merge index also requires no ran- dom <span class="s44">I/O </span>operations during insertion, in contrast to a B<span class="s181">+</span>-tree insertion. Thus, the per- formance of B<span class="s181">+</span>-trees would be worse than what the write ampliﬁcation number above indicates.</p><p class="s13" style="padding-top: 2pt;padding-left: 119pt;text-indent: 17pt;line-height: 76%;text-align: justify;"><span class="p">Merging can be optimized as follows: While merging </span>k <span class="p">trees at a particular level </span>L<span class="s145">i</span><span class="p">, intoa level </span>L<span class="s145">i</span><span class="s171">+</span><span class="s93">1 </span><span class="s94">tree, trees at levels </span>L<span class="s145">j </span><span class="p">, </span>j <span class="s83">&lt; </span>i <span class="p">can also be merged in at the same time. Entries in these trees can thus entirely skip one or more levels of the stepped-merge</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">index. Further, if the system has idle capacity, trees at a level <i>L</i><span class="s145">i </span>can be merged even if there are fewer than <i>k </i>trees at that level. In a situation where there is a long period of time with very few inserts, and the system load is light, trees across all levels could potentially get merged into a single tree at some level <i>r</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">24.2.4.2 Lookup Operations Using Bloom Filters</p><p class="s13" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="p">Lookup operations in stepped-merge index have to separately search each of the trees. Thus, compared to the basic </span><span class="s44">LSM </span><span class="p">scheme, the stepped-merge index increases the bur- den on lookups, since in the worst case lookups need to access </span>k <span class="p">trees at each level, leading to a total of </span>k <span class="s15">∗ </span>log<span class="s97">k</span><span class="p">(</span>I <span class="s15">∕</span>M <span class="p">) tree lookups, instead of </span>log<span class="s97">k</span><span class="p">(</span>I <span class="s15">∕</span>M <span class="p">) tree lookups in</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">the worst case with a basic <span class="s44">LSM </span>tree.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For workloads with a signiﬁcant fraction of reads, this overhead can be unaccept- able. For example, with the stepped-merge index with <i>I </i><span class="s15">= </span>100<i>M </i>and <i>k </i><span class="s15">= </span>5, a single lookup requires 15 tree traversals, while the <span class="s44">LSM </span>tree would require 3 tree traversals. Note that for the common case where each key value occurs in only one tree, only one of the traversals would ﬁnd a given search key, while all the other traversals would fail to ﬁnd the key.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To reduce the cost of point lookups (i.e., lookups of a given key value), most sys- tems use a Bloom ﬁlter to check if a tree can possibly contain the given key value. One Bloom ﬁlter is associated with each tree, and it is built on the set of key values in the tree. To check if a particular tree may contain a search key <i>v</i>, the key <i>v </i>is looked up in the Bloom ﬁlter. If the Bloom ﬁlter indicates that the key value is absent, it is deﬁnitely not present in the tree, and lookup can skip that tree. Otherwise, the key value may be present in the tree, which must be looked up.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A Bloom ﬁlter with 10<i>n </i>bits, where the tree has <i>n </i>elements, and using 7 hash functions would give a false positive rate of 1 percent. Thus, for a lookup on a key that is present in the index, on average just slightly more than one tree would be accessed. Thus, lookup performance would be only slightly worse than on a regular B<span class="s181">+</span>-tree.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The Bloom ﬁlter check thus works very well for point lookups, allowing a signiﬁcant fraction of the trees to be skipped, as long as suﬃcient memory is available to store all the Bloom ﬁlters in memory. With <i>I </i>key values in the index, approximately 10<i>I </i>bits of memory will be required. To reduce the main memory overhead, some of the Bloom ﬁlters may be stored on ﬂash storage.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that for range lookups, the Bloom ﬁlter optimization cannot be used, since there is no unique hash value. Instead, all trees must be accessed separately.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><a name="bookmark545">24.2.5 LSM Trees For Flash Storage</a><a name="bookmark575">&zwnj;</a></p><p class="s42" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">LSM <span class="s43">trees were initially designed to reduce the write and seek overheads of hard disks. Flash disks have a relatively low overhead for random </span>I/O <span class="s43">operations since they do not require seek, and thus the beneﬁt of avoiding random </span>I/O <span class="s43">that </span>LSM <span class="s43">tree variants provide is not particularly important with ﬂash disks.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">However, recall that ﬂash memory does not allow in-place update, and writing even a single byte to a page requires the whole page to be rewritten to a new physical location; the original location of the page needs to be erased eventually, which is a relatively expensive operation. The reduction in write ampliﬁcation using <span class="s44">LSM </span>tree variants, as compared to traditional B<span class="s181">+</span>-trees, can provide substantial performance beneﬁts when <span class="s44">LSM </span>trees are used with ﬂash storage.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part435.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part437.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
