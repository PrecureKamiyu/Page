<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>Chapter 3 Machine-Level Representation of Programs</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section class="pcalibre halftitlepage pcalibre1" id="P7000497027000000000000000001DCE" epub:type="chapter"><header class="calibre24 pcalibre pcalibre1"><h1 class="title4 pcalibre pcalibre1" id="P700049702700000000000000004004A" data-uri="chapter03.xhtml#P700049702700000000000000004004A" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001DD0" title="163" data-uri="chapter03.xhtml#P7000497027000000000000000001DD0" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre number1 pcalibre1">3 </span>Machine-Level Representation of Programs</h1></header>
<section class="pcalibre halftitlepage pcalibre1" id="d9e52564">
<nav class="pcalibre halftitlepage pcalibre1" id="P700049702700000000000000004004B" data-uri="chapter03.xhtml#P700049702700000000000000004004B" epub:type="toc">
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000004004C" data-uri="chapter03.xhtml#P700049702700000000000000004004C">
<ol class="tocentrylist pcalibre pcalibre1" id="P700049702700000000000000004004D" data-uri="chapter03.xhtml#P700049702700000000000000004004D">
<li id="P700049702700000000000000004004E" data-uri="chapter03.xhtml#P700049702700000000000000004004E" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P700049702700000000000000004004F" data-uri="chapter03.xhtml#P700049702700000000000000004004F" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000001E06.xhtml#P7000497027000000000000000001E06"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.1 </span>A Historical Perspective </span><span class="pcalibre pcalibre1" epub:type="pagebreak">166</span></a></p></li>
<li id="P7000497027000000000000000040050" data-uri="chapter03.xhtml#P7000497027000000000000000040050" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P7000497027000000000000000040051" data-uri="chapter03.xhtml#P7000497027000000000000000040051" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000001E38.xhtml#P7000497027000000000000000001E38"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.2 </span>Program Encodings</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">169</span></a></p></li>
<li id="P7000497027000000000000000040052" data-uri="chapter03.xhtml#P7000497027000000000000000040052" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P7000497027000000000000000040053" data-uri="chapter03.xhtml#P7000497027000000000000000040053" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000001EF2.xhtml#P7000497027000000000000000001EF2"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.3 </span>Data Formats</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">177</span></a></p></li>
<li id="P7000497027000000000000000040054" data-uri="chapter03.xhtml#P7000497027000000000000000040054" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P7000497027000000000000000040055" data-uri="chapter03.xhtml#P7000497027000000000000000040055" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000001F3C.xhtml#P7000497027000000000000000001F3C"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.4 </span>Accessing Information</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">179</span></a></p></li>
<li id="P7000497027000000000000000040056" data-uri="chapter03.xhtml#P7000497027000000000000000040056" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P7000497027000000000000000040057" data-uri="chapter03.xhtml#P7000497027000000000000000040057" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002185.xhtml#P7000497027000000000000000002185"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.5 </span>Arithmetic and Logical Operations</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">191</span></a></p></li>
<li id="P7000497027000000000000000040058" data-uri="chapter03.xhtml#P7000497027000000000000000040058" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P7000497027000000000000000040059" data-uri="chapter03.xhtml#P7000497027000000000000000040059" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002339"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.6 </span>Control</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">200</span></a></p></li>
<li id="P700049702700000000000000004005A" data-uri="chapter03.xhtml#P700049702700000000000000004005A" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P700049702700000000000000004005B" data-uri="chapter03.xhtml#P700049702700000000000000004005B" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000281F.xhtml#P700049702700000000000000000281F"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.7 </span>Procedures</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">238</span></a></p></li>
<li id="P700049702700000000000000004005C" data-uri="chapter03.xhtml#P700049702700000000000000004005C" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P700049702700000000000000004005D" data-uri="chapter03.xhtml#P700049702700000000000000004005D" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002B19.xhtml#P7000497027000000000000000002B19"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.8 </span>Array Allocation and Access</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">255</span></a></p></li>
<li id="P700049702700000000000000004005E" data-uri="chapter03.xhtml#P700049702700000000000000004005E" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P700049702700000000000000004005F" data-uri="chapter03.xhtml#P700049702700000000000000004005F" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002CDB.xhtml#P7000497027000000000000000002CDB"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.9 </span>Heterogeneous Data Structures</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">265</span></a></p></li>
<li id="P7000497027000000000000000040060" data-uri="chapter03.xhtml#P7000497027000000000000000040060" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P7000497027000000000000000040061" data-uri="chapter03.xhtml#P7000497027000000000000000040061" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000002E6D"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.10 </span>Combining Control and Data in Machine-Level Programs</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">276</span></a></p></li>
<li id="P7000497027000000000000000040062" data-uri="chapter03.xhtml#P7000497027000000000000000040062" class="tocpreface pcalibre pcalibre1" data-class="toclevel1"><p id="P7000497027000000000000000040063" data-uri="chapter03.xhtml#P7000497027000000000000000040063" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000003080.xhtml#P7000497027000000000000000003080"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.11 </span>Floating-Point Code</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">293</span></a></p></li>
</ol>
</div>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000040064" data-uri="chapter03.xhtml#P7000497027000000000000000040064">
<ol class="tocentrylist pcalibre pcalibre1" id="P7000497027000000000000000040065" data-uri="chapter03.xhtml#P7000497027000000000000000040065">
<li class="tocpreface pcalibre pcalibre1" id="P7000497027000000000000000040066" data-uri="chapter03.xhtml#P7000497027000000000000000040066"><p id="P7000497027000000000000000040067" data-uri="chapter03.xhtml#P7000497027000000000000000040067" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000032D2.xhtml#P70004970270000000000000000032D2"><span class="pcalibre pcalibre1" epub:type="title"><span class="pcalibre label pcalibre1">3.12 </span><span class="pcalibre label pcalibre1">Summary</span> </span><span class="pcalibre pcalibre1" epub:type="pagebreak">309</span></a></p></li>
<li class="tocpreface pcalibre pcalibre1" id="P7000497027000000000000000040068" data-uri="chapter03.xhtml#P7000497027000000000000000040068"><p id="P7000497027000000000000000040069" data-uri="chapter03.xhtml#P7000497027000000000000000040069" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000032D9.xhtml#P70004970270000000000000000032D9"><span class="pcalibre pcalibre1" epub:type="title">Bibliographic Notes </span><span class="pcalibre pcalibre1" epub:type="pagebreak">310</span></a></p></li>
<li class="tocpreface pcalibre pcalibre1" id="P700049702700000000000000004006A" data-uri="chapter03.xhtml#P700049702700000000000000004006A"><p id="P700049702700000000000000004006B" data-uri="chapter03.xhtml#P700049702700000000000000004006B" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000032E1.xhtml#P70004970270000000000000000032E1"><span class="pcalibre pcalibre1" epub:type="title">Homework Problems </span><span class="pcalibre pcalibre1" epub:type="pagebreak">311</span></a></p></li>
<li class="tocpreface pcalibre pcalibre1" id="P700049702700000000000000004006C" data-uri="chapter03.xhtml#P700049702700000000000000004006C"><p id="P700049702700000000000000004006D" data-uri="chapter03.xhtml#P700049702700000000000000004006D" class="pcalibre calibre3 pcalibre1"><a class="xref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000344D_split_000.xhtml#P700049702700000000000000000344D"><span class="pcalibre pcalibre1" epub:type="title">Solutions to Practice Problems</span>	<span class="pcalibre pcalibre1" epub:type="pagebreak">325</span></a></p></li>
</ol>
</div></nav>

<section id="P700049702700000000000000004006E" data-uri="chapter03.xhtml#P700049702700000000000000004006E" epub:type="introduction" class="introduction pcalibre pcalibre1">
<p id="P700049702700000000000000004006F" data-uri="chapter03.xhtml#P700049702700000000000000004006F" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001DF6" title="164" data-uri="chapter03.xhtml#P7000497027000000000000000001DF6" epub:type="pagebreak"></span>Computers execute <i class="calibre5 pcalibre pcalibre1">machine code</i>, sequences of bytes encoding the low-level operations that manipulate data, manage memory, read and write data on storage devices, and communicate over networks. A compiler generates machine code through a series of stages, based on the rules of the programming language, the instruction set of the target machine, and the conventions followed by the operating system. The <span class="smallcaps pcalibre pcalibre1">gcc </span>C compiler generates its output in the form of <i class="calibre5 pcalibre pcalibre1">assembly code</i>, a textual representation of the machine code giving the individual instructions in the program. <span class="smallcaps pcalibre pcalibre1">Gcc </span>then invokes both an <i class="calibre5 pcalibre pcalibre1">assembler</i> and a <i class="calibre5 pcalibre pcalibre1">linker</i> to generate the executable machine code from the assembly code. In this chapter, we will take a close look at machine code and its human-readable representation as assembly code.</p>
<p id="P7000497027000000000000000040070" data-uri="chapter03.xhtml#P7000497027000000000000000040070" class="pcalibre1 pcalibre calibre2">When programming in a high-level language such as C, and even more so in Java, we are shielded from the detailed machine-level implementation of our program. In contrast, when writing programs in assembly code (as was done in the early days of computing) a programmer must specify the low-level instructions the program uses to carry out a computation. Most of the time, it is much more productive and reliable to work at the higher level of abstraction provided by a high-level language. The type checking provided by a compiler helps detect many program errors and makes sure we reference and manipulate data in consistent ways. With modern optimizing compilers, the generated code is usually at least as efficient as what a skilled assembly-language programmer would write by hand. Best of all, a program written in a high-level language can be compiled and executed on a number of different machines, whereas assembly code is highly machine specific.</p>
<p id="P7000497027000000000000000040071" data-uri="chapter03.xhtml#P7000497027000000000000000040071" class="pcalibre1 pcalibre calibre2">So why should we spend our time learning machine code? Even though compilers do most of the work in generating assembly code, being able to read and understand it is an important skill for serious programmers. By invoking the compiler with appropriate command-line parameters, the compiler will generate a file showing its output in assembly-code form. By reading this code, we can understand the optimization capabilities of the compiler and analyze the underlying inefficiencies in the code. As we will experience in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004893.xhtml#P7000497027000000000000000004893"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">5</span></a>, programmers seeking to maximize the performance of a critical section of code often try different variations of the source code, each time compiling and examining the generated assembly code to get a sense of how efficiently the program will run. Furthermore, there are times when the layer of abstraction provided by a high-level language hidesinformationabouttherun-timebehaviorofaprogramthatweneedtounder-stand. For example, when writing concurrent programs using a thread package, as covered in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">12</span></a>, it is important to understand how program data are shared or kept private by the different threads and precisely how and where shared data are accessed. Such information is visible at the machine-code level. As another example, many of the ways programs can be attacked, allowing malware to infest a system, involve nuances of the way programs store their run-time control information. Many attacks involve exploiting weaknesses in system programs to overwrite information and thereby take control of the system. Understanding how these vulnerabilities arise and how to guard against them requires a knowledge of the machine-level representation of programs. The need for programmers to learn <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001E01" title="165" data-uri="chapter03.xhtml#P7000497027000000000000000001E01" epub:type="pagebreak"></span>machine code has shifted over the years from one of being able to write programs directly in assembly code to one of being able to read and understand the code generated by compilers.</p>
<p id="P7000497027000000000000000040072" data-uri="chapter03.xhtml#P7000497027000000000000000040072" class="pcalibre1 pcalibre calibre2">In this chapter, we will learn the details of one particular assembly language and see how C programs get compiled into this form of machine code. Reading the assembly code generated by a compiler involves a different set of skills than writing assembly code by hand. We must understand the transformations typical compilers make in converting the constructs of C into machine code. Relative to the computations expressed in the C code, optimizing compilers can rearrange execution order, eliminate unneeded computations, replace slow operations with faster ones, and even change recursive computations into iterative ones. Understanding the relation between source code and the generated assembly can often be a challenge—it's much like putting together a puzzle having a slightly different design than the picture on the box. It is a form of <i class="calibre5 pcalibre pcalibre1">reverse engineering</i>—trying to understand the process by which a system was created by studying the system and working backward. In this case, the system is a machine-generated assembly-language program, rather than something designed by a human. This simplifies the task of reverse engineering because the generated code follows fairly regular patterns and we can run experiments, having the compiler generate code for many different programs. In our presentation, we give many examples and provide a number of exercises illustrating different aspects of assembly language and compilers. This is a subject where mastering the details is a prerequisite to under-standing the deeper and more fundamental concepts. Those who say "I understand the general principles, I don't want to bother learning the details" are deluding themselves. It is critical for you to spend time studying the examples, working through the exercises, and checking your solutions with those provided.</p>
<p id="P7000497027000000000000000040073" data-uri="chapter03.xhtml#P7000497027000000000000000040073" class="pcalibre1 pcalibre calibre2">Our presentation is based on x86-64, the machine language for most of the processors found in today's laptop and desktop machines, as well as those that power very large data centers and supercomputers. This language has evolved over a long history, starting with Intel Corporation's first 16-bit processor in 1978, through to the expansion to 32 bits, and most recently to 64 bits. Along the way, features have been added to make better use of the available semiconductor technology, and to satisfy the demands of the marketplace. Much of the development has been driven by Intel, but its rival Advanced Micro Devices (AMD) has also made important contributions. The result is a rather peculiar design with features that make sense only when viewed from a historical perspective. It is also laden with features providing backward compatibility that are not used by modern compilers and operating systems. We will focus on the subset of the features used by <span class="smallcaps pcalibre pcalibre1">gcc </span>and Linux. This allows us to avoid much of the complexity and many of the arcane features of x86-64.</p>
<p id="P7000497027000000000000000040074" data-uri="chapter03.xhtml#P7000497027000000000000000040074" class="pcalibre1 pcalibre calibre2">Our technical presentation starts with a quick tour to show the relation between C, assembly code, and machine code. We then proceed to the details of x86-64, starting with the representation and manipulation of data and the implementation of control. We see how control constructs in C, such as <code id="P7000497027000000000000000040075" data-uri="chapter03.xhtml#P7000497027000000000000000040075" class="calibre25 pcalibre pcalibre1">if</code>, <code id="P7000497027000000000000000040076" data-uri="chapter03.xhtml#P7000497027000000000000000040076" class="calibre25 pcalibre pcalibre1">while</code>, and <code id="P7000497027000000000000000040077" data-uri="chapter03.xhtml#P7000497027000000000000000040077" class="calibre25 pcalibre pcalibre1">switch</code> statements, are implemented. We then cover the implementation of procedures, including how the program maintains a run-time stack to support the</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000001DFF" data-uri="chapter03.xhtml#P7000497027000000000000000001DFF"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title7 pcalibre pcalibre1" id="P7000497027000000000000000040078" data-uri="chapter03.xhtml#P7000497027000000000000000040078" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001E09" title="166" data-uri="chapter03.xhtml#P7000497027000000000000000001E09" epub:type="pagebreak"></span><span class="label3 pcalibre pcalibre1">Web Aside ASM:IA32 </span>IA32 programming</h1></header>
<p id="P7000497027000000000000000040079" data-uri="chapter03.xhtml#P7000497027000000000000000040079" class="pcalibre calibre3 pcalibre1">IA32, the 32-bit predecessor to x86-64, was introduced by Intel in 1985. It served as the machine language of choice for several decades. Most x86 microprocessors sold today, and most operating systems installed on these machines, are designed to run x86-64. However, they can also execute IA32 programs in a backward compatibility mode. As a result, many application programs are still based on IA32. In addition, many existing systems cannot execute x86-64, due to limitations of their hardware or system software. IA32 continues to be an important machine language. You will find that having a background in x86-64 will enable you to learn the IA32 machine language quite readily.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004007A" data-uri="chapter03.xhtml#P700049702700000000000000004007A">passing of data and control between procedures, as well as storage for local variables. Next, we consider how data structures such as arrays, structures, and unions are implemented at the machine level. With this background in machine-level programming, we can examine the problems of out-of-bounds memory references and the vulnerability of systems to buffer overflow attacks. We finish this part of the presentation with some tips on using the <span class="smallcaps pcalibre pcalibre1">gdb </span>debugger for examining the run-time behavior of a machine-level program. The chapter concludes with a presentation on machine-program representations of code involving floating-point data and operations.</p>
<p id="P700049702700000000000000004007B" data-uri="chapter03.xhtml#P700049702700000000000000004007B" class="pcalibre1 pcalibre calibre2">The computer industry has recently made the transition from 32-bit to 64-bit machines. A 32-bit machine can only make use of around 4 gigabytes (2<sup class="calibre82 pcalibre pcalibre1">32</sup> bytes) of random access memory, With memory prices dropping at dramatic rates, and our computational demands and data sizes increasing, it has become both economically feasible and technically desirable to go beyond this limitation. Current 64-bit machines can use up to 256 terabytes (2<sup class="calibre82 pcalibre pcalibre1">48</sup> bytes) of memory, and could readily be extended to use up to 16 exabytes (2<sup class="calibre82 pcalibre pcalibre1">64</sup> bytes). Although it is hard to imagine having a machine with that much memory, keep in mind that 4 gigabytes seemed like an extreme amount of memory when 32-bit machines became commonplace in the 1970s and 1980s.</p>
<p id="P700049702700000000000000004007C" data-uri="chapter03.xhtml#P700049702700000000000000004007C" class="pcalibre1 pcalibre calibre2">Our presentation focuses on the types of machine-level programs generated when compiling C and similar programming languages targeting modern operating systems. As a consequence, we make no attempt to describe many of the features of x86-64 that arise out of its legacy support for the styles of programs written in the early days of microprocessors, when much of the code was written manually and where programmers had to struggle with the limited range of addresses allowed by 16-bit machines.</p>
</section>

</section>
<!--EOF:P7000497027000000000000000001E06-->
<!--EOF:P7000497027000000000000000001E38-->
<!--EOF:P7000497027000000000000000001EF2-->
<!--EOF:P7000497027000000000000000001F3C-->
<!--EOF:P7000497027000000000000000002185-->
<!--EOF:P7000497027000000000000000002339-->
<!--EOF:P700049702700000000000000000281F-->
<!--EOF:P7000497027000000000000000002B19-->
<!--EOF:P7000497027000000000000000002CDB-->
<!--EOF:P7000497027000000000000000002E6D-->
<!--EOF:P7000497027000000000000000003080-->

<!--EOF:P70004970270000000000000000032D2-->
<!--EOF:P70004970270000000000000000032D9-->
<!--EOF:P70004970270000000000000000032E1-->
<!--EOF:P700049702700000000000000000344D-->


</section></body></html>
