<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>48.6 From Protocol to Distributed File System</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part524.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part526.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">48.6 From Protocol to Distributed File System</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Hopefully you are now getting some sense of how this protocol is turned into a file system across the client-side file system and the file server. The client-side file system tracks open files, and generally trans- lates application requests into the relevant set of protocol messages. The server simply responds to each protocol message, each of which has all the information needed to complete request.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">For example, let us consider a simple application which reads a file. In the diagram (Figure <span style=" color: #00AEEF;">48.1</span>), we show what system calls the application makes, and what the client-side file system and file server do in respond- ing to such calls.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A few comments about the figure. First, notice how the client tracks all relevant <b>state </b>for the file access, including the mapping of the integer file descriptor to an NFS file handle as well as the current file pointer. This enables the client to turn each read request (which you may have noticed do <i>not </i>specify the offset to read from explicitly) into a properly-formatted read protocol message which tells the server exactly which bytes from the file to read. Upon a successful read, the client updates the current file position; subsequent reads are issued with the same file handle but a different offset.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Second, you may notice where server interactions occur. When the file is opened for the first time, the client-side file system sends a LOOKUP request message. Indeed, if a long pathname must be traversed (e.g.,</p><p class="s41" style="padding-left: 41pt;text-indent: 0pt;line-height: 88%;text-align: justify;">/home/remzi/foo.txt<span class="p">), the client would send three LOOKUPs: one to look up </span>home <span class="p">in the directory </span>/<span class="p">, one to look up </span>remzi <span class="p">in </span>home<span class="p">, and finally one to look up </span>foo.txt <span class="p">in </span>remzi<span class="p">.</span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Third, you may notice how each server request has all the information needed to complete the request in its entirety. This design point is critical to be able to gracefully recover from server failure, as we will now discuss in more detail; it ensures that the server does not need state to be able to respond to the request.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 74pt;text-indent: 0pt;text-align: left;">Client                  Server</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="402" height="1" alt="image" src="Image_672.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 74pt;text-indent: 0pt;line-height: 9pt;text-align: left;">fd = open(”/foo”, ...);</p><p class="s5" style="padding-left: 79pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Send LOOKUP (rootdir FH, ”foo”)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 77pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Receive LOOKUP reply</p><p class="s5" style="padding-left: 81pt;text-indent: 0pt;text-align: left;">allocate file desc in open file table store foo’s FH in table</p><p class="s5" style="padding-left: 81pt;text-indent: 0pt;line-height: 94%;text-align: left;">store current file position (0) return file descriptor to application</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 26pt;text-indent: -4pt;text-align: left;">Receive LOOKUP request look for ”foo” in root dir return foo’s FH + attributes</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="402" height="1" alt="image" src="Image_673.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 74pt;text-indent: 0pt;line-height: 10pt;text-align: left;">read(fd, buffer, MAX);</p><p class="s5" style="padding-left: 81pt;text-indent: -4pt;text-align: left;">Index into open file table with fd get NFS file handle (FH)</p><p class="s5" style="padding-left: 81pt;text-indent: 0pt;line-height: 9pt;text-align: left;">use current file position as offset</p><p class="s5" style="padding-left: 77pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Send READ (FH, offset=0, count=MAX)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-top: 6pt;padding-left: 77pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Receive READ reply</p><p class="s5" style="padding-left: 81pt;text-indent: 0pt;text-align: left;">update file position (+bytes read) set current file position = MAX return data/error code to app</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 9pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Receive READ request</p><p class="s5" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">use FH to get volume/inode num read inode from disk (or cache) compute block location (using offset) read data from disk (or cache)</p><p class="s5" style="padding-left: 14pt;text-indent: 0pt;line-height: 10pt;text-align: left;">return data to client</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="402" height="1" alt="image" src="Image_674.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-top: 3pt;padding-left: 74pt;text-indent: 0pt;line-height: 10pt;text-align: left;">read(fd, buffer, MAX);</p><p class="s5" style="padding-left: 79pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Same except offset=MAX and set current file position = 2*MAX</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="402" height="1" alt="image" src="Image_675.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 74pt;text-indent: 0pt;line-height: 10pt;text-align: left;">read(fd, buffer, MAX);</p><p class="s5" style="padding-left: 79pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Same except offset=2*MAX and set current file position = 3*MAX</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="402" height="1" alt="image" src="Image_676.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 74pt;text-indent: 0pt;line-height: 10pt;text-align: left;">close(fd);</p><p class="s5" style="padding-left: 77pt;text-indent: 0pt;text-align: justify;">Just need to clean up local structures Free descriptor ”fd” in open file table (No need to talk to server)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 85pt;text-indent: 0pt;text-align: left;">Table 48.1: <b>Reading A File: Client-side And File Server Actions</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 85pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: I<span class="s7">DEMPOTENCY </span>I<span class="s7">S </span>P<span class="s7">OWERFUL</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;"><b>Idempotency </b>is a useful property when building reliable systems. When an operation can be issued more than once, it is much easier to handle failure of the operation; you can just retry it. If an operation is <i>not </i>idem- potent, life becomes more difficult.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part524.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part526.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
