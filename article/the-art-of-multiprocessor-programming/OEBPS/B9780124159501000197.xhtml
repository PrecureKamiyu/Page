<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 201" epub:type="pagebreak" id="page_201" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 9: Linked lists: The role of locking</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter uses the example of a list-based set to present several useful techniques for implementing concurrent data structures, starting from simple coarse-grained locking to fine-grained locking to optimistic and lazy synchronization, and finally nonblocking synchronization. It also demonstrates how to reason about the correctness of concurrent data structure implementations by identifying representation invariants, abstraction maps, and linearization points.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">coarse-grained locking; fine-grained locking; optimistic synchronization; lazy synchronization; nonblocking synchronization; wait-free; lock-free; linked lists; concurrent data structures; representation invariants; abstracton map; linearization point</p></section></header><section><h2 class="h1hd" id="s0010"><a id="st0020"/>9.1 Introduction</h2><p class="textfl" id="p0010">In Chapter <a href="B9780124159501000173.xhtml">7</a>, we saw how to build scalable spin locks that provide mutual exclusion efficiently, even when they are heavily used. We might think that it is now a simple matter to construct scalable concurrent data structures: Take a sequential implementation of the class, add a scalable lock field, and ensure that each method call acquires and releases that lock. We call this approach <i>coarse-grained synchronization</i>.</p><p class="text" id="p0015">Coarse-grained synchronization often works well, but there are important cases where it does not. The problem is that a class that uses a single lock to mediate all its method calls is not always scalable, even if the lock itself is scalable. Coarse-grained synchronization works well when levels of concurrency are low, but if too many threads try to access the object at the same time, then the object becomes a sequential bottleneck, forcing threads to wait in line for access.</p><p class="text" id="p0020">This chapter introduces several useful techniques that go beyond coarse-grained locking to allow multiple threads to access a single object at the same time.</p><div><ul><li class="bulllist" id="u0010">•  <i>Fine-grained synchronization:</i> Instead of using a single lock to synchronize every access to an object, we partition the object into independently synchronized components, allowing method calls that access disjoint components to execute concurrently.</li><li class="bulllist" id="u0015">•  <i>Optimistic synchronization:</i> Many objects, such as trees or lists, consist of multiple components linked together by references. Some methods search for a particular component (e.g., a list or tree node containing a particular key). One way to reduce the cost of fine-grained locking is to search without acquiring any locks at all. If the method finds the sought-after component, it locks that component, and then checks that the component has not changed in the interval between when it was inspected and when it was locked. This technique is worthwhile only if it succeeds more often than not, which is why we call it optimistic.</li><li class="bulllist" id="u0020">•  <i>Lazy synchronization:</i> Sometimes it makes sense to postpone hard work. For example, the task of removing a component from a data structure can be split into two phases: The component is <i>logically removed</i> simply by setting a tag bit, and later, the component can be <i>physically removed</i> by unlinking it from the rest of the data structure.</li><li class="bulllist" id="u0025">•  <i>Nonblocking synchronization:</i> Sometimes we can eliminate locks entirely, relying on built-in atomic operations such as <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> for synchronization. <span aria-label="Page 202" epub:type="pagebreak" id="page_202" role="doc-pagebreak"/></li></ul></div><p class="textfl"> Each of these techniques can be applied (with appropriate customization) to a variety of common data structures. In this chapter, we consider how to use linked lists to implement a <i>set</i>, a collection of <i>items</i> that contains no duplicate elements.</p><p class="text" id="p0045">For our purposes, as shown in <a href="#f0010" id="cf0010">Fig. 9.1</a>, a <i>set</i> provides the following three methods:</p><div><ul><li class="bulllist" id="u0030">•  The <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>x</i>) method adds <i>x</i> to the set, returning <i>true</i> if and only if <i>x</i> was not already in the est.</li><li class="bulllist" id="u0035">•  The <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(<i>x</i>) method removes <i>x</i> from the set, returning <i>true</i> if and only if <i>x</i> was in the set.</li><li class="bulllist" id="u0040">•  The <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(<i>x</i>) returns <i>true</i> if and only if the set contains <i>x</i>.</li></ul></div><p class="textfl"> For each method, we say that a call is <i>successful</i> if it returns <i>true</i>, and <i>unsuccessful</i> otherwise. In typical applications using sets, there are significantly more <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() calls than <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() or <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() calls.<span aria-label="Page 203" epub:type="pagebreak" id="page_203" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="76" src="images/B9780124159501000197/gr001.jpg" width="168"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.1</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx002.jpg" width="39"/> interface: <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() adds an item to the set (no effect if that item is already present), <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() removes it (if present), and <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() returns a Boolean indicating whether the item is present.</div></figcaption></figure></div></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>9.2 List-based sets</h2><p class="textfl" id="p0065">This chapter presents a range of concurrent set algorithms, all based on the same basic idea. A set is implemented as a linked list of nodes. The <img alt="Image" height="9" src="images/B9780124159501000197/fx006.jpg" width="46"/> class, shown in <a href="#f0015" id="cf0015">Fig. 9.2</a>, has three fields. The <img alt="Image" height="9" src="images/B9780124159501000197/fx007.jpg" width="25"/> field is the actual item of interest. The <img alt="Image" height="11" src="images/B9780124159501000197/fx008.jpg" width="18"/> field is the item's hash code. Nodes are sorted in <img alt="Image" height="11" src="images/B9780124159501000197/fx008.jpg" width="18"/> order, providing an efficient way to detect when an item is absent. The <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field is a reference to the next node in the list. (Some of the algorithms we consider require changes to this class, such as adding new fields, changing the types of existing fields, or making some fields volatile.) For simplicity, we assume that each item's hash code is unique. (Relaxing this assumption is left as an exercise.) We associate an item with the same node and key throughout any given example, which allows us to abuse notation and use the same symbol to refer to a node, its key, and its item. That is, node <i>a</i> may have key <i>a</i> and item <i>a</i>, and so on.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="76" src="images/B9780124159501000197/gr002.jpg" width="138"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.2</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx006.jpg" width="46"/> class: This internal class keeps track of the item, the item's key, and the next node in the list. Some algorithms require changes to this class.</div></figcaption></figure></div><p class="text" id="p0070">In addition to nodes that hold items in the set, the list contains two <i>sentinel</i> nodes, <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000197/fx014.jpg" width="23"/>, as the first and last nodes in the list. Sentinel nodes are never added, removed, or searched for, and their keys are the minimum and maximum integer values.<sup><a epub:type="noteref" href="#fn001" id="cf0020" role="doc-noteref">1</a></sup> Ignoring synchronization for the moment, the top part of <a href="#f0020" id="cf0025">Fig. 9.3</a> schematically describes how an item is added to the set. A thread uses two local variables to traverse the list: <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> is the current node and <span aria-label="Page 204" epub:type="pagebreak" id="page_204" role="doc-pagebreak"/><img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> is its predecessor. To add an item to the set, a thread sets <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> to <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> to its successor, and moves down the list, comparing <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>'s key to the key of the item being added until it finds a node whose key is greater than or equal to the new item's key. If the keys match, the item is already present in the set, so the call returns <i>false</i>. Otherwise, <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/>'s key is less than that of the new item, and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>'s key is greater, so the item is not present in the list. The method creates a new node <i>b</i> to hold the item, sets <i>b</i>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>, and then sets <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/>'s to <i>b</i>. Removing an item from the set works in a similar way.</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="321" src="images/B9780124159501000197/gr003.jpg" width="385"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.3</span> A sequential <img alt="Image" height="9" src="images/B9780124159501000197/fx010.jpg" width="32"/> implementation: adding and removing nodes. In part (a), a thread adding a node <i>b</i> uses two variables: <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> is the current node, and <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> is its predecessor. The thread moves down the list comparing the keys for <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> and <i>b</i>. If a match is found, the item is already present, so it returns <i>false</i>. If <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> reaches a node with a higher key, the item is not in the set, so it sets <i>b</i>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>, and <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <i>b</i>. In part (b), to delete <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>, the thread sets <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field.</div></figcaption></figure></div></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>9.3 Concurrent reasoning</h2><p class="textfl" id="p0075">Reasoning about concurrent data structures may seem impossibly difficult, but it is a skill that can be learned. Often, the key to understanding a concurrent data structure is to understand its <i>invariants</i>: properties that always hold. We can show that a property is invariant by showing that:</p><div><ol><li class="numlist" id="o0010">1.  the property holds when the object is created, and</li><li class="numlist" id="o0015">2.  once the property holds, no thread can take a step that makes it <i>false</i>.</li></ol></div><p class="textfl"> Most interesting invariants hold trivially when the list is created, so it makes sense to focus on how invariants, once established, are preserved.</p><p class="text" id="p0090">Specifically, we can check that each invariant is preserved by each invocation of <img alt="Image" height="9" src="images/B9780124159501000197/fx015.jpg" width="38"/>(), <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(), and <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() methods. This approach works only if we can assume that these methods are the <i>only</i> ones that modify nodes, a property sometimes called <i>freedom from interference</i>. In the list algorithms considered here, nodes are internal to the list implementation, so freedom from interference is guaranteed because users of the list have no opportunity to modify its internal nodes.</p><p class="text" id="p0095">We require freedom from interference even for nodes that have been removed from the list, since some of our algorithms permit a thread to unlink a node while it is being traversed by others. Fortunately, we do not attempt to reuse list nodes that have been removed from the list, relying instead on a garbage collector to recycle that memory. The algorithms described here work in languages without garbage collection, but sometimes require nontrivial modifications that are beyond the scope of this chapter. We discuss issues that arise in the absence of garbage collection and how to deal with them in Chapter <a href="B978012415950100029X.xhtml">19</a>.</p><p class="text" id="p0100">When reasoning about concurrent object implementations, it is important to understand the distinction between an object's <i>abstract value</i> (here, a set of items) and its <i>concrete representation</i> (here, a list of nodes).</p><p class="text" id="p0105">Not every list of nodes is a meaningful representation for a set. An algorithm's <i>representation invariant</i> characterizes which representations make sense as abstract values. If <i>a</i> and <i>b</i> are nodes, we say that <i>a points to b</i> if <i>a</i>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field is a reference to <i>b</i>. We say that <i>b</i> is <i>reachable</i> if there is a sequence of nodes starting at <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> and ending at <i>b</i>, where each node in the sequence points to its successor.</p><p class="text" id="p0110">The set algorithms in this chapter require the following invariants (some require more, as explained later): <span aria-label="Page 205" epub:type="pagebreak" id="page_205" role="doc-pagebreak"/></p><div><ol><li class="numlist" id="o0020">1.  The key of any node in the list is less than the key of its successor (if it has one). This implies that nodes in the list are sorted by key, and that keys are unique.</li><li class="numlist" id="o0025">2.  The key of any item added, removed, or searched for is greater than the key of <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> and less than the key of <img alt="Image" height="9" src="images/B9780124159501000197/fx014.jpg" width="23"/>. (Hence, the sentinel nodes are neither added nor removed.)</li></ol></div><p class="textfl"/><p class="text" id="p0125">Think of the representation invariant as a contract among the object's methods. Each method call preserves the invariant, and relies on the other methods to preserve the invariant. In this way, we can reason about each method in isolation, without having to consider all the possible ways they might interact.</p><p class="text" id="p0130">Given a list satisfying the representation invariant, which set does it represent? The meaning of such a list is given by an <i>abstraction map</i> carrying lists that satisfy the representation invariant to sets. Here, the abstraction map is simple: An item is in the set if and only if it is (in a node) reachable from <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>.</p><p class="text" id="p0135">What safety and liveness properties do we need? For safety, we want <i>linearizability</i>. As we saw in Chapter <a href="B9780124159501000124.xhtml">3</a>, to show that a concurrent data structure is a linearizable implementation of a sequential object, it suffices to identify a <i>linearization point</i>, an atomic step where the method call “takes effect”; we say it is <i>linearized</i> at this point. This step can be a read, a write, or a more complex atomic operation. Looking at any execution history of a list-based set, it must be the case that if the abstraction map is applied to the representation at the linearization points, the resulting sequence of states and method calls defines a valid sequential set execution. Here, <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>) adds <i>a</i> to the abstract set, <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(<i>a</i>) removes <i>a</i> from the abstract set, and <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(<i>a</i>) returns <i>true</i> or <i>false</i>, depending on whether <i>a</i> was already in the set.</p><p class="text" id="p0140">Different list algorithms make different progress guarantees. Some use locks, and care is required to ensure they are deadlock- and starvation-free. Some <i>nonblocking</i> list algorithms do not use locks at all, while others restrict locking to certain methods. Here is a brief summary, from Chapter <a href="B9780124159501000124.xhtml">3</a>, of the nonblocking properties we use:<sup><a epub:type="noteref" href="#fn002" id="cf0030" role="doc-noteref">2</a></sup></p><div><ul><li class="bulllist" id="u0045">•  A method is <i>wait-free</i> if every call finishes in a finite number of steps.</li><li class="bulllist" id="u0050">•  A method is <i>lock-free</i> if <i>some</i> call always finishes in a finite number of steps.</li></ul></div><p class="textfl"> We are now ready to consider a variety of list-based set algorithms. We start with algorithms that use coarse-grained synchronization, and successively refine them to reduce the granularity of locking, culminating in a nonblocking algorithm. Formal proofs of correctness lie beyond the scope of this book. Instead, we focus on informal reasoning useful in everyday problem solving.</p><p class="text" id="p0155">As mentioned, in each of these algorithms, methods traverse the list using two local variables: <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> is the current node and <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> is its predecessor. Because these variables are local, each thread has its own instances of them; we use <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> to denote the instances used by thread <i>A</i>.<span aria-label="Page 206" epub:type="pagebreak" id="page_206" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0025"><a id="st0035"/>9.4 Coarse-grained synchronization</h2><p class="textfl" id="p0160">We start with a simple algorithm using coarse-grained synchronization. <a href="#f0025" id="cs0010">Figs. 9.4</a> and <a href="#f0030">9.5</a> show the <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() methods for this coarse-grained algorithm. (The <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method works in much the same way, and is left as an exercise.) The list itself has a single lock which every method call must acquire. The principal advantage of this algorithm, which should not be discounted, is that it is obviously correct. All methods act on the list only while holding the lock, so the execution is essentially sequential.</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="487" src="images/B9780124159501000197/gr004.jpg" width="284"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.4</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx016.jpg" width="66"/> class: the <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="339" src="images/B9780124159501000197/gr005.jpg" width="208"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.5</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx016.jpg" width="66"/> class: the <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() method. All methods acquire a single lock, which is released on exit by the <img alt="Image" height="11" src="images/B9780124159501000197/fx017.jpg" width="46"/> block.</div></figcaption></figure></div><p class="text" id="p0165">The linearization point for an <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>) or <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(<i>a</i>) call depends on whether the call was successful (i.e., whether <i>a</i> was already present). A successful <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>) call (<i>a</i> absent) is linearized at the point that <span aria-label="Page 207" epub:type="pagebreak" id="page_207" role="doc-pagebreak"/>it updates the <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field of the predecessor of the node added (line 24). Similarly, a successful <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(<i>a</i>) call (i.e., if <i>a</i> is present before the call) is linearized when it updates the <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field of the predecessor of the node removed (line 43). An unsuccessful <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>) or <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(<i>a</i>) method call, or any <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(<i>a</i>) call, can be linearized when the lock is acquired (or any time while the lock is held).<sup><a epub:type="noteref" href="#fn003" id="cf0035" role="doc-noteref">3</a></sup></p><p class="text" id="p0170">The <img alt="Image" height="9" src="images/B9780124159501000197/fx016.jpg" width="66"/> class satisfies the same progress condition as its lock: If the <img alt="Image" height="9" src="images/B9780124159501000197/fx018.jpg" width="25"/> is starvation-free, so is our implementation. If contention is very low, this algorithm is an excellent way to implement a list. If, however, there is contention, then even if the lock itself performs well, threads will still be delayed waiting for one another.<span aria-label="Page 208" epub:type="pagebreak" id="page_208" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0030"><a id="st0040"/>9.5 Fine-grained synchronization</h2><p class="textfl" id="p0175">We can improve concurrency by locking individual nodes, rather than locking the list as a whole. Instead of placing a lock on the entire list, we add a <img alt="Image" height="9" src="images/B9780124159501000197/fx018.jpg" width="25"/> to each node, along with <img alt="Image" height="9" src="images/B9780124159501000197/fx019.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000197/fx020.jpg" width="39"/>() methods. As a thread traverses the list, it locks each node when it first visits, and sometime later releases it. Such <i>fine-grained</i> locking permits concurrent threads to traverse the list together in a pipelined fashion.</p><p class="text" id="p0180">Consider two nodes <i>a</i> and <i>b</i>, where <i>a</i> points to <i>b</i>. It is not safe to unlock <i>a</i> before locking <i>b</i> because another thread could remove <i>b</i> from the list in the interval between unlocking <i>a</i> and locking <i>b</i>. Instead, a thread acquires locks using a “hand-over-hand” protocol: it acquires the lock for a node (except the <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> node) while holding (i.e., before releasing) the lock for its predecessor. This locking protocol is sometimes called <i>lock coupling</i>. (Note that there is no obvious way to implement lock coupling using Java's <img alt="Image" height="11" src="images/B9780124159501000197/fx021.jpg" width="79"/> methods.)</p><p class="text" id="p0185"><a href="#f0035" id="cs0015">Figs. 9.6</a> and <a href="#f0040">9.7</a> show the <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> algorithm's <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() methods. As in the coarse-grained list, <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() makes <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> unreachable by setting <span aria-label="Page 209" epub:type="pagebreak" id="page_209" role="doc-pagebreak"/><img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>'s successor. To be safe, <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() must lock both <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. To see why, consider the scenario illustrated in <a href="#f0045" id="cf0045">Fig. 9.8</a>. Thread <i>A</i> is about to remove node <i>a</i>, the first node in the list, while thread <i>B</i> is about to remove node <i>b</i>, where <i>a</i> points to <i>b</i>. Suppose <i>A</i> locks <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>, and <i>B</i> locks <i>a</i>. <i>A</i> then sets <img alt="Image" height="9" src="images/B9780124159501000197/fx023.jpg" width="59"/> to <i>b</i>, while <i>B</i> sets <img alt="Image" height="8" src="images/B9780124159501000197/fx024.jpg" width="38"/> to <i>c</i>. The net effect is the removal of <i>a</i>, but not <i>b</i>. The problem is that there is no overlap between the locks held by the two <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() calls. <a href="#f0050" id="cf0050">Fig. 9.9</a> illustrates how hand-over-hand locking avoids this problem.</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="454" src="images/B9780124159501000197/gr006.jpg" width="217"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.6</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> class: The <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method uses hand-over-hand locking to traverse the list. The <img alt="Image" height="11" src="images/B9780124159501000197/fx017.jpg" width="46"/> blocks release locks before returning.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="421" src="images/B9780124159501000197/gr007.jpg" width="208"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.7</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> class: The <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() method locks both the node to be removed and its predecessor before removing that node.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="118" src="images/B9780124159501000197/gr008.jpg" width="405"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.8</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> class: why <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() must acquire two locks. Thread <i>A</i> is about to remove <i>a</i>, the first node in the list, while thread <i>B</i> is about to remove <i>b</i>, where <i>a</i> points to <i>b</i>. Suppose <i>A</i> locks <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>, and <i>B</i> locks <i>a</i>. Thread <i>A</i> then sets <img alt="Image" height="9" src="images/B9780124159501000197/fx023.jpg" width="59"/> to <i>b</i>, while <i>B</i> sets <i>a</i>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <i>c</i>. The net effect is to remove <i>a</i>, but not <i>b</i>.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="114" src="images/B9780124159501000197/gr009.jpg" width="393"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.9</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> class: Hand-over-hand locking ensures that if concurrent <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() calls try to remove adjacent nodes, then they acquire conflicting locks. Thread <i>A</i> is about to remove node <i>a</i>, the first node in the list, while thread <i>B</i> is about to remove node <i>b</i>, where <i>a</i> points to <i>b</i>. Because <i>A</i> must lock both <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> and <i>a</i> and <i>B</i> must lock both <i>a</i> and <i>b</i>, they are guaranteed to conflict on <i>a</i>, forcing one call to wait for the other.</div></figcaption></figure></div><p class="text" id="p0190">To guarantee progress, it is important that all methods acquire locks in the same order, starting at <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> and following <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> references toward <img alt="Image" height="9" src="images/B9780124159501000197/fx014.jpg" width="23"/>. As <a href="#f0055" id="cf0055">Fig. 9.10</a> shows, a deadlock could occur if different method calls were to acquire locks in different orders. In this example, thread <i>A</i>, trying to add <i>a</i>, has locked <i>b</i> and is attempting to lock <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>, while <i>B</i>, trying to remove <i>b</i>, has locked <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> and is trying to lock <i>b</i>. Clearly, these method calls will never finish. Avoiding deadlocks is one of the principal challenges of programming with locks.<span aria-label="Page 210" epub:type="pagebreak" id="page_210" role="doc-pagebreak"/><span aria-label="Page 211" epub:type="pagebreak" id="page_211" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="202" src="images/B9780124159501000197/gr010.jpg" width="396"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.10</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> class: A deadlock could occur if, for example, <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() and <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() calls acquired locks in opposite order. Then we could have the scenario depicted, in which thread <i>A</i> is about to insert <i>a</i> by locking first <i>b</i> and then <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>, and thread <i>B</i> is about to remove node <i>b</i> by locking first <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> and then <i>b</i>. Each thread holds the lock the other is waiting to acquire, so neither makes progress.</div></figcaption></figure></div><p class="text" id="p0195">The representation invariant and abstraction map for <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> are the same as for <img alt="Image" height="9" src="images/B9780124159501000197/fx016.jpg" width="66"/>: Sentinels are never added or removed, nodes are sorted by key value without duplicates, and an item is in the set if and only if its node is reachable.</p><p class="text" id="p0200">As in <img alt="Image" height="9" src="images/B9780124159501000197/fx016.jpg" width="66"/>, a successful <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>) or <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(<i>a</i>) call of <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> is linearized when it updates the <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field of the predecessor of the node added or removed (line 20 or 44). An unsuccessful <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>) or <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(<i>a</i>) call, or any <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(<i>a</i>) call, can be linearized when it acquires the lock to a node whose key is greater than or equal to <i>a</i> (line 7 or 13 for <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>); line 35 or 41 for <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(<i>a</i>)).</p><p class="text" id="p0205">The <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> algorithm is starvation-free if all the node locks are starvation-free, but arguing this property is harder than in the coarse-grained case: Because all methods acquire locks in the same down-the-list order, deadlock is impossible. If thread <i>A</i> attempts to lock <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>, it eventually succeeds. From that point on, because there are no deadlocks, eventually all locks held by threads ahead of <i>A</i> in the list will be released, and <i>A</i> will succeed in locking <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>.</p><p class="text" id="p0210">Although fine-grained locking reduces contention compared to coarse-grained locking, it imposes a potentially long sequence of lock acquisitions and releases. Moreover, threads accessing disjoint parts of the list may still block one another. For example, a thread removing the second item in the list blocks all concurrent threads searching for later nodes.</p></section><section><h2 class="h1hd" id="s0035"><a id="st0045"/>9.6 Optimistic synchronization</h2><p class="textfl" id="p0215">One way to reduce synchronization costs is to take a chance: Search without acquiring locks, lock the nodes found, and then confirm that the locked nodes are correct. If a synchronization conflict causes the wrong nodes to be locked, then release the locks and start over. When this kind of conflict is rare, this technique works well, which is why we call it <i>optimistic synchronization</i>.</p><p class="text" id="p0220">Code for the optimistic <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>) method appears in <a href="#f0060" id="cf0060">Fig. 9.11</a>. When thread <i>A</i> calls this method, it traverses the list without acquiring any locks (lines 6–8). In fact, it ignores the locks completely. It stops the traversal when <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>'s key is greater than or equal to <i>a</i>. It then locks <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>, and calls <img alt="Image" height="9" src="images/B9780124159501000197/fx026.jpg" width="52"/>() to check that <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> is reachable and its <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field still refers to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. If validation succeeds, then thread <i>A</i> proceeds as before: If <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>'s key is greater than <i>a</i>, thread <i>A</i> adds a new node with item <i>a</i> between <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>, and returns <i>true</i>. Otherwise it returns <i>false</i>. The <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() and <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() methods (<a href="#f0065" id="cs0020">Figs. 9.12</a> and <a href="#f0070">9.13</a>) operate similarly, traversing the list without locking, and then locking the target nodes and validating they are still in the list. To be consistent with the Java memory model, the <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> fields in the nodes must be declared volatile.</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="487" src="images/B9780124159501000197/gr011.jpg" width="249"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.11</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> class: the <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method traverses the list ignoring locks, acquires locks, and validates before adding the new node.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="454" src="images/B9780124159501000197/gr012.jpg" width="235"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.12</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> class: The <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() method traverses ignoring locks, acquires locks, and validates before removing the node.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="372" src="images/B9780124159501000197/gr013.jpg" width="235"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.13</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> class: The <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method searches, ignoring locks, then acquires locks, and validates to determine if the node is in the list.</div></figcaption></figure></div><p class="text" id="p0225">The code of <img alt="Image" height="9" src="images/B9780124159501000197/fx026.jpg" width="52"/>() appears in <a href="#f0075" id="cf0065">Fig. 9.14</a>. We are reminded of a story: </p><p class="quote" id="sp0145"><i>A tourist takes a taxi in a foreign town. The taxi driver speeds through a red light. The tourist, frightened, asks, “What are you are doing?” The driver answers, “Do not worry, I am an expert.” He speeds through</i> <span aria-label="Page 212" epub:type="pagebreak" id="page_212" role="doc-pagebreak"/><i>more red lights, and the tourist, on the verge of hysteria, complains again, more urgently. The driver replies, “Relax, relax, you are in the hands of an expert.” Suddenly, the light turns green, the driver slams on the brakes, and the taxi skids to a halt. The tourist picks himself off the floor of the taxi and asks, “For crying out loud, why stop now that the light is finally green?” The driver answers, “Too dangerous, another expert could be crossing.”</i></p><p class="textfl"/><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="142" src="images/B9780124159501000197/gr014.jpg" width="311"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.14</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/>: Validation checks that <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> points to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> and is reachable from <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>.</div></figcaption></figure></div><p class="text" id="p0230">Ignoring locks while traversing a dynamically changing lock-based data structure requires careful thought (there are other expert threads out there). We must be sure to use some form of <i>validation</i> and guarantee <i>freedom from interference</i>.</p><p class="text" id="p0235">Validation is necessary because the trail of references leading to <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>, or the reference from <span aria-label="Page 213" epub:type="pagebreak" id="page_213" role="doc-pagebreak"/><img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>, could have changed between when they were last read by <i>A</i> and when <i>A</i> acquired the locks. In particular, <i>A</i> could be traversing parts of the list that have already been removed. For example, as shown in <a href="#f0080" id="cf0070">Fig. 9.15</a>, the node <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> and all nodes between <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> and <i>a</i> (including <i>a</i>) may be removed while <i>A</i> is still traversing <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. Thread <i>A</i> discovers that <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> points to <i>a</i>; without validation, it would “successfully” remove <i>a</i>, even though <i>a</i> is no longer in the list. A <img alt="Image" height="9" src="images/B9780124159501000197/fx026.jpg" width="52"/>() call detects that <i>a</i> is no longer in the list, and the caller restarts the method.</p><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" height="183" src="images/B9780124159501000197/gr015.jpg" width="480"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.15</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> class: why validation is needed. Thread <i>A</i> is attempting to remove a node <i>a</i>. While traversing the list, <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> and all nodes between <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> and <i>a</i> (including <i>a</i>) might be removed (denoted by a lighter node color). In such a case, thread <i>A</i> would proceed to the point where <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> points to <i>a</i>, and, without validation, would successfully remove <i>a</i>, even though it is no longer in the list. Validation is required to determine that <i>a</i> is no longer reachable from <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>.</div></figcaption></figure></div><p class="text" id="p0240">Because we ignore the locks that protect concurrent modifications while traversing the list, a method call may traverse nodes that have been removed from the list. Nevertheless, freedom from interference implies that once a node has been unlinked from the list, the value of its <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field does not change, so following a sequence of such links eventually leads back to the list. Freedom from interference, in turn, relies on garbage collection to ensure that no node is recycled while it is being traversed.</p><p class="text" id="p0245"><span aria-label="Page 214" epub:type="pagebreak" id="page_214" role="doc-pagebreak"/>The linearization points of the optimistic algorithm are the same as those of the fine-grained algorithm, except that we must take into account the possibility of failed validation. In particular, we only linearize a method call when it acquires a lock if the subsequent validation succeeds.</p><p class="text" id="p0250"><span aria-label="Page 215" epub:type="pagebreak" id="page_215" role="doc-pagebreak"/>The <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> algorithm is not starvation-free, even if all node locks are individually starvation-free. A thread might be delayed indefinitely if new nodes are repeatedly added and removed (see <a href="#enun0040" id="cf0075">Exercise 9.6</a>). Nevertheless, we expect this algorithm to do well in practice, since starvation is rare. It works best if the cost of traversing the list twice without locking is significantly less than the cost of traversing the list once with locking.</p><p class="text" id="p0255">Although optimistic synchronization can be applied to coarse-grained locking, it does not improve that algorithm because validation requires retraversing the list while holding the lock. However, we can eliminate the need to traverse the list during validation by maintaining a version number that is incremented whenever the list is modified. We explore such an approach in the exercises.</p></section><section><h2 class="h1hd" id="s0040"><a id="st0050"/>9.7 Lazy synchronization</h2><p class="textfl" id="p0260">One drawback of the <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> algorithm (and the <img alt="Image" height="9" src="images/B9780124159501000197/fx016.jpg" width="66"/> and <img alt="Image" height="9" src="images/B9780124159501000197/fx022.jpg" width="51"/> algorithms) is that <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() acquires locks, which is unattractive since <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() calls are typically much more common than calls to other methods. We show how to refine this algorithm so that <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() is wait-free, and <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() methods, while still blocking, traverse the list only once (in the absence of contention).</p><p class="text" id="p0265">We add to each node a Boolean <img alt="Image" height="9" src="images/B9780124159501000197/fx027.jpg" width="39"/> field indicating whether that node is in the set. Now, traversals do not need to lock the target node, and there is no need to validate that the node is reachable by retraversing the whole list. Instead, the algorithm maintains the invariant that every unmarked node is reachable. If a traversing thread does not find a node, <span aria-label="Page 216" epub:type="pagebreak" id="page_216" role="doc-pagebreak"/>or finds it marked, then that item is not in the set. As a result, <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() needs only one wait-free traversal. To add an element to the list, <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() traverses the list, locks the target's predecessor, and inserts the node. The <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() method is lazy, taking two steps: It first marks the target node, <i>logically</i> removing it, and then redirects the <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field of its predecessor, <i>physically</i> removing it.</p><p class="text" id="p0270">In more detail, as in the <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> algorithm, all methods traverse the list (possibly traversing logically and physically removed nodes) ignoring the locks. The <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() methods lock the <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> nodes, and validates them, as before, except that the <img alt="Image" height="9" src="images/B9780124159501000197/fx026.jpg" width="52"/>() method (<a href="#f0085" id="cf0080">Fig. 9.16</a>) does not retraverse the list to determine that the nodes are still in the list. Instead, because of the new invariant, it suffices to check that they are not marked. We must check that both <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> are not marked because <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> is the node that is being modified. (See <a href="#f0100" id="cf0085">Fig. 9.19</a> for an illustration of why validation is necessary.)</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="43" src="images/B9780124159501000197/gr016.jpg" width="384"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.16</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> class: Validation checks that neither the <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> nor the <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> node has been logically deleted, and that <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> points to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>.</div></figcaption></figure></div><p class="text" id="p0275">Except for calling a different <img alt="Image" height="9" src="images/B9780124159501000197/fx026.jpg" width="52"/>() method, the <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method of <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> is exactly the same as that of <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/>. The <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() method (<a href="#f0090" id="cf0090">Fig. 9.17</a>) has a small difference: it marks the node (line 18) before (physically) removing it from the list, maintaining the invariant that every unmarked node is reachable.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="471" src="images/B9780124159501000197/gr017.jpg" width="229"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.17</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> class: The <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() method removes nodes in two steps, logical and physical.</div></figcaption></figure></div><p class="text" id="p0280">Logical removals require a small change to the abstraction map: An item is in the set if and only if it is referred to by an <i>unmarked</i> reachable node. Note that the path along which the node is reachable may contain marked nodes. (The diligent reader should check that any unmarked reachable node remains reachable, even if its predecessor is logically or physically deleted.) As in the <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> algorithm, <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() are not starvation-free, because list traversals may be arbitrarily delayed by ongoing modifications.</p><p class="text" id="p0285">The <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method (<a href="#f0095" id="cf0095">Fig. 9.18</a>) traverses the list once ignoring locks and returns <i>true</i> if the node it was searching for is present and unmarked, and <i>false</i> otherwise. It is thus wait-free.<sup><a epub:type="noteref" href="#fn004" id="cf0100" role="doc-noteref">4</a></sup> A marked node's value is ignored. Each time the traversal moves to a new node, the new node has a larger key than the previous one, even if the node is logically deleted.</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="109" src="images/B9780124159501000197/gr018.jpg" width="267"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.18</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> class: the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="281" src="images/B9780124159501000197/gr019.jpg" width="374"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.19</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> class: why validation is needed. In part (a), thread <i>A</i> is attempting to remove node <i>a</i>. After it reaches the point where <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> refers to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span>, and before it acquires locks on these nodes, the node <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> is logically and physically removed. After <i>A</i> acquires the locks, validation will detect the problem. In part (b), <i>A</i> is attempting to remove node <i>a</i>. After it reaches the point where <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> refers to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span>, and before it acquires locks on these nodes, a new node is added between <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span>. After <i>A</i> acquires the locks, even though neither <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> nor <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> is marked, validation detects that <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span> is not the same as <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span>, and <i>A</i>'s call to <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() will be restarted.</div></figcaption></figure></div><p class="text" id="p0290">The linearization points for <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and unsuccessful <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() calls are the same as for the <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/>. A successful <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() call is linearized when the node is marked (i.e., when the <img alt="Image" height="9" src="images/B9780124159501000197/fx027.jpg" width="39"/> bit is set on line 18), and a successful <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() call is linearized when an unmarked matching node is <span aria-label="Page 217" epub:type="pagebreak" id="page_217" role="doc-pagebreak"/>found.</p><p class="text" id="p0295"><span aria-label="Page 218" epub:type="pagebreak" id="page_218" role="doc-pagebreak"/>It is trickier to see how to linearize an unsuccessful <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method call. Consider the scenario depicted in <a href="#f0105" id="cf0105">Fig. 9.20</a>, in which thread <i>A</i> is executing <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(<i>a</i>). In part (a), while <i>A</i> is traversing the list, another thread removes, both logically and physically, <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> and all subsequent nodes up to and including <i>a</i>. Thread <i>A</i> will still follow the links until <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> points to <i>a</i>, and detect that <i>a</i> is marked, and hence no longer in the abstract set. We might be tempted to linearize it at that point (i.e., when <i>A</i> executes line 38). However, as depicted in part (b), this is not always a valid linearization point: while <i>A</i> is traversing the removed section of the list, and before it reaches the removed node <i>a</i>, another thread may call <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>), adding a new node with key <i>a</i> to the reachable part of the list. In this case, <i>A</i>'s unsuccessful <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(<i>a</i>) method call cannot be linearized at the point it finds the marked node <i>a</i>, because this point occurs <i>after</i> the new node with key <i>a</i> has been inserted in the list. The unsuccessful method call must be linearized to a point before the new node is inserted.</p><div class="pageavoid"><figure class="fig" id="f0105"><img alt="Image" height="390" src="images/B9780124159501000197/gr020.jpg" width="463"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.20</span> The <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> class: linearizing an unsuccessful <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() call. Dark nodes are physically in the list and white nodes are physically removed. In part (a), while thread <i>A</i> is traversing the list, another thread disconnects the sublist referred to by <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow/><mml:mrow><mml:mtext mathvariant="italic">A</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="8" src="images/B9780124159501000197/si1.png" style="vertical-align:middle" width="11"/></span>. We can linearize <i>A</i>'s call at the point it sees that <i>a</i> is marked and is no longer in the abstract set. However, in part (b), while <i>A</i> is traversing the removed part of the list leading to the marked node <i>a</i>, another thread adds a new node with key <i>a</i>. It would be wrong to linearize <i>A</i>'s unsuccessful <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(<i>a</i>) call to when it found the marked node <i>a</i>, since this point occurs <i>after</i> the insertion of the new node with key <i>a</i> to the list.</div></figcaption></figure></div><p class="text" id="p0300">We therefore linearize an unsuccessful <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(<i>a</i>) method call within its execution interval at the earlier of the following points: (1) the point where a marked node with key <i>a</i>, or a node with a key greater than <i>a</i>, is found, or (2) the point immediately before a new node with key <i>a</i> is added to the list. The second point is guaranteed to be within the <span aria-label="Page 219" epub:type="pagebreak" id="page_219" role="doc-pagebreak"/>execution interval because the insertion of the new node with the same key must have happened after the start of the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method, or the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method would have found that item. As can be seen, the linearization point of the unsuccessful <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() is determined by the ordering of events in the execution, and is not a predetermined point in the method's code, and indeed, may not even be at a point where the thread takes a step (e.g., it may be linearized when another thread takes a step).</p><p class="text" id="p0305">One benefit of lazy synchronization is that we can separate unobtrusive logical steps, such as setting a flag, from disruptive physical changes to the structure, such as disconnecting a node. The example presented here is simple because we disconnect one node at a time. In general, however, delayed operations can be batched and performed lazily at a convenient time, reducing the overall disruptiveness of physical modifications to the structure.</p><p class="text" id="p0310"><span aria-label="Page 220" epub:type="pagebreak" id="page_220" role="doc-pagebreak"/>A principal disadvantage of the <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> algorithm is that <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() calls are blocking: If one thread is delayed, then others may also be delayed.</p></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>9.8 Nonblocking synchronization</h2><p class="textfl" id="p0315">We have seen that we can avoid locking in <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() by marking nodes as logically removed before physically removing them from the list. We now show how to extend this idea to eliminate locks altogether, allowing all three methods, <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(), <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(), and <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>(), to be nonblocking. (The first two methods are lock-free and the last wait-free.)</p><p class="text" id="p0320">A naïve approach would be to use <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to change the <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> fields. For example, if thread <i>A</i> wants to remove <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> from the list, it might call <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to set <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>'s successor. Unfortunately, this idea does not work, as shown in <a href="#f0110" id="cf0110">Fig. 9.21</a>. Part (a) shows a thread <i>A</i> attempting to remove a node <i>a</i> while thread <i>B</i> is adding a node <i>b</i>. Suppose <i>A</i> applies <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to <img alt="Image" height="9" src="images/B9780124159501000197/fx023.jpg" width="59"/>, while <i>B</i> applies <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to <img alt="Image" height="8" src="images/B9780124159501000197/fx024.jpg" width="38"/>. The net effect is that <i>a</i> is correctly deleted but <i>b</i> is not added to the list. In part (b), <i>A</i> attempts to remove <i>a</i>, the first node in the list, while <i>B</i> is about to remove <span aria-label="Page 221" epub:type="pagebreak" id="page_221" role="doc-pagebreak"/><i>b</i>, where a points to <i>b</i>. Suppose <i>A</i> applies <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to <img alt="Image" height="9" src="images/B9780124159501000197/fx023.jpg" width="59"/>, while <i>B</i> applies <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to <img alt="Image" height="8" src="images/B9780124159501000197/fx024.jpg" width="38"/>. The net effect is the removal of <i>a</i>, but not <i>b</i>.</p><div class="pageavoid"><figure class="fig" id="f0110"><img alt="Image" height="254" src="images/B9780124159501000197/gr021.jpg" width="412"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.21</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> class: why mark and reference fields must be modified atomically. In part (a), thread <i>A</i> is about to remove <i>a</i>, the first node in the list, while <i>B</i> is about to add <i>b</i>. Suppose <i>A</i> applies <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to <img alt="Image" height="9" src="images/B9780124159501000197/fx023.jpg" width="59"/>, while <i>B</i> applies <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to <img alt="Image" height="8" src="images/B9780124159501000197/fx024.jpg" width="38"/>. The net effect is that <i>a</i> is correctly deleted but <i>b</i> is not added to the list. In part (b), thread <i>A</i> is about to remove <i>a</i>, the first node in the list, while <i>B</i> is about to remove <i>b</i>, where <i>a</i> points to <i>b</i>. Suppose <i>A</i> applies <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to <img alt="Image" height="9" src="images/B9780124159501000197/fx023.jpg" width="59"/>, while <i>B</i> applies <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to <img alt="Image" height="8" src="images/B9780124159501000197/fx024.jpg" width="38"/>. The net effect is to remove <i>a</i>, but not <i>b</i>.</div></figcaption></figure></div><p class="text" id="p0325">We need a way to ensure that a node's fields cannot be updated after that node has been logically or physically removed from the list. Our approach is to treat the node's <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000197/fx027.jpg" width="39"/> fields as a single atomic unit: any attempt to update the <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field when the <img alt="Image" height="9" src="images/B9780124159501000197/fx027.jpg" width="39"/> field is <i>true</i> will fail.</p><p class="text" id="p0330">As described in detail in <a href="#enun0010" id="cf0115">Pragma 9.8.1</a>, an <img alt="Image" height="9" src="images/B9780124159501000197/fx030.jpg" width="174"/> object encapsulates both a reference to an object of type <img alt="Image" height="9" src="images/B9780124159501000197/fx031.jpg" width="5"/> and a Boolean mark. These fields can be atomically updated, either together or individually.</p><p class="text" id="p0335"/><div class="boxg1" id="enun0010"><p class="b1num">Pragma 9.8.1 </p><div><p class="b1textfl" id="p0340">An <img alt="Image" height="9" src="images/B9780124159501000197/fx030.jpg" width="174"/> object (defined by the <span class="sans-serif">java.util.concurrent.atomic</span> package) encapsulates both a reference to an object of type <img alt="Image" height="9" src="images/B9780124159501000197/fx031.jpg" width="5"/> and a Boolean mark, also called a <i>mark bit</i>. These fields can be updated atomically, either together or individually. The <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> method tests the expected reference and mark values, and if both tests succeed, replaces them with updated reference and mark values. The <img alt="Image" height="11" src="images/B9780124159501000197/fx032.jpg" width="19"/>() method has an unusual interface: It returns the object's reference value and stores the mark value in a Boolean array argument. The <img alt="Image" height="11" src="images/B9780124159501000197/fx033.jpg" width="79"/>() and <img alt="Image" height="9" src="images/B9780124159501000197/fx034.jpg" width="51"/>() methods return the reference and mark values, respectively. The interfaces of these methods are shown in <a href="#f0115" id="cf0120">Fig. 9.22</a>.</p><div class="pageavoid"><figure class="fig" id="f0115"><img alt="Image" height="110" src="images/B9780124159501000197/gr022.jpg" width="318"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.22</span> Some <img alt="Image" height="9" src="images/B9780124159501000197/fx030.jpg" width="174"/> methods: <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> tests and updates both the mark and reference fields; <img alt="Image" height="11" src="images/B9780124159501000197/fx032.jpg" width="19"/>() returns the encapsulated reference and stores the mark at position 0 in the argument array; <img alt="Image" height="11" src="images/B9780124159501000197/fx033.jpg" width="79"/>() and <img alt="Image" height="9" src="images/B9780124159501000197/fx034.jpg" width="51"/>() return the reference and mark, respectively.</div></figcaption></figure></div><p class="b1text" id="p0345">In C or C++, one could provide this functionality efficiently by “stealing” a bit from a pointer, using bit-wise operators to extract the mark and the pointer from a single word. In Java, one cannot manipulate pointers directly, so this functionality must be provided by a library.</p></div></div><p class="textfl"/><p class="text" id="p0350">We make each node's <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field an <img alt="Image" height="9" src="images/B9780124159501000197/fx035.jpg" width="194"/>. Thread <i>A</i> logically removes <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> by setting the mark bit in the node's <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field, and shares the physical removal with other threads performing <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() or <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>(): As each thread traverses the list, it cleans up the list by physically removing any marked nodes it encounters. In other <span aria-label="Page 222" epub:type="pagebreak" id="page_222" role="doc-pagebreak"/>words, threads performing <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() do not traverse marked nodes; they remove them before continuing. The <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method remains the same as in the <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> algorithm, traversing all nodes whether they are marked or not, and testing if an item is in the list based on its key and mark.</p><p class="text" id="p0355">It is worth pondering a design decision that differentiates the <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> algorithm from the <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> algorithm. Why do threads that add or remove nodes never traverse marked nodes, and instead physically remove all marked nodes they encounter? Suppose that thread <i>A</i> were to traverse marked nodes without physically removing them, and after logically removing <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>, were to attempt to physically remove it as well. It could do so by calling <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to try to redirect <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field, simultaneously verifying that <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> is not marked and that it refers to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. The difficulty is that, because <i>A</i> is not holding locks on <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>, other threads could insert new nodes or remove <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> before the <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> call.</p><p class="text" id="p0360">Consider a scenario in which another thread marks <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>. As illustrated in <a href="#f0110" id="cf0125">Fig. 9.21</a>, we cannot safely redirect the <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field of a marked node, so <i>A</i> would have to restart the physical removal by retraversing the list. This time, however, <i>A</i> would have to physically remove <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> before it could remove <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. Even worse, if there is a sequence of logically removed nodes leading to <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>, <i>A</i> must remove them all, one after the other, before it can remove <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> itself.</p><p class="text" id="p0365">This example illustrates why <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() calls do not traverse marked nodes: When they arrive at the node to be modified, they may be forced to retraverse the list to remove previous marked nodes. Instead, we choose to have both <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() physically remove any marked nodes on the path to their target node. The <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method, by contrast, performs no modification, and therefore need not participate in the cleanup of logically removed nodes, allowing it, as in the <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/>, to traverse both marked and unmarked nodes.</p><p class="text" id="p0370">In presenting the <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> algorithm, we factor out functionality common to the <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() methods by creating a nested <img alt="Image" height="9" src="images/B9780124159501000197/fx036.jpg" width="39"/> class to help with traversal. As shown in <a href="#f0120" id="cf0130">Fig. 9.23</a>, a <img alt="Image" height="9" src="images/B9780124159501000197/fx036.jpg" width="39"/> object is a structure with <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> fields. The <img alt="Image" height="9" src="images/B9780124159501000197/fx037.jpg" width="25"/>() method takes a <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> node and a key <i>a</i>, and traverses the list, seeking to set <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> to the node with the largest key less than <i>a</i>, and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> to the node with the least key greater than or equal to <i>a</i>. As thread <i>A</i> traverses the list, each time it advances <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>, it checks whether that node is marked (line 16). If so, it calls <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to attempt to physically remove the node by setting <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>'s <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field. This call tests both the field's reference and Boolean mark values, and fails if either value has changed. A concurrent thread could change the mark value by logically removing <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>, or it could change the reference value by physically removing <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. If the call fails, <i>A</i> restarts the traversal from the head of the list; otherwise the traversal continues.</p><div class="pageavoid"><figure class="fig" id="f0120"><img alt="Image" height="454" src="images/B9780124159501000197/gr023.jpg" width="420"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.23</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> class: nested <img alt="Image" height="9" src="images/B9780124159501000197/fx036.jpg" width="39"/> class and <img alt="Image" height="9" src="images/B9780124159501000197/fx037.jpg" width="25"/>() method: <img alt="Image" height="9" src="images/B9780124159501000197/fx037.jpg" width="25"/>() returns a <img alt="Image" height="9" src="images/B9780124159501000197/fx036.jpg" width="39"/> object with nodes on either side of the key; it removes marked nodes that it encounters.</div></figcaption></figure></div><p class="text" id="p0375">The <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> class uses the same abstraction map as the <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> class: An item is in the set if and only if it is referred to by an <i>unmarked</i> reachable node. The <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> call at line 17 of the <img alt="Image" height="9" src="images/B9780124159501000197/fx037.jpg" width="25"/>() method is an example of a <i>benevolent side effect</i>: It changes the concrete list without changing the abstract set, because removing a marked node does not change the value of the abstraction map.</p><p class="text" id="p0380"><span aria-label="Page 223" epub:type="pagebreak" id="page_223" role="doc-pagebreak"/><a href="#f0125" id="cf0135">Fig. 9.24</a> shows the <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> class's <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method. Suppose thread <i>A</i> calls <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>(<i>a</i>). <i>A</i> uses <img alt="Image" height="9" src="images/B9780124159501000197/fx037.jpg" width="25"/>() to locate <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. If <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>'s key is equal to <i>a</i>'s, the call returns <i>false</i>. Otherwise, <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() initializes a new node <i>a</i> to hold <i>a</i>, and makes <i>a</i> point to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. It then calls <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> (line 39) to make <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> point to <i>a</i>. Because the <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> tests both the mark and the reference, it succeeds only if <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> is unmarked and points to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. If the <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> is successful, the method returns <i>true</i>; otherwise it starts over from <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/>.</p><div class="pageavoid"><figure class="fig" id="f0125"><img alt="Image" height="257" src="images/B9780124159501000197/gr024.jpg" width="392"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.24</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> class: The <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method calls <img alt="Image" height="9" src="images/B9780124159501000197/fx037.jpg" width="25"/>() to locate <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>. It adds a new node only if <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> is unmarked and refers to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>.</div></figcaption></figure></div><p class="text" id="p0385"><a href="#f0130" id="cf0140">Fig. 9.25</a> shows the <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> algorithm's <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() method. When <i>A</i> calls <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() to remove item <i>a</i>, it uses <img alt="Image" height="9" src="images/B9780124159501000197/fx037.jpg" width="25"/>() to locate <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>. If <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub>'s key fails to match <i>a</i>'s, the call returns <i>false</i>. Otherwise, <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() uses a <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> to attempt to mark <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub><i>A</i></sub> as logically removed (line 55). This call succeeds only if no other thread has set the mark first. If it succeeds, the call returns <i>true</i>. A single attempt is made to physically remove the node, but there is no need to try again because the node will be removed by the next thread to traverse that region of the list. If the <img alt="Image" height="12" src="images/B9780124159501000197/fx001.jpg" width="97"/> call fails, <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() starts <span aria-label="Page 224" epub:type="pagebreak" id="page_224" role="doc-pagebreak"/>over.<span aria-label="Page 225" epub:type="pagebreak" id="page_225" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0130"><img alt="Image" height="290" src="images/B9780124159501000197/gr025.jpg" width="392"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.25</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> class: The <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() method calls <img alt="Image" height="9" src="images/B9780124159501000197/fx037.jpg" width="25"/>() to locate <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>, and atomically marks the node for removal.</div></figcaption></figure></div><p class="text" id="p0390">The <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method of the <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> algorithm, shown in <a href="#f0135" id="cf0145">Fig. 9.26</a>, is the same as that of the <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> algorithm, except that it uses <img alt="Image" height="12" src="images/B9780124159501000197/fx038.jpg" width="158"/> and <img alt="Image" height="12" src="images/B9780124159501000197/fx039.jpg" width="131"/> to get the successor and mark bit of <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>.</p><div class="pageavoid"><figure class="fig" id="f0135"><img alt="Image" height="125" src="images/B9780124159501000197/gr026.jpg" width="327"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 9.26</span> The <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> class: The wait-free <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method is the same as in the <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> class, except that it calls <img alt="Image" height="12" src="images/B9780124159501000197/fx038.jpg" width="158"/> to get the successor of <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> and <img alt="Image" height="12" src="images/B9780124159501000197/fx039.jpg" width="131"/> to test whether <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> is marked.</div></figcaption></figure></div></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>9.9 Discussion</h2><p class="textfl" id="p0395">We have seen a progression of list-based lock implementations in which the granularity and frequency of locking was gradually reduced, eventually reaching a fully nonblocking list. The final transition from the <img alt="Image" height="11" src="images/B9780124159501000197/fx028.jpg" width="51"/> to the <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> exposes some of the design decisions that concurrent programmers face. As we will see, approaches such as optimistic and lazy synchronization will appear time and again when designing more complex data structures.</p><p class="text" id="p0400">On the one hand, the <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> algorithm guarantees progress in the face of arbitrary delays. However, there is a price for this strong progress guarantee:</p><div><ul><li class="bulllist" id="u0055">•  The need to support atomic modification of a reference and a Boolean mark has an added performance cost.<sup><a epub:type="noteref" href="#fn005" id="cf0150" role="doc-noteref">5</a></sup></li><li class="bulllist" id="u0060">•  As <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() traverse the list, they engage in concurrent cleanup of removed nodes, introducing the possibility of contention among threads, sometimes forcing threads to restart traversals, even if there was no change near the node each was trying to modify.</li></ul></div><p class="textfl"> On the other hand, the lazy lock-based list does not guarantee progress in the face of arbitrary delays: Its <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() methods are <span aria-label="Page 226" epub:type="pagebreak" id="page_226" role="doc-pagebreak"/>blocking. However, unlike the lock-free algorithm, it does not require each node to include an atomically markable reference. It also does not require traversals to clean up logically removed nodes; they progress down the list, ignoring marked nodes.</p><p class="text" id="p0415">Which approach is preferable depends on the application. In the end, the balance of factors such as the potential for arbitrary thread delays, the relative frequency of calls to the <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() and <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() methods, the overhead of implementing an atomically markable reference, and so on, determines the choice of whether to lock, and if so, at what granularity.</p></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>9.10 Chapter notes</h2><p class="textfl" id="p0420">Lock coupling was invented by Rudolf Bayer and Mario Schkolnick <a epub:type="noteref" href="#br0085" id="cf0155" role="doc-noteref">[17]</a>. The first designs of lock-free linked list algorithms are credited to John Valois <a epub:type="noteref" href="#br0820" id="cf0160" role="doc-noteref">[164]</a>. The lock-free list implementation shown here is a variation on the lists of Maged Michael <a epub:type="noteref" href="#br0630" id="cf0165" role="doc-noteref">[126]</a>, who based his work on earlier linked list algorithms by Tim Harris <a epub:type="noteref" href="#br0290" id="cf0170" role="doc-noteref">[58]</a>. This algorithm, referred to by many as the Harris–Michael algorithm, is the one used in the <span class="sans-serif">java.util.concurrent</span> package. The <img alt="Image" height="11" src="images/B9780124159501000197/fx025.jpg" width="92"/> algorithm was invented for this chapter, and the lazy algorithm is credited to Steve Heller, Maurice Herlihy, Victor Luchangco, Mark Moir, Bill Scherer, and Nir Shavit <a epub:type="noteref" href="#br0300" id="cf0175" role="doc-noteref">[60]</a>.</p></section><section><h2 class="h1hd" id="s0060"><a id="st0070"/>9.11 Exercises</h2><p class="textfl" id="p0425"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 9.1 </p><div><p class="b1textfl" id="p0430">Describe how to modify each of the linked list algorithms if object hash codes are not guaranteed to be unique.</p></div></div><p class="textfl"/><p class="text" id="p0435"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 9.2 </p><div><p class="b1textfl" id="p0440">Suppose every method call of <img alt="Image" height="9" src="images/B9780124159501000197/fx016.jpg" width="66"/> is linearized at the instant the lock is acquired. Explain why we cannot use the abstraction map described in Section <a href="#s0020" id="cf0180">9.3</a>. Give an alternative abstraction map that works for these linearization points.</p></div></div><p class="textfl"/><p class="text" id="p0445"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 9.3 </p><div><p class="b1textfl" id="p0450">Explain why the fine-grained locking algorithm is does not deadlock.</p></div></div><p class="textfl"/><p class="text" id="p0455"/><div class="boxg1" id="enun0030"><p class="b1num">Exercise 9.4 </p><div><p class="b1textfl" id="p0460">Explain why the fine-grained list's <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method is linearizable.</p></div></div><p class="textfl"/><p class="text" id="p0465"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 9.5 </p><div><p class="b1textfl" id="p0470">Explain why the optimistic and lazy locking algorithms are not subject to deadlock.</p></div></div><p class="textfl"/><p class="text" id="p0475"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 9.6 </p><div><p class="b1textfl" id="p0480">Show an execution of the optimistic algorithm in which a thread is forever attempting to delete a node.</p><p class="b1text" id="p0485"><i>Hint</i>: Since we assume that all the individual node locks are starvation-free, the livelock is not on any individual lock, and a bad execution must repeatedly add and remove nodes from the list.</p></div></div><p class="textfl"/><p class="text" id="p0490"/><div class="boxg1" id="enun0045"><p class="b1num">Exercise 9.7 </p><div><p class="b1textfl" id="p0495">Provide the code for the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method missing from the fine-grained algorithm. Explain why your implementation is correct.</p></div></div><p class="textfl"/><p class="text" id="p0500"><span aria-label="Page 227" epub:type="pagebreak" id="page_227" role="doc-pagebreak"/></p><div class="boxg1" id="enun0050"><p class="b1num">Exercise 9.8 </p><div><p class="b1textfl" id="p0505">Is the optimistic list implementation still correct if we switch the order in which <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() locks the <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> and <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> nodes?</p></div></div><p class="textfl"/><p class="text" id="p0510"/><div class="boxg1" id="enun0055"><p class="b1num">Exercise 9.9 </p><div><p class="b1textfl" id="p0515">Show that in the optimistic list algorithm, if <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> is not <i>null</i>, then <img alt="Image" height="9" src="images/B9780124159501000197/fx014.jpg" width="23"/> is reachable from <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub>, even if <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> itself is not reachable.</p></div></div><p class="textfl"/><p class="text" id="p0520"/><div class="boxg1" id="enun0060"><p class="b1num">Exercise 9.10 </p><div><p class="b1textfl" id="p0525">Show that in the optimistic algorithm, the <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method needs to lock only <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/>.</p></div></div><p class="textfl"/><p class="text" id="p0530"/><div class="boxg1" id="enun0065"><p class="b1num">Exercise 9.11 </p><div><p class="b1textfl" id="p0535">Design a coarse-grained optimistic locking linked list-based set algorithm that does not traverse the list while holding the lock by augmenting the list with a version number.</p></div></div><p class="textfl"/><p class="text" id="p0540"/><div class="boxg1" id="enun0070"><p class="b1num">Exercise 9.12 </p><div><p class="b1textfl" id="p0545">Design a fine-grained optimistic locking algorithm that uses a version number to avoid traversing the list while holding any lock if the list does not change during the first traversal of the list. What are the advantages and disadvantages of this list compared with the coarse-grained list from the previous exercise?</p></div></div><p class="textfl"/><p class="text" id="p0550"/><div class="boxg1" id="enun0075"><p class="b1num">Exercise 9.13 </p><div><p class="b1textfl" id="p0555">For each of the following modifications of the sorted linked list algorithms, explain why the respective algorithm is still linearizable, or give a counterexample showing it is not.</p><div><ol><li class="b1numlist" id="o0030">a.  In the optimistic algorithm, the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method locks two nodes before deciding whether a key is present. Suppose, instead, it locks no nodes, returning <i>true</i> if it observes the value, and <i>false</i> otherwise.</li><li class="b1numlist" id="o0035">b.  In the lazy algorithm, the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method executes without inspecting the locks, but it inspects the mark bit; it returns <i>false</i> if a node is marked for removal. Suppose, instead, the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() does not inspect the mark bit of the nodes, and returns <i>true</i> even for nodes that may be marked.</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0570"/><div class="boxg1" id="enun0080"><p class="b1num">Exercise 9.14 </p><div><p class="b1textfl" id="p0575">Would the lazy algorithm still work if we marked a node as removed simply by setting its <img alt="Image" height="8" src="images/B9780124159501000197/fx009.jpg" width="25"/> field to <i>null</i>? Why or why not? What about the lock-free algorithm?</p></div></div><p class="textfl"/><p class="text" id="p0580"/><div class="boxg1" id="enun0085"><p class="b1num">Exercise 9.15 </p><div><p class="b1textfl" id="p0585">In the lazy algorithm, can <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/><sub><i>A</i></sub> ever be unreachable? Justify your answer.</p></div></div><p class="textfl"/><p class="text" id="p0590"/><div class="boxg1" id="enun0090"><p class="b1num">Exercise 9.16 </p><div><p class="b1textfl" id="p0595">Your new employee claims that the lazy list's validation method (<a href="#f0085" id="cf0185">Fig. 9.16</a>) can be simplified by dropping the check that <img alt="Image" height="11" src="images/B9780124159501000197/fx040.jpg" width="59"/> is equal to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/><sub>.</sub> After all, the code always sets <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> to the old value of <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>, and before <img alt="Image" height="11" src="images/B9780124159501000197/fx040.jpg" width="59"/> can be changed, the new value of <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> must be marked, causing the validation to fail. Explain the error in this reasoning.</p></div></div><p class="textfl"/><p class="text" id="p0600"/><div class="boxg1" id="enun0095"><p class="b1num">Exercise 9.17 </p><div><p class="b1textfl" id="p0605">Can you modify the lazy algorithm's <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() so it locks only one node?</p></div></div><p class="textfl"/><p class="text" id="p0610"/><div class="boxg1" id="enun0100"><p class="b1num">Exercise 9.18 </p><div><p class="b1textfl" id="p0615">In the lock-free algorithm, argue the benefits and drawbacks of having the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method help in the cleanup of logically removed nodes.</p></div></div><p class="textfl"/><p class="text" id="p0620"><span aria-label="Page 228" epub:type="pagebreak" id="page_228" role="doc-pagebreak"/></p><div class="boxg1" id="enun0105"><p class="b1num">Exercise 9.19 </p><div><p class="b1textfl" id="p0625">In the lock-free algorithm, if an <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method call fails because <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> does not point to <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/>, but <img alt="Image" height="11" src="images/B9780124159501000197/fx012.jpg" width="25"/> is not marked, do we need to traverse the list again from <img alt="Image" height="9" src="images/B9780124159501000197/fx013.jpg" width="25"/> in order to attempt to complete the call?</p></div></div><p class="textfl"/><p class="text" id="p0630"/><div class="boxg1" id="enun0110"><p class="b1num">Exercise 9.20 </p><div><p class="b1textfl" id="p0635">Would the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method of the lazy and lock-free algorithms still be correct if logically removed entries were not guaranteed to be sorted?</p></div></div><p class="textfl"/><p class="text" id="p0640"/><div class="boxg1" id="enun0115"><p class="b1num">Exercise 9.21 </p><div><p class="b1textfl" id="p0645">The <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() method of the lock-free algorithm never finds a marked node with the same key. Can one modify the algorithm so that it will simply insert its new added object into the existing marked node with the same key if such a node exists in the list, thus saving the need to insert a new node?</p></div></div><p class="textfl"/><p class="text" id="p0650"/><div class="boxg1" id="enun0120"><p class="b1num">Exercise 9.22 </p><div><p class="b1textfl" id="p0655">Explain why the following cannot happen in the <img alt="Image" height="9" src="images/B9780124159501000197/fx029.jpg" width="78"/> algorithm: A node with item <i>x</i> is logically but not yet physically removed by some thread, then the same item <i>x</i> is added into the list by another thread, and finally a <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() call by a third thread traverses the list, finding the logically removed node, and returning <i>false</i>, even though the linearization order of the <img alt="Image" height="6" src="images/B9780124159501000197/fx004.jpg" width="38"/>() and <img alt="Image" height="9" src="images/B9780124159501000197/fx003.jpg" width="18"/>() implies that <i>x</i> is in the set.</p></div></div><p class="textfl"/><p class="text" id="p0660"/><div class="boxg1" id="enun0125"><p class="b1num">Exercise 9.23 </p><div><p class="b1textfl" id="p0665">Consider the following two modifications for the sorted linked list algorithms:</p><div><ol><li class="b1numlist" id="o0040">a.  In the optimistic algorithm, the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method locks two nodes before deciding whether a key is present. Suppose, instead, it locks no nodes, returning <i>true</i> if it observes the value, and <i>false</i> otherwise.</li><li class="b1numlist" id="o0045">b.  In the lazy algorithm, the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() method executes without inspecting the locks, but it inspects the mark bit; it returns <i>false</i> if a node is marked for removal. Suppose, instead, the <img alt="Image" height="9" src="images/B9780124159501000197/fx005.jpg" width="51"/>() does not inspect the mark bit of the nodes, and returns <i>true</i> even for nodes that may be marked.</li></ol></div><p class="b1textfl"> For both of the modifications, explain why the respective algorithm is still linearizable, or give a counterexample showing it is not.</p></div></div><p class="textfl"/><p class="text" id="p0680"/><div class="boxg1" id="enun0130"><p class="b1num">Exercise 9.24 </p><div><p class="b1textfl" id="p0685">In the lock-free algorithm, we attempt to logically remove the node <img alt="Image" height="6" src="images/B9780124159501000197/fx011.jpg" width="25"/> by calling <img alt="Image" height="12" src="images/B9780124159501000197/fx041.jpg" width="299"/> (line 55 of <a href="#f0130" id="cf0190">Fig. 9.25</a>). For each of the following implementations in which this call is replaced with a different method call, either explain why it is correct or describe an execution in which it fails.</p><div><ol><li class="b1numlist" id="o0050">a.  We instead call <img alt="Image" height="12" src="images/B9780124159501000197/fx042.jpg" width="259"/>, where <img alt="Image" height="11" src="images/B9780124159501000197/fx043.jpg" width="113"/>() is a fictional method that atomically performs a normal compare-and-swap operation on just the mark bit.</li><li class="b1numlist" id="o0055">b.  We instead call <img alt="Image" height="12" src="images/B9780124159501000197/fx044.jpg" width="212"/>, where <img alt="Image" height="11" src="images/B9780124159501000197/fx045.jpg" width="72"/>() is a real method of the <img alt="Image" height="9" src="images/B9780124159501000197/fx030.jpg" width="174"/> class that atomically changes the mark bit to the specified value if the reference has the expected value, but is allowed to spuriously fail (if there are concurrent modifications).</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0445"><h2 class="reftitle" id="st0075">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0085" role="doc-biblioentry">[17] R. Bayer, M. Schkolnick,  Concurrency of operations on B-trees,   <cite><i>Acta Informatica</i></cite> 1977;9:1–21.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0290" role="doc-biblioentry">[58] Tim Harris,  A pragmatic implementation of non-blocking linked-lists,   <i>Proceedings of 15th International Symposium on Distributed Computing</i>.  <i>DISC 2001, Lisbon, Portugal</i>.   <cite><i>Lecture Notes in Computer Science</i></cite>.  Springer Verlag; October 2001;vol. 2180:300–314.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0300" role="doc-biblioentry">[60] S. Heller, M. Herlihy, V. Luchangco, M. Moir, W.N. Scherer III, N. Shavit,  A lazy concurrent list-based set algorithm,   <i>Proc. of the Ninth International Conference on Principles of Distributed Systems</i>.  <i>OPODIS 2005</i>.  2005:3–16.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0630" role="doc-biblioentry">[126] Maged M. Michael,  High performance dynamic lock-free hash tables and list-based sets,   <i>Proceedings of the Fourteenth Annual ACM Symposium on Parallel Algorithms and Architectures</i>.  ACM Press; 2002:73–82.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0820" role="doc-biblioentry">[164] John D. Valois,  Lock-free linked lists using compare-and-swap,   <i>Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing</i>.  ACM Press; 1995:214–222.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0020" role="doc-noteref">1 </a></sup> <a id="np0010"/>“The algorithms presented here work for any ordered set of keys that has maximum and minimum values and is well founded, that is, there are only finitely many keys smaller than any given key. For simplicity, we assume here that keys are integers, and that no item's key is the maximum or minimum integer value.”</p><p class="ftnote1" epub:type="footnote" id="fn002" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0030" role="doc-noteref">2 </a></sup> <a id="np0015"/>“Chapter <a href="B9780124159501000124.xhtml">3</a> introduces an even weaker nonblocking property called <i>obstruction-freedom</i>.”</p><p class="ftnote1" epub:type="footnote" id="fn003" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0035" role="doc-noteref">3 </a></sup> <a id="np0020"/>“We can linearize every method call at the instant it acquires the lock, but doing so requires a different abstraction map than the one described in Section <a href="#s0020" id="cf0040">9.3</a>.”</p><p class="ftnote1" epub:type="footnote" id="fn004" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0100" role="doc-noteref">4 </a></sup> <a id="np0025"/>“The number of nodes a thread must traverse cannot increase without bound due to newly inserted nodes because the set of keys is well founded.”</p><p class="ftnote1" epub:type="footnote" id="fn005" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0150" role="doc-noteref">5 </a></sup> <a id="np0030"/>“In the <span class="sans-serif">java.util.concurrent</span> package, this cost is somewhat reduced by using a reference to an intermediate dummy node to signify that the <img alt="Image" height="9" src="images/B9780124159501000197/fx027.jpg" width="39"/> bit is set.”</p></div></section></footer></section></body></html>