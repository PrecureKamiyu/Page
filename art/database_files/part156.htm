<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>7.5   Algorithms for Decomposition Using Functional Dependencies</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part155.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part157.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 10pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">7.5   <span style=" color: #00AEEF;">Algorithms for Decomposition Using Functional Dependencies</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Real-world database schemas are much larger than the examples that ﬁt in the pages of a book. For this reason, we need algorithms for the generation of designs that are in appropriate normal form. In this section, we present algorithms for <span class="s44">BCNF </span>and <span class="s44">3NF</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.5.1 BCNF Decomposition</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The deﬁnition of <span class="s44">BCNF </span>can be used directly to test if a relation is in <span class="s44">BCNF</span>. However, computation of <i>F </i><span class="s181">+</span><span class="s15"> </span>can be a tedious task. We ﬁrst describe simpliﬁed tests for verifying if a relation is in <span class="s44">BCNF</span>. If a relation is not in <span class="s44">BCNF</span>, it can be decomposed to create relations that are in <span class="s44">BCNF</span>. Later in this section, we describe an algorithm to create a lossless decomposition of a relation, such that the decomposition is in <span class="s44">BCNF</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.5.1.1 Testing for BCNF</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Testing of a relation schema <i>R </i>to see if it satisﬁes <span class="s44">BCNF </span>can be simpliﬁed in some cases:</p><p class="s15" style="padding-top: 10pt;text-indent: 0pt;line-height: 16pt;text-align: right;"><span class="s39">• </span><span class="s40">To check if a nontrivial dependency </span>α <span class="s86">→ </span>β <span class="p">causes a violation of </span><span class="s44">BCNF</span><span class="p">, compute</span></p><p style="padding-left: 87pt;text-indent: 0pt;line-height: 12pt;text-align: right;"><span class="s15">α</span><span class="s239">+ </span>(the attribute closure of <span class="s15">α</span>), and verify that it includes all attributes of <i>R</i>; that</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">is, it is a superkey for <i>R</i>.</p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">To check if a relation schema </span><i>R </i>is in <span class="s44">BCNF</span>, it suﬃces to check only the dependen- cies in the given set <i>F </i>for violation of <span class="s44">BCNF</span>, rather than check all dependencies in <i>F </i><span class="s181">+</span>.</p><p style="padding-left: 107pt;text-indent: 10pt;text-align: justify;">We can show that if none of the dependencies in <i>F </i>causes a violation of <span class="s44">BCNF</span>, then none of the dependencies in <i>F </i><span class="s181">+</span><span class="s15"> </span>will cause a violation of <span class="s44">BCNF</span>, either.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_1986.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 151pt;text-indent: 0pt;text-align: left;">result <span class="p">:</span><span class="s15">= </span><span class="s95">{</span>R<span class="s95">}</span><span class="p">;</span></p><p style="padding-left: 151pt;text-indent: 0pt;text-align: left;"><i>done </i>:<span class="s15">= </span>false;</p><p class="s46" style="padding-left: 151pt;text-indent: 0pt;text-align: left;">while <span class="p">(</span>not <i>done</i><span class="p">) </span>do</p><p style="padding-left: 163pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><b>if </b>(there is a schema <i>R</i><span class="s145">i </span>in <i>result </i>that is not in <span class="s224">BCNF</span>)</p><p class="s46" style="padding-left: 172pt;text-indent: 0pt;line-height: 11pt;text-align: left;">then begin</p><p style="padding-top: 1pt;padding-left: 208pt;text-indent: 0pt;line-height: 84%;text-align: left;">let <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>be a nontrivial functional dependency that holds on <i>R</i><span class="s97">i </span>such that <span class="s15">α</span><span class="s239">+ </span>does not contain <i>R</i><span class="s97">i </span>and <span class="s15">α ∩ β = ∅ </span>; <i>result </i>:<span class="s15">= </span>(<i>result </i><span class="s15">− </span><i>R</i><span class="s97">i</span>) <span class="s15">∪ </span>(<i>R</i><span class="s97">i </span><span class="s15">− β</span>) <span class="s15">∪ </span>( <span class="s15">α</span>, <span class="s15">β</span>);</p><p class="s46" style="padding-left: 2pt;text-indent: 0pt;line-height: 11pt;text-align: center;">end</p><p style="padding-left: 19pt;text-indent: 0pt;text-align: center;"><b>else </b><i>done </i>:<span class="s15">= </span>true;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_1987.png"/></span></p><p class="s73" style="padding-top: 8pt;padding-left: 209pt;text-indent: 0pt;text-align: left;">Figure 7.11 <span class="s151">BCNF </span><span class="s152">decomposition algorithm.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 94%;text-align: left;"><span class="p">Unfortunately, the latter procedure does not work when a relation schema is decom- posed. That is, it </span>does not <span class="p">suﬃce to use </span>F <span class="p">when we test a relation schema </span>R<span class="s145">i</span><span class="p">, in a decomposition of </span>R<span class="p">, for violation of </span><span class="s44">BCNF</span><span class="p">. For example, consider relation schema (</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">, </span>D<span class="p">, </span>E<span class="p">), with functional dependencies </span>F <span class="p">containing </span>A <span class="s86">→ </span>B <span class="p">and </span>BC <span class="s86">→ </span>D<span class="p">. Sup-</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: left;">pose this were decomposed into (<i>A</i>, <i>B</i>) and (<i>A</i>, <i>C</i>, <i>D</i>, <i>E</i>). Now, neither of the depen-</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 94%;text-align: justify;">dencies in <i>F </i>contains only attributes from (<i>A</i>, <i>C</i>, <i>D</i>, <i>E</i>), so we might be misled into thinking that it is in <span class="s44">BCNF</span>. In fact, there is a dependency <i>AC </i><span class="s86">→ </span><i>D </i>in <i>F </i><span class="s181">+</span><span class="s15"> </span>(which can be inferred using the pseudotransitivity rule from the two dependencies in <i>F </i>) that shows that (<i>A</i>, <i>C</i>, <i>D</i>, <i>E</i>) is not in <span class="s44">BCNF</span>. Thus, we may need a dependency that is in <i>F </i><span class="s181">+</span>, but is not in <i>F </i>, to show that a decomposed relation is not in <span class="s44">BCNF</span>.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 93%;text-align: justify;">An alternative <span class="s44">BCNF </span>test is sometimes easier than computing every dependency in <i>F </i><span class="s181">+</span>. To check if a relation schema <i>R</i><span class="s97">i </span>in a decomposition of <i>R </i>is in <span class="s44">BCNF</span>, we apply this test:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 139pt;text-indent: -16pt;line-height: 86%;text-align: left;"><span class="s39">• </span><span class="s40">For every subset </span><span class="s15">α </span>of attributes in <i>R</i><span class="s97">i</span>, check that <span class="s15">α</span><span class="s239">+ </span>(the attribute closure of <span class="s15">α </span>under <i>F </i>) either includes no attribute of <i>R</i><span class="s97">i </span><span class="s15">− α</span>, or includes all attributes of <i>R</i><span class="s97">i</span>.</p><p style="padding-top: 13pt;padding-left: 119pt;text-indent: 0pt;line-height: 86%;text-align: justify;">If the condition is violated by some set of attributes <span class="s15">α </span>in <i>R</i><span class="s97">i</span>, consider the following functional dependency, which can be shown to be present in <i>F </i><span class="s181">+</span>:</p><p class="s15" style="padding-top: 4pt;padding-left: 17pt;text-indent: 0pt;text-align: center;">α <span class="s86">→ </span><span class="p">(</span>α<span class="s239">+ </span>− α<span class="p">) </span>∩ <span class="s13">R</span><span class="s97">i</span><span class="p">.</span></p><p style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">This dependency shows that <i>R</i><span class="s97">i </span>violates <span class="s44">BCNF</span>.</p><p class="s183" style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">7.5.1.2 BCNF Decomposition Algorithm</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We are now able to state a general method to decompose a relation schema so as to satisfy <span class="s44">BCNF</span>. Figure 7.11 shows an algorithm for this task. If <i>R </i>is not in <span class="s44">BCNF</span>, we can decompose <i>R </i>into a collection of <span class="s44">BCNF </span>schemas <i>R</i><span class="s98">1</span>, <i>R</i><span class="s98">2</span>, <span class="s15">… </span>, <i>R</i><span class="s97">n </span>by the algorithm.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">The algorithm uses dependencies that demonstrate violation of <span class="s44">BCNF </span>to perform the decomposition.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The decomposition that the algorithm generates is not only in <span class="s44">BCNF</span>, but is also a lossless decomposition. To see why our algorithm generates only lossless decom-</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 78%;text-align: justify;">positions, we note that, when we replace a schema <i>R</i><span class="s97">i </span>with (<i>R</i><span class="s97">i </span><span class="s15">− β</span>) and (<span class="s15">α</span>, <span class="s15">β</span>), the dependency <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>holds, and (<i>R</i><span class="s145">i </span><span class="s15">− β</span>) <span class="s15">∩ </span>(<span class="s15">α</span>, <span class="s15">β</span>) <span class="s15">= α</span>.</p><p class="s15" style="padding-left: 88pt;text-indent: 17pt;line-height: 89%;text-align: justify;"><span class="p">If we did not require </span>α∩β = ∅<span class="p">, then those attributes in </span>α∩β <span class="p">would not appear in the schema (</span><span class="s13">R</span><span class="s145">i </span>− β<span class="p">), and the dependency </span>α <span class="s86">→ </span>β <span class="p">would no longer hold.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1988.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1989.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 87%;text-align: justify;">It is easy to see that our decomposition of <i>in dep </i>in Section 7.3.1 would result from applying the algorithm. The functional dependency <i>dept name </i><span class="s86">→ </span><i>building</i>, <i>budget </i>satisﬁes the <span class="s15">α ∩ β = ∅ </span>condition and would therefore be chosen to decompose the</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">schema.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s64">BCNF </span><span class="s84">decomposition algorithm </span>takes time exponential to the size of the initial schema, since the algorithm for checking whether a relation in the decomposition sat- isﬁes <span class="s44">BCNF </span>can take exponential time. There is an algorithm that can compute a <span class="s44">BCNF </span>decomposition in polynomial time; however, the algorithm may “overnormalize,” that is, decompose a relation unnecessarily.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As a longer example of the use of the <span class="s44">BCNF </span>decomposition algorithm, suppose we have a database design using the <i>class </i>relation, whose schema is as shown below:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1990.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1991.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1992.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1993.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1994.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1995.png"/></span></p><p class="s13" style="padding-left: 150pt;text-indent: -26pt;text-align: left;">class <span class="p">(</span>course id<span class="p">, </span>title<span class="p">, </span>dept name<span class="p">, </span>credits<span class="p">, </span>sec id<span class="p">, </span>semester<span class="p">, </span>year<span class="p">, </span>building<span class="p">, </span>room number<span class="p">, </span>capacity<span class="p">, </span>time slot id<span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">The set of functional dependencies that we need to hold on this schema are:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1996.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1997.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1998.png"/></span></p><p class="s13" style="padding-left: 128pt;text-indent: 0pt;line-height: 77%;text-align: left;">course id <span class="s86">→ </span>title<span class="p">, </span>dept name<span class="p">, </span>credits building<span class="p">, </span>room number <span class="s86">→ </span>capacity</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_1999.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2000.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2002.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2003.png"/></span></p><p class="s13" style="padding-left: 128pt;text-indent: 0pt;line-height: 14pt;text-align: left;">course id<span class="p">, </span>sec id<span class="p">, </span>semester<span class="p">, </span>year<span class="s86">→ </span>building<span class="p">, </span>room number<span class="p">, </span>time slot id</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2005.png"/></span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">A candidate key for this schema is <span class="s95">{</span><i>course id</i>, <i>sec id</i>, <i>semester</i>, <i>year</i><span class="s95">}</span>.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: left;">We can apply the algorithm of Figure 7.11 to the <i>class </i>example as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">The functional dependency:</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2006.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2007.png"/></span></p><p class="s13" style="padding-top: 12pt;padding-left: 208pt;text-indent: 0pt;text-align: left;">course id <span class="s86">→ </span>title<span class="p">, </span>dept name<span class="p">, </span>credits</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2008.png"/></span></p><p style="padding-left: 107pt;text-indent: 0pt;text-align: left;">holds, but <i>course id </i>is not a superkey. Thus, <i>class </i>is not in <span class="s44">BCNF</span>. We replace <i>class</i></p><p style="padding-left: 107pt;text-indent: 0pt;text-align: left;">with two relations with the following schemas:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2009.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2010.png"/></span></p><p class="s13" style="padding-left: 151pt;text-indent: 0pt;text-align: left;">course <span class="p">(</span>course id<span class="p">, </span>title<span class="p">, </span>dept name<span class="p">, </span>credits<span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2011.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2012.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2013.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2014.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2015.png"/></span></p><p class="s13" style="padding-left: 184pt;text-indent: -33pt;text-align: left;">class-1 <span class="p">(</span>course id<span class="p">, </span>sec id<span class="p">, </span>semester<span class="p">, </span>year<span class="p">, </span>building<span class="p">, </span>room number capacity<span class="p">, </span>time slot id<span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2016.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2017.png"/></span></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;">The only nontrivial functional dependencies that hold on <i>course </i>include <i>course id </i>on the left side of the arrow. Since <i>course id </i>is a superkey for <i>course</i>, <i>course </i>is in <span class="s44">BCNF</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2018.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2019.png"/></span></p><p class="s13" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: left;"><span class="s39">• </span><span class="s40">A candidate key for </span>class-1 <span class="p">is </span><span class="s95">{</span>course id<span class="p">, </span>sec id<span class="p">, </span>semester<span class="p">, </span>year<span class="s95">}</span><span class="p">. The functional de- pendency:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2020.png"/></span></p><p class="s13" style="padding-left: 243pt;text-indent: 0pt;text-align: left;">building<span class="p">, </span>room number <span class="s86">→ </span>capacity</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2021.png"/></span></p><p style="padding-top: 10pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;">holds on <i>class-1</i>, but <span class="s95">{</span><i>building</i>, <i>room number</i><span class="s95">} </span>is not a superkey for <i>class-1</i>. We re- place <i>class-1 </i>two relations with the following schemas:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2022.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2023.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2024.png"/></span></p><p class="s13" style="padding-left: 215pt;text-indent: 0pt;text-align: justify;">classroom <span class="p">(</span>building<span class="p">, </span>room number<span class="p">, </span>capacity<span class="p">) </span>section <span class="p">(</span>course id<span class="p">, </span>sec id<span class="p">, </span>semester<span class="p">, </span>year<span class="p">,</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2025.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2026.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2027.png"/></span></p><p style="padding-left: 139pt;text-indent: 124pt;line-height: 202%;text-align: justify;"><i>building</i>, <i>room number</i>, <i>time slot id</i>) These two schemas are in <span class="s44">BCNF</span>.</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Thus, the decomposition of <i>class </i>results in the three relation schemas <i>course</i>, <i>classroom</i>, and <i>section</i>, each of which is in <span class="s44">BCNF</span>. These correspond to the schemas that we have used in this and previous chapters. You can verify that the decomposition is lossless and dependency preserving.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">7.5.2 3NF Decomposition</p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;line-height: 92%;text-align: justify;">Figure 7.12 shows an algorithm for ﬁnding a dependency-preserving, lossless decompo- sition into <span class="s44">3NF</span>. The set of dependencies <i>F</i><span class="s145">c </span>used in the algorithm is a canonical cover for <i>F</i>. Note that the algorithm considers the set of schemas <i>R</i><span class="s97">j </span>, <i>j </i><span class="s15">= </span>1, 2, <span class="s15">… </span>, <i>i</i>; initially <i>i </i><span class="s15">= </span>0, and in this case the set is empty.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2028.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Let us apply this algorithm to our example of <i>dept advisor </i>from Section 7.3.2, where we showed that:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2029.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2030.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2031.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2032.png"/></span></p><p class="s13" style="padding-left: 231pt;text-indent: 0pt;text-align: left;">dept advisor <span class="p">(</span>s <span class="s101">ID</span><span class="p">, </span>i <span class="s101">ID</span><span class="p">, </span>dept name<span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">is in <span class="s44">3NF </span>even though it is not in <span class="s44">BCNF</span>. The algorithm uses the following functional dependencies in <i>F </i>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2033.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2034.png"/></span></p><p class="s13" style="padding-top: 2pt;padding-left: 251pt;text-indent: 0pt;line-height: 15pt;text-align: left;">f<span class="s98">1</span><span class="p">: </span>i <span class="s101">ID </span><span class="s86">→ </span>dept name</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2035.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2036.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2037.png"/></span></p><p class="s13" style="padding-left: 251pt;text-indent: 0pt;line-height: 15pt;text-align: left;">f<span class="s98">2</span><span class="p">: </span>s <span class="s101">ID</span><span class="p">, </span>dept name <span class="s86">→ </span>i <span class="s101">ID</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2038.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2039.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2040.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2041.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2042.png"/></span></p><p class="s13" style="padding-top: 10pt;padding-left: 119pt;text-indent: 17pt;line-height: 13pt;text-align: justify;"><span class="p">There are no extraneous attributes in any of the functional dependencies in </span>F <span class="p">, so </span>F<span class="s97">c </span><span class="p">contains </span>f<span class="s130">1 </span><span class="s94">and </span>f<span class="s130">2</span><span class="s94">. The algorithm then generates as </span>R<span class="s130">1 </span><span class="s94">the schema, (</span>i <span class="s101">ID </span>dept name<span class="p">), and as </span>R<span class="s98">2</span><span class="p"> the schema (</span>s <span class="s101">ID</span><span class="p">, </span>dept name<span class="p">, </span>i <span class="s101">ID</span><span class="p">). The algorithm then ﬁnds that </span>R<span class="s98">2</span><span class="p"> contains a candidate key, so no further relation schema is created.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2043.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 123pt;text-indent: 0pt;line-height: 86%;text-align: left;">let <i>F</i><span class="s97">c </span>be a canonical cover for <i>F</i>; <i>i </i>:<span class="s15">= </span>0;</p><p style="padding-left: 141pt;text-indent: -17pt;line-height: 85%;text-align: left;"><b>for each </b>functional dependency <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>in <i>F</i><span class="s145">c </span><i>i </i>:<span class="s15">= </span><i>i </i>+ 1;</p><p style="padding-left: 141pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>R</i><span class="s97">i </span>:<span class="s15">= α β</span>;</p><p style="padding-left: 123pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><b>if </b>none of the schemas <i>R</i><span class="s97">j </span>, <i>j </i><span class="s15">= </span>1, 2, <span class="s15">… </span>, <i>i </i>contains a candidate key for <i>R</i></p><p class="s46" style="padding-left: 132pt;text-indent: 0pt;line-height: 12pt;text-align: left;">then</p><p class="s13" style="padding-left: 141pt;text-indent: 0pt;text-align: left;">i <span class="p">:</span><span class="s15">= </span>i <span class="s15">+ </span><span class="p">1;</span></p><p style="padding-left: 141pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>R</i><span class="s97">i </span>:<span class="s15">= </span>any candidate key for <i>R</i>;</p><p style="padding-left: 123pt;text-indent: 0pt;line-height: 12pt;text-align: left;">/* Optionally, remove redundant relations */</p><p class="s46" style="padding-left: 123pt;text-indent: 0pt;text-align: left;">repeat</p><p style="padding-left: 141pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><b>if </b>any schema <i>R</i><span class="s145">j </span>is contained in another schema <i>R</i><span class="s145">k</span></p><p class="s46" style="padding-left: 150pt;text-indent: 0pt;line-height: 12pt;text-align: left;">then</p><p style="padding-left: 155pt;text-indent: 0pt;line-height: 14pt;text-align: left;">/* Delete <i>R</i><span class="s145">j </span>*/</p><p class="s13" style="padding-left: 155pt;text-indent: 0pt;line-height: 90%;text-align: left;">R<span class="s145">j </span><span class="p">:</span><span class="s15">= </span>R<span class="s145">i</span><span class="p">; </span>i <span class="p">:</span><span class="s15">= </span>i <span class="p">- 1;</span></p><p style="padding-left: 123pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><b>until </b>no more <i>R</i><span class="s145">j </span>s can be deleted</p><p style="padding-left: 123pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><b>return </b>(<i>R</i><span class="s98">1</span>, <i>R</i><span class="s98">2</span>, <span class="s15">… </span>, <i>R</i><span class="s145">i</span>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2044.png"/></span></p><p class="s74" style="padding-top: 8pt;padding-left: 121pt;text-indent: 0pt;text-align: left;"><span class="s73">Figure 7.12 </span>Dependency-preserving, lossless decomposition into <span class="s157">3NF</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 91%;text-align: justify;">The resultant set of schemas can contain redundant schemas, with one schema <i>R</i><span class="s145">k </span>containing all the attributes of another schema <i>R</i><span class="s97">j </span>. For example, <i>R</i><span class="s98">2</span> above contains all the attributes from <i>R</i><span class="s98">1</span>. The algorithm deletes all such schemas that are contained in another schema. Any dependencies that could be tested on an <i>R</i><span class="s97">j </span>that is deleted can also be tested on the corresponding relation <i>R</i><span class="s97">k</span>, and the decomposition is lossless even</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">if <i>R</i><span class="s145">j </span>is deleted.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">Now let us consider again the schema of the <i>class </i>relation of Section 7.5.1.2 and</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">apply the <span class="s64">3NF </span><span class="s84">decomposition algorithm</span>. The set of functional dependencies we listed there happen to be a canonical cover. As a result, the algorithm gives us the same three schemas <i>course, classroom</i>, and <i>section</i>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The preceding example illustrates an interesting property of the <span class="s44">3NF </span>algorithm. Sometimes, the result is not only in <span class="s44">3NF</span>, but also in <span class="s44">BCNF</span>. This suggests an alterna- tive method of generating a <span class="s44">BCNF </span>design. First use the <span class="s44">3NF </span>algorithm. Then, for any schema in the <span class="s44">3NF </span>design that is not in <span class="s44">BCNF</span>, decompose using the <span class="s44">BCNF </span>algorithm. If the result is not dependency-preserving, revert to the <span class="s44">3NF </span>design.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.5.3 Correctness of the 3NF Algorithm</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <span class="s44">3NF </span>algorithm ensures the preservation of dependencies by explicitly building a schema for each dependency in a canonical cover. It ensures that the decomposition is a</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">lossless decomposition by guaranteeing that at least one schema contains a candidate key for the schema being decomposed. Practice Exercise 7.16 provides some insight into the proof that this suﬃces to guarantee a lossless decomposition.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">This algorithm is also called the <span class="s64">3NF </span><span class="s84">synthesis algorithm</span>, since it takes a set of de- pendencies and adds one schema at a time, instead of decomposing the initial schema repeatedly. The result is not uniquely deﬁned, since a set of functional dependencies can have more than one canonical cover. The algorithm may decompose a relation even if it is already in <span class="s44">3NF</span>; however, the decomposition is still guaranteed to be in <span class="s44">3NF</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 94%;text-align: justify;">To see that the algorithm produces a <span class="s44">3NF </span>design, consider a schema <i>R</i><span class="s97">i </span>in the decomposition. Recall that when we test for <span class="s44">3NF </span>it suﬃces to consider functional dependencies whose right-hand side consists of a single attribute. Therefore, to see that</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 84%;text-align: justify;"><i>R</i><span class="s97">i </span>is in <span class="s44">3NF </span>you must convince yourself that any functional dependency <span class="s15">γ </span><span class="s86">→ </span><i>B </i>that holds on <i>R</i><span class="s145">i </span>satisﬁes the deﬁnition of <span class="s44">3NF</span>. Assume that the dependency that generated <i>R</i><span class="s145">i </span>in the synthesis algorithm is <span class="s15">α </span><span class="s86">→ </span><span class="s15">β</span>. <i>B </i>must be in <span class="s15">α </span>or <span class="s15">β</span>, since <i>B </i>is in <i>R</i><span class="s145">i </span>and <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>generated <i>R</i><span class="s145">i</span>. Let us consider the three possible cases:</p><p class="s15" style="padding-top: 11pt;padding-left: 123pt;text-indent: 0pt;line-height: 16pt;text-align: justify;"><span class="s39">• </span><span class="s13">B </span><span class="p">is in both </span>α <span class="p">and </span>β<span class="p">. In this case, the dependency </span>α <span class="s86">→ </span>β <span class="p">would not have been in</span></p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 13pt;text-align: justify;"><i>F</i><span class="s145">c </span>since <i>B </i>would be extraneous in <span class="s15">β</span>. Thus, this case cannot hold.</p><p style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: justify;"><span class="s39">• </span><i>B </i>is in <span class="s15">β </span>but not <span class="s15">α</span>. Consider two cases:</p><p style="padding-top: 6pt;padding-left: 145pt;text-indent: 0pt;text-align: justify;"><span class="s50">° </span><span class="s15">γ </span>is a superkey. The second condition of <span class="s44">3NF </span>is satisﬁed.</p><p style="padding-top: 2pt;padding-left: 153pt;text-indent: -8pt;line-height: 78%;text-align: justify;"><span class="s50">° </span><span class="s15">γ </span>is not a superkey. Then <span class="s15">α </span>must contain some attribute not in <span class="s15">γ</span>. Now, since <span class="s15">γ </span><span class="s86">→ </span><i>B </i>is in <i>F </i><span class="s181">+</span>, it must be derivable from <i>F</i><span class="s145">c </span>by using the attribute closure algorithm on <span class="s15">γ</span>. The derivation could not have used <span class="s15">α </span><span class="s86">→ </span><span class="s15">β</span>, because if it had been used, <span class="s15">α </span>must be contained in the attribute closure of <span class="s15">γ</span>, which is not possible, since we assumed <span class="s15">γ </span>is not a superkey. Now, using <span class="s15">α </span><span class="s86">→ </span>(<span class="s15">β − {</span><i>B</i><span class="s15">}</span>) and <span class="s15">γ </span><span class="s86">→ </span><i>B</i>, we can derive <span class="s15">α </span><span class="s86">→ </span><i>B </i>(since <span class="s15">γ </span><span class="s83">⊆ </span><span class="s15">αβ</span>, and <span class="s15">γ </span>cannot contain <i>B </i>because <span class="s15">γ </span><span class="s86">→ </span><i>B </i>is nontrivial). This would imply that <i>B </i>is extraneous in the right-hand side of</p><p style="padding-left: 153pt;text-indent: 0pt;line-height: 93%;text-align: justify;"><span class="s15">α </span><span class="s86">→ </span><span class="s15">β</span>, which is not possible since <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>is in the canonical cover <i>F</i><span class="s97">c</span>. Thus, if <i>B </i>is in <span class="s15">β</span>, then <span class="s15">γ </span>must be a superkey, and the second condition of <span class="s44">3NF </span>must be satisﬁed.</p><p style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;line-height: 15pt;text-align: justify;"><span class="s39">• </span><i>B </i>is in <span class="s15">α </span>but not <span class="s15">β</span>.</p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">Since <span class="s15">α </span>is a candidate key, the third alternative in the deﬁnition of <span class="s44">3NF </span>is satisﬁed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Interestingly, the algorithm we described for decomposition into <span class="s44">3NF </span>can be im- plemented in polynomial time, even though testing a given schema to see if it satisﬁes <span class="s44">3NF </span>is <span class="s44">NP</span>-hard (which means that it is very unlikely that a polynomial-time algorithm will ever be invented for this task).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part155.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part157.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
