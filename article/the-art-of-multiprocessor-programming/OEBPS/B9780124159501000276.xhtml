<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 405" epub:type="pagebreak" id="page_405" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 17: Data parallelism</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter examines MapReduce and stream programming, two approaches to shared-memory data-parallel programming, that is, to implementing parallel algorithms that process large amounts of data. It explains each approach, describes a simple generic framework for developing applications with that approach, and demonstrates how to use it to implement WordCount and KMeans, two simple data-parallel applications. Finally, it shows how to implement the framework.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">data-parallel algorithms; MapReduce; stream computing; framework; aggregate operations</p></section></header><p class="textfl" id="p0010">Today, in casual conversation, people often refer to multiprocessors as “multicores,” although technically, not every multiprocessor is a multicore. When did this usage become common? <a href="#f0010" id="cf0030">Fig. 17.1</a> shows the frequency with which the word “multicore” appears in books since 1900, as reported by Google Ngram, a service that keeps track of words found in scanned books. We can see that this word has been in use since the start of the 20th century, but its frequency has almost tripled since the year 2000. (Earlier uses of “multicore” mostly seem to refer to multicore cable or multicore fiber. But we digress.)</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="185" src="images/B9780124159501000276/gr001.jpg" width="501"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.1</span> “Multicore” usage from Google NGram.</div></figcaption></figure></div><p class="text" id="p0015">To produce this graph, it was necessary to count the number of times each word appears in a set of documents. How would you write a parallel <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> program for a multiprocessor? One natural approach is to divide the document into fragments, assign each fragment to a task, and have a set of worker threads execute those tasks (as described in Chapter <a href="B9780124159501000264.xhtml">16</a>). Working in parallel, each worker thread executes a series of tasks, each counting the words in its own fragment, and reporting the results to a master thread, which merges their results. This kind of algorithm is said to be <i>data-parallel</i>, because the key element of the design is distributing data items across multiple worker threads.</p><p class="text" id="p0020">The <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> program is simple, much simpler than programs you are likely to encounter in practice. Nevertheless, it provides an example for understanding how to structure parallel programs that operate on large data sets.</p><p class="text" id="p0025"><span aria-label="Page 406" epub:type="pagebreak" id="page_406" role="doc-pagebreak"/>Let us build on <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> to do some simple literary detective work. Suppose we are given a collection of documents. Although the documents are all attributed to a single author, we suspect they were actually written by <i>k</i> distinct authors.<sup><a epub:type="noteref" href="#fn001" id="cf0035" role="doc-noteref">1</a></sup> How can we tell which of these documents were (most likely) written by the same author?</p><p class="text" id="p0030">We can adapt <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> to partition the documents into <i>k clusters</i> of similar writings, where (we hope) each cluster consists of the documents written by a distinct author.</p><p class="text" id="p0035">Assume we are given a set of <i>N</i> characteristic words whose use frequencies are likely to vary from author to author. We can modify <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> to construct, for each document, an <i>N</i>-element vector whose <i>i</i>th entry is the number of occurrences of the <i>i</i>th characteristic word, normalized so the sum of the entries is 1. Each document's vector is thus a <i>point</i> in an <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000276/si1.png" style="vertical-align:middle" width="53"/></span>-dimensional Euclidean space. The <i>distance</i> between two documents is just the distance between their vectors as points in space, defined in the usual way. Our goal is to partition these points into <i>k</i> clusters, where the points in each cluster are closer to one another than to points in the other clusters.</p><p class="text" id="p0040">Perfect clustering is computationally difficult, but there are widely used data-parallel algorithms that provide good approximations. One of the most popular is the <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> clustering algorithm. As in <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/>, the points are distributed across a set of worker threads. Unlike <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/>, <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> is iterative. A master thread chooses <i>k</i> candidate cluster centers at random, and divides the points among a set of worker threads. Working in parallel, the worker threads assign each of their points <i>p</i> to the cluster whose center is closest to <i>p</i>, and report that assignment back to the master thread. The master thread merges these assignments and computes new cluster centers. If the old and new centers are too far apart, then the clustering is considered to be of poor quality, and the master thread does another iteration, this time using the newly computed cluster centers in place of the old. The program halts when the clusters become stable, meaning that the old and new centers have become sufficiently close. <a href="#f0015" id="cf0040">Fig. 17.2</a> shows how <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> clusters converge across iterations.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="293" src="images/B9780124159501000276/gr002.jpg" width="499"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.2</span> The <i>k</i>-means task: initial, intermediate, and final clusters.</div></figcaption></figure></div><p class="text" id="p0045">In this chapter, we examine two approaches to shared-memory data-parallel programming. The first approach is based on the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> programming pattern, in which <i>mapper</i> threads operate in parallel on the data, and the results from these mapper threads are merged by <i>reducer</i> threads. This structure has been very successful in distributed systems, where processing nodes communicate over a network, but it can also be effective on shared-memory multiprocessors, albeit at a smaller scale.</p><p class="text" id="p0050">The second approach is based on <i>stream programming</i>, a programming pattern supported by a number of languages (see the chapter notes). We use the interface provided by Java 8. A stream<sup><a epub:type="noteref" href="#fn002" id="cf0045" role="doc-noteref">2</a></sup> is just a logical sequence of data items. (We say “logical” because these items may not all exist at the same time.) Programmers can create new streams by applying operations to elements of an existing stream, <span aria-label="Page 407" epub:type="pagebreak" id="page_407" role="doc-pagebreak"/>sequentially or in parallel. For example, we can <i>filter</i> a stream to select only those elements that satisfy a predicate, <i>map</i> a function onto a stream to transforms stream elements from one type to another, or <i>reduce</i> a stream to a scalar value, for example, by summing the elements of a stream or taking their average.</p><p class="text" id="p0055">Stream programs operate at a higher level than <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> programs. Whether the simplicity of stream programming outweighs the fine-grained control of <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> programming depends entirely on the application.</p><section><h2 class="h1hd" id="s0010"><a id="st0020"/>17.1 MapReduce</h2><p class="textfl" id="p0060">First, we give a high-level description of how to structure a <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> application. Once we have understood the requirements of such algorithms, we describe a general (but simplified) <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework. Finally, we explain how to apply that framework to specific problems such as <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/>.</p><p class="text" id="p0065">A <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> program first divides the data into fragments that can be analyzed independently, and assigns each fragment to one of <i>n mapper</i> tasks. In its simplest form, a mapper task scans its fragment, and produces a list of <i>key–value</i> pairs <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000276/si2.png" style="vertical-align:middle" width="139"/></span>, where the key and value types depend on the application.</p><p class="text" id="p0070">The framework collects these key–value pairs, and for each key <i>k</i>, it merges the values paired with <i>k</i> into a list. Each such key–list pair is assigned to a <i>reducer</i> task, which produces an application-specific <i>output</i> value for that key. The output of the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> program is a map matching each key to its output value.</p><p class="text" id="p0075"><span aria-label="Page 408" epub:type="pagebreak" id="page_408" role="doc-pagebreak"/>There are many possible variations of this structure. Sometimes the inputs to mapper tasks are given as key–value pairs, sometimes the reducers produce key–value pairs, or multiple key–output pairs, and sometimes there are distinct input, intermediate, and final key types. For simplicity, we choose not to use any of these variations, but it would be straightforward to incorporate them in our examples.</p><section><h3 class="h2hd" id="s0015"><a id="st0025"/>17.1.1 The <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework</h3><p class="textfl" id="p0080">The <i>MapReduce framework</i> is in charge of creating and scheduling worker threads, calling the user-provided mapper and reducer tasks, and communicating and managing their arguments and results. We describe a simple <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework parameterized by an <i>input type</i> <img alt="Image" height="9" src="images/B9780124159501000276/fx004.jpg" width="11"/>, a <i>key type</i> <img alt="Image" height="9" src="images/B9780124159501000276/fx005.jpg" width="5"/>, a <i>value type</i> <img alt="Image" height="9" src="images/B9780124159501000276/fx006.jpg" width="5"/>, and an <i>output type</i> <img alt="Image" height="9" src="images/B9780124159501000276/fx007.jpg" width="19"/>. In practice, <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> frameworks are more complicated, with configuration settings and optimizations omitted here for simplicity.</p><p class="text" id="p0085">A <img alt="Image" height="11" src="images/B9780124159501000276/fx008.jpg" width="39"/> task (<a href="#f0020" id="cf0050">Fig. 17.3</a>) extends the <img alt="Image" height="9" src="images/B9780124159501000276/fx009.jpg" width="99"/> class from Java's fork-join framework, described in Chapter <a href="B9780124159501000264.xhtml">16</a>. Its <img alt="Image" height="11" src="images/B9780124159501000276/fx010.jpg" width="52"/>() method provides the task with an input of type <img alt="Image" height="9" src="images/B9780124159501000276/fx004.jpg" width="11"/>, which it stores in the object's <img alt="Image" height="11" src="images/B9780124159501000276/fx011.jpg" width="31"/> field. The <img alt="Image" height="12" src="images/B9780124159501000276/fx012.jpg" width="57"/> method, inherited from <img alt="Image" height="9" src="images/B9780124159501000276/fx009.jpg" width="99"/>, pairs keys of type <img alt="Image" height="9" src="images/B9780124159501000276/fx005.jpg" width="5"/> with values of type <img alt="Image" height="9" src="images/B9780124159501000276/fx006.jpg" width="5"/>, accumulating them in a <img alt="Image" height="12" src="images/B9780124159501000276/fx013.jpg" width="52"/> result.</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="92" src="images/B9780124159501000276/gr003.jpg" width="458"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.3</span> The <img alt="Image" height="11" src="images/B9780124159501000276/fx008.jpg" width="39"/> class.</div></figcaption></figure></div><p class="text" id="p0090">A <img alt="Image" height="9" src="images/B9780124159501000276/fx014.jpg" width="46"/> task (<a href="#f0025" id="cf0055">Fig. 17.4</a>) also extends <img alt="Image" height="9" src="images/B9780124159501000276/fx009.jpg" width="99"/>. Its <img alt="Image" height="11" src="images/B9780124159501000276/fx010.jpg" width="52"/>() method provides the task with a key and a list of values, and its <img alt="Image" height="12" src="images/B9780124159501000276/fx012.jpg" width="57"/> method produces a single result of type <img alt="Image" height="9" src="images/B9780124159501000276/fx007.jpg" width="19"/>. <span aria-label="Page 409" epub:type="pagebreak" id="page_409" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="125" src="images/B9780124159501000276/gr004.jpg" width="434"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.4</span> The <img alt="Image" height="9" src="images/B9780124159501000276/fx014.jpg" width="46"/> class.</div></figcaption></figure></div><p class="text" id="p0095"/><div class="boxg1" id="enun0010"><p class="b1num">Pragma 17.1.1 </p><div><p class="b1textfl" id="p0100">The parameter type <img alt="Image" height="11" src="images/B9780124159501000276/fx015.jpg" width="66"/> of the <img alt="Image" height="11" src="images/B9780124159501000276/fx016.jpg" width="113"/>() and <img alt="Image" height="11" src="images/B9780124159501000276/fx017.jpg" width="119"/>() methods is a Java functional interface, implemented by an object with a single <img alt="Image" height="11" src="images/B9780124159501000276/fx018.jpg" width="19"/>() method. To tell the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework how to create mapper and reducer tasks, we use Java's <i>lambda</i> construct for anonymous method definition. For example, here is how to tell the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework to use the <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> class's implementation of mappers:</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" class="img" height="11" src="images/B9780124159501000276/fx019.jpg" width="349"/></figure></div><p class="textfl"> The argument to <img alt="Image" height="11" src="images/B9780124159501000276/fx016.jpg" width="113"/>() is a lambda: a parameter list and an expression separated by an arrow. The empty parentheses on the left indicate that the method takes no arguments, and the expression on the right states that the method creates and returns a new <img alt="Image" height="11" src="images/B9780124159501000276/fx020.jpg" width="106"/> object. This pattern, where a lambda takes no arguments and simply calls another method or operator, is so common it has a shorthand syntax:</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" class="img" height="11" src="images/B9780124159501000276/fx021.jpg" width="307"/></figure></div><p class="textfl"> Lambdas in Java have many other features, and the reader is encouraged to consult Java documentation for a more complete picture. As discussed in the chapter notes, other languages such as C#, C++, Scala, and Clojure support similar constructs.</p></div></div><p class="textfl"/><p class="text" id="p0105"><a href="#f0030" id="cf0060">Fig. 17.5</a> shows the methods of the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework. (We discuss its implementation in Section <a href="#s0030" id="cf0065">17.1.4</a>.) Even in the simplified form described here, the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework has several kinds of settings, too many to provide gracefully as arguments to the constructor. Instead, it provides individual methods to control each setting. The <img alt="Image" height="11" src="images/B9780124159501000276/fx016.jpg" width="113"/>() and <img alt="Image" height="11" src="images/B9780124159501000276/fx017.jpg" width="119"/>() methods are used to tell the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework how to create new mapper and reducer tasks. The <img alt="Image" height="11" src="images/B9780124159501000276/fx010.jpg" width="52"/>() method takes a list of <img alt="Image" height="9" src="images/B9780124159501000276/fx004.jpg" width="11"/> objects, and one mapper task is created for each such input. Finally, the <img alt="Image" height="9" src="images/B9780124159501000276/fx022.jpg" width="23"/>() method does the work: It returns a <img alt="Image" height="12" src="images/B9780124159501000276/fx023.jpg" width="66"/> pairing each key with an output value.<span aria-label="Page 410" epub:type="pagebreak" id="page_410" role="doc-pagebreak"/><span aria-label="Page 411" epub:type="pagebreak" id="page_411" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="109" src="images/B9780124159501000276/gr005.jpg" width="439"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.5</span> The <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework: methods.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0020"><a id="st0030"/>17.1.2 A <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/>-based <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> application</h3><p class="textfl" id="p0110"><a href="#f0045" id="cf0070">Fig. 17.6</a> shows one way to implement the <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> application using the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework. This application is structured as a class with static fields, methods, and inner classes. The application's <img alt="Image" height="12" src="images/B9780124159501000276/fx024.jpg" width="38"/> method (lines 5–14) first reads the document, storing in its static <img alt="Image" height="8" src="images/B9780124159501000276/fx025.jpg" width="25"/> field a reference to a list of lower-case strings stripped of punctuation and numerals (line 6). It partitions that list into approximately equal sublists, one for each mapper (line 7). It creates a <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> instance using <img alt="Image" height="11" src="images/B9780124159501000276/fx026.jpg" width="79"/> and the input type, <img alt="Image" height="11" src="images/B9780124159501000276/fx027.jpg" width="39"/> as the key type, and <img alt="Image" height="11" src="images/B9780124159501000276/fx028.jpg" width="25"/> as the value and output types. In lines 9–11 the <img alt="Image" height="12" src="images/B9780124159501000276/fx024.jpg" width="38"/> method initializes the framework, using lambdas to specify how to create mapper and reducer tasks, and provides the framework with a list containing each mapper's input. The computation is triggered by calling <img alt="Image" height="11" src="images/B9780124159501000276/fx029.jpg" width="91"/>, which returns a <img alt="Image" height="11" src="images/B9780124159501000276/fx030.jpg" width="106"/>, pairing each string found in the document with the number of times it occurs (line 12).</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="553" src="images/B9780124159501000276/gr006.jpg" width="490"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.6</span> A <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/>-based <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> application.</div></figcaption></figure></div><p class="text" id="p0115">The mapper and reducer tasks for this application are defined by static nested classes (lines 16–25). The <img alt="Image" height="11" src="images/B9780124159501000276/fx020.jpg" width="106"/> task (line 16) does most of the work. As noted, its input is the <img alt="Image" height="11" src="images/B9780124159501000276/fx026.jpg" width="79"/> it scans. Its key type is <img alt="Image" height="11" src="images/B9780124159501000276/fx027.jpg" width="39"/>, and its value type is <img alt="Image" height="11" src="images/B9780124159501000276/fx031.jpg" width="45"/>. It creates a <img alt="Image" height="11" src="images/B9780124159501000276/fx032.jpg" width="153"/> to hold its results (line 18). For each word in its sublist, the map's <img alt="Image" height="9" src="images/B9780124159501000276/fx033.jpg" width="32"/>() method binds that word to 1 if the word is not already in the map, and otherwise increments the value bound to that word (line 20). It then returns the map.</p><p class="text" id="p0120">When all the mapper tasks have completed, the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework merges each word's counts into a list, and passes each key–list pair to a <img alt="Image" height="9" src="images/B9780124159501000276/fx034.jpg" width="113"/> task. It takes as input a word and its list of counts, and simply sums and returns them (line 28).</p></section><section><h3 class="h2hd" id="s0025"><a id="st0035"/>17.1.3 A <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/>-based <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> application</h3><p class="textfl" id="p0125"><a href="#f0050" id="cf0075">Fig. 17.7</a> shows a <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> application using the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework. Like <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/>, this application is structured as a class with static fields, methods, and inner classes. The application's <img alt="Image" height="12" src="images/B9780124159501000276/fx024.jpg" width="38"/> method reads the data points from a file as a <img alt="Image" height="9" src="images/B9780124159501000276/fx035.jpg" width="72"/> (line 8). It chooses distinct random points as starting cluster centers (line 9). It creates a <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> instance (line 11), using <img alt="Image" height="9" src="images/B9780124159501000276/fx035.jpg" width="72"/> as the input type <img alt="Image" height="9" src="images/B9780124159501000276/fx004.jpg" width="11"/>, <img alt="Image" height="11" src="images/B9780124159501000276/fx031.jpg" width="45"/> as the key type <img alt="Image" height="9" src="images/B9780124159501000276/fx005.jpg" width="5"/>, <img alt="Image" height="9" src="images/B9780124159501000276/fx035.jpg" width="72"/> as the value type <img alt="Image" height="9" src="images/B9780124159501000276/fx006.jpg" width="5"/>, and <img alt="Image" height="9" src="images/B9780124159501000276/fx036.jpg" width="31"/> as the output type <img alt="Image" height="9" src="images/B9780124159501000276/fx007.jpg" width="19"/>. In lines 12–14 the <img alt="Image" height="12" src="images/B9780124159501000276/fx024.jpg" width="38"/> method uses lambdas to specify how to create mapper and reducer tasks, and provides the framework with a list of input lists of approximately equal size, one for each mapper. The computation is triggered by calling <img alt="Image" height="11" src="images/B9780124159501000276/fx029.jpg" width="91"/>, which returns a <img alt="Image" height="11" src="images/B9780124159501000276/fx037.jpg" width="120"/> pairing each of <i>k</i> cluster IDs to the central point of each cluster. (It would be easy to have mappers also return the clusters themselves, but we omit this step for brevity.)</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="701" src="images/B9780124159501000276/gr007.jpg" width="461"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.7</span> A <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/>-based <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> application.</div></figcaption></figure></div><p class="text" id="p0130">The <img alt="Image" height="9" src="images/B9780124159501000276/fx038.jpg" width="45"/> constant determines when the process is deemed to have converged (line 3), and the <img alt="Image" height="9" src="images/B9780124159501000276/fx039.jpg" width="72"/> variable keeps track of the distance between successive rounds' centers (line 15). The application repeatedly iterates calls to the <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework (line 16), starting with randomly chosen cluster centers, and using the cluster centers generated by each iteration as the cluster centers for the next (line 19). The iteration halts when the distance between successive centers converges to less than <img alt="Image" height="9" src="images/B9780124159501000276/fx038.jpg" width="45"/>. (Of course, in a real implementation, it would be prudent to stop if the process does not appear to be converging.)<span aria-label="Page 412" epub:type="pagebreak" id="page_412" role="doc-pagebreak"/><span aria-label="Page 413" epub:type="pagebreak" id="page_413" role="doc-pagebreak"/><span aria-label="Page 414" epub:type="pagebreak" id="page_414" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0030"><a id="st0040"/>17.1.4 The <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> implementation</h3><p class="textfl" id="p0135">We now describe the implementation of the simple <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> framework that appears in <a href="#f0055" id="cf0080">Fig. 17.8</a>. As noted earlier, a production-quality MapReduce framework would have many more configuration settings and options. Note also that MapReduce frameworks designed for distributed systems are likely to look quite different, because communication is more expensive, and fault tolerance is a concern.</p><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="667" src="images/B9780124159501000276/gr008.jpg" width="518"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.8</span> The <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> implementation.</div></figcaption></figure></div><p class="text" id="p0140">The framework's constructor initializes the object's fields. The framework uses a work-stealing <img alt="Image" height="9" src="images/B9780124159501000276/fx040.jpg" width="76"/> to execute mapper and reducer tasks (line 7). The constructor sets the default mapper and reducer creation methods (lines 8 and 9) to throw exceptions if the user forgets to initialize them. The class is designed for reuse.</p><p class="text" id="p0145">The <img alt="Image" height="9" src="images/B9780124159501000276/fx022.jpg" width="23"/>() method does all the work in four phases. In the first phase, for each input in its list of inputs (line 13), it creates a mapper task using the user-provided supplier (line 14), initializes that task's input (line 15), starts the asynchronous task (line 16), and stores the task in a <img alt="Image" height="11" src="images/B9780124159501000276/fx041.jpg" width="73"/> (line 17).</p><p class="text" id="p0150">In the second phase, the <img alt="Image" height="9" src="images/B9780124159501000276/fx022.jpg" width="23"/>() method creates a <img alt="Image" height="12" src="images/B9780124159501000276/fx042.jpg" width="93"/> to hold the results of the mapper tasks (line 19). It then revisits each mapper task (line 20), joins it (line 21) to get its result, and adds that result to that key's list to merge the accumulators associated with each key (lines 22–24).</p><p class="text" id="p0155">The third phase is similar to the first, except that reducer tasks are created (line 30), one per output key, initialized (line 31), and started (line 32).</p><p class="text" id="p0160">In the final phase, the results of the reducer tasks are collected and returned (lines 36–42).</p></section></section><section><h2 class="h1hd" id="s0035"><a id="st0045"/>17.2 Stream computing</h2><p class="textfl" id="p0165">Java (starting from Java 8) provides explicit support for data-parallel computation through the <img alt="Image" height="9" src="images/B9780124159501000276/fx043.jpg" width="52"/> class<sup><a epub:type="noteref" href="#fn003" id="cf0085" role="doc-noteref">3</a></sup> (<img alt="Image" height="11" src="images/B9780124159501000276/fx044.jpg" width="107"/>) . Streams are not data structures: Instead, they should be thought of as pipelines that carry values from a source (often a container such as a <img alt="Image" height="9" src="images/B9780124159501000276/fx045.jpg" width="38"/>), through a series of transformations (perhaps applied in parallel), to a destination (also often a container).</p><p class="text" id="p0170">Java streams are an example of <i>functional programming</i>, a discipline in which programs are treated like mathematical functions, producing new values and data structures, but never modifying existing ones. Functional programming has a long history, but it is only relatively recently that it has entered the repertoire of techniques that every serious programmer should understand.</p><p class="text" id="p0175">Functional programming is attractive because it avoids many of the complex side effects and interactions that form the focus of most of this book. For a long time, however, functional programming was widely viewed as an unnatural programming style that produced elegant but inefficient programs. Nevertheless, Jim Morris once remarked: </p><p class="quote" id="sp0110"><i>Functional languages are unnatural to use; but so are knives and forks, diplomatic protocols, double-entry bookkeeping, and a host of other things modern civilization has found useful.</i> <span aria-label="Page 415" epub:type="pagebreak" id="page_415" role="doc-pagebreak"/></p><p class="textfl"> As for efficiency, Morris goes on to compare functional programming to two Japanese arts: Haiku, a form of poetry, and Karate, a form of martial arts. Your mastery of Haiku will be appreciated only by those who already appreciate Haiku, but in a bar fight, your mastery of Karate will be appreciated even by those who do not know Karate.</p><p class="text" id="p0180">Is functional programming more like Haiku or more like Karate? For a long time, most computer scientists dismissed functional programming as Haiku. Today, however, improvements in hardware, compiler, and run-time technology have rendered such sweeping dismissals obsolete. Nevertheless, even today, the functional programming style should not be applied without careful thought. Here, we focus on the use of a functional programming style, in which <i>aggregate</i> operations are applied to the values in Java streams.</p><p class="text" id="p0185">A stream's transformations and reductions are applied <i>lazily</i>: No computation occurs until it becomes absolutely necessary. Instead, <i>intermediate operations</i> set the stage for the desired transformations without performing them. Laziness ensures that by the time the work must be done, the compiler and run-time systems have accumulated as much information as possible about the programmer's intended transformations, enabling optimizations that would not be possible if operations were applied in an eager, one-at-a-time manner. For example, multiple intermediate operations can be accumulated lazily and then fused into a single traversal when the results are needed. Laziness also allows streams to be <i>unbounded:</i> One can construct, for example, an unbounded stream of prime numbers, or an unbounded stream of random points.</p><p class="text" id="p0190">Once the desired (lazy) transformations have been set in place, a <i>terminal</i> operation applies those transformations and returns the result in the form of a container object, such as a <img alt="Image" height="9" src="images/B9780124159501000276/fx045.jpg" width="38"/> or <img alt="Image" height="9" src="images/B9780124159501000276/fx046.jpg" width="32"/>, or perhaps as a scalar, such as a <img alt="Image" height="11" src="images/B9780124159501000276/fx028.jpg" width="25"/> or <img alt="Image" height="9" src="images/B9780124159501000276/fx047.jpg" width="38"/>. Once a terminal operation has been applied to a stream, that stream is deemed to be consumed, and cannot be reused.</p><p class="text" id="p0195">One of the most common terminal operations is <img alt="Image" height="9" src="images/B9780124159501000276/fx048.jpg" width="45"/>(), which folds the stream elements into a cumulative result called a <img alt="Image" height="9" src="images/B9780124159501000276/fx049.jpg" width="65"/>. Such transformations can be done either sequentially or in parallel. The <img alt="Image" height="11" src="images/B9780124159501000276/fx050.jpg" width="133"/> class provides a useful set of predefined <img alt="Image" height="9" src="images/B9780124159501000276/fx049.jpg" width="65"/> instances.</p><p class="text" id="p0200">In the next sections, we will use the <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> applications to introduce many of the basic concepts associated with aggregate data. Before discussing how to design and implement parallel stream-based versions of these applications, we look at sequential stream-based versions, to help readers become accustomed to this style of programming. A word of warning: This book is not a language reference manual. There are some restrictions and corner cases to consider when using streams, either in Java or in other languages that provide similar functionality (see the chapter notes). Before you use these constructs in a real application, consult the language documentation.</p><section><h3 class="h2hd" id="s0040"><a id="st0050"/>17.2.1 A stream-based <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> application</h3><p class="textfl" id="p0205"><span aria-label="Page 416" epub:type="pagebreak" id="page_416" role="doc-pagebreak"/>The <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> application's first step is to read the target file, line-by-line, splitting each line into individual words, and converting each word to lower case. <a href="#f0060" id="cf0090">Fig. 17.9</a> shows one way to solve this task using aggregate operations. (Most applications that use streams are written in this kind of “chained” style.) The method first prepares a regular expression to be used to split lines into words (line 3). It then creates a <img alt="Image" height="9" src="images/B9780124159501000276/fx052.jpg" width="92"/> to read from the document file (line 4). The <img alt="Image" height="9" src="images/B9780124159501000276/fx053.jpg" width="31"/>() method returns a <img alt="Image" height="11" src="images/B9780124159501000276/fx054.jpg" width="93"/> whose elements are lines read from the <img alt="Image" height="9" src="images/B9780124159501000276/fx052.jpg" width="92"/>. Here are the next steps:</p><div><ol><li class="numlist" id="o0010">Line 7  The <img alt="Image" height="9" src="images/B9780124159501000276/fx055.jpg" width="19"/>() method takes as argument a lambda expression and creates a new stream by applying that lambda to each stream element, replacing each element with another. Here, we transform each line to lower case.</li><li class="numlist" id="o0015">Line 8  The <img alt="Image" height="11" src="images/B9780124159501000276/fx056.jpg" width="45"/>() method takes as an argument a lambda expression and creates a new stream by applying that lambda to each stream element, replacing each element with a <i>stream</i> of other elements, and then "flattening" these streams into a single stream. Here, we transform each line to a stream of individual words: by calling the <img alt="Image" height="9" src="images/B9780124159501000276/fx057.jpg" width="45"/> class's <img alt="Image" height="12" src="images/B9780124159501000276/fx058.jpg" width="97"/> method to replace each line with a stream of individual words.</li><li class="numlist" id="o0020">Line 9  At last, it is time to produce a result. As noted earlier, the <img alt="Image" height="9" src="images/B9780124159501000276/fx048.jpg" width="45"/>() method is a common way of storing the stream elements in a kind of “accumulator” object, in this case a <img alt="Image" height="11" src="images/B9780124159501000276/fx026.jpg" width="79"/>.</li></ol></div><p class="textfl"> The <img alt="Image" height="9" src="images/B9780124159501000276/fx059.jpg" width="58"/>() method shown here is sequential.</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="208" src="images/B9780124159501000276/gr009.jpg" width="506"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.9</span> Stream-based <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> application: the <img alt="Image" height="9" src="images/B9780124159501000276/fx051.jpg" width="52"/>() method.</div></figcaption></figure></div><p class="text" id="p0225">Using aggregate operations (<a href="#f0065" id="cf0095">Fig. 17.10</a>), <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> is quite succinct. It calls <img alt="Image" height="9" src="images/B9780124159501000276/fx051.jpg" width="52"/>(), which returns a list of lower-case strings (line 16). It turns the list into a stream (line 18) and then collects the stream contents into a <img alt="Image" height="11" src="images/B9780124159501000276/fx030.jpg" width="106"/> (line 19). Here, the <img alt="Image" height="12" src="images/B9780124159501000276/fx060.jpg" width="78"/> collector takes two arguments (line 20). The first argument is a lambda that states how to compute each stream element's <span aria-label="Page 417" epub:type="pagebreak" id="page_417" role="doc-pagebreak"/>key. The call to <img alt="Image" height="12" src="images/B9780124159501000276/fx061.jpg" width="124"/> returns the <i>identity</i> function, which returns its own input, meaning that each string is its own key (line 21). The second argument is a <i>downstream</i> reducer that operates on the stream of strings that map to the same key (line 22). Of course, the stream of strings that map to <img alt="Image" height="6" src="images/B9780124159501000276/fx062.jpg" width="6"/> is a stream of <i>k</i> copies of <img alt="Image" height="6" src="images/B9780124159501000276/fx062.jpg" width="6"/>, where <i>k</i> is the number of times that string appears in the document. The <img alt="Image" height="12" src="images/B9780124159501000276/fx063.jpg" width="138"/> container simply counts the number of elements in the stream.</p><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="208" src="images/B9780124159501000276/gr010.jpg" width="315"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.10</span> Stream-based <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> application: aggregate data.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0045"><a id="st0055"/>17.2.2 A stream-based <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> application</h3><p class="textfl" id="p0230">Recall that each iteration of <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> algorithm has <i>k</i> tentative central points around which it clusters points. Once the clusters are complete, if the new centers are too far from the old centers, it computes a new tentative center for each cluster. The <i>barycenter</i> of a set of points <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000276/si3.png" style="vertical-align:middle" width="84"/></span> is given by</p><p class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="66" src="images/B9780124159501000276/si4.png" width="119"/><a id="deq1"/></p></div><p class="textfl"> <a href="#f0070" id="cf0100">Fig. 17.11</a> shows a stream-based <img alt="Image" height="11" src="images/B9780124159501000276/fx064.jpg" width="66"/>() function. It first turns the <img alt="Image" height="9" src="images/B9780124159501000276/fx035.jpg" width="72"/> into a stream (line 4) and then applies <img alt="Image" height="12" src="images/B9780124159501000276/fx065.jpg" width="50"/> to the stream to produce a single value. The argument to <img alt="Image" height="12" src="images/B9780124159501000276/fx065.jpg" width="50"/> is a lambda defining a binary operator that combines two points into a third. Reduction repeatedly applies this operator to the stream elements until there is only one <img alt="Image" height="9" src="images/B9780124159501000276/fx036.jpg" width="31"/> left. In this case, the binary operation is the <img alt="Image" height="9" src="images/B9780124159501000276/fx036.jpg" width="31"/> class's <img alt="Image" height="12" src="images/B9780124159501000276/fx066.jpg" width="37"/> method, and <img alt="Image" height="12" src="images/B9780124159501000276/fx065.jpg" width="50"/> simply sums the points in the stream (line 5). The result of this summation is not, however, a <img alt="Image" height="9" src="images/B9780124159501000276/fx036.jpg" width="31"/>. Because reduction must be defined even for empty streams, the result is an object of type <img alt="Image" height="11" src="images/B9780124159501000276/fx067.jpg" width="100"/>, which may contain a <img alt="Image" height="9" src="images/B9780124159501000276/fx036.jpg" width="31"/> or be empty. The method calls the result's <img alt="Image" height="11" src="images/B9780124159501000276/fx018.jpg" width="19"/>() operation to extract the <img alt="Image" height="9" src="images/B9780124159501000276/fx036.jpg" width="31"/>, and multiplies the point by <span class="hiddenClass"><mml:math><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000276/si5.png" style="vertical-align:middle" width="9"/></span>, where <i>n</i> is the number of points in the cluster (line 6).</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="109" src="images/B9780124159501000276/gr011.jpg" width="348"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.11</span> The <img alt="Image" height="11" src="images/B9780124159501000276/fx064.jpg" width="66"/>() method.</div></figcaption></figure></div><p class="text" id="p0235"><span aria-label="Page 418" epub:type="pagebreak" id="page_418" role="doc-pagebreak"/>Suppose we have two methods that compute barycenters, one sequential and one parallel, and suppose we want to design an experiment to compare how they perform. Because the effectiveness of parallelism often depends on scale, a natural way to compare these methods is to generate a sequence of increasingly large sets of random points, take the barycenter of each set using both methods, and compare their performance as a function of the set size. This application illustrates a powerful aspect of streams: the ability to define <i>unbounded</i> streams that lazily produce an arbitrary number of values. <a href="#f0075" id="cf0105">Fig. 17.12</a> shows how to define a stream that produces an arbitrary number of randomly generated points. The call</p><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" class="img" height="11" src="images/B9780124159501000276/fx068.jpg" width="258"/></figure></div><p class="textfl"> constructs a new stream of length <img alt="Image" height="9" src="images/B9780124159501000276/fx069.jpg" width="5"/> from an unbounded stream.</p><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="93" src="images/B9780124159501000276/gr012.jpg" width="427"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.12</span> A stream of randomly generated points.</div></figcaption></figure></div><p class="text" id="p0240">The stream-based <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> application starts out like its <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/>-based counterpart: It reads the data points from a file as a <img alt="Image" height="9" src="images/B9780124159501000276/fx035.jpg" width="72"/> (line 12), chooses distinct random points as starting cluster centers (line 13), and iterates the algorithm until it converges (line 15) (<a href="#f0085" id="cf0110">Fig. 17.13</a>).</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="454" src="images/B9780124159501000276/gr013.jpg" width="503"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.13</span> Stream-based <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> application: aggregate data.</div></figcaption></figure></div><p class="text" id="p0245">In the first step, the application clusters the data points around the centers by creating a <img alt="Image" height="11" src="images/B9780124159501000276/fx070.jpg" width="160"/> that maps each center point's index to the set of points closest to that center (line 16).</p><p class="text" id="p0250">In the second step, it constructs a stream from the first step's map, and turns it back into a map, except replacing each cluster with its barycenter (line 21). The first argument to <img alt="Image" height="9" src="images/B9780124159501000276/fx071.jpg" width="12"/>() is a lambda expression that maps the stream element to a key, and the second maps the stream element to a value. Here, the key is the center index, and the value is the cluster's barycenter.<span aria-label="Page 419" epub:type="pagebreak" id="page_419" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0050"><a id="st0060"/>17.2.3 Making aggregate operations parallel</h3><p class="textfl" id="p0255">We have seen that the contents of a container such as a <img alt="Image" height="9" src="images/B9780124159501000276/fx072.jpg" width="45"/> or <img alt="Image" height="12" src="images/B9780124159501000276/fx013.jpg" width="52"/> can be fed into a <img alt="Image" height="9" src="images/B9780124159501000276/fx043.jpg" width="52"/>, and its contents can be manipulated by aggregate operations such as <img alt="Image" height="9" src="images/B9780124159501000276/fx055.jpg" width="19"/>(), <img alt="Image" height="9" src="images/B9780124159501000276/fx073.jpg" width="39"/>(), <img alt="Image" height="12" src="images/B9780124159501000276/fx065.jpg" width="50"/>, or <img alt="Image" height="9" src="images/B9780124159501000276/fx048.jpg" width="45"/>(). These aggregate operations are carried out sequentially, operating in a one-at-a-time order on the values in the stream.</p><p class="text" id="p0260">Instead of constructing a sequential <img alt="Image" height="9" src="images/B9780124159501000276/fx043.jpg" width="52"/> from a container, one can construct a <img alt="Image" height="9" src="images/B9780124159501000276/fx074.jpg" width="106"/>. The Java runtime partitions a parallel stream into multiple substreams, applies aggregate operations to the substreams in parallel, and then combines the results. For example, this code will print this list of Boston street names in alphabetical order:</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" class="img" height="44" src="images/B9780124159501000276/fx075.jpg" width="446"/></figure></div><p class="textfl"><span aria-label="Page 420" epub:type="pagebreak" id="page_420" role="doc-pagebreak"/> while this code will print the list of streets in a nondeterministic order:</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" class="img" height="44" src="images/B9780124159501000276/fx076.jpg" width="446"/></figure></div><p class="textfl"> One can also transform a sequential stream into a parallel stream by calling the <img alt="Image" height="11" src="images/B9780124159501000276/fx077.jpg" width="50"/>() method:</p><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" class="img" height="27" src="images/B9780124159501000276/fx078.jpg" width="375"/></figure></div><p class="textfl"/><p class="text" id="p0265">Recall that <i>reduction</i> operations transform a stream into a container or a scalar value. Here, for convenient reference, is the key reduction in the stream-based <img alt="Image" height="9" src="images/B9780124159501000276/fx001.jpg" width="59"/> application of <a href="#f0065" id="cf0115">Fig. 17.10</a>:</p><div class="pageavoid"><figure class="fig" id="f0105"><img alt="Image" class="img" height="108" src="images/B9780124159501000276/fx079.jpg" width="262"/></figure></div><p class="textfl"> Here is a parallel version:</p><div class="pageavoid"><figure class="fig" id="f0110"><img alt="Image" class="img" height="108" src="images/B9780124159501000276/fx080.jpg" width="280"/></figure></div><p class="textfl"> We made three changes: we replaced the call to <img alt="Image" height="8" src="images/B9780124159501000276/fx081.jpg" width="39"/>() with a call to <img alt="Image" height="11" src="images/B9780124159501000276/fx082.jpg" width="92"/>(), and the call to <img alt="Image" height="12" src="images/B9780124159501000276/fx060.jpg" width="78"/> with a call to <span class="inlinecode">groupingByConcurrent()</span>, which returns a <img alt="Image" height="11" src="images/B9780124159501000276/fx083.jpg" width="174"/>.</p><p class="text" id="p0270">There are some pitfalls to avoid when combining lambda expressions with concurrent streams. First, a lambda expression operating on a stream, sequential or parallel, is said to be <i>interfering</i> if it alters the stream's source. Interfering lambda expressions will usually cause run-time exceptions. For example, if <img alt="Image" height="9" src="images/B9780124159501000276/fx084.jpg" width="25"/> is a <img alt="Image" height="11" src="images/B9780124159501000276/fx085.jpg" width="86"/>, the following code will throw <img alt="Image" height="11" src="images/B9780124159501000276/fx086.jpg" width="206"/> because the list is being modified at the same time the stream is navigating through each of its values.</p><div class="pageavoid"><figure class="fig" id="f0115"><img alt="Image" class="img" height="11" src="images/B9780124159501000276/fx087.jpg" width="239"/></figure></div><p class="textfl"/><p class="text" id="p0275">A lambda expression is <i>stateful</i> if its effect depends on aspects of its environment that could change from one call to another. Stateful lambda expressions, while not illegal, should be used with care. The following two lines of code use the same stateful lambda expression. The first line simply copies values, in order, from a source list to a target list. In the second line, however, <span aria-label="Page 421" epub:type="pagebreak" id="page_421" role="doc-pagebreak"/>the target list's <img alt="Image" height="9" src="images/B9780124159501000276/fx088.jpg" width="18"/>() method may be called concurrently, possibly resulting in an exception if the target list is not thread-safe. Even if the target is properly synchronized, the order in which elements are copied may be different each time the code is run.</p><div class="pageavoid"><figure class="fig" id="f0120"><img alt="Image" class="img" height="27" src="images/B9780124159501000276/fx089.jpg" width="312"/></figure></div><p class="textfl"/><p class="text" id="p0280">For many applications, <img alt="Image" height="11" src="images/B9780124159501000276/fx082.jpg" width="92"/>() is likely to be an effective way of executing aggregate operations in parallel. But what about applications that want more explicit control over how aggregate operations are parallelized?</p><p class="text" id="p0285">A <img alt="Image" height="11" src="images/B9780124159501000276/fx093.jpg" width="93"/> provides the ability to split a stream into parts, providing the opportunity to operate on the parts in parallel. In a typical spliterator use, the stream is recursively split until it falls below a threshold size, at which point it can be processed sequentially. <a href="#f0125" id="cf0120">Fig. 17.14</a> shows the main method of <img alt="Image" height="9" src="images/B9780124159501000276/fx090.jpg" width="119"/>. It turns the document into a <img alt="Image" height="11" src="images/B9780124159501000276/fx054.jpg" width="93"/> and then into a spliterator. The actual work is done by the <img alt="Image" height="9" src="images/B9780124159501000276/fx092.jpg" width="146"/> class shown in <a href="#f0130" id="cf0125">Fig. 17.15</a>.</p><div class="pageavoid"><figure class="fig" id="f0125"><img alt="Image" height="125" src="images/B9780124159501000276/gr014.jpg" width="517"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.14</span> The <img alt="Image" height="9" src="images/B9780124159501000276/fx090.jpg" width="119"/> application: <img alt="Image" height="12" src="images/B9780124159501000276/fx091.jpg" width="38"/> method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0130"><img alt="Image" height="470" src="images/B9780124159501000276/gr015.jpg" width="503"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.15</span> The <img alt="Image" height="9" src="images/B9780124159501000276/fx092.jpg" width="146"/> class.</div></figcaption></figure></div><p class="text" id="p0290">This class inherits from <img alt="Image" height="11" src="images/B9780124159501000276/fx094.jpg" width="214"/>, so its <img alt="Image" height="12" src="images/B9780124159501000276/fx012.jpg" width="57"/> method does all the work. The task constructor takes a single argument, a <img alt="Image" height="11" src="images/B9780124159501000276/fx095.jpg" width="127"/>. The <img alt="Image" height="12" src="images/B9780124159501000276/fx012.jpg" width="57"/> method first initializes a <img alt="Image" height="11" src="images/B9780124159501000276/fx030.jpg" width="106"/> to hold the result (line 17). If the spliterator is larger than the <img alt="Image" height="9" src="images/B9780124159501000276/fx096.jpg" width="59"/> value (line 19), and if the spliterator is successfully split (line 19), then the method creates two subtasks: <img alt="Image" height="9" src="images/B9780124159501000276/fx097.jpg" width="25"/> and <img alt="Image" height="11" src="images/B9780124159501000276/fx098.jpg" width="32"/> (lines 21–22). (As its name suggests, the <img alt="Image" height="11" src="images/B9780124159501000276/fx099.jpg" width="52"/>() method might not split the stream, returning <i>null</i> for any reason.)</p><p class="text" id="p0295">The task then calls its children recursively. It forks the left child, allowing it to run in parallel with its caller (line 23), and it executes the right child directly, without forking (line 24). It merges the map returned by the right child with the result map (line 25), then it joins the left child, and does the same (line 28).</p><p class="text" id="p0300">Otherwise, if the stream is below threshold, or it cannot be split, then the task uses the <img alt="Image" height="11" src="images/B9780124159501000276/fx100.jpg" width="106"/>() operator to add the words in the stream directly to its result map.<span aria-label="Page 422" epub:type="pagebreak" id="page_422" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>17.3 Chapter notes</h2><p class="textfl" id="p0305">The notion of MapReduce as a programming pattern for distributed systems is due to Dean and Ghemawat <a epub:type="noteref" href="#br0170" id="cf0130" role="doc-noteref">[34]</a>. MapReduce frameworks for shared-memory multiprocessors include the Phoenix++ framework <a epub:type="noteref" href="#br0805" id="cf0135" role="doc-noteref">[161]</a> and Metis <a epub:type="noteref" href="#br0600" id="cf0140" role="doc-noteref">[120]</a>.</p><p class="text" id="p0310">Microsoft's C# and Visual Basic support <i>Language-Integrated query</i> (LINQ), which provides functionality comparable to that of Java streams, although expressed in the syntax of a query language.</p><p class="text" id="p0315"><span aria-label="Page 423" epub:type="pagebreak" id="page_423" role="doc-pagebreak"/>The Jim Morris quotes are taken from a Xerox PARC technical report <a epub:type="noteref" href="#br0660" id="cf0145" role="doc-noteref">[132]</a>.</p></section><section><h2 class="h1hd" id="s0060"><a id="st0070"/>17.4 Exercises</h2><p class="textfl" id="p0320"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 17.1 </p><div><p class="b1textfl" id="p0325">Java's <img alt="Image" height="11" src="images/B9780124159501000276/fx101.jpg" width="79"/> class is a specialized kind of stream whose elements are <img alt="Image" height="11" src="images/B9780124159501000276/fx102.jpg" width="25"/> values. (For computations involving lots of arithmetic, a <img alt="Image" height="11" src="images/B9780124159501000276/fx101.jpg" width="79"/> may be more efficient than a <img alt="Image" height="11" src="images/B9780124159501000276/fx103.jpg" width="79"/>.) This class provides a static <img alt="Image" height="12" src="images/B9780124159501000276/fx104.jpg" width="64"/> method that returns a stream containing <img alt="Image" height="11" src="images/B9780124159501000276/fx102.jpg" width="25"/> values <img alt="Image" height="9" src="images/B9780124159501000276/fx105.jpg" width="3"/> … <img alt="Image" height="11" src="images/B9780124159501000276/fx106.jpg" width="5"/>−1 and a static <img alt="Image" height="12" src="images/B9780124159501000276/fx107.jpg" width="104"/> method that returns a stream containing <img alt="Image" height="9" src="images/B9780124159501000276/fx105.jpg" width="3"/> … <img alt="Image" height="11" src="images/B9780124159501000276/fx106.jpg" width="5"/>.</p><p class="b1text" id="p0330">Using only the <img alt="Image" height="11" src="images/B9780124159501000276/fx101.jpg" width="79"/> class (no loops), define a class <img alt="Image" height="9" src="images/B9780124159501000276/fx108.jpg" width="38"/> with the following methods:</p><div class="pageavoid"><figure class="fig" id="f0135"><img alt="Image" class="img" height="11" src="images/B9780124159501000276/fx109.jpg" width="227"/></figure></div><p class="textfl"> tests whether a number is prime, and</p><div class="pageavoid"><figure class="fig" id="f0140"><img alt="Image" class="img" height="11" src="images/B9780124159501000276/fx110.jpg" width="239"/></figure></div><p class="textfl"> counts the number of primes less than a maximum.</p></div></div><p class="textfl"/><p class="text" id="p0335"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 17.2 </p><div><p class="b1textfl" id="p0340">A <i>comparator</i> is a lambda expression that takes two arguments. It returns a negative integer if its first argument is “less” than its second, a positive integer if it is “greater,” and 0 if the arguments are equivalent. Fill in the missing comparators in the following program.</p><div class="pageavoid"><figure class="fig" id="f0145"><img alt="Image" class="img" height="241" src="images/B9780124159501000276/fx111.jpg" width="407"/></figure></div><p class="textfl"> Your output should look like:</p><div class="pageavoid"><figure class="fig" id="f0150"><img alt="Image" class="img" height="44" src="images/B9780124159501000276/fx112.jpg" width="207"/></figure></div><p class="textfl"/></div></div><p class="textfl"/><p class="text" id="p0345"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 17.3 </p><div><p class="b1textfl" id="p0350"><a href="#f0155" id="cf0150">Fig. 17.16</a> shows part of a <img alt="Image" height="9" src="images/B9780124159501000276/fx113.jpg" width="79"/> class that uses <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> to multiply an <span class="hiddenClass"><mml:math><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000276/si6.png" style="vertical-align:middle" width="47"/></span> matrix by an <i>N</i>-element vector. For simplicity, it creates one mapper task for each matrix entry (in practice, it would be more efficient to have each mapper correspond to a larger submatrix).</p><div class="pageavoid"><figure class="fig" id="f0155"><img alt="Image" height="518" src="images/B9780124159501000276/gr016.jpg" width="449"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.16</span> The <img alt="Image" height="9" src="images/B9780124159501000276/fx113.jpg" width="79"/> class used in <a href="#enun0025" id="cf0010">Exercise 17.3</a>.</div></figcaption></figure></div><p class="b1text" id="p0355">The input matrix and vector are stored in static <img alt="Image" height="8" src="images/B9780124159501000276/fx114.jpg" width="39"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx115.jpg" width="39"/> fields of the <img alt="Image" height="9" src="images/B9780124159501000276/fx113.jpg" width="79"/> class (lines 3–4). <span aria-label="Page 424" epub:type="pagebreak" id="page_424" role="doc-pagebreak"/>Because Java does not permit arrays to be stored directly in maps or lists, the <img alt="Image" height="11" src="images/B9780124159501000276/fx008.jpg" width="39"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx014.jpg" width="46"/> classes, as static inner classes of <img alt="Image" height="9" src="images/B9780124159501000276/fx113.jpg" width="79"/>, access the <img alt="Image" height="8" src="images/B9780124159501000276/fx114.jpg" width="39"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx115.jpg" width="39"/> fields directly. A matrix position is identified by a <img alt="Image" height="9" src="images/B9780124159501000276/fx116.jpg" width="58"/> object that holds a row and column number (line 5). (As a technical aside, <img alt="Image" height="9" src="images/B9780124159501000276/fx116.jpg" width="58"/> objects can be used as keys in maps because they provide an <img alt="Image" height="11" src="images/B9780124159501000276/fx117.jpg" width="38"/>() operation that compares row and column numbers.) Each mapper is initialized with its own <img alt="Image" height="9" src="images/B9780124159501000276/fx116.jpg" width="58"/> object, identifying its position in the matrix (lines 21–26).</p><p class="b1text" id="p0360">Your task is to fill in the missing <img alt="Image" height="11" src="images/B9780124159501000276/fx008.jpg" width="39"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx014.jpg" width="46"/> classes. They should be static inner classes that access the static <img alt="Image" height="9" src="images/B9780124159501000276/fx115.jpg" width="39"/> and <img alt="Image" height="8" src="images/B9780124159501000276/fx114.jpg" width="39"/> fields.</p></div></div><p class="textfl"/><p class="text" id="p0365"><span aria-label="Page 425" epub:type="pagebreak" id="page_425" role="doc-pagebreak"/></p><div class="boxg1" id="enun0030"><p class="b1num">Exercise 17.4 </p><div><p class="b1textfl" id="p0370"><a href="#f0160" id="cf0155">Fig. 17.17</a> shows part of the code for a <img alt="Image" height="11" src="images/B9780124159501000276/fx118.jpg" width="93"/> class that multiplies one <span class="hiddenClass"><mml:math><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000276/si6.png" style="vertical-align:middle" width="47"/></span> matrix (<img alt="Image" height="9" src="images/B9780124159501000276/fx119.jpg" width="46"/>) by another (<img alt="Image" height="9" src="images/B9780124159501000276/fx120.jpg" width="46"/>). For simplicity, it creates one mapper task for each entry of <img alt="Image" height="9" src="images/B9780124159501000276/fx119.jpg" width="46"/>.</p><div class="pageavoid"><figure class="fig" id="f0160"><img alt="Image" height="518" src="images/B9780124159501000276/gr017.jpg" width="460"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.17</span> The <img alt="Image" height="11" src="images/B9780124159501000276/fx118.jpg" width="93"/> class used in <a href="#enun0030" id="cf0015">Exercise 17.4</a>.</div></figcaption></figure></div><p class="b1text" id="p0375">The two matrices are stored in static <img alt="Image" height="9" src="images/B9780124159501000276/fx119.jpg" width="46"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx120.jpg" width="46"/> fields of the <img alt="Image" height="11" src="images/B9780124159501000276/fx118.jpg" width="93"/> class (lines 3–4). Because Java does not permit arrays to be stored directly in maps or lists, the <img alt="Image" height="11" src="images/B9780124159501000276/fx008.jpg" width="39"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx014.jpg" width="46"/> classes, as static inner classes of <img alt="Image" height="9" src="images/B9780124159501000276/fx113.jpg" width="79"/>, access the <img alt="Image" height="9" src="images/B9780124159501000276/fx119.jpg" width="46"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx120.jpg" width="46"/> fields directly. A matrix position is identified by a <img alt="Image" height="9" src="images/B9780124159501000276/fx116.jpg" width="58"/> object that holds a row and column number (line 5). (As a technical aside, <img alt="Image" height="9" src="images/B9780124159501000276/fx116.jpg" width="58"/> objects can be used as keys in maps because they provide <span aria-label="Page 426" epub:type="pagebreak" id="page_426" role="doc-pagebreak"/>an <img alt="Image" height="11" src="images/B9780124159501000276/fx117.jpg" width="38"/>() operation that compares row and column numbers.) Each mapper is initialized with its own <img alt="Image" height="9" src="images/B9780124159501000276/fx116.jpg" width="58"/> object, identifying its position in the matrix (lines 21–26).</p><p class="b1text" id="p0380">Your task is to fill in the missing <img alt="Image" height="11" src="images/B9780124159501000276/fx008.jpg" width="39"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx014.jpg" width="46"/> classes. They should be static inner classes that access the static <img alt="Image" height="9" src="images/B9780124159501000276/fx119.jpg" width="46"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx120.jpg" width="46"/> fields.</p></div></div><p class="textfl"/><p class="text" id="p0385"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 17.5 </p><div><p class="b1textfl" id="p0390">In the <i>single-source shortest-path</i> (SSSP) problem, we are given a directed graph <i>G</i> and a source node <i>s</i> in <i>G</i>, and we must compute, for each node <i>n</i> in <i>G</i>, the length of the shortest directed path from <i>s</i> to <i>n</i> in <i>G</i>. For simplicity, we assume in this example that each edge has length 1.0, but it should be easy to assign different edge weights.</p><p class="b1text" id="p0395"><a href="#f0165" id="cf0160">Fig. 17.18</a> shows part of an iterated <img alt="Image" height="11" src="images/B9780124159501000276/fx003.jpg" width="59"/> SSSP implementation. Here, each node is represented as an <img alt="Image" height="11" src="images/B9780124159501000276/fx031.jpg" width="45"/>, and each distance as a <img alt="Image" height="9" src="images/B9780124159501000276/fx047.jpg" width="38"/>. The graph is a <img alt="Image" height="11" src="images/B9780124159501000276/fx122.jpg" width="174"/> carrying each node to a list of its neighbors (line 2). Node 0 is the source. The best-known distances <span aria-label="Page 427" epub:type="pagebreak" id="page_427" role="doc-pagebreak"/>from the source are tracked in a <img alt="Image" height="11" src="images/B9780124159501000276/fx123.jpg" width="127"/> (line 8), initially 0.0 for node 0, and essentially infinite for the rest (line 10).</p><div class="pageavoid"><figure class="fig" id="f0165"><img alt="Image" height="470" src="images/B9780124159501000276/gr018.jpg" width="365"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.18</span> The <img alt="Image" height="9" src="images/B9780124159501000276/fx121.jpg" width="26"/> class used in <a href="#enun0035" id="cf0020">Exercise 17.5</a>.</div></figcaption></figure></div><p class="b1text" id="p0400">Like <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/>, <img alt="Image" height="9" src="images/B9780124159501000276/fx121.jpg" width="26"/> is iterative. Unlike <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/>, the number of mappers varies at each iteration. We do a breadth-first traversal of the graph: Initially the source has distance 0, and in the first iteration, we assign its neighbors distance 1.0, in the next iteration we assign their neighbors the minimum of their current distance and 2.0, and so on. The method call at line 20 returns the list of nodes that have been discovered to be reachable from the source, and we feed these nodes to the next iteration's mapper tasks. The algorithm terminates when there is an iteration where no node's distance improves by more than a predefined <img alt="Image" height="9" src="images/B9780124159501000276/fx038.jpg" width="45"/> (line 25).</p><p class="b1text" id="p0405">Your job is to fill in the missing <img alt="Image" height="11" src="images/B9780124159501000276/fx008.jpg" width="39"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx014.jpg" width="46"/> classes. They should be static inner classes that access the static <img alt="Image" height="11" src="images/B9780124159501000276/fx124.jpg" width="32"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx125.jpg" width="59"/> fields.</p></div></div><p class="textfl"/><p class="text" id="p0410"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 17.6 </p><div><p class="b1textfl" id="p0415">In <a href="#f0165" id="cf0165">Fig. 17.18</a>, <a href="#enun0035" id="cf0170">Exercise 17.5</a>, the <img alt="Image" height="12" src="images/B9780124159501000276/fx126.jpg" width="178"/> method takes a <img alt="Image" height="11" src="images/B9780124159501000276/fx123.jpg" width="127"/> and returns a list of the <img alt="Image" height="11" src="images/B9780124159501000276/fx031.jpg" width="45"/> keys bound to values less than <img alt="Image" height="13" src="images/B9780124159501000276/fx127.jpg" width="106"/>. Implement this method using stream operators.</p></div></div><p class="textfl"/><p class="text" id="p0420"/><div class="boxg1" id="enun0045"><p class="b1num">Exercise 17.7 </p><div><p class="b1textfl" id="p0425">In <a href="#f0165" id="cf0175">Fig. 17.18</a>, <a href="#enun0035" id="cf0180">Exercise 17.5</a>, the <img alt="Image" height="12" src="images/B9780124159501000276/fx128.jpg" width="98"/> method takes two <img alt="Image" height="11" src="images/B9780124159501000276/fx123.jpg" width="127"/> arguments, which are assumed to have the same set of keys. It returns <i>true</i> if and only if the values bound to each key differ by less than a predefined constant <img alt="Image" height="9" src="images/B9780124159501000276/fx038.jpg" width="45"/>. Implement this method using stream operators.</p></div></div><p class="textfl"/><p class="text" id="p0430"/><div class="boxg1" id="enun0050"><p class="b1num">Exercise 17.8 </p><div><p class="b1textfl" id="p0435">Let <img alt="Image" height="9" src="images/B9780124159501000276/fx129.jpg" width="12"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx130.jpg" width="12"/> be two <img alt="Image" height="11" src="images/B9780124159501000276/fx131.jpg" width="52"/>nteger, Double&gt; objects. Using data-parallel streams, write a single-statement <img alt="Image" height="9" src="images/B9780124159501000276/fx132.jpg" width="52"/>() method that returns the sum of the absolute values of the differences between each key's bindings, for keys that appear in both maps. Your method should be equivalent to this:</p><div class="pageavoid"><figure class="fig" id="f0170"><img alt="Image" class="img" height="142" src="images/B9780124159501000276/fx133.jpg" width="403"/></figure></div><p class="textfl"/></div></div><p class="textfl"/><p class="text" id="p0440"/><div class="boxg1" id="enun0055"><p class="b1num">Exercise 17.9 </p><div><p class="b1textfl" id="p0445">Start with a list of strings, similar to this:</p><div class="pageavoid"><figure class="fig" id="f0175"><img alt="Image" class="img" height="27" src="images/B9780124159501000276/gr019.jpg" width="384"/></figure></div><p class="textfl"> Using stream operations,</p><div><ol><li class="b1numlist" id="o0025">1.  Print each string on a separate line.</li><li class="b1numlist" id="o0030">2.  Print each string on a separate line, followed by three exclamation points!!!</li><li class="b1numlist" id="o0035">3.  Discard each string of four characters or less, then discard the strings that do not contain the letter “l,” and print each remaining string on a separate line. <span aria-label="Page 428" epub:type="pagebreak" id="page_428" role="doc-pagebreak"/></li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0465"/><div class="boxg1" id="enun0060"><p class="b1num">Exercise 17.10 </p><div><p class="b1textfl" id="p0470">The following code fragment creates a small database mapping cities to their zip codes.</p><div class="pageavoid"><figure class="fig" id="f0180"><img alt="Image" class="img" height="77" src="images/B9780124159501000276/fx134.jpg" width="252"/></figure></div><p class="textfl"> Use a stream and stream operators to invert this map, constructing a new map that carries zip codes to cities.</p></div></div><p class="textfl"/><p class="text" id="p0475"/><div class="boxg1" id="enun0065"><p class="b1num">Exercise 17.11 </p><div><p class="b1textfl" id="p0480">Write a <img alt="Image" height="9" src="images/B9780124159501000276/fx135.jpg" width="59"/> class that provides a single <img alt="Image" height="11" src="images/B9780124159501000276/fx018.jpg" width="19"/>() method that returns an unbounded <img alt="Image" height="11" src="images/B9780124159501000276/fx103.jpg" width="79"/> of the Fibonacci numbers.</p></div></div><p class="textfl"/><p class="text" id="p0485"/><div class="boxg1" id="enun0070"><p class="b1num">Exercise 17.12 </p><div><p class="b1textfl" id="p0490">Suppose you are given a <img alt="Image" height="9" src="images/B9780124159501000276/fx136.jpg" width="86"/> containing a sequence of points of unknown, but nonzero size. Write a method</p><div class="pageavoid"><figure class="fig" id="f0185"><img alt="Image" class="img" height="11" src="images/B9780124159501000276/fx137.jpg" width="227"/></figure></div><p class="textfl"> that computes their barycenter.</p><p class="b1text" id="p0495">Hint: The <img alt="Image" height="12" src="images/B9780124159501000276/fx138.jpg" width="64"/> method that counts the number of stream elements is terminal, so you cannot continue to use the stream if you count its elements directly. Instead, you must find out how to use a single reduction to sum the points and count them simultaneously.</p></div></div><p class="textfl"/><p class="text" id="p0500"><span aria-label="Page 429" epub:type="pagebreak" id="page_429" role="doc-pagebreak"/></p><div class="boxg1" id="enun0075"><p class="b1num">Exercise 17.13 </p><div><p class="b1textfl" id="p0505"><a href="#f0190" id="cf0185">Fig. 17.19</a> shows the <img alt="Image" height="12" src="images/B9780124159501000276/fx024.jpg" width="38"/> method for a recursive spliterator of the <img alt="Image" height="9" src="images/B9780124159501000276/fx002.jpg" width="38"/> application. The <img alt="Image" height="9" src="images/B9780124159501000276/fx139.jpg" width="133"/> class is a recursive fork-join task that computes the clusters, and the <img alt="Image" height="9" src="images/B9780124159501000276/fx140.jpg" width="126"/> class is a recursive fork-join task that computes the centers from the clusters. Write the code for the <img alt="Image" height="9" src="images/B9780124159501000276/fx139.jpg" width="133"/> and <img alt="Image" height="9" src="images/B9780124159501000276/fx139.jpg" width="133"/> classes in the style of <a href="#f0130" id="cf0190">Fig. 17.15</a>.</p><div class="pageavoid"><figure class="fig" id="f0190"><img alt="Image" height="356" src="images/B9780124159501000276/gr020.jpg" width="489"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 17.19</span> Code for <a href="#enun0075" id="cf0025">Exercise 17.13</a>.</div></figcaption></figure></div></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0430"><h2 class="reftitle" id="st0075">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0170" role="doc-biblioentry">[34] Jeffrey Dean, Sanjay Ghemawat,  MapReduce: simplified data processing on large clusters,   <i>Proceedings of the 6th Conference on Symposium on Operating Systems Design &amp; Implementation - Volume 6</i>.  <i>OSDI'04</i>.  Berkeley, CA, USA: USENIX Association; 2004:10.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0600" role="doc-biblioentry">[120] Yandong Mao, Robert Morris, Frans Kaashoek,  <i>Optimizing MapReduce for multicore architectures</i>. [Technical Report MIT-CSAIL-TR-2010-020] MIT-CSAIL; 2010.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0660" role="doc-biblioentry">[132] James H. Morris,  <i>Real programming in functional languages</i>. [Technical Report 81-11] Xerox Palo Alto Research Center; 1981.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0805" role="doc-biblioentry">[161] Justin Talbot, Richard M. Yoo, Christos Kozyrakis,  Phoenix++: modular MapReduce for shared-memory systems,   <i>Proceedings of the Second International Workshop on MapReduce and Its Applications</i>.  <i>MapReduce '11</i>.  New York, NY, USA: ACM; 2011:9–16.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0035" role="doc-noteref">1 </a></sup> <a id="np0010"/>“Modern scholarship asks these questions of many documents, including the Federalist Papers (<a href="http://en.wikipedia.org/wiki/Federalist_papers">http://en.wikipedia.org/wiki/Federalist_papers</a>), the Nancy Drew Mystery fiction series (<a href="http://en.wikipedia.org/wiki/Nancy_Drew">http://en.wikipedia.org/wiki/Nancy_Drew</a>), and various sacred texts (readers are invited to provide their own examples).”</p><p class="ftnote1" epub:type="footnote" id="fn002" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0045" role="doc-noteref">2 </a></sup> <a id="np0015"/>“These streams should not be confused with the streams Java uses for I/O.”</p><p class="ftnote1" epub:type="footnote" id="fn003" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0085" role="doc-noteref">3 </a></sup> <a id="np0020"/>“These streams should not be confused with I/O streams, which are unrelated.”</p></div></section></footer></section></body></html>