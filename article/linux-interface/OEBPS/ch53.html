<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 53. POSIX Semaphores</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch52.html" title="Chapter 52. POSIX Message Queues"/><link rel="next" href="ch54.html" title="Chapter 54. POSIX Shared Memory"/></head><body><section class="chapter" title="Chapter 53. POSIX Semaphores" epub:type="chapter" id="posix_semaphores"><div class="titlepage"><div><div><h2 class="title">Chapter 53. POSIX Semaphores</h2></div></div></div><p>This chapter describes POSIX semaphores, which allow processes and threads to
            synchronize access to shared resources. In <a class="xref" href="ch47.html" title="Chapter 47. System V Semaphores">Chapter 47</a>, we
            described System V semaphores, and we’ll assume that the reader is familiar with the
            general semaphore concepts and rationale for using semaphores that were presented at the
            start of that chapter. During the course of this chapter, we’ll make comparisons between
            POSIX semaphores and System V semaphores to clarify the ways in which these two
            semaphore APIs are the same and the ways in which they differ.</p><div class="sect1" title="Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="overview-id16">Overview</h2></div></div></div><p>SUSv3 specifies two types of POSIX semaphores:<a id="IDX-CHP-53-7059" class="indexterm"/><a id="IDX-CHP-53-7060" class="indexterm"/><a id="IDX-CHP-53-7061" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Named semaphores</em></span>: This type of semaphore has a name.
                        By calling <span class="emphasis"><em>sem_open()</em></span> with the same name, unrelated
                        processes can access the same semaphore.</p></li><li class="listitem"><p><span class="emphasis"><em>Unnamed semaphores</em></span>: This type of semaphore doesn’t
                        have a name; instead, it resides at an agreed-upon location in memory.
                        Unnamed semaphores can be shared between processes or between a group of
                        threads. When shared between processes, the semaphore must reside in a
                        region of (System V, POSIX, or <span class="emphasis"><em>mmap()</em></span>) shared memory.
                        When shared between threads, the semaphore may reside in an area of memory
                        shared by the threads (e.g., on the heap or in a global variable).</p></li></ul></div><p>POSIX semaphores operate in a manner similar to System V semaphores; that is, a
                POSIX semaphore is an integer whose value is not permitted to fall below 0. If a
                process attempts to decrease the value of a semaphore below 0, then, depending on
                the function used, the call either blocks or fails with an error indicating that the
                operation was not currently possible.</p><p>Some systems don’t provide a full implementation of POSIX semaphores. A typical
                restriction is that only unnamed thread-shared semaphores are supported. That was
                the situation on Linux 2.4; with Linux 2.6 and a <span class="emphasis"><em>glibc</em></span> that
                provides NPTL, a full implementation of POSIX semaphores is available.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux 2.6 with NPTL, semaphore operations (increment and decrement) are
                    implemented using the <span class="emphasis"><em>futex(2)</em></span> system call.</p></div></div><div class="sect1" title="Named Semaphores"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="named_semaphores">Named Semaphores</h2></div></div></div><p>To work with a named semaphore, we employ the following functions:<a id="IDX-CHP-53-7062" class="indexterm"/><a id="IDX-CHP-53-7063" class="indexterm"/><a id="IDX-CHP-53-7064" class="indexterm"/><a id="IDX-CHP-53-7065" class="indexterm"/><a id="IDX-CHP-53-7066" class="indexterm"/><a id="IDX-CHP-53-7067" class="indexterm"/><a id="IDX-CHP-53-7068" class="indexterm"/><a id="IDX-CHP-53-7069" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>sem_open()</em></span> function opens or creates a semaphore,
                        initializes the semaphore if it is created by the call, and returns a handle
                        for use in later calls.<a id="IDX-CHP-53-7070" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>sem_post(sem)</em></span> and
                            <span class="emphasis"><em>sem_wait(sem)</em></span> functions respectively increment and
                        decrement a semaphore’s value.</p></li><li class="listitem"><p>The <span class="emphasis"><em>sem_getvalue()</em></span> function retrieves a semaphore’s
                        current value.</p></li><li class="listitem"><p>The <span class="emphasis"><em>sem_close()</em></span> function removes the calling
                        process’s association with a semaphore that it previously opened.</p></li><li class="listitem"><p>The <span class="emphasis"><em>sem_unlink()</em></span> function removes a semaphore name
                        and marks the semaphore for deletion when all processes have closed
                        it.</p></li></ul></div><p>SUSv3 doesn’t specify how named semaphores are to be implemented. Some UNIX
                implementations create them as files in a special location in the standard file
                system. On Linux, they are created as small POSIX shared memory objects with names
                of the form <code class="literal">sem.</code><span class="emphasis"><em>name</em></span>, in a
                dedicated <span class="emphasis"><em>tmpfs</em></span> file system (<a class="xref" href="ch14.html#a_virtual_memory_file_system_colon_tmpfs" title="A Virtual Memory File System: tmpfs">A Virtual Memory File System: <span class="emphasis"><em>tmpfs</em></span></a>) mounted under the
                directory <code class="literal">/dev/shm</code>. This file system has kernel
                persistence--the semaphore objects that it contains will persist, even if no process
                currently has them open, but they will be lost if the system is shut down.<a id="IDX-CHP-53-7071" class="indexterm"/></p><p>Named semaphores are supported on Linux since kernel 2.6.</p><div class="sect2" title="Opening a Named Semaphore"><div class="titlepage"><div><div><h3 class="title" id="opening_a_named_semaphore">Opening a Named Semaphore</h3></div></div></div><p>The <span class="emphasis"><em>sem_open()</em></span> function creates and opens a new named
                    semaphore or opens an existing semaphore.</p><a id="I_programlisting53_d1e139017"/><pre class="programlisting">#include &lt;fcntl.h&gt;            /* Defines O_* constants */
#include &lt;sys/stat.h&gt;         /* Defines mode constants */
#include &lt;semaphore.h&gt;

sem_t *<strong class="userinput"><code>sem_open</code></strong>(const char *<span class="emphasis"><em>name</em></span>, int <span class="emphasis"><em>oflag</em></span>, ...
                /* mode_t <span class="emphasis"><em>mode</em></span>, unsigned int <span class="emphasis"><em>value</em></span> */ );</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to semaphore on success, or <code class="literal">SEM_FAILED</code> on error</p></div><p>The <span class="emphasis"><em>name</em></span> argument identifies the semaphore. It is
                    specified according to the rules given in Section 51.1.</p><p>The <span class="emphasis"><em>oflag</em></span> argument is a bit mask that determines whether
                    we are opening an existing semaphore or creating and opening a new semaphore. If
                        <span class="emphasis"><em>oflag</em></span> is 0, we are accessing an existing semaphore. If
                        <code class="literal">O_CREAT</code> is specified in
                        <span class="emphasis"><em>oflag</em></span>, then a new semaphore is created if one with the
                    given <span class="emphasis"><em>name</em></span> doesn’t already exist. If
                        <span class="emphasis"><em>oflag</em></span> specifies both <code class="literal">O_CREAT</code> and <code class="literal">O_EXCL</code>, and a
                    semaphore with the given <span class="emphasis"><em>name</em></span> already exists, then
                        <span class="emphasis"><em>sem_open()</em></span> fails.</p><p>If <span class="emphasis"><em>sem_open()</em></span> is being used to open an existing
                    semaphore, the call requires only two arguments. However, if <code class="literal">O_CREAT</code> is specified in
                    <span class="emphasis"><em>flags</em></span>, then two further arguments are required:
                        <span class="emphasis"><em>mode</em></span> and <span class="emphasis"><em>value</em></span>. (If the semaphore
                    specified by <span class="emphasis"><em>name</em></span> already exists, then these two arguments
                    are ignored.) These arguments are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>mode</em></span> argument is a bit mask that specifies
                            the permissions to be placed on the new semaphore. The bit values are
                            the same as for files (<a class="xref" href="ch15.html#constants_for_file_permission_bits" title="Table 15-4. Constants for file permission bits">Table 15-4</a>, in <a class="xref" href="ch15.html#permissions_on_regular_files" title="Permissions on Regular Files">Permissions on Regular Files</a>), and, as with
                                <span class="emphasis"><em>open()</em></span>, the value in <span class="emphasis"><em>mode</em></span>
                            is masked against the process umask (<a class="xref" href="ch15.html#the_process_file_mode_creation_mask_colo" title="The Process File Mode Creation Mask: umask()">The Process File Mode Creation Mask: <span class="emphasis"><em>umask()</em></span></a>). SUSv3 doesn’t
                            specify any access mode flags (<code class="literal">O_RDONLY</code>, <code class="literal">O_WRONLY</code>,
                            and <code class="literal">O_RDWR</code>) for
                                <span class="emphasis"><em>oflag</em></span>. Many implementations, including Linux,
                            assume an access mode of <code class="literal">O_RDWR</code> when
                            opening a semaphore, since most applications using semaphores must
                            employ both <span class="emphasis"><em>sem_post()</em></span> and
                                <span class="emphasis"><em>sem_wait()</em></span>, which involve reading and modifying
                            a semaphore’s value. This means that we should ensure that both read and
                            write permissions are granted to each category of user—owner, group, and
                            other—that needs to access the semaphore.<a id="IDX-CHP-53-7072" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>value</em></span> argument is an unsigned integer that
                            specifies the initial value to be assigned to the new semaphore. The
                            creation and initialization of the semaphore are performed atomically.
                            This avoids the complexities required for the initialization of System V
                            semaphores (<a class="xref" href="ch47.html#semaphore_initialization" title="Semaphore Initialization">Semaphore Initialization</a>).</p></li></ul></div><p>Regardless of whether we are creating a new semaphore or opening an existing
                    semaphore, <span class="emphasis"><em>sem_open()</em></span> returns a pointer to a
                        <span class="emphasis"><em>sem_t</em></span> value, and we employ this pointer in subsequent
                    calls to functions that operate on the semaphore. On error,
                        <span class="emphasis"><em>sem_open()</em></span> returns the value <code class="literal">SEM_FAILED</code>. (On most implementations, <code class="literal">SEM_FAILED</code> is defined as either <span class="emphasis"><em>((sem_t *)
                        0)</em></span> or <span class="emphasis"><em>((sem_t *) -1)</em></span>; Linux defines it as
                    the former.)</p><p>SUSv3 states that the results are undefined if we attempt to perform
                    operations (<span class="emphasis"><em>sem_post()</em></span>, <span class="emphasis"><em>sem_wait()</em></span>,
                    and so on) on a <span class="emphasis"><em>copy</em></span> of the <span class="emphasis"><em>sem_t</em></span>
                    variable pointed to by the return value of <span class="emphasis"><em>sem_open()</em></span>. In
                    other words, the following use of <span class="emphasis"><em>sem2</em></span> is not
                    permissible:</p><a id="I_programlisting53_d1e139199"/><pre class="programlisting">sem_t *sp, sem2
sp = sem_open(...);
sem2 = *sp;
sem_wait(&amp;sem2);</pre><p>When a child is created via <span class="emphasis"><em>fork()</em></span>, it inherits
                    references to all of the named semaphores that are open in its parent. After the
                        <span class="emphasis"><em>fork()</em></span>, the parent and child can use these semaphores
                    to synchronize their actions.</p><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id68">Example program</h4></div></div></div><p>The program in <a class="xref" href="ch53.html#using_sem_underscore_open_open_parenthes" title="Example 53-1. Using sem_open() to open or create a POSIX named semaphore">Example 53-1</a>
                        provides a simple command-line interface to the
                            <span class="emphasis"><em>sem_open()</em></span> function. The command format for this
                        program is shown in the <span class="emphasis"><em>usageError()</em></span>
                            function.<a id="IDX-CHP-53-7073" class="indexterm"/><a id="IDX-CHP-53-7074" class="indexterm"/><a id="IDX-CHP-53-7075" class="indexterm"/><a id="IDX-CHP-53-7076" class="indexterm"/><a id="IDX-CHP-53-7077" class="indexterm"/></p><p>The following shell session log demonstrates the use of this program. We
                        first use the <span class="emphasis"><em>umask</em></span> command to deny all permissions to
                        users in the class other. We then exclusively create a semaphore and examine
                        the contents of the Linux-specific virtual directory that contains named
                        semaphores.</p><a id="I_programlisting53_d1e139253"/><pre class="programlisting">$ <strong class="userinput"><code>umask 007</code></strong>
$ <strong class="userinput"><code>./psem_create -cx /demo 666</code></strong>             <em class="lineannotation"><span class="lineannotation">666 means read+write for all users</span></em>
$ <strong class="userinput"><code>ls -l /dev/shm/sem.*</code></strong>
-rw-rw----  1 mtk users 16 Jul  6 12:09 /dev/shm/sem.demo</pre><p>The output of the <span class="emphasis"><em>ls</em></span> command shows that the process
                        umask overrode the specified permissions of read plus write for the user
                        class other.</p><p>If we try once more to exclusively create a semaphore with the same name,
                        the operation fails, because the name already exists.</p><a id="I_programlisting53_d1e139274"/><pre class="programlisting">$ <strong class="userinput"><code>./psem_create -cx /demo 666</code></strong>
ERROR [EEXIST File exists] sem_open       <em class="lineannotation"><span class="lineannotation">Failed because of</span></em> O_EXCL</pre><div class="example"><a id="using_sem_underscore_open_open_parenthes"/><div class="example-title">Example 53-1. Using <span class="emphasis"><em>sem_open()</em></span> to open or create a POSIX named
                            semaphore</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>psem/psem_create.c</code></strong>
#include &lt;semaphore.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include "tlpi_hdr.h"

static void
usageError(const char *progName)
{
    fprintf(stderr, "Usage: %s [-cx] name [octal-perms [value]]\n", progName);
    fprintf(stderr, "    -c   Create semaphore (O_CREAT)\n");
    fprintf(stderr, "    -x   Create exclusively (O_EXCL)\n");
    exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
    int flags, opt;
    mode_t perms;
    unsigned int value;
    sem_t *sem;

    flags = 0;
    while ((opt = getopt(argc, argv, "cx")) != -1) {
        switch (opt) {
        case 'c':   flags |= O_CREAT;           break;
        case 'x':   flags |= O_EXCL;            break;
        default:    usageError(argv[0]);
        }
    }

    if (optind &gt;= argc)
        usageError(argv[0]);

    /* Default permissions are rw-------; default semaphore initialization
       value is 0 */

    perms = (argc &lt;= optind + 1) ? (S_IRUSR | S_IWUSR) :
                getInt(argv[optind + 1], GN_BASE_8, "octal-perms");
    value = (argc &lt;= optind + 2) ? 0 : getInt(argv[optind + 2], 0, "value");

    sem = sem_open(argv[optind], flags, perms, value);
    if (sem == SEM_FAILED)
        errExit("sem_open");

    exit(EXIT_SUCCESS);
}
    <strong class="userinput"><code>psem/psem_create.c</code></strong></pre></div></div></div></div><div class="sect2" title="Closing a Semaphore"><div class="titlepage"><div><div><h3 class="title" id="closing_a_semaphore">Closing a Semaphore</h3></div></div></div><p>When a process opens a named semaphore, the system records the association
                    between the process and the semaphore. The <span class="emphasis"><em>sem_close()</em></span>
                    function terminates this association (i.e., closes the semaphore), releases any
                    resources that the system has associated with the semaphore for this process,
                    and decreases the count of processes referencing the semaphore.<a id="IDX-CHP-53-7078" class="indexterm"/><a id="IDX-CHP-53-7079" class="indexterm"/><a id="IDX-CHP-53-7080" class="indexterm"/><a id="IDX-CHP-53-7081" class="indexterm"/><a id="IDX-CHP-53-7082" class="indexterm"/><a id="IDX-CHP-53-7083" class="indexterm"/><a id="IDX-CHP-53-7084" class="indexterm"/></p><a id="I_programlisting53_d1e139346"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_close</code></strong>(sem_t *<span class="emphasis"><em>sem</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>Open named semaphores are also automatically closed on process termination or
                    if the process performs an <span class="emphasis"><em>exec()</em></span>.</p><p>Closing a semaphore does not delete it. For that purpose, we need to use
                        <span class="emphasis"><em>sem_unlink()</em></span>.<a id="IDX-CHP-53-7085" class="indexterm"/></p></div><div class="sect2" title="Removing a Named Semaphore"><div class="titlepage"><div><div><h3 class="title" id="removing_a_named_semaphore">Removing a Named Semaphore</h3></div></div></div><p>The <span class="emphasis"><em>sem_unlink()</em></span> function removes the semaphore
                    identified by <span class="emphasis"><em>name</em></span> and marks the semaphore to be destroyed
                    once all processes cease using it (this may mean immediately, if all processes
                    that had the semaphore open have already closed it).</p><a id="I_programlisting53_d1e139382"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_unlink</code></strong>(const char *<span class="emphasis"><em>name</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p><a class="xref" href="ch53.html#using_sem_underscore_unlink_open_parenth" title="Example 53-2. Using sem_unlink() to unlink a POSIX named semaphore">Example 53-2</a> demonstrates the
                    use of <span class="emphasis"><em>sem_unlink()</em></span>.</p><div class="example"><a id="using_sem_underscore_unlink_open_parenth"/><div class="example-title">Example 53-2. Using <span class="emphasis"><em>sem_unlink()</em></span> to unlink a POSIX named
                        semaphore</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>psem/psem_unlink.c</code></strong>
#include &lt;semaphore.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    if (argc != 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s sem-name\n", argv[0]);

    if (sem_unlink(argv[1]) == -1)
        errExit("sem_unlink");
    exit(EXIT_SUCCESS);
}
    <strong class="userinput"><code>psem/psem_unlink.c</code></strong></pre></div></div></div></div><div class="sect1" title="Semaphore Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="semaphore_operations-id1">Semaphore Operations</h2></div></div></div><p>As with a System V semaphore, a POSIX semaphore is an integer that the system
                never allows to go below 0. However, POSIX semaphore operations differ from their
                System V counterparts in the following respects:<a id="IDX-CHP-53-7086" class="indexterm"/><a id="IDX-CHP-53-7087" class="indexterm"/><a id="IDX-CHP-53-7088" class="indexterm"/><a id="IDX-CHP-53-7089" class="indexterm"/><a id="IDX-CHP-53-7090" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The functions for changing a semaphore’s
                            value—<span class="emphasis"><em>sem_post()</em></span> and
                            <span class="emphasis"><em>sem_wait()</em></span>—operate on just one semaphore at a time.
                        By contrast, the System V <span class="emphasis"><em>semop()</em></span> system call can
                        operate on multiple semaphores in a set.<a id="IDX-CHP-53-7091" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>sem_post()</em></span> and <span class="emphasis"><em>sem_wait()</em></span>
                        functions increment and decrement a semaphore’s value by exactly one. By
                        contrast, <span class="emphasis"><em>semop()</em></span> can add and subtract arbitrary
                        values.</p></li><li class="listitem"><p>There is no equivalent of the wait-for-zero operation provided by System V
                        semaphores (a <span class="emphasis"><em>semop()</em></span> call where the
                            <span class="emphasis"><em>sops.sem_op</em></span> field is specified as 0).</p></li></ul></div><p>From this list, it may seem that POSIX semaphores are less powerful than System V
                semaphores. However, this is not the case--anything that we can do with System V
                semaphores can also be done with POSIX semaphores. In a few cases, a bit more
                programming effort may be required, but, for typical scenarios, using POSIX
                semaphores actually requires less programming effort. (The System V semaphore API is
                rather more complicated than is required for most applications.)</p><div class="sect2" title="Waiting on a Semaphore"><div class="titlepage"><div><div><h3 class="title" id="waiting_on_a_semaphore">Waiting on a Semaphore</h3></div></div></div><p>The <span class="emphasis"><em>sem_wait()</em></span> function decrements (decreases by 1) the
                    value of the semaphore referred to by <span class="emphasis"><em>sem</em></span>.<a id="IDX-CHP-53-7092" class="indexterm"/><a id="IDX-CHP-53-7093" class="indexterm"/><a id="IDX-CHP-53-7094" class="indexterm"/><a id="IDX-CHP-53-7095" class="indexterm"/><a id="IDX-CHP-53-7096" class="indexterm"/><a id="IDX-CHP-53-7097" class="indexterm"/></p><a id="I_programlisting53_d1e139528"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_wait</code></strong>(sem_t *<em class="lineannotation"><span class="lineannotation">sem</span></em>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>If the semaphore currently has a value greater than 0,
                        <span class="emphasis"><em>sem_wait()</em></span> returns immediately. If the value of the
                    semaphore is currently 0, <span class="emphasis"><em>sem_wait()</em></span> blocks until the
                    semaphore value rises above 0; at that time, the semaphore is then decremented
                    and <span class="emphasis"><em>sem_wait()</em></span> returns.</p><p>If a blocked <span class="emphasis"><em>sem_wait()</em></span> call is interrupted by a signal
                    handler, then it fails with the error <code class="literal">EINTR</code>,
                    regardless of whether the <code class="literal">SA_RESTART</code> flag was
                    used when establishing the signal handler with <span class="emphasis"><em>sigaction()</em></span>.
                    (On some other UNIX implementations, <code class="literal">SA_RESTART</code> does cause <span class="emphasis"><em>sem_wait()</em></span> to
                    automatically restart.)</p><p>The program in <a class="xref" href="ch53.html#using_sem_underscore_wait_open_parenthes" title="Example 53-3. Using sem_wait() to decrement a POSIX semaphore">Example 53-3</a>
                    provides a command-line interface to the <span class="emphasis"><em>sem_wait()</em></span>
                    function. We demonstrate the use of this program shortly.</p><div class="example"><a id="using_sem_underscore_wait_open_parenthes"/><div class="example-title">Example 53-3. Using <span class="emphasis"><em>sem_wait()</em></span> to decrement a POSIX
                        semaphore</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>psem/psem_wait.c</code></strong>
#include &lt;semaphore.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    sem_t *sem;

    if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s sem-name\n", argv[0]);

    sem = sem_open(argv[1], 0);
    if (sem == SEM_FAILED)
        errExit("sem_open");

    if (sem_wait(sem) == -1)
        errExit("sem_wait");

    printf("%ld sem_wait() succeeded\n", (long) getpid());
    exit(EXIT_SUCCESS);
}
    <strong class="userinput"><code>psem/psem_wait.c</code></strong></pre></div></div><p>The <span class="emphasis"><em>sem_trywait()</em></span> function is a nonblocking version of
                        <span class="emphasis"><em>sem_wait()</em></span>.<a id="IDX-CHP-53-7098" class="indexterm"/></p><a id="I_programlisting53_d1e139602"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_trywait</code></strong>(sem_t *<span class="emphasis"><em>sem</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>If the decrement operation can’t be performed immediately,
                        <span class="emphasis"><em>sem_trywait()</em></span> fails with the error <code class="literal">EAGAIN</code>.</p><p>The <span class="emphasis"><em>sem_timedwait()</em></span> function is another variation on
                        <span class="emphasis"><em>sem_wait()</em></span>. It allows the caller to specify a limit on
                    the time for which the call will block.<a id="IDX-CHP-53-7099" class="indexterm"/></p><a id="I_programlisting53_d1e139634"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_timedwait</code></strong>(sem_t *<span class="emphasis"><em>sem</em></span>, const struct timespec *<span class="emphasis"><em>abs_timeout</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>If a <span class="emphasis"><em>sem_timedwait()</em></span> call times out without being able to
                    decrement the semaphore, then the call fails with the error <code class="literal">ETIMEDOUT</code>.</p><p>The <span class="emphasis"><em>abs_timeout</em></span> argument is a
                        <span class="emphasis"><em>timespec</em></span> structure (<a class="xref" href="ch23.html#high-resolution_sleeping_colon_nanosleep" title="High-Resolution Sleeping: nanosleep()">High-Resolution Sleeping: <span class="emphasis"><em>nanosleep()</em></span></a>) that specifies the
                    timeout as an absolute value in seconds and nanoseconds since the Epoch. If we
                    want to perform a relative timeout, then we must fetch the current value of the
                        <code class="literal">CLOCK_REALTIME</code> clock using
                        <span class="emphasis"><em>clock_gettime()</em></span> and add the required amount to that
                    value to produce a <span class="emphasis"><em>timespec</em></span> structure suitable for use with
                        <span class="emphasis"><em>sem_timedwait()</em></span>.<a id="IDX-CHP-53-7100" class="indexterm"/></p><p>The <span class="emphasis"><em>sem_timedwait()</em></span> function was originally specified in
                    POSIX.1d (1999) and is not available on all UNIX implementations.<a id="IDX-CHP-53-7101" class="indexterm"/></p></div><div class="sect2" title="Posting a Semaphore"><div class="titlepage"><div><div><h3 class="title" id="posting_a_semaphore">Posting a Semaphore</h3></div></div></div><p>The <span class="emphasis"><em>sem_post()</em></span> function increments (increases by 1) the
                    value of the semaphore referred to by <span class="emphasis"><em>sem</em></span>.<a id="IDX-CHP-53-7102" class="indexterm"/><a id="IDX-CHP-53-7103" class="indexterm"/><a id="IDX-CHP-53-7104" class="indexterm"/><a id="IDX-CHP-53-7105" class="indexterm"/><a id="IDX-CHP-53-7106" class="indexterm"/><a id="IDX-CHP-53-7107" class="indexterm"/></p><a id="I_programlisting53_d1e139736"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_post</code></strong>(sem_t *<span class="emphasis"><em>sem</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>If the value of the semaphore was 0 before the <span class="emphasis"><em>sem_post()</em></span>
                    call, and some other process (or thread) is blocked waiting to decrement the
                    semaphore, then that process is awoken, and its <span class="emphasis"><em>sem_wait()</em></span>
                    call proceeds to decrement the semaphore. If multiple processes (or threads) are
                    blocked in <span class="emphasis"><em>sem_wait()</em></span>, then, if the processes are being
                    scheduled under the default round-robin time-sharing policy, it is indeterminate
                    which one will be awoken and allowed to decrement the semaphore. (Like their
                    System V counterparts, POSIX semaphores are only a synchronization mechanism,
                    not a queuing mechanism.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 specifies that if processes or threads are being executed under a
                        realtime scheduling policy, then the process or thread that will be awoken
                        is the one with the highest priority that has been waiting the
                        longest.</p></div><p>As with System V semaphores, incrementing a POSIX semaphore corresponds to
                    releasing some shared resource for use by another process or thread.</p><p>The program in <a class="xref" href="ch53.html#using_sem_underscore_post_open_parenthes" title="Example 53-4. Using sem_post() to increment a POSIX semaphore">Example 53-4</a>
                    provides a command-line interface to the <span class="emphasis"><em>sem_post()</em></span>
                    function. We demonstrate the use of this program shortly.</p><div class="example"><a id="using_sem_underscore_post_open_parenthes"/><div class="example-title">Example 53-4. Using <span class="emphasis"><em>sem_post()</em></span> to increment a POSIX
                        semaphore</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>psem/psem_post.c</code></strong>
#include &lt;semaphore.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    sem_t *sem;

    if (argc != 2)
        usageErr("%s sem-name\n", argv[0]);

    sem = sem_open(argv[1], 0);
    if (sem == SEM_FAILED)
        errExit("sem_open");

    if (sem_post(sem) == -1)
        errExit("sem_post");
    exit(EXIT_SUCCESS);
}
    <strong class="userinput"><code>psem/psem_post.c</code></strong></pre></div></div></div><div class="sect2" title="Retrieving the Current Value of a Semaphore"><div class="titlepage"><div><div><h3 class="title" id="retrieving_the_current_value_of_a_semaph">Retrieving the Current Value of a Semaphore</h3></div></div></div><p>The <span class="emphasis"><em>sem_getvalue()</em></span> function returns the current value of
                    the semaphore referred to by <span class="emphasis"><em>sem</em></span> in the
                        <span class="emphasis"><em>int</em></span> pointed to by <span class="emphasis"><em>sval</em></span>.<a id="IDX-CHP-53-7108" class="indexterm"/><a id="IDX-CHP-53-7109" class="indexterm"/><a id="IDX-CHP-53-7110" class="indexterm"/><a id="IDX-CHP-53-7111" class="indexterm"/><a id="IDX-CHP-53-7112" class="indexterm"/><a id="IDX-CHP-53-7113" class="indexterm"/></p><a id="I_programlisting53_d1e139832"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_getvalue</code></strong>(sem_t *<span class="emphasis"><em>sem</em></span>, int *<span class="emphasis"><em>sval</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>If one or more processes (or threads) are currently blocked waiting to
                    decrement the semaphore’s value, then the value returned in
                        <span class="emphasis"><em>sval</em></span> depends on the implementation. SUSv3 permits two
                    possibilities: 0 or a negative number whose absolute value is the number of
                    waiters blocked in <span class="emphasis"><em>sem_wait()</em></span>. Linux and several other
                    implementations adopt the former behavior; a few other implementations adopt the
                    latter behavior.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although returning a negative <span class="emphasis"><em>sval</em></span> if there are
                        blocked waiters can be useful, especially for debugging purposes, SUSv3
                        doesn’t require this behavior because the techniques that some systems use
                        to efficiently implement POSIX semaphores don’t (in fact, can’t) record
                        counts of blocked waiters.</p></div><p>Note that by the time <span class="emphasis"><em>sem_getvalue()</em></span> returns, the value
                    returned in <span class="emphasis"><em>sval</em></span> may already be out of date. A program that
                    depends on the information returned by <span class="emphasis"><em>sem_getvalue()</em></span> being
                    unchanged by the time of a subsequent operation will be subject to
                    time-of-check, time-of-use race conditions (<a class="xref" href="ch38.html#beware_of_signals_and_race_conditions" title="Beware of Signals and Race Conditions">Beware of Signals and Race Conditions</a>).</p><p>The program in <a class="xref" href="ch53.html#using_sem_underscore_getvalue_open_paren" title="Example 53-5. Using sem_getvalue() to retrieve the value of a POSIX semaphore">Example 53-5</a> uses
                        <span class="emphasis"><em>sem_getvalue()</em></span> to retrieve the value of the semaphore
                    named in its command-line argument, and then displays that value on standard
                    output.</p><div class="example"><a id="using_sem_underscore_getvalue_open_paren"/><div class="example-title">Example 53-5. Using <span class="emphasis"><em>sem_getvalue()</em></span> to retrieve the value of a
                        POSIX semaphore</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>psem/psem_getvalue.c</code></strong>
#include &lt;semaphore.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int value;
    sem_t *sem;

    if (argc != 2)
        usageErr("%s sem-name\n", argv[0]);

    sem = sem_open(argv[1], 0);
    if (sem == SEM_FAILED)
        errExit("sem_open");

    if (sem_getvalue(sem, &amp;value) == -1)
        errExit("sem_getvalue");

    printf("%d\n", value);
    exit(EXIT_SUCCESS);
}
    <strong class="userinput"><code>psem/psem_getvalue.c</code></strong></pre></div></div><div class="sect3" title="Example"><div class="titlepage"><div><div><h4 class="title" id="example">Example</h4></div></div></div><p>The following shell session log demonstrates the use of the programs we
                        have shown so far in this chapter. We begin by creating a semaphore whose
                        initial value is zero, and then start a program in the background that
                        attempts to decrement the semaphore:<a id="IDX-CHP-53-7114" class="indexterm"/><a id="IDX-CHP-53-7115" class="indexterm"/></p><a id="I_programlisting53_d1e139908"/><pre class="programlisting">$ <strong class="userinput"><code>./psem_create -c /demo 600 0</code></strong>
$ <strong class="userinput"><code>./psem_wait /demo &amp;</code></strong>
[1] 31208</pre><p>The background command blocks, because the semaphore value is currently 0
                        and therefore can’t be decreased.</p><p>We then retrieve the semaphore value:</p><a id="I_programlisting53_d1e139920"/><pre class="programlisting">$ <strong class="userinput"><code>./psem_getvalue /demo</code></strong>
0</pre><p>We see the value 0 above. On some other implementations, we might see the
                        value -1, indicating that one process is waiting on the semaphore.</p><p>We then execute a command that increments the semaphore. This causes the
                        blocked <span class="emphasis"><em>sem_wait()</em></span> in the background program to
                        complete:</p><a id="I_programlisting53_d1e139932"/><pre class="programlisting">$ <strong class="userinput"><code>./psem_post /demo</code></strong>
$ 31208 sem_wait() succeeded</pre><p>(The last line of output above shows the shell prompt mixed with the
                        output of the background job.)</p><p>We press <span class="emphasis"><em>Enter</em></span> to see the next shell prompt, which
                        also causes the shell to report on the terminated background job, and then
                        perform further operations on the semaphore:</p><a id="I_programlisting53_d1e139945"/><pre class="programlisting"><em class="lineannotation"><span class="lineannotation">Press Enter</span></em>
[1]-  Done          ./psem_wait /demo
$ <strong class="userinput"><code>./psem_post /demo</code></strong> <em class="lineannotation"><span class="lineannotation">Increment semaphore</span></em>
$ <strong class="userinput"><code>./psem_getvalue /demo</code></strong> <em class="lineannotation"><span class="lineannotation">Retrieve semaphore value</span></em>
1
$ <strong class="userinput"><code>./psem_unlink /demo</code></strong> <em class="lineannotation"><span class="lineannotation">We’re done with this semaphore</span></em></pre></div></div></div><div class="sect1" title="Unnamed Semaphores"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="unnamed_semaphores">Unnamed Semaphores</h2></div></div></div><p>Unnamed semaphores (also known as <span class="emphasis"><em>memory-based semaphores</em></span>)
                are variables of type <span class="emphasis"><em>sem_t</em></span> that are stored in memory allocated
                by the application. The semaphore is made available to the processes or threads that
                use it by placing it in an area of memory that they share.<a id="IDX-CHP-53-7116" class="indexterm"/></p><p>Operations on unnamed semaphores use the same functions
                    (<span class="emphasis"><em>sem_wait()</em></span>, <span class="emphasis"><em>sem_post()</em></span>,
                    <span class="emphasis"><em>sem_getvalue()</em></span>, and so on) that are used to operate on
                named semaphores. In addition, two further functions are required:<a id="IDX-CHP-53-7117" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>sem_init()</em></span> function initializes a semaphore and
                        informs the system of whether the semaphore will be shared between processes
                        or between the threads of a single process.</p></li><li class="listitem"><p>The <span class="emphasis"><em>sem_destroy(sem)</em></span> function destroys a
                        semaphore.</p></li></ul></div><p>These functions should not be used with named semaphores.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="unnamed_versus_named_semaphores"/></div></div></div><div class="sect3" title="Unnamed versus named semaphores"><div class="titlepage"><div><div><h4 class="title" id="unnamed_versus_named_semaphores-id1">Unnamed versus named semaphores</h4></div></div></div><p>Using an unnamed semaphore allows us to avoid the work of creating a name
                        for a semaphore. This can be useful in the following cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A semaphore that is shared between threads doesn’t need a name.
                                Making an unnamed semaphore a shared (global or heap) variable
                                automatically makes it accessible to all threads.</p></li><li class="listitem"><p>A semaphore that is being shared between related processes doesn’t
                                need a name. If a parent process allocates an unnamed semaphore in a
                                region of shared memory (e.g., a shared anonymous mapping), then a
                                child automatically inherits the mapping and thus the semaphore as
                                part of the operation of <span class="emphasis"><em>fork()</em></span>.</p></li><li class="listitem"><p>If we are building a dynamic data structure (e.g., a binary tree),
                                each of whose items requires an associated semaphore, then the
                                simplest approach is to allocate an unnamed semaphore within each
                                item. Opening a named semaphore for each item would require us to
                                design a convention for generating a (unique) semaphore name for
                                each item and to manage those names (e.g., unlinking them when they
                                are no longer required).</p></li></ul></div></div></div><div class="sect2" title="Initializing an Unnamed Semaphore"><div class="titlepage"><div><div><h3 class="title" id="initializing_an_unnamed_semaphore">Initializing an Unnamed Semaphore</h3></div></div></div><p>The <span class="emphasis"><em>sem_init()</em></span> function initializes the unnamed semaphore
                    pointed to by <span class="emphasis"><em>sem</em></span> to the value specified by
                        <span class="emphasis"><em>value</em></span>.<a id="IDX-CHP-53-7118" class="indexterm"/><a id="IDX-CHP-53-7119" class="indexterm"/><a id="IDX-CHP-53-7120" class="indexterm"/><a id="IDX-CHP-53-7121" class="indexterm"/></p><a id="I_programlisting53_d1e140071"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_init</code></strong>(sem_t *<span class="emphasis"><em>sem</em></span>, int <span class="emphasis"><em>pshared</em></span>, unsigned int <span class="emphasis"><em>value</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>pshared</em></span> argument indicates whether the semaphore is
                    to be shared between threads or between processes.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>pshared</em></span> is 0, then the semaphore is to be
                            shared between the threads of the calling process. In this case,
                                <span class="emphasis"><em>sem</em></span> is typically specified as the address of
                            either a global variable or a variable allocated on the heap. A
                            thread-shared semaphore has process persistence; it is destroyed when
                            the process terminates.<a id="IDX-CHP-53-7122" class="indexterm"/></p></li><li class="listitem"><p>If <span class="emphasis"><em>pshared</em></span> is nonzero, then the semaphore is to
                            be shared between processes. In this case, <span class="emphasis"><em>sem</em></span> must
                            be the address of a location in a region of shared memory (a POSIX
                            shared memory object, a shared mapping created using
                                <span class="emphasis"><em>mmap()</em></span>, or a System V shared memory segment).
                            The semaphore persists as long as the shared memory in which it resides.
                            (The shared memory regions created by most of these techniques have
                            kernel persistence. The exception is shared anonymous mappings, which
                            persist only as long as at least one process maintains the mapping.)
                            Since a child produced via <span class="emphasis"><em>fork()</em></span> inherits its
                            parent’s memory mappings, process-shared semaphores are inherited by the
                            child of a <span class="emphasis"><em>fork()</em></span>, and the parent and child can use
                            these semaphores to synchronize their actions.<a id="IDX-CHP-53-7123" class="indexterm"/></p></li></ul></div><p>The <span class="emphasis"><em>pshared</em></span> argument is necessary for the following
                    reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Some implementations don’t support process-shared semaphores. On these
                            systems, specifying a nonzero value for <span class="emphasis"><em>pshared</em></span>
                            causes <span class="emphasis"><em>sem_init()</em></span> to return an error. Linux did not
                            support unnamed process-shared semaphores until kernel 2.6 and the
                            advent of the NPTL threading implementation. (The older LinuxThreads
                            implementation of <span class="emphasis"><em>sem_init()</em></span> fails with the error
                                <code class="literal">ENOSYS</code> if a nonzero value is
                            specified for <span class="emphasis"><em>pshared</em></span>.)</p></li><li class="listitem"><p>On implementations that support both process-shared and thread-shared
                            semaphores, specifying which kind of sharing is required may be
                            necessary because the system must take special actions to support the
                            requested sharing. Providing this information may also permit the system
                            to perform optimizations depending on the type of sharing.</p></li></ul></div><p>The NPTL <span class="emphasis"><em>sem_init()</em></span> implementation ignores
                        <span class="emphasis"><em>pshared</em></span>, since no special action is required for either
                    type of sharing. Nevertheless, portable and future-proof applications should
                    specify an appropriate value for <span class="emphasis"><em>pshared</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The SUSv3 specification for <span class="emphasis"><em>sem_init()</em></span> defines a
                        failure return of -1, but makes no statement about the return value on
                        success. Nevertheless, the manual pages on most modern UNIX implementations
                        document a 0 return on success. (One notable exception is Solaris, where the
                        description of the return value is similar to the SUSv3 specification.
                        However, inspecting the OpenSolaris source code shows that, on that
                        implementation, <span class="emphasis"><em>sem_init()</em></span> does return 0 on success.)
                        SUSv4 rectifies the situation, specifying that
                            <span class="emphasis"><em>sem_init()</em></span> shall return 0 on success.</p></div><p>There are no permission settings associated with an unnamed semaphore (i.e.,
                        <span class="emphasis"><em>sem_init()</em></span> has no analog of the
                        <span class="emphasis"><em>mode</em></span> argument of <span class="emphasis"><em>sem_open()</em></span>).
                    Access to an unnamed semaphore is governed by the permissions that are granted
                    to the process for the underlying shared memory region.</p><p>SUSv3 specifies that initializing an already initialized unnamed semaphore
                    results in undefined behavior. In other words, we must design our applications
                    so that just one process or thread calls <span class="emphasis"><em>sem_init()</em></span> to
                    initialize a semaphore.</p><p>As with named semaphores, SUSv3 says that the results are undefined if we
                    attempt to perform operations on a <span class="emphasis"><em>copy</em></span> of the
                        <span class="emphasis"><em>sem_t</em></span> variable whose address is passed as the
                        <span class="emphasis"><em>sem</em></span> argument of <span class="emphasis"><em>sem_init()</em></span>.
                    Operations should always be performed only on the “original” semaphore.</p><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id69">Example program</h4></div></div></div><p>In <a class="xref" href="ch30.html#locking_and_unlocking_a_mutex" title="Locking and Unlocking a Mutex">Locking and Unlocking a Mutex</a>, we presented a program
                            (<a class="xref" href="ch30.html#using_a_mutex_to_protect_access_to_a_glo" title="Example 30-2. Using a mutex to protect access to a global variable">Example 30-2</a>) that used
                        mutexes to protect a critical section in which two threads accessed the same
                        global variable. The program in <a class="xref" href="ch53.html#using_a_posix_unnamed_semaphore_to_prote" title="Example 53-6. Using a POSIX unnamed semaphore to protect access to a global variable">Example 53-6</a> solves the same
                        problem using an unnamed thread-shared semaphore.<a id="IDX-CHP-53-7124" class="indexterm"/><a id="IDX-CHP-53-7125" class="indexterm"/><a id="IDX-CHP-53-7126" class="indexterm"/></p><div class="example"><a id="using_a_posix_unnamed_semaphore_to_prote"/><div class="example-title">Example 53-6. Using a POSIX unnamed semaphore to protect access to a global
                            variable</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>psem/thread_incr_psem.c</code></strong>
#include &lt;semaphore.h&gt;
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"

static int glob = 0;
static sem_t sem;

static void *                   /* Loop 'arg' times incrementing 'glob' */
threadFunc(void *arg)
{
    int loops = *((int *) arg);
    int loc, j;

    for (j = 0; j &lt; loops; j++) {
        if (sem_wait(&amp;sem) == -1)
            errExit("sem_wait");

        loc = glob;
        loc++;
        glob = loc;

        if (sem_post(&amp;sem) == -1)
            errExit("sem_post");
    }

    return NULL;
}

int
main(int argc, char *argv[])
{
    pthread_t t1, t2;
    int loops, s;

    loops = (argc &gt; 1) ? getInt(argv[1], GN_GT_0, "num-loops") : 10000000;

    /* Initialize a thread-shared mutex with the value 1 */

    if (sem_init(&amp;sem, 0, 1) == -1)
        errExit("sem_init");

    /* Create two threads that increment 'glob' */

    s = pthread_create(&amp;t1, NULL, threadFunc, &amp;loops);
    if (s != 0)
        errExitEN(s, "pthread_create");
    s = pthread_create(&amp;t2, NULL, threadFunc, &amp;loops);
    if (s != 0)
        errExitEN(s, "pthread_create");

    /* Wait for threads to terminate */

    s = pthread_join(t1, NULL);
    if (s != 0)
        errExitEN(s, "pthread_join");
    s = pthread_join(t2, NULL);
    if (s != 0)
        errExitEN(s, "pthread_join");

    printf("glob = %d\n", glob);
    exit(EXIT_SUCCESS);
}
    <strong class="userinput"><code>psem/thread_incr_psem.c</code></strong></pre></div></div></div></div><div class="sect2" title="Destroying an Unnamed Semaphore"><div class="titlepage"><div><div><h3 class="title" id="destroying_an_unnamed_semaphore">Destroying an Unnamed Semaphore</h3></div></div></div><p>The <span class="emphasis"><em>sem_destroy()</em></span> function destroys the semaphore
                        <span class="emphasis"><em>sem</em></span>, which must be an unnamed semaphore that was
                    previously initialized using <span class="emphasis"><em>sem_init()</em></span>. It is safe to
                    destroy a semaphore only if no processes or threads are waiting on it.<a id="IDX-CHP-53-7127" class="indexterm"/><a id="IDX-CHP-53-7128" class="indexterm"/><a id="IDX-CHP-53-7129" class="indexterm"/><a id="IDX-CHP-53-7130" class="indexterm"/></p><a id="I_programlisting53_d1e140288"/><pre class="programlisting">#include &lt;semaphore.h&gt;

int <strong class="userinput"><code>sem_destroy</code></strong>(sem_t *<em class="lineannotation"><span class="lineannotation">sem</span></em>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>After an unnamed semaphore segment has been destroyed with
                        <span class="emphasis"><em>sem_destroy()</em></span>, it can be reinitialized with
                        <span class="emphasis"><em>sem_init()</em></span>.</p><p>An unnamed semaphore should be destroyed before its underlying memory is
                    deallocated. For example, if the semaphore is an automatically allocated
                    variable, it should be destroyed before its host function returns. If the
                    semaphore resides in a POSIX shared memory region, then it should be destroyed
                    after all processes have ceased using the semaphore and before the shared memory
                    object is unlinked with <span class="emphasis"><em>shm_unlink()</em></span>.</p><p>On some implementations, omitting calls to <span class="emphasis"><em>sem_destroy()</em></span>
                    doesn’t cause problems. However, on other implementations, failing to call
                        <span class="emphasis"><em>sem_destroy()</em></span> can result in resource leaks. Portable
                    applications should call <span class="emphasis"><em>sem_destroy()</em></span> to avoid such
                    problems.</p></div></div><div class="sect1" title="Comparisons with Other Synchronization Techniques"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="comparisons_with_other_synchronization_t">Comparisons with Other Synchronization Techniques</h2></div></div></div><p>In this section, we compare POSIX semaphores with two other synchronization
                techniques: System V semaphores and mutexes.<a id="IDX-CHP-53-7131" class="indexterm"/><a id="IDX-CHP-53-7132" class="indexterm"/><a id="IDX-CHP-53-7133" class="indexterm"/><a id="IDX-CHP-53-7134" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="posix_semaphores_versus_system_v"/></div></div></div><div class="sect3" title="POSIX semaphores versus System V semaphores"><div class="titlepage"><div><div><h4 class="title" id="posix_semaphores_versus_system_v-id1">POSIX semaphores versus System V semaphores</h4></div></div></div><p>POSIX semaphores and System V semaphores can both be used to synchronize
                        the actions of processes. <a class="xref" href="ch51.html#comparison_of_system_v_ipc_and_posix_ipc" title="Comparison of System V IPC and POSIX IPC">Comparison of System V IPC and POSIX IPC</a> listed various
                        advantages of POSIX IPC over System V IPC: the POSIX IPC interface is
                        simpler and more consistent with the traditional UNIX file model, and POSIX
                        IPC objects are reference counted, which simplifies the task of determining
                        when to delete an IPC object. These general advantages also apply to the
                        specific case of POSIX (named) semaphores versus System V semaphores.</p><p>POSIX semaphores have the following further advantages over System V
                        semaphores:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The POSIX semaphore interface is much simpler than the System V
                                semaphore interface. This simplicity is achieved without loss of
                                functional power.</p></li><li class="listitem"><p>POSIX named semaphores eliminate the initialization problem
                                associated with System V semaphores (<a class="xref" href="ch47.html#semaphore_initialization" title="Semaphore Initialization">Semaphore Initialization</a>).</p></li><li class="listitem"><p>It is easier to associate a POSIX unnamed semaphore with a
                                dynamically allocated memory object: the semaphore can simply be
                                embedded inside the object.</p></li><li class="listitem"><p>In scenarios where there is a high degree of contention for a
                                semaphore (i.e., operations on the semaphore are frequently blocked
                                because another process has set the semaphore to a value that
                                prevents the operation proceeding immediately), then the performance
                                of POSIX semaphores and System V semaphores is similar. However, in
                                cases where there is low contention for a semaphore (i.e., the
                                semaphore’s value is such that operations can normally proceed
                                without blocking), then POSIX semaphores perform considerably better
                                than System V semaphores. (On the systems tested by the author, the
                                difference in performance is more than an order of magnitude; see
                                Exercise 53-4.) POSIX semaphores perform so much better in this case
                                because the way in which they are implemented only requires a system
                                call when contention occurs, whereas System V semaphore operations
                                always require a system call, regardless of contention.</p></li></ul></div><p>However, POSIX semaphores also have the following disadvantages compared
                        to System V semaphores:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>POSIX semaphores are somewhat less portable. (On Linux, named
                                semaphores have been supported only since kernel 2.6.)</p></li><li class="listitem"><p>POSIX semaphores don’t provide an equivalent of the System V
                                semaphore undo feature. (However, as we noted in <a class="xref" href="ch47.html#semaphore_undo_values" title="Semaphore Undo Values">Semaphore Undo Values</a>, this feature may not be
                                useful in some circumstances.)</p></li></ul></div></div><div class="sect3" title="POSIX semaphores versus Pthreads mutexes"><div class="titlepage"><div><div><h4 class="title" id="posix_semaphores_versus_pthreads_mutexes">POSIX semaphores versus Pthreads mutexes</h4></div></div></div><p>POSIX semaphores and Pthreads mutexes can both be used to synchronize the
                        actions of threads within the same process, and their performance is
                        similar. However, mutexes are usually preferable, because the ownership
                        property of mutexes enforces good structuring of code (only the thread that
                        locks a mutex can unlock it). By contrast, one thread can increment a
                        semaphore that was decremented by another thread. This flexibility can lead
                        to poorly structured synchronization designs. (For this reason, semaphores
                        are sometimes referred to as the “gotos” of concurrent
                            programming.)<a id="IDX-CHP-53-7135" class="indexterm"/></p><p>There is one circumstance in which mutexes can’t be used in a
                        multithreaded application and semaphores may therefore be preferable.
                        Because it is async-signal-safe (see <a class="xref" href="ch21.html#functions_required_to_be_async-signal-sa" title="Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3">Table 21-1</a>, in <a class="xref" href="ch21.html#standard_async-signal-safe_functions" title="Standard async-signal-safe functions">Standard async-signal-safe functions</a>), the
                            <span class="emphasis"><em>sem_post()</em></span> function can be used from within a
                        signal handler to synchronize with another thread. This is not possible with
                        mutexes, because the Pthreads functions for operating on mutexes are not
                        async-signal-safe. However, because it is usually preferable to deal with
                        asynchronous signals by accepting them using
                            <span class="emphasis"><em>sigwaitinfo()</em></span> (or similar), rather than using
                        signal handlers (see <a class="xref" href="ch33.html#dealing_with_asynchronous_signals_sanely" title="Dealing with Asynchronous Signals Sanely">Dealing with Asynchronous Signals Sanely</a>), this advantage of
                        semaphores over mutexes is seldom required.</p></div></div></div><div class="sect1" title="Semaphore Limits"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="semaphore_limits-id1">Semaphore Limits</h2></div></div></div><p>SUSv3 defines two limits applying to semaphores:<a id="IDX-CHP-53-7136" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">SEM_NSEMS_MAX</code>
                    </span></dt><dd><p>This is the maximum number of POSIX semaphores that a process may
                            have. SUSv3 requires that this limit be at least 256. On Linux, the
                            number of POSIX semaphores is effectively limited only by available
                            memory.</p></dd><dt><span class="term">
                        <code class="literal">SEM_VALUE_MAX</code>
                    </span></dt><dd><p>This is the maximum value that a POSIX semaphore may reach. Semaphores
                            may assume any value from 0 up to this limit. SUSv3 requires this limit
                            to be at least 32,767; the Linux implementation allows values up to
                                <code class="literal">INT_MAX</code> (2,147,483,647 on
                            Linux/x86-32).</p></dd></dl></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id52">Summary</h2></div></div></div><p>POSIX semaphores allow processes or threads to synchronize their actions. POSIX
                semaphores come in two types: named and unnamed. A named semaphore is identified by
                a name, and can be shared by any processes that have permission to open the
                semaphore. An unnamed semaphore has no name, but processes or threads can share the
                same semaphore by placing it in a region of memory that they share (e.g., in a POSIX
                shared memory object for process sharing, or in a global variable for thread
                    sharing).<a id="IDX-CHP-53-7137" class="indexterm"/><a id="IDX-CHP-53-7138" class="indexterm"/><a id="IDX-CHP-53-7139" class="indexterm"/></p><p>The POSIX semaphore interface is simpler than the System V semaphore interface.
                Semaphores are allocated and operated on individually, and the wait and post
                operations adjust a semaphore’s value by one.</p><p>POSIX semaphores have a number of advantages over System V semaphores, but they
                are somewhat less portable. For synchronization within multithreaded applications,
                mutexes are generally preferred over semaphores.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id71"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id72">Further information</h4></div></div></div><p>[Stevens, 1999] provides an alternative presentation of POSIX semaphores
                        and shows user-space implementations using various other IPC mechanisms
                        (FIFOs, memory-mapped files, and System V semaphores). [Butenhof, 1996]
                        describes the use of POSIX semaphores in multithreaded applications.</p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id37">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Rewrite the programs in <a class="xref" href="ch48.html#transfer_blocks_of_data_from_stdin_to_a" title="Example 48-2. Transfer blocks of data from stdin to a System V shared memory segment">Example 48-2</a> and <a class="xref" href="ch48.html#transfer_blocks_of_data_from_a_system_v" title="Example 48-3. Transfer blocks of data from a System V shared memory segment to stdout">Example 48-3</a> (<a class="xref" href="ch48.html#example_colon_transferring_data_via_shar" title="Example: Transferring Data via Shared Memory">Example: Transferring Data via Shared Memory</a>) as a threaded
                        application, with the two threads passing data to each other via a global
                        buffer, and using POSIX semaphores for synchronization.</p></li><li class="listitem"><p>Modify the program in <a class="xref" href="ch53.html#using_sem_underscore_wait_open_parenthes" title="Example 53-3. Using sem_wait() to decrement a POSIX semaphore">Example 53-3</a> (<code class="literal">psem_wait.c</code>) to use
                            <span class="emphasis"><em>sem_timedwait()</em></span> instead of
                            <span class="emphasis"><em>sem_wait()</em></span>. The program should take an additional
                        command-line argument that specifies a (relative) number of seconds to be
                        used as the timeout for the <span class="emphasis"><em>sem_timedwait()</em></span>
                        call.</p></li><li class="listitem"><p>Devise an implementation of POSIX semaphores using System V
                        semaphores.</p></li><li class="listitem"><p>In <a class="xref" href="ch53.html#comparisons_with_other_synchronization_t" title="Comparisons with Other Synchronization Techniques">Comparisons with Other Synchronization Techniques</a>, we noted
                        that POSIX semaphores perform much better than System V semaphores in the
                        case where the semaphore is uncontended. Write two programs (one for each
                        semaphore type) to verify this. Each program should simply increment and
                        decrement a semaphore a specified number of times. Compare the times
                        required for the two programs.</p></li></ol></div></div></section></body></html>
