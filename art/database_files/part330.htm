<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.2  Deadlock Handling</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part329.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part331.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 72pt;text-indent: 0pt;text-align: left;"><a name="bookmark382">18.2  </a><span style=" color: #00AEEF;">Deadlock Handling</span><a name="bookmark423">&zwnj;</a></p><p class="s13" style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;line-height: 92%;text-align: justify;"><span class="p">A system is in a deadlock state if there exists a set of transactions such that every transaction in the set is waiting for another transaction in the set. More precisely, there exists a set of waiting transactions </span><span class="s95">{</span>T<span class="s130">0</span><span class="s94">, </span>T<span class="s130">1</span><span class="s94">, </span><span class="s15">… </span><span class="p">, </span>T<span class="s97">n</span><span class="s95">} </span><span class="p">such that </span>T<span class="s130">0 </span><span class="s94">is waiting for a data item that </span>T<span class="s130">1 </span><span class="s94">holds, and </span>T<span class="s130">1 </span><span class="s94">is waiting for a data item that </span>T<span class="s130">2 </span><span class="s94">holds, and </span><span class="s15">… </span><span class="p">, and </span>T<span class="s97">n</span><span class="s136">−</span><span class="s130">1 </span><span class="s94">is waiting for a data item that </span>T<span class="s145">n </span><span class="p">holds, and </span>T<span class="s145">n </span><span class="p">is waiting for a data item that </span>T<span class="s98">0</span><span class="p"> holds. None of the transactions can make progress in such a situation.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The only remedy to this undesirable situation is for the system to invoke some drastic action, such as rolling back some of the transactions involved in the deadlock. Rollback of a transaction may be partial: That is, a transaction may be rolled back to the point where it obtained a lock whose release resolves the deadlock.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">There are two principal methods for dealing with the deadlock problem. We can use a <span class="s63">deadlock prevention </span>protocol to ensure that the system will <i>never </i>enter a deadlock state. Alternatively, we can allow the system to enter a deadlock state, and then try to recover by using a <span class="s63">deadlock detection </span>and <span class="s63">deadlock recovery </span>scheme. As we shall see, both methods may result in transaction rollback. Prevention is commonly used if the probability that the system would enter a deadlock state is relatively high; otherwise, detection and recovery are more eﬃcient.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that a detection and recovery scheme requires overhead that includes not only the run-time cost of maintaining the necessary information and of executing the detection algorithm, but also the potential losses inherent in recovery from a deadlock.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">18.2.1 Deadlock Prevention</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">There are two approaches to deadlock prevention. One approach ensures that no cyclic waits can occur by ordering the requests for locks, or requiring all locks to be acquired together. The other approach is closer to deadlock recovery, and it performs transaction rollback instead of waiting for a lock whenever the wait could potentially result in a deadlock.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The simplest scheme under the ﬁrst approach requires that each transaction locks all its data items before it begins execution. Moreover, either all are locked in one step or none are locked. There are two main disadvantages to this protocol: (1) it is often hard to predict, before the transaction begins, what data items need to be locked; (2) data-item utilization may be very low, since many of the data items may be locked but unused for a long time.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Another approach for preventing deadlocks is to impose an ordering of all data items and to require that a transaction lock data items only in a sequence consistent with the ordering. We have seen one such scheme in the tree protocol, which uses a partial ordering of data items.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A variation of this approach is to use a total order of data items, in conjunction with two-phase locking. Once a transaction has locked a particular item, it cannot request locks on items that precede that item in the ordering. This scheme is easy to implement,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">as long as the set of data items accessed by a transaction is known when the transaction starts execution. There is no need to change the underlying concurrency-control system if two-phase locking is used: All that is needed is to ensure that locks are requested in the right order.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The second approach for preventing deadlocks is to use preemption and transac- tion rollbacks. In preemption, when a transaction <i>T</i><span class="s145">j </span>requests a lock that transaction <i>T</i><span class="s145">i </span>holds, the lock granted to <i>T</i><span class="s145">i </span>may be <span class="s63">preempted </span>by rolling back of <i>T</i><span class="s145">i</span>, and granting of the lock to <i>T</i><span class="s145">j </span>. To control the preemption, we assign a unique timestamp, based on a counter or on the system clock, to each transaction when it begins. The system uses these timestamps only to decide whether a transaction should wait or roll back. Lock- ing is still used for concurrency control. If a transaction is rolled back, it retains its <i>old </i>timestamp when restarted. Two diﬀerent deadlock-prevention schemes using times- tamps have been proposed:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 113pt;text-indent: -16pt;line-height: 88%;text-align: right;"><span class="s63">1. </span><span class="p">The </span><span class="s63">wait–die </span><span class="p">scheme is a nonpreemptive technique. When transaction </span>T<span class="s97">i </span><span class="p">requests a data item currently held by </span>T<span class="s97">j </span><span class="p">, </span>T<span class="s97">i </span><span class="p">is allowed to wait only if it has a timestamp smaller than that of </span>T<span class="s97">j </span><span class="p">(i.e., </span>T<span class="s97">i </span><span class="p">is older than </span>T<span class="s97">j </span><span class="p">). Otherwise, </span>T<span class="s97">i </span><span class="p">is rolled back (dies). For example, suppose that transactions </span>T<span class="s93">14</span><span class="s94">, </span>T<span class="s93">15</span><span class="s94">, and </span>T<span class="s93">16 </span><span class="s94">have timestamps 5, 10, and 15, respectively. If </span>T<span class="s93">14 </span><span class="s94">requests a data item held by </span>T<span class="s93">15</span><span class="s94">, then </span>T<span class="s93">14 </span><span class="s94">will wait.</span></p><p class="s13" style="padding-left: 113pt;text-indent: 0pt;line-height: 12pt;text-align: justify;"><span class="p">If </span>T<span class="s93">16 </span><span class="s94">requests a data item held by </span>T<span class="s93">15</span><span class="s94">, then </span>T<span class="s93">16 </span><span class="s94">will be rolled back.</span></p><p style="padding-top: 5pt;padding-left: 113pt;text-indent: -17pt;line-height: 93%;text-align: justify;"><span class="s63">2. </span>The <span class="s63">wound–wait </span>scheme is a preemptive technique. It is a counterpart to the wait– die scheme. When transaction <i>T</i><span class="s97">i </span>requests a data item currently held by <i>T</i><span class="s97">j </span>, <i>T</i><span class="s97">i </span>is allowed to wait only if it has a timestamp larger than that of <i>T</i><span class="s145">j </span>(i.e., <i>T</i><span class="s145">i </span>is younger than <i>T</i><span class="s145">j </span>). Otherwise, <i>T</i><span class="s145">j </span>is rolled back (<i>T</i><span class="s145">j </span>is <i>wounded </i>by <i>T</i><span class="s145">i</span>).</p><p class="s13" style="padding-left: 113pt;text-indent: 14pt;line-height: 87%;text-align: justify;"><span class="p">Returning to our example, with transactions </span>T<span class="s130">14</span><span class="s94">, </span>T<span class="s130">15</span><span class="s94">, and </span>T<span class="s130">16</span><span class="s94">, if </span>T<span class="s130">14 </span><span class="s94">requests a data item held by </span>T<span class="s130">15</span><span class="s94">, then the data item will be preempted from </span>T<span class="s130">15</span><span class="s94">, and </span>T<span class="s130">15 </span><span class="s94">will be rolled back. If </span>T<span class="s130">16 </span><span class="s94">requests a data item held by </span>T<span class="s130">15</span><span class="s94">, then </span>T<span class="s130">16 </span><span class="s94">will wait.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The major problem with both of these schemes is that unnecessary rollbacks may occur.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">Another simple approach to deadlock prevention is based on <span class="s63">lock timeouts</span>. In this approach, a transaction that has requested a lock waits for at most a speciﬁed amount of time. If the lock has not been granted within that time, the transaction is said to time out, and it rolls itself back and restarts. If there was in fact a deadlock, one or more transactions involved in the deadlock will time out and roll back, allowing the others to proceed. This scheme falls somewhere between deadlock prevention, where a deadlock will never occur, and deadlock detection and recovery, which Section 18.2.2 discusses. The timeout scheme is particularly easy to implement, and it works well if transac- tions are short and if long waits are likely to be due to deadlocks. However, in general it is hard to decide how long a transaction must wait before timing out. Too long a wait results in unnecessary delays once a deadlock has occurred. Too short a wait results in transaction rollback even when there is no deadlock, leading to wasted resources.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Starvation is also a possibility with this scheme. Hence, the timeout-based scheme has limited applicability.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">18.2.2 Deadlock Detection and Recovery</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">If a system does not employ some protocol that ensures deadlock freedom, then a detection and recovery scheme must be used. An algorithm that examines the state of the system is invoked periodically to determine whether a deadlock has occurred. If one has, then the system must attempt to recover from the deadlock. To do so, the system must:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s40">Maintain information about the current allocation of data items to transactions, as well as any outstanding data item requests.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s40">Provide an algorithm that uses this information to determine whether the system has entered a deadlock state.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s40">Recover from the deadlock when the detection algorithm determines that a dead- lock exists.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">In this section, we elaborate on these issues.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">18.2.2.1 Deadlock Detection</p><p class="s13" style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;line-height: 93%;text-align: justify;"><span class="p">Deadlocks can be described precisely in terms of a directed graph called a </span><span class="s63">wait-for graph</span><span class="p">. This graph consists of a pair </span>G <span class="p">= (</span>V <span class="p">, </span>E<span class="p">), where </span>V <span class="p">is a set of vertices and </span>E <span class="p">is a set of edges. The set of vertices consists of all the transactions in the system. Each element in the set </span>E <span class="p">of edges is an ordered pair </span>T<span class="s97">i </span><span class="s86">→ </span>T<span class="s97">j </span><span class="p">. If </span>T<span class="s97">i </span><span class="s86">→ </span>T<span class="s97">j </span><span class="p">is in </span>E<span class="p">, then there is a directed edge from transaction </span>T<span class="s97">i </span><span class="p">to </span>T<span class="s97">j </span><span class="p">, implying that transaction </span>T<span class="s97">i </span><span class="p">is waiting for transaction </span>T<span class="s97">j </span><span class="p">to release a data item that it needs.</span></p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;line-height: 82%;text-align: justify;"><span class="p">When transaction </span>T<span class="s97">i </span><span class="p">requests a data item currently being held by transaction </span>T<span class="s97">j </span><span class="p">, then the edge </span>T<span class="s97">i  </span><span class="s86">→ </span>T<span class="s97">j </span><span class="p">is inserted in the wait-for graph. This edge is removed only when transaction </span>T<span class="s145">j </span><span class="p">is no longer holding a data item needed by transaction </span>T<span class="s145">i</span><span class="p">.</span></p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">A deadlock exists in the system if and only if the wait-for graph contains a cycle.</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Each transaction involved in the cycle is said to be deadlocked. To detect deadlocks, the system needs to maintain the wait-for graph, and periodically to invoke an algorithm that searches for a cycle in the graph.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To illustrate these concepts, consider the wait-for graph in Figure 18.13, which depicts the following situation:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Transaction </span>T<span class="s130">17 </span><span class="s94">is waiting for transactions </span>T<span class="s130">18 </span><span class="s94">and </span>T<span class="s130">19</span><span class="s94">.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Transaction </span>T<span class="s93">19 </span><span class="s94">is waiting for transaction </span>T<span class="s93">18</span><span class="s94">.</span></p><p class="s13" style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Transaction </span>T<span class="s130">18 </span><span class="s94">is waiting for transaction </span>T<span class="s130">20</span><span class="s94">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="159" height="117" alt="image" src="Image_3010.png"/></span></p><p class="s429" style="text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s430">18</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s429" style="text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s430">20</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s429" style="text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s430">17</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s429" style="text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s430">19</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 18.13 <span class="s74">Wait-for graph with no cycle.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">Since the graph has no cycle, the system is not in a deadlock state.</p><p class="s13" style="padding-left: 88pt;text-indent: 17pt;line-height: 93%;text-align: justify;"><span class="p">Suppose now that transaction </span>T<span class="s93">20 </span><span class="s94">is requesting an item held by </span>T<span class="s93">19</span><span class="s94">. The edge </span>T<span class="s93">20 </span><span class="s86">→ </span>T<span class="s98">19</span><span class="p"> is added to the wait-for graph, resulting in the new system state in Figure 18.14. This time, the graph contains the cycle:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s128" style="padding-left: 62pt;text-indent: 0pt;text-align: center;">T<span class="s119">18 </span><span class="s147">→ </span>T<span class="s119">20 </span><span class="s147">→ </span>T<span class="s119">19 </span><span class="s147">→ </span>T<span class="s119">18</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p">implying that transactions </span>T<span class="s130">18</span><span class="s94">, </span>T<span class="s130">19</span><span class="s94">, and </span>T<span class="s130">20 </span><span class="s94">are all deadlocked.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Consequently, the question arises: When should we invoke the detection algo-</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">rithm? The answer depends on two factors:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 97pt;text-indent: 0pt;text-align: left;">1. <span class="p">How often does a deadlock occur?</span></p><p class="s63" style="padding-top: 6pt;padding-left: 96pt;text-indent: 0pt;text-align: left;">2. <span class="p">How many transactions will be aﬀected by the deadlock?</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If deadlocks occur frequently, then the detection algorithm should be invoked more frequently. Data items allocated to deadlocked transactions will be unavailable to other transactions until the deadlock can be broken. In addition, the number of cycles in the graph may also grow. In the worst case, we would invoke the detection algorithm every time a request for allocation could not be granted immediately.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="159" height="116" alt="image" src="Image_3011.png"/></span></p><p class="s429" style="text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s430">18</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s429" style="text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s430">20</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s429" style="text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s430">17</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s429" style="text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s430">19</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 18.14 <span class="s74">Wait-for graph with a cycle.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><a name="bookmark383">18.2.2.2 Recovery from Deadlock</a><a name="bookmark424">&zwnj;</a></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">When a detection algorithm determines that a deadlock exists, the system must <span class="s63">recover </span>from the deadlock. The most common solution is to roll back one or more transactions to break the deadlock. Three actions need to be taken:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span><b>Selection of a victim</b>. Given a set of deadlocked transactions, we must determine which transaction (or transactions) to roll back to break the deadlock. We should roll back those transactions that will incur the minimum cost. Unfortunately, the term <i>minimum cost </i>is not a precise one. Many factors may determine the cost of a rollback, including:</p><p style="padding-top: 6pt;padding-left: 171pt;text-indent: -15pt;text-align: left;">a. How long the transaction has computed, and how much longer the trans- action will compute before it completes its designated task.</p><p style="padding-top: 6pt;padding-left: 154pt;text-indent: 0pt;text-align: left;">b. How many data items the transaction has used.</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: 0pt;text-align: left;">c. How many more data items the transaction needs for it to complete.</p><p style="padding-top: 6pt;padding-left: 154pt;text-indent: 0pt;text-align: left;">d. How many transactions will be involved in the rollback.</p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: left;">2. <span style=" color: #231F20;">Rollback</span><span class="p">. Once we have decided that a particular transaction must be rolled back, we must determine how far this transaction should be rolled back.</span></p><p style="padding-left: 145pt;text-indent: 13pt;text-align: justify;">The simplest solution is a <span class="s63">total rollback</span>: Abort the transaction and then restart it. However, it is more eﬀective to roll back the transaction only as far as necessary to break the deadlock. Such <span class="s63">partial rollback </span>requires the system to maintain ad- ditional information about the state of all the running transactions. Speciﬁcally, the sequence of lock requests/grants and updates performed by the transaction needs to be recorded. The deadlock detection mechanism should decide which locks the selected transaction needs to release in order to break the deadlock. The selected transaction must be rolled back to the point where it obtained the ﬁrst of these locks, undoing all actions it took after that point. The recovery mech- anism must be capable of performing such partial rollbacks. Furthermore, the transactions must be capable of resuming execution after a partial rollback. See the online bibliographical notes for relevant references.</p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">3. <span style=" color: #231F20;">Starvation</span><span class="p">. In a system where the selection of victims is based primarily on cost factors, it may happen that the same transaction is always picked as a victim. As a result, this transaction never completes its designated task, thus there is </span>starvation<span class="p">. We must ensure that a transaction can be picked as a victim only a (small) ﬁnite number of times. The most common solution is to include the number of rollbacks in the cost factor.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part329.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part331.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
