<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>17.10  Transactions as SQL Statements</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part319.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part321.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">17.10  <span style=" color: #00AEEF;">Transactions as SQL Statements</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In Section 4.3, we presented the <span class="s44">SQL </span>syntax for specifying the beginning and end of transactions. Now that we have seen some of the issues in ensuring the <span class="s44">ACID </span>proper- ties for transactions, we are ready to consider how those properties are ensured when transactions are speciﬁed as a sequence of <span class="s44">SQL </span>statements rather than the restricted model of simple reads and writes that we considered up to this point.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In our simple model, we assumed a set of data items exists. While our simple model allowed data-item values to be changed, it did not allow data items to be created or deleted. In <span class="s44">SQL</span>, however, <b>insert </b>statements create new data and <b>delete </b>statements delete data. These two statements are, in eﬀect, <b>write </b>operations, since they change the database, but their interactions with the actions of other transactions are diﬀerent from what we saw in our simple model. As an example, consider how insertion or deletion would conﬂict with the following <span class="s44">SQL </span>query, which ﬁnds all instructors who earn more than $90,000:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 227pt;text-indent: 0pt;text-align: left;">select <span class="s69">ID</span><span class="p">, </span><i>name</i></p><p class="s46" style="padding-left: 227pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 227pt;text-indent: 0pt;line-height: 20pt;text-align: left;">where <i>salary </i><span class="s83">&gt; </span><span class="p">90000;</span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Using our sample <i>instructor </i>relation (Section A.3), we ﬁnd that only Einstein and Brandt satisfy the condition. Now assume that around the same time we are running our query, another user inserts a new instructor named “James” whose salary is $100,000.</p><p class="s66" style="padding-top: 3pt;padding-left: 302pt;text-indent: 0pt;text-align: left;">17.10 <span style=" color: #00AEEF;">Transactions as SQL Statements  </span><span class="s164">827</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 164pt;text-indent: 0pt;text-align: left;">insert into <i>instructor </i>values <span class="p">(&#39;11111&#39;, &#39;James&#39;, &#39;Marketing&#39;, 100000);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">The result of our query depends on whether this insert comes before or after our query is run. In a concurrent execution of these transactions, it is intuitively clear that they conﬂict, but this is a conﬂict that may not be captured by our simple model. This situ- ation is referred to as the <span class="s63">phantom phenomenon </span>because a conﬂict may exist on “phan- tom” data.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Our simple model of transactions required that operations operate on a speciﬁc data item given as an argument to the operation. In our simple model, we can look at the <b>read </b>and <b>write </b>steps to see which data items are referenced. But in an <span class="s44">SQL </span>statement, the speciﬁc data items (tuples) referenced may be determined by a <b>where </b>clause predicate. So the same transaction, if run more than once, might reference diﬀerent data items each time it is run if the values in the database change between runs. In our example,</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 94%;text-align: justify;"><span class="p">the &#39;James&#39; tuple is referenced only if our query comes after the insertion. Let </span>T <span class="p">denote the query and let </span>T <span class="s181">′</span><span class="s15"> </span><span class="p">denote the insert. If </span>T <span class="s181">′</span><span class="s15"> </span><span class="p">comes ﬁrst, then there is an edge </span>T <span class="s181">′</span><span class="s15"> </span><span class="s86">→ </span>T <span class="p">in the precedence graph. However, in the case where the query </span>T <span class="p">comes ﬁrst, there is no edge in the precedence graph between </span>T <span class="p">and </span>T <span class="s181">′</span><span class="s15"> </span><span class="p">despite the actual conﬂict on phantom data that forces </span>T <span class="p">to be serialized before </span>T <span class="s181">′</span><span class="p">.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The above-mentioned problem demonstrates that it is not suﬃcient for concur- rency control to consider only the tuples that are accessed by a transaction; the in- formation used to ﬁnd the tuples that are accessed by the transaction must also be considered for the purpose of concurrency control. The information used to ﬁnd tu- ples could be updated by an insertion or deletion, or in the case of an index, even by an update to a search-key attribute. For example, if locking is used for concurrency control, the data structures that track the tuples in a relation, as well as index structures, must be appropriately locked. However, such locking can lead to poor concurrency in some situations; index-locking protocols that maximize concurrency, while ensuring serial- izability in spite of inserts, deletes, and predicates in queries, are discussed in Section 18.4.3.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">Let us consider again the query:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 260pt;text-indent: 0pt;text-align: left;">select <span class="s69">ID</span><span class="p">, </span><i>name</i></p><p class="s46" style="padding-left: 260pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 260pt;text-indent: 0pt;line-height: 20pt;text-align: left;">where <i>salary</i><span class="s83">&gt; </span><span class="p">90000;</span></p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">and the following <span class="s44">SQL </span>update:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 256pt;text-indent: 0pt;text-align: left;">update <i>instructor</i></p><p class="s13" style="padding-left: 256pt;text-indent: 0pt;text-align: left;"><b>set </b>salary <span class="p">= </span>salary <span class="p">* 0.9</span></p><p class="s46" style="padding-left: 256pt;text-indent: 0pt;text-align: left;">where <i>name </i><span class="s15">= </span><span class="p">’Wu’;</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">We now face an interesting situation in determining whether our query conﬂicts with the update statement. If our query reads the entire <i>instructor </i>relation, then it reads the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;line-height: 76%;text-align: justify;"><a name="bookmark377">tuple with Wu’s data and conﬂicts with the update. However, if an index were available that allowed our query direct access to those tuples with </a><i>salary </i><span class="s83">&gt; </span>90000, then our query would not have accessed Wu’s data at all because Wu’s salary is initially $90,000 in our<a name="bookmark419">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">example instructor relation and reduces to $81,000 after the update.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">However, using the above approach, it would appear that the existence of a conﬂict depends on a low-level query processing decision by the system that is unrelated to a user-level view of the meaning of the two <span class="s44">SQL </span>statements! An alternative approach to concurrency control treats an insert, delete, or update as conﬂicting with a predicate</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 84%;text-align: justify;">on a relation, if it could aﬀect the set of tuples selected by a predicate. In our example query above, the predicate is “<i>salary </i><span class="s83">&gt; </span>90000”, and an update of Wu’s salary from</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">$90,000 to a value greater than $90,000, or an update of Einstein’s salary from a value</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">greater than $90,000 to a value less than or equal to $90,000, would conﬂict with this predicate. Locking based on this idea is called <span class="s63">predicate locking</span>; predicate locking is often implemented using locks on index nodes as we see in Section 18.4.3.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part319.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part321.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
