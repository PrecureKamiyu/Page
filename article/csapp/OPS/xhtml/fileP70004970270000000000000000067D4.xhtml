<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>8.2 Processes</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P70004970270000000000000000067D4" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000044FC7" data-uri="chapter08.xhtml#P7000497027000000000000000044FC7" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000067D6" title="732" data-uri="chapter08.xhtml#P70004970270000000000000000067D6" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">8.2 </span>Processes</h1></header>
<p id="P7000497027000000000000000044FC8" data-uri="chapter08.xhtml#P7000497027000000000000000044FC8" class="pcalibre1 pcalibre calibre2">Exceptions are the basic building blocks that allow the operating system kernel to provide the notion of a <i class="calibre5 pcalibre pcalibre1">process</i>, one of the most profound and successful ideas in computer science.</p>
<p id="P7000497027000000000000000044FC9" data-uri="chapter08.xhtml#P7000497027000000000000000044FC9" class="pcalibre1 pcalibre calibre2">When we run a program on a modern system, we are presented with the illusion that our program is the only one currently running in the system. Our program appears to have exclusive use of both the processor and the memory. The processor appears to execute the instructions in our program, one after the other, without interruption. Finally, the code and data of our program appear to be the only objects in the system's memory. These illusions are provided to us by the notion of a process.</p>
<p id="P7000497027000000000000000044FCA" data-uri="chapter08.xhtml#P7000497027000000000000000044FCA" class="pcalibre1 pcalibre calibre2">The classic definition of a process is <i class="calibre5 pcalibre pcalibre1">an instance of a program in execution</i>. Each program in the system runs in the <i class="calibre5 pcalibre pcalibre1">context</i> of some process. The context consists of the state that the program needs to run correctly. This state includes the program's code and data stored in memory, its stack, the contents of its general purpose registers, its program counter, environment variables, and the set of open file descriptors.</p>
<p id="P7000497027000000000000000044FCB" data-uri="chapter08.xhtml#P7000497027000000000000000044FCB" class="pcalibre1 pcalibre calibre2">Each time a user runs a program by typing the name of an executable object file to the shell, the shell creates a new process and then runs the executable object file in the context of this new process. Application programs can also create new processes and run either their own code or other applications in the context of the new process.</p>
<p id="P7000497027000000000000000044FCC" data-uri="chapter08.xhtml#P7000497027000000000000000044FCC" class="pcalibre1 pcalibre calibre2">A detailed discussion of how operating systems implement processes is beyond our scope. Instead, we will focus on the key abstractions that a process provides to the application:</p>
<ul id="P7000497027000000000000000044FCD" data-uri="chapter08.xhtml#P7000497027000000000000000044FCD" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000044FCE" data-uri="chapter08.xhtml#P7000497027000000000000000044FCE" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044FCF" data-uri="chapter08.xhtml#P7000497027000000000000000044FCF" class="pcalibre calibre3 pcalibre1">An independent logical control flow that provides the illusion that our program has exclusive use of the processor.</p></li>
<li id="P7000497027000000000000000044FD0" data-uri="chapter08.xhtml#P7000497027000000000000000044FD0" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044FD1" data-uri="chapter08.xhtml#P7000497027000000000000000044FD1" class="pcalibre calibre3 pcalibre1">A private address space that provides the illusion that our program has exclusive use of the memory system.</p></li>
</ul>
<p id="P7000497027000000000000000044FD2" data-uri="chapter08.xhtml#P7000497027000000000000000044FD2" class="pcalibre1 pcalibre calibre2">Let's look more closely at these abstractions.</p>

<section id="P70004970270000000000000000067E2" data-uri="chapter08.xhtml#P70004970270000000000000000067E2" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000044FD3" data-uri="chapter08.xhtml#P7000497027000000000000000044FD3" epub:type="title"><span class="pcalibre label pcalibre1">8.2.1  </span>Logical Control Flow</h1></header>
<p id="P7000497027000000000000000044FD4" data-uri="chapter08.xhtml#P7000497027000000000000000044FD4" class="pcalibre1 pcalibre calibre2">A process provides each program with the illusion that it has exclusive use of the processor, even though many other programs are typically running concurrently on the system. If we were to use a debugger to single-step the execution of our program, we would observe a series of program counter (PC) values that corresponded exclusively to instructions contained in our program's executable object file or in shared objects linked into our program dynamically at run time. This sequence of PC values is known as a <i class="calibre5 pcalibre pcalibre1">logical control flow</i>, or simply <i class="calibre5 pcalibre pcalibre1">logical flow</i>.</p>
<p id="P7000497027000000000000000044FD5" data-uri="chapter08.xhtml#P7000497027000000000000000044FD5" class="pcalibre1 pcalibre calibre2">Consider a system that runs three processes, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000067E6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.12</span></a>. The single physical control flow of the processor is partitioned into three logical flows, one for each process. Each vertical line represents a portion of the logical flow for</p>

<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000067E6" data-uri="chapter08.xhtml#P70004970270000000000000000067E6">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000067E7" title="733" data-uri="chapter08.xhtml#P70004970270000000000000000067E7" epub:type="pagebreak"></span><img alt="A diagram shows a vertical arrow representing time and vertical lines moving from Process A to Process B to Process C to Process A to Process C, over time." id="P7000497027000000000000000044FD6" data-uri="P700049702700000000000000000B768" src="../images/p733-1.png" class="pcalibre1 pcalibre calibre246"/>
<figcaption id="P7000497027000000000000000044FD7" data-uri="chapter08.xhtml#P7000497027000000000000000044FD7" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000044FD8" data-uri="chapter08.xhtml#P7000497027000000000000000044FD8" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">8.12 </span>Logical control flows.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000044FD9" data-uri="chapter08.xhtml#P7000497027000000000000000044FD9"><p id="P7000497027000000000000000044FDA" data-uri="chapter08.xhtml#P7000497027000000000000000044FDA" class="pcalibre calibre3 pcalibre1">Processes provide each program with the illusion that it has exclusive use of the processor. Each vertical bar represents a portion of the logical control flow for a process.</p></div>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044FDB" data-uri="chapter08.xhtml#P7000497027000000000000000044FDB">a process. In the example, the execution of the three logical flows is interleaved. Process A runs for a while, followed by B, which runs to completion. Process C then runs for a while, followed by A, which runs to completion. Finally, C is able to run to completion.</p>
<p id="P7000497027000000000000000044FDC" data-uri="chapter08.xhtml#P7000497027000000000000000044FDC" class="pcalibre1 pcalibre calibre2">The key point in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000067E6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.12</span></a> is that processes take turns using the processor. Each process executes a portion of its flow and then is <i class="calibre5 pcalibre pcalibre1">preempted</i> (temporarily suspended) while other processes take their turns. To a program running in the context of one of these processes, it appears to have exclusive use of the processor. The only evidence to the contrary is that if we were to precisely measure the elapsed time of each instruction, we would notice that the CPU appears to periodically stall between the execution of some of the instructions in our program. However, each time the processor stalls, it subsequently resumes execution of our program without any change to the contents of the program's memory locations or registers.</p>
</section>
<section id="P70004970270000000000000000067EF" data-uri="chapter08.xhtml#P70004970270000000000000000067EF" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000044FDD" data-uri="chapter08.xhtml#P7000497027000000000000000044FDD" epub:type="title"><span class="pcalibre label pcalibre1">8.2.2  </span>Concurrent Flows</h1></header>
<p id="P7000497027000000000000000044FDE" data-uri="chapter08.xhtml#P7000497027000000000000000044FDE" class="pcalibre1 pcalibre calibre2">Logical flows take many different forms in computer systems. Exception handlers, processes, signal handlers, threads, and Java processes are all examples of logical flows.</p>
<p id="P7000497027000000000000000044FDF" data-uri="chapter08.xhtml#P7000497027000000000000000044FDF" class="pcalibre1 pcalibre calibre2">A logical flow whose execution overlaps in time with another flow is called a <i class="calibre5 pcalibre pcalibre1">concurrent flow</i>, and the two flows are said to <i class="calibre5 pcalibre pcalibre1">run concurrently</i>. More precisely, flows X and Y are concurrent with respect to each other if and only if X begins after Y begins and before Y finishes, or Y begins after X begins and before X finishes. For example, in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000067E6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.12</span></a>, processes A and B run concurrently, as do A and C. On the other hand, B and C do not run concurrently, because the last instruction of B executes before the first instruction of C.</p>
<p id="P7000497027000000000000000044FE0" data-uri="chapter08.xhtml#P7000497027000000000000000044FE0" class="pcalibre1 pcalibre calibre2">The general phenomenon of multiple flows executing concurrently is known as <i class="calibre5 pcalibre pcalibre1">concurrency</i>. The notion of a process taking turns with other processes is also known as <i class="calibre5 pcalibre pcalibre1">multitasking</i>. Each time period that a process executes a portion of its flow is called a <i class="calibre5 pcalibre pcalibre1">time slice</i>. Thus, multitasking is also referred to as <i class="calibre5 pcalibre pcalibre1">time slicing</i>. For example, in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000067E6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.12</span></a>, the flow for process A consists of two time slices.</p>
<p id="P7000497027000000000000000044FE1" data-uri="chapter08.xhtml#P7000497027000000000000000044FE1" class="pcalibre1 pcalibre calibre2">Notice that the idea of concurrent flows is independent of the number of processor cores or computers that the flows are running on. If two flows overlap in time, then they are concurrent, even if they are running on the same processor. However, we will sometimes find it useful to identify a proper subset of concurrent <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000067F5" title="734" data-uri="chapter08.xhtml#P70004970270000000000000000067F5" epub:type="pagebreak"></span>flows known as <i class="calibre5 pcalibre pcalibre1">parallel flows</i>. If two flows are running concurrently on different processor cores or computers, then we say that they are <i class="calibre5 pcalibre pcalibre1">parallel flows</i>, that they are <i class="calibre5 pcalibre pcalibre1">running in parallel</i>, and have <i class="calibre5 pcalibre pcalibre1">parallel execution</i>.</p>

<section id="P70004970270000000000000000067F6" data-uri="chapter08.xhtml#P70004970270000000000000000067F6" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000044FE2" data-uri="chapter08.xhtml#P7000497027000000000000000044FE2" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">8.1 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006F86">795</a>)</h1></header>
<p id="P7000497027000000000000000044FE3" data-uri="chapter08.xhtml#P7000497027000000000000000044FE3" class="pcalibre1 pcalibre calibre2">Consider three processes with the following starting and ending times:</p>
<table id="P7000497027000000000000000044FE4" data-uri="chapter08.xhtml#P7000497027000000000000000044FE4" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000044FE5" data-uri="chapter08.xhtml#P7000497027000000000000000044FE5" class="calibre18 pcalibre pcalibre1">
Process</th><th id="P7000497027000000000000000044FE6" data-uri="chapter08.xhtml#P7000497027000000000000000044FE6" class="calibre18 pcalibre pcalibre1">Start time</th><th id="P7000497027000000000000000044FE7" data-uri="chapter08.xhtml#P7000497027000000000000000044FE7" class="calibre18 pcalibre pcalibre1">End time</th></tr></thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1"><td id="P7000497027000000000000000044FE8" data-uri="chapter08.xhtml#P7000497027000000000000000044FE8" class="calibre20 pcalibre pcalibre1">A</td><td id="P7000497027000000000000000044FE9" data-uri="chapter08.xhtml#P7000497027000000000000000044FE9" class="calibre20 pcalibre pcalibre1">0</td><td id="P7000497027000000000000000044FEA" data-uri="chapter08.xhtml#P7000497027000000000000000044FEA" class="calibre20 pcalibre pcalibre1">2</td></tr>
<tr class="pcalibre calibre17 pcalibre1"><td id="P7000497027000000000000000044FEB" data-uri="chapter08.xhtml#P7000497027000000000000000044FEB" class="calibre20 pcalibre pcalibre1">B</td><td id="P7000497027000000000000000044FEC" data-uri="chapter08.xhtml#P7000497027000000000000000044FEC" class="calibre20 pcalibre pcalibre1">1</td><td id="P7000497027000000000000000044FED" data-uri="chapter08.xhtml#P7000497027000000000000000044FED" class="calibre20 pcalibre pcalibre1">4</td></tr>
<tr class="pcalibre calibre17 pcalibre1"><td id="P7000497027000000000000000044FEE" data-uri="chapter08.xhtml#P7000497027000000000000000044FEE" class="calibre20 pcalibre pcalibre1">C</td><td id="P7000497027000000000000000044FEF" data-uri="chapter08.xhtml#P7000497027000000000000000044FEF" class="calibre20 pcalibre pcalibre1">3</td><td id="P7000497027000000000000000044FF0" data-uri="chapter08.xhtml#P7000497027000000000000000044FF0" class="calibre20 pcalibre pcalibre1">5</td></tr>
</tbody>
</table>
<p id="P7000497027000000000000000044FF1" data-uri="chapter08.xhtml#P7000497027000000000000000044FF1" class="pcalibre1 pcalibre calibre2">For each pair of processes, indicate whether they run concurrently (Y) or not (N):</p>
<table id="P7000497027000000000000000044FF2" data-uri="chapter08.xhtml#P7000497027000000000000000044FF2" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000044FF3" data-uri="chapter08.xhtml#P7000497027000000000000000044FF3" class="calibre18 pcalibre pcalibre1">
Process pair</th><th id="P7000497027000000000000000044FF4" data-uri="chapter08.xhtml#P7000497027000000000000000044FF4" class="calibre18 pcalibre pcalibre1">Concurrent?</th></tr></thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1"><td id="P7000497027000000000000000044FF5" data-uri="chapter08.xhtml#P7000497027000000000000000044FF5" class="calibre20 pcalibre pcalibre1">AB</td><td id="P7000497027000000000000000044FF6" data-uri="chapter08.xhtml#P7000497027000000000000000044FF6" class="calibre20 pcalibre pcalibre1"><span class="wol pcalibre pcalibre1">     </span></td></tr>
<tr class="pcalibre calibre17 pcalibre1"><td id="P7000497027000000000000000044FF7" data-uri="chapter08.xhtml#P7000497027000000000000000044FF7" class="calibre20 pcalibre pcalibre1">AC</td><td id="P7000497027000000000000000044FF8" data-uri="chapter08.xhtml#P7000497027000000000000000044FF8" class="calibre20 pcalibre pcalibre1"><span class="wol pcalibre pcalibre1">     </span></td></tr>
<tr class="pcalibre calibre17 pcalibre1"><td id="P7000497027000000000000000044FF9" data-uri="chapter08.xhtml#P7000497027000000000000000044FF9" class="calibre20 pcalibre pcalibre1">BC</td><td id="P7000497027000000000000000044FFA" data-uri="chapter08.xhtml#P7000497027000000000000000044FFA" class="calibre20 pcalibre pcalibre1"><span class="wol pcalibre pcalibre1">     </span></td></tr>
</tbody>
</table>
</section>
</section>

<section id="P7000497027000000000000000006810" data-uri="chapter08.xhtml#P7000497027000000000000000006810" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000044FFB" data-uri="chapter08.xhtml#P7000497027000000000000000044FFB" epub:type="title"><span class="pcalibre label pcalibre1">8.2.3  </span>Private Address Space</h1></header>
<p id="P7000497027000000000000000044FFC" data-uri="chapter08.xhtml#P7000497027000000000000000044FFC" class="pcalibre1 pcalibre calibre2">A process provides each program with the illusion that it has exclusive use of the system's address space. On a machine with <var class="calibre5 pcalibre pcalibre1">n</var>-bit addresses, the <i class="calibre5 pcalibre pcalibre1">address space</i> is the set of 2<sup class="calibre51 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">n</var></sup> possible addresses, 0, 1, ... , 2<sup class="calibre51 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">n</var></sup> - 1. A process provides each program with its own <i class="calibre5 pcalibre pcalibre1">private address space</i>. This space is private in the sense that a byte of memory associated with a particular address in the space cannot in general be read or written by any other process.</p>
<p id="P7000497027000000000000000044FFD" data-uri="chapter08.xhtml#P7000497027000000000000000044FFD" class="pcalibre1 pcalibre calibre2">Although the contents of the memory associated with each private address space is different in general, each such space has the same general organization. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006819"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.13</span></a> shows the organization of the address space for an x86-64 Linux process.</p>
<p id="P7000497027000000000000000044FFE" data-uri="chapter08.xhtml#P7000497027000000000000000044FFE" class="pcalibre1 pcalibre calibre2">The bottom portion of the address space is reserved for the user program, with the usual code, data, heap, and stack segments. The code segment always begins at address <code id="P7000497027000000000000000044FFF" data-uri="chapter08.xhtml#P7000497027000000000000000044FFF" class="pcalibre1 calibre8 pcalibre">0x400000</code>. The top portion of the address space is reserved for the kernel (the memory-resident part of the operating system). This part of the address space contains the code, data, and stack that the kernel uses when it executes instructions on behalf of the process (e.g., when the application program executes a system call).</p>
</section>
<section id="P7000497027000000000000000006816" data-uri="chapter08.xhtml#P7000497027000000000000000006816" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045000" data-uri="chapter08.xhtml#P7000497027000000000000000045000" epub:type="title"><span class="pcalibre label pcalibre1">8.2.4  </span>User and Kernel Modes</h1></header>
<p id="P7000497027000000000000000045001" data-uri="chapter08.xhtml#P7000497027000000000000000045001" class="pcalibre1 pcalibre calibre2">In order for the operating system kernel to provide an airtight process abstraction, the processor must provide a mechanism that restricts the instructions that an</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000006819" data-uri="chapter08.xhtml#P7000497027000000000000000006819">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000681A" title="735" data-uri="chapter08.xhtml#P700049702700000000000000000681A" epub:type="pagebreak"></span><img alt="A diagram illustrates process address space." id="P7000497027000000000000000045002" data-uri="P700049702700000000000000000B769" src="../images/p735-1.png" class="pcalibre calibre247 pcalibre1"/>
<figcaption id="P7000497027000000000000000045003" data-uri="chapter08.xhtml#P7000497027000000000000000045003" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045004" data-uri="chapter08.xhtml#P7000497027000000000000000045004" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">8.13 </span>Process address space.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000025326" data-uri="chapter08.xhtml#P7000497027000000000000000025326">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045005" data-uri="chapter08.xhtml#P7000497027000000000000000045005" class="pcalibre1 pcalibre calibre2">A diagram shows a stack with sections summarized below from bottom to top.</p>
<ul id="P7000497027000000000000000045006" data-uri="chapter08.xhtml#P7000497027000000000000000045006" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045007" data-uri="chapter08.xhtml#P7000497027000000000000000045007" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045008" data-uri="chapter08.xhtml#P7000497027000000000000000045008" class="pcalibre calibre3 pcalibre1">Gap from 0 to 0x400000</p></li>
<li id="P7000497027000000000000000045009" data-uri="chapter08.xhtml#P7000497027000000000000000045009" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004500A" data-uri="chapter08.xhtml#P700049702700000000000000004500A" class="pcalibre calibre3 pcalibre1">Loaded from the executable file:</p>
<ul id="P700049702700000000000000004500B" data-uri="chapter08.xhtml#P700049702700000000000000004500B" class="pcalibre calibre39 pcalibre1">
<li id="P700049702700000000000000004500C" data-uri="chapter08.xhtml#P700049702700000000000000004500C" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004500D" data-uri="chapter08.xhtml#P700049702700000000000000004500D" class="pcalibre calibre3 pcalibre1">Read-only code segment (.init, .text, .rodata)</p></li>
<li id="P700049702700000000000000004500E" data-uri="chapter08.xhtml#P700049702700000000000000004500E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004500F" data-uri="chapter08.xhtml#P700049702700000000000000004500F" class="pcalibre calibre3 pcalibre1">Read/write segment (.data, .bss)</p></li>
</ul></li>
<li id="P7000497027000000000000000045010" data-uri="chapter08.xhtml#P7000497027000000000000000045010" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045011" data-uri="chapter08.xhtml#P7000497027000000000000000045011" class="pcalibre calibre3 pcalibre1">Run-time heap (created by malloc), to brk</p></li>
<li id="P7000497027000000000000000045012" data-uri="chapter08.xhtml#P7000497027000000000000000045012" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045013" data-uri="chapter08.xhtml#P7000497027000000000000000045013" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P7000497027000000000000000045014" data-uri="chapter08.xhtml#P7000497027000000000000000045014" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045015" data-uri="chapter08.xhtml#P7000497027000000000000000045015" class="pcalibre calibre3 pcalibre1">Memory-mapped region for shared libraries</p></li>
<li id="P7000497027000000000000000045016" data-uri="chapter08.xhtml#P7000497027000000000000000045016" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045017" data-uri="chapter08.xhtml#P7000497027000000000000000045017" class="pcalibre calibre3 pcalibre1">Gap to %esp (stack pointer)</p></li>
<li id="P7000497027000000000000000045018" data-uri="chapter08.xhtml#P7000497027000000000000000045018" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045019" data-uri="chapter08.xhtml#P7000497027000000000000000045019" class="pcalibre calibre3 pcalibre1">User stack (created at run time), to 2<sup class="calibre51 pcalibre pcalibre1">48</sup> minus 1</p></li>
<li id="P700049702700000000000000004501A" data-uri="chapter08.xhtml#P700049702700000000000000004501A" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004501B" data-uri="chapter08.xhtml#P700049702700000000000000004501B" class="pcalibre calibre3 pcalibre1">Kernel virtual memory (code, data, heap, stack), to memory invisible to user code</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004501C" data-uri="chapter08.xhtml#P700049702700000000000000004501C">application can execute, as well as the portions of the address space that it can access.</p>
<p id="P700049702700000000000000004501D" data-uri="chapter08.xhtml#P700049702700000000000000004501D" class="pcalibre1 pcalibre calibre2">Processors typically provide this capability with a <i class="calibre5 pcalibre pcalibre1">mode bit</i> in some control register that characterizes the privileges that the process currently enjoys. When the mode bit is set, the process is running in <i class="calibre5 pcalibre pcalibre1">kernel mode</i> (sometimes called <i class="calibre5 pcalibre pcalibre1">supervisor mode</i>). A process running in kernel mode can execute any instruction in the instruction set and access any memory location in the system.</p>
<p id="P700049702700000000000000004501E" data-uri="chapter08.xhtml#P700049702700000000000000004501E" class="pcalibre1 pcalibre calibre2">When the mode bit is not set, the process is running in <i class="calibre5 pcalibre pcalibre1">user mode</i>. A process in user mode is not allowed to execute <i class="calibre5 pcalibre pcalibre1">privileged instructions</i> that do things such as halt the processor, change the mode bit, or initiate an I/O operation. Nor is it allowed to directly reference code or data in the kernel area of the address space. Any such attempt results in a fatal protection fault. User programs must instead access kernel code and data indirectly via the system call interface.</p>
<p id="P700049702700000000000000004501F" data-uri="chapter08.xhtml#P700049702700000000000000004501F" class="pcalibre1 pcalibre calibre2">A process running application code is initially in user mode. The only way for the process to change from user mode to kernel mode is via an exception such as an interrupt, a fault, or a trapping system call. When the exception occurs, and control passes to the exception handler, the processor changes the mode from user mode to kernel mode. The handler runs in kernel mode. When it returns to the application code, the processor changes the mode from kernel mode back to user mode.</p>
<p id="P7000497027000000000000000045020" data-uri="chapter08.xhtml#P7000497027000000000000000045020" class="pcalibre1 pcalibre calibre2">Linux provides a clever mechanism, called the <code id="P7000497027000000000000000045021" data-uri="chapter08.xhtml#P7000497027000000000000000045021" class="pcalibre1 calibre8 pcalibre">/proc</code> filesystem, that allows user mode processes to access the contents of kernel data structures. The <code id="P7000497027000000000000000045022" data-uri="chapter08.xhtml#P7000497027000000000000000045022" class="pcalibre1 calibre8 pcalibre">/proc</code> filesystem exports the contents of many kernel data structures as a hierarchy of text <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006825" title="736" data-uri="chapter08.xhtml#P7000497027000000000000000006825" epub:type="pagebreak"></span>files that can be read by user programs. For example, you can use the <code id="P7000497027000000000000000045023" data-uri="chapter08.xhtml#P7000497027000000000000000045023" class="pcalibre1 calibre8 pcalibre">/proc</code> filesystem to find out general system attributes such as CPU type (<code id="P7000497027000000000000000045024" data-uri="chapter08.xhtml#P7000497027000000000000000045024" class="pcalibre1 calibre8 pcalibre">/proc/cpuinfo</code>), or the memory segments used by a particular process (<code id="P7000497027000000000000000045025" data-uri="chapter08.xhtml#P7000497027000000000000000045025" class="pcalibre1 calibre8 pcalibre">/proc/<i class="calibre5 pcalibre pcalibre1">process-id</i>/maps</code>). The 2.6 version of the Linux kernel introduced a <code id="P7000497027000000000000000045026" data-uri="chapter08.xhtml#P7000497027000000000000000045026" class="pcalibre1 calibre8 pcalibre">/sys</code> filesystem, which exports additional low-level information about system buses and devices.</p>
</section>
<section id="P700049702700000000000000000682A" data-uri="chapter08.xhtml#P700049702700000000000000000682A" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045027" data-uri="chapter08.xhtml#P7000497027000000000000000045027" epub:type="title"><span class="pcalibre label pcalibre1">8.2.5  </span>Context Switches</h1></header>
<p id="P7000497027000000000000000045028" data-uri="chapter08.xhtml#P7000497027000000000000000045028" class="pcalibre1 pcalibre calibre2">The operating system kernel implements multitasking using a higher-level form of exceptional control flow known as a <i class="calibre5 pcalibre pcalibre1">context switch</i>. The context switch mechanism is built on top of the lower-level exception mechanism that we discussed in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000066A6.xhtml#P70004970270000000000000000066A6"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">8.1</span></a>.</p>
<p id="P7000497027000000000000000045029" data-uri="chapter08.xhtml#P7000497027000000000000000045029" class="pcalibre1 pcalibre calibre2">The kernel maintains a <i class="calibre5 pcalibre pcalibre1">context</i> for each process. The context is the state that the kernel needs to restart a preempted process. It consists of the values of objects such as the general-purpose registers, the floating-point registers, the program counter, user's stack, status registers, kernel's stack, and various kernel data structures such as a <i class="calibre5 pcalibre pcalibre1">page table</i> that characterizes the address space, a <i class="calibre5 pcalibre pcalibre1">process table</i> that contains information about the current process, and a <i class="calibre5 pcalibre pcalibre1">file table</i> that contains information about the files that the process has opened.</p>
<p id="P700049702700000000000000004502A" data-uri="chapter08.xhtml#P700049702700000000000000004502A" class="pcalibre1 pcalibre calibre2">At certain points during the execution of a process, the kernel can decide to preempt the current process and restart a previously preempted process. This decision is known as <i class="calibre5 pcalibre pcalibre1">scheduling</i> and is handled by code in the kernel, called the <i class="calibre5 pcalibre pcalibre1">scheduler</i>. When the kernel selects a new process to run, we say that the kernel has <i class="calibre5 pcalibre pcalibre1">scheduled</i> that process. After the kernel has scheduled a new process to run, it preempts the current process and transfers control to the new process using a mechanism called a <i class="calibre5 pcalibre pcalibre1">context switch</i> that (1) saves the context of the current process, (2) restores the saved context of some previously preempted process, and (3) passes control to this newly restored process.</p>
<p id="P700049702700000000000000004502B" data-uri="chapter08.xhtml#P700049702700000000000000004502B" class="pcalibre1 pcalibre calibre2">A context switch can occur while the kernel is executing a system call on behalf of the user. If the system call blocks because it is waiting for some event to occur, then the kernel can put the current process to sleep and switch to another process. For example, if a <code id="P700049702700000000000000004502C" data-uri="chapter08.xhtml#P700049702700000000000000004502C" class="pcalibre1 calibre8 pcalibre">read</code> system call requires a disk access, the kernel can opt to perform a context switch and run another process instead of waiting for the data to arrive from the disk. Another example is the <code id="P700049702700000000000000004502D" data-uri="chapter08.xhtml#P700049702700000000000000004502D" class="pcalibre1 calibre8 pcalibre">sleep</code> system call, which is an explicit request to put the calling process to sleep. In general, even if a system call does not block, the kernel can decide to perform a context switch rather than return control to the calling process.</p>
<p id="P700049702700000000000000004502E" data-uri="chapter08.xhtml#P700049702700000000000000004502E" class="pcalibre1 pcalibre calibre2">A context switch can also occur as a result of an interrupt. For example, all systems have some mechanism for generating periodic timer interrupts, typically every 1 ms or 10 ms. Each time a timer interrupt occurs, the kernel can decide that the current process has run long enough and switch to a new process.</p>
<p id="P700049702700000000000000004502F" data-uri="chapter08.xhtml#P700049702700000000000000004502F" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006819"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.13 </span></a>shows an example of context switching between a pair of processes A and B. In this example, initially process A is running in user mode until it traps to the kernel by executing a <code id="P7000497027000000000000000045030" data-uri="chapter08.xhtml#P7000497027000000000000000045030" class="pcalibre1 calibre8 pcalibre">read</code> system call. The trap handler in the kernel requests a DMA transfer from the disk controller and arranges for the disk to interrupt the</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000006835" data-uri="chapter08.xhtml#P7000497027000000000000000006835">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006836" title="737" data-uri="chapter08.xhtml#P7000497027000000000000000006836" epub:type="pagebreak"></span><img alt="A diagram illustrates a process context switch." id="P7000497027000000000000000045031" data-uri="P700049702700000000000000000B76A" src="../images/p737-1.png" class="calibre248 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045032" data-uri="chapter08.xhtml#P7000497027000000000000000045032" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045033" data-uri="chapter08.xhtml#P7000497027000000000000000045033" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">8.14 </span>Anatomy of a process context switch.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000025356" data-uri="chapter08.xhtml#P7000497027000000000000000025356">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045034" data-uri="chapter08.xhtml#P7000497027000000000000000045034" class="pcalibre calibre3 pcalibre1">A diagram shows a flow of steps over time, moving between Process A and Process B. The flow extends through user code in Process A to read, and then moves through kernel code (context switch), switching from Process A to Process B. In Process B, the flow moves through user code to disk interrupt, and then through kernel code (context switch) from Process B to Process A, to Return from read, before moving through user code in Process A.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045035" data-uri="chapter08.xhtml#P7000497027000000000000000045035">processor after the disk controller has finished transferring the data from disk to memory.</p>
<p id="P7000497027000000000000000045036" data-uri="chapter08.xhtml#P7000497027000000000000000045036" class="pcalibre1 pcalibre calibre2">The disk will take a relatively long time to fetch the data (on the order of tens of milliseconds), so instead of waiting and doing nothing in the interim, the kernel performs a context switch from process A to B. Note that, before the switch, the kernel is executing instructions in user mode on behalf of process A (i.e., there is no separate kernel process). During the first part of the switch, the kernel is executing instructions in kernel mode on behalf of process A. Then at some point it begins executing instructions (still in kernel mode) on behalf of process B. And after the switch, the kernel is executing instructions in user mode on behalf of process B.</p>
<p id="P7000497027000000000000000045037" data-uri="chapter08.xhtml#P7000497027000000000000000045037" class="pcalibre1 pcalibre calibre2">Process B then runs for a while in user mode until the disk sends an interrupt to signal that data have been transferred from disk to memory. The kernel decides that process B has run long enough and performs a context switch from process B to A, returning control in process A to the instruction immediately following the <code id="P7000497027000000000000000045038" data-uri="chapter08.xhtml#P7000497027000000000000000045038" class="pcalibre1 calibre8 pcalibre">read</code> system call. Process A continues to run until the next exception occurs, and so on.</p>
</section>
</section></body></html>
