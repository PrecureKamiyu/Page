<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>16.4  Choice of Evaluation Plans</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part298.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part300.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">16.4  <span style=" color: #00AEEF;">Choice of Evaluation Plans</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Generation of expressions is only part of the query-optimization process, since each operation in the expression can be implemented with diﬀerent algorithms. An evalua- tion plan deﬁnes exactly what algorithm should be used for each operation, and how the execution of the operations should be coordinated.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Given an evaluation plan, we can estimate its cost using statistics estimated by the techniques in Section 16.3 coupled with cost estimates for various algorithms and evaluation methods described in Chapter 15.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A <span class="s63">cost-based optimizer </span>explores the space of all query-evaluation plans that are equivalent to the given query, and chooses the one with the least estimated cost. We have seen how equivalence rules can be used to generate equivalent plans. However, cost-based optimization with arbitrary equivalence rules is fairly complicated. We ﬁrst cover a simpler version of cost-based optimization, which involves only join-order and join algorithm selection, in Section 16.4.1. Then, in Section 16.4.2, we brieﬂy sketch how a general-purpose optimizer based on equivalence rules can be built, without going into details.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Exploring the space of all possible plans may be too expensive for complex queries. Most optimizers include heuristics to reduce the cost of query optimization, at the potential risk of not ﬁnding the optimal plan. We study some such heuristics in Section 16.4.3.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">16.4.1 Cost-Based Join-Order Selection</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The most common type of query in <span class="s44">SQL </span>consists of a join of a few relations, with join predicates and selections speciﬁed in the <b>where </b>clause. In this section we consider the problem of choosing the optimal join order for such a query.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For a complex join query, the number of diﬀerent query plans that are equivalent to the query can be large. As an illustration, consider the expression:</p><p class="s13" style="padding-top: 10pt;padding-left: 84pt;text-indent: 0pt;text-align: center;">r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2 </span><span class="s86">⋈⋯⋈ </span>r<span class="s97">n</span></p><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">where the joins are expressed without any ordering. With <i>n </i><span class="s15">= </span>3, there are 12 diﬀerent join orderings:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:140.24pt" cellspacing="0"><tr style="height:14pt"><td style="width:75pt"><p class="s71" style="padding-left: 2pt;text-indent: 0pt;line-height: 13pt;text-align: left;">r<span class="s233">1 </span><span class="s414">⋈ </span><span class="s72">(</span>r<span class="s233">2 </span><span class="s414">⋈ </span>r<span class="s233">3</span><span class="s415">)</span></p></td><td style="width:83pt"><p class="s71" style="padding-left: 6pt;padding-right: 6pt;text-indent: 0pt;line-height: 13pt;text-align: center;">r<span class="s233">1 </span><span class="s414">⋈ </span><span class="s72">(</span>r<span class="s233">3 </span><span class="s414">⋈ </span>r<span class="s233">2</span><span class="s415">)</span></p></td><td style="width:83pt"><p class="s71" style="padding-left: 10pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s72">(</span>r<span class="s233">2 </span><span class="s414">⋈ </span>r<span class="s233">3</span><span class="s415">) </span><span class="s414">⋈ </span>r<span class="s233">1</span></p></td><td style="width:75pt"><p class="s71" style="padding-right: 2pt;text-indent: 0pt;line-height: 13pt;text-align: right;"><span class="s72">(</span>r<span class="s233">3 </span><span class="s414">⋈ </span>r<span class="s233">2</span><span class="s415">) </span><span class="s414">⋈ </span>r<span class="s233">1</span></p></td></tr><tr style="height:13pt"><td style="width:75pt"><p class="s71" style="padding-left: 2pt;text-indent: 0pt;line-height: 12pt;text-align: left;">r<span class="s232">2 </span><span class="s414">⋈ </span><span class="s72">(</span>r<span class="s232">1 </span><span class="s414">⋈ </span>r<span class="s232">3</span><span class="s415">)</span></p></td><td style="width:83pt"><p class="s71" style="padding-left: 6pt;padding-right: 6pt;text-indent: 0pt;line-height: 12pt;text-align: center;">r<span class="s232">2 </span><span class="s414">⋈ </span><span class="s72">(</span>r<span class="s232">3 </span><span class="s414">⋈ </span>r<span class="s232">1</span><span class="s415">)</span></p></td><td style="width:83pt"><p class="s71" style="padding-left: 10pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s72">(</span>r<span class="s232">1 </span><span class="s414">⋈ </span>r<span class="s232">3</span><span class="s415">) </span><span class="s414">⋈ </span>r<span class="s232">2</span></p></td><td style="width:75pt"><p class="s71" style="padding-right: 2pt;text-indent: 0pt;line-height: 12pt;text-align: right;"><span class="s72">(</span>r<span class="s232">3 </span><span class="s414">⋈ </span>r<span class="s232">1</span><span class="s415">) </span><span class="s414">⋈ </span>r<span class="s232">2</span></p></td></tr><tr style="height:14pt"><td style="width:75pt"><p class="s71" style="padding-left: 2pt;text-indent: 0pt;line-height: 13pt;text-align: left;">r<span class="s232">3 </span><span class="s414">⋈ </span><span class="s72">(</span>r<span class="s232">1 </span><span class="s414">⋈ </span>r<span class="s232">2</span><span class="s415">)</span></p></td><td style="width:83pt"><p class="s71" style="padding-left: 6pt;padding-right: 6pt;text-indent: 0pt;line-height: 13pt;text-align: center;">r<span class="s232">3 </span><span class="s414">⋈ </span><span class="s72">(</span>r<span class="s232">2 </span><span class="s414">⋈ </span>r<span class="s232">1</span><span class="s415">)</span></p></td><td style="width:83pt"><p class="s71" style="padding-left: 10pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s72">(</span>r<span class="s232">1 </span><span class="s414">⋈ </span>r<span class="s232">2</span><span class="s415">) </span><span class="s414">⋈ </span>r<span class="s232">3</span></p></td><td style="width:75pt"><p class="s71" style="padding-right: 2pt;text-indent: 0pt;line-height: 13pt;text-align: right;"><span class="s72">(</span>r<span class="s232">2 </span><span class="s414">⋈ </span>r<span class="s232">1</span><span class="s415">) </span><span class="s414">⋈ </span>r<span class="s232">3</span></p></td></tr></table><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">In general, with <i>n </i>relations, there are (2(<i>n </i><span class="s15">− </span>1))<span class="s15">!∕</span>(<i>n </i><span class="s15">− </span>1)<span class="s15">! </span>diﬀerent join orders. (We leave the computation of this expression for you to do in Exercise 16.12.) For joins involving small numbers of relations, this number is acceptable; for example, with <i>n </i><span class="s15">= </span>5, the number is 1680. However, as <i>n </i>increases, this number rises quickly. With</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 16pt;text-align: justify;"><i>n </i><span class="s15">= </span>7, the number is 665,280; with <i>n </i><span class="s15">= </span>10, the number is greater than 17<span class="s83">.</span>6 billion!</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Luckily, it is not necessary to generate all the expressions equivalent to a given</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">expression. For example, suppose we want to ﬁnd the best join order of the form:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><span class="p">(</span>r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2 </span><span class="s86">⋈ </span>r<span class="s130">3</span><span class="s94">) </span><span class="s86">⋈ </span>r<span class="s130">4 </span><span class="s86">⋈ </span>r<span class="s130">5</span></p><p class="s13" style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;line-height: 92%;text-align: justify;"><span class="p">which represents all join orders where </span>r<span class="s98">1</span><span class="p">, </span>r<span class="s98">2</span><span class="p">, and </span>r<span class="s98">3</span><span class="p"> are joined ﬁrst (in some order), and the result is joined (in some order) with </span>r<span class="s98">4</span><span class="p"> and </span>r<span class="s98">5</span><span class="p">. There are 12 diﬀerent join orders for computing </span>r<span class="s98">1</span><span class="p"> </span><span class="s86">⋈ </span>r<span class="s98">2</span><span class="p"> </span><span class="s86">⋈ </span>r<span class="s98">3</span><span class="p">, and 12 orders for computing the join of this result with </span>r<span class="s98">4</span><span class="p"> and </span>r<span class="s98">5</span><span class="p">. Thus, there appear to be 144 join orders to examine. However, once we have found the best join order for the subset of relations </span><span class="s15">{</span>r<span class="s98">1</span><span class="p">, </span>r<span class="s98">2</span><span class="p">, </span>r<span class="s98">3</span><span class="s15">}</span><span class="p">, we can use that order for further joins with </span>r<span class="s130">4 </span><span class="s94">and </span>r<span class="s130">5</span><span class="s94">, and we can ignore all costlier join orders of </span>r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2 </span><span class="s86">⋈ </span>r<span class="s130">3</span><span class="s94">. Thus, instead of 144 choices to examine, we need to examine only 12 + 12 choices.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Using this idea, we can develop a <i>dynamic-programming </i>algorithm for ﬁnding opti- mal join orders. Dynamic-programming algorithms store results of computations and reuse them, a procedure that can reduce execution time greatly.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">We now consider how to ﬁnd the optimal join order for a set of <i>n </i>relations <i>S </i><span class="s15">=</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 87%;text-align: justify;"><span class="s15">{</span><i>r</i><span class="s98">1</span>, <i>r</i><span class="s98">2</span>, <span class="s15">… </span>, <i>r</i><span class="s97">n</span><span class="s15">}</span>, where each relation may have selection conditions, and a set of join conditions between the relations <i>r</i><span class="s97">i </span>is provided. We assume that relations have unique names.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A recursive procedure implementing the dynamic-programming algorithm appears in Figure 16.7 and is invoked as FindBestPlan(<i>S</i>), where <i>S </i>is the set of relations above. The procedure applies selections on individual relations at the earliest possible point,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2931.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 90pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><b>procedure </b>FindBestPlan(<i>S</i>)</p><p style="padding-left: 111pt;text-indent: 0pt;line-height: 17pt;text-align: left;"><b>if </b>(<i>bestplan</i>[<i>S</i>]<span class="s83">.</span><i>cost </i><span class="s86">≠ </span><span class="s15">∞</span>) /* <i>bestplan</i>[<i>S</i>] already computed */</p><p class="s13" style="padding-left: 133pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><b>return </b>bestplan<span class="p">[</span>S<span class="p">]</span></p><p style="padding-left: 111pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><b>if </b>(<i>S </i>contains only 1 relation)</p><p style="padding-top: 2pt;padding-left: 154pt;text-indent: -21pt;line-height: 70%;text-align: left;">set <i>bestplan</i>[<i>S</i>]<span class="s83">.</span><i>plan </i>and <i>bestplan</i>[<i>S</i>]<span class="s83">.</span><i>cost </i>based on the best way of accessing <i>S </i>using selection conditions (if any) on <i>S</i>.</p><p style="padding-left: 111pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><b>else for each </b>non-empty subset <i>S</i>1 of <i>S </i>such that <i>S</i>1 <span class="s86">≠ </span><i>S</i></p><p style="padding-left: 133pt;text-indent: 0pt;line-height: 12pt;text-align: left;">P1 = FindBestPlan(<i>S</i>1)</p><p class="s13" style="padding-left: 133pt;text-indent: 0pt;text-align: left;"><span class="p">P2 = FindBestPlan(</span>S <span class="s15">− </span>S<span class="p">1)</span></p><p style="padding-left: 133pt;text-indent: 0pt;text-align: left;"><b>for each </b>algorithm <i>A </i>for joining the results of <i>P</i>1 and <i>P</i>2</p><p style="padding-left: 154pt;text-indent: 0pt;text-align: left;">// For indexed-nested loops join, the outer relation could be <i>P</i>1 or <i>P</i>2.</p><p style="padding-left: 154pt;text-indent: 0pt;text-align: left;">// Similarly for hash-join, the build relation could be <i>P</i>1 or <i>P</i>2.</p><p style="padding-left: 154pt;text-indent: 0pt;text-align: left;">// We assume the alternatives are considered as separate algorithms.</p><p style="padding-left: 154pt;text-indent: 0pt;text-align: left;">// We assume cost of <i>A </i>does not include cost of reading the inputs.</p><p style="padding-left: 154pt;text-indent: 0pt;text-align: left;"><b>if </b>algorithm <i>A </i>is indexed nested loops</p><p style="padding-left: 175pt;text-indent: 0pt;line-height: 14pt;text-align: left;">Let <i>P</i><span class="s145">o </span>and <i>P</i><span class="s145">i </span>denote the outer and inner inputs of <i>A</i></p><p class="s13" style="padding-left: 218pt;text-indent: -42pt;line-height: 90%;text-align: left;"><b>if </b>P<span class="s145">i </span><span class="p">has a single relation </span>r<span class="s145">i</span><span class="p">, and </span>r<span class="s145">i </span><span class="p">has an index on the join attributes</span></p><p class="s13" style="padding-left: 239pt;text-indent: -42pt;line-height: 78%;text-align: left;"><span class="p">plan = “execute </span>P<span class="s97">o</span><span class="s83">.</span>plan<span class="p">; join results of </span>P<span class="s97">o </span><span class="p">and </span>r<span class="s97">i </span><span class="p">using </span>A<span class="p">”, with any selection condition on </span>P<span class="s97">i </span><span class="p">performed as part of the join condition</span></p><p class="s13" style="padding-left: 197pt;text-indent: 0pt;line-height: 16pt;text-align: left;"><span class="p">cost = </span>P<span class="s145">o</span><span class="s83">.</span>cost <span class="p">+ cost of </span>A</p><p class="s46" style="padding-left: 175pt;text-indent: 0pt;line-height: 10pt;text-align: left;">else <span class="p">/* Cannot use indexed nested loops join */</span></p><p style="padding-left: 197pt;text-indent: 0pt;text-align: left;">cost = <span class="s15">∞</span></p><p class="s46" style="padding-left: 154pt;text-indent: 0pt;line-height: 11pt;text-align: left;">else</p><p style="padding-left: 175pt;text-indent: 0pt;line-height: 17pt;text-align: left;">plan = “execute <i>P</i>1<span class="s83">.</span><i>plan</i>; execute <i>P</i>2<span class="s83">.</span><i>plan</i>;</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 9pt;text-align: center;">join results of <i>P</i>1 and <i>P</i>2 using <i>A</i>”</p><p style="padding-left: 175pt;text-indent: 0pt;line-height: 15pt;text-align: left;">cost = <i>P</i>1<span class="s83">.</span><i>cost </i>+ <i>P</i>2<span class="s83">.</span><i>cost </i>+ cost of <i>A</i></p><p style="padding-top: 1pt;padding-left: 175pt;text-indent: -21pt;line-height: 61%;text-align: left;"><b>if </b>cost <span class="s83">&lt; </span><i>bestplan</i>[<i>S</i>]<span class="s83">.</span><i>cost bestplan</i>[<i>S</i>]<span class="s83">.</span><i>cost </i>= cost <i>bestplan</i>[<i>S</i>]<span class="s83">.</span><i>plan </i>= plan</p><p class="s13" style="padding-left: 111pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><b>return </b>bestplan<span class="p">[</span>S<span class="p">]</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2932.png"/></span></p><p class="s73" style="padding-top: 8pt;padding-left: 112pt;text-indent: 0pt;text-align: left;">Figure 16.7 <span class="s74">Dynamic-programming algorithm for join-order optimization.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 8pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">that is, when the relations are accessed. It is easiest to understand the procedure as- suming that all joins are natural joins, although the procedure works unchanged with any join condition. With arbitrary join conditions, the join of two subexpressions is understood to include all join conditions that relate attributes from the two subexpres- sions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The procedure stores the evaluation plans it computes in an associative array <i>bestplan</i>, which is indexed by sets of relations. Each element of the associative array contains two components: the cost of the best plan of <i>S</i>, and the plan itself. The value</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 70%;text-align: justify;">of <i>bestplan</i>[<i>S</i>]<span class="s83">.</span><i>cost </i>is assumed to be initialized to <span class="s15">∞ </span>if <i>bestplan</i>[<i>S</i>] has not yet been computed.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The procedure ﬁrst checks if the best plan for computing the join of the given set of relations <i>S </i>has been computed already (and stored in the associative array <i>bestplan</i>); if so, it returns the already computed plan.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If <i>S </i>contains only one relation, the best way of accessing <i>S </i>(taking selections on <i>S</i>, if any, into account) is recorded in <i>bestplan</i>. This may involve using an index to identify tuples, and then fetching the tuples (often referred to as an <i>index scan</i>), or scanning the entire relation (often referred to as a <i>relation scan</i>).<span class="s76">2</span> If there is any selection condition on <i>S</i>, other than those ensured by an index scan, a selection operation is added to the plan to ensure all selections on <i>S </i>are satisﬁed.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Otherwise, if <i>S </i>contains more than one relation, the procedure tries every way of dividing <i>S </i>into two disjoint subsets. For each division, the procedure recursively ﬁnds the best plans for each of the two subsets. It then considers all possible algorithms for joining the results of the two subsets. Note that since indexed nested loops join can potentially use either input <i>P</i>1 or <i>P</i>2 as the inner input, we consider the two alternatives as two diﬀerent algorithms. The choice of build versus probe input also leads us to consider the two choices for hash join as two diﬀerent algorithms.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The cost of each alternative is considered, and the least cost option chosen. The join cost considered should not include the cost of reading the inputs, since we as- sume that the input is pipelined from the preceding operators, which could be a rela- tion/index scan, or a preceding join. Recall that some operators, such as hash join, can be treated as having suboperators with a blocking (materialized) edge between them, but with the input and output edges of the join being pipelined. The join cost formulae that we saw in Chapter 15 can be used with appropriate modiﬁcations to ignore the cost of reading the input relations. Note that indexed nested loops join is treated diﬀer- ently from other join techniques: the plan as well as the cost are diﬀerent in this case, since we do not perform a relation/index scan of the inner input, and the index lookup cost is included in the cost of indexed nested loops join.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The procedure picks the cheapest plan from among all the alternatives for dividing <i>S </i>into two sets and the algorithms for joining the results of the two sets. The cheapest plan and its cost are stored in the array <i>bestplan </i>and returned by the procedure. The time complexity of the procedure can be shown to be <i>O</i>(3<i>n</i>) (see Practice Exercise 16.13).</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The order in which tuples are generated by the join of a set of relations is important for ﬁnding the best overall join order, since it can aﬀect the cost of further joins. For</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_2933.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">2<span class="s78">If an index contains all the attributes of a relation that are used in a query, it is possible to perform an </span><span class="s111">index-only scan</span><span class="s80">, which retrieves the required attribute values from the index, without fetching actual tuples.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">instance, if merge join is used, a potentially expensive sort operation is required on the input, unless the input is already sorted on the join attribute.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 92%;text-align: justify;">A particular sort order of the tuples is said to be an <span class="s63">interesting sort order </span>if it could be useful for a later operation. For instance, generating the result of <i>r</i><span class="s98">1</span> <span class="s86">⋈ </span><i>r</i><span class="s98">2</span> <span class="s86">⋈ </span><i>r</i><span class="s98">3</span> sorted on the attributes common with <i>r</i><span class="s98">4</span> or <i>r</i><span class="s98">5</span> may be useful, but generating it sorted on the attributes common to only <i>r</i><span class="s98">1</span> and <i>r</i><span class="s98">2</span> is not useful. Using merge join for computing <i>r</i><span class="s98">1</span> <span class="s86">⋈ </span><i>r</i><span class="s98">2</span> <span class="s86">⋈ </span><i>r</i><span class="s98">3</span> may be costlier than using some other join technique, but it may provide</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">an output sorted in an interesting sort order.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Hence, it is not suﬃcient to ﬁnd the best join order for each subset of the set of <i>n </i>given relations. Instead, we have to ﬁnd the best join order for each subset, for each interesting sort order of the join result for that subset. The <i>bestplan </i>array can now be indexed by [<i>S</i>, <i>o</i>], where <i>S </i>is a set of relations, and <i>o </i>is an interesting sort order. The FindBestPlan function can then be modiﬁed to take interesting sort orders into consideration; we leave details as an exercise for you (see Practice Exercise 16.11).</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The number of subsets of <i>n </i>relations is 2<i>n</i>. The number of interesting sort orders is generally not large. Thus, about 2<i>n</i><i> </i>join expressions need to be stored. The dynamic- programming algorithm for ﬁnding the best join order can be extended to handle sort orders. Speciﬁcally, when considering sort-merge join, the cost of sorting has to be added if an input (which may be a relation, or the result of a join operation) is not sorted on the join attribute, but is not added if it is sorted.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The cost of the extended algorithm depends on the number of interesting orders for each subset of relations; since this number has been found to be small in practice, the cost remains at <i>O</i>(3<i>n</i>). With <i>n </i><span class="s15">= </span>10, this number is around 59,000, which is much</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 70%;text-align: justify;">better than the 17<span class="s83">.</span>6 billion diﬀerent join orders. More important, the storage required is much less than before, since we need to store only one join order for each interesting</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">sort order of each of 1024 subsets of <i>r</i><span class="s98">1</span>, <span class="s15">… </span>, <i>r</i><span class="s98">10</span>. Although both numbers still increase rapidly with <i>n</i>, commonly occurring joins usually have less than 10 relations and can be handled easily.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The code shown in Figure 16.7 actually considers each possible way of dividing <i>S </i>into two disjoint subsets twice, since each of the two subsets can play the role of <i>S</i>1. Considering the division twice does not aﬀect correctness, but wastes time. The code can be optimized as follows: ﬁnd the alphabetically smallest relation <i>r</i><span class="s97">i </span>in <i>S</i>1, and the</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="p">alphabetically smallest relation </span>r<span class="s97">j </span><span class="p">in </span>S <span class="s15">− </span>S<span class="p">1, and execute the loop only if </span>r<span class="s97">i </span><span class="s83">&lt; </span>r<span class="s97">j </span><span class="p">. Doing</span></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">so ensures that each division is considered only once.</p><p class="s13" style="padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="p">Further, the code also considers all possible join orders, including those that con- tain Cartesian products; for example, if two relations </span>r<span class="s98">1</span><span class="p"> and </span>r<span class="s98">3</span><span class="p"> do not have any join condition linking the two relations, the code will still consider </span>S <span class="s15">= {</span>r<span class="s98">1</span><span class="p">, </span>r<span class="s98">3</span><span class="s15">}</span><span class="p">, which will result in a Cartesian product. It is possible to take join conditions into account, and modify the code to only generate divisions that do not result in Cartesian products. This optimization can save a great deal of time for many queries. See the Further Reading section at the end of the chapter for references providing more details on Cartesian- product-free join order enumeration.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">16.4.2 Cost-Based Optimization with Equivalence Rules</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The join-order optimization technique we just saw handles the most common class of queries, which perform an inner join of a set of relations. However, many queries use other features, such as aggregation, outer join, and nested queries, which are not addressed by join-order selection, but can be handled by using equivalence rules.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In this section we outline how to create a general-purpose cost-based optimizer based on equivalence rules. Equivalence rules can help explore alternatives with a wide variety of operations, such as outer joins, aggregations, and set operations, as we have seen earlier. Equivalence rules can be added if required for further operations, such as operators that return the top-K results in sorted order.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">In Section 16.2.4, we saw how an optimizer could systematically generate all ex- pressions equivalent to the given query. The procedure for generating equivalent expres- sions can be modiﬁed to generate all possible evaluation plans as follows: A new class of equivalence rules, called <span class="s63">physical equivalence rules</span>, is added that allows a logical op- eration, such as a join, to be transformed to a physical operation, such as a hash join, or a nested-loops join. By adding such rules to the original set of equivalence rules, the procedure can generate all possible evaluation plans. The cost estimation techniques we have seen earlier can then be used to choose the optimal (i.e., the least-cost) plan.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">However, the procedure shown in Section 16.2.4 is very expensive, even if we do not consider generation of evaluation plans. To make the approach work eﬃciently requires the following:</p><p class="s63" style="padding-top: 9pt;padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span class="p">A space-eﬃcient representation of expressions that avoids making multiple copies of the same subexpressions when equivalence rules are applied.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 128pt;text-indent: 0pt;text-align: justify;">2. <span class="p">E ﬃcient techniques for detecting duplicate derivations of the same expression.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">3. <span class="p">A form of dynamic programming based on </span>memoization<span class="p">, which stores the optimal query evaluation plan for a subexpression when it is optimized for the ﬁrst time; subsequent requests to optimize the same subexpression are handled by returning the already memorized plan.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">4. <span class="p">Techniques that avoid generating all possible equivalent plans by keeping track of the cheapest plan generated for any subexpression up to any point of time, and pruning away any plan that is more expensive than the cheapest plan found so far for that subexpression.</span></p><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The details are more complex than we wish to deal with here. This approach was pi- oneered by the Volcano research project, and the query optimizer of <span class="s44">SQL S</span>erver is based on this approach. See the bibliographical notes for references containing further information.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">16.4.3 Heuristics in Optimization</p><p style="padding-top: 6pt;padding-left: 121pt;text-indent: 0pt;text-align: right;">A drawback of cost-based optimization is the cost of optimization itself. Although the cost of query optimization can be reduced by clever algorithms, the number of diﬀerent</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">evaluation plans for a query can be very large, and ﬁnding the optimal plan from this set requires a lot of computational eﬀort. Hence, optimizers use <span class="s63">heuristics </span>to reduce the cost of optimization.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">An example of a heuristic rule is the following rule for transforming relational- algebra queries:</p><p class="s39" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">Perform selection operations as early as possible.</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">A heuristic optimizer would use this rule without ﬁnding out whether the cost is re- duced by this transformation. In the ﬁrst transformation example in Section 16.2, the selection operation was pushed into a join.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We say that the preceding rule is a heuristic because it usually, but not always, helps to reduce the cost. For an example of where it can result in an increase in cost, consider an expression <span class="s15">σ</span><span class="s137">θ</span>(<i>r </i><span class="s86">⋈ </span><i>s</i>), where the condition <span class="s15">θ </span>refers to only attributes in</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">s<span class="p">. The selection can certainly be performed before the join. However, if </span>r <span class="p">is extremely</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">small compared to <i>s</i>, and if there is an index on the join attributes of <i>s</i>, but no index on the attributes used by <span class="s15">θ</span>, then it is probably a bad idea to perform the selection early. Performing the selection early— that is, directly on <i>s </i>— would require doing a scan of all tuples in <i>s</i>. It is probably cheaper, in this case, to compute the join by using the index and then to reject tuples that fail the selection. (This case is speciﬁcally handled by the dynamic programming algorithm for join order optimization.)</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The projection operation, like the selection operation, reduces the size of relations. Thus, whenever we need to generate a temporary relation, it is advantageous to apply immediately any projections that are possible. This advantage suggests a companion to the “perform selections early” heuristic:</p><p class="s39" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">Perform projections early.</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">It is usually better to perform selections earlier than projections, since selections have the potential to reduce the sizes of relations greatly, and selections enable the use of indices to access tuples. An example similar to the one used for the selection heuristic should convince you that this heuristic does not always reduce the cost.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Optimizers based on join-order enumeration typically use heuristic transforma- tions to handle constructs other than joins, and applying the cost-based join-order selection algorithm to subexpressions involving only joins and selections. Details of such heuristics are for the most part speciﬁc to individual optimizers, and we do not cover them.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Most practical query optimizers have further heuristics to reduce the cost of opti- mization. For example, many query optimizers, such as the System R optimizer,<span class="s76">3</span> do not consider all join orders, but rather restrict the search to particular kinds of join or-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_2934.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s77">3</span>System R was one of the ﬁrst implementations of <span class="s153">SQL</span>, and its optimizer pioneered the idea of cost-based join-order optimization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="153" height="89" alt="image" src="Image_2935.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="25" height="22" alt="image" src="Image_2936.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="61" alt="image" src="Image_2937.png"/></span></p><p class="s69" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">r3</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 136pt;text-indent: 0pt;text-align: left;">r1     r2</p><p class="s69" style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">r3</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="25" height="22" alt="image" src="Image_2938.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="61" alt="image" src="Image_2939.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="120" height="112" alt="image" src="Image_2940.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="25" height="22" alt="image" src="Image_2941.png"/></span></p><p class="s69" style="text-indent: 0pt;line-height: 11pt;text-align: left;">r5</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="text-indent: 0pt;line-height: 11pt;text-align: left;">r4</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 75pt;text-indent: 0pt;text-align: left;">r1     r2</p><p class="s69" style="padding-top: 4pt;padding-left: 20pt;text-indent: 0pt;text-align: left;">r4     r5</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s42" style="padding-top: 4pt;padding-left: 152pt;text-indent: 0pt;text-align: left;">(a) Left-deep join tree          (b) Non-left-deep join tree</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 233pt;text-indent: 0pt;text-align: left;">Figure 16.8 <span class="s74">Left-deep join trees.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 93%;text-align: justify;">ders. The System R optimizer considers only those join orders where the right operand of each join is one of the initial relations <i>r</i><span class="s98">1</span>, <span class="s15">… </span>, <i>r</i><span class="s97">n</span>. Such join orders are called <span class="s63">left-deep join orders</span>. Left-deep join orders are particularly convenient for pipelined evaluation,</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">since the right operand is a stored relation, and thus only one input to each join is pipelined.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Figure 16.8 illustrates the diﬀerence between left-deep join trees and non-left-deep join trees. The time it takes to consider all left-deep join orders is <i>O</i>(<i>n</i><span class="s15">!</span>), which is much less than the time to consider all join orders. With the use of dynamic-programming optimizations, the System R optimizer can ﬁnd the best join order in time <i>O</i>(<i>n</i>2<i>n</i>). Contrast this cost with the <i>O</i>(3<i>n</i>) time required to ﬁnd the best overall join order. The System R optimizer uses heuristics to push selections and projections down the query tree.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A heuristic approach to reduce the cost of join-order selection, which was originally used in some versions of Oracle, works roughly this way: For an <i>n</i>-way join, it considers <i>n </i>evaluation plans. Each plan uses a left-deep join order, starting with a diﬀerent one of the <i>n </i>relations. The heuristic constructs the join order for each of the <i>n </i>evaluation plans by repeatedly selecting the “best” relation to join next, on the basis of a ranking of the available access paths. Either nested-loop or sort-merge join is chosen for each of the joins, depending on the available access paths. Finally, the heuristic chooses one of the <i>n </i>evaluation plans in a heuristic manner, on the basis of minimizing the number of nested-loop joins that do not have an index available on the inner relation and on the number of sort-merge joins.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Query-optimization approaches that apply heuristic plan choices for some parts of the query, with cost-based choice based on generation of alternative access plans on other parts of the query, have been adopted in several systems. The approach used in System R and in its successor, the Starburst project, is a hierarchical procedure based on the nested-block concept of <span class="s44">SQL</span>. The cost-based optimization techniques described here are used for each block of the query separately. The optimizers in several</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">database products, such as <span class="s44">IBM DB2 </span>and Oracle, are based on the above approach, with extensions to handle other operations such as aggregation. For compound <span class="s44">SQL </span>queries (using the <span class="s15">∪</span>, <span class="s15">∩</span>, or <span class="s15">− </span>operation), the optimizer processes each component separately and combines the evaluation plans to form the overall evaluation plan.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Most optimizers allow a cost budget to be speciﬁed for query optimization. The search for the optimal plan is terminated when the <span class="s63">optimization cost budget </span>is exceeded, and the best plan found up to that point is returned. The budget itself may be set dynam- ically; for example, if a cheap plan is found for a query, the budget may be reduced, on the premise that there is no point spending a lot of time optimizing the query if the best plan found so far is already quite cheap. On the other hand, if the best plan found so far is expensive, it makes sense to invest more time in optimization, which could result in a signiﬁcant reduction in execution time. To best exploit this idea, optimizers usually ﬁrst apply cheap heuristics to ﬁnd a plan and then start full cost-based optimization with a budget based on the heuristically chosen plan.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Many applications execute the same query repeatedly, but with diﬀerent values for the constants. For example, a university application may repeatedly execute a query to ﬁnd the courses for which a student has registered, but each time for a diﬀerent student with a diﬀerent value for the student <span class="s44">ID</span>. As a heuristic, many optimizers optimize a query once, with whatever values were provided for the constants when the query was ﬁrst submitted, and cache the query plan. Whenever the query is executed again, perhaps with new values for constants, the cached query plan is reused (using new values for the constants). The optimal plan for the new constants may diﬀer from the optimal plan for the initial values, but as a heuristic the cached plan is reused.<span class="s76">4</span> Caching and reuse of query plans is referred to as <span class="s63">plan caching</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Even with the use of heuristics, cost-based query optimization imposes a substan- tial overhead on query processing. However, the added cost of cost-based query op- timization is usually more than oﬀset by the saving at query-execution time, which is dominated by slow disk accesses. The diﬀerence in execution time between a good plan and a bad one may be huge, making query optimization essential. The achieved saving is magniﬁed in those applications that run on a regular basis, where a query can be op- timized once, and the selected query plan can be used each time the query is executed. Therefore, most commercial systems include relatively sophisticated optimizers. The bibliographical notes give references to descriptions of the query optimizers of actual database systems.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">16.4.4 Optimizing Nested Subqueries</p><p class="s42" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">SQL <span class="s43">conceptually treats nested subqueries in the </span><span class="s46">where </span><span class="p">clause as functions that take parameters and return either a single value or a set of values (possibly an empty set). The parameters are the variables from an outer-level query that are used in the nested</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2942.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s77">4</span>For the student registration query, the plan would almost certainly be the same for any student <span class="s153">ID</span>. But a query that took a range of student <span class="s153">ID</span>s, and returned registration information for all student <span class="s153">ID</span>s in that range, would probably have a diﬀerent optimal plan if the range were very small than if the range were large.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">subquery (these variables are called <span class="s63">correlation variables</span>). For instance, suppose we have the following query, to ﬁnd the names of all instructors who taught a course in 2019:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 209pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 209pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 209pt;text-indent: 0pt;text-align: left;">where exists <span class="p">(</span>select <span class="p">*</span></p><p class="s46" style="padding-left: 267pt;text-indent: 0pt;text-align: left;">from <i>teaches</i></p><p class="s13" style="padding-left: 267pt;text-indent: 0pt;text-align: left;"><b>where </b>instructor<span class="p">.</span><span class="s69">ID </span><span class="s15">= </span>teaches<span class="p">.</span><span class="s69">ID</span></p><p class="s13" style="padding-left: 295pt;text-indent: 0pt;text-align: left;"><b>and </b>teaches<span class="p">.</span>year <span class="s15">= </span><span class="p">2019);</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Conceptually, the subquery can be viewed as a function that takes a parameter (here, <i>instructor</i>.<span class="s69">ID</span>) and returns the set of all courses taught in 2019 by instructors (with the same <span class="s69">ID</span>).</p><p class="s46" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">evaluates the overall query (conceptually) by computing the Cartesian product of the relations in the outer </span>from <span class="p">clause and then testing the predicates in the </span>where <span class="p">clause for each tuple in the product. In the preceding example, the predicate tests if the result of the subquery evaluation is empty. In practice, the predicates in the </span>where <span class="p">clause that can be used as join predicates, or as selection predicates are evaluated as part of the selections on relations or to perform joins that avoid Cartesian products. Predicates involving nested subqueries in the </span>where <span class="p">clause are evaluated subsequently, since they are usually expensive, by invoking the subquery as a function.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The technique of evaluating a nested subquery by invoking it as a function is called <span class="s63">correlated evaluation</span>. Correlated evaluation is not very eﬃcient, since the subquery is separately evaluated for each tuple in the outer level query. A large number of random disk <span class="s44">I/O </span>operations may result.</p><p class="s42" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">SQL <span class="s43">optimizers therefore attempt to transform nested subqueries into joins, where possible. Eﬃcient join algorithms help avoid expensive random </span>I/O<span class="s43">. Where the trans- formation is not possible, the optimizer keeps the subqueries as separate expressions, optimizes them separately, and then evaluates them by correlated evaluation.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As an attempt at transforming a nested subquery into a join, the query in the pre- ceding example can be rewritten in relational algebra as a join:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s109" style="padding-left: 179pt;text-indent: 0pt;text-align: left;"><span class="s125">Π</span>name<span class="s129">(</span><span class="s128">instructor </span><span class="s147">⋈</span>instructor<span class="s126">.</span>ID<span class="s118">=</span>teaches<span class="s126">.</span>ID <span class="s118">∧</span>teaches<span class="s126">.</span>year<span class="s118">=</span><span class="s119">2019 </span><span class="s128">teaches</span><span class="s129">)</span></p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Unfortunately, the above query is not quite correct, since the multiset versions of the relational algebra operators are used in <span class="s44">SQL </span>implementations, and as a result an in- structor who teaches multiple sections in 2019 will appear multiple times in the result of the relational algebra query, although that instructor would appear only once in the <span class="s44">SQL </span>query result. Using the set version of the relational algebra operators will not help either, since if there are two instructors with the same name who teach in 2019, the name would appear only once with the set version of relational algebra, but would ap- pear twice in the <span class="s44">SQL </span>query result. (We note that the set version of relational algebra</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">would give the correct result if the query output contained the primary key of <i>instructor</i>, namely <span class="s69">ID</span>.)</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To properly reﬂect <span class="s44">SQL </span>semantics, the number of duplicates of a tuple in the result should not change because of the rewriting. The semijoin operator of the relational al- gebra provides a solution to this problem. The multiset version of the <span class="s63">semijoin </span>operator <i>r </i><span class="s86">⋉</span><span class="s171">θ </span><i>s </i>is deﬁned as follows: if a tuple <i>r</i><span class="s145">i </span>appears <i>n </i>times in <i>r</i>, it appears <i>n </i>times in the</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">result of <i>r</i><span class="s86">⋉</span><span class="s171">θ </span>if there is at least one tuple <i>s</i><span class="s145">j </span>such that <i>r</i><span class="s145">i </span>and <i>s</i><span class="s145">j </span>together satisfy predicate</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 83%;text-align: justify;"><span class="s15">θ</span><span class="p">; otherwise </span>r<span class="s145">i </span><span class="p">does not appear in the result. The set version of the semijoin operator </span>r <span class="s86">⋉</span><span class="s136">θ </span>s <span class="p">can be deﬁned as </span><span class="s15">Π</span><span class="s123">R</span><span class="p">(</span>r <span class="s86">⋈</span><span class="s136">θ </span>s<span class="p">), where </span>R <span class="p">is the set of attributes in the schema of </span>r<span class="p">. The multiset version of the semijoin operator outputs the same tuples, but the</span></p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 87%;text-align: justify;">number of duplicates of each tuple <i>r</i><span class="s97">i </span>in the semijoin result is the same as the number of duplicates of <i>r</i><span class="s97">i </span>in <i>r</i>.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">The preceding <span class="s44">SQL </span>query can be translated into the following equivalent relational</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">algebra using the multiset semijoin operator:</p><p class="s109" style="padding-top: 6pt;padding-left: 63pt;text-indent: 0pt;text-align: center;"><span class="s125">Π</span>name<span class="s129">(</span><span class="s128">instructor </span><span class="s147">⋉</span>instructor<span class="s126">.</span>ID<span class="s118">=</span>teaches<span class="s126">.</span>ID <span class="s118">∧ </span>teaches<span class="s126">.</span>year<span class="s118">=</span><span class="s119">2019 </span><span class="s128">teaches</span><span class="s129">)</span></p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The above query in the multiset relational algebra gives the same result as the <span class="s44">SQL</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">query, including the counts of duplicates. The query can equivalently be written as:</p><p class="s109" style="padding-top: 5pt;padding-left: 63pt;text-indent: 0pt;text-align: center;"><span class="s117">Π</span>name<span class="s122">(</span><span class="s121">instructor </span><span class="s138">⋉</span>instructor<span class="s126">.</span>ID<span class="s118">=</span>teaches<span class="s126">.</span>ID <span class="s122">(</span><span class="s117">σ</span>teaches<span class="s126">.</span>year<span class="s118">=</span><span class="s119">2019</span><span class="s120">(</span><span class="s121">teaches</span><span class="s122">)))</span></p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The following <span class="s44">SQL </span>query using the <b>in </b>clause is equivalent to the preceding <span class="s44">SQL </span>query using the <b>exists </b>clause, and can be translated to the same relational algebra expression using semijoin.</p><p class="s46" style="padding-top: 6pt;padding-left: 166pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 166pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 166pt;text-indent: 0pt;text-align: left;">where <i>instructor</i><span class="p">.</span><span class="s69">ID </span>in <span class="p">(</span>select <i>teaches</i><span class="p">.</span><span class="s69">ID</span></p><p class="s46" style="padding-left: 265pt;text-indent: 0pt;text-align: left;">from <i>teaches</i></p><p class="s13" style="padding-left: 265pt;text-indent: 0pt;text-align: left;"><b>where </b>teaches<span class="p">.</span>year <span class="s15">= </span><span class="p">2019);</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="12" height="1" alt="image" src="Image_2943.png"/></span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 17pt;line-height: 84%;text-align: justify;">The anti-semijoin is useful with <b>not exists </b>queries. The multiset <span class="s63">anti-semijoin </span>oper- ator <i>r </i><span class="s86">⋉</span><span class="s171">θ </span><i>s </i>is deﬁned as follows: if a tuple <i>r</i><span class="s145">i </span>appears <i>n </i>times in <i>r</i>, it appears <i>n </i>times in the result of <i>r </i><span class="s86">⋉</span><span class="s171">θ </span><i>s </i>if there does not exist any tuple <i>s</i><span class="s145">j </span>in <i>s </i>such that <i>r</i><span class="s145">i </span>and <i>s</i><span class="s145">j </span>satisfy predicate <span class="s15">θ</span>; otherwise <i>r</i><span class="s97">i </span>does not appear in the result. The anti-semijoin operator is also known as the <span class="s63">anti-join </span>operator.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">Consider the <span class="s44">SQL </span>query:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;text-align: left;">where not exists <span class="p">(</span>select <span class="p">*</span></p><p class="s46" style="padding-left: 244pt;text-indent: 0pt;text-align: left;">from <i>teaches</i></p><p class="s13" style="padding-left: 244pt;text-indent: 0pt;text-align: left;"><b>where </b>instructor<span class="p">.</span><span class="s69">ID </span><span class="s15">= </span>teaches<span class="p">.</span><span class="s69">ID</span></p><p class="s13" style="padding-left: 272pt;text-indent: 0pt;text-align: left;"><b>and </b>teaches<span class="p">.</span>year <span class="s15">= </span><span class="p">2019);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">The preceding query can be translated into the following relational algebra using the anti-semijoin operator:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="12" height="1" alt="image" src="Image_2944.png"/></span></p><p class="s109" style="padding-top: 7pt;padding-left: 137pt;text-indent: 35pt;line-height: 123%;text-align: left;"><span class="s117">Π</span>name<span class="s122">(</span><span class="s121">instructor </span><span class="s138">⋉</span>instructor<span class="s126">.</span>ID<span class="s118">=</span>teaches<span class="s126">.</span>ID<span class="s122">(</span><span class="s117">σ</span>teaches<span class="s126">.</span>year<span class="s118">=</span><span class="s119">2019</span><span class="s120">(</span><span class="s121">teaches</span><span class="s122">))) </span><span class="p">In general, a query of the form:</span></p><p class="s46" style="padding-top: 5pt;padding-left: 224pt;text-indent: 0pt;text-align: left;">select <i>A</i></p><p class="s13" style="padding-left: 224pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><b>from </b>r<span class="s98">1</span><span class="p">, </span>r<span class="s98">2</span><span class="p">, . . . , </span>r<span class="s97">n</span></p><p class="s46" style="padding-left: 224pt;text-indent: 0pt;line-height: 12pt;text-align: left;">where <i>P</i><span class="s98">1</span><span class="p"> </span>and exists <span class="p">(</span>select <span class="p">*</span></p><p class="s13" style="padding-left: 313pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><b>from </b>s<span class="s98">1</span><span class="p">, </span>s<span class="s98">2</span><span class="p">, ..., </span>s<span class="s145">m</span></p><p class="s46" style="padding-left: 313pt;text-indent: 0pt;line-height: 7pt;text-align: left;">where <i>P</i><span class="s76">1</span><span class="p"> </span>and <i>P</i><span class="s76">2</span><span class="p">);</span></p><p class="s119" style="padding-left: 346pt;text-indent: 0pt;line-height: 8pt;text-align: left;">2   2</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;line-height: 8pt;text-align: left;">where <i>P</i><span class="s76">1</span> are predicates that only reference the relations <i>s</i><span class="s97">i </span>in the subquery, and <i>P</i><span class="s76">2</span></p><p class="s119" style="padding-left: 155pt;text-indent: 0pt;line-height: 6pt;text-align: left;">2                                               2</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 87%;text-align: left;">predicates that also reference the relations <i>r</i><span class="s97">i </span>from the outer query, can be translated to:</p><p class="s15" style="padding-top: 8pt;padding-left: 188pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Π<span class="s123">A</span><span class="p">((</span>σ<span class="s123">P</span><span class="s13"> </span><span class="p">(</span><span class="s13">r</span><span class="s93">1 </span>× <span class="s13">r</span><span class="s93">2 </span>× … × <span class="s13">r</span><span class="s145">n</span><span class="p">)) </span><span class="s86">⋉</span><span class="s169">P</span><span class="s150">2 </span>σ<span class="s123">P</span><span class="s150">1 </span><span class="s388">(</span><span class="s13">s</span><span class="s93">1 </span>× <span class="s13">s</span><span class="s93">2 </span>×… × <span class="s13">s</span><span class="s145">m</span><span class="p">))</span></p><p class="s416" style="padding-left: 72pt;text-indent: 0pt;line-height: 7pt;text-align: center;">1                <span class="s150">2   2</span></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">If <b>not exists </b>were used instead of <b>exists</b>, the semijoin should be replaced by anti-semijoin in the relational algebra query. If an <b>in </b>clause is used instead of <b>exists</b>, the relational algebra query can be appropriately modiﬁed by adding a corresponding predicate in the semijoin predicate, as our earlier example illustrated.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The process of replacing a nested query by a query with a join, semijoin, or anti- semijoin is called <span class="s63">decorrelation</span>. The semijoin and anti-semijoin operators can be eﬃ- ciently implemented using modiﬁcations of the join algorithms, as explored in Practice Exercise 15.10.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Consider the following query with aggregation in a scalar subquery, that ﬁnds in- structors who have taught more than one course section in 2019.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 213pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 213pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p style="padding-left: 213pt;text-indent: 0pt;line-height: 17pt;text-align: left;"><b>where </b>1 <span class="s83">&lt; </span>(<b>select count</b>(*)</p><p class="s46" style="padding-left: 263pt;text-indent: 0pt;line-height: 10pt;text-align: left;">from <i>teaches</i></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;text-align: right;"><b>where </b>instructor<span class="p">.</span><span class="s69">ID </span><span class="s15">= </span>teaches<span class="p">.</span><span class="s69">ID</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;text-align: right;"><b>and </b>teaches<span class="p">.</span>year <span class="s15">= </span><span class="p">2019);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: right;">The above query can be rewritten using a semijoin as follows:</p><p class="s109" style="padding-top: 7pt;padding-left: 119pt;text-indent: 15pt;line-height: 121%;text-align: justify;"><span class="s117">Π</span>name<span class="s122">(</span><span class="s121">instructor </span><span class="s138">⋉</span><span class="s119">(</span>instructor<span class="s126">.</span>ID<span class="s118">=</span>TID<span class="s119">)</span><span class="s118">∧</span><span class="s119">(1</span><span class="s126">&lt;</span>cnt<span class="s119">)</span><span class="s120">(</span>ID <b>as </b>TID<span class="s117">γ</span><b>count</b><span class="s119">(</span><span class="s118">∗</span><span class="s119">) </span><b>as </b>cnt<span class="s122">(</span><span class="s117">σ</span>year<span class="s118">=</span><span class="s119">2019</span><span class="s120">(</span><span class="s121">teaches</span><span class="s122">))) </span><span class="p">Observe that the subquery has a predicate </span><span class="s13">instructor</span><span class="p">.</span><span class="s69">ID</span><span class="s15">= </span><span class="s13">teaches</span><span class="p">.</span><span class="s69">ID</span><span class="p">, and aggregation</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 76%;text-align: justify;">without a group by clause. The decorrelated query has the predicate moved into the semijoin condition, and the aggregation is now grouped by <span class="s69">ID</span>. The predicate 1 <span class="s83">&lt; </span>(sub- query) has turned into a semijoin predicate. Intuitively, the subquery performs a sep-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><a name="bookmark340">arate count for each </a><i>instructor</i>.<span class="s69">ID</span>; grouping by <span class="s69">ID </span>ensures that counts are computed separately for each <span class="s69">ID</span>.<a name="bookmark360">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Decorrelation is clearly more complicated when the nested subquery uses aggre- gation, or when the nested subquery is used as a scalar subquery. In fact, decorrelation is not possible for certain cases of subqueries. For example, a subquery that is used as a scalar subquery is expected to return only one result; if it returns more than one result, a runtime exception can occur, which is not possible with a decorrelated query. Further, whether to decorrelate or not should ideally be done in a cost-based manner, depending on whether decorrelation reduces the cost or not. Some query optimizers represent nested subqueries using extended relational-algebra constructs, and express transformations of nested subqueries to semijoin, anti-semijoin, and so forth, as equiv- alence rules. We do not attempt to give algorithms for the general case, and instead refer you to relevant items in the online bibliographical notes.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Optimization of complex nested subqueries is a complicated task, as you can in- fer from the preceding discussion, and many optimizers do only a limited amount of decorrelation. It better to avoid using complex nested subqueries, where possible, since we cannot be sure that the query optimizer will succeed in converting them to a form that can be evaluated eﬃciently.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part298.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part300.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
