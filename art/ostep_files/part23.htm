<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2.3 Concurrency</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part22.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part24.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 6pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">2.3 Concurrency</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Another main theme of this book is <b>concurrency</b>. We use this concep- tual term to refer to a host of problems that arise, and must be addressed, when working on many things at once (i.e., concurrently) in the same program. The problems of concurrency arose first within the operating system itself; as you can see in the examples above on virtualization, the OS is juggling many things at once, first running one process, then an- other, and so forth. As it turns out, doing so leads to some deep and interesting problems.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_012.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: justify;">5<span class="s12">For this example to work, you need to make sure address-space randomization is dis- abled; randomization, as it turns out, can be a good defense against certain kinds of security flaws. Read more about it on your own, especially if you want to learn how to break into computer systems via stack-smashing attacks. Not that we would recommend such a thing...</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#include &lt;stdio.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">#include &lt;stdlib.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3  <span class="s38">#include &quot;common.h&quot;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">4</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">volatile int counter = 0;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6  <span class="s38">int loops;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">7</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">8  </span>void <span class="s39">*</span>worker(void <span class="s39">*</span>arg) {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;">9    <span class="s38">int i;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10     <span class="s38">for (i = 0; i &lt; loops; i++) {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11       <span class="s38">counter++;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">13    <span class="s38">return NULL;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">15</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16  <span class="s38">int</span></p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">17  </span>main(int argc, char <span class="s39">*</span>argv[])</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">18  <span class="s38">{</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19    <span class="s38">if (argc != 2) {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">20       <span class="s38">fprintf(stderr, &quot;usage: threads &lt;value&gt;\n&quot;);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">21       <span class="s38">exit(1);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">22    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">23    <span class="s38">loops = atoi(argv[1]);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">24    <span class="s38">pthread_t p1, p2;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">25    <span class="s38">printf(&quot;Initial value : %d\n&quot;, counter);</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">26</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">27    <span class="s38">Pthread_create(&amp;p1, NULL, worker, NULL);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">28    <span class="s38">Pthread_create(&amp;p2, NULL, worker, NULL);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">29    <span class="s38">Pthread_join(p1, NULL);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">30    <span class="s38">Pthread_join(p2, NULL);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">31     <span class="s38">printf(&quot;Final value  : %d\n&quot;, counter);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">32    <span class="s38">return 0;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">33  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 108pt;text-indent: 0pt;text-align: left;">Figure 2.5: <b>A Multi-threaded Program</b></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Unfortunately, the problems of concurrency are no longer limited just to the OS itself. Indeed, modern <b>multi-threaded </b>programs exhibit the same problems. Let us demonstrate with an example of a <b>multi-threaded </b>program (Figure <span style=" color: #00AEEF;">2.5</span>).</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_013.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 92%;text-align: justify;">Although you might not understand this example fully at the moment (and we’ll learn a lot more about it in later chapters, in the section of the book on concurrency), the basic idea is simple. The main program creates two <b>threads </b>using <span class="s41">Pthread create()</span><span class="s35">6</span>. You can think of a thread as a function running within the same memory space as other functions, with</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 88%;text-align: justify;">more than one of them active at a time. In this example, each thread starts running in a routine called <span class="s41">worker()</span>, in which it simply increments a counter in a loop for <span class="s41">loops </span>number of times.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Below is a transcript of what happens when we run this program with the input value for the variable <span class="s41">loops </span>set to 1000. The value of <span class="s41">loops</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_014.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_015.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_016.png"/></span></p><p class="s12" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 90%;text-align: justify;"><span class="s11">6</span>The actual call should be to lower-case <span class="s38">pthread create()</span>; the upper-case version is our own wrapper that calls <span class="s38">pthread create() </span>and makes sure that the return code indicates that the call succeeded. See the code for details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX OF THE </span>P<span class="s7">ROBLEM</span>:</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: center;">H<span class="s7">OW </span>T<span class="s7">O </span>B<span class="s7">UILD </span>C<span class="s7">ORRECT </span>C<span class="s7">ONCURRENT </span>P<span class="s7">ROGRAMS</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">When there are many concurrently executing threads within the same memory space, how can we build a correctly working program? What primitives are needed from the OS? What mechanisms should be pro- vided by the hardware? How can we use them to solve the problems of concurrency?</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">determines how many times each of the two workers will increment the shared counter in a loop. When the program is run with the value of <span class="s41">loops </span>set to 1000, what do you expect the final value of <span class="s41">counter </span>to be?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; gcc -o thread thread.c -Wall -pthread prompt&gt; ./thread 1000</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">Initial value : 0 Final value : 2000</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As you probably guessed, when the two threads are finished, the final value of the counter is 2000, as each thread incremented the counter 1000 times. Indeed, when the input value of <span class="s41">loops </span>is set to <span class="s43">N </span>, we would expect the final output of the program to be <span class="s44">2</span><span class="s43">N </span>. But life is not so simple, as it turns out. Let’s run the same program, but with higher values for <span class="s41">loops</span>, and see what happens:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; ./thread 100000 Initial value : 0</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">Final value  : 143012  // huh?? prompt&gt; ./thread 100000</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Initial value : 0</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">Final value : 137298  // what the??</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this run, when we gave an input value of 100,000, instead of getting a final value of 200,000, we instead first get 143,012. Then, when we run the program a second time, we not only again get the <i>wrong </i>value, but also a <i>different </i>value than the last time. In fact, if you run the program over and over with high values of <span class="s41">loops</span>, you may find that sometimes you even get the right answer! So why is this happening?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As it turns out, the reason for these odd and unusual outcomes relate to how instructions are executed, which is one at a time. Unfortunately, a key part of the program above, where the shared counter is incremented, takes three instructions: one to load the value of the counter from mem- ory into a register, one to increment it, and one to store it back into mem- ory. Because these three instructions do not execute <b>atomically </b>(all at once), strange things can happen. It is this problem of <b>concurrency </b>that we will address in great detail in the second part of this book.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#include &lt;stdio.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">#include &lt;unistd.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3  <span class="s38">#include &lt;assert.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4  <span class="s38">#include &lt;fcntl.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">#include &lt;sys/types.h&gt;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">6</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">7  <span class="s38">int</span></p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">8  </span>main(int argc, char <span class="s39">*</span>argv[])</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;">9  <span class="s38">{</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10     <span class="s38">int fd = open(&quot;/tmp/file&quot;, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11    <span class="s38">assert(fd &gt; -1);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12     <span class="s38">int rc = write(fd, &quot;hello world\n&quot;, 13);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">13    <span class="s38">assert(rc == 13);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14    <span class="s38">close(fd);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15    <span class="s38">return 0;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part22.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part24.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
