<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.8 Memory Mapping</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P70004970270000000000000000072B5" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000045D75" data-uri="chapter09.xhtml#P7000497027000000000000000045D75" epub:type="title"><span class="pcalibre label pcalibre1">9.8 </span>Memory Mapping</h1></header>
<p id="P7000497027000000000000000045D76" data-uri="chapter09.xhtml#P7000497027000000000000000045D76" class="pcalibre1 pcalibre calibre2">Linux initializes the contents of a virtual memory area by associating it with an <i class="calibre5 pcalibre pcalibre1">object</i> on disk, a process known as <i class="calibre5 pcalibre pcalibre1">memory mapping.</i> Areas can be mapped to one of two types of objects:</p>
<ol id="P7000497027000000000000000045D77" data-uri="chapter09.xhtml#P7000497027000000000000000045D77" class="calibre72 pcalibre pcalibre1">
<li id="P7000497027000000000000000045D78" data-uri="chapter09.xhtml#P7000497027000000000000000045D78" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045D79" data-uri="chapter09.xhtml#P7000497027000000000000000045D79" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Regular file in the Linux file system: </span>An area can be mapped to a contiguous section of a regular disk file, such as an executable object file. The file section is divided into page-size pieces, with each piece containing the initial contents of a virtual page. Because of demand paging, none of these virtual pages is actually swapped into physical memory until the CPU first <i class="calibre5 pcalibre pcalibre1">touches</i> the page (i.e., issues a virtual address that falls within that page's region of the address space). If the area is larger than the file section, then the area is padded with zeros.</p></li>
<li id="P7000497027000000000000000045D7A" data-uri="chapter09.xhtml#P7000497027000000000000000045D7A" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045D7B" data-uri="chapter09.xhtml#P7000497027000000000000000045D7B" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Anonymous file: </span>An area can also be mapped to an anonymous file, created by the kernel, that contains all binary zeros. The first time the CPU touches a virtual page in such an area, the kernel finds an appropriate victim page in physical memory, swaps out the victim page if it is dirty, overwrites the victim page with binary zeros, and updates the page table to mark the page as resident. Notice that no data are actually transferred between disk and memory. For this reason, pages in areas that are mapped to anonymous files are sometimes called <i class="calibre5 pcalibre pcalibre1">demand-zero pages.</i></p></li>
</ol>
<p id="P7000497027000000000000000045D7C" data-uri="chapter09.xhtml#P7000497027000000000000000045D7C" class="pcalibre1 pcalibre calibre2">In either case, once a virtual page is initialized, it is swapped back and forth between a special <i class="calibre5 pcalibre pcalibre1">swap file</i> maintained by the kernel. The swap file is also known as the <i class="calibre5 pcalibre pcalibre1">swap space</i> or the <i class="calibre5 pcalibre pcalibre1">swap area.</i> An important point to realize is that at any point in time, the swap space bounds the total amount of virtual pages that can be allocated by the currently running processes.</p>
<section id="P70004970270000000000000000072BE" data-uri="chapter09.xhtml#P70004970270000000000000000072BE" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045D7D" data-uri="chapter09.xhtml#P7000497027000000000000000045D7D" epub:type="title"><span class="pcalibre label pcalibre1">9.8.1 </span>Shared Objects Revisited</h1></header>
<p id="P7000497027000000000000000045D7E" data-uri="chapter09.xhtml#P7000497027000000000000000045D7E" class="pcalibre1 pcalibre calibre2">The idea of memory mapping resulted from a clever insight that if the virtual memory system could be integrated into the conventional file system, then it could provide a simple and efficient way to load programs and data into memory.</p>
<p id="P7000497027000000000000000045D7F" data-uri="chapter09.xhtml#P7000497027000000000000000045D7F" class="pcalibre1 pcalibre calibre2">As we have seen, the process abstraction promises to provide each process with its own private virtual address space that is protected from errant writes or reads by other processes. However, many processes have identical read-only code areas. For example, each process that runs the Linux shell program bash has the same code area. Further, many programs need to access identical copies of read-only run-time library code. For example, every C program requires functions from the standard C library such as <code id="P7000497027000000000000000045D80" data-uri="chapter09.xhtml#P7000497027000000000000000045D80" class="pcalibre1 calibre8 pcalibre">printf</code>. It would be extremely wasteful for each process to keep duplicate copies of these commonly used codes in physical <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000072C3" title="834" data-uri="chapter09.xhtml#P70004970270000000000000000072C3" epub:type="pagebreak"></span>memory. Fortunately, memory mapping provides us with a clean mechanism for controlling how objects are shared by multiple processes.</p>
<p id="P7000497027000000000000000045D81" data-uri="chapter09.xhtml#P7000497027000000000000000045D81" class="pcalibre1 pcalibre calibre2">An object can be mapped into an area of virtual memory as either a <i class="calibre5 pcalibre pcalibre1">shared object</i> or <i class="calibre5 pcalibre pcalibre1">a private object.</i> If a process maps a shared object into an area of its virtual address space, then any writes that the process makes to that area are visible to any other processes that have also mapped the shared object into their virtual memory. Further, the changes are also reflected in the original object on disk.</p>
<p id="P7000497027000000000000000045D82" data-uri="chapter09.xhtml#P7000497027000000000000000045D82" class="pcalibre1 pcalibre calibre2">Changes made to an area mapped to a private object, on the other hand, are not visible to other processes, and any writes that the process makes to the area are <i class="calibre5 pcalibre pcalibre1">not</i> reflected back to the object on disk. A virtual memory area into which a shared object is mapped is often called a <i class="calibre5 pcalibre pcalibre1">shared area.</i> Similarly for <i class="calibre5 pcalibre pcalibre1">a private area.</i></p>
<p id="P7000497027000000000000000045D83" data-uri="chapter09.xhtml#P7000497027000000000000000045D83" class="pcalibre1 pcalibre calibre2">Suppose that process 1 maps a shared object into an area of its virtual memory, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000072C7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.29(a)</span></a>. Now suppose that process 2 maps the same shared object</p>
<figure id="P70004970270000000000000000072C7" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000072C7">
<img alt="Diagram (a) shows shared object mapped to process 1 virtual memory (shared with physical memory). Diagram (b) shows shared object mapped to process 1 and process 2 virtual memory." id="P7000497027000000000000000045D84" data-uri="P700049702700000000000000000B798" src="../images/p834-1.png" class="pcalibre1 calibre288 pcalibre"/>
<figcaption id="P7000497027000000000000000045D85" data-uri="chapter09.xhtml#P7000497027000000000000000045D85" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045D86" data-uri="chapter09.xhtml#P7000497027000000000000000045D86" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.29 </span>A shared object.</h1></header><div class="caption pcalibre pcalibre1" id="P7000497027000000000000000045D87" data-uri="chapter09.xhtml#P7000497027000000000000000045D87"><p id="P7000497027000000000000000045D88" data-uri="chapter09.xhtml#P7000497027000000000000000045D88" class="pcalibre calibre3 pcalibre1">(a) After process 1 maps the shared object, (b) After process 2 maps the same shared object. (Note that the physical pages are not necessarily contiguous.)</p></div></figcaption>
</figure>
<figure id="P70004970270000000000000000072CD" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000072CD">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000072CE" title="835" data-uri="chapter09.xhtml#P70004970270000000000000000072CE" epub:type="pagebreak"></span>
<img alt="Diagrams illustrate a private copy-on-write object." id="P7000497027000000000000000045D89" data-uri="P700049702700000000000000000B799" src="../images/p835-1.png" class="calibre289 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045D8A" data-uri="chapter09.xhtml#P7000497027000000000000000045D8A" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045D8B" data-uri="chapter09.xhtml#P7000497027000000000000000045D8B" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.30 </span>A private copy-on-write object.</h1></header><div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045D8C" data-uri="chapter09.xhtml#P7000497027000000000000000045D8C"><p id="P7000497027000000000000000045D8D" data-uri="chapter09.xhtml#P7000497027000000000000000045D8D" class="pcalibre calibre3 pcalibre1">(a) After both processes have mapped the private copy-on-write object, (b) After process 2 writes to a page in the private area.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000260DB" data-uri="chapter09.xhtml#P70004970270000000000000000260DB">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<ul id="P7000497027000000000000000045D8E" data-uri="chapter09.xhtml#P7000497027000000000000000045D8E" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045D8F" data-uri="chapter09.xhtml#P7000497027000000000000000045D8F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045D90" data-uri="chapter09.xhtml#P7000497027000000000000000045D90" class="pcalibre calibre3 pcalibre1">Diagram (a) shows private copy-on-write object mapped to process 1 and process 2 virtual memory.</p></li>
<li id="P7000497027000000000000000045D91" data-uri="chapter09.xhtml#P7000497027000000000000000045D91" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045D92" data-uri="chapter09.xhtml#P7000497027000000000000000045D92" class="pcalibre calibre3 pcalibre1">Diagram (b) shows private copy-on-write object mapped to process 1 and process 2 virtual memory. The copy-on-write segment is repeated in physical memory, which is then mapped as write to private copy-on-write page on process 2 virtual memory.</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045D93" data-uri="chapter09.xhtml#P7000497027000000000000000045D93">into its address space (not necessarily at the same virtual address as process 1), as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000072C7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.29(b)</span></a>.</p>
<p id="P7000497027000000000000000045D94" data-uri="chapter09.xhtml#P7000497027000000000000000045D94" class="pcalibre1 pcalibre calibre2">Since each object has a unique filename, the kernel can quickly determine that process 1 has already mapped this object and can point the page table entries in process 2 to the appropriate physical pages. The key point is that only a single copy of the shared object needs to be stored in physical memory, even though the object is mapped into multiple shared areas. For convenience, we have shown the physical pages as being contiguous, but of course this is not true in general.</p>
<p id="P7000497027000000000000000045D95" data-uri="chapter09.xhtml#P7000497027000000000000000045D95" class="pcalibre1 pcalibre calibre2">Private objects are mapped into virtual memory using a clever technique known as <i class="calibre5 pcalibre pcalibre1">copy-on-write.</i> A private object begins life in exactly the same way as a shared object, with only one copy of the private object stored in physical memory. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000072CD"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.30(a)</span></a> shows a case where two processes have mapped a private object into different areas of their virtual memories but share the same <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000072D7" title="836" data-uri="chapter09.xhtml#P70004970270000000000000000072D7" epub:type="pagebreak"></span>physical copy of the object. For each process that maps the private object, the page table entries for the corresponding private area are flagged as read-only, and the area struct is flagged <i class="calibre5 pcalibre pcalibre1">as private copy-on-write.</i> So long as neither process attempts to write to its respective private area, they continue to share a single copy of the object in physical memory. However, as soon as a process attempts to write to some page in the private area, the write triggers a protection fault.</p>
<p id="P7000497027000000000000000045D96" data-uri="chapter09.xhtml#P7000497027000000000000000045D96" class="pcalibre1 pcalibre calibre2">When the fault handler notices that the protection exception was caused by the process trying to write to a page in a private copy-on-write area, it creates a new copy of the page in physical memory, updates the page table entry to point to the new copy, and then restores write permissions to the page, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000072CD"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.30(b)</span></a>. When the fault handler returns, the CPU re-executes the write, which now proceeds normally on the newly created page.</p>
<p id="P7000497027000000000000000045D97" data-uri="chapter09.xhtml#P7000497027000000000000000045D97" class="pcalibre1 pcalibre calibre2">By deferring the copying of the pages in private objects until the last possible moment, copy-on-write makes the most efficient use of scarce physical memory.</p>
</section>
<section id="P70004970270000000000000000072DA" data-uri="chapter09.xhtml#P70004970270000000000000000072DA" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045D98" data-uri="chapter09.xhtml#P7000497027000000000000000045D98" epub:type="title"><span class="pcalibre label pcalibre1">9.8.2 </span>The <code id="P7000497027000000000000000045D99" data-uri="chapter09.xhtml#P7000497027000000000000000045D99" class="pcalibre1 calibre8 pcalibre">fork</code> Function Revisited</h1></header>
<p id="P7000497027000000000000000045D9A" data-uri="chapter09.xhtml#P7000497027000000000000000045D9A" class="pcalibre1 pcalibre calibre2">Now that we understand virtual memory and memory mapping, we can get a clear idea of how the <code id="P7000497027000000000000000045D9B" data-uri="chapter09.xhtml#P7000497027000000000000000045D9B" class="pcalibre1 calibre8 pcalibre">fork</code> function creates a new process with its own independent virtual address space.</p>
<p id="P7000497027000000000000000045D9C" data-uri="chapter09.xhtml#P7000497027000000000000000045D9C" class="pcalibre1 pcalibre calibre2">When the <code id="P7000497027000000000000000045D9D" data-uri="chapter09.xhtml#P7000497027000000000000000045D9D" class="pcalibre1 calibre8 pcalibre">fork</code> function is called by the <i class="calibre5 pcalibre pcalibre1">current process</i>, the kernel creates various data structures for the <i class="calibre5 pcalibre pcalibre1">new process</i> and assigns it a unique PID. To create the virtual memory for the new process, it creates exact copies of the current process's <code id="P7000497027000000000000000045D9E" data-uri="chapter09.xhtml#P7000497027000000000000000045D9E" class="pcalibre1 calibre8 pcalibre">mm_struct</code>, area structs, and page tables. It flags each page in both processes as read-only, and flags each area struct in both processes as private copy-on-write.</p>
<p id="P7000497027000000000000000045D9F" data-uri="chapter09.xhtml#P7000497027000000000000000045D9F" class="pcalibre1 pcalibre calibre2">When the <code id="P7000497027000000000000000045DA0" data-uri="chapter09.xhtml#P7000497027000000000000000045DA0" class="pcalibre1 calibre8 pcalibre">fork</code> returns in the new process, the new process now has an exact copy of the virtual memory as it existed when the fork was called. When either of the processes performs any subsequent writes, the copy-on-write mechanism creates new pages, thus preserving the abstraction of a private address space for each process.</p>
</section>
<section id="P70004970270000000000000000072E4" data-uri="chapter09.xhtml#P70004970270000000000000000072E4" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045DA1" data-uri="chapter09.xhtml#P7000497027000000000000000045DA1" epub:type="title"><span class="pcalibre label pcalibre1">9.8.3 </span>The execve Function Revisited</h1></header>
<p id="P7000497027000000000000000045DA2" data-uri="chapter09.xhtml#P7000497027000000000000000045DA2" class="pcalibre1 pcalibre calibre2">Virtual memory and memory mapping also play key roles in the process of loading programs into memory. Now that we understand these concepts, we can understand how the <code id="P7000497027000000000000000045DA3" data-uri="chapter09.xhtml#P7000497027000000000000000045DA3" class="pcalibre1 calibre8 pcalibre">execve</code> function really loads and executes programs. Suppose that the program running in the current process makes the following call:</p>
<pre id="P7000497027000000000000000045DA4" data-uri="chapter09.xhtml#P7000497027000000000000000045DA4" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045DA5" data-uri="chapter09.xhtml#P7000497027000000000000000045DA5" class="calibre10 pcalibre pcalibre1">
execve("a.out", NULL, NULL);
</code></pre>
<p id="P7000497027000000000000000045DA6" data-uri="chapter09.xhtml#P7000497027000000000000000045DA6" class="pcalibre1 pcalibre calibre2">As you learned in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">8</span></a>, the <code id="P7000497027000000000000000045DA7" data-uri="chapter09.xhtml#P7000497027000000000000000045DA7" class="pcalibre1 calibre8 pcalibre">execve</code> function loads and runs the program contained in the executable object file <code id="P7000497027000000000000000045DA8" data-uri="chapter09.xhtml#P7000497027000000000000000045DA8" class="pcalibre1 calibre8 pcalibre">a.out</code> within the current process, effectively replacing the current program with the <code id="P7000497027000000000000000045DA9" data-uri="chapter09.xhtml#P7000497027000000000000000045DA9" class="pcalibre1 calibre8 pcalibre">a.out</code> program. Loading and running <code id="P7000497027000000000000000045DAA" data-uri="chapter09.xhtml#P7000497027000000000000000045DAA" class="pcalibre1 calibre8 pcalibre">a.out</code> requires the following steps:</p>
<figure id="P70004970270000000000000000072EF" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000072EF">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000072F0" title="837" data-uri="chapter09.xhtml#P70004970270000000000000000072F0" epub:type="pagebreak"></span>
<img alt="A diagram illustrates how the loader maps the areas of the user address space." id="P7000497027000000000000000045DAB" data-uri="P700049702700000000000000000B79A" src="../images/p837-1.png" class="calibre290 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045DAC" data-uri="chapter09.xhtml#P7000497027000000000000000045DAC" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045DAD" data-uri="chapter09.xhtml#P7000497027000000000000000045DAD" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.31 </span>How the loader maps the areas of the user address space.</h1></header>

<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000260FC" data-uri="chapter09.xhtml#P70004970270000000000000000260FC">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045DAE" data-uri="chapter09.xhtml#P7000497027000000000000000045DAE" class="pcalibre1 pcalibre calibre2">A diagram of a stack has the following areas, listed from bottom to top:</p>
<ul id="P7000497027000000000000000045DAF" data-uri="chapter09.xhtml#P7000497027000000000000000045DAF" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045DB0" data-uri="chapter09.xhtml#P7000497027000000000000000045DB0" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DB1" data-uri="chapter09.xhtml#P7000497027000000000000000045DB1" class="pcalibre calibre3 pcalibre1">Gap from 0</p></li>
<li id="P7000497027000000000000000045DB2" data-uri="chapter09.xhtml#P7000497027000000000000000045DB2" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DB3" data-uri="chapter09.xhtml#P7000497027000000000000000045DB3" class="pcalibre calibre3 pcalibre1">Code (.text) and Initialized data (.data); together part of a.out and private, file-backed</p></li>
<li id="P7000497027000000000000000045DB4" data-uri="chapter09.xhtml#P7000497027000000000000000045DB4" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DB5" data-uri="chapter09.xhtml#P7000497027000000000000000045DB5" class="pcalibre calibre3 pcalibre1">Uninitialized data (.bss) (private, demand-zero)</p></li>
<li id="P7000497027000000000000000045DB6" data-uri="chapter09.xhtml#P7000497027000000000000000045DB6" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DB7" data-uri="chapter09.xhtml#P7000497027000000000000000045DB7" class="pcalibre calibre3 pcalibre1">Run-time heap (via malloc) (private, demand-zero)</p></li>
<li id="P7000497027000000000000000045DB8" data-uri="chapter09.xhtml#P7000497027000000000000000045DB8" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DB9" data-uri="chapter09.xhtml#P7000497027000000000000000045DB9" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P7000497027000000000000000045DBA" data-uri="chapter09.xhtml#P7000497027000000000000000045DBA" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DBB" data-uri="chapter09.xhtml#P7000497027000000000000000045DBB" class="pcalibre calibre3 pcalibre1">Memory-mapped region for shared libraries (libc.so containing .data and .text; shared, file-backed)</p></li>
<li id="P7000497027000000000000000045DBC" data-uri="chapter09.xhtml#P7000497027000000000000000045DBC" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DBD" data-uri="chapter09.xhtml#P7000497027000000000000000045DBD" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P7000497027000000000000000045DBE" data-uri="chapter09.xhtml#P7000497027000000000000000045DBE" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DBF" data-uri="chapter09.xhtml#P7000497027000000000000000045DBF" class="pcalibre calibre3 pcalibre1">User stack (private, demand-zero).</p></li>
</ul>
</details>
</figcaption>
</figure>
<ol id="P7000497027000000000000000045DC0" data-uri="chapter09.xhtml#P7000497027000000000000000045DC0" class="calibre72 pcalibre pcalibre1">
<li id="P7000497027000000000000000045DC1" data-uri="chapter09.xhtml#P7000497027000000000000000045DC1" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DC2" data-uri="chapter09.xhtml#P7000497027000000000000000045DC2" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Delete existing user areas. </span>Delete the existing area structs in the user portion of the current process's virtual address.</p></li>
<li id="P7000497027000000000000000045DC3" data-uri="chapter09.xhtml#P7000497027000000000000000045DC3" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DC4" data-uri="chapter09.xhtml#P7000497027000000000000000045DC4" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Map private areas. </span>Create new area structs for the code, data, bss, and stack areas of the new program. All of these new areas are private copy-on-write. The code and data areas are mapped to the <code id="P7000497027000000000000000045DC5" data-uri="chapter09.xhtml#P7000497027000000000000000045DC5" class="pcalibre1 calibre8 pcalibre">.text</code> and <code id="P7000497027000000000000000045DC6" data-uri="chapter09.xhtml#P7000497027000000000000000045DC6" class="pcalibre1 calibre8 pcalibre">.data</code> sections of the <code id="P7000497027000000000000000045DC7" data-uri="chapter09.xhtml#P7000497027000000000000000045DC7" class="pcalibre1 calibre8 pcalibre">a.out</code> file. The bss area is demand-zero, mapped to an anonymous file whose size is contained in <code id="P7000497027000000000000000045DC8" data-uri="chapter09.xhtml#P7000497027000000000000000045DC8" class="pcalibre1 calibre8 pcalibre">a.out</code>. The stack and heap area are also demand-zero, initially of zero length. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000072EF"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.31</span></a> summarizes the different mappings of the private areas.</p></li>
<li id="P7000497027000000000000000045DC9" data-uri="chapter09.xhtml#P7000497027000000000000000045DC9" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DCA" data-uri="chapter09.xhtml#P7000497027000000000000000045DCA" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Map shared areas. </span>If the <code id="P7000497027000000000000000045DCB" data-uri="chapter09.xhtml#P7000497027000000000000000045DCB" class="pcalibre1 calibre8 pcalibre">a.out</code> program was linked with shared objects, such as the standard C library <code id="P7000497027000000000000000045DCC" data-uri="chapter09.xhtml#P7000497027000000000000000045DCC" class="pcalibre1 calibre8 pcalibre">libc.so</code>, then these objects are dynamically linked into the program, and then mapped into the shared region of the user's virtual address space.</p></li>
<li id="P7000497027000000000000000045DCD" data-uri="chapter09.xhtml#P7000497027000000000000000045DCD" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DCE" data-uri="chapter09.xhtml#P7000497027000000000000000045DCE" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Set the program counter (PC). </span>The last thing that <code id="P7000497027000000000000000045DCF" data-uri="chapter09.xhtml#P7000497027000000000000000045DCF" class="pcalibre1 calibre8 pcalibre">execve</code> does is to set the program counter in the current process's context to point to the entry point in the code area.</p></li>
</ol>
<p id="P7000497027000000000000000045DD0" data-uri="chapter09.xhtml#P7000497027000000000000000045DD0" class="pcalibre1 pcalibre calibre2">The next time this process is scheduled, it will begin execution from the entry point. Linux will swap in code and data pages as needed.</p>
</section>
<section id="P7000497027000000000000000007305" data-uri="chapter09.xhtml#P7000497027000000000000000007305" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045DD1" data-uri="chapter09.xhtml#P7000497027000000000000000045DD1" epub:type="title"><span class="pcalibre label pcalibre1">9.8.4 </span>User-Level Memory Mapping with the <code id="P7000497027000000000000000045DD2" data-uri="chapter09.xhtml#P7000497027000000000000000045DD2" class="pcalibre1 calibre8 pcalibre">mmap</code> Function</h1></header>
<p id="P7000497027000000000000000045DD3" data-uri="chapter09.xhtml#P7000497027000000000000000045DD3" class="pcalibre1 pcalibre calibre2">Linux processes can use the <code id="P7000497027000000000000000045DD4" data-uri="chapter09.xhtml#P7000497027000000000000000045DD4" class="pcalibre1 calibre8 pcalibre">mmap</code> function to create new areas of virtual memory and to map objects into these areas.</p>
<figure id="P700049702700000000000000000730A" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P700049702700000000000000000730A">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000730B" title="838" data-uri="chapter09.xhtml#P700049702700000000000000000730B" epub:type="pagebreak"></span>
<img alt="A diagram shows a mapping of a section between the following: disk file specified by file descriptor fd, with length (bytes) beginning at offset (bytes); process virtual memory with length (bytes) beginning at start (or address chosen by the kernel), higher than offset." id="P7000497027000000000000000045DD5" data-uri="P700049702700000000000000000B79B" src="../images/p838-1.png" class="calibre291 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045DD6" data-uri="chapter09.xhtml#P7000497027000000000000000045DD6" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045DD7" data-uri="chapter09.xhtml#P7000497027000000000000000045DD7" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.32 </span>Visual interpretation of <code id="P7000497027000000000000000045DD8" data-uri="chapter09.xhtml#P7000497027000000000000000045DD8" class="pcalibre1 calibre8 pcalibre">mmap</code> arguments.</h1></header></figcaption>
</figure>
<pre id="P7000497027000000000000000045DD9" data-uri="chapter09.xhtml#P7000497027000000000000000045DD9" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045DDA" data-uri="chapter09.xhtml#P7000497027000000000000000045DDA" class="calibre10 pcalibre pcalibre1">
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

void *mmap(void *start, size_t length, int prot, int flags,
			 int fd, off_t offset);
				Returns: pointer to mapped area if OK, MAP_FAILED (–1) on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045DDB" data-uri="chapter09.xhtml#P7000497027000000000000000045DDB">The <code id="P7000497027000000000000000045DDC" data-uri="chapter09.xhtml#P7000497027000000000000000045DDC" class="pcalibre1 calibre8 pcalibre">mmap</code> function asks the kernel to create a new virtual memory area, preferably one that starts at address <code id="P7000497027000000000000000045DDD" data-uri="chapter09.xhtml#P7000497027000000000000000045DDD" class="pcalibre1 calibre8 pcalibre">start</code>, and to map a contiguous chunk of the object specified by file descriptor <code id="P7000497027000000000000000045DDE" data-uri="chapter09.xhtml#P7000497027000000000000000045DDE" class="pcalibre1 calibre8 pcalibre">fd</code> to the new area. The contiguous object chunk has a size of length bytes and starts at an <code id="P7000497027000000000000000045DDF" data-uri="chapter09.xhtml#P7000497027000000000000000045DDF" class="pcalibre1 calibre8 pcalibre">offset</code> of offset bytes from the beginning of the file. The <code id="P7000497027000000000000000045DE0" data-uri="chapter09.xhtml#P7000497027000000000000000045DE0" class="pcalibre1 calibre8 pcalibre">start</code> address is merely a hint, and is usually specified as NULL. For our purposes, we will always assume a NULL start address. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000730A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.32</span></a> depicts the meaning of these arguments.</p>
<p id="P7000497027000000000000000045DE1" data-uri="chapter09.xhtml#P7000497027000000000000000045DE1" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045DE2" data-uri="chapter09.xhtml#P7000497027000000000000000045DE2" class="pcalibre1 calibre8 pcalibre">prot</code> argument contains bits that describe the access permissions of the newly mapped virtual memory area (i.e., the <code id="P7000497027000000000000000045DE3" data-uri="chapter09.xhtml#P7000497027000000000000000045DE3" class="pcalibre1 calibre8 pcalibre">vm_prot</code> bits in the corresponding area struct).</p>
<ul class="pcalibre ul_none pcalibre1" id="P7000497027000000000000000045DE4" data-uri="chapter09.xhtml#P7000497027000000000000000045DE4">
<li id="P7000497027000000000000000045DE5" data-uri="chapter09.xhtml#P7000497027000000000000000045DE5" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DE6" data-uri="chapter09.xhtml#P7000497027000000000000000045DE6" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">PROT_EXEC. </span>Pages in the area consist of instructions that may be executed by the CPU.</p></li>
<li id="P7000497027000000000000000045DE7" data-uri="chapter09.xhtml#P7000497027000000000000000045DE7" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DE8" data-uri="chapter09.xhtml#P7000497027000000000000000045DE8" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">PROT_READ. </span>Pages in the area may be read.</p></li>
<li id="P7000497027000000000000000045DE9" data-uri="chapter09.xhtml#P7000497027000000000000000045DE9" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DEA" data-uri="chapter09.xhtml#P7000497027000000000000000045DEA" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">PROT_WRITE. </span>Pages in the area may be written.</p></li>
<li id="P7000497027000000000000000045DEB" data-uri="chapter09.xhtml#P7000497027000000000000000045DEB" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045DEC" data-uri="chapter09.xhtml#P7000497027000000000000000045DEC" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">PROT_NONE. </span>Pages in the area cannot be accessed.</p></li>
</ul>
<p id="P7000497027000000000000000045DED" data-uri="chapter09.xhtml#P7000497027000000000000000045DED" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045DEE" data-uri="chapter09.xhtml#P7000497027000000000000000045DEE" class="pcalibre1 calibre8 pcalibre">flags</code> argument consists of bits that describe the type of the mapped object. If the MAP_ANON flag bit is set, then the backing store is an anonymous object and the corresponding virtual pages are demand-zero. MAP_PRIVATE indicates a private copy-on-write object, and MAP_SHARED indicates a shared object. For example,</p>
<pre id="P7000497027000000000000000045DEF" data-uri="chapter09.xhtml#P7000497027000000000000000045DEF" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045DF0" data-uri="chapter09.xhtml#P7000497027000000000000000045DF0" class="calibre10 pcalibre pcalibre1">
bufp = Mmap(NULL, size, PROT_READ, MAP_PRIVATEIMAP_ANON, 0, 0);
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045DF1" data-uri="chapter09.xhtml#P7000497027000000000000000045DF1"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007329" title="839" data-uri="chapter09.xhtml#P7000497027000000000000000007329" epub:type="pagebreak"></span>asks the kernel to create a new read-only, private, demand-zero area of virtual memory containing size bytes. If the call is successful, then <code id="P7000497027000000000000000045DF2" data-uri="chapter09.xhtml#P7000497027000000000000000045DF2" class="pcalibre1 calibre8 pcalibre">bufp</code> contains the address of the new area.</p>
<p id="P7000497027000000000000000045DF3" data-uri="chapter09.xhtml#P7000497027000000000000000045DF3" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045DF4" data-uri="chapter09.xhtml#P7000497027000000000000000045DF4" class="pcalibre1 calibre8 pcalibre">munmap</code> function deletes regions of virtual memory:</p>
<pre id="P7000497027000000000000000045DF5" data-uri="chapter09.xhtml#P7000497027000000000000000045DF5" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045DF6" data-uri="chapter09.xhtml#P7000497027000000000000000045DF6" class="calibre10 pcalibre pcalibre1">
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

int munmap(void *start, size_t length);
											Returns: 0 if OK, –1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045DF7" data-uri="chapter09.xhtml#P7000497027000000000000000045DF7">The <code id="P7000497027000000000000000045DF8" data-uri="chapter09.xhtml#P7000497027000000000000000045DF8" class="pcalibre1 calibre8 pcalibre">munmap</code> function deletes the area starting at virtual address <code id="P7000497027000000000000000045DF9" data-uri="chapter09.xhtml#P7000497027000000000000000045DF9" class="pcalibre1 calibre8 pcalibre">start</code> and consisting of the next <code id="P7000497027000000000000000045DFA" data-uri="chapter09.xhtml#P7000497027000000000000000045DFA" class="pcalibre1 calibre8 pcalibre">length</code> bytes. Subsequent references to the deleted region result in segmentation faults.</p>
<section id="P7000497027000000000000000007333" data-uri="chapter09.xhtml#P7000497027000000000000000007333" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045DFB" data-uri="chapter09.xhtml#P7000497027000000000000000045DFB" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">9.5 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P70004970270000000000000000077D5">882</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000045DFC" data-uri="chapter09.xhtml#P7000497027000000000000000045DFC">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000045DFD" data-uri="chapter09.xhtml#P7000497027000000000000000045DFD">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045DFE" data-uri="chapter09.xhtml#P7000497027000000000000000045DFE"><p id="P7000497027000000000000000045DFF" data-uri="chapter09.xhtml#P7000497027000000000000000045DFF" class="pcalibre calibre3 pcalibre1">Write a C program <code id="P7000497027000000000000000045E00" data-uri="chapter09.xhtml#P7000497027000000000000000045E00" class="pcalibre1 calibre8 pcalibre">mmapcopy.c</code> that uses <code id="P7000497027000000000000000045E01" data-uri="chapter09.xhtml#P7000497027000000000000000045E01" class="pcalibre1 calibre8 pcalibre">mmap</code> to copy an arbitrary-size disk file to <code id="P7000497027000000000000000045E02" data-uri="chapter09.xhtml#P7000497027000000000000000045E02" class="pcalibre1 calibre8 pcalibre">stdout</code>. The name of the input file should be passed as a command-line argument.</p></div></li></ol>
</section>
</section>
</section></body></html>
