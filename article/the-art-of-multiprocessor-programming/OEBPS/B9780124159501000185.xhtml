<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 183" epub:type="pagebreak" id="page_183" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 8: Monitors and blocking synchronization</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter introduces monitors, a structured way to encapsulate data, methods, and synchronization in a single modular package. It illustrates how to use monitors to implement basic synchronization mechanisms such as readers-writers locks and semaphores.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">monitors; condition variables; lost wakeups; readers–writers lock; semaphore; reentrant locks</p></section></header><section><h2 class="h1hd" id="s0010"><a id="st0020"/>8.1 Introduction</h2><p class="textfl" id="p0010">A <i>monitor</i> is a structured way of combining synchronization and data, encapsulating data, methods, and synchronization in a single modular package in the same way that a class encapsulates data and methods.</p><p class="text" id="p0015">Here is why modular synchronization is important: Imagine an application with two threads, a producer and a consumer, that communicate through a shared FIFO queue. The threads might share two objects: an unsynchronized queue and a lock to protect the queue. The producer might look something like this:</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" class="img" height="93" src="images/B9780124159501000185/fx001.jpg" width="100"/></figure></div><p class="textfl"> This is no way to run a railroad! Suppose the queue is bounded, meaning that an attempt to add an item to a full queue cannot proceed until the queue has room. Here, the decision whether to block the call or to let it proceed depends on the queue's internal state, which is (and should be) inaccessible to the caller. Moreover, suppose the application grows to have multiple producers, consumers, or both. Each such thread must keep track of both the lock and the queue objects, and the application will be correct only if every thread follows the same locking conventions.</p><p class="text" id="p0020">A more sensible approach is to allow each queue to manage its own synchronization. The queue itself has its own internal lock, acquired by each method when it is called and released when it returns. There is no need to ensure that every thread that uses the queue follows a cumbersome synchronization protocol. If a thread tries to enqueue an item to a queue that is already full, then the <img alt="Image" height="9" src="images/B9780124159501000185/fx002.jpg" width="19"/>() method itself can detect the problem, suspend the caller, and resume the caller when the queue has room.<span aria-label="Page 184" epub:type="pagebreak" id="page_184" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>8.2 Monitor locks and conditions</h2><p class="textfl" id="p0025">As in Chapters <a href="B9780124159501000112.xhtml">2</a> and <a href="B9780124159501000173.xhtml">7</a>, a lock is the basic mechanism for ensuring mutual exclusion. Only one thread at a time can <i>hold</i> a lock. A thread <i>acquires</i> a lock when it first starts to hold the lock. A thread <i>releases</i> a lock when it stops holding the lock. A monitor exports a collection of methods, each of which acquires the lock when it is called, and releases it when it returns.</p><p class="text" id="p0030">If a thread must wait for some condition to hold, it can either <i>spin</i>, repeatedly testing for the desired condition, or <i>block</i>, giving up the processor for a while to allow another thread to run.<sup><a epub:type="noteref" href="#fn001" id="cf0010" role="doc-noteref">1</a></sup> Spinning makes sense on a multiprocessor if we expect to wait for a short time, because blocking a thread requires an expensive call to the operating system. On the other hand, blocking makes sense if we expect to wait for a long time, because a spinning thread keeps a processor busy without doing any work.</p><p class="text" id="p0035">For example, a thread waiting for another thread to release a lock should spin if that particular lock is held briefly, while a consumer thread waiting to dequeue an item from an empty buffer should block, since there is usually no way to predict how long it may have to wait. Often, it makes sense to combine spinning and blocking: A thread waiting to dequeue an item might spin for a brief duration, and then switch to blocking if the delay appears to be long. Blocking works on both multiprocessors and uniprocessors, while spinning works only on multiprocessors.</p><p class="text" id="p0040">Most of the locks in this book follow the interface shown in <a href="#f0015" id="cf0015">Fig. 8.1</a>. Here is a description of the <img alt="Image" height="9" src="images/B9780124159501000185/fx003.jpg" width="25"/> interface's methods:</p><div><ul><li class="bulllist" id="u0010">•  The <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/>() method blocks the caller until it acquires the lock.</li><li class="bulllist" id="u0015">•  The <img alt="Image" height="11" src="images/B9780124159501000185/fx005.jpg" width="112"/>() method acts like <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/>(), but throws an exception if the thread is interrupted while it is waiting (see Pragma <a href="#enun0010" id="cf0020">8.2.1</a>).</li><li class="bulllist" id="u0020">•  The <img alt="Image" height="9" src="images/B9780124159501000185/fx006.jpg" width="39"/>() method releases the lock.</li><li class="bulllist" id="u0025">•  The <img alt="Image" height="9" src="images/B9780124159501000185/fx007.jpg" width="78"/>() method is a <i>factory</i> that creates and returns a <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/> object associated with the lock (explained in Section <a href="#s0020" id="cf0025">8.2.1</a>).</li><li class="bulllist" id="u0030">•  The <img alt="Image" height="11" src="images/B9780124159501000185/fx009.jpg" width="46"/>() method acquires the lock if it is free, and immediately returns a Boolean indicating whether it acquired the lock. This method can also be called with a timeout. <span aria-label="Page 185" epub:type="pagebreak" id="page_185" role="doc-pagebreak"/></li></ul></div><p class="textfl"/><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="125" src="images/B9780124159501000185/gr001.jpg" width="359"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.1</span> The <img alt="Image" height="9" src="images/B9780124159501000185/fx003.jpg" width="25"/> interface.</div></figcaption></figure></div><section><h3 class="h2hd" id="s0020"><a id="st0030"/>8.2.1 Conditions</h3><p class="textfl" id="p0070">While a thread is waiting for something to happen, say, for another thread to place an item in a queue, it must release the lock on the queue; otherwise, the other thread will never be able to enqueue the anticipated item. After the waiting thread has released the lock, we need a way to be notify it when to reacquire the lock and try again.</p><p class="text" id="p0075">In the <span class="sans-serif">java.util.concurrent</span> package (and in similar packages such as Pthreads), the ability to release a lock temporarily is provided by a <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/> object associated with a lock. (Conditions are often called <i>condition variables</i> in the literature.) <a href="#f0020" id="cf0030">Fig. 8.2</a> shows how to use the <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/> interface provided in the <span class="sans-serif">java.util.concurrent.locks</span> library. A condition is associated with a lock, and is created by calling that lock's <img alt="Image" height="9" src="images/B9780124159501000185/fx007.jpg" width="78"/>() method. If the thread holding that lock calls the associated condition's <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() method, it releases that lock and suspends itself, giving another thread the opportunity to acquire the lock. When the calling thread awakens, it reacquires the lock, perhaps competing with other threads.</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="175" src="images/B9780124159501000185/gr002.jpg" width="280"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.2</span> How to use <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/> objects.</div></figcaption></figure></div><p class="text" id="p0080">Like locks, <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/> objects must be used in a stylized way. Suppose a thread wants to wait until a certain property holds. The thread tests the property while holding the lock. If the property does not hold, then the thread calls <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() to release the lock and sleep until it is awakened by another thread. Here is the key point: There is no guarantee that the property will hold when the thread awakens. The <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() method can return spuriously (i.e., for no reason), or the thread that signaled the condition may have awakened too many sleeping threads. Whatever the reason, the thread must retest the property, and if it finds the property does not hold at that time, it must call <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() again.</p><p class="text" id="p0085">The <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/> interface in <a href="#f0025" id="cf0035">Fig. 8.3</a> provides several variations of this call, some of which provide the ability to specify a maximum time the caller can be suspended, or whether the thread can be interrupted while it is waiting. When the queue changes, the thread that made the change can notify other threads waiting on a condition. Calling <img alt="Image" height="11" src="images/B9780124159501000185/fx011.jpg" width="36"/>() wakes up one thread waiting on a condition (if there is one), while calling <img alt="Image" height="11" src="images/B9780124159501000185/fx012.jpg" width="56"/>() wakes up all waiting threads.</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="142" src="images/B9780124159501000185/gr003.jpg" width="439"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.3</span> The <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/> interface: <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() and its variants release the lock, and give up the processor, and then later awaken and reacquire the lock. The <img alt="Image" height="11" src="images/B9780124159501000185/fx011.jpg" width="36"/>() and <img alt="Image" height="11" src="images/B9780124159501000185/fx012.jpg" width="56"/>() methods awaken one or more waiting threads.</div></figcaption></figure></div><p class="text" id="p0090"><span aria-label="Page 186" epub:type="pagebreak" id="page_186" role="doc-pagebreak"/></p><div class="boxg1" id="enun0010"><p class="b1num">Pragma 8.2.1 </p><div><p class="b1textfl" id="p0095">Threads in Java can be <i>interrupted</i> by other threads. If a thread is interrupted during a call to a <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/>'s <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() method, the call throws <img alt="Image" height="11" src="images/B9780124159501000185/fx013.jpg" width="131"/>. The proper response to an interrupt is application-dependent. <a href="#f0020" id="cf0040">Fig. 8.2</a> shows a schematic example.</p><p class="b1text" id="p0100">To avoid clutter, we usually omit <img alt="Image" height="11" src="images/B9780124159501000185/fx013.jpg" width="131"/> handlers from example code, even though they would be required in actual code. (It is bad programming practice to ignore interrupts.)</p></div></div><p class="textfl"/><p class="text" id="p0105"><span aria-label="Page 187" epub:type="pagebreak" id="page_187" role="doc-pagebreak"/>This combination of methods, mutual exclusion locks, and condition objects is called a <i>monitor</i>. It is common to talk of threads that have called <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() (and have not yet returned) as being in a “waiting room”. We use this imagery to illustrate an execution of a monitor in <a href="#f0030" id="cf0045">Fig. 8.4</a>.</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="127" src="images/B9780124159501000185/gr004.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.4</span> A schematic representation of a monitor execution. In part (a), thread <i>A</i> has acquired the monitor lock, called <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() on a condition, released the lock, and is now in the waiting room. Thread <i>B</i> then goes through the same sequence of steps, entering the critical section, calling <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() on the condition, relinquishing the lock, and entering the waiting room. In part (b), both <i>A</i> and <i>B</i> leave the waiting room after thread <i>C</i> exits the critical section and calls <img alt="Image" height="11" src="images/B9780124159501000185/fx012.jpg" width="56"/>(). <i>A</i> and <i>B</i> then attempt to reacquire the monitor lock. However, thread <i>D</i> manages to acquire the critical section lock first, and so both <i>A</i> and <i>B</i> spin until <i>D</i> leaves the critical section. Note that if <i>C</i> had issued a <img alt="Image" height="11" src="images/B9780124159501000185/fx011.jpg" width="36"/>() instead of a <img alt="Image" height="11" src="images/B9780124159501000185/fx012.jpg" width="56"/>(), only <i>A</i> or <i>B</i> would have left the waiting room, and the other would have continued to wait.</div></figcaption></figure></div><p class="text" id="p0110"><a href="#f0035" id="cf0050">Fig. 8.5</a> shows how to implement a bounded FIFO queue using explicit locks and conditions. The <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/> field is a lock that must be acquired by all methods. We must initialize it to hold an instance of a class that implements the <img alt="Image" height="9" src="images/B9780124159501000185/fx003.jpg" width="25"/> interface. Here, we choose <img alt="Image" height="9" src="images/B9780124159501000185/fx015.jpg" width="86"/>, a useful lock type provided by the <span class="sans-serif">java.util.concurrent.locks</span> package. This lock is <i>reentrant</i>: A thread that is holding the lock can acquire it again without blocking. (See Section <a href="#s0045" id="cf0055">8.4</a> for more discussion on reentrant locks.)</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="635" src="images/B9780124159501000185/gr005.jpg" width="316"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.5</span> The <img alt="Image" height="11" src="images/B9780124159501000185/fx014.jpg" width="72"/> class: a FIFO queue using locks and conditions. There are two condition fields, one to detect when the queue becomes nonempty, and one to detect when it becomes nonfull.</div></figcaption></figure></div><p class="text" id="p0115">There are two condition objects: <img alt="Image" height="11" src="images/B9780124159501000185/fx016.jpg" width="52"/> notifies waiting dequeuers when the queue goes from being empty to nonempty, and <img alt="Image" height="9" src="images/B9780124159501000185/fx017.jpg" width="43"/> for the opposite direction. Although using two conditions instead of one is more complex, it is more efficient, since fewer threads are woken up unnecessarily.</p></section><section><h3 class="h2hd" id="s0025"><a id="st0035"/>8.2.2 The lost-wakeup problem</h3><p class="textfl" id="p0120">Just as locks are inherently vulnerable to deadlock, <img alt="Image" height="9" src="images/B9780124159501000185/fx008.jpg" width="59"/> objects are inherently vulnerable to <i>lost wakeups</i>, in which one or more threads wait forever without realizing that the condition for which they are waiting has become true.</p><p class="text" id="p0125">Lost wakeups can occur in subtle ways. <a href="#f0040" id="cf0060">Fig. 8.6</a> shows an ill-considered optimization of the <img alt="Image" height="11" src="images/B9780124159501000185/fx018.jpg" width="52"/> class. Instead of signaling the <img alt="Image" height="11" src="images/B9780124159501000185/fx016.jpg" width="52"/> condition each time <img alt="Image" height="9" src="images/B9780124159501000185/fx002.jpg" width="19"/>() enqueues an item, would it not be more efficient to signal the condition only when the queue actually transitions from empty to nonempty? This optimization works as intended if there is only one producer and one consumer, but it is incorrect if there are multiple producers or consumers. Consider the following scenario: Consumers <i>A</i> and <i>B</i> both try to dequeue an item from an empty queue, both detect the queue is empty, and both block on the <img alt="Image" height="11" src="images/B9780124159501000185/fx016.jpg" width="52"/> condition. Producer <i>C</i> enqueues an item in the buffer, and signals <img alt="Image" height="11" src="images/B9780124159501000185/fx016.jpg" width="52"/>, waking <i>A</i>. Before <i>A</i> can acquire the lock, however, another producer <i>D</i> puts a second item in the queue, and because the queue is not empty, it does not signal <img alt="Image" height="11" src="images/B9780124159501000185/fx016.jpg" width="52"/>. Then <i>A</i> acquires the lock and removes the first item, but <i>B</i>, victim of a lost wakeup, waits forever, even though there is an item in the queue to be consumed.</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="257" src="images/B9780124159501000185/gr006.jpg" width="227"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.6</span> This example is <i>incorrect</i>. It suffers from lost wakeups. The <img alt="Image" height="9" src="images/B9780124159501000185/fx002.jpg" width="19"/>() method signals <img alt="Image" height="11" src="images/B9780124159501000185/fx016.jpg" width="52"/> only if it is the first to place an item in an empty buffer. A lost wakeup occurs if multiple consumers are waiting, but only the first is awakened to consume an item.</div></figcaption></figure></div><p class="text" id="p0130">Although there is no substitute for reasoning carefully about our program, there are simple programming practices that minimize vulnerability to lost wakeups.</p><div><ul><li class="bulllist" id="u0035">•  Always signal <i>all</i> processes waiting on a condition, not just one.</li><li class="bulllist" id="u0040">•  Specify a timeout when waiting.</li></ul></div><p class="textfl"> Either of these two practices would fix the bounded queue error we just described. Each has a small performance penalty, but negligible compared to the cost of a lost wakeup.</p><p class="text" id="p0145">Java provides support for monitors in the form of <img alt="Image" height="11" src="images/B9780124159501000185/fx019.jpg" width="79"/> blocks and methods, and built-in <img alt="Image" height="9" src="images/B9780124159501000185/fx020.jpg" width="26"/>(), <img alt="Image" height="11" src="images/B9780124159501000185/fx021.jpg" width="39"/>(), and <img alt="Image" height="11" src="images/B9780124159501000185/fx022.jpg" width="56"/>() methods (see Appendix <a href="B9780124159501000318.xhtml">A</a>).<span aria-label="Page 188" epub:type="pagebreak" id="page_188" role="doc-pagebreak"/><span aria-label="Page 189" epub:type="pagebreak" id="page_189" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0030"><a id="st0040"/>8.3 Readers–writers locks</h2><p class="textfl" id="p0150">Many shared objects have the property that most method calls return information about the object's state without modifying the object, and relatively few calls actually modify the object. We call method calls of the first kind <i>readers</i>, and method calls of the latter kind <i>writers</i>.</p><p class="text" id="p0155">Readers need not synchronize with one another; it is perfectly safe for them to access the object concurrently. Writers, on the other hand, must lock out readers as well as other writers. A <i>readers–writers lock</i> allows multiple readers or a single writer to enter the critical section concurrently. We use the following interface:</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" class="img" height="60" src="images/B9780124159501000185/fx023.jpg" width="191"/></figure></div><p class="textfl"/><p class="text" id="p0160">This interface exports two lock objects: the <i>read lock</i> and the <i>write lock</i>. They satisfy the following safety properties:</p><div><ul><li class="bulllist" id="u0045">•  No thread can acquire the write lock while any thread holds either the write lock or the read lock.</li><li class="bulllist" id="u0050">•  No thread can acquire the read lock while any thread holds the write lock.</li></ul></div><p class="textfl"> Naturally, multiple threads may hold the read lock at the same time.</p><p class="text" id="p0175">We now consider two readers–writers lock implementations.</p><section><h3 class="h2hd" id="s0035"><a id="st0045"/>8.3.1 Simple readers–writers lock</h3><p class="textfl" id="p0180"><span aria-label="Page 190" epub:type="pagebreak" id="page_190" role="doc-pagebreak"/>The <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> class appears in <a href="#f0050" id="cs0010">Figs. 8.7</a> and <a href="#f0055">8.8</a>. To define the associated read and write locks, this code uses <i>inner classes</i>, a Java feature that allows an object to create other objects that can access the first object's private fields. The <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> object has fields that keep track of the number of readers that hold the lock and whether a writer holds the lock; the read lock and write lock use these fields to guarantee the readers–writers lock properties. To allow the methods of the read lock and the write lock to synchronize access to these fields, the class also maintains a private <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/> and a <img alt="Image" height="9" src="images/B9780124159501000185/fx025.jpg" width="58"/> associated with that lock.</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="355" src="images/B9780124159501000185/gr007.jpg" width="378"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.7</span> The <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> class: fields and public methods.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="700" src="images/B9780124159501000185/gr008.jpg" width="291"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.8</span> The <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> class: the inner read and write locks classes.</div></figcaption></figure></div><p class="text" id="p0185">How are waiting writers notified when the last reader releases its lock? When a writer tries to acquire the write lock, it acquires <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/> (i.e., the <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> object's private lock), and if any readers (or another writer) hold the lock, it waits on <img alt="Image" height="9" src="images/B9780124159501000185/fx025.jpg" width="58"/>. A reader releasing the read lock also acquires <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/>, and signals <img alt="Image" height="9" src="images/B9780124159501000185/fx025.jpg" width="58"/> if all readers have released their locks. Similarly, readers that try to acquire the lock while a writer holds it wait on <img alt="Image" height="9" src="images/B9780124159501000185/fx025.jpg" width="58"/>, and writers releasing the lock signal <img alt="Image" height="9" src="images/B9780124159501000185/fx025.jpg" width="58"/> to notify waiting readers and writers.</p><p class="text" id="p0190">Although the <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> algorithm is correct, it is not quite satisfactory. If readers are much more frequent than writers, as is usually the case, then writers could be locked out indefinitely by a continual stream of <span aria-label="Page 191" epub:type="pagebreak" id="page_191" role="doc-pagebreak"/>readers.<span aria-label="Page 192" epub:type="pagebreak" id="page_192" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0040"><a id="st0050"/>8.3.2 Fair readers–writers lock</h3><p class="textfl" id="p0195">The <img alt="Image" height="9" src="images/B9780124159501000185/fx026.jpg" width="112"/> class (<a href="#f0060" id="cs0015">Figs. 8.9</a> and <a href="#f0065">8.10</a>) shows one way to prevent writers from being starved by a continual stream of readers. This class ensures that once a writer calls the write lock's <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/>() method, no more readers will acquire the read lock until the writer has acquired and released the write lock. Eventually, the readers holding the read lock will drain out without letting any more readers in, and the writer can acquire the write lock.</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="355" src="images/B9780124159501000185/gr009.jpg" width="365"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.9</span> The <img alt="Image" height="9" src="images/B9780124159501000185/fx026.jpg" width="112"/> class: fields and public methods.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="734" src="images/B9780124159501000185/gr010.jpg" width="281"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.10</span> The <img alt="Image" height="9" src="images/B9780124159501000185/fx026.jpg" width="112"/> class: inner read and write lock classes.</div></figcaption></figure></div><p class="text" id="p0200">The <img alt="Image" height="11" src="images/B9780124159501000185/fx027.jpg" width="78"/> field counts the total number of read-lock acquisitions, and the <img alt="Image" height="9" src="images/B9780124159501000185/fx028.jpg" width="78"/> field counts the total number of read-lock releases. When these quantities match, no thread is holding the read lock. (For simplicity, we are ignoring potential integer overflow and wraparound problems.) As in the <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> class, the <img alt="Image" height="9" src="images/B9780124159501000185/fx026.jpg" width="112"/> class has private <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000185/fx025.jpg" width="58"/> fields that the methods of the read lock and write lock use to synchronize accesses to the other fields of <img alt="Image" height="9" src="images/B9780124159501000185/fx026.jpg" width="112"/>. The difference is that in <img alt="Image" height="9" src="images/B9780124159501000185/fx026.jpg" width="112"/>, a thread attempting to acquire the writer lock sets the <img alt="Image" height="9" src="images/B9780124159501000185/fx029.jpg" width="39"/> flag even if readers hold the lock. If a writer holds the lock, however, it waits for the writer to release the lock, and unset the <img alt="Image" height="9" src="images/B9780124159501000185/fx029.jpg" width="39"/> flag, before proceeding. That is, the thread first waits until no writer holds the lock, then sets <img alt="Image" height="9" src="images/B9780124159501000185/fx029.jpg" width="39"/>, and then waits until no reader holds the lock (lines 49–53).<span aria-label="Page 193" epub:type="pagebreak" id="page_193" role="doc-pagebreak"/><span aria-label="Page 194" epub:type="pagebreak" id="page_194" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>8.4 Our own reentrant lock</h2><p class="textfl" id="p0205">Using the locks described in Chapters <a href="B9780124159501000112.xhtml">2</a> and <a href="B9780124159501000173.xhtml">7</a>, a thread that attempts to reacquire a lock it already holds will deadlock with itself. This situation can arise if a method that acquires a lock makes a nested call to another method that acquires the same lock.</p><p class="text" id="p0210">A lock is <i>reentrant</i> if it can be acquired multiple times by the same thread. We now examine how to create a reentrant lock from a nonreentrant lock. This exercise is intended to illustrate how to use locks and conditions. The <span class="sans-serif">java.util.concurrent.locks</span> package provides reentrant lock classes, so in practice there is no need to write our own.</p><p class="text" id="p0215"><a href="#f0070" id="cf0065">Fig. 8.11</a> shows the <img alt="Image" height="11" src="images/B9780124159501000185/fx030.jpg" width="127"/> class. The <img alt="Image" height="6" src="images/B9780124159501000185/fx031.jpg" width="32"/> field holds the ID of the last thread to acquire the lock, and the <img alt="Image" height="9" src="images/B9780124159501000185/fx032.jpg" width="59"/> field is incremented each time the lock is acquired, and decremented each time it is released. The lock is free when the <img alt="Image" height="9" src="images/B9780124159501000185/fx032.jpg" width="59"/> value is zero. Because these two fields are manipulated atomically, we need an internal, short-term lock. The <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/> field is a lock used by <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000185/fx006.jpg" width="39"/>() to manipulate the fields, and the <img alt="Image" height="9" src="images/B9780124159501000185/fx025.jpg" width="58"/> field is used by threads waiting for the lock to become free. We initialize the internal <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/> field to an object of a (fictitious) <img alt="Image" height="11" src="images/B9780124159501000185/fx033.jpg" width="66"/> class, which is presumably not reentrant (line 6).</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="684" src="images/B9780124159501000185/gr011.jpg" width="331"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.11</span> The <img alt="Image" height="11" src="images/B9780124159501000185/fx030.jpg" width="127"/> class: <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000185/fx006.jpg" width="39"/>() methods.</div></figcaption></figure></div><p class="text" id="p0220">The <img alt="Image" height="9" src="images/B9780124159501000185/fx004.jpg" width="25"/>() method acquires the internal lock (line 13). If the current thread is already the owner, it increments the hold count and returns (line 15). Otherwise, if the hold count is not zero, the lock is held by another thread, and the caller releases the internal lock and waits until the condition is signaled (line 20). When the caller awakens, it must still check whether the hold count is zero. If it is, the calling thread makes itself the owner and sets the hold count to 1.</p><p class="text" id="p0225">The <img alt="Image" height="9" src="images/B9780124159501000185/fx006.jpg" width="39"/>() method acquires the internal lock (line 29). It throws an exception if either the lock is free, or the caller is not the owner (line 31). Otherwise, it decrements the hold count. If the hold count is zero, then the lock is free, so the caller signals the condition to wake up a waiting thread (line 35).</p></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>8.5 Semaphores</h2><p class="textfl" id="p0230">As we have seen, a mutual exclusion lock guarantees that only one thread at a time can enter a critical section. If another thread wants to enter the critical section while it is occupied, then it blocks, suspending itself until another thread notifies it to try again. One of the earliest forms of synchronization, a <i>semaphore</i> is a generalization of the mutual exclusion lock. Each semaphore has a <i>capacity</i> that is determined when the semaphore is initialized. Instead of allowing only one thread at a time into the critical section, a semaphore allows at most <i>c</i> threads, where <i>c</i> is its capacity.</p><p class="text" id="p0235">The <img alt="Image" height="11" src="images/B9780124159501000185/fx034.jpg" width="59"/> class of <a href="#f0075" id="cf0070">Fig. 8.12</a> provides two methods: A thread calls <img alt="Image" height="11" src="images/B9780124159501000185/fx035.jpg" width="45"/>() to request permission to enter the critical section, and <img alt="Image" height="9" src="images/B9780124159501000185/fx036.jpg" width="45"/>() to announce that it is leaving the critical section. The <img alt="Image" height="11" src="images/B9780124159501000185/fx034.jpg" width="59"/> itself is just a counter: It keeps track of the number of threads that have been granted permission to enter. If a new <img alt="Image" height="11" src="images/B9780124159501000185/fx035.jpg" width="45"/>() call is about to exceed the capacity, the calling thread is suspended until there is room. When a thread calls <img alt="Image" height="9" src="images/B9780124159501000185/fx036.jpg" width="45"/>() after leaving the critical section, it signals to notify any waiting thread that there is now <span aria-label="Page 195" epub:type="pagebreak" id="page_195" role="doc-pagebreak"/>room.<span aria-label="Page 196" epub:type="pagebreak" id="page_196" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="520" src="images/B9780124159501000185/gr012.jpg" width="236"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.12</span> Semaphore implementation.</div></figcaption></figure></div></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>8.6 Chapter notes</h2><p class="textfl" id="p0240">Monitors were invented by Per Brinch-Hansen <a epub:type="noteref" href="#br0285" id="cf0075" role="doc-noteref">[57]</a> and Tony Hoare <a epub:type="noteref" href="#br0385" id="cf0080" role="doc-noteref">[77]</a>. Semaphores were invented by Edsger Dijkstra <a epub:type="noteref" href="#br0190" id="cf0085" role="doc-noteref">[38]</a>. McKenney <a epub:type="noteref" href="#br0610" id="cf0090" role="doc-noteref">[122]</a> surveys different kinds of locking protocols.<span aria-label="Page 197" epub:type="pagebreak" id="page_197" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0060"><a id="st0070"/>8.7 Exercises</h2><p class="textfl" id="p0245"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 8.1 </p><div><p class="b1textfl" id="p0250">Reimplement the <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> class using Java <span class="inlinecode"><b>synchronized</b></span>, <img alt="Image" height="9" src="images/B9780124159501000185/fx020.jpg" width="26"/>(), <img alt="Image" height="11" src="images/B9780124159501000185/fx021.jpg" width="39"/>(), and <img alt="Image" height="11" src="images/B9780124159501000185/fx022.jpg" width="56"/>() constructs in place of explicit locks and conditions.</p><p class="b1text" id="p0255">Hint: You must figure out how methods of the inner read and write lock classes can lock the outer <img alt="Image" height="11" src="images/B9780124159501000185/fx024.jpg" width="127"/> object.</p></div></div><p class="textfl"/><p class="text" id="p0260"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 8.2 </p><div><p class="b1textfl" id="p0265">Design a “nested” readers–writers lock in which a thread must first grab the read lock in order to grab the write lock, and releasing the write lock does not release the read lock. In order for a reader to become a writer with exclusive write access, every other reader must either unlock the read lock or also attempt to lock the write lock. Show that your implementation is correct and has a reasonable fairness guarantee between readers and writers.</p></div></div><p class="textfl"/><p class="text" id="p0270"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 8.3 </p><div><p class="b1textfl" id="p0275">Read–write locks are fundamentally asymmetric in that many readers can enter at once but only one writer can enter. Design a symmetric locking protocol for two types of threads: <span class="sans-serif">RED</span> and <span class="sans-serif">BLUE</span>. For correctness, never allow a <span class="sans-serif">RED</span> and <span class="sans-serif">BLUE</span> thread to enter simultaneously. For progress, allow for multiple <span class="sans-serif">RED</span> threads or multiple <span class="sans-serif">BLUE</span> threads to enter at once, and have a symmetric fairness mechanism for draining <span class="sans-serif">RED</span> threads to allow waiting <span class="sans-serif">BLUE</span> threads to enter, and vice versa. Show that your implementation is correct, and describe the exact fairness property it guarantees and why you chose to use it.</p></div></div><p class="textfl"/><p class="text" id="p0280"/><div class="boxg1" id="enun0030"><p class="b1num">Exercise 8.4 </p><div><p class="b1textfl" id="p0285">The <img alt="Image" height="9" src="images/B9780124159501000185/fx037.jpg" width="146"/> class provided by the <span class="sans-serif">java.util.concurrent.locks</span> package does not allow a thread holding the lock in read mode to then access that lock in write mode (the thread will block). Justify this design decision by sketching what it would take to permit such lock upgrades.</p></div></div><p class="textfl"/><p class="text" id="p0290"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 8.5 </p><div><p class="b1textfl" id="p0295">A <i>savings account</i> object holds a nonnegative balance, and provides <img alt="Image" height="11" src="images/B9780124159501000185/fx038.jpg" width="46"/>(<i>k</i>) and <img alt="Image" height="9" src="images/B9780124159501000185/fx039.jpg" width="53"/>(<i>k</i>) methods, where <img alt="Image" height="11" src="images/B9780124159501000185/fx038.jpg" width="46"/>(<i>k</i>) adds <i>k</i> to the balance, and <img alt="Image" height="9" src="images/B9780124159501000185/fx039.jpg" width="53"/>(<i>k</i>) subtracts <i>k</i>, if the balance is at least <i>k</i>, and otherwise blocks until the balance becomes <i>k</i> or greater.</p><div><ol><li class="b1numlist" id="o0010">1.  Implement this savings account using locks and conditions.</li><li class="b1numlist" id="o0015">2.  Now suppose there are two kinds of withdrawals: <i>ordinary</i> and <i>preferred</i>. Devise an implementation that ensures that no ordinary withdrawal occurs if there is a preferred withdrawal waiting to occur.</li><li class="b1numlist" id="o0020">3.  Now add a <img alt="Image" height="9" src="images/B9780124159501000185/fx040.jpg" width="52"/>() method that transfers a sum from one account to another:</li></ol><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" class="img" height="142" src="images/B9780124159501000185/fx041.jpg" width="233"/></figure></div><ol><li class="b1numlist"><span aria-label="Page 198" epub:type="pagebreak" id="page_198" role="doc-pagebreak"/> We are given a set of 10 accounts, whose balances are unknown. At 1:00pm, each of <i>n</i> threads tries to transfer $100 from another account into its own account. At 2:00pm, a boss thread deposits $1000 to each account. Is every transfer method called at 1:00pm certain to return?</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0315"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 8.6 </p><div><p class="b1textfl" id="p0320">In the <i>shared-bathroom problem</i>, there are two classes of threads, called <img alt="Image" height="9" src="images/B9780124159501000185/fx042.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000185/fx043.jpg" width="38"/>. There is a single <img alt="Image" height="9" src="images/B9780124159501000185/fx044.jpg" width="52"/> resource that must be used in the following way:</p><div><ol><li class="b1numlist" id="o0025">1.  Mutual exclusion: persons of opposite sex may not occupy the bathroom simultaneously.</li><li class="b1numlist" id="o0030">2.  Weak starvation-freedom: Assuming that eventually there will be both a male and a female who want to use the bathroom, then everyone who needs to use the bathroom eventually enters.</li></ol></div><p class="b1textfl"/><p class="b1text" id="p0335">The protocol specifies the following four procedures: <img alt="Image" height="9" src="images/B9780124159501000185/fx045.jpg" width="59"/>() delays the caller until a male can enter the bathroom, and <img alt="Image" height="9" src="images/B9780124159501000185/fx046.jpg" width="58"/>() is called when a male leaves the bathroom, while <img alt="Image" height="9" src="images/B9780124159501000185/fx047.jpg" width="72"/>() and <img alt="Image" height="9" src="images/B9780124159501000185/fx048.jpg" width="72"/>() do the same for females. For example,</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" class="img" height="43" src="images/B9780124159501000185/fx049.jpg" width="143"/></figure></div><p class="textfl"> Implement this class using locks and condition variables. Explain why your implementation satisfies mutual exclusion and weak starvation-freedom.</p></div></div><p class="textfl"/><p class="text" id="p0340"/><div class="boxg1" id="enun0045"><p class="b1num">Exercise 8.7 </p><div><p class="b1textfl" id="p0345">The <img alt="Image" height="9" src="images/B9780124159501000185/fx050.jpg" width="31"/> class manages a collection of <i>rooms</i>, indexed from 0 to <span class="hiddenClass"><mml:math><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000185/si1.png" style="vertical-align:middle" width="40"/></span> (<i>m</i> is an argument to the constructor). Threads can enter or exit any room in that range. Each room can hold an arbitrary number of threads simultaneously, but only one room can be occupied at a time. For example, if there are two rooms, indexed 0 and 1, then any number of threads might enter room 0, but no thread can enter room 1 while room 0 is occupied. <a href="#f0090" id="cf0095">Fig. 8.13</a> shows an outline of the <img alt="Image" height="9" src="images/B9780124159501000185/fx050.jpg" width="31"/> class.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="129" src="images/B9780124159501000185/gr013.jpg" width="344"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.13</span> The <img alt="Image" height="9" src="images/B9780124159501000185/fx050.jpg" width="31"/> class.</div></figcaption></figure></div><p class="b1text" id="p0350">Each room can be assigned an <i>exit handler</i>: Calling <img alt="Image" height="9" src="images/B9780124159501000185/fx051.jpg" width="92"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000185/si2.png" style="vertical-align:middle" width="34"/></span> sets the exit handler for room <i>i</i> to handler <i>h</i>. <span aria-label="Page 199" epub:type="pagebreak" id="page_199" role="doc-pagebreak"/>The exit handler is called by the last thread to leave a room, but before any threads subsequently enter any room. This method is called once per room and while it is running, no threads are in any rooms.</p><p class="b1text" id="p0355">Implement the <img alt="Image" height="9" src="images/B9780124159501000185/fx050.jpg" width="31"/> class. Make sure that:</p><div><ul><li class="b1bulllist" id="u0055">•  If some thread is in room <i>i</i>, then no thread is in room <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000185/si3.png" style="vertical-align:middle" width="34"/></span>.</li><li class="b1bulllist" id="u0060">•  The last thread to leave a room calls the room's exit handler, and no threads are in any room while that handler is running.</li><li class="b1bulllist" id="u0065">•  Your implementation is <i>fair</i>: Any thread that tries to enter a room eventually succeeds. (You may assume that every thread that enters a room eventually leaves.)</li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0375"/><div class="boxg1" id="enun0050"><p class="b1num">Exercise 8.8 </p><div><p class="b1textfl" id="p0380">Consider an application with distinct sets of <i>active</i> and <i>passive</i> threads, where we want to block the passive threads until every active thread has given permission for the passive threads to proceed.</p><p class="b1text" id="p0385">A <img alt="Image" height="9" src="images/B9780124159501000185/fx052.jpg" width="92"/> encapsulates a counter, initialized to the number <i>n</i> of active threads. An active thread gives permission for the passive threads to run by calling <img alt="Image" height="12" src="images/B9780124159501000185/fx053.jpg" width="70"/>, which decrements the counter. Each passive thread calls <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>(), which blocks the thread until the counter reaches zero (<a href="#f0095" id="cf0100">Fig. 8.14</a>).</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="368" src="images/B9780124159501000185/gr014.jpg" width="400"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.14</span> The <img alt="Image" height="9" src="images/B9780124159501000185/fx052.jpg" width="92"/> class: an example usage.</div></figcaption></figure></div><p class="b1text" id="p0390">Provide a <img alt="Image" height="9" src="images/B9780124159501000185/fx052.jpg" width="92"/> implementation. Do not worry about reusing the <img alt="Image" height="9" src="images/B9780124159501000185/fx052.jpg" width="92"/> object.</p></div></div><p class="textfl"/><p class="text" id="p0395"><span aria-label="Page 200" epub:type="pagebreak" id="page_200" role="doc-pagebreak"/></p><div class="boxg1" id="enun0055"><p class="b1num">Exercise 8.9 </p><div><p class="b1textfl" id="p0400">This exercise is a followup to <a href="#enun0050" id="cf0105">Exercise 8.8</a>. Provide a <img alt="Image" height="9" src="images/B9780124159501000185/fx052.jpg" width="92"/> implementation where the <img alt="Image" height="9" src="images/B9780124159501000185/fx052.jpg" width="92"/> object can be reused.</p></div></div><p class="textfl"/><p class="text" id="p0405"/><div class="boxg1" id="enun0060"><p class="b1num">Exercise 8.10 </p><div><p class="b1textfl" id="p0410"><a href="#f0100" id="cf0110">Fig. 8.15</a> shows a proposed implementation of a <img alt="Image" height="9" src="images/B9780124159501000185/fx054.jpg" width="72"/> class, which runs jobs but limits the “weight” of the jobs started per minute using a <img alt="Image" height="11" src="images/B9780124159501000185/fx055.jpg" width="32"/>, which is increased to <img alt="Image" height="9" src="images/B9780124159501000185/fx056.jpg" width="31"/> every minute by a separate thread. We want to guarantee that jobs will run promptly if there is enough <img alt="Image" height="11" src="images/B9780124159501000185/fx055.jpg" width="32"/>. You may assume a fast processor and fair scheduler, so that the <img alt="Image" height="9" src="images/B9780124159501000185/fx054.jpg" width="72"/> reaches a quiescent state (all jobs are sleeping in <img alt="Image" height="9" src="images/B9780124159501000185/fx010.jpg" width="32"/>() or running), if possible, before each call to <img alt="Image" height="11" src="images/B9780124159501000185/fx057.jpg" width="85"/>().</p><div><ol><li class="b1numlist" id="o0035">a.  Describe the distributions of <img alt="Image" height="11" src="images/B9780124159501000185/fx058.jpg" width="39"/> values (<img alt="Image" height="12" src="images/B9780124159501000185/fx059.jpg" width="119"/>) under which this implementation works or fails and explain why.</li><li class="b1numlist" id="o0040">b.  Fix this implementation so it allows jobs to have any <img alt="Image" height="11" src="images/B9780124159501000185/fx058.jpg" width="39"/> value from 0 to <img alt="Image" height="9" src="images/B9780124159501000185/fx056.jpg" width="31"/>, and describe how it may impact performance.</li></ol></div><p class="b1textfl"/><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="428" src="images/B9780124159501000185/gr015.jpg" width="420"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 8.15</span> A proposed <img alt="Image" height="9" src="images/B9780124159501000185/fx054.jpg" width="72"/> class implementation.</div></figcaption></figure></div></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0410"><h2 class="reftitle" id="st0075">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0190" role="doc-biblioentry">[38] E.W. Dijkstra,  The structure of the THE multiprogramming system,   <cite><i>Communications of the ACM</i></cite> 1968;11(5):341–346.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0285" role="doc-biblioentry">[57] Per Brinch Hansen,  Structured multi-programming,   <cite><i>Communications of the ACM</i></cite> 1972;15(7):574–578.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0385" role="doc-biblioentry">[77] C.A.R. Hoare,  Monitors: an operating system structuring concept,   <cite><i>Communications of the ACM</i></cite> 1974;17(10):549–557.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0610" role="doc-biblioentry">[122] Paul E. McKenney,  Selecting locking primitives for parallel programming,   <cite><i>Communications of the ACM</i></cite> 1996;39(10):75–82.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0010" role="doc-noteref">1 </a></sup> <a id="np0010"/>“In Chapter <a href="B9780124159501000124.xhtml">3</a>, we make a distinction between blocking and nonblocking synchronization algorithms. There, we mean something entirely different: A blocking algorithm is one where a delay by one thread can cause a delay in another. <a href="B9780124159501000124.xhtml">Remark 3.3.1</a> discusses various ways in which the term <i>blocking</i> is used.”</p></div></section></footer></section></body></html>