<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Concurrency</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part258.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part260.htm">下一个 &gt;</a></p><h1 style="padding-left: 21pt;text-indent: 0pt;text-align: center;">Concurrency</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part260.htm">A Dialogue on Concurrency</a><a class="toc0" href="part261.htm">Concurrency: An Introduction</a><a class="toc1" href="part262.htm">26.1 An Example: Thread Creation</a><a class="toc1" href="part263.htm">26.2 Why It Gets Worse: Shared Data</a><a class="toc1" href="part264.htm">26.3 The Heart of the Problem: Uncontrolled Scheduling</a><a class="toc1" href="part265.htm">26.4 The Wish For Atomicity</a><a class="toc1" href="part266.htm">26.5 One More Problem: Waiting For Another</a><a class="toc1" href="part267.htm">26.6 Summary: Why in OS Class?</a><a class="toc1" href="part268.htm">References</a><a class="toc1" href="part269.htm">Homework</a><a class="toc2" href="part270.htm">Questions</a><a class="toc0" href="part271.htm">Interlude: Thread API</a><a class="toc1" href="part272.htm">27.1 Thread Creation</a><a class="toc1" href="part273.htm">27.2 Thread Completion</a><a class="toc1" href="part274.htm">27.3 Locks</a><a class="toc1" href="part275.htm">27.4 Condition Variables</a><a class="toc1" href="part276.htm">27.5 Compiling and Running</a><a class="toc1" href="part277.htm">27.6 Summary</a><a class="toc1" href="part278.htm">References</a><a class="toc0" href="part279.htm">Locks</a><a class="toc1" href="part280.htm">28.1 Locks: The Basic Idea</a><a class="toc1" href="part281.htm">28.2 Pthread Locks</a><a class="toc1" href="part282.htm">28.3 Building A Lock</a><a class="toc1" href="part283.htm">28.4 Evaluating Locks</a><a class="toc1" href="part284.htm">28.5 Controlling Interrupts</a><a class="toc1" href="part285.htm">28.6 Test And Set (Atomic Exchange)</a><a class="toc1" href="part286.htm">28.7 Building A Working Spin Lock</a><a class="toc1" href="part287.htm">28.8 Evaluating Spin Locks</a><a class="toc1" href="part288.htm">28.9 Compare-And-Swap</a><a class="toc1" href="part289.htm">28.10 Load-Linked and Store-Conditional</a><a class="toc1" href="part290.htm">28.11 Fetch-And-Add</a><a class="toc1" href="part291.htm">28.12 Summary: So Much Spinning</a><a class="toc1" href="part292.htm">28.13 A Simple Approach: Just Yield, Baby</a><a class="toc1" href="part293.htm">28.14 Using Queues: Sleeping Instead Of Spinning</a><a class="toc1" href="part294.htm">28.15 Different OS, Different Support</a><a class="toc1" href="part295.htm">28.16 Two-Phase Locks</a><a class="toc1" href="part296.htm">28.17 Summary</a><a class="toc1" href="part297.htm">References</a><a class="toc0" href="part298.htm">Lock-based Concurrent Data Structures</a><a class="toc1" href="part299.htm">29.1 Concurrent Counters</a><a class="toc2" href="part300.htm">Simple But Not Scalable</a><a class="toc2" href="part301.htm">Scalable Counting</a><a class="toc1" href="part302.htm">29.2 Concurrent Linked Lists</a><a class="toc2" href="part303.htm">Scaling Linked Lists</a><a class="toc1" href="part304.htm">29.3 Concurrent Queues</a><a class="toc1" href="part305.htm">29.4 Concurrent Hash Table</a><a class="toc1" href="part306.htm">29.5 Summary</a><a class="toc1" href="part307.htm">References</a><a class="toc0" href="part308.htm">Condition Variables</a><a class="toc1" href="part309.htm">30.1 Definition and Routines</a><a class="toc1" href="part310.htm">30.2 The Producer/Consumer (Bound Buffer) Problem</a><a class="toc2" href="part311.htm">A Broken Solution</a><a class="toc2" href="part312.htm">Better, But Still Broken: While, Not If</a><a class="toc2" href="part313.htm">The Single Buffer Producer/Consumer Solution</a><a class="toc2" href="part314.htm">The Final Producer/Consumer Solution</a><a class="toc1" href="part315.htm">30.3 Covering Conditions</a><a class="toc1" href="part316.htm">30.4 Summary</a><a class="toc1" href="part317.htm">References</a><a class="toc0" href="part318.htm">Semaphores</a><a class="toc1" href="part319.htm">31.1 Semaphores: A Definition</a><a class="toc1" href="part320.htm">31.2 Binary Semaphores (Locks)</a><a class="toc1" href="part321.htm">31.3 Semaphores As Condition Variables</a><a class="toc1" href="part322.htm">31.4 The Producer/Consumer (Bounded-Buffer) Problem</a><a class="toc2" href="part323.htm">First Attempt</a><a class="toc2" href="part324.htm">A Solution: Adding Mutual Exclusion</a><a class="toc2" href="part325.htm">Avoiding Deadlock</a><a class="toc2" href="part326.htm">Finally, A Working Solution</a><a class="toc1" href="part327.htm">31.5 Reader-Writer Locks</a><a class="toc1" href="part328.htm">31.6 The Dining Philosophers</a><a class="toc2" href="part329.htm">Broken Solution</a><a class="toc2" href="part330.htm">A Solution: Breaking The Dependency</a><a class="toc1" href="part331.htm">31.7 How To Implement Semaphores</a><a class="toc1" href="part332.htm">31.8 Summary</a><a class="toc1" href="part333.htm">References</a><a class="toc0" href="part334.htm">Common Concurrency Problems</a><a class="toc1" href="part335.htm">32.1 What Types Of Bugs Exist?</a><a class="toc1" href="part336.htm">32.2 Non-Deadlock Bugs</a><a class="toc2" href="part337.htm">Atomicity-Violation Bugs</a><a class="toc2" href="part338.htm">Order-Violation Bugs</a><a class="toc2" href="part339.htm">Non-Deadlock Bugs: Summary</a><a class="toc1" href="part340.htm">32.3 Deadlock Bugs</a><a class="toc2" href="part341.htm">Why Do Deadlocks Occur?</a><a class="toc2" href="part342.htm">Conditions for Deadlock</a><a class="toc2" href="part343.htm">Prevention</a><a class="toc2" href="part348.htm">Deadlock Avoidance via Scheduling</a><a class="toc2" href="part349.htm">Detect and Recover</a><a class="toc1" href="part350.htm">32.4 Summary</a><a class="toc1" href="part351.htm">References</a><a class="toc0" href="part352.htm">Event-based Concurrency (Advanced)</a><a class="toc1" href="part353.htm">33.1 The Basic Idea: An Event Loop</a><a class="toc1" href="part354.htm">33.2 An Important API: select() (or poll())</a><a class="toc1" href="part355.htm">33.3 Using select()</a><a class="toc1" href="part356.htm">33.4 Why Simpler? No Locks Needed</a><a class="toc1" href="part357.htm">33.5 A Problem: Blocking System Calls</a><a class="toc1" href="part358.htm">33.6 A Solution: Asynchronous I/O</a><a class="toc1" href="part359.htm">33.7 Another Problem: State Management</a><a class="toc1" href="part360.htm">33.8 What Is Still Difficult With Events</a><a class="toc1" href="part361.htm">33.9 Summary</a><a class="toc1" href="part362.htm">References</a><a class="toc0" href="part363.htm">Summary Dialogue on Concurrency</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part258.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part260.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
