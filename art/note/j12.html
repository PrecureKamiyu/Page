<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-04-27 Thu 14:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chapter 12: Network</title>
<meta name="generator" content="Org mode" />
<link rel = "stylesheet" type="text/css" href ="style_for_org.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Chapter 12: Network</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org10906f0">1. 网络通信</a>
<ul>
<li><a href="#org3e5d4d7">1.1. IP</a></li>
<li><a href="#orgc94156d">1.2. 域名系统 (DNS)</a></li>
<li><a href="#org393144b">1.3. 网络协议层级</a></li>
<li><a href="#org60b7a30">1.4. TCP 和 UDP</a></li>
<li><a href="#org2103346">1.5. Socket</a></li>
<li><a href="#org3630e2d">1.6. Socket 客户端和服务器</a></li>
<li><a href="#org903cd90">1.7. socket 流</a></li>
<li><a href="#org27e3696">1.8. Socket 的构造法</a></li>
</ul>
</li>
<li><a href="#org2303f96">2. Volumn Two</a>
<ul>
<li><a href="#orgcaa17ee">2.1. URLとは？</a></li>
<li><a href="#org9c17f24">2.2. 创建 URL</a></li>
<li><a href="#orgb4da2b9">2.3. URL 通信和 Socket 通信之间的区别</a></li>
</ul>
</li>
<li><a href="#orgd308f06">3. Volumn Three: 观察者模式</a>
<ul>
<li><a href="#org4278bd9">3.1. 动机:</a></li>
<li><a href="#orgf3db04e">3.2. 定义</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org10906f0" class="outline-2">
<h2 id="org10906f0"><span class="section-number-2">1</span> 网络通信</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org3e5d4d7" class="outline-3">
<h3 id="org3e5d4d7"><span class="section-number-3">1.1</span> IP</h3>
<div class="outline-text-3" id="text-1-1">
<p>
IP 地址是 Internet Protocol Address 的缩写，指的是网络中设备的标识符。
它是一个由 32 位二进制数字组成的地址，在人类可读的形式下被表示为 4 个
十进制数（每个数在 0-255 之间），用点号分隔开来。
</p>

<p>
IP 地址分为两种类型：IPv4 和 IPv6。IPv4 地址由 32 位二进制数字组成，而
IPv6 地址则由 128 位二进制数字组成。目前，IPv4 地址仍然是互联网上最常
用的地址类型。IPv4 地址共有 4294967296 个，但由于一些保留地址和私有地
址的存在，实际可用的公共 IPv4 地址数量要少得多。
</p>

<p>
IP 地址的作用是唯一地标识连接到 Internet 上的设备，并且它是 Internet
通信过程中的基本单元。每次从一台计算机向另一台计算机发送数据时，数据包
都会携带源 IP 地址和目标 IP 地址，以确保数据传输到正确的设备上。
</p>

<p>
本机地址为: 127.0.0.1
</p>
</div>
</div>

<div id="outline-container-orgc94156d" class="outline-3">
<h3 id="orgc94156d"><span class="section-number-3">1.2</span> 域名系统 (DNS)</h3>
<div class="outline-text-3" id="text-1-2">
<p>
DNS 代表域名系统（Domain Name System），是一个用于将易于记忆的域名转换
为 IP 地址的分布式数据库系统。因为互联网上存在数以亿计的设备和计算机，
用 IP 地址来访问它们是不方便的，而且很难记住众多的数字地址。DNS 解决了
这个问题，它允许我们使用易于记忆的域名，例如 <code>www.example.com</code> ，而不是记
住其对应的 IP 地址。
</p>

<p>
当您在浏览器中输入 URL 或域名时，DNS 服务器会将该域名映射到相应的 IP
地址，并将其返回给您的计算机，然后您的计算机可以使用该地址连接到目标服
务器。DNS 系统是一个分层的系统，由许多不同的 DNS 服务器组成，每个 DNS
服务器都存储了一部分域名和 IP 地址的映射关系。当一个 DNS 服务器无法找
到所请求的域名和 IP 地址的映射时，它会向其他 DNS 服务器发送请求，直到
找到匹配的映射为止。
</p>
</div>
</div>

<div id="outline-container-org393144b" class="outline-3">
<h3 id="org393144b"><span class="section-number-3">1.3</span> 网络协议层级</h3>
<div class="outline-text-3" id="text-1-3">
<p>
TCP/IP 是一个网络通信协议族，它包含了许多不同的协议，按照功能可以分为四个层级：
</p>

<ol class="org-ol">
<li><b>应用层</b> ：应用层协议处理特定应用程序之间的通信，例如 Web 浏览器、电子
邮件客户端和文件传输协议（FTP）客户端等。常见的应用层协议包括 HTTP、
SMTP、POP3、FTP 等。</li>

<li><b>传输层</b> ：传输层协议负责在源和目标设备之间提供端到端的可靠数据传输服
务。TCP 是最常用的传输层协议，它提供流控制、拥塞控制和错误检测等功
能。另一个传输层协议是用户数据报协议（UDP），它提供无连接的数据传输
服务。</li>

<li><b>网络层</b> ：网络层协议负责在互联网上路由数据包，确保它们到达正确的目标。
IP协议是最常用的网络层协议，它定义了网络地址和路由选择，并将传输层
的数据封装在 IP 数据包中以进行传输。</li>

<li><b>链路层(网络接口层)</b> ：链路层协议负责在物理网络上传输数据帧。它确保
数据从一个网络节点传输到下一个网络节点，并提供对物理层面的控制和管
理。常见的链路层协议包括以太网和 Wi-Fi。</li>
</ol>

<p>
总之，TCP/IP 协议族是一个四层网络通信协议体系结构，它包括了应用层、传
输层、网络层和链路层。不同层级的协议协同工作，为数据在网络中的传输提供
了完整的解决方案。
</p>
</div>
</div>

<div id="outline-container-org60b7a30" class="outline-3">
<h3 id="org60b7a30"><span class="section-number-3">1.4</span> TCP 和 UDP</h3>
<div class="outline-text-3" id="text-1-4">
<p>
TCP 是在传输层的东西. TCP 是最常用的传输层协议，它提供 <b>流控制、拥塞控制 和错误检测</b> 等功能。另一个传输层协议是用户数据报协议（UDP），它提供无连
接的数据传输服务.
</p>

<p>
UDP 是用户数据报协议（User Datagram Protocol）的缩写。它是一种无连接协
议，用于在计算机网络上发送数据包。相对于 TCP 协议，UDP 协议具有更快的
传输速度，但是不保证数据包的 <b>可靠性和顺序性</b> 。因此，在某些应用场景中，如
实时音视频传输、在线游戏等，UDP 协议更为适用。
</p>
</div>
</div>

<div id="outline-container-org2103346" class="outline-3">
<h3 id="org2103346"><span class="section-number-3">1.5</span> Socket</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Socket（套接字）是一种在计算机网络中进行进程间通信或传输数据的机制。它
提供了一种标准的接口，使得应用程序能够通过网络协议与其他应用程序进行通
信。
</p>

<p>
Socket 有两个部分组成, 1. <span class="underline">IP地址</span>; 2. <span class="underline">端口号</span>.
</p>

<p>
Socket 通常被用于实现客户端 / 服务器模型，其中服务器监听来自客户端的连
接请求，并向客户端提供服务。客户端则通过 Socket 与服务器建立连接并发送
请求，以获取服务响应。
</p>

<p>
在编程中，Socket 可以使用各种编程语言和网络库进行实现。常见的 Socket
类型有 TCP Socket 和 UDP Socket。
</p>


<p>
在局域网中 <b>多</b> 台计算机可能共享同一个公网IP地址，这是通过网络地址转换
技术（NAT）实现的。NAT技术允许多台计算机共享同一个公网IP地址，从而节省
了有限的IPv4地址资源。当使用NAT技术时， <b>路由器</b> 会在转发数据包时修改
数据包中的源IP地址和源端口号，以便外部网络可以正确地将响应数据发送回路
由器。
</p>

<p>
当路由器接收到来自外部网络的响应数据时，它会根据之前保存的NAT映射表，
将数据包中的目的IP地址和目的端口号修改为内部网络中计算机的IP地址和端口
号，然后将数据包 <b>转发</b> 给内部网络中的计算机。因此，在使用NAT技术时，
外部网络无法直接根据IP地址和端口号确定数据来自或发送给内部网络中的哪台
计算机。只有路由器才能根据NAT映射表确定数据来自或发送给内部网络中的哪
台计算机
</p>
</div>
</div>

<div id="outline-container-org3630e2d" class="outline-3">
<h3 id="org3630e2d"><span class="section-number-3">1.6</span> Socket 客户端和服务器</h3>
<div class="outline-text-3" id="text-1-6">
<p>
当然可以，以下是一个简单的 Java Socket 客户端和服务器端通信的例子：
</p>

<p>
Server.java:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">IOException</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">net</span>.<span style="color: #98fb98;">ServerSocket</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">net</span>.<span style="color: #98fb98;">Socket</span>;

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Server</span> {
    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">IOException</span> {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">port</span> = 12345;
        <span style="color: #98fb98;">ServerSocket</span> <span style="color: #eedd82;">serverSocket</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ServerSocket</span>(port);
        System.out.println(<span style="color: #ffa07a;">"Server started on port "</span> + port);

        <span style="color: #00ffff;">while</span> (<span style="color: #7fffd4;">true</span>) {
            <span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">socket</span> = serverSocket.accept();
            System.out.println(<span style="color: #ffa07a;">"New client connected: "</span> + socket.getInetAddress().getHostAddress());

            <span style="color: #98fb98;">ClientHandler</span> <span style="color: #eedd82;">clientHandler</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">ClientHandler</span>(socket);
            clientHandler.start();
        }
    }
}
</pre>
</div>
<p>
ClientHandler.java:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">BufferedReader</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">IOException</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">InputStreamReader</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">PrintWriter</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">net</span>.<span style="color: #98fb98;">Socket</span>;

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">ClientHandler</span> <span style="color: #00ffff;">extends</span> <span style="color: #98fb98;">Thread</span> {
    <span style="color: #00ffff;">private</span> <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">socket</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">BufferedReader</span> <span style="color: #eedd82;">input</span>;
    <span style="color: #00ffff;">private</span> <span style="color: #98fb98;">PrintWriter</span> <span style="color: #eedd82;">output</span>;

    <span style="color: #00ffff;">public</span> <span style="color: #87cefa;">ClientHandler</span>(<span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">socket</span>) {
        <span style="color: #00ffff;">this</span>.socket = socket;
    }

    <span style="color: #7fffd4;">@Override</span>
    <span style="color: #00ffff;">public</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">run</span>() {
        <span style="color: #00ffff;">try</span> {
            input = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">BufferedReader</span>(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">InputStreamReader</span>(socket.getInputStream()));
            output = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">PrintWriter</span>(socket.getOutputStream(), <span style="color: #7fffd4;">true</span>);

            <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">message</span>;
            <span style="color: #00ffff;">while</span> ((message = input.readLine()) != <span style="color: #7fffd4;">null</span>) {
                System.out.println(<span style="color: #ffa07a;">"Received message from client: "</span> + message);
                output.println(<span style="color: #ffa07a;">"Echo: "</span> + message);
            }
        } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">IOException</span> <span style="color: #eedd82;">e</span>) {
            System.err.println(<span style="color: #ffa07a;">"Error handling client: "</span> + e.getMessage());
        } <span style="color: #00ffff;">finally</span> {
            <span style="color: #00ffff;">try</span> {
                socket.close();
            } <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">IOException</span> <span style="color: #eedd82;">e</span>) {
                System.err.println(<span style="color: #ffa07a;">"Error closing socket: "</span> + e.getMessage());
            }
        }
    }
}
</pre>
</div>

<p>
Client.java:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">BufferedReader</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">IOException</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">InputStreamReader</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">io</span>.<span style="color: #98fb98;">PrintWriter</span>;
<span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">net</span>.<span style="color: #98fb98;">Socket</span>;

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Client</span> {
    <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">IOException</span> {
        <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">host</span> = <span style="color: #ffa07a;">"localhost"</span>;
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">port</span> = 12345;

        <span style="color: #98fb98;">Socket</span> <span style="color: #eedd82;">socket</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Socket</span>(host, port);
        System.out.println(<span style="color: #ffa07a;">"Connected to server on "</span> + host + <span style="color: #ffa07a;">":"</span> + port);

        <span style="color: #98fb98;">BufferedReader</span> <span style="color: #eedd82;">input</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">BufferedReader</span>(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">InputStreamReader</span>(System.in));
        <span style="color: #98fb98;">BufferedReader</span> <span style="color: #eedd82;">serverInput</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">BufferedReader</span>(<span style="color: #00ffff;">new</span> <span style="color: #98fb98;">InputStreamReader</span>(socket.getInputStream()));
        <span style="color: #98fb98;">PrintWriter</span> <span style="color: #eedd82;">output</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">PrintWriter</span>(socket.getOutputStream(), <span style="color: #7fffd4;">true</span>);

        <span style="color: #98fb98;">String</span> <span style="color: #eedd82;">message</span>;
        <span style="color: #00ffff;">while</span> ((message = input.readLine()) != <span style="color: #7fffd4;">null</span>) {
            output.println(message);
            System.out.println(<span style="color: #ffa07a;">"Received from server: "</span> + serverInput.readLine());
        }

        socket.close();
    }
}
</pre>
</div>

<p>
这个例子中，服务器程序在端口 12345 上监听客户端连接请求。每当有一个新
的客户端连接时，它会启动一个新的线程来处理该客户端的请求。客户端程序通
过 IP 地址和端口号连接到服务器，并输入要发送的消息。在服务器程序中，新
的线程接收到客户端发送的消息并将其打印到控制台上，然后将其作为回显发送
给客户端。
</p>
</div>
</div>

<div id="outline-container-org903cd90" class="outline-3">
<h3 id="org903cd90"><span class="section-number-3">1.7</span> socket 流</h3>
<div class="outline-text-3" id="text-1-7">
<p>
<code>sock.getInputStream();</code> 就能够得到一个 input 流, 这是用来从服务器处读
取数据用的. 然后又, <code>sock.getOutputStream()</code> 能够到的一个 output 流,
用来向 socket 里面写数据的.
</p>

<p>
我们常用 BufferedReader 来封装这个 input, 使用 PrintWriter 来封装这个
output 流.
</p>


<p>
如果服务器与客户端断开连接后重连，它们将无法使用原来的Socket实例进行通
信（如果通信会出现IOException异常）。当服务器与客户端之间的连接被断开
时，它们之间的Socket实例将不再有效，如果客户端想要重新连接到服务器，它
需要创建一个新的Socket实例，并使用这个新的实例与服务器建立连接。对于服
务器，此时它接收到一个新的（重连就视为新的）客户端连接，它的
serverSocket.accept方法将返回一个新的Socket实例，这个Socket实例与原来
的Socket实例是完全独立的，没有任何关联
</p>
</div>
</div>

<div id="outline-container-org27e3696" class="outline-3">
<h3 id="org27e3696"><span class="section-number-3">1.8</span> Socket 的构造法</h3>
<div class="outline-text-3" id="text-1-8">
<p>
<code>ServerSocket</code> 的构造法: 
</p>

<ol class="org-ol">
<li><code>public ServerSocket (int port);</code>
创建绑定到特定端口的服务器端口.</li>
<li><code>public ServerSocket (int port, int backlog);</code>
利用指定的 <code>backlog</code> 创建 socket, 并且绑定到本地的端口号上.</li>
<li><code>public ServerSocket (int port, int backlog, InetAddress address);</code>
使用指定的端口, 侦听 <code>backlog</code> 和要绑定到本地 IP 地址创建服务器.</li>
<li><code>public ServerSocket();</code> 创建非绑定服务器 socket.</li>
</ol>

<p>
<code>Socket</code> 的构造法: 
</p>

<ol class="org-ol">
<li><code>public Socket(String hostname, int port);</code></li>

<li><code>public Socket(String hostname, int port);</code></li>

<li>\(\dots\)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org2303f96" class="outline-2">
<h2 id="org2303f96"><span class="section-number-2">2</span> Volumn Two</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgcaa17ee" class="outline-3">
<h3 id="orgcaa17ee"><span class="section-number-3">2.1</span> URLとは？</h3>
<div class="outline-text-3" id="text-2-1">
<p>
URL 是互联网上最基本的概念之一，经常被用于在浏览器中打开网页或下载文件。
它由许多组件构成，每个组件都有自己的作用。以下是一些常见的 URL 组件：
</p>

<ol class="org-ol">
<li>协议：指定要使用的通信协议，例如 http、https、ftp 等。</li>

<li>主机名：指定将请求发送到哪个服务器。主机名可以是域名（例如
www.example.com）或 IP 地址（例如 192.168.0.1）。</li>

<li>端口号：对于某些协议（如 http 和 https），需要指定端口号。默认情况
下，http 使用端口 80，而 https 使用 443。</li>

<li>路径：指定请求的资源在服务器上的位置。路径以斜杠 “/” 开头，后面跟着
文件夹和文件名。</li>

<li>查询参数：提供关于请求的附加信息。查询参数通常以问号 “?” 开始，后面
是一系列键值对，键值对之间用 “&amp;” 分隔。</li>
</ol>

<p>
例如，以下是一个包含所有这些组件的 URL 示例：
</p>

<p>
<a href="https://www.example.com:8080/products/index.html?category=electronics&amp;page=1">https://www.example.com:8080/products/index.html?category=electronics&amp;page=1</a>
</p>

<p>
在这个 URL 中，协议是 https，主机名是 www.exaqmple.com，端口号是 8080，
路径是 /products/index.html，查询参数是 category=electronics 和 page=1。
</p>
</div>
</div>

<div id="outline-container-org9c17f24" class="outline-3">
<h3 id="org9c17f24"><span class="section-number-3">2.2</span> 创建 URL</h3>
<div class="outline-text-3" id="text-2-2">
<p>
在 Java 中，可以使用 <code>java.net.URL</code> 类来创建 <code>URL</code> 对象。 <code>URL</code> 类表示
统一资源定位符，它用于标识互联网上的资源。
</p>

<p>
以下是一个简单的示例，演示如何创建 URL 对象：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">import</span> <span style="color: #7fffd4;">java</span>.<span style="color: #7fffd4;">net</span>.*;

<span style="color: #00ffff;">public</span> <span style="color: #00ffff;">class</span> <span style="color: #98fb98;">Main</span> {
  <span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">String</span>[] <span style="color: #eedd82;">args</span>) <span style="color: #00ffff;">throws</span> <span style="color: #98fb98;">Exception</span> {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21019;&#24314; URL &#23545;&#35937;</span>
    <span style="color: #98fb98;">URL</span> <span style="color: #eedd82;">url</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">URL</span>(<span style="color: #ffa07a;">"https://www.example.com"</span>);

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36755;&#20986; URL &#30340;&#21508;&#20010;&#37096;&#20998;</span>
    System.out.println(<span style="color: #ffa07a;">"&#21327;&#35758;&#65306;"</span> + url.getProtocol());
    System.out.println(<span style="color: #ffa07a;">"&#20027;&#26426;&#21517;&#65306;"</span> + url.getHost());
    System.out.println(<span style="color: #ffa07a;">"&#31471;&#21475;&#21495;&#65306;"</span> + url.getPort());
    System.out.println(<span style="color: #ffa07a;">"&#36335;&#24452;&#65306;"</span> + url.getPath());
    System.out.println(<span style="color: #ffa07a;">"&#26597;&#35810;&#23383;&#31526;&#20018;&#65306;"</span> + url.getQuery());
  }
}
</pre>
</div>
<p>
在上面的示例中，我们首先导入了 <code>java.net.*</code> 包，然后创建了一个 <code>URL</code>
对象，其参数为指向资源的地址。接下来，我们可以使用 <code>getProtocol()</code> 、
<code>getHost()</code> 、 <code>getPort()</code> 等方法获取 URL 的各个部分，并将其输出到控制
台上。
</p>

<p>
需要注意的是，在创建 URL 对象时，还需要处理可能会抛出 MalformedURLException 异常，例如：
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">try</span> {
  <span style="color: #98fb98;">URL</span> <span style="color: #eedd82;">url</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">URL</span>(<span style="color: #ffa07a;">"https://www.example.com"</span>);
} <span style="color: #00ffff;">catch</span> (<span style="color: #98fb98;">MalformedURLException</span> <span style="color: #eedd82;">e</span>) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22788;&#29702;&#24322;&#24120;</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4da2b9" class="outline-3">
<h3 id="orgb4da2b9"><span class="section-number-3">2.3</span> URL 通信和 Socket 通信之间的区别</h3>
<div class="outline-text-3" id="text-2-3">
<p>
区别主要在于: 
</p>

<p>
<code>Socket</code> 的通信方式是在 <b>服务器端运行通信程序</b>, 不停地监听客户端的连接
请求. <b>主动地</b> 等待客户端的请求服务. 而 URL 进行通信的时候, 是被动的等
待客户端请求.
</p>

<p>
<code>Socket</code> 通信方式是服务器端可以 <b>同时和多个客户端</b> 链接, URL 通信方式
却只能和一个客户进行连接.
</p>

<p>
利用URL进行通信时，会在服务器端常驻一个CGI程序，但它一直处于休眠状态。
只有在客户端要求建立连接时才被激活，然后与用户进行URL通信。一个线程一
个时间只能与一个客户端进行URL通信，通信结束后它才能再与另一个客户端进
行URL通信（但很少这样做，一般线程直接被释放）。所以，在URL通信中，服务
器是被动等待连接通信的到来，URL通信方式服务器只能同时与一个客户端进行
通信（在一个线程中）
</p>

<p>
多个客户端用URL与一个网站通信时，服务器通常会为每个客户端创建一个单独
的线程来处理它的请求，通信结束后服务器为该客户端创建的线程会被释放。这
样，服务器就可以同时处理多个客户端的请求，且每个线程都是独立的，它们之
间不会相互干扰
</p>

<p>
URL常用于爬取网页信息 
</p>

<p>
URL通信可以用来从服务器获取数据，也可以用来向服务器发送数据。例如，当
在网页上填写表单并提交时，你的浏览器通常会通过URL通信向服务器发送数据
</p>


<p>
&#x2014;
</p>

<p>
当我们在浏览器中输入一个 URL 时，我们实际上是在请求服务器上的资源。URL
(Uniform Resource Locator) 是一种用于定位互联网上资源的标识符，它能够
告诉网络客户端需要连接到哪个服务器，请求哪个资源，并以什么协议进行通信。
因此，URL 主要是用于获取互联网上的资源。
</p>

<p>
与此相反，Socket 是用于应用程序之间的通信的一种机制。它基于网络协议，
提供了一种面向连接的数据传输方式，使得应用程序能够在网络上双向地传输数
据。例如，当您在一个聊天应用程序中发送一条消息时，这条消息将通过
Socket 发送给服务器或其他用户，而不是通过 URL 请求资源。
</p>

<p>
总的来说，URL 和 Socket 都是用于在网络上进行通信的技术，但它们解决了不
同层面的问题。URL 主要是用于获取互联网上的资源，而 Socket 则提供了更灵
活的双向、面向连接的数据传输方式。
</p>
</div>
</div>
</div>

<div id="outline-container-orgd308f06" class="outline-2">
<h2 id="orgd308f06"><span class="section-number-2">3</span> Volumn Three: 观察者模式</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org4278bd9" class="outline-3">
<h3 id="org4278bd9"><span class="section-number-3">3.1</span> 动机:</h3>
</div>

<div id="outline-container-orgf3db04e" class="outline-3">
<h3 id="orgf3db04e"><span class="section-number-3">3.2</span> 定义</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2023-04-27 Thu 14:27</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>