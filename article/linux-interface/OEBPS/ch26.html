<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 26. Monitoring Child Processes</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch25.html" title="Chapter 25. Process Termination"/><link rel="next" href="ch27.html" title="Chapter 27. Program Execution"/></head><body><section class="chapter" title="Chapter 26. Monitoring Child Processes" epub:type="chapter" id="monitoring_child_processes"><div class="titlepage"><div><div><h2 class="title">Chapter 26. Monitoring Child Processes</h2></div></div></div><p>In many application designs, a parent process needs to know when one of its child
            processes changes state—when the child terminates or is stopped by a signal. This
            chapter describes two techniques used to monitor child processes: the
                <span class="emphasis"><em>wait()</em></span> system call (and its variants) and the use of the
                <code class="literal">SIGCHLD</code> signal.<a id="IDX-CHP-26-3889" class="indexterm"/></p><div class="sect1" title="Waiting on a Child Process"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="waiting_on_a_child_process">Waiting on a Child Process</h2></div></div></div><p>In many applications where a parent creates child processes, it is useful for the
                parent to be able to monitor the children to find out when and how they terminate.
                This facility is provided by <span class="emphasis"><em>wait()</em></span> and a number of related
                system calls.<a id="IDX-CHP-26-3890" class="indexterm"/></p><div class="sect2" title="The wait() System Call"><div class="titlepage"><div><div><h3 class="title" id="the_wait_open_parenthesis_close_parenthe">The <span class="emphasis"><em>wait()</em></span> System Call</h3></div></div></div><p>The <span class="emphasis"><em>wait()</em></span> system call waits for one of the children of
                    the calling process to terminate and returns the termination status of that
                    child in the buffer pointed to by <span class="emphasis"><em>status</em></span>.<a id="IDX-CHP-26-3891" class="indexterm"/><a id="IDX-CHP-26-3892" class="indexterm"/><a id="IDX-CHP-26-3893" class="indexterm"/></p><a id="I_programlisting26_d1e72530"/><pre class="programlisting">#include &lt;sys/wait.h&gt;

pid_t <strong class="userinput"><code>wait</code></strong>(int *<span class="emphasis"><em>status</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns process ID of terminated child, or -1 on error</p></div><p>The <span class="emphasis"><em>wait()</em></span> system call does the following:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>If no (previously unwaited-for) child of the calling process has yet
                            terminated, the call blocks until one of the children terminates. If a
                            child has already terminated by the time of the call,
                                <span class="emphasis"><em>wait()</em></span> returns immediately.</p></li><li class="listitem"><p>If <span class="emphasis"><em>status</em></span> is not <code class="literal">NULL</code>, information about how the child terminated is
                            returned in the integer to which <span class="emphasis"><em>status</em></span> points. We
                            describe the information returned in <span class="emphasis"><em>status</em></span> in
                                <a class="xref" href="ch26.html#the_wait_status_value" title="The Wait Status Value">The Wait Status Value</a>.</p></li><li class="listitem"><p>The kernel adds the process CPU times (<a class="xref" href="ch10.html#process_time" title="Process Time">Process Time</a>)
                            and resource usage statistics (<a class="xref" href="ch36.html#process_resource_usage" title="Process Resource Usage">Process Resource Usage</a>)
                            to running totals for all children of this parent process.</p></li><li class="listitem"><p>As its function result, <span class="emphasis"><em>wait()</em></span> returns the
                            process ID of the child that has terminated.</p></li></ol></div><p>On error, <span class="emphasis"><em>wait()</em></span> returns -1. One possible error is that
                    the calling process has no (previously unwaited-for) children, which is
                    indicated by the <span class="emphasis"><em>errno</em></span> value <code class="literal">ECHILD</code>. This means that we can use the following loop to wait for
                    all children of the calling process to terminate:</p><a id="I_programlisting26_d1e72594"/><pre class="programlisting">while ((childPid = wait(NULL)) != -1)
    continue;
if (errno != ECHILD)                /* An unexpected error... */
    errExit("wait");</pre><p><a class="xref" href="ch26.html#creating_and_waiting_for_multiple_childr" title="Example 26-1. Creating and waiting for multiple children">Example 26-1</a> demonstrates the
                    use of <span class="emphasis"><em>wait()</em></span>. This program creates multiple child
                    processes, one per (integer) command-line argument. Each child sleeps for the
                    number of seconds specified in the corresponding command-line argument and then
                    exits. In the meantime, after all children have been created, the parent process
                    repeatedly calls <span class="emphasis"><em>wait()</em></span> to monitor the termination of its
                    children. This loop continues until <span class="emphasis"><em>wait()</em></span> returns -1.
                    (This is not the only approach: we could alternatively exit the loop when the
                    number of terminated children, <span class="emphasis"><em>numDead</em></span>, matches the number
                    of children created.) The following shell session log shows what happens when we
                    use the program to create three children:</p><a id="I_programlisting26_d1e72611"/><pre class="programlisting">$ <strong class="userinput"><code>./multi_wait 7 1 4</code></strong>
[13:41:00] child 1 started with PID 21835, sleeping 7 seconds
[13:41:00] child 2 started with PID 21836, sleeping 1 seconds
[13:41:00] child 3 started with PID 21837, sleeping 4 seconds
[13:41:01] wait() returned child PID 21836 (numDead=1)
[13:41:04] wait() returned child PID 21837 (numDead=2)
[13:41:07] wait() returned child PID 21835 (numDead=3)
No more children - bye!</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>If there are multiple terminated children at a particular moment, SUSv3
                        leaves unspecified the order in which these children will be reaped by a
                        sequence of <span class="emphasis"><em>wait()</em></span> calls; that is, the order depends on
                        the implementation. Even across versions of the Linux kernel, the behavior
                        varies.</p></div><div class="example"><a id="creating_and_waiting_for_multiple_childr"/><div class="example-title">Example 26-1. Creating and waiting for multiple children</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procexec/multi_wait.c</code></strong>
#include &lt;sys/wait.h&gt;
#include &lt;time.h&gt;
#include "curr_time.h"              /* Declaration of currTime() */
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int numDead;       /* Number of children so far waited for */
    pid_t childPid;    /* PID of waited for child */
    int j;

    if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s sleep-time...\n", argv[0]);

    setbuf(stdout, NULL);           /* Disable buffering of stdout */

    for (j = 1; j &lt; argc; j++) {    /* Create one child for each argument */
        switch (fork()) {
        case -1:
            errExit("fork");

        case 0:                     /* Child sleeps for a while then exits */
            printf("[%s] child %d started with PID %ld, sleeping %s "
                    "seconds\n", currTime("%T"), j, (long) getpid(), argv[j]);
            sleep(getInt(argv[j], GN_NONNEG, "sleep-time"));
            _exit(EXIT_SUCCESS);

        default:                    /* Parent just continues around loop */
            break;
        }
    }

    numDead = 0;
    for (;;) {                      /* Parent waits for each child to exit */
        childPid = wait(NULL);
        if (childPid == -1) {
            if (errno == ECHILD) {
                printf("No more children - bye!\n");
                exit(EXIT_SUCCESS);
            } else {                /* Some other (unexpected) error */
                errExit("wait");
            }
        }

        numDead++;
        printf("[%s] wait() returned child PID %ld (numDead=%d)\n",
                currTime("%T"), (long) childPid, numDead);
    }
}
     <strong class="userinput"><code>procexec/multi_wait.c</code></strong></pre></div></div></div><div class="sect2" title="The waitpid() System Call"><div class="titlepage"><div><div><h3 class="title" id="the_waitpid_open_parenthesis_close_paren">The <span class="emphasis"><em>waitpid()</em></span> System Call</h3></div></div></div><p>The <span class="emphasis"><em>wait()</em></span> system call has a number of limitations, which
                        <span class="emphasis"><em>waitpid()</em></span> was designed to address:<a id="IDX-CHP-26-3895" class="indexterm"/><a id="IDX-CHP-26-3896" class="indexterm"/><a id="IDX-CHP-26-3897" class="indexterm"/><a id="IDX-CHP-26-3898" class="indexterm"/><a id="IDX-CHP-26-3899" class="indexterm"/><a id="IDX-CHP-26-3900" class="indexterm"/><a id="IDX-CHP-26-3894" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If a parent process has created multiple children, it is not possible
                            to <span class="emphasis"><em>wait()</em></span> for the completion of a specific child;
                            we can only wait for the next child that terminates.</p></li><li class="listitem"><p>If no child has yet terminated, <span class="emphasis"><em>wait()</em></span> always
                            blocks. Sometimes, it would be preferable to perform a nonblocking wait
                            so that if no child has yet terminated, we obtain an immediate
                            indication of this fact.</p></li><li class="listitem"><p>Using <span class="emphasis"><em>wait()</em></span>, we can find out only about children
                            that have terminated. It is not possible to be notified when a child is
                            stopped by a signal (such as <code class="literal">SIGSTOP</code>
                            or <code class="literal">SIGTTIN</code>) or when a stopped child
                            is resumed by delivery of a <code class="literal">SIGCONT</code>
                                signal.<a id="IDX-CHP-26-3901" class="indexterm"/></p></li></ul></div><a id="I_programlisting26_d1e72716"/><pre class="programlisting">#include &lt;sys/wait.h&gt;

pid_t <strong class="userinput"><code>waitpid</code></strong>(pid_t <span class="emphasis"><em>pid</em></span>, int <span class="emphasis"><em>*status</em></span>, int <span class="emphasis"><em>options</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns process ID of child, 0 (see text), or -1 on error</p></div><p>The return value and <span class="emphasis"><em>status</em></span> arguments of
                        <span class="emphasis"><em>waitpid()</em></span> are the same as for
                        <span class="emphasis"><em>wait()</em></span>. (See <a class="xref" href="ch26.html#the_wait_status_value" title="The Wait Status Value">The Wait Status Value</a>
                    for an explanation of the value returned in <span class="emphasis"><em>status</em></span>.) The
                        <span class="emphasis"><em>pid</em></span> argument enables the selection of the child to be
                    waited for, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>pid</em></span> is greater than 0, wait for the child
                            whose <span class="emphasis"><em>process ID</em></span> equals
                            <span class="emphasis"><em>pid</em></span>.</p></li><li class="listitem"><p>If <span class="emphasis"><em>pid</em></span> equals 0, wait for any child in the
                                <span class="emphasis"><em>same process group as the caller</em></span> (parent). We
                            describe process groups in Section 34.2.</p></li><li class="listitem"><p>If <span class="emphasis"><em>pid</em></span> is less than -1, wait for any child whose
                                <span class="emphasis"><em>process group</em></span> identifier equals the absolute
                            value of <span class="emphasis"><em>pid</em></span>.</p></li><li class="listitem"><p>If <span class="emphasis"><em>pid</em></span> equals -1, wait for
                                <span class="emphasis"><em>any</em></span> child. The call
                                <span class="emphasis"><em>wait(&amp;status)</em></span> is equivalent to the call
                                <span class="emphasis"><em>waitpid(-1, &amp;status, 0)</em></span>.</p></li></ul></div><p>The <span class="emphasis"><em>options</em></span> argument is a bit mask that can include (OR)
                    zero or more of the following flags (all of which are specified in
                    SUSv3):</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">WUNTRACED</code>
                        </span></dt><dd><p>In addition to returning information about terminated children,
                                also return information when a child is <span class="emphasis"><em>stopped</em></span>
                                by a signal.</p></dd><dt><span class="term"><code class="literal">WCONTINUED</code> (since Linux
                            2.6.10)</span></dt><dd><p>Also return status information about stopped children that have
                                been resumed by delivery of a <code class="literal">SIGCONT</code> signal.</p></dd><dt><span class="term">
                            <code class="literal">WNOHANG</code>
                        </span></dt><dd><p>If no child specified by <span class="emphasis"><em>pid</em></span> has yet changed
                                state, then return immediately, instead of blocking (i.e., perform a
                                “poll”). In this case, the return value of
                                    <span class="emphasis"><em>waitpid()</em></span> is 0. If the calling process has
                                no children that match the specification in
                                <span class="emphasis"><em>pid</em></span>, <span class="emphasis"><em>waitpid()</em></span> fails with
                                the error <code class="literal">ECHILD</code>.</p></dd></dl></div><p>We demonstrate the use of <span class="emphasis"><em>waitpid()</em></span> in <a class="xref" href="ch26.html#using_waitpid_open_parenthesis_close_par" title="Example 26-3. Using waitpid() to retrieve the status of a child process">Example 26-3</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In its rationale for <span class="emphasis"><em>waitpid()</em></span>, SUSv3 notes that the
                        name <code class="literal">WUNTRACED</code> is a historical artifact
                        of this flag’s origin in BSD, where a process could be stopped in one of two
                        ways: as a consequence of being traced by the <span class="emphasis"><em>ptrace()</em></span>
                        system call, or by being stopped by a signal (i.e., not being traced). When
                        a child is being traced by <span class="emphasis"><em>ptrace()</em></span>, then delivery of
                            <span class="emphasis"><em>any</em></span> signal (other than <code class="literal">SIGKILL</code>) causes the child to be stopped, and a <code class="literal">SIGCHLD</code> signal is consequently sent to the
                        parent. This behavior occurs even if the child is ignoring the signal.
                        However, if the child is blocking the signal, then it is not stopped (unless
                        the signal is <code class="literal">SIGSTOP</code>, which can’t be
                            blocked).<a id="IDX-CHP-26-3902" class="indexterm"/><a id="IDX-CHP-26-3903" class="indexterm"/></p></div></div><div class="sect2" title="The Wait Status Value"><div class="titlepage"><div><div><h3 class="title" id="the_wait_status_value">The Wait Status Value</h3></div></div></div><p>The <span class="emphasis"><em>status</em></span> value returned by <span class="emphasis"><em>wait()</em></span>
                    and <span class="emphasis"><em>waitpid()</em></span> allows us to distinguish the following events
                    for the child:<a id="IDX-CHP-26-3904" class="indexterm"/><a id="IDX-CHP-26-3905" class="indexterm"/><a id="IDX-CHP-26-3906" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The child terminated by calling _<span class="emphasis"><em>exit()</em></span> (or
                                <span class="emphasis"><em>exit()</em></span>), specifying an integer <span class="emphasis"><em>exit
                                status</em></span>.<a id="IDX-CHP-26-3907" class="indexterm"/><a id="IDX-CHP-26-3908" class="indexterm"/></p></li><li class="listitem"><p>The child was terminated by the delivery of an unhandled
                            signal.</p></li><li class="listitem"><p>The child was stopped by a signal, and <span class="emphasis"><em>waitpid()</em></span>
                            was called with the <code class="literal">WUNTRACED</code>
                            flag.</p></li><li class="listitem"><p>The child was resumed by a <code class="literal">SIGCONT</code>
                            signal, and <span class="emphasis"><em>waitpid()</em></span> was called with the <code class="literal">WCONTINUED</code> flag.<a id="IDX-CHP-26-3909" class="indexterm"/></p></li></ul></div><p>We use the term <span class="emphasis"><em>wait status</em></span> to encompass all of the above
                    cases. The designation <span class="emphasis"><em>termination status</em></span> is used to refer
                    to the first two cases. (In the shell, we can obtain the termination status of
                    the last command executed by examining the contents of the variable
                        <span class="emphasis"><em>$?</em></span>.)<a id="IDX-CHP-26-3910" class="indexterm"/><a id="IDX-CHP-26-3911" class="indexterm"/></p><p>Although defined as an <span class="emphasis"><em>int</em></span>, only the bottom 2 bytes of
                    the value pointed to by <span class="emphasis"><em>status</em></span> are actually used. The way
                    in which these 2 bytes are filled depends on which of the above events occurred
                    for the child, as depicted in <a class="xref" href="ch26.html#value_returned_in_the_status_argument_of" title="Figure 26-1. Value returned in the status argument of wait() and waitpid()">Figure 26-1</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p><a class="xref" href="ch26.html#value_returned_in_the_status_argument_of" title="Figure 26-1. Value returned in the status argument of wait() and waitpid()">Figure 26-1</a> shows the
                        layout of the wait status value for Linux/x86-32. The details vary across
                        implementations. SUSv3 doesn’t specify any particular layout for this
                        information, or even require that it is contained in the bottom 2 bytes of
                        the value pointed to by <span class="emphasis"><em>status</em></span>. Portable applications
                        should always use the macros described in this section to inspect this
                        value, rather than directly inspecting its bit-mask components.</p></div><div class="figure"><a id="value_returned_in_the_status_argument_of"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject26_d1e73019"/><img src="figs/web/26-1_PROCEXEC-wait-status.png.jpg" alt="Value returned in the status argument of wait() and waitpid()"/></div></div><div class="figure-title">Figure 26-1. Value returned in the <span class="emphasis"><em>status</em></span> argument of
                            <span class="emphasis"><em>wait()</em></span> and <span class="emphasis"><em>waitpid()</em></span></div></div><p>The <code class="literal">&lt;sys/wait.h&gt;</code> header file
                    defines a standard set of macros that can be used to dissect a wait status
                    value. When applied to a <span class="emphasis"><em>status</em></span> value returned by
                        <span class="emphasis"><em>wait()</em></span> or <span class="emphasis"><em>waitpid()</em></span>, only one of
                    the macros in the list below will return true. Additional macros are provided to
                    further dissect the <span class="emphasis"><em>status</em></span> value, as noted in the
                    list.</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">WIFEXITED(status)</code>
                        </span></dt><dd><p>This macro returns true if the child process exited normally. In
                                this case, the macro <code class="literal">WEXITSTATUS(status)</code> returns the exit status of the
                                child process. (As noted in <a class="xref" href="ch25.html#terminating_a_process_colon__underscore" title="Terminating a Process: _exit() and exit()">Terminating a Process: <span class="emphasis"><em>_exit()</em></span> and
                    <span class="emphasis"><em>exit()</em></span></a>, only the
                                least significant byte of the child’s exit status is available to
                                the parent.)</p></dd><dt><span class="term">
                            <code class="literal">WIFSIGNALED(status)</code>
                        </span></dt><dd><p>This macro returns true if the child process was killed by a
                                signal. In this case, the macro <code class="literal">WTERMSIG(status)</code> returns the number of the signal
                                that caused the process to terminate, and the macro <code class="literal">WCOREDUMP(status)</code> returns true if the
                                child process produced a core dump file. The <code class="literal">WCOREDUMP()</code> macro is not specified by
                                SUSv3, but is available on most UNIX implementations.<a id="IDX-CHP-26-3912" class="indexterm"/><a id="IDX-CHP-26-3913" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">WIFSTOPPED(status)</code>
                        </span></dt><dd><p>This macro returns true if the child process was stopped by a
                                signal. In this case, the macro <code class="literal">WSTOPSIG(status)</code> returns the number of the signal
                                that stopped the process.</p></dd><dt><span class="term">
                            <code class="literal">WIFCONTINUED(status)</code>
                        </span></dt><dd><p>This macro returns true if the child was resumed by delivery of
                                    <code class="literal">SIGCONT</code>. This macro is
                                available since Linux 2.6.10.</p></dd></dl></div><p>Note that although the name <span class="emphasis"><em>status</em></span> is also used for the
                    argument of the above macros, they expect a plain integer, rather than a pointer
                    to an integer as required by <span class="emphasis"><em>wait()</em></span> and
                        <span class="emphasis"><em>waitpid()</em></span>.</p><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id31">Example program</h4></div></div></div><p>The <span class="emphasis"><em>printWaitStatus()</em></span> function of <a class="xref" href="ch26.html#displaying_the_status_value_returned_by" title="Example 26-2. Displaying the status value returned by wait() and related calls">Example 26-2</a> uses all of the
                        macros described above. This function dissects and prints the contents of a
                        wait status value.<a id="IDX-CHP-26-3914" class="indexterm"/><a id="IDX-CHP-26-3915" class="indexterm"/><a id="IDX-CHP-26-3916" class="indexterm"/><a id="IDX-CHP-26-3917" class="indexterm"/><a id="IDX-CHP-26-3918" class="indexterm"/><a id="IDX-CHP-26-3919" class="indexterm"/><a id="IDX-CHP-26-3920" class="indexterm"/><a id="IDX-CHP-26-3921" class="indexterm"/><a id="IDX-CHP-26-3922" class="indexterm"/><a id="IDX-CHP-26-3923" class="indexterm"/><a id="IDX-CHP-26-3924" class="indexterm"/><a id="IDX-CHP-26-3925" class="indexterm"/><a id="IDX-CHP-26-3926" class="indexterm"/><a id="IDX-CHP-26-3927" class="indexterm"/><a id="IDX-CHP-26-3928" class="indexterm"/><a id="IDX-CHP-26-3929" class="indexterm"/><a id="IDX-CHP-26-3930" class="indexterm"/><a id="IDX-CHP-26-3931" class="indexterm"/><a id="IDX-CHP-26-3932" class="indexterm"/><a id="IDX-CHP-26-3933" class="indexterm"/></p><div class="example"><a id="displaying_the_status_value_returned_by"/><div class="example-title">Example 26-2. Displaying the status value returned by <span class="emphasis"><em>wait()</em></span>
                            and related calls</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procexec/print_wait_status.c</code></strong>
#define _GNU_SOURCE     /* Get strsignal() declaration from &lt;string.h&gt; */
#include &lt;string.h&gt;
#include &lt;sys/wait.h&gt;
#include "print_wait_status.h"  /* Declaration of printWaitStatus() */
#include "tlpi_hdr.h"

/* NOTE: The following function employs printf(), which is not
   async-signal-safe (see Section 21.1.2). As such, this function is
   also not async-signal-safe (i.e., beware of calling it from a
   SIGCHLD handler). */

void                    /* Examine a wait() status using the W* macros */
printWaitStatus(const char *msg, int status)
{
if (msg != NULL)
        printf("%s", msg);

    if (WIFEXITED(status)) {
        printf("child exited, status=%d\n", WEXITSTATUS(status));

    } else if (WIFSIGNALED(status)) {
        printf("child killed by signal %d (%s)",
                WTERMSIG(status), strsignal(WTERMSIG(status)));
#ifdef WCOREDUMP        /* Not in SUSv3, may be absent on some systems */
        if (WCOREDUMP(status))
            printf(" (core dumped)");
#endif
        printf("\n");

    } else if (WIFSTOPPED(status)) {
        printf("child stopped by signal %d (%s)\n",
                WSTOPSIG(status), strsignal(WSTOPSIG(status)));

#ifdef WIFCONTINUED     /* SUSv3 has this, but older Linux versions and
                           some other UNIX implementations don't */
    } else if (WIFCONTINUED(status)) {
        printf("child continued\n");
#endif

    } else {            /* Should never happen */
        printf("what happened to this child? (status=%x)\n",
                (unsigned int) status);
    }
}

     <strong class="userinput"><code>procexec/print_wait_status.c</code></strong></pre></div></div><p>The <span class="emphasis"><em>printWaitStatus()</em></span> function is used in <a class="xref" href="ch26.html#using_waitpid_open_parenthesis_close_par" title="Example 26-3. Using waitpid() to retrieve the status of a child process">Example 26-3</a>. This program
                        creates a child process that either loops continuously calling
                            <span class="emphasis"><em>pause()</em></span> (during which time signals can be sent to
                        the child) or, if an integer command-line argument was supplied, exits
                        immediately using this integer as the exit status. In the meantime, the
                        parent monitors the child via <span class="emphasis"><em>waitpid()</em></span>, printing the
                        returned status value and passing this value to
                            <span class="emphasis"><em>printWaitStatus()</em></span>. The parent exits when it detects
                        that the child has either exited normally or been terminated by a
                        signal.</p><p>The following shell session shows a few example runs of the program in
                            <a class="xref" href="ch26.html#using_waitpid_open_parenthesis_close_par" title="Example 26-3. Using waitpid() to retrieve the status of a child process">Example 26-3</a>. We begin by
                        creating a child that immediately exits with a status of 23:</p><a id="I_programlisting26_d1e73260"/><pre class="programlisting">$ <strong class="userinput"><code>./child_status 23</code></strong>
Child started with PID = 15807
waitpid() returned: PID=15807; status=0x1700 (23,0)
child exited, status=23</pre><p>In the next run, we start the program in the background, and then send
                            <code class="literal">SIGSTOP</code> and <code class="literal">SIGCONT</code> signals to the child:</p><a id="I_programlisting26_d1e73273"/><pre class="programlisting">$ <strong class="userinput"><code>./child_status &amp;</code></strong>
[1] 15870
$ Child started with PID = 15871
<strong class="userinput"><code>kill -STOP 15871</code></strong>
$ waitpid() returned: PID=15871; status=0x137f (19,127)
child stopped by signal 19 (Stopped (signal))
<strong class="userinput"><code>kill -CONT 15871</code></strong>
$ waitpid() returned: PID=15871; status=0xffff (255,255)
child continued</pre><p>The last two lines of output will appear only on Linux 2.6.10 and later,
                        since earlier kernels don’t support the <span class="emphasis"><em>waitpid()</em></span>
                        <code class="literal">WCONTINUED</code> option. (This shell session is
                        made slightly hard to read by the fact that output from the program
                        executing in the background is in some cases intermingled with the prompt
                        produced by the shell.)</p><p>We continue the shell session by sending a <code class="literal">SIGABRT</code> signal to terminate the child:</p><a id="I_programlisting26_d1e73297"/><pre class="programlisting"><strong class="userinput"><code>kill -ABRT 15871</code></strong>
$ waitpid() returned: PID=15871; status=0x0006 (0,6)
child killed by signal 6 (Aborted)
<em class="lineannotation"><span class="lineannotation">Press Enter, in order to see shell notification that background job has terminated</span></em>
[1]+  Done              ./child_status
$ <strong class="userinput"><code>ls -l core</code></strong>
ls: core: No such file or directory
$ <strong class="userinput"><code>ulimit -c</code></strong>                                    <em class="lineannotation"><span class="lineannotation">Display</span></em> RLIMIT_CORE <em class="lineannotation"><span class="lineannotation">limit</span></em>
0</pre><p>Although the default action of <code class="literal">SIGABRT</code>
                        is to produce a core dump file and terminate the process, no core file was
                        produced. This is because core dumps were disabled—the <code class="literal">RLIMIT_CORE</code> soft resource limit (<a class="xref" href="ch36.html#details_of_specific_resource_limits" title="Details of Specific Resource Limits">Details of Specific Resource Limits</a>), which specifies the
                        maximum size of a core file, was set to 0, as shown by the
                            <span class="emphasis"><em>ulimit</em></span> command above.</p><p>We repeat the same experiment, but this time enabling core dumps before
                        sending <code class="literal">SIGABRT</code> to the child:</p><a id="I_programlisting26_d1e73335"/><pre class="programlisting">$ <strong class="userinput"><code>ulimit -c unlimited</code></strong>                           <em class="lineannotation"><span class="lineannotation">Allow core dumps</span></em>
$ <strong class="userinput"><code>./child_status &amp;</code></strong>
[1] 15902
$ Child started with PID = 15903
<strong class="userinput"><code>kill -ABRT 15903</code></strong>                                <em class="lineannotation"><span class="lineannotation">Send</span></em> SIGABRT <em class="lineannotation"><span class="lineannotation">to child</span></em>
$ waitpid() returned: PID=15903; status=0x0086 (0,134)
child killed by signal 6 (Aborted) (core dumped)
<em class="lineannotation"><span class="lineannotation">Press Enter, in order to see shell notification that background job has terminated</span></em>
[1]+  Done              ./child_status
$ <strong class="userinput"><code>ls -l core</code></strong>                                   <em class="lineannotation"><span class="lineannotation">This time we get a core dump</span></em>
-rw-------   1 mtk      users       65536 May  6 21:01 core</pre><div class="example"><a id="using_waitpid_open_parenthesis_close_par"/><div class="example-title">Example 26-3. Using <span class="emphasis"><em>waitpid()</em></span> to retrieve the status of a
                            child process</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procexec/child_status.c</code></strong>
#include &lt;sys/wait.h&gt;
#include "print_wait_status.h"          /* Declares printWaitStatus() */
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int status;
    pid_t childPid;
if (argc &gt; 1 &amp;&amp; strcmp(argv[1], "—help") == 0)
        usageErr("%s [exit-status]\n", argv[0]);

    switch (fork()) {
    case -1: errExit("fork");

    case 0:             /* Child: either exits immediately with given
                           status or loops waiting for signals */
        printf("Child started with PID = %ld\n", (long) getpid());
        if (argc &gt; 1)                   /* Status supplied on command line? */
            exit(getInt(argv[1], 0, "exit-status"));
        else                            /* Otherwise, wait for signals */
            for (;;)
                pause();
        exit(EXIT_FAILURE);             /* Not reached, but good practice */

    default:            /* Parent: repeatedly wait on child until it
                           either exits or is terminated by a signal */
        for (;;) {
            childPid = waitpid(-1, &amp;status, WUNTRACED
#ifdef WCONTINUED       /* Not present on older versions of Linux */
                                                | WCONTINUED
#endif
                    );
            if (childPid == -1)
                errExit("waitpid");

            /* Print status in hex, and as separate decimal bytes */

            printf("waitpid() returned: PID=%ld; status=0x%04x (%d,%d)\n",
                    (long) childPid,
                    (unsigned int) status, status &gt;&gt; 8, status &amp; 0xff);
            printWaitStatus(NULL, status);

            if (WIFEXITED(status) || WIFSIGNALED(status))
                exit(EXIT_SUCCESS);
        }
    }
}
      <strong class="userinput"><code>procexec/child_status.c</code></strong></pre></div></div></div></div><div class="sect2" title="Process Termination from a Signal Handler"><div class="titlepage"><div><div><h3 class="title" id="process_termination_from_a_signal_handle">Process Termination from a Signal Handler</h3></div></div></div><p>As shown in <a class="xref" href="ch20.html#linux_signals" title="Table 20-1. Linux signals">Table 20-1</a> (in <a class="xref" href="ch20.html#changing_signal_dispositions_colon_signa" title="Changing Signal Dispositions: signal()">Changing Signal Dispositions: <span class="emphasis"><em>signal()</em></span></a>), some signals
                    terminate a process by default. In some circumstances, we may wish to have
                    certain cleanup steps performed before a process terminates. For this purpose,
                    we can arrange to have a handler catch such signals, perform the cleanup steps,
                    and then terminate the process. If we do this, we should bear in mind that the
                    termination status of a process is available to its parent via
                        <span class="emphasis"><em>wait()</em></span> or <span class="emphasis"><em>waitpid()</em></span>. For example,
                    calling <span class="emphasis"><em>_exit(EXIT_SUCCESS)</em></span> from the signal handler will
                    make it appear to the parent process that the child terminated
                        successfully.<a id="IDX-CHP-26-3934" class="indexterm"/><a id="IDX-CHP-26-3935" class="indexterm"/><a id="IDX-CHP-26-3936" class="indexterm"/><a id="IDX-CHP-26-3937" class="indexterm"/></p><p>If the child needs to inform the parent that it terminated because of a
                    signal, then the child’s signal handler should first disestablish itself, and
                    then raise the same signal once more, which this time will terminate the
                    process. The signal handler would contain code such as the following:</p><a id="I_programlisting26_d1e73425"/><pre class="programlisting">void
handler(int sig)
{
    /* Perform cleanup steps */

    signal(sig, SIG_DFL);            /* Disestablish handler */
    raise(sig);                      /* Raise signal again */
}</pre></div><div class="sect2" title="The waitid() System Call"><div class="titlepage"><div><div><h3 class="title" id="the_waitid_open_parenthesis_close_parent">The <span class="emphasis"><em>waitid()</em></span> System Call</h3></div></div></div><p>Like <span class="emphasis"><em>waitpid()</em></span>, <span class="emphasis"><em>waitid()</em></span> returns the
                    status of child processes. However, <span class="emphasis"><em>waitid()</em></span> provides extra
                    functionality that is unavailable with <span class="emphasis"><em>waitpid()</em></span>. This
                    system call derives from System V, but is now specified in SUSv3. It was added
                    to Linux in kernel 2.6.9.<a id="IDX-CHP-26-3939" class="indexterm"/><a id="IDX-CHP-26-3940" class="indexterm"/><a id="IDX-CHP-26-3941" class="indexterm"/><a id="IDX-CHP-26-3942" class="indexterm"/><a id="IDX-CHP-26-3943" class="indexterm"/><a id="IDX-CHP-26-3944" class="indexterm"/><a id="IDX-CHP-26-3945" class="indexterm"/><a id="IDX-CHP-26-3946" class="indexterm"/><a id="IDX-CHP-26-3947" class="indexterm"/><a id="IDX-CHP-26-3948" class="indexterm"/><a id="IDX-CHP-26-3949" class="indexterm"/><a id="IDX-CHP-26-3950" class="indexterm"/><a id="IDX-CHP-26-3951" class="indexterm"/><a id="IDX-CHP-26-3952" class="indexterm"/><a id="IDX-CHP-26-3953" class="indexterm"/><a id="IDX-CHP-26-3954" class="indexterm"/><a id="IDX-CHP-26-3955" class="indexterm"/><a id="IDX-CHP-26-3938" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Before Linux 2.6.9, a version of <span class="emphasis"><em>waitid()</em></span> was
                        provided via an implementation in <span class="emphasis"><em>glibc</em></span>. However,
                        because a full implementation of this interface requires kernel support, the
                            <span class="emphasis"><em>glibc</em></span> implementation provided no more functionality
                        than was available using <span class="emphasis"><em>waitpid()</em></span>.</p></div><a id="I_programlisting26_d1e73555"/><pre class="programlisting">#include &lt;sys/wait.h&gt;

int <strong class="userinput"><code>waitid</code></strong>(idtype_t <span class="emphasis"><em>idtype</em></span>, id_t <span class="emphasis"><em>id</em></span>, siginfo_t *<span class="emphasis"><em>infop</em></span>, int <span class="emphasis"><em>options</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success or if <code class="literal">WNOHANG</code> was
                        specified and there were no children to wait for, or -1 on error</p></div><p>The <span class="emphasis"><em>idtype</em></span> and <span class="emphasis"><em>id</em></span> arguments specify
                    which child(ren) to wait for, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If <span class="emphasis"><em>idtype</em></span> is <code class="literal">P_ALL</code>, wait for any child; <span class="emphasis"><em>id</em></span> is
                            ignored.</p></li><li class="listitem"><p>If <span class="emphasis"><em>idtype</em></span> is <code class="literal">P_PID</code>, wait for the child whose process ID equals
                                <span class="emphasis"><em>id</em></span>.</p></li><li class="listitem"><p>If <span class="emphasis"><em>idtype</em></span> is <code class="literal">P_PGID</code>, wait for any child whose process group ID equals
                                <span class="emphasis"><em>id</em></span>.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Note that unlike <span class="emphasis"><em>waitpid()</em></span>, it is not possible to
                        specify 0 in id to mean any process in the same process group as the caller.
                        Instead, we must explicitly specify the caller’s process group ID using the
                        value returned by <span class="emphasis"><em>getpgrp()</em></span>.</p></div><p>The most significant difference between <span class="emphasis"><em>waitpid()</em></span> and
                        <span class="emphasis"><em>waitid()</em></span> is that <span class="emphasis"><em>waitid()</em></span> provides
                    more precise control of the child events that should be waited for. We control
                    this by ORing one or more of the following flags in
                    <span class="emphasis"><em>options</em></span>:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">WEXITED</code>
                        </span></dt><dd><p>Wait for children that have terminated, either normally or
                                abnormally.</p></dd><dt><span class="term">
                            <code class="literal">WSTOPPED</code>
                        </span></dt><dd><p>Wait for children that have been stopped by a signal.</p></dd><dt><span class="term">
                            <code class="literal">WCONTINUED</code>
                        </span></dt><dd><p>Wait for children that have been resumed by a <code class="literal">SIGCONT</code> signal.<a id="IDX-CHP-26-3956" class="indexterm"/></p></dd></dl></div><p>The following additional flags may be ORed in
                    <span class="emphasis"><em>options</em></span>:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">WNOHANG</code>
                        </span></dt><dd><p>This flag has the same meaning as for
                                    <span class="emphasis"><em>waitpid()</em></span>. If none of the children matching
                                the specification in id has status information to return, then
                                return immediately (a poll). In this case, the return value of
                                    <span class="emphasis"><em>waitid()</em></span> is 0. If the calling process has
                                no children that match the specification in <span class="emphasis"><em>id</em></span>,
                                    <span class="emphasis"><em>waitid()</em></span> instead fails with the error
                                    <code class="literal">ECHILD</code>.</p></dd><dt><span class="term">
                            <code class="literal">WNOWAIT</code>
                        </span></dt><dd><p>Normally, once a child has been waited for using
                                    <span class="emphasis"><em>waitid()</em></span>, then that “status event” is
                                consumed. However, if <code class="literal">WNOWAIT</code> is
                                specified, then the child status is returned, but the child remains
                                in a waitable state, and we can later wait for it again to retrieve
                                the same information.</p></dd></dl></div><p>On success, <span class="emphasis"><em>waitid()</em></span> returns 0, and the
                        <span class="emphasis"><em>siginfo_t</em></span> structure (<a class="xref" href="ch21.html#the_sa_underscore_siginfo_flag" title="The SA_SIGINFO Flag">The <code class="literal">SA_SIGINFO</code> Flag</a>) pointed to by
                        <span class="emphasis"><em>infop</em></span> is updated to contain information about the
                    child. The following fields are filled in the <span class="emphasis"><em>siginfo_t</em></span>
                        structure:<a id="IDX-CHP-26-3957" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                            <span class="emphasis"><em>si_code</em></span>
                        </span></dt><dd><p>This field contains one of the following values: <code class="literal">CLD_EXITED</code>, indicating that the child
                                terminated by calling <span class="emphasis"><em>_exit()</em></span>; <code class="literal">CLD_KILLED</code>, indicating that the child
                                was killed by a signal; <code class="literal">CLD_STOPPED</code>, indicating that the child was stopped by
                                a signal; or <code class="literal">CLD_CONTINUED</code>,
                                indicating that the (previously stopped) child resumed execution as
                                a consequence of receiving a (<code class="literal">SIGCONT</code>) signal.</p></dd><dt><span class="term">
                            <span class="emphasis"><em>si_pid</em></span>
                        </span></dt><dd><p>This field contains the process ID of the child whose state has
                                changed.</p></dd><dt><span class="term">
                            <span class="emphasis"><em>si_signo</em></span>
                        </span></dt><dd><p>This field is always set to <code class="literal">SIGCHLD</code>.</p></dd><dt><span class="term">
                            <span class="emphasis"><em>si_status</em></span>
                        </span></dt><dd><p>This field contains either the exit status of the child, as passed
                                to <span class="emphasis"><em>_exit()</em></span>, or the signal that caused the child
                                to stop, continue, or terminate. We can determine which type of
                                information is in this field by examining the
                                    <span class="emphasis"><em>si_code</em></span> field.</p></dd><dt><span class="term">
                            <span class="emphasis"><em>si_uid</em></span>
                        </span></dt><dd><p>This field contains the real user ID of the child. Most other UNIX
                                implementations don’t set this field.</p></dd></dl></div><div class="note" title="Note"><h3 class="title">Note</h3><p>On Solaris, two additional fields are filled in:
                            <span class="emphasis"><em>si_stime</em></span> and <span class="emphasis"><em>si_utime</em></span>. These
                        contain the system and user CPU time used by the child, respectively. SUSv3
                        doesn’t require these fields to be set by
                        <span class="emphasis"><em>waitid()</em></span>.</p></div><p>One detail of the operation of <span class="emphasis"><em>waitid()</em></span> needs further
                    clarification. If <code class="literal">WNOHANG</code> is specified in
                        <span class="emphasis"><em>options</em></span>, then a 0 return value from
                        <span class="emphasis"><em>waitid()</em></span> can mean one of two things: a child had
                    already changed state at the time of the call (and information about the child
                    is returned in the <span class="emphasis"><em>siginfo_t</em></span> structure pointed to by
                        <span class="emphasis"><em>infop</em></span>), or there was no child whose state has changed.
                    For the case where no child has changed state, some UNIX implementations
                    (including Linux), zero out the returned <span class="emphasis"><em>siginfo_t</em></span>
                    structure. This provides a method of distinguishing the two possibilities: we
                    can check whether the value in <span class="emphasis"><em>si_pid</em></span> is 0 or nonzero.
                    Unfortunately, this behavior is not required by SUSv3, and some UNIX
                    implementations leave the <span class="emphasis"><em>siginfo_t</em></span> structure unchanged in
                    this case. (A future corrigendum to SUSv4 is likely to add a requirement that
                        <span class="emphasis"><em>si_pid</em></span> and <span class="emphasis"><em>si_signo</em></span> are zeroed in
                    this case.) The only portable way to distinguish these two cases is to zero out
                    the <span class="emphasis"><em>siginfo_t</em></span> structure before calling
                        <span class="emphasis"><em>waitid()</em></span>, as in the following code:</p><a id="I_programlisting26_d1e73859"/><pre class="programlisting">siginfo_t info;
...
memset(&amp;info, 0, sizeof(siginfo_t));
if (waitid(idtype, id, &amp;info, options | WNOHANG) == -1)
    errExit("waitid");
if (info.si_pid == 0) {
    /* No children changed state */
} else {
    /* A child changed state; details are provided in 'info' */
}</pre></div><div class="sect2" title="The wait3() and wait4() System Calls"><div class="titlepage"><div><div><h3 class="title" id="the_wait3_open_parenthesis_close_parenth">The <span class="emphasis"><em>wait3()</em></span> and <span class="emphasis"><em>wait4()</em></span> System
                    Calls</h3></div></div></div><p>The <span class="emphasis"><em>wait3()</em></span> and <span class="emphasis"><em>wait4()</em></span> system calls
                    perform a similar task to <span class="emphasis"><em>waitpid()</em></span>. The principal semantic
                    difference is that <span class="emphasis"><em>wait3()</em></span> and <span class="emphasis"><em>wait4()</em></span>
                    return <span class="emphasis"><em>resource usage</em></span> information about the terminated
                    child in the structure pointed to by the <span class="emphasis"><em>rusage</em></span> argument.
                    This information includes the amount of CPU time used by the process and
                    memory-management statistics. We defer detailed discussion of the
                        <span class="emphasis"><em>rusage</em></span> structure until <a class="xref" href="ch36.html#process_resource_usage" title="Process Resource Usage">Process Resource Usage</a>, where we describe the
                        <span class="emphasis"><em>getrusage()</em></span> system call.<a id="IDX-CHP-26-3960" class="indexterm"/><a id="IDX-CHP-26-3961" class="indexterm"/><a id="IDX-CHP-26-3962" class="indexterm"/><a id="IDX-CHP-26-3963" class="indexterm"/><a id="IDX-CHP-26-3964" class="indexterm"/><a id="IDX-CHP-26-3958" class="indexterm"/><a id="IDX-CHP-26-3959" class="indexterm"/><a id="IDX-CHP-26-3965" class="indexterm"/><a id="IDX-CHP-26-3966" class="indexterm"/><a id="IDX-CHP-26-3967" class="indexterm"/></p><a id="I_programlisting26_d1e73956"/><pre class="programlisting">#define _BSD_SOURCE       /* Or #define _XOPEN_SOURCE 500 for wait3() */
#include &lt;sys/resource.h&gt;
#include &lt;sys/wait.h&gt;

pid_t <strong class="userinput"><code>wait3</code></strong>(int *<span class="emphasis"><em>status</em></span>, int <span class="emphasis"><em>options</em></span>, struct rusage *<span class="emphasis"><em>rusage</em></span>);
pid_t <strong class="userinput"><code>wait4</code></strong>(pid_t <span class="emphasis"><em>pid</em></span>, int *<span class="emphasis"><em>status</em></span>, int <span class="emphasis"><em>options</em></span>, struct rusage *<span class="emphasis"><em>rusage</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return process ID of child, or -1 on error</p></div><p>Excluding the use of the <span class="emphasis"><em>rusage</em></span> argument, a call to
                        <span class="emphasis"><em>wait3()</em></span> is equivalent to the following
                        <span class="emphasis"><em>waitpid()</em></span> call:</p><a id="I_programlisting26_d1e74000"/><pre class="programlisting">waitpid(-1, &amp;status, options);</pre><p>Similarly, <span class="emphasis"><em>wait4()</em></span> is equivalent to the following:</p><a id="I_programlisting26_d1e74007"/><pre class="programlisting">waitpid(pid, &amp;status, options);</pre><p>In other words, <span class="emphasis"><em>wait3()</em></span> waits for any child, while
                        <span class="emphasis"><em>wait4()</em></span> can be used to select a specific child or
                    children upon which to wait.</p><p>On some UNIX implementations, <span class="emphasis"><em>wait3()</em></span> and
                        <span class="emphasis"><em>wait4()</em></span> return resource usage information only for
                    terminated children. On Linux, resource usage information can also be retrieved
                    for stopped children if the <code class="literal">WUNTRACED</code> flag is
                    specified in <span class="emphasis"><em>options</em></span>.</p><p>The names for these two system calls refer to the number of arguments they
                    each take. Both system calls originated in BSD, but are now available on most
                    UNIX implementations. Neither is standardized in SUSv3. (SUSv2 did specify
                        <span class="emphasis"><em>wait3()</em></span>, but marked it LEGACY.)</p><p>We usually avoid the use of <span class="emphasis"><em>wait3()</em></span> and
                        <span class="emphasis"><em>wait4()</em></span> in this book. Typically, we don’t need the
                    extra information returned by these calls. Also, lack of standardization limits
                    their portability.</p></div></div><div class="sect1" title="Orphans and Zombies"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="orphans_and_zombies">Orphans and Zombies</h2></div></div></div><p>The lifetimes of parent and child processes are usually not the same—either the
                parent outlives the child or vice versa. This raises two questions:<a id="IDX-CHP-26-3968" class="indexterm"/><a id="IDX-CHP-26-3969" class="indexterm"/><a id="IDX-CHP-26-3970" class="indexterm"/><a id="IDX-CHP-26-3971" class="indexterm"/><a id="IDX-CHP-26-3972" class="indexterm"/><a id="IDX-CHP-26-3973" class="indexterm"/><a id="IDX-CHP-26-3974" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Who becomes the parent of an <span class="emphasis"><em>orphaned</em></span> child? The
                        orphaned child is adopted by <span class="emphasis"><em>init</em></span>, the ancestor of all
                        processes, whose process ID is 1. In other words, after a child’s parent
                        terminates, a call to <span class="emphasis"><em>getppid()</em></span> will return the value
                        1. This can be used as a way of determining if a child’s true parent is
                        still alive (this assumes a child that was created by a process other than
                            <span class="emphasis"><em>init</em></span>).<a id="IDX-CHP-26-3975" class="indexterm"/></p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Using the <code class="literal">PR_SET_PDEATHSIG</code> operation of the
                    Linux-specific <span class="emphasis"><em>prctl()</em></span> system call, it is possible to
                    arrange that a process receives a specified signal when it becomes an
                        orphan.<a id="IDX-CHP-26-3976" class="indexterm"/></p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>What happens to a child that terminates before its parent has had a chance
                        to perform a <span class="emphasis"><em>wait()</em></span>? The point here is that, although
                        the child has finished its work, the parent should still be permitted to
                        perform a <span class="emphasis"><em>wait()</em></span> at some later time to determine how
                        the child terminated. The kernel deals with this situation by turning the
                        child into a <span class="emphasis"><em>zombie</em></span>. This means that most of the
                        resources held by the child are released back to the system to be reused by
                        other processes. The only part of the process that remains is an entry in
                        the kernel’s process table recording (among other things) the child’s
                        process ID, termination status, and resource usage statistics (<a class="xref" href="ch36.html#process_resource_usage" title="Process Resource Usage">Process Resource Usage</a>).</p></li></ul></div><p>Regarding zombies, UNIX systems imitate the movies—a zombie process can’t be
                killed by a signal, not even the (silver bullet) <code class="literal">SIGKILL</code>. This ensures that the parent can always eventually perform a
                    <span class="emphasis"><em>wait()</em></span>.<a id="IDX-CHP-26-3977" class="indexterm"/></p><p>When the parent does perform a <span class="emphasis"><em>wait()</em></span>, the kernel removes the
                zombie, since the last remaining information about the child is no longer required.
                On the other hand, if the parent terminates without doing a
                    <span class="emphasis"><em>wait()</em></span>, then the <span class="emphasis"><em>init</em></span> process adopts
                the child and automatically performs a <span class="emphasis"><em>wait()</em></span>, thus removing
                the zombie process from the system.</p><p>If a parent creates a child, but fails to perform a <span class="emphasis"><em>wait()</em></span>,
                then an entry for the zombie child will be maintained indefinitely in the kernel’s
                process table. If a large number of such zombie children are created, they will
                eventually fill the kernel process table, preventing the creation of new processes.
                Since the zombies can’t be killed by a signal, the only way to remove them from the
                system is to kill their parent (or wait for it to exit), at which time the zombies
                are adopted and waited on by <span class="emphasis"><em>init</em></span>, and consequently removed
                from the system.</p><p>These semantics have important implications for the design of long-lived parent
                processes, such as network servers and shells, that create numerous children. To put
                things another way, in such applications, a parent process should perform
                    <span class="emphasis"><em>wait()</em></span> calls in order to ensure that dead children are
                always removed from the system, rather than becoming long-lived zombies. The parent
                may perform such <span class="emphasis"><em>wait()</em></span> calls either synchronously, or
                asynchronously, in response to delivery of the <code class="literal">SIGCHLD</code> signal, as described in <a class="xref" href="ch26.html#establishing_a_handler_for_sigchld" title="Establishing a Handler for SIGCHLD">Establishing a Handler for <code class="literal">SIGCHLD</code></a>.<a id="IDX-CHP-26-3978" class="indexterm"/></p><p><a class="xref" href="ch26.html#creating_a_zombie_child_process" title="Example 26-4. Creating a zombie child process">Example 26-4</a> demonstrates the creation of a
                zombie and that a zombie can’t be killed by <code class="literal">SIGKILL</code>. When we run this program, we see the following
                output:</p><a id="I_programlisting26_d1e74187"/><pre class="programlisting">$ <strong class="userinput"><code>./make_zombie</code></strong>
Parent PID=1013
Child (PID=1014) exiting
 1013 pts/4    00:00:00 make_zombie                       <em class="lineannotation"><span class="lineannotation">Output from</span></em> <strong class="userinput"><code>ps(1)</code></strong>
 1014 pts/4    00:00:00 make_zombie &lt;defunct&gt;
After sending SIGKILL to make_zombie (PID=1014):
 1013 pts/4    00:00:00 make_zombie                       <em class="lineannotation"><span class="lineannotation">Output from</span></em> <strong class="userinput"><code>ps(1)</code></strong>
 1014 pts/4    00:00:00 make_zombie &lt;defunct&gt;</pre><p>In the above output, we see that <span class="emphasis"><em>ps(1)</em></span> displays the string
                    <code class="literal">&lt;defunct&gt;</code> to indicate a process
                in the zombie state.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The program in <a class="xref" href="ch26.html#creating_a_zombie_child_process" title="Example 26-4. Creating a zombie child process">Example 26-4</a> uses the
                        <span class="emphasis"><em>system()</em></span> function to execute the shell command given in
                    its character-string argument. We describe <span class="emphasis"><em>system()</em></span> in
                    detail in Section 27.6.</p></div><div class="example"><a id="creating_a_zombie_child_process"/><div class="example-title">Example 26-4. Creating a zombie child process</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procexec/make_zombie.c</code></strong>
#include &lt;signal.h&gt;
#include &lt;libgen.h&gt;             /* For basename() declaration */
#include "tlpi_hdr.h"

#define CMD_SIZE 200

int
main(int argc, char *argv[])
{
    char cmd[CMD_SIZE];
    pid_t childPid;

    setbuf(stdout, NULL);       /* Disable buffering of stdout */

    printf("Parent PID=%ld\n", (long) getpid());

    switch (childPid = fork()) {
    case -1:
        errExit("fork");

    case 0:     /* Child: immediately exits to become zombie */
        printf("Child (PID=%ld) exiting\n", (long) getpid());
        _exit(EXIT_SUCCESS);

        default:    /* Parent */
        sleep(3);               /* Give child a chance to start and exit */
        snprintf(cmd, CMD_SIZE, "ps | grep %s", basename(argv[0]));
        cmd[CMD_SIZE - 1] = '\0';       /* Ensure string is null-terminated */
        system(cmd);            /* View zombie child */

        /* Now send the "sure kill" signal to the zombie */

        if (kill(childPid, SIGKILL) == -1)
            errMsg("kill");
        sleep(3);               /* Give child a chance to react to signal */
        printf("After sending SIGKILL to zombie (PID=%ld):\n", (long) childPid);
        system(cmd);            /* View zombie child again */

        exit(EXIT_SUCCESS);
    }
}
      <strong class="userinput"><code>procexec/make_zombie.c</code></strong></pre></div></div></div><div class="sect1" title="The SIGCHLD Signal"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_sigchld_signal">The <code class="literal">SIGCHLD</code> Signal</h2></div></div></div><p>The termination of a child process is an event that occurs asynchronously. A
                parent can’t predict when one of its child will terminate. (Even if the parent sends
                a <code class="literal">SIGKILL</code> signal to the child, the exact time of
                termination is still dependent on when the child is next scheduled for use of a
                CPU.) We have already seen that the parent should use <span class="emphasis"><em>wait()</em></span>
                (or similar) in order to prevent the accumulation of zombie children, and have
                looked at two ways in which this can be done:<a id="IDX-CHP-26-3979" class="indexterm"/><a id="IDX-CHP-26-3980" class="indexterm"/><a id="IDX-CHP-26-3981" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The parent can call <span class="emphasis"><em>wait()</em></span>, or
                            <span class="emphasis"><em>waitpid()</em></span> without specifying the <code class="literal">WNOHANG</code> flag, in which case the call will
                        block if a child has not already terminated.</p></li><li class="listitem"><p>The parent can periodically perform a nonblocking check (a poll) for dead
                        children via a call to <span class="emphasis"><em>waitpid()</em></span> specifying the
                            <code class="literal">WNOHANG</code> flag.</p></li></ul></div><p>Both of these approaches can be inconvenient. On the one hand, we may not want the
                parent to be blocked waiting for a child to terminate. On the other hand, making
                repeated nonblocking <span class="emphasis"><em>waitpid()</em></span> calls wastes CPU time and adds
                complexity to an application design. To get around these problems, we can employ a
                handler for the <code class="literal">SIGCHLD</code> signal.<a id="IDX-CHP-26-3982" class="indexterm"/></p><div class="sect2" title="Establishing a Handler for SIGCHLD"><div class="titlepage"><div><div><h3 class="title" id="establishing_a_handler_for_sigchld">Establishing a Handler for <code class="literal">SIGCHLD</code></h3></div></div></div><p>The <code class="literal">SIGCHLD</code> signal is sent to a parent
                    process whenever one of its children terminates. By default, this signal is
                    ignored, but we can catch it by installing a signal handler. Within the signal
                    handler, we can use <span class="emphasis"><em>wait()</em></span> (or similar) to reap the zombie
                    child. However, there is a subtlety to consider in this approach.</p><p>In <a class="xref" href="ch20.html#the_signal_mask_open_parenthesis_blockin" title="The Signal Mask (Blocking Signal Delivery)">The Signal Mask (Blocking Signal Delivery)</a> and <a class="xref" href="ch20.html#signals_are_not_queued" title="Signals Are Not Queued">Signals Are Not Queued</a>, we observed that when a signal handler
                    is called, the signal that caused its invocation is temporarily blocked (unless
                    the <span class="emphasis"><em>sigaction()</em></span>
                    <code class="literal">SA_NODEFER</code> flag was specified), and also that
                    standard signals, of which <code class="literal">SIGCHLD</code> is one,
                    are not queued. Consequently, if a second and third child terminate in quick
                    succession while a <code class="literal">SIGCHLD</code> handler is
                    executing for an already terminated child, then, although <code class="literal">SIGCHLD</code> is generated twice, it is queued only once
                    to the parent. As a result, if the parent’s <code class="literal">SIGCHLD</code> handler called <span class="emphasis"><em>wait()</em></span> only once each
                    time it was invoked, the handler might fail to reap some zombie children.</p><p>The solution is to loop inside the <code class="literal">SIGCHLD</code>
                    handler, repeatedly calling <span class="emphasis"><em>waitpid()</em></span> with the <code class="literal">WNOHANG</code> flag until there are no more dead children
                    to be reaped. Often, the body of a <code class="literal">SIGCHLD</code>
                    handler simply consists of the following code, which reaps any dead children
                    without checking their status:</p><a id="I_programlisting26_d1e74352"/><pre class="programlisting">while (waitpid(-1, NULL, WNOHANG) &gt; 0)
    continue;</pre><p>The above loop continues until <span class="emphasis"><em>waitpid()</em></span> returns either
                    0, indicating no more zombie children, or -1, indicating an error (probably
                        <code class="literal">ECHILD</code>, meaning that there are no more
                    children).</p><div class="sect3" title="Design issues for SIGCHLD handlers"><div class="titlepage"><div><div><h4 class="title" id="design_issues_for_sigchld_handlers">Design issues for <code class="literal">SIGCHLD</code>
                        handlers</h4></div></div></div><p>Suppose that, at the time we establish a handler for <code class="literal">SIGCHLD</code>, there is already a terminated child
                        for this process. Does the kernel then immediately generate a <code class="literal">SIGCHLD</code> signal for the parent? SUSv3 leaves
                        this point unspecified. Some System V-derived implementations do generate a
                            <code class="literal">SIGCHLD</code> in these circumstances; other
                        implementations, including Linux, do not. A portable application can make
                        this difference invisible by establishing the <code class="literal">SIGCHLD</code> handler before creating any children. (This is
                        usually the natural way of doing things, of course.)<a id="IDX-CHP-26-3983" class="indexterm"/><a id="IDX-CHP-26-3984" class="indexterm"/><a id="IDX-CHP-26-3985" class="indexterm"/><a id="IDX-CHP-26-3986" class="indexterm"/></p><p>A further point to consider is the issue of reentrancy. In <a class="xref" href="ch21.html#reentrant_and_async-signal-safe_function" title="Reentrant and Async-Signal-Safe Functions">Reentrant and Async-Signal-Safe Functions</a>, we noted that
                        using a system call (e.g., <span class="emphasis"><em>waitpid()</em></span>) from within a
                        signal handler may change the value of the global variable
                            <span class="emphasis"><em>errno</em></span>. Such a change could interfere with attempts
                        by the main program to explicitly set <span class="emphasis"><em>errno</em></span> (see, for
                        example, the discussion of <span class="emphasis"><em>getpriority()</em></span> in <a class="xref" href="ch35.html#process_priorities_open_parenthesis_nice" title="Process Priorities (Nice Values)">Process Priorities (Nice Values)</a>) or check its value
                        after a failed system call. For this reason, it is sometimes necessary to
                        code a <code class="literal">SIGCHLD</code> handler to save
                            <span class="emphasis"><em>errno</em></span> in a local variable on entry to the handler,
                        and then restore the <span class="emphasis"><em>errno</em></span> value just prior to
                        returning. An example of this is shown in <a class="xref" href="ch26.html#reaping_dead_children_via_a_handler_for" title="Example 26-5. Reaping dead children via a handler for SIGCHLD">Example 26-5</a>.<a id="IDX-CHP-26-3987" class="indexterm"/></p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id32">Example program</h4></div></div></div><p><a class="xref" href="ch26.html#reaping_dead_children_via_a_handler_for" title="Example 26-5. Reaping dead children via a handler for SIGCHLD">Example 26-5</a> provides an
                        example of a more complex <code class="literal">SIGCHLD</code>
                        handler. This handler displays the process ID and wait status of each reaped
                        child <span class="inlinemediaobject"><a id="I_inlinemediaobject26_d1e74447"/><img src="figs/web/U001.png" alt=""/></span>. In order to see that multiple <code class="literal">SIGCHLD</code> signals are not queued while the handler is already
                        invoked, execution of the handler is artificially lengthened by a call to
                            <span class="emphasis"><em>sleep()</em></span>
                        <span class="inlinemediaobject"><a id="I_inlinemediaobject26_d1e74459"/><img src="figs/web/U002.png" alt=""/></span>. The main program creates one child process for each
                        (integer) command-line argument <span class="inlinemediaobject"><a id="I_inlinemediaobject26_d1e74466"/><img src="figs/web/U004.png" alt=""/></span>. Each of these children sleeps for the number of
                        seconds specified in the corresponding command-line argument and then exits
                            <span class="inlinemediaobject"><a id="I_inlinemediaobject26_d1e74472"/><img src="figs/web/U005.png" alt=""/></span>. In the following example of the execution of this
                        program, we see that even though three children terminate, <code class="literal">SIGCHLD</code> is only queued twice to the
                            parent:<a id="IDX-CHP-26-3988" class="indexterm"/><a id="IDX-CHP-26-3989" class="indexterm"/><a id="IDX-CHP-26-3990" class="indexterm"/></p><a id="I_programlisting26_d1e74501"/><pre class="programlisting">$ <strong class="userinput"><code>./multi_SIGCHLD 1 2 4</code></strong>
16:45:18 Child 1 (PID=17767) exiting
16:45:18 handler: Caught SIGCHLD            <em class="lineannotation"><span class="lineannotation">First invocation of handler</span></em>
16:45:18 handler: Reaped child 17767 - child exited, status=0
16:45:19 Child 2 (PID=17768) exiting        <em class="lineannotation"><span class="lineannotation">These children terminate during...</span></em>
16:45:21 Child 3 (PID=17769) exiting        <em class="lineannotation"><span class="lineannotation">first invocation of handler</span></em>
16:45:23 handler: returning                 <em class="lineannotation"><span class="lineannotation">End of first invocation of handler</span></em>
16:45:23 handler: Caught SIGCHLD            <em class="lineannotation"><span class="lineannotation">Second invocation of handler</span></em>
16:45:23 handler: Reaped child 17768 - child exited, status=0
16:45:23 handler: Reaped child 17769 - child exited, status=0
16:45:28 handler: returning
16:45:28 All 3 children have terminated; SIGCHLD was caught 2 times</pre><p>Note the use of <span class="emphasis"><em>sigprocmask()</em></span> to block the SIGCHLD
                        signal before any children are created in <a class="xref" href="ch26.html#reaping_dead_children_via_a_handler_for" title="Example 26-5. Reaping dead children via a handler for SIGCHLD">Example 26-5</a>
                        <span class="inlinemediaobject"><a id="I_inlinemediaobject26_d1e74529"/><img src="figs/web/U003.png" alt=""/></span>. This is done to ensure correct operation of the
                            <span class="emphasis"><em>sigsuspend()</em></span> loop in the parent. If we failed to
                        block <code class="literal">SIGCHLD</code> in this way, and a child
                        terminated between the test of the value of
                            <span class="emphasis"><em>numLiveChildren</em></span> and the execution of the
                            <span class="emphasis"><em>sigsuspend()</em></span> call (or alternatively a
                            <span class="emphasis"><em>pause()</em></span> call), then the
                            <span class="emphasis"><em>sigsuspend()</em></span> call would block forever waiting for a
                        signal that has already been caught <span class="inlinemediaobject"><a id="I_inlinemediaobject26_d1e74554"/><img src="figs/web/U006.png" alt=""/></span>. The requirement for dealing with this type of race
                        condition was detailed in Section 22.9.</p><div class="example"><a id="reaping_dead_children_via_a_handler_for"/><div class="example-title">Example 26-5. Reaping dead children via a handler for <code class="literal">SIGCHLD</code></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procexec/multi_SIGCHLD.c</code></strong>
    #include &lt;signal.h&gt;
    #include &lt;sys/wait.h&gt;
    #include "print_wait_status.h"
    #include "curr_time.h"
    #include "tlpi_hdr.h"

    static volatile int numLiveChildren = 0;
                    /* Number of children started but not yet waited on */

    static void
    sigchldHandler(int sig)
    {

        int status, savedErrno;
        pid_t childPid;

        /* UNSAFE: This handler uses non-async-signal-safe functions
           (printf(), printWaitStatus(), currTime(); see Section 21.1.2) */

        savedErrno = errno;     /* In case we modify 'errno' */

        printf("%s handler: Caught SIGCHLD\n", currTime("%T"));

        while ((childPid = waitpid(-1, &amp;status, WNOHANG)) &gt; 0) {
<img src="figs/web/U001.png" alt=""/>
            printf("%s handler: Reaped child %ld - ", currTime("%T"),
                    (long) childPid);
            printWaitStatus(NULL, status);
            numLiveChildren—;
        }

        if (childPid == -1 &amp;&amp; errno != ECHILD)
            errMsg("waitpid");
    <img src="figs/web/U002.png" alt=""/>    sleep(5);               /* Artificially lengthen execution of handler */
        printf("%s handler: returning\n", currTime("%T"));

        errno = savedErrno;
    }

    int
    main(int argc, char *argv[])
    {
        int j, sigCnt;
        sigset_t blockMask, emptyMask;
        struct sigaction sa;

        if (argc &lt; 2 || strcmp(argv[1], "—help") == 0)
            usageErr("%s child-sleep-time...\n", argv[0]);

        setbuf(stdout, NULL);       /* Disable buffering of stdout */

        sigCnt = 0;
        numLiveChildren = argc - 1;

        sigemptyset(&amp;sa.sa_mask);
        sa.sa_flags = 0;
        sa.sa_handler = sigchldHandler;
        if (sigaction(SIGCHLD, &amp;sa, NULL) == -1)
            errExit("sigaction");

        /* Block SIGCHLD to prevent its delivery if a child terminates
           before the parent commences the sigsuspend() loop below */

        sigemptyset(&amp;blockMask);
        sigaddset(&amp;blockMask, SIGCHLD);
<img src="figs/web/U003.png" alt=""/>    if (sigprocmask(SIG_SETMASK, &amp;blockMask, NULL) == -1)
            errExit("sigprocmask");

<img src="figs/web/U004.png" alt=""/>    for (j = 1; j &lt; argc; j++) {
            switch (fork()) {
            case -1:
                errExit("fork");

            case 0:         /* Child - sleeps and then exits */
<img src="figs/web/U005.png" alt=""/>            sleep(getInt(argv[j], GN_NONNEG, "child-sleep-time"));
                printf("%s Child %d (PID=%ld) exiting\n", currTime("%T"),
                        j, (long) getpid());
                _exit(EXIT_SUCCESS);

            default:        /* Parent - loops to create next child */
                break;
            }
        }

            /* Parent comes here: wait for SIGCHLD until all children are dead */

        sigemptyset(&amp;emptyMask);
        while (numLiveChildren &gt; 0) {
<img src="figs/web/U006.png" alt=""/>        if (sigsuspend(&amp;emptyMask) == -1 &amp;&amp; errno != EINTR)
                errExit("sigsuspend");
            sigCnt++;
        }

        printf("%s All %d children have terminated; SIGCHLD was caught "
                "%d times\n", currTime("%T"), argc - 1, sigCnt);

        exit(EXIT_SUCCESS);
    }
          <strong class="userinput"><code>procexec/multi_SIGCHLD.c</code></strong></pre></div></div></div></div><div class="sect2" title="Delivery of SIGCHLD for Stopped Children"><div class="titlepage"><div><div><h3 class="title" id="delivery_of_sigchld_for_stopped_children">Delivery of <code class="literal">SIGCHLD</code> for Stopped
                    Children</h3></div></div></div><p>Just as <span class="emphasis"><em>waitpid()</em></span> can be used to monitor stopped
                    children, so is it possible for a parent process to receive the <code class="literal">SIGCHLD</code> signal when one of its children is stopped
                    by a signal. This behavior is controlled by the <code class="literal">SA_NOCLDSTOP</code> flag when using <span class="emphasis"><em>sigaction()</em></span> to
                    establish a handler for the <code class="literal">SIGCHLD</code> signal.
                    If this flag is omitted, a <code class="literal">SIGCHLD</code> signal is
                    delivered to the parent when one of its children stops; if the flag is present,
                        <code class="literal">SIGCHLD</code> is not delivered for stopped
                    children. (The implementation of <span class="emphasis"><em>signal()</em></span> given in <a class="xref" href="ch22.html#implementation_and_portability_of_signal" title="Implementation and Portability of signal()">Implementation and Portability of <span class="emphasis"><em>signal()</em></span></a> doesn’t specify
                        <code class="literal">SA_NOCLDSTOP</code>.)<a id="IDX-CHP-26-3991" class="indexterm"/><a id="IDX-CHP-26-3992" class="indexterm"/><a id="IDX-CHP-26-3993" class="indexterm"/><a id="IDX-CHP-26-3994" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since <code class="literal">SIGCHLD</code> is ignored by default,
                        the <code class="literal">SA_NOCLDSTOP</code> flag has a meaning only
                        if we are establishing a handler for <code class="literal">SIGCHLD</code>. Furthermore, <code class="literal">SIGCHLD</code> is the only signal for which the <code class="literal">SA_NOCLDSTOP</code> flag has an effect.</p></div><p>SUSv3 also allows for a parent to be sent a <code class="literal">SIGCHLD</code> signal if one of its stopped children is resumed by being
                    sent a <code class="literal">SIGCONT</code> signal. (This corresponds to
                    the <code class="literal">WCONTINUED</code> flag for
                        <span class="emphasis"><em>waitpid()</em></span>.) This feature is implemented in Linux since
                    kernel 2.6.9.<a id="IDX-CHP-26-3995" class="indexterm"/></p></div><div class="sect2" title="Ignoring Dead Child Processes"><div class="titlepage"><div><div><h3 class="title" id="ignoring_dead_child_processes">Ignoring Dead Child Processes</h3></div></div></div><p>There is a further possibility for dealing with dead child processes.
                    Explicitly setting the disposition of <code class="literal">SIGCHLD</code>
                    to <code class="literal">SIG_IGN</code> causes any child process that
                    subsequently terminates to be immediately removed from the system instead of
                    being converted into a zombie. In this case, since the status of the child
                    process is simply discarded, a subsequent call to <span class="emphasis"><em>wait()</em></span>
                    (or similar) can’t return any information for the terminated child.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Note that even though the default disposition for <code class="literal">SIGCHLD</code> is to be ignored, explicitly setting the disposition
                        to <code class="literal">SIG_IGN</code> causes the different behavior
                        described here. In this respect, <code class="literal">SIGCHLD</code>
                        is treated uniquely among signals.</p></div><p>On Linux, as on many UNIX implementations, setting the disposition of <code class="literal">SIGCHLD</code> to <code class="literal">SIG_IGN</code> doesn’t affect the status of any existing zombie
                    children, which must still be waited upon in the usual way. On some other UNIX
                    implementations (e.g., Solaris 8), setting the disposition of <code class="literal">SIGCHLD</code> to <code class="literal">SIG_IGN</code>
                    <span class="emphasis"><em>does</em></span> remove existing zombie children.</p><p>The <code class="literal">SIG_IGN</code> semantics for <code class="literal">SIGCHLD</code> have a long history, deriving from System
                    V. SUSv3 specifies the behavior described here, but these semantics were left
                    unspecified in the original POSIX.1 standard. Thus, on some older UNIX
                    implementations, ignoring <code class="literal">SIGCHLD</code> has no
                    effect on the creation of zombies. The only completely portable way of
                    preventing the creation of zombies is to call <span class="emphasis"><em>wait()</em></span> or
                        <span class="emphasis"><em>waitpid()</em></span>, possibly from within a handler established
                    for <code class="literal">SIGCHLD</code>.</p><div class="sect3" title="Deviations from SUSv3 in older Linux kernels"><div class="titlepage"><div><div><h4 class="title" id="deviations_from_susv3_in_older_linux_ker">Deviations from SUSv3 in older Linux kernels</h4></div></div></div><p>SUSv3 specifies that if the disposition of <code class="literal">SIGCHLD</code> is set to <code class="literal">SIG_IGN</code>,
                        the resource usage information for the child should be discarded and not
                        included in the totals returned when the parent makes a call to
                            <span class="emphasis"><em>getrusage()</em></span> specifying the <code class="literal">RUSAGE_CHILDREN</code> flag (<a class="xref" href="ch36.html#process_resource_usage" title="Process Resource Usage">Process Resource Usage</a>). However, on Linux versions before kernel 2.6.9, the CPU times and
                        resources used by the child <span class="emphasis"><em>are</em></span> recorded and are
                        visible in calls to <span class="emphasis"><em>getrusage()</em></span>. This nonconformance is
                        fixed in Linux 2.6.9 and later.<a id="IDX-CHP-26-3996" class="indexterm"/><a id="IDX-CHP-26-3997" class="indexterm"/><a id="IDX-CHP-26-3998" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Setting the disposition of <code class="literal">SIGCHLD</code>
                            to <code class="literal">SIG_IGN</code> should also prevent the
                            child CPU times from being included in the structure returned by
                                <span class="emphasis"><em>times()</em></span> (<a class="xref" href="ch10.html#process_time" title="Process Time">Process Time</a>).
                            However, on Linux kernels before 2.6.9, a similar nonconformance applies
                            for the information returned by <span class="emphasis"><em>times()</em></span>.<a id="IDX-CHP-26-3999" class="indexterm"/></p></div><p>SUSv3 specifies that if the disposition of <code class="literal">SIGCHLD</code> is set to <code class="literal">SIG_IGN</code>,
                        and the parent has no terminated children that have been transformed into
                        zombies and have not yet been waited for, then a call to
                            <span class="emphasis"><em>wait()</em></span> (or <span class="emphasis"><em>waitpid()</em></span>) should
                        block until <span class="emphasis"><em>all</em></span> of the parent’s children have
                        terminated, at which point the call should terminate with the error <code class="literal">ECHILD</code>. Linux 2.6 conforms to this
                        requirement. However, in Linux 2.4 and earlier, <span class="emphasis"><em>wait()</em></span>
                        blocks only until the <span class="emphasis"><em>next</em></span> child terminates, and then
                        returns the process ID and status of that child (i.e., the behavior is the
                        same as if the disposition of <code class="literal">SIGCHLD</code> had
                        not been set to <code class="literal">SIG_IGN</code>).</p></div><div class="sect3" title="The sigaction()SA_NOCLDWAIT flag"><div class="titlepage"><div><div><h4 class="title" id="the_sigaction_open_parenthesis_close_par">The <span class="emphasis"><em>sigaction()</em></span><code class="literal">SA_NOCLDWAIT</code> flag</h4></div></div></div><p>SUSv3 specifies the <code class="literal">SA_NOCLDWAIT</code> flag,
                        which can be used when setting the disposition of the <code class="literal">SIGCHLD</code> signal using
                            <span class="emphasis"><em>sigaction()</em></span>. This flag produces behavior similar to
                        that when the disposition of <code class="literal">SIGCHLD</code> is
                        set to <code class="literal">SIG_IGN</code>. This flag was not
                        implemented in Linux 2.4 and earlier, but is implemented in Linux
                        2.6.</p><p>The principal difference between setting the disposition of <code class="literal">SIGCHLD</code> to <code class="literal">SIG_IGN</code> and employing <code class="literal">SA_NOCLDWAIT</code> is that, when establishing a handler with
                            <code class="literal">SA_NOCLDWAIT</code>, SUSv3 leaves it
                        unspecified whether or not a <code class="literal">SIGCHLD</code>
                        signal is sent to the parent when a child terminates. In other words, an
                        implementation is permitted to deliver <code class="literal">SIGCHLD</code> when <code class="literal">SA_NOCLDWAIT</code>
                        is specified, and an application could catch this signal (although the
                            <code class="literal">SIGCHLD</code> handler would not be able to
                        reap the child status using <span class="emphasis"><em>wait()</em></span>, since the kernel
                        has already discarded the zombie). On some UNIX implementations, including
                        Linux, the kernel does generate a <code class="literal">SIGCHLD</code>
                        signal for the parent process. On other UNIX implementations, <code class="literal">SIGCHLD</code> is not generated.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When setting the <code class="literal">SA_NOCLDWAIT</code> flag
                            for the <code class="literal">SIGCHLD</code> signal, older Linux
                            kernels demonstrate the same details of nonconformance to SUSv3 as were
                            described above for setting the disposition of <code class="literal">SIGCHLD</code> to <code class="literal">SIG_IGN</code>.</p></div></div><div class="sect3" title="The System V SIGCLD signal"><div class="titlepage"><div><div><h4 class="title" id="the_system_v_sigcld_signal">The System V <code class="literal">SIGCLD</code> signal</h4></div></div></div><p>On Linux, the name SIGCLD is provided as a synonym for the <code class="literal">SIGCHLD</code> signal. The reason for the existence
                        of both names is historical. The <code class="literal">SIGCHLD</code>
                        signal originated on BSD, and this name was adopted by POSIX, which largely
                        standardized on the BSD signal model. System V provided the corresponding
                            <code class="literal">SIGCLD</code> signal, with slightly
                        different semantics.<a id="IDX-CHP-26-4000" class="indexterm"/></p><p>The key difference between BSD <code class="literal">SIGCHLD</code>
                        and System V <code class="literal">SIGCLD</code> lies in what happens
                        when the disposition of the signal was set to <code class="literal">SIG_IGN</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On historical (and some contemporary) BSD implementations, the
                                system continues to generate zombies for unwaited-for children, even
                                when <code class="literal">SIGCHLD</code> is ignored.</p></li><li class="listitem"><p>On System V, using <span class="emphasis"><em>signal()</em></span> (but not
                                    <span class="emphasis"><em>sigaction()</em></span>) to ignore <code class="literal">SIGCLD</code> has the result that zombies are
                                not generated when children died.</p></li></ul></div><p>As already noted, the original POSIX.1 standard left the result of
                        ignoring <code class="literal">SIGCHLD</code> unspecified, thus
                        permitting the System V behavior. Nowadays, this System V behavior is
                        specified as part of SUSv3 (which nevertheless holds to the name <code class="literal">SIGCHLD</code>). Modern System V derivatives use the
                        standard name <code class="literal">SIGCHLD</code> for this signal,
                        but continue to provide the synonym <code class="literal">SIGCLD</code>. Further details on <code class="literal">SIGCLD</code> can be found in [Stevens &amp; Rago, 2005].</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id25">Summary</h2></div></div></div><p>Using <span class="emphasis"><em>wait()</em></span> and <span class="emphasis"><em>waitpid()</em></span> (and other
                related functions), a parent process can obtain the status of its terminated and
                stopped children. This status indicates whether a child process terminated normally
                (with an exit status indicating either success or failure), terminated abnormally,
                was stopped by a signal, or was resumed by a <code class="literal">SIGCONT</code> signal.<a id="IDX-CHP-26-4001" class="indexterm"/><a id="IDX-CHP-26-4002" class="indexterm"/></p><p>If a child’s parent terminates, the child becomes an orphan and is adopted by the
                    <span class="emphasis"><em>init</em></span> process, whose process ID is 1.</p><p>When a child process terminates, it becomes a zombie, and is removed from the
                system only when its parent calls <span class="emphasis"><em>wait()</em></span> (or similar) to
                retrieve the child’s status. Long-running programs such as shells and daemons should
                be designed so that they always reap the status of the child processes they create,
                since a process in the zombie state can’t be killed, and unreaped zombies will
                eventually clog the kernel process table.</p><p>A common way of reaping dead child processes is to establish a handler for the
                    <code class="literal">SIGCHLD</code> signal. This signal is delivered to a
                parent process whenever one of its children terminates, and optionally when a child
                is stopped by a signal. Alternatively, but somewhat less portably, a process may
                elect to set the disposition of <code class="literal">SIGCHLD</code> to
                    <code class="literal">SIG_IGN</code>, in which case the status of
                terminated children is immediately discarded (and thus can’t later be retrieved by
                the parent), and the children don’t become zombies.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id29"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id30">Further information</h4></div></div></div><p>Refer to the sources of further information listed in Section 24.6.</p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id16">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Write a program to verify that when a child’s parent terminates, a call to
                            <span class="emphasis"><em>getppid()</em></span> returns 1 (the process ID of
                            <span class="emphasis"><em>init</em></span>).</p></li><li class="listitem"><p>Suppose that we have three processes related as grandparent, parent, and
                        child, and that the grandparent doesn’t immediately perform a
                            <span class="emphasis"><em>wait()</em></span> after the parent exits, so that the parent
                        becomes a zombie. When do you expect the grandchild to be adopted by
                            <span class="emphasis"><em>init</em></span> (so that <span class="emphasis"><em>getppid()</em></span> in the
                        grandchild returns 1): after the parent terminates or after the grandparent
                        does a <span class="emphasis"><em>wait()</em></span>? Write a program to verify your
                        answer.</p></li><li class="listitem"><p>Replace the use of <span class="emphasis"><em>waitpid()</em></span> with
                            <span class="emphasis"><em>waitid()</em></span> in <a class="xref" href="ch26.html#using_waitpid_open_parenthesis_close_par" title="Example 26-3. Using waitpid() to retrieve the status of a child process">Example 26-3</a> (<code class="literal">child_status.c</code>). The call to
                            <span class="emphasis"><em>printWaitStatus()</em></span> will need to be replaced by code
                        that prints relevant fields from the <span class="emphasis"><em>siginfo_t</em></span>
                        structure returned by <span class="emphasis"><em>waitid()</em></span>.</p></li><li class="listitem"><p><a class="xref" href="ch26.html#creating_a_zombie_child_process" title="Example 26-4. Creating a zombie child process">Example 26-4</a> (<code class="literal">make_zombie.c</code>) uses a call to
                            <span class="emphasis"><em>sleep()</em></span> to allow the child process a chance to
                        execute and terminate before the parent executes
                            <span class="emphasis"><em>system()</em></span>. This approach produces a theoretical race
                        condition. Modify the program to eliminate the race condition by using
                        signals to synchronize the parent and child.<a id="IDX-CHP-26-4003" class="indexterm"/></p></li></ol></div></div></section></body></html>
