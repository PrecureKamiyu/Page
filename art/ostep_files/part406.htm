<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>RAID-4 Analysis</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part405.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part407.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">RAID-4 Analysis</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 90%;text-align: justify;">Let us now analyze RAID-4. From a capacity standpoint, RAID-4 uses 1 disk for parity information for every group of disks it is protecting. Thus, our useful capacity for a RAID group is (N-1).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Reliability is also quite easy to understand: RAID-4 tolerates 1 disk failure and no more. If more than one disk is lost, there is simply no way to reconstruct the lost data.</p><p class="s44" style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;"><span class="p">Finally, there is performance. This time, let us start by analyzing steady- state throughput. Sequential read performance can utilize all of the disks except for the parity disk, and thus deliver a peak effective bandwidth of </span>(<span class="s43">N </span><span class="s4">− </span>1) <span class="s4">· </span><span class="s43">S </span><span class="p">MB/s (an easy case).</span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">To understand the performance of sequential writes, we must first un- derstand how they are done. When writing a big chunk of data to disk,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">RAID-4 can perform a simple optimization known as a <b>full-stripe write</b>. For example, imagine the case where the blocks 0, 1, 2, and 3 have been sent to the RAID as part of a write request (Table <span style=" color: #00AEEF;">38.4</span>).</p><p style="text-indent: 0pt;text-align: left;"><span><img width="229" height="16" alt="image" src="Image_563.png"/></span></p><p class="s5" style="padding-top: 4pt;padding-left: 133pt;text-indent: 0pt;text-align: justify;">Disk 0  Disk 1  Disk 2  Disk 3  Disk 4</p><p class="s5" style="padding-top: 1pt;padding-left: 142pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0    1    2    3    P0</p><p class="s5" style="padding-left: 142pt;text-indent: 0pt;line-height: 10pt;text-align: left;">4    5    6    7    P1</p><p class="s5" style="padding-left: 142pt;text-indent: 0pt;line-height: 10pt;text-align: left;">8    9    10    11    P2</p><p class="s5" style="padding-left: 140pt;text-indent: 0pt;line-height: 10pt;text-align: left;">12    13    14    15    P3</p><p style="padding-top: 5pt;padding-left: 132pt;text-indent: 0pt;text-align: justify;">Table 38.4: <b>Full-stripe Writes In RAID-4</b></p><p style="padding-top: 2pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this case, the RAID can simply calculate the new value of P0 (by performing an XOR across the blocks 0, 1, 2, and 3) and then write all of the blocks (including the parity block) to the five disks above in parallel (highlighted in gray in the figure). Thus, full-stripe writes are the most efficient way for RAID-4 to write to disk.</p><p class="s44" style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;"><span class="p">Once we understand the full-stripe write, calculating the performance of sequential writes on RAID-4 is easy; the effective bandwidth is also </span>(<span class="s43">N </span><span class="s4">− </span>1) <span class="s4">· </span><span class="s43">S </span><span class="p">MB/s. Even though the parity disk is constantly in use during the operation, the client does not gain performance advantage from it.</span></p><p class="s44" style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;"><span class="p">Now let us analyze the performance of random reads. As you can also see from the figure above, a set of 1-block random reads will be spread across the data disks of the system but not the parity disk. Thus, the effective performance is: </span>(<span class="s43">N </span><span class="s4">− </span>1) <span class="s4">· </span><span class="s43">R </span><span class="p">MB/s.</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Random writes, which we have saved for last, present the most in- teresting case for RAID-4. Imagine we wish to overwrite block 1 in the example above. We could just go ahead and overwrite it, but that would leave us with a problem: the parity block P0 would no longer accurately reflect the correct parity value for the stripe. Thus, in this example, P0 must also be updated. But how can we update it both correctly and effi- ciently?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">It turns out there are two methods. The first, known as <b>additive parity</b>, requires us to do the following. To compute the value of the new parity block, read in all of the other data blocks in the stripe in parallel (in the example, blocks 0, 2, and 3) and XOR those with the new block (1). The result is your new parity block. To complete the write, you can then write the new data and new parity to their respective disks, also in parallel.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The problem with this technique is that it scales with the number of disks, and thus in larger RAIDs requires a high number of reads to com- pute parity. Thus, the <b>subtractive parity </b>method.</p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">For example, imagine this string of bits (4 data bits, one parity):</p><p class="s5" style="padding-top: 7pt;padding-left: 141pt;text-indent: 0pt;line-height: 10pt;text-align: left;">C0  C1  C2  C3     P</p><p class="s5" style="padding-left: 144pt;text-indent: 0pt;line-height: 10pt;text-align: left;">0   0   1   1  XOR(0,0,1,1) = 0</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let’s imagine that we wish to overwrite bit C2 with a new value which we will call C2(new). The subtractive method works in three steps. First, we read in the old data at C2 (C2(old) = 1) and the old parity (P(old) =</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">0). Then, we compare the old data and the new data; if they are the same (e.g., C2(new) = C2(old)), then we know the parity bit will also remain the same (i.e., P(new) = P(old)). If, however, they are different, then we must flip the old parity bit to the opposite of its current state, that is, if (P(old) == 1), P(new) will be set to 0; if (P(old) == 0), P(new) will be set to</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">1. We can express this whole mess neatly with XOR as it turns out (if you understand XOR, this will now make sense to you):</p><p class="s38" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">P(new) = (C(old) XOR C(new)) XOR P(old)</p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Because we are dealing with blocks, not bits, we perform this calcula- tion over all the bits in the block (e.g., 4096 bytes in each block multiplied by 8 bits per byte). Thus, in most cases, the new block will be different than the old block and thus the new parity block will too.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">You should now be able to figure out when we would use the additive parity calculation and when we would use the subtractive method. Think about how many disks would need to be in the system so that the additive method performs fewer I/Os than the subtractive method; what is the cross-over point?</p><p style="text-indent: 0pt;text-align: left;"><span><img width="229" height="1" alt="image" src="Image_564.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="19" height="16" alt="image" src="Image_565.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">For this performance analysis, let us assume we are using the subtrac- tive method. Thus, for each write, the RAID has to perform 4 physical I/Os (two reads and two writes). Now imagine there are lots of writes submitted to the RAID; how many can RAID-4 perform in parallel? To understand, let us again look at the RAID-4 layout (Figure <span style=" color: #00AEEF;">38.5</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:99.388pt" cellspacing="0"><tr style="height:9pt"><td style="width:103pt" colspan="3"><p class="s108" style="padding-left: 6pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Disk 0  Disk 1  Disk 2</p></td><td style="width:40pt"><p class="s108" style="padding-left: 4pt;padding-right: 10pt;text-indent: 0pt;line-height: 8pt;text-align: center;">Disk 3</p></td><td style="width:22pt"><p class="s108" style="text-indent: 0pt;line-height: 8pt;text-align: center;">Disk 4</p></td></tr><tr style="height:10pt"><td style="width:42pt"><p class="s108" style="padding-left: 15pt;text-indent: 0pt;line-height: 9pt;text-align: left;">0</p></td><td style="width:19pt"><p class="s108" style="text-indent: 0pt;line-height: 9pt;text-align: center;">1</p></td><td style="width:42pt"><p class="s108" style="padding-right: 15pt;text-indent: 0pt;line-height: 9pt;text-align: right;">2</p></td><td style="width:40pt"><p class="s108" style="padding-right: 5pt;text-indent: 0pt;line-height: 9pt;text-align: center;">3</p></td><td style="width:22pt"><p class="s108" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: center;">P0</p></td></tr><tr style="height:13pt"><td style="width:42pt"><p class="s195" style="padding-left: 12pt;text-indent: 0pt;line-height: 85%;text-align: left;">∗<span class="s196">4</span></p></td><td style="width:19pt"><p class="s108" style="padding-top: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">5</p></td><td style="width:42pt"><p class="s108" style="padding-top: 2pt;padding-right: 15pt;text-indent: 0pt;line-height: 10pt;text-align: right;">6</p></td><td style="width:40pt"><p class="s108" style="padding-top: 2pt;padding-right: 5pt;text-indent: 0pt;line-height: 10pt;text-align: center;">7</p></td><td style="width:22pt" bgcolor="#CBCBCB"><p class="s197" style="padding-top: 2pt;text-indent: 0pt;line-height: 10pt;text-align: center;">+<span class="s108">P1</span></p></td></tr><tr style="height:10pt"><td style="width:42pt"><p class="s108" style="padding-left: 15pt;text-indent: 0pt;line-height: 8pt;text-align: left;">8</p></td><td style="width:19pt"><p class="s108" style="text-indent: 0pt;line-height: 9pt;text-align: center;">9</p></td><td style="width:42pt"><p class="s108" style="padding-right: 13pt;text-indent: 0pt;line-height: 8pt;text-align: right;">10</p></td><td style="width:40pt"><p class="s108" style="padding-left: 4pt;padding-right: 10pt;text-indent: 0pt;line-height: 8pt;text-align: center;">11</p></td><td style="width:22pt"><p class="s108" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 8pt;text-align: center;">P2</p></td></tr><tr style="height:13pt"><td style="width:42pt"><p class="s108" style="padding-top: 2pt;padding-left: 13pt;text-indent: 0pt;line-height: 10pt;text-align: left;">12</p></td><td style="width:19pt" bgcolor="#CBCBCB"><p class="s198" style="padding-left: 2pt;padding-right: 2pt;text-indent: 0pt;line-height: 11pt;text-align: center;">∗<span class="s108">13</span></p></td><td style="width:42pt"><p class="s108" style="padding-top: 2pt;padding-right: 13pt;text-indent: 0pt;line-height: 10pt;text-align: right;">14</p></td><td style="width:40pt"><p class="s108" style="padding-top: 2pt;padding-left: 4pt;padding-right: 10pt;text-indent: 0pt;line-height: 10pt;text-align: center;">15</p></td><td style="width:22pt" bgcolor="#CBCBCB"><p class="s199" style="padding-top: 1pt;text-indent: 0pt;line-height: 11pt;text-align: center;">+<span class="s108">P3</span></p></td></tr></table><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part407.htm">Table 38.5: Example: Writes To 4, 13, And Respective Parity Blocks</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part405.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part407.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
