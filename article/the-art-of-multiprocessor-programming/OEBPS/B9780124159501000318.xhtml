<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="appendix" role="doc-appendix"><div id="CN"><a id="c0010tit1"/></div><div aria-label="Page 497" epub:type="pagebreak" id="page_497" role="doc-pagebreak"/><h1 class="fmtitle" id="ti0010">Appendix A: Software basics</h1><p class="textfl" id="p0010"/><section><h2 class="h1hd" id="s0010"><a id="st0010"/>A.1 Introduction</h2><p class="textfl" id="p0015">This appendix describes the basic programming language constructs needed to understand our examples and to write your own concurrent programs. Mostly, we use Java, but the same ideas could be equally well expressed in other high-level languages and libraries. Here, we review the basic software concepts needed to understand this text in Java, C++, and C#. Our discussion here is necessarily incomplete. If in doubt, consult the current documentation for the language or library of interest.</p></section><section><h2 class="h1hd" id="s0015"><a id="st0015"/>A.2 Java</h2><p class="textfl" id="p0020">The Java programming language uses a concurrency model in which <i>threads</i> manipulate <i>objects</i><sup><a epub:type="noteref" href="#fn001" id="cf0010" role="doc-noteref">1</a></sup> by calling the objects' <i>methods</i>. The possibly concurrent calls are coordinated using various language and library constructs. We begin by explaining the basic Java constructs used in this text.</p><section><h3 class="h2hd" id="s0020"><a id="st0020"/>A.2.1 Threads</h3><p class="textfl" id="p0025">A <i>thread</i> executes a single, sequential program. In Java, a thread is an instance of (a subclass of) <span class="sans-serif">java.lang.Thread</span>, which provides methods for creating threads, starting them, suspending them, and waiting for them to finish.</p><p class="text" id="p0030">First, create a class that implements the <img alt="Image" height="9" src="images/B9780124159501000318/fx001.jpg" width="52"/> interface. The class's <img alt="Image" height="6" src="images/B9780124159501000318/fx002.jpg" width="18"/>() method does all the work. For example, here is a simple thread that prints a string:</p><p class="text" id="p0035"/><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" class="img" height="142" src="images/B9780124159501000318/fx003.jpg" width="270"/></figure></div><p class="textfl"><span aria-label="Page 498" epub:type="pagebreak" id="page_498" role="doc-pagebreak"/>A <img alt="Image" height="9" src="images/B9780124159501000318/fx001.jpg" width="52"/> object can be turned into a thread by calling the <img alt="Image" height="9" src="images/B9780124159501000318/fx004.jpg" width="39"/> class constructor, which takes a <img alt="Image" height="9" src="images/B9780124159501000318/fx001.jpg" width="52"/> object as its argument, like this:</p><p class="text" id="p0040"/><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" class="img" height="26" src="images/B9780124159501000318/fx005.jpg" width="288"/></figure></div><p class="textfl"/><p class="text" id="p0045">Java provides a syntactic shortcut, called an <i>anonymous inner class</i>, that allows you to avoid defining an explicit <img alt="Image" height="9" src="images/B9780124159501000318/fx006.jpg" width="65"/> class:</p><p class="text" id="p0050"/><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" class="img" height="92" src="images/B9780124159501000318/fx007.jpg" width="324"/></figure></div><p class="textfl"> This snippet creates an anonymous class implementing the <img alt="Image" height="9" src="images/B9780124159501000318/fx001.jpg" width="52"/> interface, whose <img alt="Image" height="6" src="images/B9780124159501000318/fx002.jpg" width="18"/>() method behaves as shown.</p><p class="text" id="p0055">After a thread has been created, it must be <i>started</i>:</p><p class="text" id="p0060"/><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" class="img" height="11" src="images/B9780124159501000318/fx008.jpg" width="88"/></figure></div><p class="textfl"> This method causes <img alt="Image" height="9" src="images/B9780124159501000318/fx009.jpg" width="38"/> to run (i.e., to execute the <img alt="Image" height="6" src="images/B9780124159501000318/fx002.jpg" width="18"/>() method). The thread that calls <img alt="Image" height="8" src="images/B9780124159501000318/fx010.jpg" width="32"/>() returns immediately. If the caller wants to wait for <img alt="Image" height="9" src="images/B9780124159501000318/fx009.jpg" width="38"/> to finish, it must <i>join</i> the thread:</p><p class="text" id="p0065"/><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" class="img" height="11" src="images/B9780124159501000318/fx011.jpg" width="82"/></figure></div><p class="textfl"> The caller is blocked until the joined thread's <img alt="Image" height="6" src="images/B9780124159501000318/fx002.jpg" width="18"/>() method returns.</p><p class="text" id="p0070"><a href="#f0035" id="cf0015">Fig. A.1</a> shows a method that initializes multiple threads, starts them, waits for them to finish, and then prints out a message. The method creates an array of threads, and initializes them in lines 2–10, using the anonymous inner class syntax. At the end of this loop, it has created an array of dormant threads. In lines 11–13, it starts the threads, and each thread executes its <img alt="Image" height="6" src="images/B9780124159501000318/fx002.jpg" width="18"/>() method, displaying its message. Finally, in lines 14–16, it waits for each thread to finish.</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="273" src="images/B9780124159501000318/gr001.jpg" width="379"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.1</span> This method initializes a number of Java threads, starts them, and then waits for them to finish.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0025"><a id="st0025"/>A.2.2 Monitors</h3><p class="textfl" id="p0075">Java provides a number of ways to synchronize access to shared data, both built-in and through packages. Here we describe the built-in model, called the <i>monitor</i> model, a simple and commonly used approach. We discuss monitors in Chapter <a href="B9780124159501000185.xhtml">8</a>.</p><p class="text" id="p0080">Imagine you are in charge of software for a call center. During peak hours, calls arrive faster than they can be answered. When a call arrives, your switchboard software places that call in a queue; it plays a recorded announcement assuring the caller that you consider this call to be very important, and that calls will be answered in the order received. An <i>operator</i>—an employee in charge of answering calls—dispatches an <i>operator thread</i> to dequeue and answer the next call. When an operator finishes with one call, he or she dequeues the next call from the queue and answers it.</p><p class="text" id="p0085"><span aria-label="Page 499" epub:type="pagebreak" id="page_499" role="doc-pagebreak"/><a href="#f0040" id="cf0020">Fig. A.2</a> shows a simple but incorrect queue class. The calls are kept in an array <img alt="Image" height="9" src="images/B9780124159501000318/fx012.jpg" width="32"/>, where <img alt="Image" height="9" src="images/B9780124159501000318/fx013.jpg" width="25"/> is the index of the next call to remove and <img alt="Image" height="9" src="images/B9780124159501000318/fx014.jpg" width="23"/> is the index of the next free slot in the array.</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="191" src="images/B9780124159501000318/gr002.jpg" width="374"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.2</span> An <i>incorrect</i> queue class.</div></figcaption></figure></div><p class="text" id="p0090">This class does not work correctly if two operators try to dequeue a call at the same time. The expression</p><p class="text" id="p0095"/><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" class="img" height="11" src="images/B9780124159501000318/fx015.jpg" width="178"/></figure></div><p class="textfl"><span aria-label="Page 500" epub:type="pagebreak" id="page_500" role="doc-pagebreak"/> does not happen as an <i>atomic</i> (i.e., indivisible) step. Instead, the compiler produces code that looks something like this:</p><p class="text" id="p0100"/><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" class="img" height="60" src="images/B9780124159501000318/fx016.jpg" width="167"/></figure></div><p class="textfl"/><p class="text" id="p0105">Two operators might execute these statements together: They execute the first line at the same time, then the second, and so on. In the end, both operators dequeue and answer the same call, possibly annoying the customer.</p><p class="text" id="p0110">To make this queue work correctly, we must ensure that only one operator at a time can dequeue the next call, a property called <i>mutual exclusion</i>. Java provides a useful built-in mechanism to support mutual exclusion. Each object has an (implicit) <i>lock</i>. If a thread <i>A acquires</i> the object's lock (or, equivalently, <i>locks</i> that object), then no other thread can acquire that lock until <i>A releases</i> the lock (or, equivalently, <i>unlocks</i> the object). If a class declares a method to be <img alt="Image" height="11" src="images/B9780124159501000318/fx017.jpg" width="79"/>, then that method implicitly acquires the lock when it is called, and releases it when it returns.</p><p class="text" id="p0115">Here is one way to ensure mutual exclusion for the <img alt="Image" height="9" src="images/B9780124159501000318/fx018.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000318/fx019.jpg" width="19"/>() methods:</p><p class="text" id="p0120"/><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" class="img" height="93" src="images/B9780124159501000318/fx020.jpg" width="183"/></figure></div><p class="textfl"/><p class="text" id="p0125">Once a call to a synchronized method has acquired the object's lock, any other call to a synchronized method of that object is blocked until the lock is released. (Calls to other objects, subject to other locks, are not blocked.) The body of a synchronized method is often called a <i>critical section</i>.</p><p class="text" id="p0130">There is more to synchronization than mutual exclusion. What should an operator do if he or she tries to dequeue a call, but there are no calls waiting in the queue? The call might throw an exception or return <i>null</i>, but what could the operator do then, other than try again? Instead, it makes sense for the operator to <i>wait</i> for a call to appear. Here is a first attempt at a solution:</p><p class="text" id="p0135"/><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" class="img" height="60" src="images/B9780124159501000318/fx021.jpg" width="301"/></figure></div><p class="textfl"> This attempt is not just wrong, it is disastrously wrong. The dequeuing thread waits inside a synchronized method, locking out every other thread, including the switchboard thread that could be trying to enqueue a call. This is a <i>deadlock</i>: The dequeuing thread holds the lock waiting for an enqueuing thread, while the enqueuing thread waits for the dequeuing thread to release the lock. Nothing will ever happen.</p><p class="text" id="p0140">From this we learn that if a thread executing a synchronized method needs to wait for something to happen, then it must <i>unlock</i> the object while <span aria-label="Page 501" epub:type="pagebreak" id="page_501" role="doc-pagebreak"/>it waits. The waiting thread should periodically reacquire the lock to test whether it can proceed. If so, it proceeds; if not, it releases the lock and goes back to waiting.</p><p class="text" id="p0145">In Java, each object provides a <img alt="Image" height="9" src="images/B9780124159501000318/fx022.jpg" width="26"/>() method, which unlocks the object and suspends the caller. While that thread is waiting, another thread can lock and change the object. Later, when the suspended thread resumes, it locks the object again before it returns from the <img alt="Image" height="9" src="images/B9780124159501000318/fx022.jpg" width="26"/>() call. Here is a revised, but still incorrect, dequeue method:<sup><a epub:type="noteref" href="#fn002" id="cf0025" role="doc-noteref">2</a></sup></p><p class="text" id="p0150"/><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" class="img" height="60" src="images/B9780124159501000318/fx024.jpg" width="338"/></figure></div><p class="textfl"/><p class="text" id="p0155">Each operator thread, seeking a call to answer, repeatedly tests whether the queue is empty. If so, it releases the lock and waits; if not, it removes and returns the item. In a similar way, an enqueuing thread checks whether the buffer is full.</p><p class="text" id="p0160">When does a waiting thread wake up? The program must <i>notify</i> waiting threads when something significant happens. The <img alt="Image" height="11" src="images/B9780124159501000318/fx025.jpg" width="39"/>() method eventually wakes up one waiting thread, chosen arbitrarily from the set of waiting threads. When that thread awakens, it competes for the lock like any other thread. When that thread reacquires the lock, it returns from its <img alt="Image" height="9" src="images/B9780124159501000318/fx022.jpg" width="26"/>() call. You cannot control which waiting thread is chosen. By contrast, the <img alt="Image" height="11" src="images/B9780124159501000318/fx026.jpg" width="56"/>() method wakes up all waiting threads, eventually. Each time the object is unlocked, one of these newly awakened threads will reacquire the lock and return from its <img alt="Image" height="9" src="images/B9780124159501000318/fx022.jpg" width="26"/>() call. You cannot control the order in which the threads reacquire the lock.</p><p class="text" id="p0165">In the call center example, there are multiple operators and one switchboard. Suppose the switchboard software decides to optimize its use of <img alt="Image" height="11" src="images/B9780124159501000318/fx025.jpg" width="39"/>() as follows. If it adds a call to an empty queue, then it should notify only one blocked dequeuer, since there is only one call to consume. This optimization, while it may seem reasonable, is flawed. Suppose the operator threads <i>A</i> and <i>B</i> discover the queue is empty, and block waiting for calls to answer. The switchboard thread <i>S</i> puts a call in the queue, and calls <img alt="Image" height="11" src="images/B9780124159501000318/fx025.jpg" width="39"/>() to wake up one operator thread. Because the notification is asynchronous, however, there is a delay. <i>S</i> then returns and places another call in the queue, and because the queue already had a waiting call, it does not notify other threads. The switchboard's <img alt="Image" height="11" src="images/B9780124159501000318/fx025.jpg" width="39"/>() finally takes effect, waking up <i>A</i>, but not <i>B</i>, even though there is a call for <i>B</i> to answer. This pitfall is called the <i>lost-wakeup</i> problem: One or more waiting threads fail to be notified that the condition for which they are waiting has become true. See Section <a href="B9780124159501000185.xhtml">8.2.2</a> for a more detailed discussion.<span aria-label="Page 502" epub:type="pagebreak" id="page_502" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0030"><a id="st0030"/>A.2.3 Yielding and sleeping</h3><p class="textfl" id="p0170">In addition to the <img alt="Image" height="9" src="images/B9780124159501000318/fx022.jpg" width="26"/>() method, which allows a thread holding a lock to release the lock and pause, Java provides other ways for a thread that does not hold a lock to pause. A <img alt="Image" height="11" src="images/B9780124159501000318/fx027.jpg" width="33"/>() call pauses the thread, asking the scheduler to run something else. The scheduler decides whether to pause the thread, and when to restart it. If there are no other threads to run, the scheduler may ignore the <img alt="Image" height="11" src="images/B9780124159501000318/fx027.jpg" width="33"/>() call. Section <a href="B9780124159501000264.xhtml">16.4.2</a> describes how yielding can be an effective way to prevent livelock. A call to <img alt="Image" height="11" src="images/B9780124159501000318/fx028.jpg" width="32"/>(<i>t</i>), where <i>t</i> is a time value, instructs the scheduler not to run that thread for that duration. The scheduler is free to restart the thread at any later time.</p></section><section><h3 class="h2hd" id="s0035"><a id="st0035"/>A.2.4 Thread-local objects</h3><p class="textfl" id="p0175">Often it is useful for each thread to have its own private instance of a variable. Java supports such <i>thread-local</i> objects through the <img alt="Image" height="9" src="images/B9780124159501000318/fx029.jpg" width="93"/> class, which manages a collection of objects of type <img alt="Image" height="9" src="images/B9780124159501000318/fx030.jpg" width="5"/>, one for each thread. Because thread-local variables were not built into Java, they have a somewhat complicated and awkward interface. Nevertheless, they are extremely useful, and we use them often, so we review how to use them here.</p><p class="text" id="p0180">The <img alt="Image" height="9" src="images/B9780124159501000318/fx029.jpg" width="93"/> class provides <img alt="Image" height="11" src="images/B9780124159501000318/fx031.jpg" width="19"/>() and <img alt="Image" height="8" src="images/B9780124159501000318/fx032.jpg" width="18"/>() methods that read and update the thread's local value, and an <img alt="Image" height="9" src="images/B9780124159501000318/fx033.jpg" width="78"/>() method that is called the first time a thread tries to get the value of a thread-local object. To initialize each thread's local value appropriately, we define a <i>subclass</i> of <img alt="Image" height="9" src="images/B9780124159501000318/fx029.jpg" width="93"/> that overrides the parent's <img alt="Image" height="9" src="images/B9780124159501000318/fx033.jpg" width="78"/>() method.</p><p class="text" id="p0185">This mechanism is best illustrated by an example. In many of our algorithms, we assume that each of <i>n</i> concurrent threads has a unique thread-local identifier between 0 and <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000318/si1.png" style="vertical-align:middle" width="37"/></span>. To provide such an identifier, we show how to define a <img alt="Image" height="9" src="images/B9780124159501000318/fx034.jpg" width="53"/> class with a single static method: <img alt="Image" height="11" src="images/B9780124159501000318/fx031.jpg" width="19"/>() returns the calling thread's identifier. When a thread calls <img alt="Image" height="11" src="images/B9780124159501000318/fx031.jpg" width="19"/>() for the first time, it is assigned the next unused identifier. Each subsequent call by that thread returns that thread's identifier.</p><p class="text" id="p0190"><a href="#f0070" id="cf0030">Fig. A.3</a> shows the simplest way to use a thread-local object to implement this useful class. Line 2 declares an integer <img alt="Image" height="9" src="images/B9780124159501000318/fx035.jpg" width="39"/> field that holds the next identifier to be issued. Lines 3–7 define an <i>inner class</i> accessible only within the body of the enclosing <img alt="Image" height="9" src="images/B9780124159501000318/fx034.jpg" width="53"/> class. This inner class manages the thread's identifier. It is a subclass of <img alt="Image" height="11" src="images/B9780124159501000318/fx036.jpg" width="133"/> that overrides the <img alt="Image" height="9" src="images/B9780124159501000318/fx033.jpg" width="78"/>() method to assign the next unused identifier to the current thread.</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="240" src="images/B9780124159501000318/gr003.jpg" width="424"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.3</span> The <img alt="Image" height="9" src="images/B9780124159501000318/fx034.jpg" width="53"/> class: Give each thread a unique identifier.</div></figcaption></figure></div><p class="text" id="p0195">Here is an example how the <img alt="Image" height="9" src="images/B9780124159501000318/fx034.jpg" width="53"/> class might be used:</p><p class="text" id="p0200"/><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" class="img" height="76" src="images/B9780124159501000318/fx037.jpg" width="407"/></figure></div><p class="textfl"/><p class="text" id="p0205">Because the inner <img alt="Image" height="9" src="images/B9780124159501000318/fx038.jpg" width="86"/> class is used exactly once, it makes little sense to give it a name (for the same reason that it makes little sense to name your Thanksgiving turkey). Instead, it is more common to use an anonymous class as described earlier.</p><p class="text" id="p0210"><span aria-label="Page 503" epub:type="pagebreak" id="page_503" role="doc-pagebreak"/></p><div class="boxg1" id="enun0010"><p class="b1num">Pragma A.2.1 </p><div><p class="b1textfl" id="p0215">In the type expression <img alt="Image" height="11" src="images/B9780124159501000318/fx036.jpg" width="133"/>, we use <img alt="Image" height="11" src="images/B9780124159501000318/fx039.jpg" width="45"/> instead of <img alt="Image" height="9" src="images/B9780124159501000318/fx040.jpg" width="18"/> because <img alt="Image" height="9" src="images/B9780124159501000318/fx040.jpg" width="18"/> is a primitive type, and only reference types, such as <img alt="Image" height="11" src="images/B9780124159501000318/fx039.jpg" width="45"/>, are allowed in angle brackets. Since Java 1.5, a feature called <i>autoboxing</i> allows you to use <img alt="Image" height="9" src="images/B9780124159501000318/fx040.jpg" width="18"/> and <img alt="Image" height="11" src="images/B9780124159501000318/fx039.jpg" width="45"/> values more-or-less interchangeably, for example:</p><p class="b1text" id="p0220"/><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" class="img" height="43" src="images/B9780124159501000318/fx041.jpg" width="106"/></figure></div><p class="textfl"> Consult your Java reference manual for complete details.</p></div></div><p class="textfl"/></section><section><h3 class="h2hd" id="s0040"><a id="st0040"/>A.2.5 Randomization</h3><p class="textfl" id="p0225"><i>Randomization</i> is an important tool for algorithm design; several algorithms in this book use randomization to reduce contention, for example. When using randomization, it is important to understand the properties of the random number generator used. For example, the <img alt="Image" height="9" src="images/B9780124159501000318/fx042.jpg" width="73"/> method uses a single global instance of the <img alt="Image" height="11" src="images/B9780124159501000318/fx043.jpg" width="107"/> class to generate random numbers. Although <img alt="Image" height="9" src="images/B9780124159501000318/fx044.jpg" width="39"/> is thread-safe, concurrent calls to the same instance by multiple threads can introduce contention and synchronization.</p><p class="text" id="p0230">To avoid this contention, we use the <img alt="Image" height="9" src="images/B9780124159501000318/fx045.jpg" width="113"/> class from the <span aria-label="Page 504" epub:type="pagebreak" id="page_504" role="doc-pagebreak"/><span class="sans-serif">java.util.concurrent</span> package, which, as its name suggests, maintains a separate random number generator<sup><a epub:type="noteref" href="#fn003" id="cf0035" role="doc-noteref">3</a></sup> for each thread. The static method <img alt="Image" height="12" src="images/B9780124159501000318/fx046.jpg" width="57"/> returns the random number generator associated with the caller; it is recommended to always call this method when using <img alt="Image" height="9" src="images/B9780124159501000318/fx045.jpg" width="113"/>. For example, to generate a random <img alt="Image" height="9" src="images/B9780124159501000318/fx047.jpg" width="18"/> from 0 to <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000318/si2.png" style="vertical-align:middle" width="36"/></span>, we call</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" class="img" height="11" src="images/B9780124159501000318/fx048.jpg" width="221"/></figure></div><p class="textfl"/><p class="text" id="p0235">The random numbers generated by <img alt="Image" height="9" src="images/B9780124159501000318/fx045.jpg" width="113"/> are <i>not</i> cryptographically secure. If such security is required, consider using <img alt="Image" height="11" src="images/B9780124159501000318/fx049.jpg" width="174"/> instead. However, if you do, then be careful not to introduce contention by having multiple threads concurrently access the same random number generator.</p></section></section><section><h2 class="h1hd" id="s0045"><a id="st0045"/>A.3 The Java memory model</h2><p class="textfl" id="p0240">The Java programming language does not guarantee linearizability, or even sequential consistency, when reading or writing fields of shared objects. Why not? The principal reason is that strict adherence to sequential consistency would outlaw widely used compiler optimizations, such as register allocation, common subexpression elimination, and redundant read elimination, all of which involve reordering memory reads and writes. In a single-thread computation, such reorderings are invisible to the optimized program, but in a multithreaded computation, one thread can spy on another and observe out-of-order executions.</p><p class="text" id="p0245">The Java memory model satisfies the <i>fundamental property</i> of relaxed memory models: If a program's sequentially consistent executions follow certain rules, then every execution of that program in the relaxed model will still be sequentially consistent. In this section, we describe rules that guarantee that the Java programs are sequentially consistent. We do not try to cover the complete set of rules, which is rather large and complex. Instead, we focus on a set of straightforward rules that suffices for most purposes.</p><p class="text" id="p0250"><a href="#f0090" id="cf0040">Fig. A.4</a> shows <i>double-checked locking</i>, a once-common programming idiom that falls victim to Java's lack of sequential consistency. Here, the <img alt="Image" height="11" src="images/B9780124159501000318/fx050.jpg" width="59"/> class manages a single instance of a <img alt="Image" height="11" src="images/B9780124159501000318/fx050.jpg" width="59"/> object, accessible through the <img alt="Image" height="11" src="images/B9780124159501000318/fx051.jpg" width="73"/>() method. This method creates the instance the first time it is called. This method must be synchronized to ensure that only one instance is created, even if several threads observe <img alt="Image" height="9" src="images/B9780124159501000318/fx052.jpg" width="52"/> to be <i>null</i>. Once the instance has been created, however, no further synchronization should be necessary. As an optimization, the code in <a href="#f0090" id="cf0045">Fig. A.4</a> enters the synchronized block only when it observes an <img alt="Image" height="9" src="images/B9780124159501000318/fx052.jpg" width="52"/> to be <i>null</i>. Once it has entered, it <i>double-checks</i> that <img alt="Image" height="9" src="images/B9780124159501000318/fx052.jpg" width="52"/> is still <i>null</i> before creating the instance.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="142" src="images/B9780124159501000318/gr004.jpg" width="253"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.4</span> Double-checked locking.</div></figcaption></figure></div><p class="text" id="p0255">This pattern is incorrect: At line 5, the constructor call appears to take place before the <img alt="Image" height="9" src="images/B9780124159501000318/fx052.jpg" width="52"/> field is <span aria-label="Page 505" epub:type="pagebreak" id="page_505" role="doc-pagebreak"/>assigned, but the Java memory model allows these steps to occur out of order, effectively making a partially initialized <img alt="Image" height="11" src="images/B9780124159501000318/fx050.jpg" width="59"/> object visible to other threads.</p><p class="text" id="p0260">In the Java memory model, objects reside in a shared memory and each thread has a private working memory that contains cached copies of fields it has read or written. In the absence of explicit synchronization (explained later), a thread that writes to a field might not propagate that update to the shared memory right away, and a thread that reads a field might not update its working memory if the field's copy in the shared memory changes value. Naturally, a Java virtual machine is free to keep such cached copies consistent, and in practice they often do, but they are not required to do so. At this point, we can guarantee only that a thread's own reads and writes appear to that thread to happen in order, and that any field value read by a thread was written to that field (i.e., values do not appear out of thin air).</p><p class="text" id="p0265">Certain statements are <i>synchronization events</i>. The term “synchronization” usually implies some form of atomicity or mutual exclusion. In Java, however, it also implies reconciling a thread's working memory with the shared memory. Some synchronization events cause a thread to write cached changes back to shared memory, making those changes visible to other threads. Other synchronization events cause the thread to invalidate its cached values, forcing it to reread field values from memory, making other threads' changes visible. Synchronization events are linearizable: They are totally ordered, and all threads agree on that ordering. We now look at different kinds of synchronization events.</p><section><h3 class="h2hd" id="s0050"><a id="st0050"/>A.3.1 Locks and synchronized blocks</h3><p class="textfl" id="p0270">A thread can achieve mutual exclusion either by entering a <img alt="Image" height="11" src="images/B9780124159501000318/fx017.jpg" width="79"/> block or method, which acquires an implicit lock, or by acquiring an explicit lock (such as the <img alt="Image" height="9" src="images/B9780124159501000318/fx053.jpg" width="86"/> from the <span class="sans-serif">java.util.concurrent.locks</span> package). These approaches have the same implications for memory behavior.</p><p class="text" id="p0275">If all accesses to a particular field are protected by the same lock, then reads and writes to that field are linearizable. Specifically, when a thread releases a lock, modified fields in working memory are written back to <span aria-label="Page 506" epub:type="pagebreak" id="page_506" role="doc-pagebreak"/>shared memory, performing modifications while holding the lock accessible to other threads. When a thread acquires the lock, it invalidates its working memory to ensure fields are reread from shared memory. Together, these conditions ensure that reads and writes to the fields of any object protected by a single lock are linearizable.</p></section><section><h3 class="h2hd" id="s0055"><a id="st0055"/>A.3.2 Volatile fields</h3><p class="textfl" id="p0280"><i>Volatile</i> fields are linearizable. Reading a volatile field is like acquiring a lock: The working memory is invalidated and the volatile field's current value is reread from memory. Writing a volatile field is like releasing a lock: The volatile field is immediately written back to memory.</p><p class="text" id="p0285">Although reading and writing a volatile field has the same effect on memory consistency as acquiring and releasing a lock, multiple reads and writes are not atomic. For example, if <img alt="Image" height="6" src="images/B9780124159501000318/fx054.jpg" width="6"/> is a volatile variable, the expression <img alt="Image" height="6" src="images/B9780124159501000318/fx055.jpg" width="17"/> will not necessarily increment <img alt="Image" height="6" src="images/B9780124159501000318/fx054.jpg" width="6"/> if concurrent threads can modify <img alt="Image" height="6" src="images/B9780124159501000318/fx054.jpg" width="6"/>. Some form of mutual exclusion is needed as well. One common usage pattern for volatile variables occurs when a field is read by multiple threads but written by only one.</p><p class="text" id="p0290">Also, the compiler does not remove accesses to <img alt="Image" height="9" src="images/B9780124159501000318/fx056.jpg" width="53"/> fields, nor the shared-memory accesses of synchronization methods.</p><p class="text" id="p0295"/><div class="boxg1" id="enun0015"><p class="b1num">Pragma A.3.1 </p><div><p class="b1textfl" id="p0300">Arrays require special attention: If a field or variable containing an array is declared <img alt="Image" height="9" src="images/B9780124159501000318/fx056.jpg" width="53"/>, only accesses to the field or variable must be synchronized; accesses to the <i>elements</i> of the array need not be synchronized. Therefore, when access to the elements of an array must be synchronized, we must use a special array type that provides such synchronized access.</p></div></div><p class="textfl"/><p class="text" id="p0305">The <span class="sans-serif">java.util.concurrent.atomic</span> package includes classes that provide linearizable memory such as <img alt="Image" height="9" src="images/B9780124159501000318/fx057.jpg" width="120"/> or <img alt="Image" height="11" src="images/B9780124159501000318/fx058.jpg" width="87"/>. The <img alt="Image" height="12" src="images/B9780124159501000318/fx059.jpg" width="97"/> and <img alt="Image" height="8" src="images/B9780124159501000318/fx032.jpg" width="18"/>() methods act like volatile writes, and <img alt="Image" height="11" src="images/B9780124159501000318/fx031.jpg" width="19"/>() acts like a volatile read.</p></section><section><h3 class="h2hd" id="s0060"><a id="st0060"/>A.3.3 Final fields</h3><p class="textfl" id="p0310">Recall that a field declared to be <img alt="Image" height="9" src="images/B9780124159501000318/fx060.jpg" width="30"/> cannot be modified once it has been initialized. An object's final fields are initialized in its constructor. If the constructor follows certain simple rules, described in the following paragraphs, then the correct value of any final fields will be visible to other threads without synchronization. For example, in the code shown in <a href="#f0095" id="cf0050">Fig. A.5</a>, a thread that calls <img alt="Image" height="9" src="images/B9780124159501000318/fx061.jpg" width="39"/>() is guaranteed to see <i>x</i> equal to 3, because <i>x</i> is a final field. There is no guarantee that <i>y</i> will be equal to 4, because <i>y</i> is not final.</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="257" src="images/B9780124159501000318/gr005.jpg" width="211"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.5</span> Constructor with final field.</div></figcaption></figure></div><p class="text" id="p0315"><span aria-label="Page 507" epub:type="pagebreak" id="page_507" role="doc-pagebreak"/>If a constructor is synchronized incorrectly, however, final fields may be observed to change value. The rule is simple: The <img alt="Image" height="9" src="images/B9780124159501000318/fx063.jpg" width="25"/> reference must not be released from the constructor before the constructor returns.</p><p class="text" id="p0320"><a href="#f0100" id="cf0055">Fig. A.6</a> shows an example of an incorrect constructor in an event-driven system. Here, an <img alt="Image" height="9" src="images/B9780124159501000318/fx062.jpg" width="86"/> class registers itself with an <img alt="Image" height="9" src="images/B9780124159501000318/fx064.jpg" width="72"/> class, making a reference to the listener object accessible to other threads. This code may appear safe, since registration is the last step in the constructor, but it is incorrect because if another thread calls the event listener's <img alt="Image" height="9" src="images/B9780124159501000318/fx065.jpg" width="46"/>() method before the constructor finishes, then the <img alt="Image" height="9" src="images/B9780124159501000318/fx065.jpg" width="46"/>() method is not guaranteed to see a correct value for <img alt="Image" height="6" src="images/B9780124159501000318/fx066.jpg" width="6"/>.</p><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="142" src="images/B9780124159501000318/gr006.jpg" width="455"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.6</span> Incorrect <img alt="Image" height="9" src="images/B9780124159501000318/fx062.jpg" width="86"/> class.</div></figcaption></figure></div><p class="text" id="p0325">In summary, reads and writes to fields are linearizable if the field is either volatile or protected by a unique lock that is acquired by all readers and writers.<span aria-label="Page 508" epub:type="pagebreak" id="page_508" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0065"><a id="st0065"/>A.4 C++</h2><p class="textfl" id="p0330">Prior to the 2011 C++ standard (C++11), C++ did not have native support for threads. Instead, like C, it relied on operating system-specific mechanisms for threading. This reliance came at a steep cost: Code was not portable across operating systems, and programmers could not reason formally about the correctness of their code.</p><p class="text" id="p0335">Since 2011, C++ has used a concurrency model that includes threads, locks, condition variables, and <img alt="Image" height="9" src="images/B9780124159501000318/fx067.jpg" width="86"/> variables. To use these features, a programmer must include the appropriate header files:</p><p class="text" id="p0340"/><div class="pageavoid"><figure class="fig" id="f0105"><img alt="Image" class="img" height="78" src="images/B9780124159501000318/fx068.jpg" width="392"/></figure></div><p class="textfl"/><p class="text" id="p0345">It may also be necessary to provide a flag at compile time to enable these features (e.g., <span class="inlinecode">-std=c++11</span> or <span class="inlinecode">-std=c++14</span>). The C++ standard is updated every 3 years, and each update since C++11 has added additional features for concurrency.</p><section><h3 class="h2hd" id="s0070"><a id="st0070"/>A.4.1 Threads in C++</h3><p class="textfl" id="p0350">The <span class="inlinecode">std::thread</span> object represents a thread. The constructor to this object can take either a function or a lambda expression. Arguments to that function or lambda can also be provided, as shown in the example in <a href="#f0110" id="cf0060">Fig. A.7</a>. (On certain operating systems, such as some flavors of Linux, the linker may need to be given pthread-related flags (e.g., <span class="inlinecode">-lpthread</span>) in order to compile the program.)</p><div class="pageavoid"><figure class="fig" id="f0110"><img alt="Image" height="552" src="images/B9780124159501000318/gr007.jpg" width="454"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.7</span> Examples of creating and joining threads in C++.</div></figcaption></figure></div><p class="text" id="p0355">On lines 10 and 12, the threads are created by providing the name of the function that the thread should run. In the former case, the function takes no parameters. In the latter, it takes two integer arguments, which are also passed to the thread constructor.</p><p class="text" id="p0360">In addition, a thread can be created by providing it with a lambda to execute. The examples on lines 17–32 illustrate some of the ways that a thread can be given a lambda expression to run.</p><p class="text" id="p0365">In C++, unlike Java, a single call creates the thread and also starts executing it. A program must call <span class="inlinecode">join</span> on all of its threads before terminating.<sup><a epub:type="noteref" href="#fn004" id="cf0065" role="doc-noteref">4</a></sup> A common idiom is to store created threads in a <span class="inlinecode">std::vector</span>, so that they are easily found and joined. An example appears below:</p><div class="pageavoid"><figure class="fig" id="f0115"><img alt="Image" class="img" height="76" src="images/B9780124159501000318/fx069.jpg" width="232"/></figure></div><p class="textfl"><span aria-label="Page 509" epub:type="pagebreak" id="page_509" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0075"><a id="st0075"/>A.4.2 Locks in C++</h3><p class="textfl" id="p0370">The most commonly used locks in C++ are <span class="inlinecode">std::mutex</span>, <span class="inlinecode">std::recursive_mutex</span>, and <span class="inlinecode">std::shared_mutex</span>. Programmers acquire and release a <span class="inlinecode">std::mutex</span> by using its <span class="inlinecode">lock()</span> and <span class="inlinecode">unlock()</span> methods. There is also a <span class="inlinecode">try_lock()</span> method, which prevents a thread from blocking when it attempts to acquire a lock that is held by another thread:</p><p class="text" id="p0375"/><div class="pageavoid"><figure class="fig" id="f0120"><img alt="Image" class="img" height="191" src="images/B9780124159501000318/fx070.jpg" width="312"/></figure></div><p class="textfl"/><p class="text" id="p0380"><span aria-label="Page 510" epub:type="pagebreak" id="page_510" role="doc-pagebreak"/>A <span class="inlinecode">std::recursive_mutex</span> maintains an internal counter and ID field, so that a thread that attempts to <span class="inlinecode">lock()</span> a mutex that it already holds does not block but instead increments the counter. A thread must <span class="inlinecode">unlock()</span> a <span class="inlinecode">recursive_mutex</span> as many times as it has locked it. The <span class="inlinecode">std::shared_mutex</span> supports all the operations of <span class="inlinecode">std::mutex</span>, and also has methods <span class="inlinecode">lock_shared()</span>, <span class="inlinecode">unlock_shared()</span>, and <span class="inlinecode">try_lock_shared()</span>, which allow threads to use it as a readers–writers lock.</p><p class="text" id="p0385">Although C++ does not have <span class="inlinecode">finally</span> blocks, the <i>resource-acquisition-is-initialization</i> (RAII) idiom can be used to achieve the same effect: If an object is constructed on the stack, its destructor runs when the object goes out of scope. The <span class="inlinecode">std::lock_guard</span> wrapper object manages lock acquisition and release:</p><div class="pageavoid"><figure class="fig" id="f0125"><img alt="Image" class="img" height="158" src="images/B9780124159501000318/fx071.jpg" width="268"/></figure></div><p class="textfl"/></section><section><h3 class="h2hd" id="s0080"><a id="st0080"/>A.4.3 Condition variables</h3><p class="textfl" id="p0390">C++14 added condition variables as a language feature. Condition variables can be used to create objects that behave like Java monitors. However, programmers must explicitly manage the association between mutexes and condition variables.</p><p class="text" id="p0395">One complication that arises is that <span class="inlinecode">std::lock_guard</span> does not allow a programmer to unlock and relock the mutex: for as long as the <span class="inlinecode">lock_guard</span> is in scope, the mutex must be acquired. When a condition variable is used to make a thread wait, the critical section must break atomicity. To do so, it must release the lock. It would be unfortunate if programmers had to give up the convenience of <span class="inlinecode">lock_guard</span> when using condition variables. Fortunately, the <span class="inlinecode">std::unique_lock</span> wrapper is like <span class="inlinecode">lock_guard</span>, but also allows threads to unlock and relock the underlying mutex. See <a href="#f0130" id="cf0070">Fig. A.8</a> for an example.</p><div class="pageavoid"><figure class="fig" id="f0130"><img alt="Image" height="601" src="images/B9780124159501000318/gr008.jpg" width="328"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.8</span> Example of using condition variables in C++.</div></figcaption></figure></div><p class="text" id="p0400"><span aria-label="Page 511" epub:type="pagebreak" id="page_511" role="doc-pagebreak"/>The <span class="inlinecode">std::condition_variable</span> object requires that its associated mutex is accessed through a <span class="inlinecode">unique_lock</span>. The <span class="inlinecode">std::condition_variable</span> object provides two different <span class="inlinecode">wait()</span> methods. We use the more advanced version, which takes a predicate as a second parameter and uses it to decide when to stop waiting. Consider the call to <span class="inlinecode">wait()</span> on line 24. It could be written as: <span aria-label="Page 512" epub:type="pagebreak" id="page_512" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0135"><img alt="Image" class="img" height="29" src="images/B9780124159501000318/fx072.jpg" width="112"/></figure></div><p class="textfl"> While this code is equivalent, most programmers prefer to use a predicate, which avoids having to remember that condition variables, like Java monitors, are subject to spurious wakeups.</p><p class="text" id="p0405">Condition variables also have methods that let the programmer control how a thread waits (e.g., by incorporating timeouts). There is also a <span class="inlinecode">notify_all()</span> to wake all threads that are waiting on a condition variable. C++ allows the programmer to call <span class="inlinecode">notify_one</span> or <span class="inlinecode">notify_all</span> while holding the lock, and also while not holding the lock. Although notifying without the lock may be faster in some cases, it is easier to assert the correctness of code when it holds the lock while calling a notify function.</p></section><section><h3 class="h2hd" id="s0085"><a id="st0085"/>A.4.4 Atomic variables</h3><p class="textfl" id="p0410">The C++ memory model allows programmers to reason about the correctness of programs. It defines a happens-before order between thread lifecycle events (e.g., via <span class="inlinecode">thread</span> constructors and calls to <span class="inlinecode">join()</span>), and ensures that programmers can reason about the orders that are created among threads that use a common mutex. For fine-grained ordering, C++ defines the <img alt="Image" height="9" src="images/B9780124159501000318/fx067.jpg" width="86"/> type, which is similar to <img alt="Image" height="9" src="images/B9780124159501000318/fx056.jpg" width="53"/> in Java: By default, these variables are never cached in registers by the compiler, and their use implies fences and ordering (both during compilation and during execution) with respect to both regular data accesses and other <img alt="Image" height="9" src="images/B9780124159501000318/fx067.jpg" width="86"/> accesses.</p><p class="text" id="p0415">Similar to <img alt="Image" height="9" src="images/B9780124159501000318/fx056.jpg" width="53"/> in Java, <img alt="Image" height="9" src="images/B9780124159501000318/fx067.jpg" width="86"/> can represent atomic scalar values, atomic floating-point values, and atomic pointers. It is also possible to have pointers to <img alt="Image" height="9" src="images/B9780124159501000318/fx067.jpg" width="86"/>, an improvement over <img alt="Image" height="9" src="images/B9780124159501000318/fx056.jpg" width="53"/> in Java. Through operator overloading, <img alt="Image" height="9" src="images/B9780124159501000318/fx067.jpg" width="86"/> integers support fetch-and-modify operations for arithmetic and logic. For example, in the following code, increments of <span class="inlinecode">x</span> will be achieved via a hardware read–modify–write operation, and will not be vulnerable to races:</p><div class="pageavoid"><figure class="fig" id="f0140"><img alt="Image" class="img" height="125" src="images/B9780124159501000318/fx073.jpg" width="148"/></figure></div><p class="textfl"> The <img alt="Image" height="9" src="images/B9780124159501000318/fx067.jpg" width="86"/> type also provides <img alt="Image" height="14" src="images/B9780124159501000318/fx074.jpg" width="165"/> for performing compare-and-set operations.</p><p class="text" id="p0420">When accessing a <img alt="Image" height="9" src="images/B9780124159501000318/fx067.jpg" width="86"/> variable, a programmer can treat it as if it were of a nonatomic type. For example, the following are valid:</p><div class="pageavoid"><figure class="fig" id="f0145"><img alt="Image" class="img" height="45" src="images/B9780124159501000318/fx075.jpg" width="143"/></figure></div><p class="textfl"><span aria-label="Page 513" epub:type="pagebreak" id="page_513" role="doc-pagebreak"/> When a program uses this syntax, the compiler will enforce the strictest ordering that it can. That is, an atomic load will prevent subsequent accesses from happening before it, a store will prevent preceding accesses from happening after it, and any read–modify–write operation will prevent any reorderings across it. A programmer can relax these orderings by using explicit load and store methods:</p><div class="pageavoid"><figure class="fig" id="f0150"><img alt="Image" class="img" height="45" src="images/B9780124159501000318/fx076.jpg" width="155"/></figure></div><p class="textfl"> By default, the <img alt="Image" height="8" src="images/B9780124159501000318/fx077.jpg" width="22"/> and <img alt="Image" height="7" src="images/B9780124159501000318/fx078.jpg" width="29"/> methods ensure strict ordering, but the guarantees can be relaxed by specifying an additional parameter (e.g., <img alt="Image" height="12" src="images/B9780124159501000318/fx079.jpg" width="149"/>). In some programs, such relaxation can significantly improve performance. This idea is explored, briefly, in Chapter <a href="B9780124159501000306.xhtml">20</a>.</p></section><section><h3 class="h2hd" id="s0090"><a id="st0090"/>A.4.5 Thread-local storage</h3><p class="textfl" id="p0425">In C++, variable may have the <img alt="Image" height="12" src="images/B9780124159501000318/fx080.jpg" width="69"/> storage class specifier, which indicates that each thread reads and writes a different logical instance of the variable. For example, in the code in <a href="#f0155" id="cf0075">Fig. A.9</a>, many threads increment a shared counter, and also thread-local counters.</p><div class="pageavoid"><figure class="fig" id="f0155"><img alt="Image" height="322" src="images/B9780124159501000318/gr009.jpg" width="413"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.9</span> A C++ program that uses thread-local variables.</div></figcaption></figure></div><p class="text" id="p0430"><span aria-label="Page 514" epub:type="pagebreak" id="page_514" role="doc-pagebreak"/>If we call <img alt="Image" height="12" src="images/B9780124159501000318/fx081.jpg" width="65"/> with multiple threads (e.g., <img alt="Image" height="12" src="images/B9780124159501000318/fx082.jpg" width="142"/>), the final value of the global counter will be equal to the sum of the <img alt="Image" height="12" src="images/B9780124159501000318/fx083.jpg" width="125"/> values passed to each of the threads. The threads increment the counter concurrently. As they do so, they also increment <img alt="Image" height="12" src="images/B9780124159501000318/fx084.jpg" width="77"/>. However, each thread's increments are to a per-thread copy. Thus there are no races on <img alt="Image" height="12" src="images/B9780124159501000318/fx084.jpg" width="77"/>, and its value does not equal <img alt="Image" height="12" src="images/B9780124159501000318/fx085.jpg" width="83"/> when the program completes.</p></section></section><section><h2 class="h1hd" id="s0095"><a id="st0095"/>A.5 C#</h2><p class="textfl" id="p0435">C# is a Java-like language that runs on Microsoft's .Net platform.</p><section><h3 class="h2hd" id="s0100"><a id="st0100"/>A.5.1 Threads</h3><p class="textfl" id="p0440">C# provides a threading model similar to Java's. C# threads are implemented by the <img alt="Image" height="11" src="images/B9780124159501000318/fx086.jpg" width="153"/> class. When you create a thread, you tell it what to do by passing it a <img alt="Image" height="9" src="images/B9780124159501000318/fx087.jpg" width="73"/> <i>delegate</i>, a kind of pointer to the method you want to call. For example, here is a method that prints a simple message:</p><div class="pageavoid"><figure class="fig" id="f0160"><img alt="Image" class="img" height="60" src="images/B9780124159501000318/fx088.jpg" width="219"/></figure></div><p class="textfl"> We then turn this method into a <img alt="Image" height="9" src="images/B9780124159501000318/fx087.jpg" width="73"/> delegate, and pass that delegate to the thread constructor:</p><p class="text" id="p0445"/><div class="pageavoid"><figure class="fig" id="f0165"><img alt="Image" class="img" height="27" src="images/B9780124159501000318/fx089.jpg" width="288"/></figure></div><p class="textfl"> C# provides a syntactic shortcut, called an <i>anonymous method</i>, that allows you to define a delegate directly, for example, by combining the previous steps into a single expression:</p><div class="pageavoid"><figure class="fig" id="f0170"><img alt="Image" class="img" height="60" src="images/B9780124159501000318/fx090.jpg" width="221"/></figure></div><p class="textfl"> As in Java, after a thread has been created, it must be <i>started</i>:</p><div class="pageavoid"><figure class="fig" id="f0175"><img alt="Image" class="img" height="11" src="images/B9780124159501000318/fx091.jpg" width="88"/></figure></div><p class="textfl"> This call causes the thread to run, while the caller returns immediately. If the caller wants to wait for the thread to finish, it must <i>join</i> the thread:</p><div class="pageavoid"><figure class="fig" id="f0180"><img alt="Image" class="img" height="11" src="images/B9780124159501000318/fx092.jpg" width="82"/></figure></div><p class="textfl"> The caller is blocked until the thread's method returns.</p><p class="text" id="p0450"><a href="#f0185" id="cf0080">Fig. A.10</a> shows a method that initializes a number of threads, starts them, waits for them to finish, and then prints out <span aria-label="Page 515" epub:type="pagebreak" id="page_515" role="doc-pagebreak"/>a message. The method creates an array of threads, initializing each thread with its own <img alt="Image" height="9" src="images/B9780124159501000318/fx087.jpg" width="73"/> delegate. We then start the threads, and each thread executes its delegate, displaying its message. Finally, we wait for each thread to finish, and display a message when they are all done. Except for minor syntactic differences, this code is similar to what you would write in Java.<span aria-label="Page 516" epub:type="pagebreak" id="page_516" role="doc-pagebreak"/><span aria-label="Page 517" epub:type="pagebreak" id="page_517" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0185"><img alt="Image" height="405" src="images/B9780124159501000318/gr010.jpg" width="348"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.10</span> This method initializes a number of C# threads, starts them, waits for them to finish, and then prints out a message.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0105"><a id="st0105"/>A.5.2 Monitors</h3><p class="textfl" id="p0455">For simple mutual exclusion, C# provides the ability to <i>lock</i> an object much like the <img alt="Image" height="11" src="images/B9780124159501000318/fx017.jpg" width="79"/> modifier in Java:</p><div class="pageavoid"><figure class="fig" id="f0195"><img alt="Image" class="img" height="109" src="images/B9780124159501000318/fx094.jpg" width="131"/></figure></div><p class="textfl"> Unlike Java, C# does not allow you to use a <img alt="Image" height="9" src="images/B9780124159501000318/fx095.jpg" width="25"/> statement to modify a method directly. Instead, the <img alt="Image" height="9" src="images/B9780124159501000318/fx095.jpg" width="25"/> statement is used to enclose the method body.</p><p class="text" id="p0460">Concurrent data structures require more than mutual exclusion: They also require the ability to wait and signal conditions. Unlike in Java, where every object is an implicit monitor, in C# you must explicitly create the monitor associated with an object. To acquire a monitor lock, call <span class="inlinecode">Monitor.Enter(this)</span>, and to release the lock, call <span class="inlinecode">Monitor.Exit(this)</span>. Each monitor has a single implicit condition, which is waited upon by <span class="inlinecode">Monitor.Wait(this)</span>, and signaled by <span class="inlinecode">Monitor.Pulse(this)</span> or <span class="inlinecode">Monitor.PulseAll(this)</span>, which respectively wake up one or all sleeping threads. <a href="#f0190" id="cf0085">Fig. A.11</a> shows how to implement a bounded queue using C# monitors.</p><div class="pageavoid"><figure class="fig" id="f0190"><img alt="Image" height="733" src="images/B9780124159501000318/gr011.jpg" width="402"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.11</span> A bounded <img alt="Image" height="11" src="images/B9780124159501000318/fx093.jpg" width="32"/> class.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0110"><a id="st0110"/>A.5.3 Thread-local objects</h3><p class="textfl" id="p0465">C# provides a very simple way to make a static field thread-local: Simply prefix the field declaration with the attribute <img alt="Image" height="12" src="images/B9780124159501000318/fx096.jpg" width="89"/>:</p><p class="text" id="p0470"/><div class="pageavoid"><figure class="fig" id="f0200"><img alt="Image" class="img" height="27" src="images/B9780124159501000318/fx097.jpg" width="100"/></figure></div><p class="textfl"> Do not provide an initial value for a <img alt="Image" height="12" src="images/B9780124159501000318/fx096.jpg" width="89"/> field, because the initialization happens once, not once per thread. Instead, each thread will find the field initially has that type's default value: zero for integers, <i>null</i> for references, and so on.</p><p class="text" id="p0475"><a href="#f0205" id="cf0090">Fig. A.12</a> shows how to implement the <img alt="Image" height="9" src="images/B9780124159501000318/fx034.jpg" width="53"/> class (Java version in <a href="#f0070" id="cf0095">Fig. A.3</a>). There is one point about this program that may require a comment. The first time a thread inspects its <img alt="Image" height="12" src="images/B9780124159501000318/fx096.jpg" width="89"/> identifier, that field will be zero, the default value for integers. To distinguish between an uninitialized zero and a thread ID zero, this field holds the thread ID displaced by one: Thread 0 has field value 1, and so on.<span aria-label="Page 518" epub:type="pagebreak" id="page_518" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0205"><img alt="Image" height="207" src="images/B9780124159501000318/gr012.jpg" width="361"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure A.12</span> The <img alt="Image" height="9" src="images/B9780124159501000318/fx034.jpg" width="53"/> class provides each thread a unique identifier implemented using <img alt="Image" height="12" src="images/B9780124159501000318/fx096.jpg" width="89"/>.</div></figcaption></figure></div></section></section><section><h2 class="h1hd" id="s0115"><a id="st0115"/>A.6 Appendix notes</h2><p class="textfl" id="p0480">The Java programming language was created by James Gosling <a epub:type="noteref" href="#br0260" id="cf0100" role="doc-noteref">[52]</a>. Dennis Ritchie is credited with creating C. The basic monitor model is credited to Tony Hoare <a epub:type="noteref" href="#br0385" id="cf0105" role="doc-noteref">[77]</a> and Per Brinch Hansen <a epub:type="noteref" href="#br0285" id="cf0110" role="doc-noteref">[57]</a>, although they used different mechanisms for waiting and notification. The mechanisms used by Java (and later by C#) were originally proposed by Butler Lampson and David Redell <a epub:type="noteref" href="#br0535" id="cf0115" role="doc-noteref">[107]</a>.</p></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0465"><h2 class="reftitle" id="st0120">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0260" role="doc-biblioentry">[52] James Gosling, Bill Joy, Guy Steele, Gilad Bracha,  <i>The Java Language Specification</i>. third edition Prentice Hall PTR; 2005 0321246780.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0285" role="doc-biblioentry">[57] Per Brinch Hansen,  Structured multi-programming,   <cite><i>Communications of the ACM</i></cite> 1972;15(7):574–578.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0385" role="doc-biblioentry">[77] C.A.R. Hoare,  Monitors: an operating system structuring concept,   <cite><i>Communications of the ACM</i></cite> 1974;17(10):549–557.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0535" role="doc-biblioentry">[107] B. Lampson, D. Redell,  Experience with processes and monitors in Mesa,   <cite><i>Communications of the ACM</i></cite> 1980;2(23):105–117.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0010" role="doc-noteref">1 </a></sup> <a id="np0010"/>“Technically, threads are objects.”</p><p class="ftnote1" epub:type="footnote" id="fn002" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0025" role="doc-noteref">2 </a></sup> <a id="np0015"/>“This program will not compile because the <img alt="Image" height="9" src="images/B9780124159501000318/fx022.jpg" width="26"/>() call can throw <img alt="Image" height="11" src="images/B9780124159501000318/fx023.jpg" width="132"/>, which must be caught or rethrown. As discussed in <a href="B9780124159501000185.xhtml">Pragma 8.2.1</a>, real code must handle such exceptions, but we often elide such handlers to make the examples easier to read.”</p><p class="ftnote1" epub:type="footnote" id="fn003" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0035" role="doc-noteref">3 </a></sup> <a id="np0020"/>“Technically, this is a <i>pseudorandom number generator</i>.”</p><p class="ftnote1" epub:type="footnote" id="fn004" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0065" role="doc-noteref">4 </a></sup> <a id="np0025"/>“This requirement can be avoided by using a thread's <span class="inlinecode">detach()</span> method.”</p></div></section></footer></section></body></html>