<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>40.5 Free Space Management</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part441.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part443.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">40.5 Free Space Management</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A file system must track which inodes and data blocks are free, and which are not, so that when a new file or directory is allocated, it can find space for it. Thus <b>free space management </b>is important for all file systems. In vsfs, we have two simple bitmaps for this task.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 80pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>F<span class="s45">REE </span>S<span class="s45">PACE </span>M<span class="s45">ANAGEMENT</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">There are many ways to manage free space; bitmaps are just one way. Some early file systems used <b>free lists</b>, where a single pointer in the super block was kept to point to the first free block; inside that block the next free pointer was kept, thus forming a list through the free blocks of the system. When a block was needed, the head block was used and the list updated accordingly.</p><p style="padding-top: 2pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Modern file systems use more sophisticated data structures. For example, SGI’s XFS [S+96] uses some form of a <b>B-tree </b>to compactly represent which chunks of the disk are free. As with any data structure, different time- space trade-offs are possible.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 2pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">For example, when we create a file, we will have to allocate an inode for that file. The file system will thus search through the bitmap for an in- ode that is free, and allocate it to the file; the file system will have to mark the inode as used (with a 1) and eventually update the on-disk bitmap with the correct information. A similar set of activities take place when a data block is allocated.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Some other considerations might also come into play when allocating data blocks for a new file. For example, some Linux file systems, such as ext2 and ext3, will look for a sequence of blocks (say 8) that are free when a new file is created and needs data blocks; by finding such a se- quence of free blocks, and then allocating them to the newly-created file, the file system guarantees that a portion of the file will be on the disk and contiguous, thus improving performance. Such a <b>pre-allocation </b>policy is thus a commonly-used heuristic when allocating space for data blocks.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part441.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part443.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
