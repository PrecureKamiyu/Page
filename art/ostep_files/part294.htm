<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.15 Different OS, Different Support</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part293.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part295.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">28.15 Different OS, Different Support</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We have thus far seen one type of support that an OS can provide in order to build a more efficient lock in a thread library. Other OS’s provide similar support; the details vary.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">For example, Linux provides something called a <b>futex </b>which is simi- lar to the Solaris interface but provides a bit more in-kernel functionality. Specifically, each futex has associated with it a specific physical mem- ory location; associated with each such memory location is an in-kernel queue. Callers can use futex calls (described below) to sleep and wake as need be.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_364.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_365.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: left;">Specifically, two calls are available. The call to <span class="s41">futex wait(address, expected) </span>puts the calling thread to sleep, assuming the value at <span class="s41">address </span>is equal to <span class="s41">expected</span>. If it is <i>not </i>equal, the call returns immediately. The call to the routine <span class="s41">futex wake(address) </span>wakes one thread that is wait- ing on the queue. The usage of these in Linux is as found in <span style=" color: #00AEEF;">28.9</span>.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">This code snippet from <span class="s41">lowlevellock.h </span>in the nptl library (part of the gnu libc library) [L09] is pretty interesting. Basically, it uses a single integer to track both whether the lock is held or not (the high bit of the integer) and the number of waiters on the lock (all the other bits). Thus, if the lock is negative, it is held (because the high bit is set and that bit determines the sign of the integer). The code is also interesting because it shows how to optimize for the common case where there is no contention: with only one thread acquiring and releasing a lock, very little work is done (the atomic bit test-and-set to lock and an atomic add to release the lock). See if you can puzzle through the rest of this “real-world” lock to see how it works.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part293.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part295.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
