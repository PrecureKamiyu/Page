<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>47.4 Communication Abstractions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part511.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part513.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">47.4 Communication Abstractions</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Given a basic messaging layer, we now approach the next question in this chapter: what abstraction of communication should we use when building a distributed system?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 54pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: B<span class="s7">E </span>C<span class="s7">AREFUL </span>S<span class="s7">ETTING </span>T<span class="s7">HE </span>T<span class="s7">IMEOUT </span>V<span class="s7">ALUE</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">As you can probably guess from the discussion, setting the timeout value correctly is an important aspect of using timeouts to retry message sends. If the timeout is too small, the sender will re-send messages needlessly, thus wasting CPU time on the sender and network resources. If the time- out is too large, the sender waits too long to re-send and thus perceived performance at the sender is reduced. The “right” value, from the per- spective of a single client and server, is thus to wait just long enough to detect packet loss but no longer.</p><p style="padding-top: 2pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">However, there are often more than just a single client and server in a distributed system, as we will see in future chapters. In a scenario with many clients sending to a single server, packet loss at the server may be an indicator that the server is overloaded. If true, clients might retry in a different adaptive manner; for example, after the first timeout, a client might increase its timeout value to a higher amount, perhaps twice as high as the original value. Such an <b>exponential back-off </b>scheme, pio- neered in the early Aloha network and adopted in early Ethernet [A70], avoid situations where resources are being overloaded by an excess of re-sends. Robust systems strive to avoid overload of this nature.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The systems community developed a number of approaches over the years. One body of work took OS abstractions and extended them to operate in a distributed environment. For example, <b>distributed shared memory </b>(<b>DSM</b>) systems enable processes on different machines to share a large, virtual address space [LH89]. This abstraction turns a distributed computation into something that looks like a multi-threaded application; the only difference is that these threads run on different machines instead of different processors within the same machine.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The way most DSM systems work is through the virtual memory sys- tem of the OS. When a page is accessed on one machine, two things can happen. In the first (best) case, the page is already local on the machine, and thus the data is fetched quickly. In the second case, the page is cur- rently on some other machine. A page fault occurs, and the page fault handler sends a message to some other machine to fetch the page, install it in the page table of the requesting process, and continue execution.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This approach is not widely in use today for a number of reasons. The largest problem for DSM is how it handles failure. Imagine, for example, if a machine fails; what happens to the pages on that machine? What if the data structures of the distributed computation are spread across the entire address space? In this case, parts of these data structures would suddenly become unavailable. Dealing with failure when parts of your address space go missing is hard; imagine a linked list that where a next pointer points into a portion of the address space that is gone. Yikes!</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">A further problem is performance. One usually assumes, when writ- ing code, that access to memory is cheap. In DSM systems, some accesses</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">are inexpensive, but others cause page faults and expensive fetches from remote machines. Thus, programmers of such DSM systems had to be very careful to organize computations such that almost no communica- tion occurred at all, defeating much of the point of such an approach. Though much research was performed in this space, there was little prac- tical impact; nobody builds reliable distributed systems using DSM today.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part511.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part513.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
