<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Homework</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part392.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part394.htm">下一个 &gt;</a></p><h4 style="padding-top: 2pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">Homework</h4><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This homework uses <span class="s41">disk.py </span>to familiarize you with how a modern hard drive works. It has a lot of different options, and unlike most of the other simulations, has a graphical animator to show you exactly what happens when the disk is in action. See the README for details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 88%;text-align: justify;">1. Compute the seek, rotation, and transfer times for the following sets of requests: <span class="s41">-a 0</span>, <span class="s41">-a 6</span>, <span class="s41">-a 30</span>, <span class="s41">-a 7,30,8</span>, and finally <span class="s41">-a 10,11,12,13</span>.</p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 88%;text-align: justify;">2. Do the same requests above, but change the seek rate to different values: <span class="s41">-S 2</span>, <span class="s41">-S 4</span>, <span class="s41">-S 8</span>, <span class="s41">-S 10</span>, <span class="s41">-S 40</span>, <span class="s41">-S 0.1</span>. How do the times change?</p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">3. Do the same requests above, but change the rotation rate: <span class="s41">-R 0.1</span>,</p><p class="s41" style="padding-left: 91pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">-R 0.5<span class="p">, </span>-R 0.01<span class="p">. How do the times change?</span></p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 89%;text-align: justify;">4. You might have noticed that some request streams would be bet- ter served with a policy better than FIFO. For example, with the request stream <span class="s41">-a 7,30,8</span>, what order should the requests be pro- cessed in? Now run the shortest seek-time first (SSTF) scheduler (<span class="s41">-p SSTF</span>) on the same workload; how long should it take (seek, rotation, transfer) for each request to be served?</p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 88%;text-align: justify;">5. Now do the same thing, but using the shortest access-time first (SATF) scheduler (<span class="s41">-p SATF</span>). Does it make any difference for the set of requests as specified by <span class="s41">-a 7,30,8</span>? Find a set of requests where SATF does noticeably better than SSTF; what are the condi- tions for a noticeable difference to arise?</p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 88%;text-align: justify;">6. You might have noticed that the request stream <span class="s41">-a 10,11,12,13 </span>wasn’t particularly well handled by the disk. Why is that? Can you introduce a track skew to address this problem (<span class="s41">-o skew</span>, where <span class="s41">skew </span>is a non-negative integer)? Given the default seek rate, what should the skew be to minimize the total time for this set of re- quests? What about for different seek rates (e.g., <span class="s41">-S 2</span>, <span class="s41">-S 4</span>)? In general, could you write a formula to figure out the skew, given the seek rate and sector layout information?</p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 89%;text-align: justify;">7. Multi-zone disks pack more sectors into the outer tracks. To config- ure this disk in such a way, run with the <span class="s41">-z </span>flag. Specifically, try running some requests against a disk run with <span class="s41">-z 10,20,30 </span>(the numbers specify the angular space occupied by a sector, per track; in this example, the outer track will be packed with a sector every 10 degrees, the middle track every 20 degrees, and the inner track with a sector every 30 degrees). Run some random requests (e.g.,</p><p class="s41" style="padding-left: 91pt;text-indent: 0pt;line-height: 88%;text-align: justify;">-a -1 -A 5,-1,0<span class="p">, which specifies that random requests should be used via the </span>-a -1 <span class="p">flag and that five requests ranging from 0 to the max be generated), and see if you can compute the seek, rota- tion, and transfer times. Use different random seeds (</span>-s 1<span class="p">, </span>-s 2<span class="p">, etc.). What is the bandwidth (in sectors per unit time) on the outer, middle, and inner tracks?</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 64pt;text-indent: -11pt;line-height: 89%;text-align: justify;">8. Scheduling windows determine how many sector requests a disk can examine at once in order to determine which sector to serve next. Generate some random workloads of a lot of requests (e.g.,</p><p class="s41" style="padding-left: 64pt;text-indent: 0pt;line-height: 89%;text-align: justify;">-A 1000,-1,0<span class="p">, with different seeds perhaps) and see how long the SATF scheduler takes when the scheduling window is changed from 1 up to the number of requests (e.g., </span>-w 1 <span class="p">up to </span>-w 1000<span class="p">, and some values in between). How big of scheduling window is needed to approach the best possible performance? Make a graph and see. Hint: use the </span>-c <span class="p">flag and don’t turn on graphics with </span>-G <span class="p">to run these more quickly. When the scheduling window is set to 1, does it matter which policy you are using?</span></p><p style="padding-left: 64pt;text-indent: -11pt;line-height: 89%;text-align: justify;">9. Avoiding starvation is important in a scheduler. Can you think of a series of requests such that a particular sector is delayed for a very long time given a policy such as SATF? Given that sequence, how does it perform if you use a <b>bounded SATF </b>or <b>BSATF </b>scheduling approach? In this approach, you specify the scheduling window (e.g., <span class="s41">-w 4</span>) as well as the BSATF policy (<span class="s41">-p BSATF</span>); the scheduler then will only move onto the next window of requests when <i>all </i>of the requests in the current window have been serviced. Does this solve the starvation problem? How does it perform, as compared to SATF? In general, how should a disk make this trade-off between performance and starvation avoidance?</p><p style="padding-left: 64pt;text-indent: -15pt;line-height: 89%;text-align: justify;">10. All the scheduling policies we have looked at thus far are <b>greedy</b>, in that they simply pick the next best option instead of looking for the optimal schedule over a set of requests. Can you find a set of requests in which this greedy approach is not optimal?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="430" height="57" alt="image" src="Image_559.png"/></span></p><p class="s50" style="padding-top: 7pt;text-indent: 0pt;text-align: right;">38</p><p style="text-indent: 0pt;text-align: left;"/><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part392.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part394.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
