<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos870716" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_62"><span class="bold">13. The Virtual Filesystem</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos870884"> </div>
<p class="calibre_2">The <em class="calibre4">Virtual Filesystem</em> (sometimes called the <em class="calibre4">Virtual File Switch</em> or more commonly simply the <em class="calibre4">VFS</em>) is the subsystem of the kernel that implements the file and filesystem-related interfaces provided to user-space programs. All filesystems rely on the VFS to enable them not only to coexist, but also to interoperate. This enables programs to use standard Unix system calls to read and write to different filesystems, even on different media, as shown in <a href="#filepos871504">Figure 13.1</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos871504"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 13.1. The VFS in action: Using the <code class="calibre6"><span class="calibre15">cp(1)</span></code> utility to move data from a hard disk mounted as ext3 to a removable disk mounted as ext2. Two different filesystems, two different media, one VFS.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00184.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos871984"> </div>
<h3 class="calibre_21"><span class="bold">Common Filesystem Interface</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The VFS is the glue that enables system calls such as <code class="calibre6"><span class="calibre7">open()</span></code>, <code class="calibre6"><span class="calibre7">read()</span></code>, and <code class="calibre6"><span class="calibre7">write()</span></code> to work regardless of the filesystem or underlying physical medium. These days, that might not sound novel—we have long been taking such a feature for granted—but it is a nontrivial <a id="filepos872495"></a>feat for such generic system calls to work across many diverse filesystems and varying media. More so, the system calls work <em class="calibre4">between</em> these different filesystems and media—we can use standard system calls to copy or move files from one filesystem to another. In older operating systems, such as DOS, this would never have worked; any access to a non-native filesystem required special tools. It is only because modern operating systems, such as Linux, abstract access to the filesystems via a virtual interface that such interoperation and generic access is possible.</p><div class="calibre_3"> </div>
<p class="calibre_2">New filesystems and new varieties of storage media can find their way into Linux, and programs need not be rewritten or even recompiled. In this chapter, we will discuss the VFS, which provides the abstraction allowing myriad filesystems to behave as one. In the next chapter, we will discuss the block I/O layer, which allows various storage devices—CD to Blu-ray discs to hard drives to CompactFlash. Together, the VFS and the block I/O layer provide the abstractions, interfaces, and glue that allow user-space programs to issue generic system calls to access files via a uniform naming policy on any filesystem, which itself exists on any storage medium.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos873842"> </div>
<h3 class="calibre_21"><span class="bold">Filesystem Abstraction Layer</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Such a generic interface for any type of filesystem is feasible only because the kernel implements an abstraction layer around its low-level filesystem interface. This abstraction layer enables Linux to support different filesystems, even if they differ in supported features or behavior. This is possible because the VFS provides a common file model that can represent any filesystem’s general feature set and behavior. Of course, it is biased toward Unix-style filesystems. (You see what constitutes a Unix-style filesystem later in this chapter.) Regardless, wildly differing filesystem types are still supportable in Linux, from DOS’s FAT to Windows’s NTFS to many Unix-style and Linux-specific filesystems.</p><div class="calibre_3"> </div>
<p class="calibre_2">The abstraction layer works by defining the basic conceptual interfaces and data structures that all filesystems support. The filesystems mold their view of concepts such as “<em class="calibre4">this is how I open files</em>” and “<em class="calibre4">this is what a directory is to me</em>” to match the expectations of the VFS. The actual filesystem code hides the implementation details. To the VFS layer and the rest of the kernel, however, each filesystem looks the same. They all support notions such as files and directories, and they all support operations such as creating and deleting files.</p><div class="calibre_3"> </div>
<p class="calibre_2">The result is a general abstraction layer that enables the kernel to support many types of filesystems easily and cleanly. The filesystems are programmed to provide the abstracted interfaces and data structures the VFS expects; in turn, the kernel easily works with any filesystem and the exported user-space interface seamlessly works on any filesystem.</p><div class="calibre_3"> </div>
<p class="calibre_2">In fact, nothing in the kernel needs to understand the underlying details of the filesystems, except the filesystems themselves. For example, consider a simple user-space program that does</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">ret = write (fd, buf, len);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This system call writes the <code class="calibre6"><span class="calibre7">len</span></code> bytes pointed to by <code class="calibre6"><span class="calibre7">buf</span></code> into the current position in the file represented by the file descriptor <code class="calibre6"><span class="calibre7">fd</span></code>. This system call is first handled by a generic <code id="filepos876455" class="calibre6"><span class="calibre7">sys_write()</span></code> system call that determines the actual file writing method for the filesystem on which <code class="calibre6"><span class="calibre7">fd</span></code> resides. The generic write system call then invokes this method, which is part of the filesystem implementation, to write the data to the media (or whatever this filesystem does on write). <a href="#filepos877355">Figure 13.2</a> shows the flow from user-space’s <code class="calibre6"><span class="calibre7">write()</span></code> call through the data arriving on the physical media. On one side of the system call is the generic VFS interface, providing the frontend to user-space; on the other side of the system call is the filesystem-specific backend, dealing with the implementation details. The rest of this chapter looks at how the VFS achieves this abstraction and provides its interfaces.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos877355"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 13.2. The flow of data from user-space issuing a <code class="calibre6"><span class="calibre15">write()</span></code> call, through the VFS’s generic system call, into the filesystem’s specific write method, and finally arriving at the physical media.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00185.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos877849"> </div>
<h3 class="calibre_21"><span class="bold">Unix Filesystems</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Historically, Unix has provided four basic filesystem-related abstractions: files, directory entries, inodes, and mount points.</p><div class="calibre_3"> </div>
<p class="calibre_2">A <em class="calibre4">filesystem</em> is a hierarchical storage of data adhering to a specific structure. Filesystems contain files, directories, and associated control information. Typical operations performed on filesystems are creation, deletion, and mounting. In Unix, filesystems are mounted at a specific mount point in a global hierarchy known as a <em class="calibre4">namespace</em>.<sup class="calibre8"><a id="filepos878510" href="#filepos879123">1</a></sup> This enables all mounted filesystems to appear as entries in a single tree. Contrast this single, unified tree with the behavior of DOS and Windows, which break the file namespace up into drive letters, such as <code class="calibre6"><span class="calibre7">C:</span></code>. This breaks the namespace up among device and partition boundaries, “leaking” hardware details into the filesystem abstraction. As this delineation may be arbitrary and even confusing to the user, it is inferior to Linux’s unified namespace.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos879123" href="#filepos878510">1</a></sup>
<em class="calibre4">Recently, Linux has made this hierarchy per-process, to give a unique namespace to each process. Because each process inherits its parent’s namespace (unless you specify otherwise), there is seemingly one global namespace.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">A <em class="calibre4">file</em> is an ordered string of bytes. The first byte marks the beginning of the file, and the last byte marks the end of the file. Each file is assigned a human-readable name for identification by both the system and the user. Typical file operations are read, write, <a id="filepos879740"></a>create, and delete. The Unix concept of the file is in stark contrast to record-oriented filesystems, such as OpenVMS’s Files-11. Record-oriented filesystems provide a richer, more structured representation of files than Unix’s simple byte-stream abstraction, at the cost of simplicity and flexibility.</p><div class="calibre_3"> </div>
<p class="calibre_2">Files are organized in directories. A <em class="calibre4">directory</em> is analogous to a folder and usually contains related files. Directories can also contain other directories, called subdirectories. In this fashion, directories may be nested to form paths. Each component of a path is called a <em class="calibre4">directory entry</em>. A path example is <code class="calibre6"><span class="calibre7">/home/wolfman/butter</span></code>—the root directory <code class="calibre6"><span class="calibre7">/</span></code>, the directories <code class="calibre6"><span class="calibre7">home</span></code> and <code class="calibre6"><span class="calibre7">wolfman</span></code>, and the file <code class="calibre6"><span class="calibre7">butter</span></code> are all directory entries, called <em class="calibre4">dentries</em>. In Unix, directories are actually normal files that simply list the files contained therein. Because a directory is a file to the VFS, the same operations performed on files can be performed on directories.</p><div class="calibre_3"> </div>
<p class="calibre_2">Unix systems separate the concept of a file from any associated information about it, such as access permissions, size, owner, creation time, and so on. This information is sometimes called <em class="calibre4">file metadata</em> (that is, data about the file’s data) and is stored in a separate data structure from the file, called the <em class="calibre4">inode</em>. This name is short for <em class="calibre4">index node</em>, although these days the term <em class="calibre4">inode</em> is much more ubiquitous.</p><div class="calibre_3"> </div>
<p class="calibre_2">All this information is tied together with the filesystem’s own control information, which is stored in the <em class="calibre4">superblock</em>. The superblock is a data structure containing information about the filesystem as a whole. Sometimes the collective data is referred to as <em class="calibre4">filesystem metadata</em>. Filesystem metadata includes information about both the individual files and the filesystem as a whole.</p><div class="calibre_3"> </div>
<p class="calibre_2">Traditionally, Unix filesystems implement these notions as part of their physical on-disk layout. For example, file information is stored as an inode in a separate block on the disk; directories are files; control information is stored centrally in a superblock, and so on. The Unix file concepts are <em class="calibre4">physically mapped</em> on to the storage medium. The Linux VFS is designed to work with filesystems that understand and implement such concepts. Non-Unix filesystems, such as FAT or NTFS, still work in Linux, but their filesystem code must provide the appearance of these concepts. For example, even if a filesystem does not support distinct inodes, it must assemble the inode data structure in memory as if it did. Or if a filesystem treats directories as a special object, to the VFS they must represent directories as mere files. Often, this involves some special processing done on-the-fly by the non-Unix filesystems to cope with the Unix paradigm and the requirements of the VFS. Such filesystems still work, however, and the overhead is not unreasonable.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos883101"> </div>
<h3 class="calibre_21"><span class="bold">VFS Objects and Their Data Structures</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos883241"> </div>
<p class="calibre_2">The VFS is object-oriented.<sup class="calibre8"><a id="filepos883324" href="#filepos883822">2</a></sup> A family of data structures represents the common file model. These data structures are akin to objects. Because the kernel is programmed strictly in C, without the benefit of a language directly supporting object-oriented paradigms, the data structures are represented as C structures. The structures contain both data and pointers to filesystem-implemented functions that operate on the data.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos883822" href="#filepos883324">2</a></sup>
<em class="calibre4">People often miss this, or even deny it, but there are many examples of object-oriented programming in the kernel. Although the kernel developers may shun C++ and other explicitly object-oriented languages, thinking in terms of objects is often useful. The VFS is a good example of how to do clean and efficient OOP in C, which is a language that lacks any OOP constructs.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">The four primary object types of the VFS are</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <em class="calibre4">superblock</em> object, which represents a specific mounted filesystem.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <em class="calibre4">inode</em> object, which represents a specific file.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <em class="calibre4">dentry</em> object, which represents a directory entry, which is a single component of a path.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <em class="calibre4">file</em> object, which represents an open file as associated with a process.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Note that because the VFS treats directories as normal files, there is not a specific directory object. Recall from earlier in this chapter that a dentry represents a component in a path, which might include a regular file. In other words, a dentry is not the same as a directory, but a directory is just another kind of file. Got it?</p><div class="calibre_3"> </div>
<p class="calibre_2">An <em class="calibre4">operations</em> object is contained within each of these primary objects. These objects describe the methods that the kernel invokes against the primary objects:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <code class="calibre6"><span class="calibre7">super_operations</span></code> object, which contains the methods that the kernel can invoke on a specific filesystem, such as <code class="calibre6"><span class="calibre7">write_inode()</span></code> and <code class="calibre6"><span class="calibre7">sync_fs()</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <code class="calibre6"><span class="calibre7">inode_operations</span></code> object, which contains the methods that the kernel can invoke on a specific file, such as <code class="calibre6"><span class="calibre7">create()</span></code> and <code class="calibre6"><span class="calibre7">link()</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <code class="calibre6"><span class="calibre7">dentry_operations</span></code> object, which contains the methods that the kernel can invoke on a specific directory entry, such as <code class="calibre6"><span class="calibre7">d_compare()</span></code> and <code class="calibre6"><span class="calibre7">d_delete()</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The <code class="calibre6"><span class="calibre7">file_operations</span></code> object, which contains the methods that a process can invoke on an open file, such as <code class="calibre6"><span class="calibre7">read()</span></code> and <code class="calibre6"><span class="calibre7">write()</span></code></p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The operations objects are implemented as a structure of pointers to functions that operate on the parent object. For many methods, the objects can inherit a generic function if basic functionality is sufficient. Otherwise, the specific instance of the particular filesystem fills in the pointers with its own filesystem-specific methods.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos887375"></a>Again, note that <em class="calibre4">objects</em> refer to structures—not explicit class types, such as those in C++ or Java. These structures, however, represent specific instances of an object, their associated data, and methods to operate on themselves. They are very much objects.</p><div class="calibre_3"> </div>
<p class="calibre_2">The VFS loves structures, and it is comprised of a couple more than the primary objects previously discussed. Each registered filesystem is represented by a <code class="calibre6"><span class="calibre7">file_system_type</span></code> structure. This object describes the filesystem and its capabilities. Furthermore, each mount point is represented by the <code class="calibre6"><span class="calibre7">vfsmount</span></code> structure. This structure contains information about the mount point, such as its location and mount flags.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, two per-process structures describe the filesystem and files associated with a process. They are, respectively, the <code class="calibre6"><span class="calibre7">fs_struct</span></code> structure and the <code class="calibre6"><span class="calibre7">file</span></code> structure.</p><div class="calibre_3"> </div>
<p class="calibre_2">The rest of this chapter discusses these objects and the role they play in implementing the VFS layer.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos888675"> </div>
<h3 class="calibre_21"><span class="bold">The Superblock Object</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The superblock object is implemented by each filesystem and is used to store information describing that specific filesystem. This object usually corresponds to the <em class="calibre4">filesystem superblock</em> or the <em class="calibre4">filesystem control block</em>, which is stored in a special sector on disk (hence the object’s name). Filesystems that are not disk-based (a virtual memory–based filesystem, such as <em class="calibre4">sysfs</em>, for example) generate the superblock on-the-fly and store it in memory.</p><div class="calibre_3"> </div>
<p class="calibre_2">The superblock object is represented by struct <code class="calibre6"><span class="calibre7">super_block</span></code> and defined in <code class="calibre6"><span class="calibre7">&lt;linux/fs.h&gt;</span></code>. Here is what it looks like, with comments describing each entry:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00186.jpg" class="calibre2"/></p><div class="calibre_3"> </div>
<p class="calibre_32"><img alt="image" src="images/00187.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos889791"></a>The code for creating, managing, and destroying superblock objects lives in <code class="calibre6"><span class="calibre7">fs/super.c</span></code>. A superblock object is created and initialized via the <code class="calibre6"><span class="calibre7">alloc_super()</span></code> function. When mounted, a filesystem invokes this function, reads its superblock off of the disk, and fills in its superblock object.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos890202"> </div>
<h3 class="calibre_21"><span class="bold">Superblock Operations</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The most important item in the superblock object is <code class="calibre6"><span class="calibre7">s_op</span></code>, which is a pointer to the superblock operations table. The superblock operations table is represented by <code class="calibre6"><span class="calibre7">struct super_operations</span></code> and is defined in <code class="calibre6"><span class="calibre7">&lt;linux/fs.h&gt;</span></code>. It looks like this:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00188.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Each item in this structure is a pointer to a function that operates on a superblock object. The superblock operations perform low-level operations on the filesystem and its inodes.</p><div class="calibre_3"> </div>
<p class="calibre_2">When a filesystem needs to perform an operation on its superblock, it follows the pointers from its superblock object to the desired method. For example, if a filesystem wanted to write to its superblock, it would invoke</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">sb-&gt;s_op-&gt;write_super(sb);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">In this call, <code class="calibre6"><span class="calibre7">sb</span></code> is a pointer to the filesystem’s superblock. Following that pointer into <code class="calibre6"><span class="calibre7">s_op</span></code> yields the superblock operations table and ultimately the desired <code class="calibre6"><span class="calibre7">write_super()</span></code> function, which is then invoked. Note how the <code class="calibre6"><span class="calibre7">write_super()</span></code> call must be passed a superblock, despite the method being associated with one. This is because of the lack of object-oriented support in C. In C++, a call such as the following would suffice:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">sb.write_super();</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">In C, there is no way for the method to easily obtain its parent, so you have to pass it.</p><div class="calibre_3"> </div>
<p class="calibre_2">Let’s take a look at some of the superblock operations that are specified by <code class="calibre6"><span class="calibre7">super_operations</span></code>:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">struct inode * alloc_inode(struct super_block *sb)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Creates and initializes a new inode object under the given superblock.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void destroy_inode(struct inode *inode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Deallocates the given inode.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void dirty_inode(struct inode *inode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Invoked by the VFS when an inode is dirtied (modified). Journaling filesystems such as ext3 and ext4 use this function to perform journal updates.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void write_inode(struct inode *inode, int wait)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Writes the given inode to disk. The <code class="calibre6"><span class="calibre7">wait</span></code> parameter specifies whether the operation should be synchronous.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void drop_inode(struct inode *inode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS when the last reference to an inode is dropped. Normal Unix filesystems do not define this function, in which case the VFS simply deletes the inode.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void delete_inode(struct inode *inode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Deletes the given inode from the disk.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void put_super(struct super_block *sb)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS on unmount to release the given superblock object. The caller must hold the <code class="calibre6"><span class="calibre7">s_lock</span></code> lock.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void write_super(struct super_block *sb)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Updates the on-disk superblock with the specified superblock. The VFS uses this function to synchronize a modified in-memory superblock with the disk. The caller must hold the <code class="calibre6"><span class="calibre7">s_lock</span></code> lock.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int sync_fs(struct super_block *sb, int wait)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Synchronizes filesystem metadata with the on-disk filesystem. The <code class="calibre6"><span class="calibre7">wait</span></code> parameter specifies whether the operation is synchronous.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void write_super_lockfs(struct super_block *sb)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Prevents changes to the filesystem, and then updates the on-disk superblock with the specified superblock. It is currently used by LVM (the Logical Volume Manager).</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void unlockfs(struct super_block *sb)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Unlocks the filesystem against changes as done by <code class="calibre6"><span class="calibre7">write_super_lockfs()</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int statfs(struct super_block *sb, struct statfs *statfs)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS to obtain filesystem statistics. The statistics related to the given filesystem are placed in <code class="calibre6"><span class="calibre7">statfs</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int remount_fs(struct super_block *sb, int *flags, char *data)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS when the filesystem is remounted with new mount options. The caller must hold the <code class="calibre6"><span class="calibre7">s_lock</span></code> lock.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void clear_inode(struct inode *inode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS to release the inode and clear any pages containing related data.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void umount_begin(struct super_block *sb)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS to interrupt a mount operation. It is used by network filesystems, such as NFS.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">All these functions are invoked by the VFS, in process context. All except <code class="calibre6"><span class="calibre7">dirty_inode()</span></code> may all block if needed.</p><div class="calibre_3"> </div>
<p class="calibre_2">Some of these functions are optional; a specific filesystem can then set its value in the superblock operations structure to <code class="calibre6"><span class="calibre7">NULL</span></code>. If the associated pointer is <code class="calibre6"><span class="calibre7">NULL</span></code>, the VFS either calls a generic function or does nothing, depending on the operation.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos898714"> </div>
<h3 class="calibre_21"><span class="bold">The Inode Object</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos898833"> </div>
<p class="calibre_2">The inode object represents all the information needed by the kernel to manipulate a file or directory. For Unix-style filesystems, this information is simply read from the on-disk inode. If a filesystem does not have inodes, however, the filesystem must obtain the information from wherever it is stored on the disk. Filesystems without inodes generally store file-specific information as part of the file; unlike Unix-style filesystems, they do not separate file data from its control information. Some modern filesystems do neither and store file metadata as part of an on-disk database. Whatever the case, the inode object is constructed in memory in whatever manner is applicable to the filesystem.</p><div class="calibre_3"> </div>
<p class="calibre_2">The inode object is represented by <code class="calibre6"><span class="calibre7">struct inode</span></code> and is defined in <code class="calibre6"><span class="calibre7">&lt;linux/fs.h&gt;</span></code>. Here is the structure, with comments describing each entry:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00189.jpg" class="calibre2"/></p><div class="calibre_3"> </div>
<p class="calibre_32"><img alt="image" src="images/00190.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">An inode represents each file on a filesystem, but the inode object is constructed in memory only as files are accessed. This includes special files, such as device files or pipes. Consequently, some of the entries in <code class="calibre6"><span class="calibre7">struct inode</span></code> are related to these special files. For example, the <code class="calibre6"><span class="calibre7">i_pipe</span></code> entry points to a named pipe data structure, <code class="calibre6"><span class="calibre7">i_bdev</span></code> points to a block device structure, and <code class="calibre6"><span class="calibre7">i_cdev</span></code> points to a character device structure. These three pointers are stored in a union because a given inode can represent only one of these (or none of them) at a time.</p><div class="calibre_3"> </div>
<p class="calibre_2">It might occur that a given filesystem does not support a property represented in the inode object. For example, some filesystems might not record an access timestamp. In that case, the filesystem is free to implement the feature however it sees fit; it can store zero for <code class="calibre6"><span class="calibre7">i_atime</span></code>, make <code class="calibre6"><span class="calibre7">i_atime</span></code> equal to <code class="calibre6"><span class="calibre7">i_mtime</span></code>, update <code class="calibre6"><span class="calibre7">i_atime</span></code> in memory but never flush it back to disk, or whatever else the filesystem implementer decides.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos901438"> </div>
<h3 class="calibre_21"><span class="bold">Inode Operations</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">As with the superblock operations, the <code class="calibre6"><span class="calibre7">inode_operations</span></code> member is important. It describes the filesystem’s implemented functions that the VFS can invoke on an inode. As with the superblock, inode operations are invoked via</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">i-&gt;i_op-&gt;truncate(i)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">In this call, <code class="calibre6"><span class="calibre7">i</span></code> is a reference to a particular inode. In this case, the <code class="calibre6"><span class="calibre7">truncate()</span></code> operation defined by the filesystem on which <code class="calibre6"><span class="calibre7">i</span></code> exists is called on the given inode. The <code class="calibre6"><span class="calibre7">inode_operations</span></code> structure is defined in <code class="calibre6"><span class="calibre7">&lt;linux/fs.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00191.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The following interfaces constitute the various functions that the VFS may perform, or ask a specific filesystem to perform, on a given inode:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int create(struct inode *dir, struct dentry *dentry, int mode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">The VFS calls this function from the <code class="calibre6"><span class="calibre7">creat()</span></code> and <code class="calibre6"><span class="calibre7">open()</span></code> system calls to create a new inode associated with the given dentry object with the specified initial access mode.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">struct dentry * lookup(struct inode *dir, struct dentry *dentry)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">This function searches a directory for an inode corresponding to a filename specified in the given dentry.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int link(struct dentry *old_dentry,<br class="calibre1"/>         struct inode *dir,<br class="calibre1"/>         struct dentry *dentry)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Invoked by the <code class="calibre6"><span class="calibre7">link()</span></code> system call to create a hard link of the file <code class="calibre6"><span class="calibre7">old_dentry</span></code> in the directory <code class="calibre6"><span class="calibre7">dir</span></code> with the new filename <code class="calibre6"><span class="calibre7">dentry</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int unlink(struct inode *dir,<br class="calibre1"/>           struct dentry *dentry)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called from the <code class="calibre6"><span class="calibre7">unlink()</span></code> system call to remove the inode specified by the directory entry <code class="calibre6"><span class="calibre7">dentry</span></code> from the directory <code class="calibre6"><span class="calibre7">dir</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int symlink(struct inode *dir,<br class="calibre1"/>            struct dentry *dentry,<br class="calibre1"/>            const char *symname)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called from the <code class="calibre6"><span class="calibre7">symlink()</span></code> system call to create a symbolic link named <code class="calibre6"><span class="calibre7">symname</span></code> to the file represented by <code class="calibre6"><span class="calibre7">dentry</span></code> in the directory <code class="calibre6"><span class="calibre7">dir</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int mkdir(struct inode *dir,<br class="calibre1"/>          struct dentry *dentry,<br class="calibre1"/>          int mode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called from the <code class="calibre6"><span class="calibre7">mkdir()</span></code> system call to create a new directory with the given initial mode.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int rmdir(struct inode *dir,<br class="calibre1"/>          struct dentry *dentry)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the <code class="calibre6"><span class="calibre7">rmdir()</span></code> system call to remove the directory referenced by <code class="calibre6"><span class="calibre7">dentry</span></code> from the directory <code class="calibre6"><span class="calibre7">dir</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int mknod(struct inode *dir,<br class="calibre1"/>          struct dentry *dentry,<br class="calibre1"/>          int mode, dev_t rdev)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the <code class="calibre6"><span class="calibre7">mknod()</span></code> system call to create a special file (device file, named pipe, or socket). The file is referenced by the device <code class="calibre6"><span class="calibre7">rdev</span></code> and the directory entry <code class="calibre6"><span class="calibre7">dentry</span></code> in the directory <code class="calibre6"><span class="calibre7">dir</span></code>. The initial permissions are given via <code class="calibre6"><span class="calibre7">mode</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int rename(struct inode *old_dir,<br class="calibre1"/>           struct dentry *old_dentry,<br class="calibre1"/>           struct inode *new_dir,<br class="calibre1"/>           struct dentry *new_dentry)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS to move the file specified by <code class="calibre6"><span class="calibre7">old_dentry</span></code> from the <code class="calibre6"><span class="calibre7">old_dir</span></code> directory to the directory <code class="calibre6"><span class="calibre7">new_dir</span></code>, with the filename specified by <code class="calibre6"><span class="calibre7">new_dentry</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int readlink(struct dentry *dentry,<br class="calibre1"/>             char *buffer, int buflen)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the <code class="calibre6"><span class="calibre7">readlink()</span></code> system call to copy at most <code class="calibre6"><span class="calibre7">buflen</span></code> bytes of the full path associated with the symbolic link specified by <code class="calibre6"><span class="calibre7">dentry</span></code> into the specified buffer.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int follow_link(struct dentry *dentry,<br class="calibre1"/>                struct nameidata *nd)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS to translate a symbolic link to the inode to which it points. The link pointed at by <code class="calibre6"><span class="calibre7">dentry</span></code> is translated, and the result is stored in the <code class="calibre6"><span class="calibre7">nameidata</span></code> structure pointed at by <code class="calibre6"><span class="calibre7">nd</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int put_link(struct dentry *dentry,<br class="calibre1"/>             struct nameidata *nd)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS to clean up after a call to <code class="calibre6"><span class="calibre7">follow_link()</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void truncate(struct inode *inode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS to modify the size of the given file. Before invocation, the inode’s <code class="calibre6"><span class="calibre7">i_size</span></code> field must be set to the desired new size.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int permission(struct inode *inode, int mask)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Checks whether the specified access mode is allowed for the file referenced by <code class="calibre6"><span class="calibre7">inode</span></code>. This function returns zero if the access is allowed and a negative error code otherwise. Most filesystems set this field to <code class="calibre6"><span class="calibre7">NULL</span></code> and use the generic VFS method, which simply compares the mode bits in the inode’s objects to the given mask. More complicated filesystems, such as those supporting access control lists (ACLs), have a specific <code class="calibre6"><span class="calibre7">permission()</span></code> method.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int setattr(struct dentry *dentry,<br class="calibre1"/>            struct iattr *attr)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called from <code class="calibre6"><span class="calibre7">notify_change()</span></code> to notify a “change event” after an inode has been modified.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int getattr(struct vfsmount *mnt,<br class="calibre1"/>            struct dentry *dentry,<br class="calibre1"/>            struct kstat *stat)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Invoked by the VFS upon noticing that an inode needs to be refreshed from disk. Extended attributes allow the association of key/values pairs with files.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int setxattr(struct dentry *dentry,<br class="calibre1"/>             const char *name,<br class="calibre1"/>             const void *value, size_t size,<br class="calibre1"/>             int flags)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Used by the VFS to set the extended attribute <code class="calibre6"><span class="calibre7">name</span></code> to the value <code class="calibre6"><span class="calibre7">value</span></code> on the file referenced by <code class="calibre6"><span class="calibre7">dentry</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t getxattr(struct dentry *dentry,<br class="calibre1"/>                 const char *name,<br class="calibre1"/>                 void *value, size_t size)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Used by the VFS to copy into <code class="calibre6"><span class="calibre7">value</span></code> the value of the extended attribute <code class="calibre6"><span class="calibre7">name</span></code> for the specified file.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t listxattr(struct dentry *dentry,<br class="calibre1"/>                  char *list, size_t size)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Copies the list of all attributes for the specified file into the buffer <code class="calibre6"><span class="calibre7">list</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int removexattr(struct dentry *dentry,<br class="calibre1"/>                const char *name)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Removes the given attribute from the given file.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos914589"> </div>
<h3 class="calibre_21"><span class="bold">The Dentry Object</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos914709"> </div>
<p class="calibre_2">As discussed, the VFS treats directories as a type of file. In the path <code class="calibre6"><span class="calibre7">/bin/vi</span></code>, both <code class="calibre6"><span class="calibre7">bin</span></code> and <code class="calibre6"><span class="calibre7">vi</span></code> are files—<code class="calibre6"><span class="calibre7">bin</span></code> being the special directory file and <code class="calibre6"><span class="calibre7">vi</span></code> being a regular file. An inode object represents each of these components. Despite this useful unification, the VFS often needs to perform directory-specific operations, such as path name lookup. Path name lookup involves translating each component of a path, ensuring it is valid, and following it to the next component.</p><div class="calibre_3"> </div>
<p class="calibre_2">To facilitate this, the VFS employs the concept of a directory entry (dentry). A <em class="calibre4">dentry</em> is a specific component in a path. Using the previous example, <code class="calibre6"><span class="calibre7">/</span></code>, <code class="calibre6"><span class="calibre7">bin</span></code>, and <code class="calibre6"><span class="calibre7">vi</span></code> are all dentry objects. The first two are directories and the last is a regular file. This is an important point: Dentry objects are <em class="calibre4">all</em> components in a path, including files. Resolving a path and walking its components is a nontrivial exercise, time-consuming and heavy on string operations, which are expensive to execute and cumbersome to code. The dentry object makes the whole process easier.</p><div class="calibre_3"> </div>
<p class="calibre_2">Dentries might also include mount points. In the path <code class="calibre6"><span class="calibre7">/mnt/cdrom/foo</span></code>, the components <code class="calibre6"><span class="calibre7">/</span></code>, <code class="calibre6"><span class="calibre7">mnt</span></code>, <code class="calibre6"><span class="calibre7">cdrom</span></code>, and <code class="calibre6"><span class="calibre7">foo</span></code> are all dentry objects. The VFS constructs dentry objects on-the-fly, as needed, when performing directory operations.</p><div class="calibre_3"> </div>
<p class="calibre_2">Dentry objects are represented by <code class="calibre6"><span class="calibre7">struct dentry</span></code> and defined in <code class="calibre6"><span class="calibre7">&lt;linux/dcache.h&gt;</span></code>. Here is the structure, with comments describing each member:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00192.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Unlike the previous two objects, the dentry object does not correspond to any sort of on-disk data structure. The VFS creates it on-the-fly from a string representation of a path <a id="filepos917188"></a>name. Because the dentry object is not physically stored on the disk, no flag in <code class="calibre6"><span class="calibre7">struct dentry</span></code> specifies whether the object is modified (that is, whether it is dirty and needs to be written back to disk).</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos917478"> </div>
<h4 class="calibre_27"><span class="calibre3">Dentry State</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">A valid dentry object can be in one of three states: used, unused, or negative.</p><div class="calibre_3"> </div>
<p class="calibre_2">A used dentry corresponds to a valid inode (<code class="calibre6"><span class="calibre7">d_inode</span></code> points to an associated inode) and indicates that there are one or more users of the object (<code class="calibre6"><span class="calibre7">d_count</span></code> is positive). A used dentry is in use by the VFS and points to valid data and, thus, cannot be discarded.</p><div class="calibre_3"> </div>
<p class="calibre_2">An unused dentry corresponds to a valid inode (<code class="calibre6"><span class="calibre7">d_inode</span></code> points to an inode), but the VFS is not currently using the dentry object (<code class="calibre6"><span class="calibre7">d_count</span></code> is zero). Because the dentry object still points to a valid object, the dentry is kept around—cached—in case it is needed again. Because the dentry has not been destroyed prematurely, the dentry need not be re-created if it is needed in the future, and path name lookups can complete quicker than if the dentry was not cached. If it is necessary to reclaim memory, however, the dentry can be discarded because it is not in active use.</p><div class="calibre_3"> </div>
<p class="calibre_2">A negative dentry is not associated with a valid inode (<code class="calibre6"><span class="calibre7">d_inode</span></code> is <code class="calibre6"><span class="calibre7">NULL</span></code>) because either the inode was deleted or the path name was never correct to begin with. The dentry is kept around, however, so that future lookups are resolved quickly. For example, consider a daemon that continually tries to open and read a config file that is not present. The <code class="calibre6"><span class="calibre7">open()</span></code> system calls continually returns <code class="calibre6"><span class="calibre7">ENOENT</span></code>, but not until after the kernel constructs the path, walks the on-disk directory structure, and verifies the file’s inexistence. Because even this failed lookup is expensive, caching the “negative” results are worthwhile. Although a negative dentry is useful, it can be destroyed if memory is at a premium because nothing is actually using it.</p><div class="calibre_3"> </div>
<p class="calibre_2">A dentry object can also be freed, sitting in the slab object cache, as discussed in the previous chapter. In that case, there is no valid reference to the dentry object in any VFS or any filesystem code.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos920011"> </div>
<h4 class="calibre_27"><span class="calibre3">The Dentry Cache</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">After the VFS layer goes through the trouble of resolving each element in a path name into a dentry object and arriving at the end of the path, it would be quite wasteful to throw away all that work. Instead, the kernel caches dentry objects in the dentry cache or, simply, the <em class="calibre4">dcache</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The dentry cache consists of three parts:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Lists of “used” dentries linked off their associated inode via the <code class="calibre6"><span class="calibre7">i_dentry</span></code> field of the inode object. Because a given inode can have multiple links, there might be multiple dentry objects; consequently, a list is used.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A doubly linked “least recently used” list of unused and negative dentry objects. The list is inserted at the head, such that entries toward the head of the list are newer than entries toward the tail. When the kernel must remove entries to reclaim memory, the entries are removed from the tail; those are the oldest and presumably have the least chance of being used in the near future.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A hash table and hashing function used to quickly resolve a given path into the associated dentry object.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The hash table is represented by the <code class="calibre6"><span class="calibre7">dentry_hashtable</span></code> array. Each element is a pointer to a list of dentries that hash to the same value. The size of this array depends on the amount of physical RAM in the system.</p><div class="calibre_3"> </div>
<p class="calibre_2">The actual hash value is determined by <code class="calibre6"><span class="calibre7">d_hash()</span></code>. This enables filesystems to provide a unique hashing function.</p><div class="calibre_3"> </div>
<p class="calibre_2">Hash table lookup is performed <code class="calibre6"><span class="calibre7">via d_lookup()</span></code>. If a matching dentry object is found in the dcache, it is returned. On failure, <code class="calibre6"><span class="calibre7">NULL</span></code> is returned.</p><div class="calibre_3"> </div>
<p class="calibre_2">As an example, assume that you are editing a source file in your home directory, <code class="calibre6"><span class="calibre7">/home/dracula/src/the_sun_sucks.c</span></code>. Each time this file is accessed (for example, when you first open it, later save it, compile it, and so on), the VFS must follow each directory entry to resolve the full path: <code class="calibre6"><span class="calibre7">/</span></code>, <code class="calibre6"><span class="calibre7">home</span></code>, <code class="calibre6"><span class="calibre7">dracula</span></code>, <code class="calibre6"><span class="calibre7">src</span></code>, and finally <code class="calibre6"><span class="calibre7">the_sun_sucks.c</span></code>. To avoid this time-consuming operation each time this path name is accessed, the VFS can first try to look up the path name in the dentry cache. If the lookup succeeds, the required final dentry object is obtained without serious effort. Conversely, if the dentry is not in the dentry cache, the VFS must manually resolve the path by walking the filesystem for each component of the path. After this task is completed, the kernel adds the dentry objects to the dcache to speed up any future lookups.</p><div class="calibre_3"> </div>
<p class="calibre_2">The dcache also provides the front end to an inode cache, the <em class="calibre4">icache</em>. Inode objects that are associated with dentry objects are not freed because the dentry maintains a positive usage count over the inode. This enables dentry objects to pin inodes in memory. As long as the dentry is cached, the corresponding inodes are cached, too. Consequently, when a path name lookup succeeds from cache, as in the previous example, the associated inodes are already cached in memory.</p><div class="calibre_3"> </div>
<p class="calibre_2">Caching dentries and inodes is beneficial because file access exhibits both spatial and temporal locality. File access is temporal in that programs tend to access and reaccess the same files over and over. Thus when a file is accessed, there is a high probability that caching the associated dentries and inodes will result in a cache hit in the near future. File access is spatial in that programs tend to access multiple files in the same directory. Thus caching directories entries for one file have a high probability of a cache hit, as a related file is likely manipulated next.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos924625"> </div>
<h3 class="calibre_21"><span class="bold">Dentry Operations</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos924745"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">dentry_operations</span></code> structure specifies the methods that the VFS invokes on directory entries on a given filesystem.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">dentry_operations</span></code> structure is defined in <code class="calibre6"><span class="calibre7">&lt;linux/dcache.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00193.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The methods are as follows:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int d_revalidate(struct dentry *dentry,<br class="calibre1"/>                 struct nameidata *)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Determines whether the given dentry object is valid. The VFS calls this function whenever it is preparing to use a dentry from the dcache. Most filesystems set this method to <code class="calibre6"><span class="calibre7">NULL</span></code> because their dentry objects in the dcache are always valid.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int d_hash(struct dentry *dentry,<br class="calibre1"/>           struct qstr *name)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Creates a hash value from the given dentry. The VFS calls this function whenever it adds a dentry to the hash table.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int d_compare(struct dentry *dentry,<br class="calibre1"/>              struct qstr *name1,<br class="calibre1"/>              struct qstr *name2)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32"><a id="filepos926843"></a>Called by the VFS to compare two filenames, <code class="calibre6"><span class="calibre7">name1</span></code> and <code class="calibre6"><span class="calibre7">name2</span></code>. Most filesystems leave this at the VFS default, which is a simple string compare. For some filesystems, such as FAT, a simple string compare is insufficient. The FAT filesystem is not case-sensitive and therefore needs to implement a comparison function that disregards case. This function requires the <code class="calibre6"><span class="calibre7">dcache_lock</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int d_delete (struct dentry *dentry)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS when the specified dentry object’s <code class="calibre6"><span class="calibre7">d_count</span></code> reaches zero. This function requires the <code class="calibre6"><span class="calibre7">dcache_lock</span></code> and the dentry’s <code class="calibre6"><span class="calibre7">d_lock</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void d_release(struct dentry *dentry)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS when the specified dentry is going to be freed. The default function does nothing.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void d_iput(struct dentry *dentry,<br class="calibre1"/>            struct inode *inode)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS when a dentry object loses its associated inode (say, because the entry was deleted from the disk). By default, the VFS simply calls the <code class="calibre6"><span class="calibre7">iput()</span></code> function to release the inode. If a filesystem overrides this function, it must also call <code class="calibre6"><span class="calibre7">iput()</span></code> in addition to performing whatever filesystem-specific work it requires.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos928969"> </div>
<h3 class="calibre_21"><span class="bold">The File Object</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The final primary VFS object that we shall look at is the file object. The file object is used to represent a file opened by a process. When we think of the VFS from the perspective of user-space, the file object is what readily comes to mind. Processes deal directly with files, not superblocks, inodes, or dentries. It is not surprising that the information in the file object is the most familiar (data such as access mode and current offset) or that the file operations are familiar system calls such as <code class="calibre6"><span class="calibre7">read()</span></code> and <code class="calibre6"><span class="calibre7">write()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The file object is the in-memory representation of an open file. The object (but not the physical file) is created in response to the <code class="calibre6"><span class="calibre7">open()</span></code> system call and destroyed in response to the <code class="calibre6"><span class="calibre7">close()</span></code> system call. All these file-related calls are actually methods defined in the file operations table. Because multiple processes can open and manipulate a file at the same time, there can be multiple file objects in existence for the same file. The file object merely represents a process’s view of an open file. The object points back to the dentry (which in turn points back to the inode) that actually represents the open file. The inode and dentry objects, of course, are unique.</p><div class="calibre_3"> </div>
<p class="calibre_2">The file object is represented by <code class="calibre6"><span class="calibre7">struct file</span></code> and is defined in <code class="calibre6"><span class="calibre7">&lt;linux/fs.h&gt;</span></code>. Let’s look at the structure, again with comments added to describe each entry:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00194.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos930915"></a>Similar to the dentry object, the file object does not actually correspond to any on-disk data. Therefore, no flag in the object represents whether the object is dirty and needs to be written back to disk. The file object does point to its associated dentry object via the <code class="calibre6"><span class="calibre7">f_dentry</span></code> pointer. The dentry in turn points to the associated inode, which reflects whether the file itself is dirty.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos931391"> </div>
<h3 class="calibre_21"><span class="bold">File Operations</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">As with all the other VFS objects, the file operations table is quite important. The operations associated with <code class="calibre6"><span class="calibre7">struct file</span></code> are the familiar system calls that form the basis of the standard Unix system calls.</p><div class="calibre_3"> </div>
<p class="calibre_2">The file object methods are specified in <code class="calibre6"><span class="calibre7">file_operations</span></code> and defined in <code class="calibre6"><span class="calibre7">&lt;linux/fs.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00195.jpg" class="calibre2"/></p><div class="calibre_3"> </div>
<p class="calibre_32"><img alt="image" src="images/00196.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Filesystems can implement unique functions for each of these operations, or they can use a generic method if one exists. The generic methods tend to work fine on normal Unix-based filesystems. A filesystem is under no obligation to implement all these methods—although not implementing the basics is silly—and can simply set the method to <code class="calibre6"><span class="calibre7">NULL</span></code> if not interested.</p><div class="calibre_3"> </div>
<p class="calibre_2">Here are the individual operations:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">loff_t llseek(struct file *file,<br class="calibre1"/>              loff_t offset, int origin)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Updates the file pointer to the given offset. It is called via the <code class="calibre6"><span class="calibre7">llseek()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t read(struct file *file,<br class="calibre1"/>             char *buf, size_t count,<br class="calibre1"/>             loff_t *offset)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Reads <code class="calibre6"><span class="calibre7">count</span></code> bytes from the given file at position <code class="calibre6"><span class="calibre7">offset</span></code> into <code class="calibre6"><span class="calibre7">buf</span></code>. The file pointer is then updated. This function is called by the <code class="calibre6"><span class="calibre7">read()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25"><a id="filepos933960"></a>• <code class="calibre6"><span class="calibre7">ssize_t aio_read(struct kiocb *iocb,<br class="calibre1"/>                 char *buf, size_t count,<br class="calibre1"/>                 loff_t offset)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Begins an asynchronous read of <code class="calibre6"><span class="calibre7">count</span></code> bytes into <code class="calibre6"><span class="calibre7">buf</span></code> of the file described in <code class="calibre6"><span class="calibre7">iocb</span></code>. This function is called by the <code class="calibre6"><span class="calibre7">aio_read()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t write(struct file *file,<br class="calibre1"/>              const char *buf, size_t count,<br class="calibre1"/>              loff_t *offset)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Writes <code class="calibre6"><span class="calibre7">count</span></code> bytes from <code class="calibre6"><span class="calibre7">buf</span></code> into the given file at position <code class="calibre6"><span class="calibre7">offset</span></code>. The file pointer is then updated. This function is called by the <code class="calibre6"><span class="calibre7">write()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t aio_write(struct kiocb *iocb,<br class="calibre1"/>                  const char *buf,<br class="calibre1"/>                  size_t count, loff_t offset)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Begins an asynchronous write of <code class="calibre6"><span class="calibre7">count</span></code> bytes into <code class="calibre6"><span class="calibre7">buf</span></code> of the file described in <code class="calibre6"><span class="calibre7">iocb</span></code>. This function is called by the <code class="calibre6"><span class="calibre7">aio_write()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int readdir(struct file *file, void *dirent,<br class="calibre1"/>            filldir_t filldir)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Returns the next directory in a directory listing. This function is called by the <code class="calibre6"><span class="calibre7">readdir()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">unsigned int poll(struct file *file,<br class="calibre1"/>                  struct poll_table_struct *poll_table)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Sleeps, waiting for activity on the given file. It is called by the <code class="calibre6"><span class="calibre7">poll()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int ioctl(struct inode *inode,<br class="calibre1"/>          struct file *file,<br class="calibre1"/>          unsigned int cmd,<br class="calibre1"/>          unsigned long arg)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Sends a command and argument pair to a device. It is used when the file is an open device node. This function is called from the <code class="calibre6"><span class="calibre7">ioctl()</span></code> system call. Callers must hold the BKL.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int unlocked_ioctl(struct file *file,<br class="calibre1"/>                   unsigned int cmd,<br class="calibre1"/>                   unsigned long arg)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Implements the same functionality as <code class="calibre6"><span class="calibre7">ioctl()</span></code> but without needing to hold the BKL. The VFS calls <code class="calibre6"><span class="calibre7">unlocked_ioctl()</span></code> if it exists in lieu of <code class="calibre6"><span class="calibre7">ioctl()</span></code> when user-space invokes the ioctl() system call. Thus filesystems need implement only one, preferably <code class="calibre6"><span class="calibre7">unlocked_ioctl()</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int compat_ioctl(struct file *file,<br class="calibre1"/>                 unsigned int cmd,<br class="calibre1"/>                 unsigned long arg)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Implements a portable variant of <code class="calibre6"><span class="calibre7">ioctl()</span></code> for use on 64-bit systems by 32-bit applications. This function is designed to be 32-bit safe even on 64-bit architectures, performing any necessary size conversions. New drivers should design their ioctl commands such that all are portable, and thus enable <code class="calibre6"><span class="calibre7">compat_ioctl()</span></code> and <code class="calibre6"><span class="calibre7">unlocked_ioctl()</span></code> to point to the same function. Like <code class="calibre6"><span class="calibre7">unlocked_ioctl()</span></code>, <code class="calibre6"><span class="calibre7">compat_ioctl()</span></code> does not hold the BKL.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int mmap(struct file *file,<br class="calibre1"/>         struct vm_area_struct *vma)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Memory maps the given file onto the given address space and is called by the <code class="calibre6"><span class="calibre7">mmap()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int open(struct inode *inode,<br class="calibre1"/>         struct file *file)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Creates a new file object and links it to the corresponding inode object. It is called by the <code class="calibre6"><span class="calibre7">open()</span></code> system call.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int flush(struct file *file)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS whenever the reference count of an open file decreases. Its purpose is filesystem-dependent.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int release(struct inode *inode,<br class="calibre1"/>            struct file *file)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the VFS when the last remaining reference to the file is destroyed—for example, when the last process sharing a file descriptor calls <code class="calibre6"><span class="calibre7">close()</span></code> or exits. Its purpose is filesystem-dependent.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int fsync(struct file *file,<br class="calibre1"/>          struct dentry *dentry,<br class="calibre1"/>          int datasync)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the <code class="calibre6"><span class="calibre7">fsync()</span></code> system call to write all cached data for the file to disk.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int aio_fsync(struct kiocb *iocb,<br class="calibre1"/>              int datasync)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the <code class="calibre6"><span class="calibre7">aio_fsync()</span></code> system call to write all cached data for the file associated with <code class="calibre6"><span class="calibre7">iocb</span></code> to disk.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int fasync(int fd, struct file *file, int on)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Enables or disables signal notification of asynchronous I/O.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int lock(struct file *file, int cmd,<br class="calibre1"/>         struct file_lock *lock)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Manipulates a file lock on the given file.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t readv(struct file *file,<br class="calibre1"/>              const struct iovec *vector,<br class="calibre1"/>              unsigned long count,<br class="calibre1"/>              loff_t *offset)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the <code class="calibre6"><span class="calibre7">readv()</span></code> system call to read from the given file and put the results into the <code class="calibre6"><span class="calibre7">count</span></code> buffers described by <code class="calibre6"><span class="calibre7">vector</span></code>. The file offset is then incremented.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t writev(struct file *file,<br class="calibre1"/>               const struct iovec *vector,<br class="calibre1"/>               unsigned long count,<br class="calibre1"/>               loff_t *offset)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Called by the <code class="calibre6"><span class="calibre7">writev()</span></code> system call to write from the <code class="calibre6"><span class="calibre7">count</span></code> buffers described by <code class="calibre6"><span class="calibre7">vector</span></code> into the file specified by <code class="calibre6"><span class="calibre7">file</span></code>. The file offset is then incremented.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t sendfile(struct file *file,<br class="calibre1"/>                 loff_t *offset,<br class="calibre1"/>                 size_t size,<br class="calibre1"/>                 read_actor_t actor,<br class="calibre1"/>                 void *target)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32"><a id="filepos945899"></a>Called by the <code class="calibre6"><span class="calibre7">sendfile()</span></code> system call to copy data from one file to another. It performs the copy entirely in the kernel and avoids an extraneous copy to user-space.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">ssize_t sendpage(struct file *file,<br class="calibre1"/>                 struct page *page,<br class="calibre1"/>                 int offset, size_t size,<br class="calibre1"/>                 loff_t *pos, int more)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Used to send data from one file to another.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">unsigned long get_unmapped_area(struct file *file,<br class="calibre1"/>                                unsigned long addr,<br class="calibre1"/>                                unsigned long len,<br class="calibre1"/>                                unsigned long offset,<br class="calibre1"/>                                unsigned long flags)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Gets unused address space to map the given file.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int check_flags(int flags)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Used to check the validity of the flags passed to the <code class="calibre6"><span class="calibre7">fcntl()</span></code> system call when the <code class="calibre6"><span class="calibre7">SETFL</span></code> command is given. As with many VFS operations, filesystems need not implement <code class="calibre6"><span class="calibre7">check_flags()</span></code>; currently, only NFS does so. This function enables filesystems to restrict invalid <code class="calibre6"><span class="calibre7">SETFL</span></code> flags otherwise enabled by the generic <code class="calibre6"><span class="calibre7">fcntl()</span></code> function. In the case of NFS, combining <code class="calibre6"><span class="calibre7">O_APPEND</span></code> and <code class="calibre6"><span class="calibre7">O_DIRECT</span></code> is not enabled.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int flock(struct file *filp,<br class="calibre1"/>          int cmd,<br class="calibre1"/>          struct file_lock *fl)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">Used to implement the <code class="calibre6"><span class="calibre7">flock()</span></code> system call, which provides advisory locking.</p></blockquote><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">So Many Ioctls!</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">Not long ago, there existed only a single ioctl method. Today, there are three methods. <code class="calibre6"><span class="calibre7">unlocked_ioctl()</span></code> is the same as <code class="calibre6"><span class="calibre7">ioctl()</span></code>, except it is called without the Big Kernel Lock (BKL). It is thus up to the author of that function to ensure proper synchronization. Because the BKL is a coarse-grained, inefficient lock, drivers should implement <code class="calibre6"><span class="calibre7">unlocked_ioctl()</span></code> and not <code class="calibre6"><span class="calibre7">ioctl()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><code class="calibre6"><span class="calibre7">compat_ioctl()</span></code> is also called without the BKL, but its purpose is to provide a 32-bit compatible ioctl method for 64-bit systems. How you implement it depends on your existing ioctl commands. Older drivers with implicitly sized types (such as <code class="calibre6"><span class="calibre7">long</span></code>) should implement a <code class="calibre6"><span class="calibre7">compat_ioctl()</span></code> method that works appropriately with 32-bit applications. This generally means translating the 32-bit values to the appropriate types for a 64-bit kernel. New drivers that have the luxury of designing their ioctl commands from scratch should ensure all their arguments and data are explicitly sized, safe for 32-bit apps on a 32-bit system, 32-bit apps on a 64-bit system, and 64-bit apps on a 64-bit system. These drivers can then point the <code class="calibre6"><span class="calibre7">compat_ioctl()</span></code> function pointer at the same function as <code class="calibre6"><span class="calibre7">unlocked_ioctl()</span></code>.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos951256"> </div>
<h3 class="calibre_21"><span class="bold">Data Structures Associated with Filesystems</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos951402"> </div>
<p class="calibre_2">In addition to the fundamental VFS objects, the kernel uses other standard data structures to manage data related to filesystems. The first object is used to describe a specific variant of a filesystem, such as ext3, ext4, or UDF. The second data structure describes a mounted instance of a filesystem.</p><div class="calibre_3"> </div>
<p class="calibre_2">Because Linux supports so many different filesystems, the kernel must have a special structure for describing the capabilities and behavior of each filesystem. The <code class="calibre6"><span class="calibre7">file_system_type</span></code> structure, defined in <code class="calibre6"><span class="calibre7">&lt;linux/fs.h&gt;</span></code>, accomplishes this:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00197.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">get_sb()</span></code> function reads the superblock from the disk and populates the superblock object when the filesystem is loaded. The remaining functions describe the filesystem’s properties.</p><div class="calibre_3"> </div>
<p class="calibre_2">There is only one <code class="calibre6"><span class="calibre7">file_system_type</span></code> per filesystem, regardless of how many instances of the filesystem are mounted on the system, or whether the filesystem is even mounted at all.</p><div class="calibre_3"> </div>
<p class="calibre_2">Things get more interesting when the filesystem is actually mounted, at which point the <code class="calibre6"><span class="calibre7">vfsmount</span></code> structure is created. This structure represents a specific instance of a filesystem—in other words, a mount point.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">vfsmount</span></code> structure is defined in <code class="calibre6"><span class="calibre7">&lt;linux/mount.h&gt;</span></code>. Here it is:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00198.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos953380"></a>The complicated part of maintaining the list of all mount points is the relation between the filesystem and all the other mount points. The various linked lists in <code class="calibre6"><span class="calibre7">vfsmount</span></code> keep track of this information.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">vfsmount</span></code> structure also stores the flags, if any, specified on mount in the <code class="calibre6"><span class="calibre7">mnt_flags</span></code> field. <a href="#filepos953964">Table 13.1</a> is a list of the standard mount flags.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos953964"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 13.1. Standard Mount Flags</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00199.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">These flags are most useful on removable devices that the administrator does not trust. They are defined in <code class="calibre6"><span class="calibre7">&lt;linux/mount.h&gt;</span></code> along with other, lesser used, flags.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos954499"> </div>
<h3 class="calibre_21"><span class="bold">Data Structures Associated with a Process</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Each process on the system has its own list of open files, root filesystem, current working directory, mount points, and so on. Three data structures tie together the VFS layer and the processes on the system: <code class="calibre6"><span class="calibre7">files_struct</span></code>, <code class="calibre6"><span class="calibre7">fs_struct</span></code>, and <code class="calibre6"><span class="calibre7">namespace</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos955048"></a>The <code class="calibre6"><span class="calibre7">files_struct</span></code> is defined in <code class="calibre6"><span class="calibre7">&lt;linux/fdtable.h&gt;</span></code>. This table’s address is pointed to by the <code class="calibre6"><span class="calibre7">files</span></code> entry in the processor descriptor. All per-process information about open files and file descriptors is contained therein. Here it is, with comments:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00200.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The array <code class="calibre6"><span class="calibre7">fd_array</span></code> points to the list of open file objects. Because <code class="calibre6"><span class="calibre7">NR_OPEN_DEFAULT</span></code> is equal to <code class="calibre6"><span class="calibre7">BITS_PER_LONG</span></code>, which is 64 on a 64-bit architecture; this includes room for 64 file objects. If a process opens more than 64 file objects, the kernel allocates a new array and points the <code class="calibre6"><span class="calibre7">fdt</span></code> pointer at it. In this fashion, access to a reasonable number of file objects is quick, taking place in a static array. If a process opens an abnormal number of files, the kernel can create a new array. If the majority of processes on a system opens more than 64 files, for optimum performance the administrator can increase the <code class="calibre6"><span class="calibre7">NR_OPEN_DEFAULT</span></code> preprocessor macro to match.</p><div class="calibre_3"> </div>
<p class="calibre_2">The second process-related structure is <code class="calibre6"><span class="calibre7">fs_struct</span></code>, which contains filesystem information related to a process and is pointed at by the <code class="calibre6"><span class="calibre7">fs</span></code> field in the process descriptor. The structure is defined in <code class="calibre6"><span class="calibre7">&lt;linux/fs_struct.h&gt;</span></code>. Here it is, with comments:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00201.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This structure holds the current working directory (<code class="calibre6"><span class="calibre7">pwd</span></code>) and root directory of the current process.</p><div class="calibre_3"> </div>
<p class="calibre_2">The third and final structure is the <code class="calibre6"><span class="calibre7">namespace</span></code> structure, which is defined in <code class="calibre6"><span class="calibre7">&lt;linux/mnt_namespace.h&gt;</span></code> and pointed at by the <code class="calibre6"><span class="calibre7">mnt_namespace</span></code> field in the process descriptor. Per-process namespaces were added to the 2.4 Linux kernel. They enable each process to have a unique view of the mounted filesystems on the system—not just a unique root directory, but an entirely unique filesystem hierarchy. Here is the structure, with the usual comments:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00202.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos957818"></a>The <code class="calibre6"><span class="calibre7">list</span></code> member specifies a doubly linked list of the mounted filesystems that make up the namespace.</p><div class="calibre_3"> </div>
<p class="calibre_2">These data structures are linked from each process descriptor. For most processes, the process descriptor points to unique <code class="calibre6"><span class="calibre7">files_struct</span></code> and <code class="calibre6"><span class="calibre7">fs_struct</span></code> structures. For processes created with the clone flag <code class="calibre6"><span class="calibre7">CLONE_FILES</span></code> or <code class="calibre6"><span class="calibre7">CLONE_FS</span></code>, however, these structures are shared.<sup class="calibre8"><a id="filepos958416" href="#filepos958859">3</a></sup> Consequently, multiple process descriptors might point to the same <code class="calibre6"><span class="calibre7">files_struct</span></code> or <code class="calibre6"><span class="calibre7">fs_struct</span></code> structure. The <code class="calibre6"><span class="calibre7">count</span></code> member of each structure provides a reference count to prevent destruction while a process is still using the structure.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos958859" href="#filepos958416">3</a></sup>
<em class="calibre4">Threads usually specify</em>
<code class="calibre6"><span class="calibre7">CLONE_FILES</span></code>
<em class="calibre4">and</em>
<code class="calibre6"><span class="calibre7">CLONE_FS</span></code>
<em class="calibre4">and, thus, share a single</em>
<code class="calibre6"><span class="calibre7">files_struct</span></code>
<em class="calibre4">and</em>
<code class="calibre6"><span class="calibre7">fs_struct</span></code>
<em class="calibre4">among themselves. Normal processes, on the other hand, do not specify these flags and consequently have their own filesystems information and open files tables.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">namespace</span></code> structure works the other way around. By default, all processes share the same namespace. (That is, they all see the same filesystem hierarchy from the same mount table.) Only when the <code class="calibre6"><span class="calibre7">CLONE_NEWNS</span></code> flag is specified during <code class="calibre6"><span class="calibre7">clone()</span></code> is the process given a unique copy of the <code class="calibre6"><span class="calibre7">namespace</span></code> structure. Because most processes do <em class="calibre4">not</em> provide this flag, all the processes inherit their parents’ namespaces. Consequently, on many systems there is only one namespace, although the functionality is but a single <code class="calibre6"><span class="calibre7">CLONE_NEWNS</span></code> flag away.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos960183"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Linux supports a wide range of filesystems, from native filesystems, such as ext3 and ext4, to networked filesystems, such as NFS and Coda—more than 60 filesystems alone in the official kernel. The VFS layer provides these disparate filesystems with both a framework for their implementation and an interface for working with the standard system calls. The VFS layer, thus, both makes it clean to implement new filesystems in Linux and enables those filesystems to automatically interoperate via the standard Unix system calls.</p><div class="calibre_3"> </div>
<p class="calibre_2">This chapter described the purpose of the VFS and discussed its various data structures, including the all-important inode, dentry, and superblock objects. <a href="index_split_023.html#filepos961208">Chapter 14</a>, “The Block I/O Layer,” discusses how data physically ends up in a filesystem.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_63"></div>
</body></html>
