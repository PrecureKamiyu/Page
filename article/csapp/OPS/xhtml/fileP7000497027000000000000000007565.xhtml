<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.10 Garbage Collection</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000007565" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000046075" data-uri="chapter09.xhtml#P7000497027000000000000000046075" epub:type="title"><span class="pcalibre label pcalibre1">9.10 </span>Garbage Collection</h1></header>
<p id="P7000497027000000000000000046076" data-uri="chapter09.xhtml#P7000497027000000000000000046076" class="pcalibre1 pcalibre calibre2">With an explicit allocator such as the C <code id="P7000497027000000000000000046077" data-uri="chapter09.xhtml#P7000497027000000000000000046077" class="pcalibre1 calibre8 pcalibre">malloc</code> package, an application allocates and frees heap blocks by making calls to <code id="P7000497027000000000000000046078" data-uri="chapter09.xhtml#P7000497027000000000000000046078" class="pcalibre1 calibre8 pcalibre">malloc</code> and <code id="P7000497027000000000000000046079" data-uri="chapter09.xhtml#P7000497027000000000000000046079" class="pcalibre1 calibre8 pcalibre">free</code>. It is the application's responsibility to free any allocated blocks that it no longer needs.</p>
<p id="P700049702700000000000000004607A" data-uri="chapter09.xhtml#P700049702700000000000000004607A" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000756C" title="866" data-uri="chapter09.xhtml#P700049702700000000000000000756C" epub:type="pagebreak"></span>Failing to free allocated blocks is a common programming error. For example, consider the following C function that allocates a block of temporary storage as part of its processing:</p>
<pre id="P700049702700000000000000004607B" data-uri="chapter09.xhtml#P700049702700000000000000004607B" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004607C" data-uri="chapter09.xhtml#P700049702700000000000000004607C" class="calibre10 pcalibre pcalibre1">
1	void garbage()
2	{
3		int *p = (int *)Malloc(15213);
4	
5		return; /* Array p is garbage at this point */
6	}
</code></pre>
<p id="P700049702700000000000000004607D" data-uri="chapter09.xhtml#P700049702700000000000000004607D" class="pcalibre1 pcalibre calibre2">Since <code id="P700049702700000000000000004607E" data-uri="chapter09.xhtml#P700049702700000000000000004607E" class="pcalibre1 calibre8 pcalibre">p</code> is no longer needed by the program, it should have been freed before garbage returned. Unfortunately, the programmer has forgotten to free the block. It remains allocated for the lifetime of the program, needlessly occupying heap space that could be used to satisfy subsequent allocation requests.</p>
<p id="P700049702700000000000000004607F" data-uri="chapter09.xhtml#P700049702700000000000000004607F" class="pcalibre1 pcalibre calibre2">A <i class="calibre5 pcalibre pcalibre1">garbage collector</i> is a dynamic storage allocator that automatically frees allocated blocks that are no longer needed by the program. Such blocks are known as <i class="calibre5 pcalibre pcalibre1">garbage</i> (hence the term "garbage collector"). The process of automatically reclaiming heap storage is known as <i class="calibre5 pcalibre pcalibre1">garbage collection.</i> In a system that supports garbage collection, applications explicitly allocate heap blocks but never explicitly free them. In the context of a C program, the application calls <code id="P7000497027000000000000000046080" data-uri="chapter09.xhtml#P7000497027000000000000000046080" class="pcalibre1 calibre8 pcalibre">malloc</code> but never calls <code id="P7000497027000000000000000046081" data-uri="chapter09.xhtml#P7000497027000000000000000046081" class="pcalibre1 calibre8 pcalibre">free</code>. Instead, the garbage collector periodically identifies the garbage blocks and makes the appropriate calls to <code id="P7000497027000000000000000046082" data-uri="chapter09.xhtml#P7000497027000000000000000046082" class="pcalibre1 calibre8 pcalibre">free</code> to place those blocks back on the free list.</p>
<p id="P7000497027000000000000000046083" data-uri="chapter09.xhtml#P7000497027000000000000000046083" class="pcalibre1 pcalibre calibre2">Garbage collection dates back to Lisp systems developed by John McCarthy at MIT in the early 1960s. It is an important part of modern language systems such as Java, ML, Perl, and Mathematica, and it remains an active and important area of research. The literature describes an amazing number of approaches for garbage collection. We will limit our discussion to McCarthy's original <i class="calibre5 pcalibre pcalibre1">Mark&amp;Sweep</i> algorithm, which is interesting because it can be built on top of an existing <code id="P7000497027000000000000000046084" data-uri="chapter09.xhtml#P7000497027000000000000000046084" class="pcalibre1 calibre8 pcalibre">malloc</code> package to provide garbage collection for C and C++ programs.</p>
<section id="P7000497027000000000000000007577" data-uri="chapter09.xhtml#P7000497027000000000000000007577" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046085" data-uri="chapter09.xhtml#P7000497027000000000000000046085" epub:type="title"><span class="pcalibre label pcalibre1">9.10.1 </span>Garbage Collector Basics</h1></header>
<p id="P7000497027000000000000000046086" data-uri="chapter09.xhtml#P7000497027000000000000000046086" class="pcalibre1 pcalibre calibre2">A garbage collector views memory as a directed <i class="calibre5 pcalibre pcalibre1">reachability graph</i> of the form shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000757B"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.49</span></a>. The nodes of the graph are partitioned into a set of <i class="calibre5 pcalibre pcalibre1">root nodes</i> and a set of <i class="calibre5 pcalibre pcalibre1">heap nodes.</i> Each heap node corresponds to an allocated block in the heap. A directed edge <var class="calibre5 pcalibre pcalibre1">p</var>â†’ <var class="calibre5 pcalibre pcalibre1">q</var> means that some location in block <var class="calibre5 pcalibre pcalibre1">p</var> points to some location in block <i class="calibre5 pcalibre pcalibre1">q.</i> Root nodes correspond to locations not in the heap that contain pointers into the heap. These locations can be registers, variables on the stack, or global variables in the read/write data area of virtual memory.</p>
<p id="P7000497027000000000000000046087" data-uri="chapter09.xhtml#P7000497027000000000000000046087" class="pcalibre1 pcalibre calibre2">We say that a node <var class="calibre5 pcalibre pcalibre1">p</var> is <i class="calibre5 pcalibre pcalibre1">reachable</i> if there exists a directed path from any root node to <i class="calibre5 pcalibre pcalibre1">p.</i> At any point in time, the unreachable nodes correspond to garbage that can never be used again by the application. The role of a garbage collector is to maintain some representation of the reachability graph and periodically reclaim the unreachable nodes by freeing them and returning them to the free list.</p>
<figure id="P700049702700000000000000000757B" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P700049702700000000000000000757B">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000757C" title="867" data-uri="chapter09.xhtml#P700049702700000000000000000757C" epub:type="pagebreak"></span>
<img alt="A directed graph has arrows from three reachable root nodes to reachable heap nodes below: one branching to two reachable nodes; one above a circle of three unreachable (garbage) nodes; and one to a reachable node beside an unreachable." id="P7000497027000000000000000046088" data-uri="P700049702700000000000000000B7A7" src="../images/p867-1.png" class="pcalibre1 calibre301 pcalibre"/>
<figcaption id="P7000497027000000000000000046089" data-uri="chapter09.xhtml#P7000497027000000000000000046089" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004608A" data-uri="chapter09.xhtml#P700049702700000000000000004608A" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.49 </span>A garbage collector's view of memory as a directed graph.</h1></header></figcaption>
</figure>
<figure id="P7000497027000000000000000007580" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007580">
<img alt="A diagram shows an interaction with a C application program and malloc() within a dynamic storage allocator, within which a conservative garbage collector interacts with malloc() and free()." id="P700049702700000000000000004608B" data-uri="P700049702700000000000000000B7A8" src="../images/p867-2.png" class="pcalibre calibre302 pcalibre1"/>
<figcaption id="P700049702700000000000000004608C" data-uri="chapter09.xhtml#P700049702700000000000000004608C" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004608D" data-uri="chapter09.xhtml#P700049702700000000000000004608D" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.50 </span>Integrating a conservative garbage collector and a C <code id="P700049702700000000000000004608E" data-uri="chapter09.xhtml#P700049702700000000000000004608E" class="pcalibre1 calibre8 pcalibre">malloc</code> package.</h1></header></figcaption>
</figure>
<p id="P700049702700000000000000004608F" data-uri="chapter09.xhtml#P700049702700000000000000004608F" class="pcalibre1 pcalibre calibre2">Garbage collectors for languages like ML and Java, which exert tight control over how applications create and use pointers, can maintain an exact representation of the reachability graph and thus can reclaim all garbage. However, collectors for languages like C and C++ cannot in general maintain exact representations of the reachability graph. Such collectors are known as <i class="calibre5 pcalibre pcalibre1">conservative garbage collectors.</i> They are conservative in the sense that each reachable block is correctly identified as reachable, while some unreachable nodes might be incorrectly identified as reachable.</p>
<p id="P7000497027000000000000000046090" data-uri="chapter09.xhtml#P7000497027000000000000000046090" class="pcalibre1 pcalibre calibre2">Collectors can provide their service on demand, or they can run as separate threads in parallel with the application, continuously updating the reachability graph and reclaiming garbage. For example, consider how we might incorporate a conservative collector for C programs into an existing <code id="P7000497027000000000000000046091" data-uri="chapter09.xhtml#P7000497027000000000000000046091" class="pcalibre1 calibre8 pcalibre">malloc</code> package, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007580"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.50</span></a>.</p>
<p id="P7000497027000000000000000046092" data-uri="chapter09.xhtml#P7000497027000000000000000046092" class="pcalibre1 pcalibre calibre2">The application calls <code id="P7000497027000000000000000046093" data-uri="chapter09.xhtml#P7000497027000000000000000046093" class="pcalibre1 calibre8 pcalibre">malloc</code> in the usual manner whenever it needs heap space. If <code id="P7000497027000000000000000046094" data-uri="chapter09.xhtml#P7000497027000000000000000046094" class="pcalibre1 calibre8 pcalibre">malloc</code> is unable to find a free block that fits, then it calls the garbage collector in hopes of reclaiming some garbage to the free list. The collector identifies the garbage blocks and returns them to the heap by calling the <code id="P7000497027000000000000000046095" data-uri="chapter09.xhtml#P7000497027000000000000000046095" class="pcalibre1 calibre8 pcalibre">free</code> function. The key idea is that the collector calls free instead of the application. When the call to the collector returns, <code id="P7000497027000000000000000046096" data-uri="chapter09.xhtml#P7000497027000000000000000046096" class="pcalibre1 calibre8 pcalibre">malloc</code> tries again to find a free block that fits. If that fails, then it can ask the operating system for additional memory. Eventually, <code id="P7000497027000000000000000046097" data-uri="chapter09.xhtml#P7000497027000000000000000046097" class="pcalibre1 calibre8 pcalibre">malloc</code> returns a pointer to the requested block (if successful) or the NULL pointer (if unsuccessful).</p>
</section>
<section id="P700049702700000000000000000758E" data-uri="chapter09.xhtml#P700049702700000000000000000758E" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046098" data-uri="chapter09.xhtml#P7000497027000000000000000046098" epub:type="title"><span class="pcalibre label pcalibre1">9.10.2 </span>Mark&amp;Sweep Garbage Collectors</h1></header>
<p id="P7000497027000000000000000046099" data-uri="chapter09.xhtml#P7000497027000000000000000046099" class="pcalibre1 pcalibre calibre2">A Mark&amp;Sweep garbage collector consists of a <i class="calibre5 pcalibre pcalibre1">mark phase</i>, which marks all reachable and allocated descendants of the root nodes, followed by a <i class="calibre5 pcalibre pcalibre1">sweep phase</i>, which frees each unmarked allocated block. Typically, one of the spare low-order bits in the block header is used to indicate whether a block is marked or not.</p>
<figure id="P7000497027000000000000000007591" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007591">
<p id="P700049702700000000000000004609A" data-uri="chapter09.xhtml#P700049702700000000000000004609A" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007593" title="868" data-uri="chapter09.xhtml#P7000497027000000000000000007593" epub:type="pagebreak"></span>(a) <code id="P700049702700000000000000004609B" data-uri="chapter09.xhtml#P700049702700000000000000004609B" class="pcalibre1 calibre8 pcalibre">mark</code> function</p>
<pre id="P700049702700000000000000004609C" data-uri="chapter09.xhtml#P700049702700000000000000004609C" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004609D" data-uri="chapter09.xhtml#P700049702700000000000000004609D" class="calibre10 pcalibre pcalibre1">
void mark (ptr p) {
	if ((b = isPtr(p)) == NULL)
		return;
	if (blockMarked(b))
		return;
	markBlock(b);
	len = length(b);
	for (i=0; i &lt; len; i++)
		mark(b[i]);
	return;
}
</code></pre>
<p id="P700049702700000000000000004609E" data-uri="chapter09.xhtml#P700049702700000000000000004609E" class="pcalibre1 pcalibre calibre2">(b) <code id="P700049702700000000000000004609F" data-uri="chapter09.xhtml#P700049702700000000000000004609F" class="pcalibre1 calibre8 pcalibre">sweep</code> function</p>
<pre id="P70004970270000000000000000460A0" data-uri="chapter09.xhtml#P70004970270000000000000000460A0" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000460A1" data-uri="chapter09.xhtml#P70004970270000000000000000460A1" class="calibre10 pcalibre pcalibre1">
void sweep(ptr b, ptr end) {
	while (b &lt; end) {
		if (blockMarked(b))
			unmarkBlock(b);
		else if (blockAllocated(b))
			free(b);
		b = nextBlock(b);
	}
	return;
}
</code></pre>
<figcaption id="P70004970270000000000000000460A2" data-uri="chapter09.xhtml#P70004970270000000000000000460A2" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000460A3" data-uri="chapter09.xhtml#P70004970270000000000000000460A3" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.51 </span>Pseudocode for the <code id="P70004970270000000000000000460A4" data-uri="chapter09.xhtml#P70004970270000000000000000460A4" class="pcalibre1 calibre8 pcalibre">mark</code> and <code id="P70004970270000000000000000460A5" data-uri="chapter09.xhtml#P70004970270000000000000000460A5" class="pcalibre1 calibre8 pcalibre">sweep</code> functions.</h1></header></figcaption>
</figure>
<p id="P70004970270000000000000000460A6" data-uri="chapter09.xhtml#P70004970270000000000000000460A6" class="pcalibre1 pcalibre calibre2">Our description of Mark&amp;Sweep will assume the following functions, where <code id="P70004970270000000000000000460A7" data-uri="chapter09.xhtml#P70004970270000000000000000460A7" class="pcalibre1 calibre8 pcalibre">ptr</code> is defined as <code id="P70004970270000000000000000460A8" data-uri="chapter09.xhtml#P70004970270000000000000000460A8" class="pcalibre1 calibre8 pcalibre">typedef void *ptr</code>:</p>
<ul class="pcalibre ul_none pcalibre1" id="P70004970270000000000000000460A9" data-uri="chapter09.xhtml#P70004970270000000000000000460A9">
<li id="P70004970270000000000000000460AA" data-uri="chapter09.xhtml#P70004970270000000000000000460AA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460AB" data-uri="chapter09.xhtml#P70004970270000000000000000460AB" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><code id="P70004970270000000000000000460AC" data-uri="chapter09.xhtml#P70004970270000000000000000460AC" class="pcalibre1 calibre8 pcalibre">ptr isPtr (ptr p).</code> </span>If <code id="P70004970270000000000000000460AD" data-uri="chapter09.xhtml#P70004970270000000000000000460AD" class="pcalibre1 calibre8 pcalibre">p</code> points to some word in an allocated block, it returns a pointer <code id="P70004970270000000000000000460AE" data-uri="chapter09.xhtml#P70004970270000000000000000460AE" class="pcalibre1 calibre8 pcalibre">b</code> to the beginning of that block. Returns NULL otherwise.</p></li>
<li id="P70004970270000000000000000460AF" data-uri="chapter09.xhtml#P70004970270000000000000000460AF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460B0" data-uri="chapter09.xhtml#P70004970270000000000000000460B0" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><code id="P70004970270000000000000000460B1" data-uri="chapter09.xhtml#P70004970270000000000000000460B1" class="pcalibre1 calibre8 pcalibre">int blockMarked(ptr b)</code>. </span>Returns true if block <code id="P70004970270000000000000000460B2" data-uri="chapter09.xhtml#P70004970270000000000000000460B2" class="pcalibre1 calibre8 pcalibre">b</code> is already marked.</p></li>
<li id="P70004970270000000000000000460B3" data-uri="chapter09.xhtml#P70004970270000000000000000460B3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460B4" data-uri="chapter09.xhtml#P70004970270000000000000000460B4" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><code id="P70004970270000000000000000460B5" data-uri="chapter09.xhtml#P70004970270000000000000000460B5" class="pcalibre1 calibre8 pcalibre">int blockAllocated(ptr b)</code>. </span>Returns true if block <code id="P70004970270000000000000000460B6" data-uri="chapter09.xhtml#P70004970270000000000000000460B6" class="pcalibre1 calibre8 pcalibre">b</code> is allocated.</p></li>
<li id="P70004970270000000000000000460B7" data-uri="chapter09.xhtml#P70004970270000000000000000460B7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460B8" data-uri="chapter09.xhtml#P70004970270000000000000000460B8" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><code id="P70004970270000000000000000460B9" data-uri="chapter09.xhtml#P70004970270000000000000000460B9" class="pcalibre1 calibre8 pcalibre">void markBlock(ptr b)</code>. </span>Marks block <code id="P70004970270000000000000000460BA" data-uri="chapter09.xhtml#P70004970270000000000000000460BA" class="pcalibre1 calibre8 pcalibre">b</code>.</p></li>
<li id="P70004970270000000000000000460BB" data-uri="chapter09.xhtml#P70004970270000000000000000460BB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460BC" data-uri="chapter09.xhtml#P70004970270000000000000000460BC" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><code id="P70004970270000000000000000460BD" data-uri="chapter09.xhtml#P70004970270000000000000000460BD" class="pcalibre1 calibre8 pcalibre">int length (ptr b)</code>. </span>Returns the length in words (excluding the header) of block <code id="P70004970270000000000000000460BE" data-uri="chapter09.xhtml#P70004970270000000000000000460BE" class="pcalibre1 calibre8 pcalibre">b</code>.</p></li>
<li id="P70004970270000000000000000460BF" data-uri="chapter09.xhtml#P70004970270000000000000000460BF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460C0" data-uri="chapter09.xhtml#P70004970270000000000000000460C0" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><code id="P70004970270000000000000000460C1" data-uri="chapter09.xhtml#P70004970270000000000000000460C1" class="pcalibre1 calibre8 pcalibre">void unmarkBlock (ptr b)</code>. </span>Changes the status of block <code id="P70004970270000000000000000460C2" data-uri="chapter09.xhtml#P70004970270000000000000000460C2" class="pcalibre1 calibre8 pcalibre">b</code> from marked to unmarked.</p></li>
<li id="P70004970270000000000000000460C3" data-uri="chapter09.xhtml#P70004970270000000000000000460C3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460C4" data-uri="chapter09.xhtml#P70004970270000000000000000460C4" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><code id="P70004970270000000000000000460C5" data-uri="chapter09.xhtml#P70004970270000000000000000460C5" class="pcalibre1 calibre8 pcalibre">ptr nextBlock(ptr b)</code>. </span>Returns the successor of block <var class="calibre5 pcalibre pcalibre1">b</var> in the heap.</p></li>
</ul>
<p id="P70004970270000000000000000460C6" data-uri="chapter09.xhtml#P70004970270000000000000000460C6" class="pcalibre1 pcalibre calibre2">The mark phase calls the mark function shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007591"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.51(a)</span></a> once for each root node. The <code id="P70004970270000000000000000460C7" data-uri="chapter09.xhtml#P70004970270000000000000000460C7" class="pcalibre1 calibre8 pcalibre">mark</code> function returns immediately if <code id="P70004970270000000000000000460C8" data-uri="chapter09.xhtml#P70004970270000000000000000460C8" class="pcalibre1 calibre8 pcalibre">p</code> does not point to an allocated and unmarked heap block. Otherwise, it marks the block and calls itself recursively on each word in block. Each call to the <code id="P70004970270000000000000000460C9" data-uri="chapter09.xhtml#P70004970270000000000000000460C9" class="pcalibre1 calibre8 pcalibre">mark</code> function marks any unmarked and reachable descendants of some root node. At the end of the mark phase, any allocated block that is not marked is guaranteed to be unreachable and, hence, garbage that can be reclaimed in the sweep phase.</p>
<p id="P70004970270000000000000000460CA" data-uri="chapter09.xhtml#P70004970270000000000000000460CA" class="pcalibre1 pcalibre calibre2">The sweep phase is a single call to the sweep function shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007591"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.51(b)</span></a>. The <code id="P70004970270000000000000000460CB" data-uri="chapter09.xhtml#P70004970270000000000000000460CB" class="pcalibre1 calibre8 pcalibre">sweep</code> function iterates over each block in the heap, freeing any unmarked allocated blocks (i.e., garbage) that it encounters.</p>
<p id="P70004970270000000000000000460CC" data-uri="chapter09.xhtml#P70004970270000000000000000460CC" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000075C6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.52</span></a> shows a graphical interpretation of Mark&amp;Sweep for a small heap. Block boundaries are indicated by heavy lines. Each square corresponds to a word of memory. Each block has a one-word header, which is either marked or unmarked.</p>
<figure id="P70004970270000000000000000075C6" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000075C6">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000075C7" title="869" data-uri="chapter09.xhtml#P70004970270000000000000000075C7" epub:type="pagebreak"></span>
<img alt="A diagram illustrates mark&amp;sweep." id="P70004970270000000000000000460CD" data-uri="P700049702700000000000000000B7A9" src="../images/p869-1.png" class="pcalibre1 pcalibre calibre303"/>
<figcaption id="P70004970270000000000000000460CE" data-uri="chapter09.xhtml#P70004970270000000000000000460CE" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000460CF" data-uri="chapter09.xhtml#P70004970270000000000000000460CF" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.52 </span>Mark&amp;Sweep example.</h1></header><div class="edition pcalibre pcalibre1" id="P70004970270000000000000000460D0" data-uri="chapter09.xhtml#P70004970270000000000000000460D0"><p id="P70004970270000000000000000460D1" data-uri="chapter09.xhtml#P70004970270000000000000000460D1" class="pcalibre calibre3 pcalibre1">Note that the arrows in this example denote memory references, not free list pointers.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P700049702700000000000000002642B" data-uri="chapter09.xhtml#P700049702700000000000000002642B">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000460D2" data-uri="chapter09.xhtml#P70004970270000000000000000460D2" class="pcalibre1 pcalibre calibre2">A diagram of a mark&amp;sweep example has three rows of 16 blocks each, with arrows and labels summarized below.</p>
<ul id="P70004970270000000000000000460D3" data-uri="chapter09.xhtml#P70004970270000000000000000460D3" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000460D4" data-uri="chapter09.xhtml#P70004970270000000000000000460D4" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460D5" data-uri="chapter09.xhtml#P70004970270000000000000000460D5" class="pcalibre calibre3 pcalibre1">Before mark: unmarked block headers 1 through 4 are separated by blank blocks, followed by the root block. Unmarked block header 5 is second from the root, followed by three blank blocks and unmarked block header 6. Arrows point from root to the end of block 3; from block before block 4 to end of block 1; from block after root to end of block 6</p></li>
<li id="P70004970270000000000000000460D6" data-uri="chapter09.xhtml#P70004970270000000000000000460D6" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460D7" data-uri="chapter09.xhtml#P70004970270000000000000000460D7" class="pcalibre calibre3 pcalibre1">After mark: blocks 1, 3, 4, and 6 are now marked block headers</p></li>
<li id="P70004970270000000000000000460D8" data-uri="chapter09.xhtml#P70004970270000000000000000460D8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000460D9" data-uri="chapter09.xhtml#P70004970270000000000000000460D9" class="pcalibre calibre3 pcalibre1">After sweep: the third and fourth blocks, as well as marked blocks 5 to 6 are now free unmarked block headers.</p></li>
</ul>
</details>
</figcaption>
</figure>
<figure id="P70004970270000000000000000075CD" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000075CD">
<img alt="A diagram shows an allocated block header followed by the remainder of the block. The allocated block header contains size, left and right, with an arrow from left labeled &lt; and an arrow from right labeled &gt;." id="P70004970270000000000000000460DA" data-uri="P700049702700000000000000000B7AA" src="../images/p869-2.png" class="calibre304 pcalibre pcalibre1"/>
<figcaption id="P70004970270000000000000000460DB" data-uri="chapter09.xhtml#P70004970270000000000000000460DB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000460DC" data-uri="chapter09.xhtml#P70004970270000000000000000460DC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.53 </span>Left and right pointers in a balanced tree of allocated blocks.</h1></header></figcaption>
</figure>
<p id="P70004970270000000000000000460DD" data-uri="chapter09.xhtml#P70004970270000000000000000460DD" class="pcalibre1 pcalibre calibre2">Initially, the heap in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000075C6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.52</span></a> consists of six allocated blocks, each of which is unmarked. Block 3 contains a pointer to block 1. Block 4 contains pointers to blocks 3 and 6. The root points to block 4. After the mark phase, blocks 1,3,4, and 6 are marked because they are reachable from the root. Blocks 2 and 5 are unmarked because they are unreachable. After the sweep phase, the two unreachable blocks are reclaimed to the free list.</p>
</section>
<section id="P70004970270000000000000000075D2" data-uri="chapter09.xhtml#P70004970270000000000000000075D2" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000460DE" data-uri="chapter09.xhtml#P70004970270000000000000000460DE" epub:type="title"><span class="pcalibre label pcalibre1">9.10.3 </span>Conservative Mark&amp;Sweep for C Programs</h1></header>
<p id="P70004970270000000000000000460DF" data-uri="chapter09.xhtml#P70004970270000000000000000460DF" class="pcalibre1 pcalibre calibre2">Mark&amp;Sweep is an appropriate approach for garbage collecting C programs because it works in place without moving any blocks. However, the C language poses some interesting challenges for the implementation of the <code id="P70004970270000000000000000460E0" data-uri="chapter09.xhtml#P70004970270000000000000000460E0" class="pcalibre1 calibre8 pcalibre">isPtr</code> function.</p>
<p id="P70004970270000000000000000460E1" data-uri="chapter09.xhtml#P70004970270000000000000000460E1" class="pcalibre1 pcalibre calibre2">First, C does not tag memory locations with any type information. Thus, there is no obvious way for <code id="P70004970270000000000000000460E2" data-uri="chapter09.xhtml#P70004970270000000000000000460E2" class="pcalibre1 calibre8 pcalibre">isPtr</code> to determine if its input parameter <code id="P70004970270000000000000000460E3" data-uri="chapter09.xhtml#P70004970270000000000000000460E3" class="pcalibre1 calibre8 pcalibre">p</code> is a pointer or not. Second, even if we were to know that <code id="P70004970270000000000000000460E4" data-uri="chapter09.xhtml#P70004970270000000000000000460E4" class="pcalibre1 calibre8 pcalibre">p</code> was a pointer, there would be no obvious way for <code id="P70004970270000000000000000460E5" data-uri="chapter09.xhtml#P70004970270000000000000000460E5" class="pcalibre1 calibre8 pcalibre">isPtr</code> to determine whether <code id="P70004970270000000000000000460E6" data-uri="chapter09.xhtml#P70004970270000000000000000460E6" class="pcalibre1 calibre8 pcalibre">p</code> points to some location in the payload of an allocated block.</p>
<p id="P70004970270000000000000000460E7" data-uri="chapter09.xhtml#P70004970270000000000000000460E7" class="pcalibre1 pcalibre calibre2">One solution to the latter problem is to maintain the set of allocated blocks as a balanced binary tree that maintains the invariant that all blocks in the left subtree are located at smaller addresses and all blocks in the right subtree are located in larger addresses. As shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000075CD"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.53</span></a>, this requires two additional fields (<code id="P70004970270000000000000000460E8" data-uri="chapter09.xhtml#P70004970270000000000000000460E8" class="pcalibre1 calibre8 pcalibre">left</code> and <code id="P70004970270000000000000000460E9" data-uri="chapter09.xhtml#P70004970270000000000000000460E9" class="pcalibre1 calibre8 pcalibre">right</code>) in the header of each allocated block. Each field points to the header of some allocated block. The <code id="P70004970270000000000000000460EA" data-uri="chapter09.xhtml#P70004970270000000000000000460EA" class="pcalibre1 calibre8 pcalibre">isPtr (ptr p)</code> function uses the tree to perform a binary search of the allocated blocks. At each step, it relies on the size field in the block header to determine if <code id="P70004970270000000000000000460EB" data-uri="chapter09.xhtml#P70004970270000000000000000460EB" class="pcalibre1 calibre8 pcalibre">p</code> falls within the extent of the block.</p>
<p id="P70004970270000000000000000460EC" data-uri="chapter09.xhtml#P70004970270000000000000000460EC" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000075E2" title="870" data-uri="chapter09.xhtml#P70004970270000000000000000075E2" epub:type="pagebreak"></span>The balanced tree approach is correct in the sense that it is guaranteed to mark all of the nodes that are reachable from the roots. This is a necessary guarantee, as application users would certainly not appreciate having their allocated blocks prematurely returned to the free list. However, it is conservative in the sense that it may incorrectly mark blocks that are actually unreachable, and thus it may fail to free some garbage. While this does not affect the correctness of application programs, it can result in unnecessary external fragmentation.</p>
<p id="P70004970270000000000000000460ED" data-uri="chapter09.xhtml#P70004970270000000000000000460ED" class="pcalibre1 pcalibre calibre2">The fundamental reason that Mark&amp;Sweep collectors for C programs must be conservative is that the C language does not tag memory locations with type information. Thus, scalars like <code id="P70004970270000000000000000460EE" data-uri="chapter09.xhtml#P70004970270000000000000000460EE" class="pcalibre1 calibre8 pcalibre">ints</code> or <code id="P70004970270000000000000000460EF" data-uri="chapter09.xhtml#P70004970270000000000000000460EF" class="pcalibre1 calibre8 pcalibre">floats</code> can masquerade as pointers. For example, suppose that some reachable allocated block contains an <code id="P70004970270000000000000000460F0" data-uri="chapter09.xhtml#P70004970270000000000000000460F0" class="pcalibre1 calibre8 pcalibre">int</code> in its payload whose value happens to correspond to an address in the payload of some other allocated block <i class="calibre5 pcalibre pcalibre1">b.</i> There is no way for the collector to infer that the data is really an <code id="P70004970270000000000000000460F1" data-uri="chapter09.xhtml#P70004970270000000000000000460F1" class="pcalibre1 calibre8 pcalibre">int</code> and not a pointer. Therefore, the allocator must conservatively mark block <var class="calibre5 pcalibre pcalibre1">b</var> as reachable, when in fact it might not be.</p>
</section>
</section></body></html>
