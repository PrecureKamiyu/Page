<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>4.3   Transactions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part104.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part106.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">4.3   <span style=" color: #00AEEF;">Transactions</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">A <span class="s63">transaction </span>consists of a sequence of query and/or update statements. The <span class="s44">SQL </span>stan- dard speciﬁes that a transaction begins implicitly when an <span class="s44">SQL </span>statement is executed. One of the following <span class="s44">SQL </span>statements must end the transaction:</p><p class="s39" style="padding-top: 10pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Commit work </span><span class="p">commits the current transaction; that is, it makes the updates per- formed by the transaction become permanent in the database. After the transac- tion is committed, a new transaction is automatically started.</span></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Rollback work </span>causes the current transaction to be rolled back; that is, it undoes all the updates performed by the <span class="s44">SQL </span>statements in the transaction. Thus, the database state is restored to what it was before the ﬁrst statement of the transaction was executed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">The keyword <b>work </b>is optional in both the statements.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Transaction rollback is useful if some error condition is detected during execution of a transaction. Commit is similar, in a sense, to saving changes to a document that is being edited, while rollback is similar to quitting the edit session without saving</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">changes. Once a transaction has executed <b>commit work</b>, its eﬀects can no longer be undone by <b>rollback work</b>. The database system guarantees that in the event of some failure, such as an error in one of the <span class="s44">SQL </span>statements, a power outage, or a system crash, a transaction’s eﬀects will be rolled back if it has not yet executed <b>commit work</b>. In the case of power outage or other system crash, the rollback occurs when the system restarts.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">For instance, consider a banking application where we need to transfer money from one bank account to another in the same bank. To do so, we need to update two account balances, subtracting the amount transferred from one, and adding it to the other. If the system crashes after subtracting the amount from the ﬁrst account but before adding it to the second account, the bank balances will be inconsistent. A similar problem occurs if the second account is credited before subtracting the amount from the ﬁrst account and the system crashes just after crediting the amount.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_718.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As another example, consider our running example of a university application. We assume that the attribute <i>tot cred </i>of each tuple in the <i>student </i>relation is kept up-to- date by modifying it whenever the student successfully completes a course. To do so, whenever the <i>takes </i>relation is updated to record successful completion of a course by a student (by assigning an appropriate grade), the corresponding <i>student </i>tuple must also be updated. If the application performing these two updates crashes after one update is performed, but before the second one is performed, the data in the database will be inconsistent.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">By either committing the actions of a transaction after all its steps are completed, or rolling back all its actions in case the transaction could not complete all its actions successfully, the database provides an abstraction of a transaction as being <span class="s63">atomic</span>, that is, indivisible. Either all the eﬀects of the transaction are reﬂected in the database or none are (after rollback).</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Applying the notion of transactions to the above applications, the update state- ments should be executed as a single transaction. An error while a transaction executes one of its statements would result in undoing the eﬀects of the earlier statements of the transaction so that the database is not left in a partially updated state.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If a program terminates without executing either of these commands, the updates are either committed or rolled back. The standard does not specify which of the two happens, and the choice is implementation dependent.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In many <span class="s44">SQL </span>implementations, including <span class="s44">M</span>y<span class="s44">SQL </span>and <span class="s44">P</span>ostgre<span class="s44">SQL</span>, by default each <span class="s44">SQL </span>statement is taken to be a transaction on its own, and it gets committed as soon as it is executed. Such <i>automatic commit </i>of individual <span class="s44">SQL </span>statements must be turned oﬀ if a transaction consisting of multiple <span class="s44">SQL </span>statements needs to be executed. How to turn oﬀ automatic commit depends on the speciﬁc <span class="s44">SQL </span>implementation, although many databases support the command <b>set autocommit oﬀ</b>.<span class="s76">6</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_719.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;"><span class="s77">6</span>There is a standard way of turning autocommit on or oﬀ when using application program interfaces such as <span class="s153">JDBC </span>or</p><p class="s177" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">ODBC<span class="s178">, which we study in Section 5.1.1 and Section 5.1.3, respectively.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;"><a name="bookmark61">A better alternative, which is part of the </a><span class="s44">SQL:1999 </span>standard is to allow multiple <span class="s44">SQL </span>statements to be enclosed between the keywords <b>begin atomic </b><span class="s15">… </span><b>end</b>. All the statements between the keywords then form a single transaction, which is committed by default if execution reaches the <b>end </b>statement. Only some databases, such as <span class="s44">SQL S</span>erver, support the above syntax. However, several other databases, such as <span class="s44">M</span>y<span class="s44">SQL </span>and <span class="s44">P</span>ostgre<span class="s44">SQL</span>, support a <b>begin </b>statement which starts a transaction containing all subsequent <span class="s44">SQL </span>statements, but do not support the <b>end </b>statement; instead, the transaction must be ended by either a <b>commit work </b>or a <b>rollback work </b>command.<a name="bookmark102">&zwnj;</a></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If you use a database such as Oracle, where the automatic commit is not the default for <span class="s44">DML </span>statements, be sure to issue a <b>commit </b>command after adding or modifying data, or else when you disconnect, all your database modiﬁcations will be rolled back!<span class="s76">7</span> You should be aware that although Oracle has automatic commit turned oﬀ by default, that default may be overridden by local conﬁguration settings.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We study further properties of transactions in Chapter 17; issues in implementing transactions are addressed in Chapter 18 and Chapter 19.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part104.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part106.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
