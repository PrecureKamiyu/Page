<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>10.6  Graph Databases</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part207.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part209.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">10.6  <span style=" color: #00AEEF;">Graph Databases</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Graphs are an important type of data that databases need to deal with. For example, a computer network with multiple routers and links between them can be modeled as a graph, with routers as nodes and network links as edges. Road networks are another common type of graph, with road intersections modeled as nodes and the road links between intersections as edges. Web pages with hyperlinks between them are yet an- other example of graphs, where web pages can be modeled as nodes and hyperlinks between them as edges.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In fact, if we consider an <span class="s44">E-R </span>model of an enterprise, every entity can be modeled as a node of a graph, and every binary relationship can be modeled as an edge of the graph. Ternary and higher-degree relationships are harder to model, but as we saw in Section 6.9.4, such relationships can be modeled as a set of binary relationships if desired.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Graphs can be represented using the relational model using the following two re- lations:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2361.png"/></span></p><p class="s63" style="padding-top: 6pt;padding-left: 97pt;text-indent: 0pt;text-align: justify;">1. <span class="p">node(ID, label, node data)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2362.png"/></span></p><p class="s63" style="padding-top: 6pt;padding-left: 96pt;text-indent: 0pt;text-align: justify;">2. <span class="p">edge(fromID, toID, label, edge data)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2363.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2364.png"/></span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">where node data and edge data contain all the data related to nodes and edges, respec- tively.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2365.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">3<span class="s78">Some systems generate timestamps based on when the window is processed, but doing so results in output timestamps that are nondeterministic.</span></p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">10.6 <span style=" color: #00AEEF;">Graph Databases  </span><span class="s164">509</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Modeling a graph using just two relations is too simplistic for complex database schemas. For example, applications require modeling of many types of nodes, each with its own set of attributes, and many types of edges, each with its own set of attributes. We can correspondingly have multiple relations that store nodes of diﬀerent types and multiple relations that store edges of diﬀerent types.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Although graph data can be easily stored in relational databases, graph databases such as the widely used Neo4j provide several extra features:</p><p class="s39" style="padding-top: 10pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s40">They allow relations to be identiﬁed as representing nodes or edges and oﬀer spe- cial syntax for deﬁning such relations</span></p><p class="s40" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: left;"><span class="s39">• </span>They support query languages designed for easily expressing path queries, which may be harder to express in <span class="s41">SQL</span>.</p><p class="s40" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: left;"><span class="s39">• </span>They provide eﬃcient implementations for such queries, which can execute queries much faster than if they were expressed in <span class="s41">SQL </span>and executed on a regular database.</p><p class="s39" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: left;">• <span class="s40">They provide support for other features such as graph visualization.</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">As an example of a graph query, we consider a query in the Cypher query language supported by Neo4j. Suppose the input graph has nodes corresponding to students (stored in a relation <i>student</i>) and instructors (stored in a relation <i>instructor</i>, and an edge type <i>advisor </i>from <i>student </i>to <i>instructor</i>. We omit details of how to create such node and edge types in Neo4j and assume appropriate schemas for these types. We can then write the following query:</p><p style="padding-top: 8pt;padding-left: 172pt;text-indent: 0pt;line-height: 19pt;text-align: left;"><b>match </b>(<i>i</i>:<i>instructor</i>)<span class="s83">&lt;</span><span class="s15">−</span>[:<i>advisor</i>]<span class="s15">−</span>(<i>s</i>:<i>student</i>)</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2366.png"/></span></p><p class="s13" style="padding-left: 172pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><b>where </b>i<span class="p">.</span>dept name<span class="p">= &#39;Comp. Sci.&#39;</span></p><p class="s13" style="padding-left: 172pt;text-indent: 0pt;text-align: left;"><b>return </b>i<span class="p">.</span><span class="s44">ID </span><b>as </b><span class="s42">ID</span><span class="s43">, </span>i<span class="p">.</span>name <b>as </b>name<span class="p">, </span><b>collect</b><span class="p">(</span>s<span class="p">.</span>name<span class="p">) </span><b>as </b>advisees</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Observe that the <b>match </b>clause in the query connects instructors to students via the advisor relation, which is modeled as a graph path that traverses the advisor edge in the backwards direction (the edge points from student to instructor), by using the syn-</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 70%;text-align: justify;">tax (<i>i</i>:<i>instructor</i>)<span class="s83">&lt;</span><span class="s15">−</span>[:<i>advisor</i>]<span class="s15">−</span>(<i>s</i>:<i>student</i>). This step basically performs a join of the instructor, advisor and student relations. The query then performs a group by on in-</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">structor ID and name, and collects all the students advised by the instructor into a set called advisees. We omit details, and refer the interested reader to online tutorials available at <span class="s49">neo4j.com/developer</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2367.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2368.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Neo4J also supports recursive traversal of edges. For example, suppose we wish to ﬁnd direct and indirect prerequisites of courses, with the relation <i>course </i>modeled with type node, and relation <i>prereq</i>(<i>course id, prereq id</i>) modeled with type edge. We can then write the following query:</p><p style="padding-top: 8pt;padding-left: 205pt;text-indent: 0pt;line-height: 19pt;text-align: left;"><b>match </b>(<i>c1</i>:<i>course</i>)<span class="s15">−</span>[:<i>prereq </i>*1..]<span class="s15">−</span><span class="s83">&gt;</span>(<i>c</i>2:<i>course</i>)</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2369.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2370.png"/></span></p><p class="s13" style="padding-left: 205pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><b>return </b>c<span class="p">1.</span>course id<span class="p">, </span>c<span class="p">2.</span>course id</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Here, the annotation “*1..” indicates we want to consider paths with multiple <i>prereq </i>edges, with a minimum of 1 edge (with a minimum of 0, a course would appear as its own prerequisite).</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We note that Neo4j is a centralized system and does not (as of 2018) support parallel processing. However, there are many applications that need to process very large graphs, and parallel processing is key for such applications.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Computation of PageRank (which we saw earlier in Section 8.3.2.2) on very large graphs containing a node for every web page, and an edge for every hyperlink from one page to another, is a good example of a complex computation on very large graphs. The web graph today has hundreds of billions of nodes and trillions of edges. Social networks are another example of very large graphs, containing billions of nodes and edges; computations on such graphs include shortest paths (to ﬁnd connectivity be- tween people), or computing how inﬂuential people are based on edges in the social network.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">There are two popular approaches for parallel graph processing:</p><p class="s63" style="padding-top: 7pt;padding-left: 113pt;text-indent: -16pt;text-align: justify;">1. <span style=" color: #231F20;">Map-reduce and algebraic frameworks</span><span class="p">: Graphs can be represented as relations, and individual steps of many parallel graph algorithms can be represented as joins. Graphs can thus be stored in a parallel storage system, partitioned across multiple machines. We can then use map-reduce programs, algebraic frameworks such as Spark, or parallel relational database implementations to process each step of a graph algorithm in parallel across multiple nodes.</span></p><p style="padding-left: 113pt;text-indent: 13pt;text-align: justify;">Such approaches work well for many applications. However, when performing iterative computations that traverse long paths in graphs, these approaches are quite ineﬃcient, since they typically read the entire graph in each iteration.</p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;"><span class="s63">2.  </span><b>Bulk synchronous processing frameworks</b>: The <span class="s63">bulk synchronous processing </span>(<span class="s64">BSP</span>) framework for graph algorithms frames graph algorithms as computations asso- ciated with vertices that operate in an iterative manner. Unlike the preceding approach, here the graph is typically stored in memory, with vertices partitioned across multiple machines; most importantly, the graph does not have to be read in each iteration.</p><p style="padding-left: 113pt;text-indent: 15pt;text-align: justify;">Each vertex (node) of the graph has data (state) associated with it. Similar to how programmers provide <span class="s49">map() </span>and <span class="s49">reduce() </span>functions in the MapReduce framework, in the <span class="s44">BSP </span>framework programmers provide methods that are exe- cuted for each node of the graph. The methods can send messages to neighboring nodes and receive messages from neighboring nodes of the graph. In each iter- ation, called a <span class="s63">superstep</span>, the method associated with each node is executed; the method consumes any incoming messages, updates the data associated with the node, and may optionally send messages to neighboring nodes. Messages sent in one iteration are received by the recipients in the next iteration. The method executing at each vertex may vote to halt if they decide they have no more compu- tation to carry out. If in some iteration all vertices vote to halt, and no messages are sent out, the computation can be halted.</p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;"><a name="bookmark225">10.7 </a><span style=" color: #00AEEF;">Summary  </span><span class="s164">511</span><a name="bookmark243">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;">The result of the computation is contained in the state at each node. The state can be collected and output as the result of the computation.</p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The idea of bulk synchronous processing is quite old but was popularized by the <i>Pregel </i>system developed by Google, which provided a fault-tolerant implementation of the framework. The <i>Apache Giraph </i>system is an open-source version of the Pregel system.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The GraphX component of Apache Spark supports graph computations on large graphs. It provides an <span class="s44">API </span>based on Pregel, as well as a number of other operations that take a graph as input, and output a graph. Operations supported by GraphX include map functions applied on vertices and edges of graphs, join of a graph with an <span class="s44">RDD</span>, and an aggregation operation that works as follows: a user-deﬁned function is used to create messages that are sent to all the neighbors of each node, and another user- deﬁned function is used to aggregate the messages. All these operations can be executed in parallel to handle large graphs.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For more information on how to write graph algorithms in such settings, see the references in the Further Reading section at the end of the chapter.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part207.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part209.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
