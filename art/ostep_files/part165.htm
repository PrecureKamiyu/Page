<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Splitting and Coalescing</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part164.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part166.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Splitting and Coalescing</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">A free list contains a set of elements that describe the free space still re- maining in the heap. Thus, assume the following 30-byte heap:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:120.223pt" cellspacing="0"><tr style="height:10pt"><td style="width:43pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s96" style="padding-left: 14pt;padding-right: 14pt;text-indent: 0pt;line-height: 8pt;text-align: center;">free</p></td><td style="width:43pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#D3D3D3"><p class="s96" style="padding-left: 13pt;text-indent: 0pt;line-height: 8pt;text-align: left;">used</p></td><td style="width:44pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p class="s96" style="padding-left: 14pt;padding-right: 14pt;text-indent: 0pt;line-height: 8pt;text-align: center;">free</p></td></tr></table><p class="s46" style="padding-left: 118pt;text-indent: 0pt;text-align: left;">0      10      20      30</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The free list for this heap would have two elements on it. One entry de- scribes the first 10-byte free segment (bytes 0-9), and one entry describes the other free segment (bytes 20-29):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="148" height="42" alt="image" src="Image_161.png"/></span></p><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">addr:0</p><p class="s47" style="text-indent: 0pt;line-height: 8pt;text-align: left;">len:10</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">addr:20</p><p class="s47" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">len:10</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">head                NULL</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As described above, a request for anything greater than 10 bytes will fail (returning NULL); there just isn’t a single contiguous chunk of mem- ory of that size available. A request for exactly that size (10 bytes) could be satisfied easily by either of the free chunks. But what happens if the request is for something <i>smaller </i>than 10 bytes?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Assume we have a request for just a single byte of memory. In this case, the allocator will perform an action known as <b>splitting</b>: it will find</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_162.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 92%;text-align: justify;">2<span class="s12">Once you hand a pointer to a chunk of memory to a C program, it is generally difficult to determine all references (pointers) to that region, which may be stored in other variables or even in registers at a given point in execution. This may not be the case in more strongly- typed, garbage-collected languages, which would thus enable compaction as a technique to combat fragmentation.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">a free chunk of memory that can satisfy the request and split it into two. The first chunk it will return to the caller; the second chunk will remain on the list. Thus, in our example above, if a request for 1 byte were made, and the allocator decided to use the second of the two elements on the list to satisfy the request, the call to malloc() would return 20 (the address of the 1-byte allocated region) and the list would end up looking like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="148" height="42" alt="image" src="Image_163.png"/></span></p><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">addr:0</p><p class="s47" style="text-indent: 0pt;line-height: 8pt;text-align: left;">len:10</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">addr:21</p><p class="s47" style="padding-left: 4pt;text-indent: 0pt;line-height: 8pt;text-align: left;">len:9</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">head                NULL</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 93%;text-align: justify;">In the picture, you can see the list basically stays intact; the only change is that the free region now starts at 21 instead of 20, and the length of that free region is now just 9<span class="s35">3</span>. Thus, the split is commonly used in allocators when requests are smaller than the size of any particular free chunk.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">A corollary mechanism found in many allocators is known as <b>coalesc- ing </b>of free space. Take our example from above once more (free 10 bytes, used 10 bytes, and another free 10 bytes).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">Given this (tiny) heap, what happens when an application calls free(10), thus returning the space in the middle of the heap? If we simply add this free space back into our list without too much thinking, we might end up with a list that looks like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="211" height="42" alt="image" src="Image_164.png"/></span></p><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">addr:10</p><p class="s47" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">len:10</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">addr:0</p><p class="s47" style="text-indent: 0pt;line-height: 8pt;text-align: left;">len:10</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">addr:20</p><p class="s47" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">len:10</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">head                       NULL</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Note the problem: while the entire heap is now free, it is seemingly divided into three chunks of 10 bytes each. Thus, if a user requests 20 bytes, a simple list traversal will not find such a free chunk, and return failure.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">What allocators do in order to avoid this problem is coalesce free space when a chunk of memory is freed. The idea is simple: when returning a free chunk in memory, look carefully at the addresses of the chunk you are returning as well as the nearby chunks of free space; if the newly- freed space sits right next to one (or two, as in this example) existing free chunks, merge them into a single larger free chunk. Thus, with coalesc- ing, our final list should look like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="85" height="42" alt="image" src="Image_165.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 21pt;text-indent: 0pt;text-align: center;">addr:0 len:30</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 86pt;text-indent: 0pt;text-align: left;">head          NULL</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Indeed, this is what the heap list looked like at first, before any allo- cations were made. With coalescing, an allocator can better ensure that large free extents are available for the application.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_166.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: justify;">3<span class="s12">This discussion assumes that there are no headers, an unrealistic but simplifying assump- tion we make for now.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">ptr</p><p class="s67" style="padding-top: 3pt;padding-left: 109pt;text-indent: 0pt;text-align: left;">The header used by malloc library</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 4pt;text-indent: 0pt;line-height: 5pt;text-align: left;"><span><img width="25" height="7" alt="image" src="Image_167.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="104" height="115" alt="image" src="Image_168.png"/></span></p><p class="s67" style="padding-left: 109pt;text-indent: 0pt;text-align: left;">The 20 bytes returned to caller</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">Figure 17.1: <b>An Allocated Region Plus Header</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="91" height="23" alt="image" src="Image_169.png"/></span></p><p class="s67" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">magic: 1234567</p><p style="text-indent: 0pt;text-align: left;"/><p class="s67" style="text-indent: 0pt;line-height: 8pt;text-align: left;">20</p><p style="text-indent: 0pt;text-align: left;"/><p class="s67" style="text-indent: 0pt;line-height: 8pt;text-align: left;">size:</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="25" height="7" alt="image" src="Image_170.png"/></span></p><p class="s67" style="padding-top: 3pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">hptr</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="25" height="7" alt="image" src="Image_171.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="104" height="70" alt="image" src="Image_172.png"/></span></p><p class="s67" style="padding-left: 63pt;text-indent: 0pt;text-align: left;">ptr</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-top: 6pt;padding-left: 184pt;text-indent: 0pt;text-align: left;">The 20 bytes returned to caller</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 93pt;text-indent: 0pt;text-align: left;">Figure 17.2: <b>Specific Contents Of The Header</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part164.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part166.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
