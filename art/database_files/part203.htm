<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>10.1  Motivation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part202.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part204.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">10.1  <span style=" color: #00AEEF;">Motivation</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The growth of the World Wide Web in the 1990s and 2000s resulted in the need to store and query data with volumes that far exceeded the enterprise data that relational databases were designed to manage. Although much of the user-visible data on the web in the early days was static, web sites generated a very large amount of data about users who visited their sites, what web pages they accessed, and when. These data were typi- cally stored on log ﬁles on the web server, in textual form. People managing web sites soon realized that there was a wealth of information in the web logs that could be used by companies to understand more about their users and to target advertisements and marketing campaigns at users. Such information included details of which pages had been accessed by users, which could also be linked with user proﬁle data, such as age, gender, income level, and so on, that were collected by many web sites. Transactional web sites such as shopping sites had other kinds of data as well, such as what prod- ucts a user had browsed or purchased. The 2000s saw exceptionally large growth in the volume of user-generated data, in particular social-media data.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The volume of such data soon grew well beyond the scale that could be handled by traditional database systems, and both storage and processing require a very high degree of parallelism. Furthermore, much of the data were in textual form such as log records, or in other semi-structured forms that we saw in Chapter 8. Such data, are characterized by their size, speed at which they are generated, and the variety of formats, are generically called Big Data.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">467</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Big Data has been contrasted with traditional relational databases on the following metrics:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Volume</span><span class="p">: The amount of data to be stored and processed is much larger than tradi- tional databases, including traditional parallel relational databases, were designed to handle. Although there is a long history of parallel database systems, early gen- eration parallel databases were designed to work on tens to a few hundreds of machines. In contrast, some of the new applications require the use of thousands of machines in parallel to store and process the data.</span></p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Velocity</span>: The rate of arrival of data are much higher in today’s networked world than in earlier days. Data management systems must be able to ingest and store data at very high rates. Further, many applications need data items to be processed as they arrive, in order to detect and respond quickly to certain events (such sys- tems are referred to a <i>streaming data systems</i>). Thus, processing velocity is very important for many applications today.</p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Variety</span><span class="p">: The relational representation of data, relational query languages, and re- lational database systems have been very successful over the past several decades, and they form the core of the data representation of most organizations. However, clearly, not all data are relational.</span></p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">As we saw in Chapter 8, a variety of data representations are used for diﬀer- ent purposes today. While much of today’s data can be eﬃciently represented in relational form, there are many data sources that have other forms of data, such as semi-structured data, textual data, and graph data. The <span class="s44">SQL </span>query language is well suited to specifying a variety of queries on relational data, and it has been extended to handle semi-structured data. However, many computations cannot be easily expressed in <span class="s44">SQL </span>or eﬃciently evaluated if represented using <span class="s44">SQL</span>.</p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">A new generation of languages and frameworks has been developed for speci- fying and eﬃciently executing complex queries on new forms of data.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We shall use the term Big Data in a generic sense, to refer to any data-processing need that requires a high degree of parallelism to handle, regardless of whether the data are relational or otherwise.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Over the past decade, several systems have been developed for storing and process- ing Big Data, using very large clusters of machines, with thousands, or in some cases, tens of thousands of machines. The term <span class="s63">node </span>is often used to refer to a machine in a cluster.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">10.1.1 Sources and Uses of Big Data</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The rapid growth of the web was the key driver for the enormous growth of data vol- umes in the late 1990s and early 2000s. The initial sources of data were logs from web server software, which recorded user interactions with the web servers. With each user</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">clicking on multiple links each day, and hundreds of millions of users, which later grew to billions of users, the large web companies found they were generating multiple ter- abytes of data each day. Web companies soon realized that there was a lot of important information in the web logs, which could be used for multiple purposes, such as these:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Deciding what posts, news, and other information to present to which user, to keep them more engaged with the site. Information on what the user had viewed earlier, as well as information on what other users with similar preferences had viewed, are key to making these decisions.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Deciding what advertisements to show to which users, to maximize the beneﬁt to the advertiser, while also ensuring the advertisements that a user sees are more likely to be of relevance to the user. Again, information on what pages a user had visited, or what advertisements a user had clicked on earlier, are key to making such decisions.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Deciding how a web site should be structured, to make it easy for most users to ﬁnd information that they are looking for. Knowing to what pages users typically navigate, and what page they typically view after visiting a particular page, is key to making such decisions.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Determining user preferences and trends based on page views, which can help a manufacturer or vendor decide what items to produce or stock more of, and what to produce or stock less of. This is part of a more general topic of business intelligence.</span></p><p class="s63" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">Advertisement display and click-through information. A </span>click-through <span class="p">refers to a user clicking on an advertisement to get more information, and is a measure of the success of the advertisement in getting user attention. A </span>conversion <span class="p">occurs when the user actually purchases the advertised product or service. Web sites are often paid when a click-through or conversion occurs. This makes click-through and conversion rates for diﬀerent advertisements a key metric for a site to decide which advertisements to display.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: left;">Today, there are many other sources of very high-volume data. Examples include the following:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Data from mobile phone apps that help in understanding user interaction with the app, in the same way that clicks on a web site help in understanding user interaction with the web site.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Transaction data from retain enterprises (both online and oﬄine). Early users of very large volumes of data included large retail chains such as Walmart, who used parallel database systems even in the years preceding the web, to manage and analyze their data.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Data from sensors. High-end equipment today typically has a large number of sen- sors to monitor the health of the equipment. Collecting such data centrally helps to track status and predict the chances of problems with the equipment, helping ﬁx problems before they result in failure. The increasing use of such sensors to the connection of sensors and other computing devices embedded within other objects such as vehicles, buildings, machinery, and so forth to the internet, often referred to as the </span><span class="s63">internet of things</span><span class="p">. The number of such devices is now more than the number of humans on the internet.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Metadata from communication networks, including traﬃc and other monitoring information for data networks, and call information for voice networks. Such data are important for detecting potential problems before they occur, for detecting problems as they occur, and for capacity planning and other related decisions.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The amount of data stored in databases has been growing rapidly for multiple decades, well before the term Big Data came into use. But the extremely rapid growth of the web created an inﬂection point, with the major web sites having to handle data generated by hundreds of millions to billions of users; this was a scale signiﬁcantly greater than most of the earlier applications.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Even companies that are not web related have found it necessary to deal with very large amounts of data. Many companies procure and analyze large volumes of data generated by other companies. For example, web search histories annotated with user proﬁle information, have become available to many companies, which can use such information to make a variety of business decisions, such as planning advertising cam- paigns, planning what products to manufacture and when, and so on.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Companies today ﬁnd it essential to make use of social media data to make business decisions. Reactions to new product launches by a company, or a change in existing of- ferings can be found on Twitter and other social media sites. Not only is the volume of data on social media sites such as Twitter very high, but the data arrives at a very high velocity, and needs to be analyzed and responded to very quickly. For example, if a company puts out an advertisement, and there is strong negative reaction on Twitter, the company would want to detect the issue quickly, and perhaps stop using the adver- tisement before there is too much damage. Thus, Big Data has become a key enabler for a variety of activities of many organizations today.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">10.1.2 Querying Big Data</p><p class="s42" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">SQL <span class="s43">is by far the most widely used language for querying relational databases. However, there is a wider variety of query language options for Big Data applications, driven by the need to handle more variety of data types, and by the need to scale to very large data volumes/velocity.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Building data management systems that can scale to a large volume/velocity of data requires parallel storage and processing of data. Building a relational database that supports <span class="s44">SQL </span>along with other database features, such as transactions (which we</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">study later in Chapter 17), and <i>at the same time </i>can support very high performance by running on a very large number of machines, is not an easy task. There are two categories of such applications:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: right;">1. <span class="s13">Transaction-processing systems that need very high scalability</span><span class="p">: Transaction- processing systems support a large number of short running queries and updates. It is much easier for a database designed to support transaction processing to scale to very large numbers of machines if the requirements to support all features of a relational database are relaxed. Conversely, many transaction-processing ap- plications that need to scale to very high volumes/velocity can manage without</span></p><p style="padding-left: 145pt;text-indent: 0pt;text-align: justify;">full database support.</p><p style="padding-left: 145pt;text-indent: 14pt;text-align: justify;">The primary mode of data access for such applications is to store data with an associated key, and to retrieve data with that key; such a storage system is called a key-value store. In the preceding user proﬁle example, the key for user-proﬁle data would be the user’s identiﬁer. There are applications that conceptually require joins but implement the joins either in application code or by a form of view materialization.</p><p style="padding-left: 145pt;text-indent: 14pt;text-align: justify;">For example, in a social-networking application, when a user connects to the system, the user should be shown new posts from all her friends. If the data about posts and friends is maintained in relational format, this would require a join. Suppose that instead, the system maintains an object for each user in a key-value store, containing their friend information as well as their posts. Instead of a join done in the database, the application code could implement the join by ﬁrst ﬁnding the set of friends of the user, and then querying the data object of each friend to ﬁnd their posts. Another alternative is as follows: whenever a user <i>u</i><span class="s98">0</span> makes a post, for each friend <i>u</i><span class="s97">i </span>of the user, a message is sent to the data</p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">object representing <i>u</i><span class="s97">i</span>, and the data associated with the friend are updated with a</p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 94%;text-align: justify;">summary of the new post. When that user <i>u</i><span class="s97">i </span>checks for updates, all data required to provide a summary view of posts by friends are available in one place and can be retrieved quickly.</p><p style="padding-left: 145pt;text-indent: 14pt;text-align: justify;">There are trade-oﬀs between the two alternatives, such as higher cost at query time for the ﬁrst alternative, versus higher storage cost and higher cost at the time of writes for the second alternative.<span class="s76">1</span>But both approaches allow the application to carry out its tasks without support for joins in the key-value storage system.</p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span class="s13">Query processing systems that need very high scalability, and need to support non- relational data</span><span class="p">: Typical examples of such systems are those designed to perform analysis on logs generated by web servers and other applications. Other examples include document and knowledge storage and indexing systems, such as those that support keyword search on the web.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_2314.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">1<span class="s78">It is worth mentioning that it appears (based on limited publicly available information as of 2018) that Facebook uses the ﬁrst alternative for its news feed to avoid the high storage overhead of the second alternative.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 113pt;text-indent: 0pt;text-align: justify;"><a name="bookmark220">The data consumed by many such applications are stored in multiple ﬁles. A system designed to support such applications ﬁrst needs to be able to store a large number of large ﬁles. Second, it must be able to support parallel querying of data stored in such ﬁles. Since the data are not necessarily relational, a system designed for querying such data must support arbitrary program code, not just relational algebra or </a><span class="s44">SQL </span>queries.<a name="bookmark238">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Big Data applications often require processing of very large volumes of text, image, and video data. Traditionally such data were stored in ﬁle systems and processed using stand-alone applications. For example, keyword search on textual data, and its succes- sor, keyword search on the web, both depend on preprocessing textual data, followed by query processing using data structures such as indices built during the preprocessing step. It should be clear that the <span class="s44">SQL </span>constructs we have seen earlier are not suited for carrying out such tasks, since the input data are not in relational form, and the output too may not be in relational form.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In earlier days, processing of such data was done using stand-alone programs; this is very similar to how organizational data were processed prior to the advent of database management systems. However, with the very rapid growth of data sizes, the limitations of stand-alone programs became clear. Parallel processing is critical given the very large scale of Big Data. Writing programs that can process data in parallel while dealing with failures (which are common with large scale parallelism) is not easy.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In this chapter, we study techniques for querying of Big Data that are widely used today. A key to the success of these techniques is the fact that they allow speciﬁcation of complex data processing tasks, while enabling easy parallelization of the tasks. These techniques free the programmer from having to deal with issues such as how to perform parallelization, how to deal with failures, how to deal with load imbalances between machines, and many other similar low-level issues.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part202.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part204.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
