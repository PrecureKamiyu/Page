<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>33.6 A Solution: Asynchronous I/O</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part357.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part359.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">33.6 A Solution: Asynchronous I/O</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To overcome this limit, many modern operating systems have intro- duced new ways to issue I/O requests to the disk system, referred to generically as <b>asynchronous I/O</b>. These interfaces enable an application to issue an I/O request and return control immediately to the caller, be- fore the I/O has completed; additional interfaces enable an application to determine whether various I/Os have completed.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 90%;text-align: justify;">For example, let us examine the interface provided on Mac OS X (other systems have similar APIs). The APIs revolve around a basic structure,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">the <span class="s41">struct aiocb </span>or <b>AIO control block </b>in common terminology. A simplified version of the structure looks like this (see the manual pages for more information):</p><p class="s38" style="padding-top: 6pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">struct aiocb {</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;line-height: 8pt;text-align: left;">int     aio_fildes;    /<span class="s39">* </span>File descriptor <span class="s39">*</span>/</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;line-height: 89%;text-align: left;">off_t     aio_offset;    /<span class="s39">* </span>File offset <span class="s39">*</span>/ volatile void  <span class="s39">*</span>aio_buf;     /<span class="s39">* </span>Location of buffer <span class="s39">*</span>/ size_t    aio_nbytes;    /<span class="s39">* </span>Length of transfer <span class="s39">*</span>/</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 7pt;text-align: left;">};</p><p style="padding-top: 5pt;padding-left: 80pt;text-indent: 0pt;text-align: left;">To issue an asynchronous read to a file, an application should first</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_502.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_503.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_504.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_505.png"/></span></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: justify;">fill in this structure with the relevant information: the file descriptor of the file to be read (<span class="s41">aio fildes</span>), the offset within the file (<span class="s41">aio offset</span>) as well as the length of the request (<span class="s41">aio nbytes</span>), and finally the tar- get memory location into which the results of the read should be copied (<span class="s41">aio buf</span>).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">After this structure is filled in, the application must issue the asyn- chronous call to read the file; on Mac OS X, this API is simply the <b>asyn- chronous read </b>API:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">int aio_read(struct aiocb <span class="s39">*</span>aiocbp);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This call tries to issue the I/O; if successful, it simply returns right away and the application (i.e., the event-based server) can continue with its work.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_506.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">There is one last piece of the puzzle we must solve, however. How can we tell when an I/O is complete, and thus that the buffer (pointed to by <span class="s41">aio buf</span>) now has the requested data within it?</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_507.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One last API is needed. On Mac OS X, it is referred to (somewhat confusingly) as <span class="s41">aio error()</span>. The API looks like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">int aio_error(const struct aiocb <span class="s39">*</span>aiocbp);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_508.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This system call checks whether the request referred to by <span class="s41">aiocbp </span>has completed. If it has, the routine returns success (indicated by a zero); if not, EINPROGRESS is returned. Thus, for every outstanding asyn- chronous I/O, an application can periodically <b>poll </b>the system via a call to <span class="s41">aio error() </span>to determine whether said I/O has yet completed.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One thing you might have noticed is that it is painful to check whether an I/O has completed; if a program has tens or hundreds of I/Os issued at a given point in time, should it simply keep checking each of them repeatedly, or wait a little while first, or ... ?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To remedy this issue, some systems provide an approach based on the <b>interrupt</b>. This method uses U<span class="s7">NIX </span><b>signals </b>to inform applications when an asynchronous I/O completes, thus removing the need to repeatedly ask the system. This polling vs. interrupts issue is seen in devices too, as you will see (or already have seen) in the chapter on I/O devices.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="408" height="606" alt="image" src="Image_509.png"/></span></p><p style="padding-top: 2pt;padding-left: 21pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A<span class="s7">SIDE</span>: <b>U</b><span class="s45">NIX </span><b>S</b><span class="s45">IGNALS</span></p><p class="s5" style="padding-left: 41pt;text-indent: 11pt;text-align: justify;">A huge and fascinating infrastructure known as <b>signals </b>is present in all mod- ern U<span class="s13">NIX </span>variants. At its simplest, signals provide a way to communicate with a process. Specifically, a signal can be delivered to an application; doing so stops the application from whatever it is doing to run a <b>signal handler</b>, i.e., some code in the application to handle that signal. When finished, the process just resumes its previous behavior.</p><p class="s5" style="padding-top: 2pt;padding-left: 41pt;text-indent: 11pt;text-align: justify;">Each signal has a name, such as <b>HUP </b>(hang up), <b>INT </b>(interrupt), <b>SEGV </b>(seg- mentation violation), etc; see the manual page for details. Interestingly, sometimes it is the kernel itself that does the signaling. For example, when your program en- counters a segmentation violation, the OS sends it a <b>SIGSEGV </b>(prepending <b>SIG </b>to signal names is common); if your program is configured to catch that signal, you can actually run some code in response to this erroneous program behavior (which can be useful for debugging). When a signal is sent to a process not config- ured to handle that signal, some default behavior is enacted; for SEGV, the process is killed.</p><p class="s5" style="padding-top: 2pt;padding-left: 41pt;text-indent: 11pt;text-align: justify;">Here is a simple program that goes into an infinite loop, but has first set up a signal handler to catch SIGHUP:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">#include &lt;stdio.h&gt; #include &lt;signal.h&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">void handle(int arg) {</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">printf(&quot;stop wakin’ me up...\n&quot;);</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 57pt;text-indent: -16pt;line-height: 90%;text-align: left;">int main(int argc, char <span class="s39">*</span>argv[]) { signal(SIGHUP, handle);</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">while (1)</p><p class="s38" style="padding-left: 57pt;text-indent: 16pt;text-align: left;">; // doin’ nothin’ except catchin’ some sigs return 0;</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 41pt;text-indent: 11pt;text-align: justify;">You can send signals to it with the <b>kill </b>command line tool (yes, this is an odd and aggressive name). Doing so will interrupt the main while loop in the program and run the handler code <span class="s15">handle()</span>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">prompt&gt; ./main &amp; [3] 36705</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">prompt&gt; kill -HUP 36705 stop wakin’ me up... prompt&gt; kill -HUP 36705 stop wakin’ me up... prompt&gt; kill -HUP 36705 stop wakin’ me up...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 41pt;text-indent: 11pt;text-align: justify;">There is a lot more to learn about signals, so much that a single page, much less a single chapter, does not nearly suffice. As always, there is one great source: Stevens and Rago [SR05]. Read more if interested.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In systems without asynchronous I/O, the pure event-based approach cannot be implemented. However, clever researchers have derived meth- ods that work fairly well in their place. For example, Pai et al. [PDZ99] describe a hybrid approach in which events are used to process network packets, and a thread pool is used to manage outstanding I/Os. Read their paper for details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part357.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part359.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
