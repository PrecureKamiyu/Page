<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.2 Expressing Program Performance</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P700049702700000000000000000493B" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000043082" data-uri="chapter05.xhtml#P7000497027000000000000000043082" epub:type="title"><span class="pcalibre label pcalibre1">5.2 </span>Expressing Program Performance</h1></header>
<p id="P7000497027000000000000000043083" data-uri="chapter05.xhtml#P7000497027000000000000000043083" class="pcalibre1 pcalibre calibre2">We introduce the metric <i class="calibre5 pcalibre pcalibre1">cycles per element</i>, abbreviated CPE, to express program performance in a way that can guide us in improving the code. CPE measurements help us understand the loop performance of an iterative program at a detailed level. It is appropriate for programs that perform a repetitive computation, such as processing the pixels in an image or computing the elements in a matrix product.</p>
<p id="P7000497027000000000000000043084" data-uri="chapter05.xhtml#P7000497027000000000000000043084" class="pcalibre1 pcalibre calibre2">The sequencing of activities by a processor is controlled by a clock providing a regular signal of some frequency, usually expressed in <i class="calibre5 pcalibre pcalibre1">gigahertz</i> (GHz), billions of cycles per second. For example, when product literature characterizes a system as a "4 GHz" processor, it means that the processor clock runs at 4.0 × 10<sup class="calibre51 pcalibre pcalibre1">−9</sup> cycles per second. The time required for each clock cycle is given by the reciprocal of the clock frequency. These typically are expressed in <i class="calibre5 pcalibre pcalibre1">nanoseconds</i> (1 nanosecond is 10<sup class="calibre51 pcalibre pcalibre1">−9</sup> seconds) or <i class="calibre5 pcalibre pcalibre1">picoseconds</i> (1 picosecond is 10<sup class="calibre51 pcalibre pcalibre1">−12</sup> seconds). For example, the period of a 4 GHz clock can be expressed as either 0.25 nanoseconds or 250 picoseconds. From a programmer's perspective, it is more instructive to express measurements in clock cycles rather than nanoseconds or picoseconds. That way, the measurements express how many instructions are being executed rather than how fast the clock runs.</p>
<p id="P7000497027000000000000000043085" data-uri="chapter05.xhtml#P7000497027000000000000000043085" class="pcalibre1 pcalibre calibre2">Many procedures contain a loop that iterates over a set of elements. For example, functions <code id="P7000497027000000000000000043086" data-uri="chapter05.xhtml#P7000497027000000000000000043086" class="pcalibre1 calibre8 pcalibre">psum1</code> and <code id="P7000497027000000000000000043087" data-uri="chapter05.xhtml#P7000497027000000000000000043087" class="pcalibre1 calibre8 pcalibre">psum2</code> in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004949"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.1</span></a> both compute the <i class="calibre5 pcalibre pcalibre1">prefix sum</i> of a vector of length <var class="calibre5 pcalibre pcalibre1">n</var>. For a vector <span class="inlineequation pcalibre pcalibre1"><m:math display="inline" alttext="" data-uri="" altimg-width="139" altimg-height="16" altimg="../images/ch05-1.png"><m:mrow><m:mover accent="true"><m:mi>a</m:mi><m:mo>→</m:mo></m:mover><m:mo>=</m:mo><m:mrow><m:mo>〈</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mtext> </m:mtext><m:mo>,</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mo>〉</m:mo></m:mrow></m:mrow></m:math></span>, the prefix sum <span class="inlineequation pcalibre pcalibre1"><m:math display="inline" alttext="" data-uri="" altimg-width="201" altimg-height="21" altimg="../images/ch05-2.png"><m:mrow><m:mover accent="true"><m:mi>p</m:mi><m:mo>→</m:mo></m:mover><m:mo>=</m:mo><m:mrow><m:mo>〈</m:mo><m:mrow><m:msub><m:mi>p</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:msub><m:mi>p</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mtext> </m:mtext><m:mo>,</m:mo><m:msub><m:mi>p</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mo>〉</m:mo></m:mrow></m:mrow></m:math> </span>is defined as</p>
<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000043088" data-uri="chapter05.xhtml#P7000497027000000000000000043088">
<m:math display="block" alttext="" data-uri="" altimg-width="236" altimg-height="51" altimg="../images/ch05-3.png"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>p</m:mi><m:mn>0</m:mn></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>p</m:mi><m:mi>i</m:mi></m:msub><m:mo>=</m:mo><m:msub><m:mi>p</m:mi><m:mrow><m:mi>i</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mi>i</m:mi></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:mn>1</m:mn><m:mo>&lt;</m:mo><m:mi>i</m:mi><m:mo>&lt;</m:mo><m:mi>n</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
<span class="number3 pcalibre pcalibre1">(5.1)</span>
</div>
<p id="P7000497027000000000000000043089" data-uri="chapter05.xhtml#P7000497027000000000000000043089" class="pcalibre1 pcalibre calibre2">Function <code id="P700049702700000000000000004308A" data-uri="chapter05.xhtml#P700049702700000000000000004308A" class="pcalibre1 calibre8 pcalibre">psum1</code> computes one element of the result vector per iteration. Function <code id="P700049702700000000000000004308B" data-uri="chapter05.xhtml#P700049702700000000000000004308B" class="pcalibre1 calibre8 pcalibre">psum2</code> uses a technique known as <i class="calibre5 pcalibre pcalibre1">loop unrolling</i> to compute two elements per iteration. We will explore the benefits of loop unrolling later in this chapter. (See Problems 5.11,5.12, and 5.19 for more about analyzing and optimizing the prefix-sum computation.)</p>
<p id="P700049702700000000000000004308C" data-uri="chapter05.xhtml#P700049702700000000000000004308C" class="pcalibre1 pcalibre calibre2">The time required by such a procedure can be characterized as a constant plus a factor proportional to the number of elements processed. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004951"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.2</span></a> shows a plot of the number of clock cycles required by the two functions for a range of values of <var class="calibre5 pcalibre pcalibre1">n</var>. Using a <i class="calibre5 pcalibre pcalibre1">least squares fit</i>, we find that the run times (in clock cycles) for <code id="P700049702700000000000000004308D" data-uri="chapter05.xhtml#P700049702700000000000000004308D" class="pcalibre1 calibre8 pcalibre">psum1</code> and <code id="P700049702700000000000000004308E" data-uri="chapter05.xhtml#P700049702700000000000000004308E" class="pcalibre1 calibre8 pcalibre">psum2</code> can be approximated by the equations 368 + 9.0<var class="calibre5 pcalibre pcalibre1">n</var> and 368 + 6.0<var class="calibre5 pcalibre pcalibre1">n</var>, respectively. These equations indicate an overhead of 368 cycles due to the timing code and to initiate the procedure, set up the loop, and complete the</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004949" data-uri="chapter05.xhtml#P7000497027000000000000000004949">
<pre id="P700049702700000000000000004308F" data-uri="chapter05.xhtml#P700049702700000000000000004308F" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043090" data-uri="chapter05.xhtml#P7000497027000000000000000043090" class="calibre10 pcalibre pcalibre1">
<span class="pcalibre pagebreak1 pcalibre1" id="P700049702700000000000000000494C" title="503" data-uri="chapter05.xhtml#P700049702700000000000000000494C" epub:type="pagebreak"></span>1	/* Compute prefix sum of vector a */
2	void pum1(float a[], float p[], long n)
3	{
4		long i;
5		p[0] = a[0];
6		for (i = 1; i &lt; n; i++)
7			p[i] = p[i-1] + a[i];
8	}
9	
10	void psum2(float a[], float p[], long n)
11	{
12		long i;
13		p[0] = a[0];
14		for (i = 1; i &lt; n-1; i+=2) {
15			float mid_val = p[i-1] + a[i];
16			p[i] = mid_val;
17			p[i+1] = mid_val + a[i+1];
18 }
19	/* For even n, finish remaining element */
20	if (i &lt; n)
21			p[i] = p[i-1] + a[i];
22	}
</code></pre>
<figcaption id="P7000497027000000000000000043091" data-uri="chapter05.xhtml#P7000497027000000000000000043091" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000043092" data-uri="chapter05.xhtml#P7000497027000000000000000043092" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.1 </span>Prefix-sum functions.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000043093" data-uri="chapter05.xhtml#P7000497027000000000000000043093"><p id="P7000497027000000000000000043094" data-uri="chapter05.xhtml#P7000497027000000000000000043094" class="pcalibre calibre3 pcalibre1">These functions provide examples for how we express program performance.</p></div></figcaption></figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004951" data-uri="chapter05.xhtml#P7000497027000000000000000004951">
<img alt="A graph of cycles versus elements shows two lines, the higher representing psum1 with slope = 9 and the lower representing psum2 with slope = 6." id="P7000497027000000000000000043095" data-uri="P700049702700000000000000000B70D" src="../images/p503-1.png" class="calibre168 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000043096" data-uri="chapter05.xhtml#P7000497027000000000000000043096" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000043097" data-uri="chapter05.xhtml#P7000497027000000000000000043097" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.2 </span>Performance of prefix-sum functions.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000043098" data-uri="chapter05.xhtml#P7000497027000000000000000043098"><p id="P7000497027000000000000000043099" data-uri="chapter05.xhtml#P7000497027000000000000000043099" class="pcalibre calibre3 pcalibre1">The slope of the lines indicates the number of clock cycles per element (CPE).</p></div></figcaption></figure>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000004957" data-uri="chapter05.xhtml#P7000497027000000000000000004957"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P700049702700000000000000004309A" data-uri="chapter05.xhtml#P700049702700000000000000004309A" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004959" title="504" data-uri="chapter05.xhtml#P7000497027000000000000000004959" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>What is a least squares fit?</h1></header>
<p id="P700049702700000000000000004309B" data-uri="chapter05.xhtml#P700049702700000000000000004309B" class="calibre13 pcalibre pcalibre1">For a set of data points (<var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre">1</sub>, <var class="calibre5 pcalibre pcalibre1">y</var><sub class="pcalibre1 calibre47 pcalibre">1</sub>),. . . (<i class="calibre5 pcalibre pcalibre1">x<sub class="pcalibre1 calibre47 pcalibre">n</sub></i>, <i class="calibre5 pcalibre pcalibre1">y<sub class="pcalibre1 calibre47 pcalibre">n</sub></i>), we often try to draw a line that best approximates the X-Y trend represented by these data. With a least squares fit, we look for a line of the form <i class="calibre5 pcalibre pcalibre1">y = mx</i> + <var class="calibre5 pcalibre pcalibre1">b</var> that minimizes the following error measure:</p>
<div class="informalequation pcalibre pcalibre1" id="P700049702700000000000000004309C" data-uri="chapter05.xhtml#P700049702700000000000000004309C">
<m:math display="block" alttext="" data-uri="" altimg-width="184" altimg-height="34" altimg="../images/ch05-4.png"><m:mrow><m:mi>E</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>m</m:mi><m:mo>,</m:mo><m:mi>b</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:munder><m:mo>∑</m:mo><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mi>n</m:mi></m:mrow></m:munder><m:mrow><m:msup><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:mi>m</m:mi><m:msub><m:mi>x</m:mi><m:mi>i</m:mi></m:msub><m:mo>+</m:mo><m:mi>b</m:mi><m:mo>-</m:mo><m:msub><m:mi>y</m:mi><m:mi>i</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow><m:mn>2</m:mn></m:msup></m:mrow></m:mrow></m:math>
</div>
<p class="pcalibre calibre3 pcalibre1" id="P700049702700000000000000004309D" data-uri="chapter05.xhtml#P700049702700000000000000004309D">An algorithm for computing <var class="calibre5 pcalibre pcalibre1">m</var> and <var class="calibre5 pcalibre pcalibre1">b</var> can be derived by finding the derivatives of <i class="calibre5 pcalibre pcalibre1">E(m, b)</i> with respect to <var class="calibre5 pcalibre pcalibre1">m</var> and <var class="calibre5 pcalibre pcalibre1">b</var> and setting them to 0.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004309E" data-uri="chapter05.xhtml#P700049702700000000000000004309E">procedure, plus a linear factor of 6.0 or 9.0 cycles per element. For large values of <var class="calibre5 pcalibre pcalibre1">n</var> (say, greater than 200), the run times will be dominated by the linear factors. We refer to the coefficients in these terms as the effective number of cycles per element. We prefer measuring the number of cycles per <i class="calibre5 pcalibre pcalibre1">element</i> rather than the number of cycles per <i class="calibre5 pcalibre pcalibre1">iteration</i>, because techniques such as loop unrolling allow us to use fewer iterations to complete the computation, but our ultimate concern is how fast the procedure will run for a given vector length. We focus our efforts on minimizing the CPE for our computations. By this measure, <code id="P700049702700000000000000004309F" data-uri="chapter05.xhtml#P700049702700000000000000004309F" class="pcalibre1 calibre8 pcalibre">psum2</code>, with a CPE of 6.0, is superior to <code id="P70004970270000000000000000430A0" data-uri="chapter05.xhtml#P70004970270000000000000000430A0" class="pcalibre1 calibre8 pcalibre">psum1</code>, with a CPE of 9.0.</p>
<section id="P7000497027000000000000000004960" data-uri="chapter05.xhtml#P7000497027000000000000000004960" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000430A1" data-uri="chapter05.xhtml#P70004970270000000000000000430A1" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.2 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050DD">573</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000430A2" data-uri="chapter05.xhtml#P70004970270000000000000000430A2">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000430A3" data-uri="chapter05.xhtml#P70004970270000000000000000430A3">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000430A4" data-uri="chapter05.xhtml#P70004970270000000000000000430A4"><p id="P70004970270000000000000000430A5" data-uri="chapter05.xhtml#P70004970270000000000000000430A5" class="pcalibre calibre3 pcalibre1">Later in this chapter we will start with a single function and generate many different variants that preserve the function's behavior, but with different performance characteristics. For three of these variants, we found that the run times (in clock cycles) can be approximated by the following functions:</p>
<ul class="pcalibre ul_none pcalibre1" id="P70004970270000000000000000430A6" data-uri="chapter05.xhtml#P70004970270000000000000000430A6">
<li id="P70004970270000000000000000430A7" data-uri="chapter05.xhtml#P70004970270000000000000000430A7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000430A8" data-uri="chapter05.xhtml#P70004970270000000000000000430A8" class="calibre13 pcalibre pcalibre1">Version 1: 60 + 35<var class="calibre5 pcalibre pcalibre1">n</var></p></li>
<li id="P70004970270000000000000000430A9" data-uri="chapter05.xhtml#P70004970270000000000000000430A9" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000430AA" data-uri="chapter05.xhtml#P70004970270000000000000000430AA" class="calibre13 pcalibre pcalibre1">Version 2: 136 + 4<var class="calibre5 pcalibre pcalibre1">n</var></p></li>
<li id="P70004970270000000000000000430AB" data-uri="chapter05.xhtml#P70004970270000000000000000430AB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000430AC" data-uri="chapter05.xhtml#P70004970270000000000000000430AC" class="calibre13 pcalibre pcalibre1">Version 3: 157 + 1.25<var class="calibre5 pcalibre pcalibre1">n</var></p></li>
</ul>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000430AD" data-uri="chapter05.xhtml#P70004970270000000000000000430AD">For what values of <var class="calibre5 pcalibre pcalibre1">n</var> would each version be the fastest of the three? Remember that <var class="calibre5 pcalibre pcalibre1">n</var> will always be an integer.</p></div></li>
</ol>
</section>
</section></body></html>
