#+title: Memory

* Chapter 06 Memory Shit chapter from Tang Shuo Fei

哎, 说实话我还是记录中文吧, 这真是...

这一章是关于存储器的. 理论上我还可以写一个 Stallings 的书的笔记, 但还
是算了? 真的是烦捏. 时间问题可能是.

总之这章就开始了, 主要研究问题是什么? 

- Cache
- Main Memory
- RAM
- Disk
- Some other forms of memory

这里是说, 我们将要研究, Cache 的基本运作原理. Main Memory 的组成. RAM
的工作原理, 然后是 Magnetic Disk 的运作原理. 我们来看一下 Tang 的目录
组成吧, 没什么办法, 我们考的还是这个几把东西.

1. 概述
   1. 存储器的分类
   2. 存储器的 Heirarchy
2. Main Memory
   1. 概述
   2. SemiConductor 芯片
   3. RAM
   4. ROM
   5. 存储器和 CPU 之间的链接
   6. Memory 的校验 Parity
   7. 几把
3. Cache
4. 虚拟 Memory
5. 辅助存储器

子目录我是不想抄的, 反正之后是要抄写上去的. 

** 概述
为什么研究存储器非常重要?
- CPU 的运行速度变得高的同时, 存储器的读取速度跟不上这个发展, 于是说计
  算机系统的运行速度很大程度上收到了存储器的制约.
- 另一方面, 当我们 IO 设备的数量不断增多, 若是 IO 设备和存储器之间的信
  息交换都是直接通过 CPU 来实现. 那么其将降低 CPU 的运转效率.

随后我们对存储器进行分类, 因为, 嘛, 反正我们有很多存储器. 随后, 这种分
类让我们看到的那些区别, 正是这些区别让我们有 Memory Heirarchy. 总之我
们来看, 目前我们有三种分类方法: 1. 按照存储介质进行分类; 2. 按照存取方
式进行分类; 3. 按照功能进行分类.

---------
按照存储介质进行分类:
1. SemiConductor 存储器. 这是一种 volatile 还是什么来着的一种存储, 也
   就是 "断电会丢失" 的存储器.
2. 磁表面存储器. 也就是 Magnetic Memory 其实. 使用了磁介质来存储. 里面
   有一些单元, 每一个单元存储着一个bit的信息, 这个信息是使用单元内的磁
   场方向来表示的. 
3. 磁芯存储器. ?什么价吧. 
4. 光盘存储器. 在读写过程之中应用了激光. 额, 剩下的我就不是很知道了.

--------
然后我们还可以按照存储方式分类
1. RAM. 可读可写的存储器. 有 SRAM 和 DRAM.
2. ROM. 只可读的存储器. 有很多种, 比如说 EPROM, EEPROM, Flash Memory.
3. 串行访问存储器. 简单来说, 就是和 Random accessing 相反的一个存在.
   RA 指的是, 能够通过地址来进行访问. 这种就是随机访问, 也就是说, 给定
   了一个地址, 我们能够直接访问到那个地址里面的数据. 串行访问存储器就
   是不能够做到这一点的存储器.

---------
然后我们还可以按照功能进行分类. 这里就不进行分类了, 因为分类是显然的.
这是由他们的物理特性决定的.



** Memory heirarchy

这里是一个类似于金字塔的东西. 记忆也是简单的. 我们稍微看一下这个层级,
简单来说, 我们有

#+begin_center
CPU <-> 缓存 <-> Main 存 <-> 辅存
#+end_center

Main 存就是我们常说的内存啦. 缓存的存在是为了加速 CPU 和 Main 存之间的
交互. 如果说我们知道了 hit rate 的概念, 当这个 hit rate 的数值接近于 1
的时候, 我们就可以说, CPU 能够以 "缓存的速度" 去访问 Main 存, 也就是
说, 相当于缓存的大小被扩张为 Main 存的大小. 总之就是爽.

值得注意的是, Main 存以及 Cache 可以被称为 Internal Memory. 因为其实放
在板上的, 与之相对的是, 辅存被称为 External Memory. 这是说, 存储设备是
和 Chip 分开的. 于是我们能够知道访问 External Memory 的时候, 需要涉及
Bus. 应该.

---------

在 main 存和 Cache 之间还发展出来了虚拟存储. 简单来说, 这是一层抽象.
因为我们的 Main 存的大小是实际上并没有那么大, 这层抽象让我们可以将一些
并不是 Main 存的地方 "看作" 是 Main 存. 剩下的细节交给系统和操作系统进
行处理.

这里面我们有两种概念: 1. 逻辑 (Logical) 地址; 2. 物理 (Physical) 地址.
前者就是一种逻辑上的地址, 已经被封装过了的地址, 而物理地址就是实际的,
Chip 上面的地址, 程序执行过程之中真正访问的地址.

---------

** Main 存


1. Words

字长便是 word 的长度. 如果说内部有 4 个 bytes, 那么这四个字节都是可以
独立寻址的. 一般来说, word 的长度, 是 2^m 个 bytes. 我们能够有按 word
寻址, 也能够按照 bytes 寻址

- 寻址范围
一般来说, 地址的长度就能够算出 "寻址范围", 虽然说是范围, 但实际上, 我
们可以直接认为是, "能够访问的单元个数的多少".