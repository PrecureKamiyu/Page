<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>9.7   Application Performance</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part188.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part190.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 10pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">9.7   <span style=" color: #00AEEF;">Application Performance</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Web sites may be accessed by millions of people from across the globe, at rates of thousands of requests per second, or even more, for the most popular sites. Ensuring</p><p class="s66" style="padding-top: 3pt;padding-left: 341pt;text-indent: 0pt;text-align: left;">9.7 <span style=" color: #00AEEF;">Application Performance  </span><span class="s164">435</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2290.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2291.png"/></span></p><p class="s49" style="padding-top: 4pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">from models import Student, Instructor def get names(persons):</p><p class="s49" style="padding-left: 155pt;text-indent: 0pt;line-height: 12pt;text-align: left;">res = &quot;&quot;</p><p class="s49" style="padding-left: 155pt;text-indent: 0pt;text-align: left;">for p in persons:</p><p class="s49" style="padding-left: 155pt;text-indent: 21pt;text-align: left;">res += p.name + &quot;, &quot; return res.rstrip(&quot;, &quot;)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2292.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2293.png"/></span></p><p class="s49" style="padding-left: 134pt;text-indent: 0pt;text-align: left;">def person query model(request):</p><p class="s49" style="padding-left: 155pt;text-indent: 0pt;text-align: left;">persontype = request.GET.get(’persontype’) personname = request.GET.get(’personname’) html = &quot;&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 155pt;text-indent: 0pt;text-align: left;">if persontype == ’student’:</p><p class="s49" style="padding-left: 177pt;text-indent: 0pt;text-align: left;">students = Student.objects.filter(name=personname) for student in students:</p><p class="s49" style="padding-left: 198pt;text-indent: 0pt;line-height: 12pt;text-align: left;">advisors = students.advisors.all()</p><p class="s49" style="padding-left: 198pt;text-indent: 0pt;line-height: 11pt;text-align: left;">html = html + &quot;Advisee: &quot; + student.name + &quot;&lt;br&gt;Advisors: &quot;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2294.png"/></span></p><p class="s49" style="padding-left: 219pt;text-indent: 0pt;line-height: 14pt;text-align: left;">+ get names(advisors) + &quot;<span class="s186">&lt;</span>br<span class="s186">&gt; </span><span class="s185">∖</span>n&quot;</p><p class="s49" style="padding-left: 155pt;text-indent: 0pt;line-height: 11pt;text-align: left;">else:</p><p class="s49" style="padding-left: 177pt;text-indent: 0pt;text-align: left;">instructors = Instructor.objects.filter(name=personname) for instructor in instructors:</p><p class="s49" style="padding-left: 198pt;text-indent: 0pt;text-align: left;">advisees = instructor.advisees.all()</p><p class="s49" style="padding-left: 198pt;text-indent: 0pt;line-height: 11pt;text-align: left;">html = html+&quot;Advisor: &quot; + instructor.name + &quot;&lt;br&gt;Advisees: &quot;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2295.png"/></span></p><p class="s49" style="padding-left: 219pt;text-indent: 0pt;line-height: 14pt;text-align: left;">+ get names(advisees) + &quot;<span class="s186">&lt;</span>br<span class="s186">&gt; </span><span class="s185">∖</span>n&quot;</p><p class="s49" style="padding-left: 155pt;text-indent: 0pt;line-height: 11pt;text-align: left;">return HttpResponse(html)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2296.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 190pt;text-indent: 0pt;text-align: left;">Figure 9.16 <span class="s74">View definition in Django using models.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">that requests are served with low response times is a major challenge for web-site de- velopers. To do so, application developers try to speed up the processing of individual requests by using techniques such as caching, and they exploit parallel processing by using multiple application servers. We describe these techniques brieﬂy next. Tuning of database applications is another way to improve performance and is described in Section 25.1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">9.7.1 Reducing Overhead by Caching</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Suppose that the application code for servicing each user request connects to a database through <span class="s44">JDBC</span>. Creating a new <span class="s44">JDBC </span>connection may take several millisec- onds, so opening a new connection for each user request is not a good idea if very high transaction rates are to be supported.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s63">connection pooling </span>method is used to reduce this overhead; it works as follows: The connection pool manager (typically a part of the application server) creates a pool (that is, a set) of open <span class="s44">ODBC</span>/<span class="s44">JDBC </span>connections. Instead of opening a new connection to the database, the code servicing a user request (typically a servlet) asks for (requests) a connection from the connection pool and returns the connection to the pool when the code (servlet) completes its processing. If the pool has no unused connections when a connection is requested, a new connection is opened to the database (taking care not to exceed the maximum number of connections that the database system can support concurrently). If there are many open connections that have not been used for a while, the connection pool manager may close some of the open database connections. Many application servers and newer <span class="s44">ODBC</span>/<span class="s44">JDBC </span>drivers provide a built-in connection pool manager.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Details of how to create a connection pool vary by application server or <span class="s44">JDBC </span>driver, but most implementations require the creation of a <span class="s49">DataSource </span>object using the <span class="s44">JDBC </span>connection details such as the machine, port, database, user-id and password, as well as other parameters related to connection pooling. The <span class="s49">getConnection() </span>method invoked on the <span class="s49">DataSource </span>object gets a connection from the connection pool. Closing the connection returns the connection to the pool.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Certain requests may result in exactly the same query being resubmitted to the database. The cost of communication with the database can be greatly reduced by caching the results of earlier queries and reusing them, so long as the query result has not changed at the database. Some web servers support such query-result caching; caching can otherwise be done explicitly in application code.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Costs can be further reduced by caching the ﬁnal web page that is sent in response to a request. If a new request comes with exactly the same parameters as a previous request, the request does not perform any updates, and the resultant web page is in the cache, that page can be reused to avoid the cost of recomputing the page. Caching can be done at the level of fragments of web pages, which are then assembled to create complete web pages.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Cached query results and cached web pages are forms of materialized views. If the underlying database data change, the cached results must be discarded, or recomputed, or even incrementally updated, as in materialized-view maintenance (described in Sec- tion 16.5). Some database systems (such as Microsoft <span class="s44">SQL </span>Server) provide a way for the application server to register a query with the database and get a <span class="s63">notiﬁcation </span>from the database when the result of the query changes. Such a notiﬁcation mechanism can be used to ensure that query results cached at the application server are up-to-date.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">There are several widely used main-memory caching systems; among the more pop- ular ones are <span class="s63">memcached </span>and <span class="s63">Redis</span>. Both systems allow applications to store data with an associated key and retrieve data for a speciﬁed key. Thus, they act as hash-map data structures that allow data to be stored in the main memory but also provide cache eviction of infrequently used data.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;"><a name="bookmark192">For example, with memcached, data can be stored using </a><span class="s49">memcached.add(key, data) </span>and fetched using <span class="s49">memcached.fetch(key)</span>. Instead of issuing a database query to fetch user data witha speciﬁed key, say <span class="s49">key1</span>, froma relation <span class="s49">r</span>, an application would ﬁrst check if the required data are already cached by issuing a <span class="s49">fetch(&quot;r:&quot;+key1) </span>(here, the key is appended to the relation name, to distinguish data from diﬀerent relations that may be stored in the same memcached instance). If the fetch returns null, the database query is issued, a copy of the data fetched from the database is stored in memcached, and the data are then returned to the user. If the fetch does ﬁnd the requested data, it can be used without accessing the database, leading to much faster access.<a name="bookmark212">&zwnj;</a></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A client can connect to multiple memcached instances, which may run on diﬀer- ent machines and store/retrieve data from any of them. How to decide what data are stored on which instance is left to the client code. By partitioning the data storage across multiple machines, an application can beneﬁt from the aggregate main memory available across all the machines.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2297.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2298.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Memcached does not support automatic invalidation of cached data, but the ap- plication can track database changes and issue updates (using <span class="s49">memcached set(key, newvalue)</span>) or deletes (using <span class="s49">memcached delete(key)</span>) for the key values aﬀected by update or deletion in the database. Redis oﬀers very similar functionality. Both mem- cached and Redis provide <span class="s44">API</span>s in multiple languages.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">9.7.2 Parallel Processing</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">A commonly used approach to handling such very heavy loads is to use a large number of application servers running in parallel, each handling a fraction of the requests. A web server or a network router can be used to route each client request to one of the application servers. All requests from a particular client session must go to the same application server, since the server maintains state for a client session. This property can be ensured, for example, by routing all requests from a particular <span class="s44">IP </span>address to the same application server. The underlying database is, however, shared by all the application servers, so users see a consistent view of the database.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">While the above architecture ensures that application servers do not become bot- tlenecks, it cannot prevent the database from becoming a bottleneck, since there is only one database server. To avoid overloading the database, application designers often use caching techniques to reduce the number of requests to the database. In addition, par- allel database systems, described in Chapter 21 through Chapter 23, are used when the database needs to handle very large amounts of data, or a very large query load. Parallel data storage systems that are accessible via web service <span class="s44">API</span>s are also popular in applications that need to scale to a very large number of users.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part188.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part190.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
