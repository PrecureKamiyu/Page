<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 229" epub:type="pagebreak" id="page_229" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 10: Queues, memory management, and the ABA problem</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter presents a variety of queue implementations, from bounded lock-based queues to unbounded lock-free queues to synchronous queues. It introduces the notions of partial methods, which block when certain conditions are not met, for example, trying to remove an element from an empty queue or add an element to a full (bounded) queue, and synchronous methods, in which two threads must rendezvous at a data structure to exchange information. It also touches briefly on memory management and the ABA problem, which we will return to in more detail in Chapter <a href="B978012415950100029X.xhtml">19</a>.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">queues; pools; memory management; ABA problem; partial methods; synchronous methods; dual data structures</p></section></header><section><h2 class="h1hd" id="s0010"><a id="st0020"/>10.1 Introduction</h2><p class="textfl" id="p0010">In the next few chapters, we look at a broad class of objects known as <i>pools</i>. A pool is similar to the <img alt="Image" height="9" src="images/B9780124159501000203/fx001.jpg" width="32"/> class studied in Chapter <a href="B9780124159501000197.xhtml">9</a>, with two main differences: A pool does not necessarily provide a <img alt="Image" height="9" src="images/B9780124159501000203/fx002.jpg" width="51"/>() method to test membership, and it allows the same item to appear more than once. The <img alt="Image" height="9" src="images/B9780124159501000203/fx003.jpg" width="38"/> has <img alt="Image" height="11" src="images/B9780124159501000203/fx004.jpg" width="18"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx005.jpg" width="19"/>() methods, as shown in <a href="#f0010" id="cf0020">Fig. 10.1</a>. Pools show up in many places in concurrent systems. For example, in many applications, one or more <i>producer</i> threads produce items to be consumed by one or more <i>consumer</i> threads. These items may be jobs to perform, keystrokes to interpret, purchase orders to execute, or packets to decode. Sometimes producers are <i>bursty</i>, suddenly and briefly producing items faster than consumers can consume them. To allow consumers to keep up, we can place a <i>buffer</i> between the producers and the consumers. Items produced faster than they can be consumed accumulate in the buffer, from which they are consumed as quickly as possible. Often, pools act as producer–consumer buffers.</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="60" src="images/B9780124159501000203/gr001.jpg" width="174"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.1</span> The <img alt="Image" height="9" src="images/B9780124159501000203/fx006.jpg" width="45"/> interface.</div></figcaption></figure></div><p class="text" id="p0015">Pools come in several varieties.</p><div><ul><li class="bulllist" id="u0010">•  A pool may be <i>bounded</i> or <i>unbounded</i>. A bounded pool holds a limited number of items. This limit is called its <i>capacity</i>. By contrast, an unbounded pool can hold any number of items. Bounded pools are useful when we want to keep producer and consumer threads loosely synchronized, ensuring that producers do not get too far ahead of consumers. Bounded pools may also be simpler to implement than unbounded pools. On the other hand, unbounded pools are useful when it is not easy to fix a limit on how far producers can outstrip consumers.</li><li class="bulllist" id="u0015">•  Pool methods may be <i>total</i> or <i>partial</i>. Some partial methods are <i>synchronous</i>.<ul><li class="bulllist1" id="u0020">•  A method is <i>partial</i> if calls may wait for certain conditions to hold. For example, a partial <img alt="Image" height="11" src="images/B9780124159501000203/fx005.jpg" width="19"/>()<span aria-label="Page 230" epub:type="pagebreak" id="page_230" role="doc-pagebreak"/> call that tries to remove an item from an empty pool blocks until an item is available to return. If the pool is bounded, a partial <img alt="Image" height="11" src="images/B9780124159501000203/fx004.jpg" width="18"/>() call that tries to add an item to a full pool blocks until an empty slot is available to fill. A partial interface makes sense when the producer (or consumer) has nothing better to do than to wait for the pool to become nonfull (or nonempty).</li><li class="bulllist1" id="u0025">•  A method is <i>total</i> if calls never need to wait for conditions to become true. For example, a <img alt="Image" height="11" src="images/B9780124159501000203/fx005.jpg" width="19"/>() call that tries to remove an item from an empty pool, or a <img alt="Image" height="11" src="images/B9780124159501000203/fx004.jpg" width="18"/>() call that tries to add an item to a full pool, may immediately return a failure code or throw an exception. A total interface makes sense when the producer (or consumer) thread has something better to do than wait for the method call to take effect.</li><li class="bulllist1" id="u0030">•  A partial method is <i>synchronous</i> if it waits for another method to overlap its call interval. For example, in a synchronous pool, a method call that adds an item to the pool is blocked until that item is removed by another method call. Symmetrically, a method call that removes an item from the pool is blocked until another method call makes an item available to be removed. Synchronous pools are used for communication in programming languages such as CSP and Ada, in which threads <i>rendezvous</i> to exchange information.</li></ul></li><li class="bulllist" id="u0035">•  Pools provide different <i>fairness</i> guarantees. They may be FIFO (i.e., a queue) or last-in-first-out (LIFO) (i.e., a stack), or have other, typically weaker, properties. The importance of fairness when buffering using a pool is clear to anyone who has ever called a bank or a technical support line, only to be placed in a pool of waiting calls. The longer you wait, the more consolation you draw from the recorded message asserting that calls are answered in the order they arrive. Perhaps.</li></ul></div><p class="textfl"/></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>10.2 Queues</h2><p class="textfl" id="p0050">In this chapter, we consider a kind of pool that provides <i>first-in-first-out</i> (FIFO) fairness. A sequential <img alt="Image" height="11" src="images/B9780124159501000203/fx007.jpg" width="52"/> is an ordered sequence of items (of type <img alt="Image" height="9" src="images/B9780124159501000203/fx008.jpg" width="5"/>). It provides an <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>(<i>x</i>) method that puts item <i>x</i> at one end of the queue, called the <i>tail</i>, and a <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method that removes and returns the item at the other end of the queue, called the <i>head</i>. A concurrent queue is linearizable to a sequential queue. Queues are pools where <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() implements <img alt="Image" height="11" src="images/B9780124159501000203/fx004.jpg" width="18"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() implements <img alt="Image" height="11" src="images/B9780124159501000203/fx005.jpg" width="19"/>(). We use queue implementations to illustrate a number of important principles. In later chapters we consider pools that provide other fairness guarantees.</p></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>10.3 A bounded partial queue</h2><p class="textfl" id="p0055">For simplicity, we assume it is illegal to add a <i>null</i> value to a queue. Of course, there may be circumstances where it makes sense to add and remove <i>null</i> values; we leave it as an exercise to adapt our algorithms to accommodate <i>null</i> values.</p><p class="text" id="p0060"><span aria-label="Page 231" epub:type="pagebreak" id="page_231" role="doc-pagebreak"/>How much concurrency can we expect a bounded queue implementation with multiple concurrent enqueuers and dequeuers to provide? Informally, the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods operate on opposite ends of the queue; as long as the queue is neither full nor empty, an <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() call and a <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() call should be able to proceed without interference. For the same reason, concurrent <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() calls probably will interfere, and the same holds for <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() calls. This informal reasoning may sound convincing, and it is mostly correct, but realizing this level of concurrency is nontrivial.</p><p class="text" id="p0065">Here, we implement a bounded queue as a linked list. (We could also have used an array.) <a href="#f0015" id="cf0025">Fig. 10.2</a> shows the queue's fields and constructor, and <a href="#f0020" id="cf0030">Fig. 10.3</a> shows a queue node. <a href="#f0025" id="cs0010">Figs. 10.4</a> and <a href="#f0030">10.5</a> show the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods. Like the lists studied in Chapter <a href="B9780124159501000197.xhtml">9</a>, a queue node has <img alt="Image" height="9" src="images/B9780124159501000203/fx012.jpg" width="32"/> and <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> fields.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="290" src="images/B9780124159501000203/gr002.jpg" width="309"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.2</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx011.jpg" width="79"/> class: fields and constructor.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="125" src="images/B9780124159501000203/gr003.jpg" width="199"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.3</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx011.jpg" width="79"/> class: list node.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="372" src="images/B9780124159501000203/gr004.jpg" width="248"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.4</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx011.jpg" width="79"/> class: the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="405" src="images/B9780124159501000203/gr005.jpg" width="301"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.5</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx011.jpg" width="79"/> class: the <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method.</div></figcaption></figure></div><p class="text" id="p0070"><span aria-label="Page 232" epub:type="pagebreak" id="page_232" role="doc-pagebreak"/>As shown in <a href="#f0035" id="cf0035">Fig. 10.6</a>, the queue has <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> fields that respectively refer to the first and last nodes in the list. The queue always contains at least one node, and the first node is a <i>sentinel</i>. Like the sentinel nodes in Chapter <a href="B9780124159501000197.xhtml">9</a>, it marks a position in the queue (in this case, the head of the queue), but its value is meaningless. Unlike the list algorithms in Chapter <a href="B9780124159501000197.xhtml">9</a>, in which the same nodes always act as sentinels, the queue repeatedly replaces the sentinel node. The abstraction map for this algorithm carries a list of nodes to a queue with the items referred to by the nonsentinel nodes in the list in the same order as they appear in the list. The item referred to by the first node is <i>not</i> in the abstract queue. The abstract queue is empty if there is only one node in the list (i.e., if <img alt="Image" height="9" src="images/B9780124159501000203/fx016.jpg" width="111"/>).</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="208" src="images/B9780124159501000203/gr006.jpg" width="438"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.6</span> The <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods of the <img alt="Image" height="11" src="images/B9780124159501000203/fx011.jpg" width="79"/> with four slots. First a node is enqueued into the queue by acquiring the <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/>. The <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() checks that the <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> is 3, which is less than the bound. It then redirects the <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field of the node referenced by the <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field (step 1), redirects <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> to the new node (step 2), increments the <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> to 4, and releases the lock. Since <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> is now 4, any further calls to <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() will cause the threads to block until the <img alt="Image" height="9" src="images/B9780124159501000203/fx019.jpg" width="105"/> is signaled by some <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>(). Next, a node is dequeued from the queue by some thread. The <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() acquires the <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/>, reads the new value <i>b</i> from the successor of the node referenced by <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> (this node is the current sentinel), redirects <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> to this successor node (step 3), decrements the <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> to 3, and releases the lock. Before completing the <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>(), because the <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> was 4 when it started, the thread acquires the <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> and signals any enqueuers waiting on <img alt="Image" height="9" src="images/B9780124159501000203/fx019.jpg" width="105"/> that they can proceed.</div></figcaption></figure></div><p class="text" id="p0075">We use two locks, <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> and <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/>, to ensure that at any time, at most one enqueuer and at most one dequeuer can manipulate the queue object's fields. Using two locks instead of one allows an enqueuer to not lock out a dequeuer unnecessarily, and vice versa. Each lock has an associated <i>condition</i>: <img alt="Image" height="9" src="images/B9780124159501000203/fx019.jpg" width="105"/> for <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> is used to notify waiting enqueuers when the queue is no longer full; <img alt="Image" height="11" src="images/B9780124159501000203/fx021.jpg" width="112"/> for <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/> is used to notify waiting dequeuers when the queue is no longer empty.</p><p class="text" id="p0080">To keep the queue bounded, we must prevent items from being enqueued when the queue is at capacity. The <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> field is an <img alt="Image" height="11" src="images/B9780124159501000203/fx022.jpg" width="87"/> that <span aria-label="Page 233" epub:type="pagebreak" id="page_233" role="doc-pagebreak"/>tracks the number of objects currently in the queue. This field is decremented by <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() calls and incremented by <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() calls. We use an <img alt="Image" height="11" src="images/B9780124159501000203/fx022.jpg" width="87"/> because this field is not protected by either lock: An enqueuer and a dequeuer may access it concurrently.</p><p class="text" id="p0085">To enqueue an item, a thread acquires the <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> (line 30), and reads the <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> field (line 32). If that field is equal to the capacity, the queue is full, and the enqueuer must wait until a dequeuer makes room. The enqueuer waits on <img alt="Image" height="9" src="images/B9780124159501000203/fx019.jpg" width="105"/> (line 33), releasing the <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> temporarily, and blocking until that condition is signaled. Each time the thread awakens, it checks whether there is room; if not, it goes back to sleep.</p><p class="text" id="p0090">Once the enqueuer determines there is room, it can proceed to completion. No other thread can fill the queue while the enqueue is in progress: All other enqueuers are locked out, and concurrent dequeuers only increase the space available.</p><p class="text" id="p0095">We must carefully check that this implementation does not suffer from the kind of “lost-wakeup” bug described in Chapter <a href="B9780124159501000185.xhtml">8</a>. Care is needed because an enqueuer encounters a full queue in two steps: First, it sees that <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> is the queue capacity, and second, it waits on <span aria-label="Page 234" epub:type="pagebreak" id="page_234" role="doc-pagebreak"/><img alt="Image" height="9" src="images/B9780124159501000203/fx019.jpg" width="105"/> until there is room in the queue. When a dequeuer changes the queue from full to nonfull, it acquires <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> and signals <img alt="Image" height="9" src="images/B9780124159501000203/fx019.jpg" width="105"/>. Even though the <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> field is not protected by the <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/>, the dequeuer acquires the <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> before it signals the condition, so the dequeuer cannot signal between the enqueuer's two steps.</p><p class="text" id="p0100">To dequeue an item, a thread acquires the <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/> and checks whether the queue is empty. However, unlike in the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method, a dequeuer does not read the <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> field. Instead, it checks whether <img alt="Image" height="9" src="images/B9780124159501000203/fx016.jpg" width="111"/> (line 55); if so, the abstract queue is empty and the thread must wait until an item is enqueued. Like in the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method, the dequeuer waits on <img alt="Image" height="11" src="images/B9780124159501000203/fx021.jpg" width="112"/>, which temporarily releases <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/>, and blocks until the condition is signaled. Each time the thread awakens, it checks whether the queue is empty, and if so, goes back to sleep.</p><p class="text" id="p0105">Once a dequeuer establishes that the queue is nonempty, the queue will remain nonempty for the duration of the <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() call, because all other dequeuers have been locked out. Because the queue is nonempty, it has a nonsentinel node; the dequeuer accesses the first such node (i.e., the node referenced by the sentinel node's <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field). It reads this node's <img alt="Image" height="9" src="images/B9780124159501000203/fx012.jpg" width="32"/> field, and makes the node the new sentinel node by setting the queue's <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> to refer to it. The dequeuer then decrements <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> and releases the <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/>. If the dequeuer found the former size was the queue capacity, then there may be enqueuers waiting on <img alt="Image" height="11" src="images/B9780124159501000203/fx021.jpg" width="112"/>, so the dequeuer acquires <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/>, and signals all such threads to wake up.</p><p class="text" id="p0110"><span aria-label="Page 235" epub:type="pagebreak" id="page_235" role="doc-pagebreak"/>Note that the abstract queue's last item is not always the one in the node referenced by <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/>. An item is logically added to the queue as soon as the last node's <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field is redirected to the new node, even if the enqueuer has not yet updated <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> (i.e., an <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() call linearizes to line 34). For example, suppose a thread is in the process of inserting a new node: It has acquired the <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> and redirected the last node to point to the new node, but has not yet redirected the <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field. A concurrent dequeuing thread could acquire the <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/>, read and return the new node's value, redirect the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> to the new node, and decrement <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/>, all before the enqueuer redirects <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> to the newly inserted node. In this example, <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> would be negative temporarily because the dequeuer decrements it before the enqueuer increments it. The enqueuer need not wake any waiting dequeuers in this case, because the item it enqueued has already been dequeued.</p><p class="text" id="p0115">One drawback of this implementation is that concurrent <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() calls interfere with each other, but not through locks. All method calls apply <img alt="Image" height="10" src="images/B9780124159501000203/fx023.jpg" width="90"/>() or <img alt="Image" height="11" src="images/B9780124159501000203/fx024.jpg" width="99"/>() calls to the <img alt="Image" height="9" src="images/B9780124159501000203/fx018.jpg" width="25"/> field. These methods are more expensive than ordinary reads and writes, and they could cause a sequential bottleneck.</p><p class="text" id="p0120">We can reduce such interactions by splitting this field into two: <img alt="Image" height="11" src="images/B9780124159501000203/fx025.jpg" width="72"/> is an integer field incremented by <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>(), and <img alt="Image" height="11" src="images/B9780124159501000203/fx026.jpg" width="72"/> is an integer field decremented by <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>(); the actual size of the queue is the sum of these two counters (<img alt="Image" height="11" src="images/B9780124159501000203/fx026.jpg" width="72"/> is always 0 or negative). A thread calling <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() tests <img alt="Image" height="11" src="images/B9780124159501000203/fx025.jpg" width="72"/>, and as long as it is less than the capacity, it proceeds. When the field reaches capacity, the thread locks <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/>, adds <img alt="Image" height="11" src="images/B9780124159501000203/fx026.jpg" width="72"/> to <img alt="Image" height="11" src="images/B9780124159501000203/fx025.jpg" width="72"/>, and resets <img alt="Image" height="11" src="images/B9780124159501000203/fx026.jpg" width="72"/> to 0. Instead of synchronizing on every method call, this technique synchronizes sporadically when the enqueuer's size estimate becomes too large.</p></section><section><h2 class="h1hd" id="s0025"><a id="st0035"/>10.4 An unbounded total queue</h2><p class="textfl" id="p0125">We now describe an implementation of an unbounded queue. The <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method always enqueues its item, and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() throws <img alt="Image" height="11" src="images/B9780124159501000203/fx027.jpg" width="91"/> if there is no item to dequeue. The representation is the same as the bounded queue, except there is no need to count the number of items in the queue, or to provide conditions on which to wait. As shown in <a href="#f0040" id="cs0015">Figs. 10.7</a> and <a href="#f0045">10.8</a>, this algorithm is simpler than the bounded algorithm.</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="159" src="images/B9780124159501000203/gr007.jpg" width="168"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.7</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx028.jpg" width="113"/> class: the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="224" src="images/B9780124159501000203/gr008.jpg" width="250"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.8</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx028.jpg" width="113"/> class: the <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method.</div></figcaption></figure></div><p class="text" id="p0130">This queue cannot deadlock, because each method acquires only one lock, either <img alt="Image" height="11" src="images/B9780124159501000203/fx017.jpg" width="46"/> or <img alt="Image" height="11" src="images/B9780124159501000203/fx020.jpg" width="46"/>. A sentinel node alone in the queue will never be deleted, so each <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() call will succeed as soon as it acquires the lock. Of course, a <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method may fail if the queue is empty (i.e., if <img alt="Image" height="9" src="images/B9780124159501000203/fx029.jpg" width="59"/> is <i>null</i>). As in the bounded queue implementation, an item is actually enqueued when the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() call sets the last node's <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field to the new node, even before <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() resets <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> to refer to the new node. After that instant, the new item is reachable along a chain of the <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> references. As usual, the queue's actual head and tail are not necessarily the items referenced by <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/>. Instead, the actual head is the item reference by the successor of <span aria-label="Page 236" epub:type="pagebreak" id="page_236" role="doc-pagebreak"/><img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/>, and the actual tail is the last item reachable from the head. Both the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods are total as they do not wait for the queue to become empty or full.</p></section><section><h2 class="h1hd" id="s0030"><a id="st0040"/>10.5 A lock-free unbounded queue</h2><p class="textfl" id="p0135">We now describe a lock-free unbounded queue implementation. <a href="#f0050" id="cs0020">Figs. 10.9</a>–<a href="#f0065">10.12</a> show the <img alt="Image" height="11" src="images/B9780124159501000203/fx030.jpg" width="106"/> class, a natural extension of the unbounded total queue of Section <a href="#s0025" id="cf0040">10.4</a>. It prevents method calls from starving by having the quicker threads help the slower threads.</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="142" src="images/B9780124159501000203/gr009.jpg" width="238"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.9</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx031.jpg" width="99"/> class: fields and constructor.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="125" src="images/B9780124159501000203/gr010.jpg" width="291"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.10</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx030.jpg" width="106"/> class: list node.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="273" src="images/B9780124159501000203/gr011.jpg" width="329"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.11</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx030.jpg" width="106"/> class: the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="307" src="images/B9780124159501000203/gr012.jpg" width="293"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.12</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx030.jpg" width="106"/> class: the <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method.</div></figcaption></figure></div><p class="text" id="p0140">As before, we represent the queue as a list of nodes, in which the first node is a sentinel whose value is meaningless. However, as shown in <a href="#f0050" id="cs0025">Figs. 10.9</a> and <a href="#f0055">10.10</a><span aria-label="Page 237" epub:type="pagebreak" id="page_237" role="doc-pagebreak"/><span aria-label="Page 238" epub:type="pagebreak" id="page_238" role="doc-pagebreak"/>, <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> fields are <img alt="Image" height="9" src="images/B9780124159501000203/fx032.jpg" width="140"/> fields that refer to the first node and the last node in the queue, respectively, and each node's <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field is an <img alt="Image" height="9" src="images/B9780124159501000203/fx032.jpg" width="140"/> that refers to the next node in the list. The queue constructor creates a new sentinel node and sets both <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> to refer to it.</p><p class="text" id="p0145">The <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method (<a href="#f0060" id="cf0045">Fig. 10.11</a>) creates a new node (line 19), locates the last node in the queue (lines 21–22), and then updates the list to append the new node. This method is <i>lazy</i>: It does the update in two distinct steps, illustrated in <a href="#f0070" id="cf0050">Fig. 10.13</a>:</p><div><ol><li class="numlist" id="o0010">1.  it calls <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> to append the new node (line 25), and then</li><li class="numlist" id="o0015">2.  it calls <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> to change the queue's <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field from the prior last node to the new last node (line 26).</li></ol></div><p class="textfl"> Because these two steps are not executed atomically, every other method call must be prepared to encounter a half-finished <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() call, and to finish the job. This is a real-world example of the “helping” technique we first saw in the universal construction of Chapter <a href="B978012415950100015X.xhtml">6</a>.</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="158" src="images/B9780124159501000203/gr013.jpg" width="483"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.13</span> The <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods of the <img alt="Image" height="11" src="images/B9780124159501000203/fx034.jpg" width="85"/>. The <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method is lazy: a node is inserted into the queue in two steps. First, a <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> call changes the <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field of the node referenced by the queue's <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> from <i>null</i> to the new node. Then a <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> call advances <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> itself to refer to the new node. An item is removed from the queue by checking that the sentinel has a successor, and then calling <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> to redirect <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> from the current sentinel to its successor, making the latter the new sentinel. The item removed is the one referred to by the new sentinel. Both <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods help complete unfinished <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> updates.</div></figcaption></figure></div><p class="text" id="p0160">We now review all the steps in detail. An enqueuer thread <i>A</i> creates a new node with the new value to be enqueued (line 19), and finds the node that appears to be last by reading <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> (line 21–23). To verify that the node found is indeed last, <i>A</i> checks that it has no successor (line 24). If so, <i>A</i> attempts to append the new node by calling <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> (line 25). (A <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> is required because other threads may be trying the same thing.) <span aria-label="Page 239" epub:type="pagebreak" id="page_239" role="doc-pagebreak"/>If the <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> succeeds, <i>A</i> uses a second <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> to advance <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> to the new node (line 26). Even if this second <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> call fails, <i>A</i> can still return successfully because, as we will see, this <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> fails only if some other thread “helped” <i>A</i> by advancing <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/>.</p><p class="text" id="p0165">If the tail node has a successor (line 29), then some other enqueuer must have appended its node but not updated <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> before <i>A</i> read it. In this case, <i>A</i> tries to “help” that other thread by advancing <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> to refer directly to the successor (line 30) before trying again to insert its own node.</p><p class="text" id="p0170">This <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() is total, meaning that it never waits for a dequeuer. A successful <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() is linearized at the instant where the executing thread (or a concurrent helping thread) successfully calls <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> to redirect the <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field to the new node at line 30.</p><p class="text" id="p0175">The <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method is similar to its counterpart from the <img alt="Image" height="11" src="images/B9780124159501000203/fx035.jpg" width="92"/>. If the queue is nonempty, the dequeuer calls <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> to change <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> from the sentinel node to its successor, making the successor the new sentinel node. The <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method makes sure that the queue is not empty in the same way as before: by checking that the <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field of the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> node is not <i>null</i>.</p><p class="text" id="p0180">There is, however, a subtle issue in the lock-free case, depicted in <a href="#f0075" id="cf0055">Fig. 10.14</a>: Before advancing <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/>, a dequeuer must make sure that <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> is not left referring to the sentinel node that is about to be removed from the queue. To avoid this problem we add a test: If <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> equals <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> (line 41) and the (sentinel) node they refer to has a <i>nonnull</i> <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field (line 42), then the <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> is deemed to be lagging behind. In this case, as in the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method, the dequeuer attempts to help make <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> consistent by swinging it to the sentinel node's successor (line 45), and only then updates <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> to remove the sentinel (line 48). As in the partial queue, the value is read from the successor of the sentinel node (line 47). If this method returns a value, <span aria-label="Page 240" epub:type="pagebreak" id="page_240" role="doc-pagebreak"/>then its linearization point occurs when it successfully appends a node to the list (i.e., when the <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> at line 48 succeeds); otherwise it is linearized when it saw that the sentinel node has no successor (i.e., when it got a <i>null</i> value at line 39).</p><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="152" src="images/B9780124159501000203/gr014.jpg" width="206"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.14</span> Why dequeuers must help advance <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> in line 45 of <a href="#f0065" id="cf0010">Fig. 10.12</a>. Consider the scenario in which a thread enqueuing node <i>b</i> has redirected <i>a</i>'s <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field to <i>b</i>, but has yet to redirect <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> from <i>a</i> to <i>b</i>. If another thread starts dequeuing, it will read <i>b</i>'s value and redirect <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> from <i>a</i> to <i>b</i>, effectively removing node <i>a</i> while <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> still refers to it. To avoid this problem, the dequeuing thread must help advance <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> from <i>a</i> to <i>b</i> before redirecting <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/>.</div></figcaption></figure></div><p class="text" id="p0185">It is easy to check that the resulting queue is lock-free. Every method call first checks for an incomplete <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() call, and tries to complete it. In the worst case, all threads are trying to advance the queue's <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field, and one of them must succeed. A thread fails to enqueue or dequeue a node only if another thread's method call succeeds in changing the reference, so some method call always completes. As it turns out, being lock-free substantially enhances the performance of queue implementations, and lock-free algorithms often outperform the most efficient blocking ones.</p></section><section><h2 class="h1hd" id="s0035"><a id="st0045"/>10.6 Memory reclamation and the ABA problem</h2><p class="textfl" id="p0190">Our queue implementations so far rely on the Java garbage collector to recycle nodes after they have been dequeued. What happens if we choose to do our own memory management? There are several reasons why we might want to do this. Languages such as C or C++ do not provide garbage collection. Even if garbage collection is available, it is often more efficient for a class to do its own memory management, particularly if it creates and releases many small objects. Finally, if the garbage collection process is not lock-free, we might want to supply our own lock-free memory reclamation.</p><p class="text" id="p0195">A natural way to recycle nodes in a lock-free manner is to have each thread maintain its own private (i.e., thread-local) <i>free list</i> of unused queue entries.</p><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" class="img" height="43" src="images/B9780124159501000203/fx036.jpg" width="325"/></figure></div><p class="textfl"><span aria-label="Page 241" epub:type="pagebreak" id="page_241" role="doc-pagebreak"/> When an enqueuing thread needs a new node, it tries to remove one from its thread-local free list. If the free list is empty, it simply allocates a node using the <img alt="Image" height="6" src="images/B9780124159501000203/fx037.jpg" width="20"/> operator. When a dequeuing thread is ready to retire a node, it links it back onto the thread-local list. Because the list is thread-local, there is no need for expensive synchronization. This design works well as long as each thread performs roughly the same number of enqueues and dequeues. If there is an imbalance, then there may be a need for more complex techniques, such as periodically stealing nodes from other threads.</p><p class="text" id="p0200">Surprisingly, perhaps, the lock-free queue will not work if nodes are recycled in the most straightforward way. Consider the scenario depicted in <a href="#f0085" id="cf0060">Fig. 10.15</a>. <span aria-label="Page 242" epub:type="pagebreak" id="page_242" role="doc-pagebreak"/>In part (a), the dequeuing thread <i>A</i> observes the sentinel node is <i>a</i>, and the next node is <i>b</i>. It then prepares to update <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> by calling <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> with old value <i>a</i> and new value <i>b</i>. Before it takes another step, other threads dequeue <i>b</i> and its successor, placing both <i>a</i> and <i>b</i> in the free pool. Node <i>a</i> is recycled, and eventually reappears as the sentinel node in the queue, as depicted in part (b). The thread now wakes up, calls <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/>, and succeeds, since the old value of the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> is indeed <i>a</i>. Unfortunately, it has redirected <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> to a recycled node!</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="433" src="images/B9780124159501000203/gr015.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.15</span> An ABA scenario: Assume that we use local pools of recycled nodes in our lock-free queue algorithm. In part (a), the dequeuer thread <i>A</i> observes that the sentinel node is <i>a</i>, and next node is <i>b</i>. (Step 1) It then prepares to update <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> by applying a <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> with old value <i>a</i> and new value <i>b</i>. (Step 2) Suppose, however, that before it takes another step, other threads dequeue <i>b</i>, then its successor, placing both <i>a</i> and <i>b</i> in the free pool. In part (b), (Step 3) node <i>a</i> is reused, and eventually reappears as the sentinel node in the queue. (Step 4) Thread <i>A</i> now wakes up, calls <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/>, and succeeds in setting <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> to <i>b</i>, since the old value of <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> is indeed <i>a</i>. Now, <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> is incorrectly set to a recycled node.</div></figcaption></figure></div><p class="text" id="p0205">This phenomenon is called the <i>ABA problem</i>. It shows up often, especially in dynamic memory algorithms that use conditional synchronization operations such as <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/>. Typically, a reference about to be modified by a <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> changes from <i>a</i> to <i>b</i> and back to <i>a</i> again. As a result, the <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> call succeeds even though its effect on the data structure has changed, and no longer has the desired effect.</p><p class="text" id="p0210">One straightforward way to fix this problem is to tag each atomic reference with a unique <i>stamp</i>. An <span class="inlinecode">AtomicStampedReference&lt;T&gt;</span> object, described in detail in <a href="#enun0010" id="cf0065">Pragma 10.6.1</a>, encapsulates both a reference to an object of Type <img alt="Image" height="9" src="images/B9780124159501000203/fx008.jpg" width="5"/> and an integer <i>stamp</i>. These fields can be atomically updated either together or individually.</p><p class="text" id="p0215"/><div class="boxg1" id="enun0010"><p class="b1num">Pragma 10.6.1 </p><div><p class="b1textfl" id="p0220">The <img alt="Image" height="11" src="images/B9780124159501000203/fx038.jpg" width="167"/> class encapsulates both a reference to an object of Type <img alt="Image" height="9" src="images/B9780124159501000203/fx008.jpg" width="5"/> and an integer <i>stamp</i>. It generalizes the <span class="inlinecode">AtomicMarkableReference&lt;T&gt;</span> class (<a href="B9780124159501000197.xhtml">Pragma 9.8.1</a>), replacing the Boolean <i>mark</i> with an integer stamp.</p><p class="b1text" id="p0225">We most commonly use this stamp as a <i>version number</i> to avoid the ABA problem, incrementing the value of the stamp each time we modify the object. Sometimes, as in the <img alt="Image" height="11" src="images/B9780124159501000203/fx039.jpg" width="126"/> class of Chapter <a href="B9780124159501000215.xhtml">11</a>, we use the stamp to hold one of a finite set of states.</p><p class="b1text" id="p0230">The stamp and reference fields can be updated atomically, either together or individually. For example, the <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> method tests expected reference and stamp values, and if both tests succeed, replaces them with updated reference and stamp values. The <img alt="Image" height="11" src="images/B9780124159501000203/fx005.jpg" width="19"/>() method has an unusual interface: It returns the object's reference value and stores the stamp value in an integer array argument. <a href="#f0090" id="cf0070">Fig. 10.16</a> illustrates the signatures for these methods.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="126" src="images/B9780124159501000203/gr016.jpg" width="313"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.16</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx038.jpg" width="167"/> class: the <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> and <img alt="Image" height="11" src="images/B9780124159501000203/fx005.jpg" width="19"/>() methods. The <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> method tests and updates both the stamp and reference fields; the <img alt="Image" height="11" src="images/B9780124159501000203/fx005.jpg" width="19"/>() method returns the encapsulated reference and stores the stamp at position 0 in the argument array; the <img alt="Image" height="11" src="images/B9780124159501000203/fx040.jpg" width="79"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx041.jpg" width="52"/>() methods return the reference and stamp, respectively; and the <img alt="Image" height="11" src="images/B9780124159501000203/fx004.jpg" width="18"/>() method updates the encapsulated reference and the stamp.</div></figcaption></figure></div><p class="b1text" id="p0235">In a language like C or C++, one could provide this functionality efficiently in a 64-bit architecture by “stealing” bits from pointers. A 32-bit architecture would probably require a level of indirection.</p></div></div><p class="textfl"/><p class="text" id="p0240"><a href="#f0095" id="cf0075">Fig. 10.17</a> shows the <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method using the <img alt="Image" height="11" src="images/B9780124159501000203/fx043.jpg" width="187"/> to avoid the ABA problem. Each time through the loop, it reads both the reference and stamp values for the first, next, and last nodes (lines 6–8). It uses <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> to compare both the reference and the stamp (line 18). It increments the stamp each time it uses <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> to update a reference (lines 15 and 18).<sup><a epub:type="noteref" href="#fn001" id="cf0080" role="doc-noteref">1</a></sup><span aria-label="Page 243" epub:type="pagebreak" id="page_243" role="doc-pagebreak"/><span aria-label="Page 244" epub:type="pagebreak" id="page_244" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="421" src="images/B9780124159501000203/gr017.jpg" width="378"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.17</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx042.jpg" width="153"/> class: The <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method uses stamps to avoid ABA.</div></figcaption></figure></div><p class="text" id="p0245">The ABA problem can occur in many synchronization scenarios, not just those involving conditional synchronization. For example, it can occur when using only loads and stores. Conditional synchronization operations such as <i>load-linked/store-conditional</i>, available on some architectures (see Appendix <a href="B978012415950100032X.xhtml">B</a>), avoid the ABA problem by testing not whether a value is the same at two points in time, but whether the value has ever changed between those points.</p><section><h3 class="h2hd" id="s0040"><a id="st0050"/>10.6.1 A naïve synchronous queue</h3><p class="textfl" id="p0250">We now turn our attention to an even tighter kind of synchronization. One or more <i>producer</i> threads produce items to be removed, in FIFO order, by one or more <i>consumer</i> threads. Here, however, producers and consumers <i>rendezvous</i> with one another: A producer that puts an item in the queue blocks until that item is removed by a consumer, and vice versa. Such rendezvous synchronization is built into languages such as CSP and Ada.</p><p class="text" id="p0255"><a href="#f0100" id="cf0085">Fig. 10.18</a> shows he <img alt="Image" height="11" src="images/B9780124159501000203/fx044.jpg" width="127"/> class, a straightforward monitor-based synchronous queue implementation. It has the following fields: <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> is the first item waiting to be dequeued, <img alt="Image" height="11" src="images/B9780124159501000203/fx046.jpg" width="59"/> is a Boolean value used by enqueuers to synchronize among themselves, <img alt="Image" height="9" src="images/B9780124159501000203/fx047.jpg" width="25"/> is the lock used for mutual exclusion, and <img alt="Image" height="9" src="images/B9780124159501000203/fx048.jpg" width="58"/> is used to block partial methods. If the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method finds <img alt="Image" height="11" src="images/B9780124159501000203/fx046.jpg" width="59"/> to be <i>true</i> (line 10), then another enqueuer has supplied an item and is waiting to rendezvous with a dequeuer, so the enqueuer repeatedly releases the lock, sleeps, and, when it awakens, checks whether <img alt="Image" height="11" src="images/B9780124159501000203/fx046.jpg" width="59"/> has become <i>false</i> (line 11). When this condition is satisfied, the enqueuer sets <img alt="Image" height="11" src="images/B9780124159501000203/fx046.jpg" width="59"/> to <i>true</i>, which locks out other enqueuers until the current rendezvous is complete, and sets <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> to refer to the new item (lines 12–13). It then notifies any waiting threads (line 14), and waits until <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> becomes <i>null</i> (lines 15–16). When the wait is over, the rendezvous has occurred, so the enqueuer sets <img alt="Image" height="11" src="images/B9780124159501000203/fx046.jpg" width="59"/> to <i>false</i>, notifies any waiting threads, and returns (lines 17 and 19).</p><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="586" src="images/B9780124159501000203/gr018.jpg" width="226"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.18</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx044.jpg" width="127"/> class.</div></figcaption></figure></div><p class="text" id="p0260">The <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method simply waits until <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> is not <i>null</i> (lines 26–27), records the item, sets the <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> field to <i>null</i>, and notifies any waiting threads before returning the item (lines 28–31).</p><p class="text" id="p0265">Although the design of the queue is relatively simple, it incurs a high synchronization cost. Whenever one thread might wake up another, both enqueuers and dequeuers wake up all waiting threads, leading to a number of wakeups quadratic in the number of waiting threads. Although it is possible to use multiple condition objects to reduce the number of wakeups, it is still necessary to block on every call, which is expensive.<span aria-label="Page 245" epub:type="pagebreak" id="page_245" role="doc-pagebreak"/><span aria-label="Page 246" epub:type="pagebreak" id="page_246" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>10.7 Dual data structures</h2><p class="textfl" id="p0270">To reduce the synchronization overheads of the synchronous queue, we consider an alternative synchronous queue implementation that treats <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods symmetrically, splitting a <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method call that finds the queue empty into two steps. In the first step, the dequeuer puts a <i>reservation</i> object in the queue, indicating that the dequeuer is waiting for an enqueuer with which to rendezvous. The reservation object contains an empty slot, on which the dequeuer spins until the slot is occupied; an enqueuer <i>fulfills</i> the reservation by depositing an item into that slot. Similarly, when an enqueuer adds an item to the queue, if there is no reservation to fulfill, it spins on the item until it is removed by a dequeuer. The queue contains either only items waiting to be dequeued or only reservations waiting to be fulfilled, or it is empty; it never contains items and reservations at the same time.</p><p class="text" id="p0275">This structure is called a <i>dual data structure</i>, because it can contain both items and reservations. It has a number of nice properties. First, waiting threads can spin on a locally cached flag, which we have seen is essential for scalability. Second, it ensures fairness in a natural way. Reservations are queued in the order they arrive, ensuring that requests are fulfilled in the same order. Note that this data structure is linearizable, since each partial method call can be ordered when it is fulfilled.</p><p class="text" id="p0280">The queue is implemented as a list of nodes, where a node represents either an item waiting to be dequeued, or a reservation waiting to be fulfilled (<a href="#f0105" id="cf0090">Fig. 10.19</a>). A node's <img alt="Image" height="11" src="images/B9780124159501000203/fx050.jpg" width="25"/> field indicates which. At any time, all nodes in the queue have the same type: Either the queue consists entirely of items waiting to be dequeued, or entirely of reservations waiting to be fulfilled.</p><div class="pageavoid"><figure class="fig" id="f0105"><img alt="Image" height="174" src="images/B9780124159501000203/gr019.jpg" width="288"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.19</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx049.jpg" width="154"/> class: queue node.</div></figcaption></figure></div><p class="text" id="p0285">When an item is enqueued, the node's <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> field holds the item, which is reset to <i>null</i> when that item is dequeued. When a reservation is enqueued, the node's <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> field is <i>null</i>, and is reset to an item when fulfilled by an enqueuer.</p><p class="text" id="p0290"><a href="#f0110" id="cf0095">Fig. 10.20</a> shows the <img alt="Image" height="11" src="images/B9780124159501000203/fx051.jpg" width="133"/>'s constructor and <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method. (The <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method is symmetric.) As in earlier queues we have considered, the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> field always refers to a <i>sentinel</i> node that serves as a placeholder, and whose actual value (and type) is unimportant. The queue is empty when <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> refer to the same node (i.e., the sentinel node). The constructor creates a sentinel node with an arbitrary value, referred to by both <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/>.</p><div class="pageavoid"><figure class="fig" id="f0110"><img alt="Image" height="569" src="images/B9780124159501000203/gr020.jpg" width="391"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.20</span> The <img alt="Image" height="11" src="images/B9780124159501000203/fx049.jpg" width="154"/> class: <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method and constructor.</div></figcaption></figure></div><p class="text" id="p0295">The <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method first checks whether the queue is empty or contains enqueued items waiting to be dequeued (line 21). If so, then just as in the lock-free queue, it reads the queue's <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field (line 22), and checks that the values read are consistent (line 23). If the <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field does not refer to the last node in the queue, then the method advances the <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field and starts over (lines 24–25). Otherwise, the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method tries to append the new node to the end of the queue by resetting the tail node's <img alt="Image" height="8" src="images/B9780124159501000203/fx013.jpg" width="25"/> field to refer to the new node (line 26). If it succeeds, it tries to advance <span aria-label="Page 247" epub:type="pagebreak" id="page_247" role="doc-pagebreak"/>the tail to the newly appended node (line 27), and then spins, waiting for a dequeuer to announce that it has dequeued the item by setting the node's <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> field to <i>null</i>. Once the item is dequeued, the method tries to clean up by making its node the new sentinel. This last step serves only to enhance performance, because the implementation remains correct, whether or not the method advances the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> reference.</p><p class="text" id="p0300">If, however, the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method discovers that the queue contains dequeuers' reservations waiting to be fulfilled, then it tries to find a reservation <span aria-label="Page 248" epub:type="pagebreak" id="page_248" role="doc-pagebreak"/>to fulfill. Since the queue's <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> node is a sentinel with no meaningful value, <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() reads the head's successor (line 36), checks that the values it has read are consistent (lines 37–39), and tries to switch that node's <img alt="Image" height="9" src="images/B9780124159501000203/fx045.jpg" width="25"/> field from <i>null</i> to the item being enqueued. Whether or not this step succeeds, the method tries to advance <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> (line 41). If the <img alt="Image" height="12" src="images/B9780124159501000203/fx033.jpg" width="97"/> call succeeds (line 40), the method returns; otherwise it retries.</p></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>10.8 Chapter notes</h2><p class="textfl" id="p0305">The partial queue employs a mixture of techniques adapted from Doug Lea <a epub:type="noteref" href="#br0550" id="cf0100" role="doc-noteref">[110]</a> and from an algorithm by Maged Michael and Michael Scott <a epub:type="noteref" href="#br0625" id="cf0105" role="doc-noteref">[125]</a>. The lock-free queue is a slightly simplified version of a queue algorithm by Maged Michael and Michael Scott <a epub:type="noteref" href="#br0625" id="cf0110" role="doc-noteref">[125]</a>. The synchronous queue implementations are adapted from algorithms by Bill Scherer, Doug Lea, and Michael Scott <a epub:type="noteref" href="#br0835" id="cf0115" role="doc-noteref">[167]</a>.</p></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>10.9 Exercises</h2><p class="textfl" id="p0310"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 10.1 </p><div><p class="b1textfl" id="p0315">Change the <img alt="Image" height="11" src="images/B9780124159501000203/fx049.jpg" width="154"/> class to work correctly with <i>null</i> items.</p></div></div><p class="textfl"/><p class="text" id="p0320"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 10.2 </p><div><p class="b1textfl" id="p0325">Consider the queue presented in <a href="#f0115" id="cf0120">Fig. 10.21</a>, a variant of the simple lock-free queue for a single enqueuer and a single dequeuer described in Chapter <a href="B9780124159501000124.xhtml">3</a>. This queue is blocking; that is, removing an item from an empty queue, or adding an item to a full one, causes the threads to spin. Surprisingly, this queue requires only loads and stores and not a more powerful read–modify–write synchronization operation.</p><div class="pageavoid"><figure class="fig" id="f0115"><img alt="Image" height="306" src="images/B9780124159501000203/gr021.jpg" width="303"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.21</span> A lock-free FIFO queue with blocking semantics for a single enqueuer and single dequeuer. The queue is implemented in an array. Initially the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> fields are equal and the queue is empty. If the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> differ by <img alt="Image" height="11" src="images/B9780124159501000203/fx052.jpg" width="52"/>, then the queue is full. The <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method reads the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> field, and if the queue is full, it repeatedly checks the <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> until the queue is no longer full. It then stores the object in the array, and increments the <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field. The <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method works in a symmetric way.</div></figcaption></figure></div><p class="b1text" id="p0330">Does the queue implementation, however, require the use of a memory barrier? If so, where in the code is such a barrier needed and why? If not, explain why not.</p></div></div><p class="textfl"/><p class="text" id="p0335"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 10.3 </p><div><p class="b1textfl" id="p0340">Design a bounded lock-based queue implementation using an array instead of a linked list.</p><div><ol><li class="b1numlist" id="o0020">1.  Allow parallelism by using two separate locks for <img alt="Image" height="9" src="images/B9780124159501000203/fx014.jpg" width="25"/> and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/>.</li><li class="b1numlist" id="o0025">2.  Try to transform your algorithm to be lock-free. Where do you run into difficulty?</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0355"/><div class="boxg1" id="enun0030"><p class="b1num">Exercise 10.4 </p><div><p class="b1textfl" id="p0360">In the <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method of the unbounded lock-based queue (<a href="#f0045" id="cf0125">Fig. 10.8</a>), is it necessary to hold the lock when checking that the queue is not empty? Explain.</p></div></div><p class="textfl"/><p class="text" id="p0365"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 10.5 </p><div><p class="b1textfl" id="p0370">In Dante's <i>Inferno</i>, he describes a visit to Hell. In a recently discovered chapter, he encounters five people sitting at a table with a pot of stew in the middle. Although each one holds a spoon that reaches the pot, each spoon's handle is much longer than each person's arm, so no one can feed him- or herself. They are famished and desperate.</p><p class="b1text" id="p0375">Dante then suggests: “Why do you not feed one another?”</p><p class="b1text" id="p0380">The rest of the chapter is lost.</p><div><ol><li class="b1numlist" id="o0030">1.  <span aria-label="Page 249" epub:type="pagebreak" id="page_249" role="doc-pagebreak"/>Write an algorithm to allow these unfortunates to feed one another. Two or more people may not feed the same person at the same time. Your algorithm must be, well, starvation-free.</li><li class="b1numlist" id="o0035">2.  Discuss the advantages and disadvantages of your algorithm. Is it centralized or decentralized, high or low in contention, and deterministic or randomized?</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0395"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 10.6 </p><div><p class="b1textfl" id="p0400">Consider the linearization points of the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods of the lock-free queue (<a href="#f0060" id="cs0030">Figs.10.11</a> and <a href="#f0065">10.12</a>).</p><div><ol><li class="b1numlist" id="o0040">1.  Can we choose the point at which the returned value is read from a node as the linearization point of a successful <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>()? Explain.</li><li class="b1numlist" id="o0045">2.  Can we choose the linearization point of the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() method to be the point at which the <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> field is updated, possibly by other threads? Explain.</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0415"/><div class="boxg1" id="enun0045"><p class="b1num">Exercise 10.7 </p><div><p class="b1textfl" id="p0420">Consider the unbounded queue implementation shown in <a href="#f0120" id="cf0130">Fig. 10.22</a>. This queue is blocking, meaning that the <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() method does not return until it has found an item to dequeue.</p><div class="pageavoid"><figure class="fig" id="f0120"><img alt="Image" height="322" src="images/B9780124159501000203/gr022.jpg" width="276"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 10.22</span> Queue used in <a href="#enun0045" id="cf0015">Exercise 10.7</a>.</div></figcaption></figure></div><p class="b1text" id="p0425">The queue has two fields: <img alt="Image" height="9" src="images/B9780124159501000203/fx053.jpg" width="31"/> is a very large array, and <img alt="Image" height="9" src="images/B9780124159501000203/fx015.jpg" width="23"/> is the index of the next unused element in the array.</p><div><ol><li class="b1numlist" id="o0050">1.  Are the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>()<span aria-label="Page 250" epub:type="pagebreak" id="page_250" role="doc-pagebreak"/> and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods wait-free? If not, are they lock-free? Explain.</li><li class="b1numlist" id="o0055">2.  Identify linearization points for the <img alt="Image" height="9" src="images/B9780124159501000203/fx009.jpg" width="19"/>() and <img alt="Image" height="11" src="images/B9780124159501000203/fx010.jpg" width="19"/>() methods. (Careful! They may be execution-dependent.)</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0810"><h2 class="reftitle" id="st0070">Bibliography</h2><p class="reflist2" epub:type="biblioentry footnote" id="br0550" role="doc-biblioentry">[110] Doug Lea,  Java community process, JSR 166, concurrency utilities,   <a href="http://www.jcp.org/en/jsr/detail?id=166">http://www.jcp.org/en/jsr/detail?id=166</a>; 2003.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0625" role="doc-biblioentry">[125] M.M. Michael, M.L. Scott,  Simple, fast and practical non-blocking and blocking concurrent queue algorithms,   <i>Proc. of the Fifteenth Annual ACM Symposium on Principles of Distributed Computing</i>.  ACM Press; 1996:267–275.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0835" role="doc-biblioentry">[167] William N. Scherer III, Doug Lea, Michael L. Scott,  Scalable synchronous queues,   <i>PPoPP '06: Proceedings of the Eleventh ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</i>.  New York, NY, USA: ACM Press; 2006:147–156.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0080" role="doc-noteref">1 </a></sup> <a id="np0010"/>“For simplicity, we ignore the (remote) possibility that the stamp could wrap around and cause an error.”</p></div></section></footer></section></body></html>