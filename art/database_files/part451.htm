<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>25.4  Standardization</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part450.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part452.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 72pt;text-indent: 0pt;text-align: left;"><a name="bookmark555">25.4  </a><span style=" color: #00AEEF;">Standardization</span><a name="bookmark585">&zwnj;</a></p><p class="s63" style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Standards <span class="p">deﬁne the interface of a software system. For example, standards deﬁne the syntax and semantics of a programming language, or the functions in an application- program interface, or even a data model (such as the object-oriented database stan- dards). Today, database systems are complex, and they are often made up of multiple independently created parts that need to interact. For example, client programs may be created independently of backend systems, but the two must be able to interact with each other. A company that has multiple heterogeneous database systems may need to exchange data between the databases. Given such a scenario, standards play an impor- tant role.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;"><span class="s63">Formal standards </span>are those developed by a standards organization or by industry groups through a public process. Dominant products sometimes become <span class="s63">de facto stan- dards</span>, in that they become generally accepted as standards without any formal process of recognition. Some formal standards, like many aspects of the <span class="s44">SQL-92 </span>and <span class="s44">SQL:1999 </span>standards, are <span class="s63">anticipatory standards </span>that lead the marketplace; they deﬁne features that vendors then implement in products. In other cases, the standards, or parts of the standards, are <span class="s63">reactionary standards</span>, in that they attempt to standardize features that some vendors have already implemented, and that may even have become de facto standards. <span class="s44">SQL-89 </span>was in many ways reactionary, since it standardized features, such as integrity checking, that were already present in the <span class="s44">IBM SAA SQL </span>standard and in other databases.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Formal standards committees are typically composed of representatives of the ven- dors and of members from user groups and standards organizations such as the Inter- national Organization for Standardization (<span class="s44">ISO</span>) or the American National Standards Institute (<span class="s44">ANSI</span>), or professional bodies, such as the Institute of Electrical and Electron- ics Engineers (<span class="s44">IEEE</span>). Formal standards committees meet periodically, and members present proposals for features to be added to or modiﬁed in the standard. After a (usu- ally extended) period of discussion, modiﬁcations to the proposal, and public review, members vote on whether to accept or reject a feature. Some time after a standard has been deﬁned and implemented, its shortcomings become clear and new requirements become apparent. The process of updating the standard then begins, and a new version of the standard is usually released after a few years. This cycle usually repeats every few years, until eventually (perhaps many years later) the standard becomes technologically irrelevant or loses its user base.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">This section gives a very high-level overview of diﬀerent standards, concentrating on the goals of the standard. Detailed descriptions of the standards mentioned in this section appear in the bibliographic notes for this chapter, available online.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">25.4.1 SQL Standards</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Since <span class="s44">SQL </span>is the most widely used query language, much work has been done on stan- dardizing it. <span class="s44">ANSI </span>and <span class="s44">ISO</span>, with the various database vendors, have played a leading</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">role in this work. The <span class="s44">SQL-86 </span>standard was the initial version. The <span class="s44">IBM </span>Systems Appli- cation Architecture (<span class="s44">SAA</span>) standard for <span class="s44">SQL </span>was released in 1987. As people identiﬁed the need for more features, updated versions of the formal <span class="s44">SQL </span>standard were devel- oped, called <span class="s44">SQL-89 </span>and <span class="s44">SQL-92</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s44">SQL:1999 </span>version of the <span class="s44">SQL </span>standard added a variety of features to <span class="s44">SQL</span>. We have seen many of these features in earlier chapters.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">Subsequent versions of the <span class="s44">SQL </span>standard include the following:</p><p class="s41" style="padding-top: 9pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>SQL:2003<span class="s40">, which is a minor extension of the </span>SQL:1999 <span class="s40">standard. Some features such as the </span>SQL:1999 OLAP <span class="s40">features (Section 11.3.3) were speciﬁed as an amend- ment to the earlier version of the </span>SQL:1999 <span class="s40">standard, instead of waiting for the release of </span>SQL:2003<span class="s40">.</span></p><p class="s41" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;"><span class="s39">• </span>SQL:2006<span class="s40">, which added several features related to </span>XML<span class="s40">.</span></p><p class="s41" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>SQL:2008<span class="s40">, which introduced only minor extensions to the </span>SQL <span class="s40">language such as extensions to the </span><span class="s49">merge </span><span class="p">clause.</span></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s41">SQL:2011</span><span class="s40">, which added a number of temporal extensions to </span><span class="s41">SQL</span><span class="s40">, including the ability to associate time periods with tuples, optionally using existing columns as start and end times, and primary key deﬁnitions based on the time periods. The extensions support deletes and updates with associated periods; such deletes and updates may result in modiﬁcation of the time period of existing tuples, along with deletes or inserts of new tuples. A number of operators related to time periods, such as </span><span class="s49">overlaps </span>and <span class="s49">contains</span>, were also introduced in <span class="s44">SQL:2011</span>.</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">In addition, the standard provided a number of other features, such as further extensions to the <span class="s49">merge </span>construct, extensions to the window constructs that were introduced in earlier versions of <span class="s44">SQL</span>, and extensions to limit the number of results fetched by a query, using a <span class="s49">fetch </span>clause.</p><p class="s41" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>SQL:2016<span class="s40">, which added a number of features related to </span>JSON <span class="s40">support, and support for the aggregate operation </span><span class="s49">listagg</span><span class="p">, which concatenates attributes from a group of tuples into a string.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">It is worth mentioning that most of the new features are supported by only a few database systems, and conversely most database systems support a number of features that are not part of the standard.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">25.4.2 Database Connectivity Standards</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <span class="s64">ODBC </span>standard is a widely used standard for communication between client appli- cations and database systems and deﬁnes <span class="s44">API</span>s in several languages. The <span class="s44">JDBC </span>standard for communication between Java applications and databases was modeled on <span class="s44">ODBC </span>and provides similar functionality.</p><p class="s42" style="padding-left: 87pt;text-indent: 0pt;text-align: right;">ODBC <span class="s43">is based on the </span>SQL <span class="s63">Call Level Interface </span><span class="p">(</span><span class="s64">CLI</span><span class="p">) standards developed by the</span></p><p style="text-indent: 0pt;text-align: right;"><span class="s63">X/Open </span>industry consortium and the <span class="s44">SQL </span>Access Group, but it has several extensions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The <span class="s44">ODBC API </span>deﬁnes a <span class="s44">CLI</span>, an <span class="s44">SQL </span>syntax deﬁnition, and rules about permissible sequences of <span class="s44">CLI </span>calls. The standard also deﬁnes conformance levels for the <span class="s44">CLI </span>and the <span class="s44">SQL </span>syntax. For example, the core level of the <span class="s44">CLI </span>has commands to connect to a database, to prepare and execute <span class="s44">SQL </span>statements, to get back results or status values, and to manage transactions. The next level of conformance (level 1) requires support for catalog information retrieval and some other features over and above the core-level <span class="s44">CLI</span>; level 2 requires further features, such as the ability to send and retrieve arrays of parameter values and to retrieve more detailed catalog information.</p><p class="s42" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">ODBC <span class="s43">allows a client to connect simultaneously to multiple data sources and to switch among them, but transactions on each are independent; </span>ODBC <span class="s43">does not support two-phase commit.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A distributed system provides a more general environment than a client– server system. The X/Open consortium has also developed the <span class="s63">X/Open </span><span class="s82">XA </span><span class="s63">standards </span>for interoperation of databases. These standards deﬁne transaction-management primi- tives (such as transaction begin, commit, abort, and prepare-to-commit) that compliant databases should provide; a transaction manager can invoke these primitives to imple- ment distributed transactions by two-phase commit. The <span class="s44">XA </span>standards are independent of the data model and of the speciﬁc interfaces between clients and databases to ex- change data. Thus, we can use the <span class="s44">XA </span>protocols to implement a distributed transaction system in which a single transaction can access relational as well as object-oriented databases, yet the transaction manager ensures global consistency via two-phase com- mit.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">There are many data sources that are not relational databases, and in fact may not be databases at all. Examples are ﬂat ﬁles and email stores. Microsoft’s <span class="s64">OLE-DB </span>is a C++ <span class="s44">API </span>with goals similar to <span class="s44">ODBC</span>, but for nondatabase data sources that may provide only limited querying and update facilities. Just like <span class="s44">ODBC</span>, <span class="s44">OLE-DB </span>provides constructs for connecting to a data source, starting a session, executing commands, and getting back results in the form of a rowset, which is a set of result rows.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <span class="s63">ActiveX Data Objects </span>(<span class="s64">ADO</span>) and <span class="s64">ADO.NET </span><span class="s42">API</span><span class="s43">s, created by Microsoft, provide an interface to access data from not only relational databases, but also some other types of data sources, such as </span><span class="s42">OLE-DB </span><span class="s43">data sources.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">25.4.3 Object Database Standards</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Standards in the area of object-oriented databases (<span class="s44">OODB</span>) have so far been driven primarily by <span class="s44">OODB </span>vendors. The <span class="s63">Object Database Management Group </span>(<span class="s64">ODMG</span>) was a group formed by <span class="s44">OODB </span>vendors to standardize the data model and language interfaces to <span class="s44">OODB</span>s. <span class="s44">ODMG </span>is no longer active. <span class="s44">JDO </span>is a standard for adding persistence to Java. There were several other attempts to standardize object databases and related object-based technologies such as services. However, most were not widely adopted,</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">and they are rarely used anymore.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Object-relational mapping technologies, which store data in relational databases at the back end but provide programmers with an object-based <span class="s44">API </span>to access and manip-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><a name="bookmark556">ulate data, have proven quite popular. Systems that support object-relational mapping include Hibernate, which supports Java, and the data layer of the popular Django Web framework, which is based on the Python programming language. However, there are no widely accepted formal standards in this area.</a><a name="bookmark586">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part450.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part452.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
