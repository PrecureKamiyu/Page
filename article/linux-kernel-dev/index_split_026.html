<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1108197" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_74"><span class="bold">17. Devices and Modules</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1108362"> </div>
<p class="calibre_2">In this chapter, we discuss four kernel components related to device drivers and device management:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <strong class="calibre3">Device types—</strong>Classifications used in all Unix systems to unify behavior of common devices</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <strong class="calibre3">Modules—</strong>The mechanism by which the Linux kernel can load and unload object code on demand</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <strong class="calibre3">Kernel objects—</strong>Support for adding simple object-oriented behavior and a parent/child relationship to kernel data structures</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <strong class="calibre3">Sysfs—</strong>A filesystem representation of the system’s device tree</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1109367"> </div>
<h3 class="calibre_21"><span class="bold">Device Types</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">In Linux, as with all Unix systems, devices are classified into one of three types:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Block devices</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Character devices</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Network devices</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Often abbreviated <em class="calibre4">blkdevs</em>, <em class="calibre4">block devices</em> are addressable in device-specified chunks called <em class="calibre4">blocks</em> and generally support <em class="calibre4">seeking</em>, the random access of data. Example block devices include hard drives, Blu-ray discs, and memory devices such as flash. Block devices are accessed via a special file called a <em class="calibre4">block device node</em> and generally mounted as a filesystem. We discuss filesystems in <a href="index_split_022.html#filepos870716">Chapter 13</a>, “The Virtual Filesystem,” and block devices in <a href="index_split_023.html#filepos961208">Chapter 14</a>, “The Block I/O Layer.”</p><div class="calibre_3"> </div>
<p class="calibre_2">Often abbreviated <em class="calibre4">cdevs</em>, character devices are generally not addressable, providing access to data only as a stream, generally of characters (bytes). Example character devices include keyboards, mice, printers, and most pseudo-devices. Character devices are accessed via a special file called a <em class="calibre4">character device node</em>. Unlike with block devices, applications interact with character devices directly through their device node.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1111066"></a>Sometimes called <em class="calibre4">Ethernet devices</em> after the most common type of network devices, <em class="calibre4">network devices</em> provide access to a network (such as the Internet) via a physical adapter (such as your laptop’s 802.11 card) and a specific protocol (such as IP). Breaking Unix’s “everything is a file” design principle, network devices are not accessed via a device node but with a special interface called the <em class="calibre4">socket API</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Linux provides a handful of other device types, but they are specialized to a single task and not common. One exception is <em class="calibre4">miscellaneous devices</em>, often abbreviated <em class="calibre4">miscdevs</em>, which are actually a simplified form of character devices. Miscellaneous devices enable a device driver author to represent simple devices easily, trading functionality for common infrastructure.</p><div class="calibre_3"> </div>
<p class="calibre_2">Not all device drivers represent physical devices. Some device drivers are <em class="calibre4">virtual</em>, providing access to kernel functionality. We call these <em class="calibre4">pseudo devices</em>; some of the most common are the <em class="calibre4">kernel random number generator</em> (accessible at <code class="calibre6"><span class="calibre7">/dev/random</span></code> and <code class="calibre6"><span class="calibre7">/dev/urandom</span></code>), the <em class="calibre4">null device</em> (accessible at <code class="calibre6"><span class="calibre7">/dev/null</span></code>), the <em class="calibre4">zero device</em> (accessible at <code class="calibre6"><span class="calibre7">/dev/zero</span></code>), the <em class="calibre4">full device</em> (accessible at <code class="calibre6"><span class="calibre7">/dev/full</span></code>), and the <em class="calibre4">memory device</em> (accessible at <code class="calibre6"><span class="calibre7">/dev/mem</span></code>). Most device drivers, however, represent physical hardware.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1112834"> </div>
<h3 class="calibre_21"><span class="bold">Modules</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Despite being “monolithic,” in the sense that the whole kernel runs in a single address space, the Linux kernel is modular, supporting the dynamic insertion and removal of code from itself at runtime. Related subroutines, data, and entry and exit points are grouped together in a single binary image, a loadable kernel object, called a <em class="calibre4">module</em>. Support for modules allows systems to have only a minimal base kernel image, with optional features and drivers supplied via loadable, separate objects. Modules also enable the removal and reloading of kernel code, facilitate debugging, and allow for the loading of new drivers on demand in response to the hot plugging of new devices.</p><div class="calibre_3"> </div>
<p class="calibre_2">This chapter looks at the magic behind modules in the kernel and how you can write your own module.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1113845"> </div>
<h4 class="calibre_27"><span class="calibre3">Hello, World!</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Unlike development on core subsystems of the kernel—which is much of the material discussed thus far—module development is more like writing a new application, at least in the sense that modules have entry points and exit points and live in their own files.</p><div class="calibre_3"> </div>
<p class="calibre_2">It might be cliché, but it would be a travesty to have the opportunity to write a <em class="calibre4">Hello, World!</em> and not capitalize on the occasion. Here is a <em class="calibre4">Hello, World!</em> kernel module:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00232.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos1114612"></a>This is as simple a kernel module as one can get. The <code class="calibre6"><span class="calibre7">hello_init()</span></code> function is registered as this module’s entry point via <code class="calibre6"><span class="calibre7">module_init()</span></code>. The kernel invokes <code class="calibre6"><span class="calibre7">hello_init()</span></code> when the module is loaded. The call to <code class="calibre6"><span class="calibre7">module_init()</span></code>is not actually a function call but a macro that assigns its sole parameter as the initialization function for this module. All <code class="calibre6"><span class="calibre7">init</span></code> functions must have the form,</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int my_init(void);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Because <code class="calibre6"><span class="calibre7">init</span></code> functions are typically not directly invoked by external code, you don’t need to export the function beyond file-level scope, and it can be marked as <code class="calibre6"><span class="calibre7">static</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Init functions return an <code class="calibre6"><span class="calibre7">int</span></code>. If initialization (or whatever your init function does) was successful, the function must return zero. On failure, the function must unwind any initialization and return nonzero.</p><div class="calibre_3"> </div>
<p class="calibre_2">This init function merely prints a simple message and returns zero. In actual modules, init functions register resources, initialize hardware, allocate data structures, and so on. If this file were compiled statically into the kernel image, the init function would be stored in the kernel image and run on kernel boot.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">module_exit()</span></code> function registers a module’s exit point. In this example, we register the function <code class="calibre6"><span class="calibre7">hello_exit()</span></code>. The kernel invokes the exit point when the module is removed from memory. Exit functions might free resources, shutdown and reset hardware, <a id="filepos1116641"></a>and perform other cleanup before returning. Simply put, exit functions are responsible for undoing whatever the <code class="calibre6"><span class="calibre7">init</span></code> function and lifetime of the module did—essentially cleaning up after the module. After the exit function returns, the module is unloaded.</p><div class="calibre_3"> </div>
<p class="calibre_2">Exit functions must have the form</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void my_exit(void);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">As with the <code class="calibre6"><span class="calibre7">init</span></code> function, you probably want to mark it <code class="calibre6"><span class="calibre7">static</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">If this file were compiled into the static kernel image, the exit function would <em class="calibre4">not</em> be included, and it would <em class="calibre4">never</em> be invoked because if it were not a module, the code could never be removed from memory.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">MODULE_LICENSE()</span></code> macro specifies the copyright license for this file. Loading a non-GPL module into memory results in the tainted flag being set in the kernel. The copyright license serves two purposes. First, it is for informational purposes; many kernel developers give bug reports less credence when the tainted flag is set in an oops, because they presume a binary-only module (that is, a module that they cannot debug) was loaded into the kernel. Second, non-GPL modules cannot invoke GPL-only symbols. We cover GPL-only symbols in the section “<a href="#filepos1150367">Exported Symbols</a>” later in this chapter.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, the <code class="calibre6"><span class="calibre7">MODULE_AUTHOR()</span></code> and <code class="calibre6"><span class="calibre7">MODULE_DESCRIPTION()</span></code> macros provide, respectively, the module’s author and a brief description of the module. The value of these macros is entirely informational.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1118693"> </div>
<h4 class="calibre_27"><span class="calibre3">Building Modules</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">In the 2.6 kernel, building modules is easier than in previous versions, thanks to the new <em class="calibre4">kbuild</em> build system. The first decision in building modules is deciding where the module source is to live. You can add the module source to the kernel source proper, either as a patch or by eventually merging your code into the official tree. Alternatively, you can maintain and build your module source outside the source tree.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1119291"> </div>
<h5 class="calibre_29"><span class="calibre3">Living in the Source Tree</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">Ideally, your module is an official part of Linux and thus lives in the kernel source tree. Getting your work into the kernel proper might require more work at first, but it is the preferred path because when your code is in the Linux kernel, the entire kernel community can help maintain and debug it.</p><div class="calibre_3"> </div>
<p class="calibre_2">When you decide to place your module in the kernel source tree, the next step is deciding <em class="calibre4">where</em> in the tree your module is to live. Drivers are stored in subdirectories of the <code class="calibre6"><span class="calibre7">drivers/</span></code> directory in the root of the kernel source tree. Inside <code class="calibre6"><span class="calibre7">drivers/</span></code>, class, type, and specific device further organize drivers. For example, drivers for character devices live in <code class="calibre6"><span class="calibre7">drivers/char/</span></code>, block devices live in <code class="calibre6"><span class="calibre7">drivers/block/</span></code>, and USB devices live in <code class="calibre6"><span class="calibre7">drivers/usb/</span></code>. The rules are flexible because many devices belong in multiple categories—for instance, many USB devices are character devices, but they reside in <code class="calibre6"><span class="calibre7">drivers/usb/</span></code> not <code class="calibre6"><span class="calibre7">drivers/char/</span></code>. Despite such complications, when you get the hang of it, the organization is understandable and descriptive.</p><div class="calibre_3"> </div>
<p class="calibre_2">Let’s assume you have a character device and want to store it in <code class="calibre6"><span class="calibre7">drivers/char/</span></code>. Inside this directory are numerous C source files and a handful of other directories. Drivers with only one or two source files might simply stick their source in this directory. Drivers with multiple source files or other accompanying data might create a new subdirectory. There is no hard and fast rule. Presume that you want to create your own subdirectory. Let’s further assume that your driver is for a fishing pole with a computer interface, the Fish Master XL 3000, so you need to create a <code class="calibre6"><span class="calibre7">fishing</span></code> subdirectory inside <code class="calibre6"><span class="calibre7">drivers/char/</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Next, you need to add a line to the Makefile in <code class="calibre6"><span class="calibre7">drivers/char/</span></code>. So you edit <code class="calibre6"><span class="calibre7">drivers/char/Makefile</span></code> and add</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">obj-m += fishing/</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This causes the build system to descend into the <code class="calibre6"><span class="calibre7">fishing/</span></code> subdirectory whenever it compiles modules. More likely, your driver’s compilation is contingent on a specific configuration option; for example, perhaps <code class="calibre6"><span class="calibre7">CONFIG_FISHING_POLE</span></code> (see the section “<a href="#filepos1133690">Managing Configuration Options</a>” later in this chapter for how to add a new configuration option). In that case, you would instead add the line</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">obj-$(CONFIG_FISHING_POLE) += fishing/</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Finally, inside <code class="calibre6"><span class="calibre7">drivers/char/fishing/</span></code>, you add a new Makefile with the following line:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">obj-m += fishing.o</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The build system now descends into <code class="calibre6"><span class="calibre7">fishing/</span></code> and builds the module <code class="calibre6"><span class="calibre7">fishing.ko</span></code> from <code class="calibre6"><span class="calibre7">fishing.c</span></code>. Yes, confusingly, you write an extension of <code class="calibre6"><span class="calibre7">.o</span></code> but the module is compiled as <code class="calibre6"><span class="calibre7">.ko</span></code>. As before, more likely your fishing pole driver’s compilation is conditional on a configuration option. So you probably want to write the following:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">obj-$(CONFIG_FISHING_POLE) += fishing.o</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">One day, your fishing pole driver might get so complicated—autodetection of fishing line test is just the latest “must have!”—that it grows to occupy more than one source file. No problem, anglers! You simply make your Makefile read the following:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">obj-$(CONFIG_FISHING_POLE) += fishing.o<br class="calibre1"/>fishing-objs := fishing-main.o fishing-line.o</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Now, <code class="calibre6"><span class="calibre7">fishing-main.c</span></code> and <code class="calibre6"><span class="calibre7">fishing-line.c</span></code> will be compiled and linked into <code class="calibre6"><span class="calibre7">fishing.ko</span></code> whenever <code class="calibre6"><span class="calibre7">CONFIG_FISHING_POLE</span></code> is set.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, you might need to pass to the C compiler additional compile flags during the build process solely for your file. To do so, simply add a line such as the following to your Makefile:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">EXTRA_CFLAGS += -DTITANIUM_POLE</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If you opted to place your source file(s) in <code class="calibre6"><span class="calibre7">drivers/char/</span></code> and not create a new subdirectory, you would merely place the preceding lines (that you placed in your Makefile in <code class="calibre6"><span class="calibre7">drivers/char/fishing/</span></code>) into <code class="calibre6"><span class="calibre7">drivers/char/Makefile</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1125219"></a>To compile, run the kernel build process as usual. If your module’s build was conditioned on a configuration option, as it was with <code class="calibre6"><span class="calibre7">CONFIG_FISHING_POLE</span></code>, make sure that the option is enabled before beginning.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1125518"> </div>
<h5 class="calibre_29"><span class="calibre3">Living Externally</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">If you prefer to maintain and build your module outside the kernel source tree, to live the life of an outsider, simply create a Makefile in your own source directory with this single line:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">obj-m := fishing.o</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This compiles <code class="calibre6"><span class="calibre7">fishing.c</span></code> into <code class="calibre6"><span class="calibre7">fishing.ko</span></code>. If your source spans multiple files, two lines will suffice:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">obj-m := fishing.o<br class="calibre1"/>fishing-objs := fishing-main.o fishing-line.o</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This example compiles <code class="calibre6"><span class="calibre7">fishing-main.c</span></code> and <code class="calibre6"><span class="calibre7">fishing-line.c</span></code> into <code class="calibre6"><span class="calibre7">fishing.ko</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The main difference in living externally is the build process. Because your module lives outside the kernel tree, you need to instruct <code class="calibre6"><span class="calibre7">make</span></code> on how to find the kernel source files and base Makefile. This is also easy:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">make -C /kernel/source/location SUBDIRS=$PWD modules</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">In this example, <code class="calibre6"><span class="calibre7">/kernel/source/location</span></code> is the location of your configured kernel source tree. Recall that you should <em class="calibre4">not</em> store your working copy of the kernel source tree in <code class="calibre6"><span class="calibre7">/usr/src/linux</span></code> but somewhere else, easily accessible, in your home directory.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1127459"> </div>
<h4 class="calibre_27"><span class="calibre3">Installing Modules</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Compiled modules are installed into <code class="calibre6"><span class="calibre7">/lib/modules/</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">version</span></code></em><code class="calibre6"><span class="calibre7">/kernel/</span></code>, where each directory under <code class="calibre6"><span class="calibre7">kernel/</span></code> corresponds to the module’s location in the kernel source tree. For example, with a kernel version of 2.6.34, the compiled fishing pole module would live at <code class="calibre6"><span class="calibre7">/lib/modules/2.6.34/kernel/drivers/char/fishing.ko</span></code> if you stuck it directly in <code class="calibre6"><span class="calibre7">drivers/char/</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The following build command is used to install compiled modules into the correct location:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">make modules_install</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This needs to be run as root.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1128550"> </div>
<h4 class="calibre_27"><span class="calibre3">Generating Module Dependencies</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The Linux module utilities understand dependencies. This means that module <code class="calibre6"><span class="calibre7">chum</span></code> can depend on module <code class="calibre6"><span class="calibre7">bait</span></code>, and when you load the <code class="calibre6"><span class="calibre7">chum</span></code> module, the module loader automatically loads the <code class="calibre6"><span class="calibre7">bait</span></code> module. This dependency information must be generated. Most <a id="filepos1129071"></a>Linux distributions generate the mapping automatically and keep it up to date on each boot. To build the module dependency information, as root simply run</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">depmod</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">To perform a quick update, rebuilding only the information for modules newer than the dependency information, run as root</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">depmod -A</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The module dependency information is stored in the file <code class="calibre6"><span class="calibre7">/lib/modules/</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">version</span></code></em><code class="calibre6"><span class="calibre7">/modules.dep</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1129923"> </div>
<h4 class="calibre_27"><span class="calibre3">Loading Modules</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The simplest way to load a module is via <code class="calibre6"><span class="calibre7">insmod</span></code>. This utility is basic. It simply asks the kernel to load the module you specify. The <code class="calibre6"><span class="calibre7">insmod</span></code> program does not perform any dependency resolution or advanced error checking. Usage is trivial. As root, simply run this command:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">insmod <span><tt class="calibre6"><span class="calibre19">module.ko</span></tt></span></span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos1130612"></a>Here, <em class="calibre4"><code class="calibre6"><span class="calibre7">module.ko</span></code></em> is the filename of the module that you want to load. To load the fishing pole module, you would run this command as root:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">insmod fishing.ko</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">In a similar fashion, to remove a module, you use the <code class="calibre6"><span class="calibre7">rmmod</span></code> utility. As root, simply run the following, where <em class="calibre4"><code class="calibre6"><span class="calibre7">module</span></code></em> is the name of an already-loaded module:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">rmmod <span><tt class="calibre6"><span class="calibre19">module</span></tt></span></span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">For example, this command removes the fishing pole module:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">rmmod fishing</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">These utilities, however, are unintelligent. The utility <code class="calibre6"><span class="calibre7">modprobe</span></code> provides dependency resolution, error checking and reporting, configurable behavior, and more advanced features. Its use is highly encouraged.</p><div class="calibre_3"> </div>
<p class="calibre_2">To insert a module into the kernel via <code class="calibre6"><span class="calibre7">modprobe</span></code>, run as root:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">modprobe <span><tt class="calibre6"><span class="calibre19">module [ module parameters ]</span></tt></span></span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Here, <em class="calibre4"><code class="calibre6"><span class="calibre7">module</span></code></em> is the name of the module to load. Any following arguments are taken as parameters to pass to the module on load. See the section “<a href="#filepos1141594">Module Parameters</a>” for a discussion on module parameters.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">modprobe</span></code> command attempts to load not only the requested module, but also any modules on which it depends. Consequently, it is the preferred mechanism for loading kernel modules.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">modprobe</span></code> command can also be used to remove modules from the kernel. To remove a module, as root, run</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">modprobe –r <span><tt class="calibre6"><span class="calibre19">modules</span></tt></span></span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Here, <em class="calibre4"><code class="calibre6"><span class="calibre7">modules</span></code></em> specifies one or more modules to remove. Unlike <code class="calibre6"><span class="calibre7">rmmod</span></code>, <code class="calibre6"><span class="calibre7">modprobe</span></code> also removes any modules on which the given module depends, if they are unused. Section 8 of the Linux manual pages provides a reference on its other, less used, options.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1133690"> </div>
<h4 class="calibre_27"><span class="calibre3">Managing Configuration Options</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">An earlier section in this chapter looked at compiling the fishing pole module only if the <code class="calibre6"><span class="calibre7">CONFIG_FISHING_POLE</span></code> configuration option was set. Configuration options have been discussed in earlier chapters, too, but now let’s look at actually adding a new one, continuing with the fishing pole device driver example.</p><div class="calibre_3"> </div>
<p class="calibre_2">Thanks to the new “kbuild” system in the 2.6 kernel, adding new configuration options is easy. All you have to do is add an entry to the <code class="calibre6"><span class="calibre7">Kconfig</span></code> file responsible for the applicable branch of the kernel source tree. For drivers, this is usually the directory in which the source lives. If the fishing pole driver lives in <code class="calibre6"><span class="calibre7">drivers/char/</span></code>, you use <code class="calibre6"><span class="calibre7">drivers/char/Kconfig</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">If you <em class="calibre4">created</em> a new subdirectory and want a new <code class="calibre6"><span class="calibre7">Kconfig</span></code> file to live there, you need to source it from an existing <code class="calibre6"><span class="calibre7">Kconfig</span></code>. You do this by adding a line such as the following to an existing <code class="calibre6"><span class="calibre7">Kconfig</span></code> file:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">source "drivers/char/fishing/Kconfig"</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">In this example, you would add this line to <code class="calibre6"><span class="calibre7">drivers/char/Kconfig</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Entries in <code class="calibre6"><span class="calibre7">Kconfig</span></code> are easy to add. Our fishing pole module would look like this:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00233.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The first line defines what configuration option this entry represents. Note that the <code class="calibre6"><span class="calibre7">CONFIG_</span></code> prefix is assumed and <em class="calibre4">not</em> written.</p><div class="calibre_3"> </div>
<p class="calibre_2">The second line states that this option is a <em class="calibre4">tristate</em>, meaning that it can be built into the kernel (Y), built as a module (M), or not built at all (N). To remove the option of building as a module—say, if this option represented a feature and not a device driver—use the directive <code class="calibre6"><span class="calibre7">bool</span></code> instead of <code class="calibre6"><span class="calibre7">tristate</span></code>. The quoted text following the directive provides the name of this option in the various configuration utilities.</p><div class="calibre_3"> </div>
<p class="calibre_2">The third line specifies the default for this option, which is not built (<code class="calibre6"><span class="calibre7">n</span></code>). You can also specify the default as built into the kernel (<code class="calibre6"><span class="calibre7">y</span></code>) or built as a module (<code class="calibre6"><span class="calibre7">m</span></code>). For device drivers, the default is usually to not build it (<code class="calibre6"><span class="calibre7">n</span></code>).</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">help</span></code> directive signifies that the rest of the test, indented as it is, is the help text for this entry. The various configuration tools can display this text when requested. Because this text is for developers building their own kernels, it can be succinct and technical. End users do not typically build kernels and, if they did, they could presumably understand the configuration help.</p><div class="calibre_3"> </div>
<p class="calibre_2">There are other options, too. The <code class="calibre6"><span class="calibre7">depends</span></code> directive specifies options that must be set before this option can be set. If the dependencies are not met, the option is disabled. For example, if you added the following directive to the <code class="calibre6"><span class="calibre7">Kconfig</span></code> entry, the device driver could not be enabled (<code class="calibre6"><span class="calibre7">y</span></code> or <code class="calibre6"><span class="calibre7">m</span></code>) until the <code class="calibre6"><span class="calibre7">CONFIG_FISH_TANK</span></code> option is enabled:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">depends on FISH_TANK</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">select</span></code> directive is like <code class="calibre6"><span class="calibre7">depends</span></code>, except that it forces the given option if our option is selected. The <code class="calibre6"><span class="calibre7">select</span></code> directive should not be used as frequently as <code class="calibre6"><span class="calibre7">depends</span></code> because it automatically enables other configuration options. The following line enables <code class="calibre6"><span class="calibre7">CONFIG_BAIT</span></code> whenever <code class="calibre6"><span class="calibre7">CONFIG_FISHING_POLE</span></code> is enabled:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">select BAIT</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">For both <code class="calibre6"><span class="calibre7">select</span></code> and <code class="calibre6"><span class="calibre7">depends</span></code>, you can request multiple options via <code class="calibre6"><span class="calibre7">&amp;&amp;</span></code>. With <code class="calibre6"><span class="calibre7">depends</span></code>, you can also specify that an option <em class="calibre4">not</em> be enabled by prefixing the option with an exclamation mark. For example</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">depends on EXAMPLE_DRIVERS &amp;&amp; !NO_FISHING_ALLOWED</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This line specifies that the driver depends on <code class="calibre6"><span class="calibre7">CONFIG_EXAMPLE_DRIVERS</span></code> being set and <code class="calibre6"><span class="calibre7">CONFIG_NO_FISHING_ALLOWED</span></code> being unset.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">tristate</span></code> and <code class="calibre6"><span class="calibre7">bool</span></code> options can be followed by the directive <code class="calibre6"><span class="calibre7">if</span></code>, which makes the entire option conditional on another configuration option. If the condition is not met, the configuration option is not only disabled but also does not appear in the configuration utilities. For example, this directive instructs the configuration system to display an option only if <code class="calibre6"><span class="calibre7">CONFIG_OCEAN</span></code> is set. Here, <em class="calibre4">deep sea mode</em> is available only if <code class="calibre6"><span class="calibre7">CONFIG_OCEAN</span></code> is enabled:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">bool "Deep Sea Mode" if OCEAN</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">if</span></code> directive can also follow the <code class="calibre6"><span class="calibre7">default</span></code> directive, enforcing the default only if the conditional is met.</p><div class="calibre_3"> </div>
<p class="calibre_2">The configuration system exports several meta-options to help make configuration easier. The option <code class="calibre6"><span class="calibre7">CONFIG_EMBEDDED</span></code> is enabled only if the users specified that they want to see options designed for disabling key features (presumably to save precious memory on embedded systems). The option <code class="calibre6"><span class="calibre7">CONFIG_BROKEN_ON_SMP</span></code> is used to specify a driver that is not SMP-safe. Normally this option is not set, forcing the user to explicitly acknowledge the brokenness. New drivers, of course, should not use this flag. The option <code class="calibre6"><span class="calibre7">CONFIG_DEBUG_KERNEL</span></code> enables the selection of debugging-related options. Finally, the <code class="calibre6"><span class="calibre7">CONFIG_EXPERIMENTAL</span></code> option is used to flag options that are experimental or otherwise <a id="filepos1141412"></a>of beta quality. The option defaults to off, again forcing users to explicitly acknowledge the risk before they enable your driver.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1141594"> </div>
<h4 class="calibre_27"><span class="calibre3">Module Parameters</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The Linux kernel provides a simple framework, enabling drivers to declare parameters that the user can specify on either boot or module load and then have these parameters exposed in your driver as global variables. These module parameters also show up in sysfs (see later in this chapter). Consequently, creating and managing module parameters that can be specified in a myriad of convenient ways is trivial.</p><div class="calibre_3"> </div>
<p class="calibre_2">Defining a module parameter is done via the macro <code class="calibre6"><span class="calibre7">module_param()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">module_param(<span><tt class="calibre6"><span class="calibre19">name</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">type</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">perm</span></tt></span>);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Here, <em class="calibre4"><code class="calibre6"><span class="calibre7">name</span></code></em> is the name of both the parameter exposed to the user and the variable holding the parameter inside your module. The <em class="calibre4"><code class="calibre6"><span class="calibre7">type</span></code></em> argument holds the parameter’s data type; it is one of <code class="calibre6"><span class="calibre7">byte</span></code>, <code class="calibre6"><span class="calibre7">short</span></code>, <code class="calibre6"><span class="calibre7">ushort</span></code>, <code class="calibre6"><span class="calibre7">int</span></code>, <code class="calibre6"><span class="calibre7">uint</span></code>, <code class="calibre6"><span class="calibre7">long</span></code>, <code class="calibre6"><span class="calibre7">ulong</span></code>, <code class="calibre6"><span class="calibre7">charp</span></code>, <code class="calibre6"><span class="calibre7">bool</span></code>, or <code class="calibre6"><span class="calibre7">invbool</span></code>. These types are, respectively, a byte, a short integer, an unsigned short integer, an integer, an unsigned integer, a long integer, an unsigned long integer, a pointer to a <code class="calibre6"><span class="calibre7">char</span></code>, a Boolean, and a Boolean whose value is inverted from what the user specifies. The <code class="calibre6"><span class="calibre7">byte</span></code> type is stored in a single <code class="calibre6"><span class="calibre7">char</span></code> and the Boolean types are stored in variables of type <code class="calibre6"><span class="calibre7">int</span></code>. The rest are stored in the corresponding primitive C types. Finally, the <code class="calibre6"><span class="calibre7">perm</span></code> argument specifies the permissions of the corresponding file in sysfs. The permissions can be specified in the usual octal format, for example <code class="calibre6"><span class="calibre7">0644</span></code> (owner can read and write, group can read, everyone else can read), or by ORing together the usual <code class="calibre6"><span class="calibre7">S_Ifoo</span></code> defines, for example <code class="calibre6"><span class="calibre7">S_IRUGO | S_IWUSR</span></code> (everyone can read; user can also write). A value of zero disables the sysfs entry altogether.</p><div class="calibre_3"> </div>
<p class="calibre_2">The macro does not declare the variable for you. You must do that <em class="calibre4">before</em> using the macro. Therefore, typical use might resemble</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00234.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This would be in the outermost scope of your module’s source file. In other words, <code class="calibre6"><span class="calibre7">allow_live_bait</span></code> is global to the file.</p><div class="calibre_3"> </div>
<p class="calibre_2">It is possible to have the internal variable named differently than the external parameter. This is accomplished via <code class="calibre6"><span class="calibre7">module_param_named()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">module_param_named(<span><tt class="calibre6"><span class="calibre19">name</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">variable</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">type</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">perm</span></tt></span>);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Here, <code class="calibre6"><span class="calibre7">name</span></code> is the externally viewable parameter name, and <code class="calibre6"><span class="calibre7">variable</span></code> is the name of the internal global variable. For example</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static unsigned int max_test = DEFAULT_MAX_LINE_TEST;<br class="calibre1"/>module_param_named(maximum_line_test, max_test, int, 0);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Normally, you would use a type of <code class="calibre6"><span class="calibre7">charp</span></code> to define a module parameter that takes a string. The kernel copies the string provided by the user into memory and points your variable to the string. For example</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static char *name;<br class="calibre1"/>module_param(name, charp, 0);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If so desired, it is also possible to have the kernel copy the string directly into a character array that you supply. This is done via <code class="calibre6"><span class="calibre7">module_param_string()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">module_param_string(<span><tt class="calibre6"><span class="calibre19">name</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">string</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">len</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">perm</span></tt></span>);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Here, <code class="calibre6"><span class="calibre7">name</span></code> is the external parameter name, <code class="calibre6"><span class="calibre7">string</span></code> is the internal variable name, <code class="calibre6"><span class="calibre7">len</span></code> is the size of the buffer named by <code class="calibre6"><span class="calibre7">string</span></code> (or some smaller size, but that does not make much sense), and <code class="calibre6"><span class="calibre7">perm</span></code> is the sysfs permissions (or zero to disable a sysfs entry altogether). For example</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static char species[BUF_LEN];<br class="calibre1"/>module_param_string(specifies, species, BUF_LEN, 0);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">You can accept a comma-separated list of parameters stored in a C array via <code class="calibre6"><span class="calibre7">module_param_array()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">module_param_array(name, type, nump, perm);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Here, <code class="calibre6"><span class="calibre7">name</span></code> is again the external parameter and internal variable name, <code class="calibre6"><span class="calibre7">type</span></code> is the data type, and <code class="calibre6"><span class="calibre7">perm</span></code> is the sysfs permissions. The new argument, <code class="calibre6"><span class="calibre7">nump</span></code>, is a pointer to an integer in which the kernel stores the number of entries stored into the array. Note that the array pointed to by <code class="calibre6"><span class="calibre7">name</span></code> must be statically allocated. The kernel determines the array’s size at compile-time and ensures that it does not cause an overrun. Use is simple. For example</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static int fish[MAX_FISH];<br class="calibre1"/>static int nr_fish;<br class="calibre1"/>module_param_array(fish, int, &amp;nr_fish, 0444);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">You can name the internal array something different than the external parameter with <code class="calibre6"><span class="calibre7">module_param_array_named()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">module_param_array_named(<span><tt class="calibre6"><span class="calibre19">name</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">array</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">type</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">nump</span></tt></span>, <span><tt class="calibre6"><span class="calibre19">perm</span></tt></span>);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The parameters are identical to the other macros.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, you can document your parameters by using <code class="calibre6"><span class="calibre7">MODULE_PARM_DESC()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static unsigned short size = 1;<br class="calibre1"/>module_param(size, ushort, 0644);<br class="calibre1"/>MODULE_PARM_DESC(size, "The size in inches of the fishing pole.");</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">All these macros require the inclusion of <code class="calibre6"><span class="calibre7">&lt;linux/module.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1150367"> </div>
<h4 class="calibre_27"><span class="calibre3">Exported Symbols</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1150485"> </div>
<p class="calibre_2">When modules are loaded, they are dynamically linked into the kernel. As with user-space, dynamically linked binaries can call only into external functions explicitly <em class="calibre4">exported</em> for use. In the kernel, this is handled via special directives called <code class="calibre6"><span class="calibre7">EXPORT_SYMBOL()</span></code> and <code class="calibre6"><span class="calibre7">EXPORT_SYMBOL_GPL()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Exported functions are available for use by modules. Functions not exported cannot be invoked from modules. The linking and invoking rules are much more stringent for modules than code in the core kernel image. Core code can call any nonstatic interface in the kernel because all core source files are linked into a single base image. Exported symbols, of course, must be nonstatic, too. The set of exported kernel symbols are known as the <em class="calibre4">exported kernel interfaces</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Exporting a symbol is easy. After the function is declared, it is usually followed by an <code class="calibre6"><span class="calibre7">EXPORT_SYMBOL()</span></code>. For example</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00235.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Presuming that <code class="calibre6"><span class="calibre7">get_pirate_beard_color()</span></code> is also declared in an accessible header file, any module can now access it.</p><div class="calibre_3"> </div>
<p class="calibre_2">Some developers want their interfaces accessible to only GPL-compliant modules. The kernel linker enforces this restriction through use of the <code class="calibre6"><span class="calibre7">MODULE_LICENSE()</span></code> directive. If you want the previous function accessible to only modules that labeled themselves as GPL-licensed, use instead</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">EXPORT_SYMBOL_GPL(get_pirate_beard_color);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If your code is configurable as a module, you must ensure that when compiled as a module all interfaces that it uses are exported. Otherwise linking errors (and a broken module) result.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1152723"> </div>
<h3 class="calibre_21"><span class="bold">The Device Model</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">A significant new feature in the 2.6 Linux kernel is the addition of a unified <em class="calibre4">device model</em>. The device model provides a single mechanism for representing devices and describing their topology in the system. Such a system provides several benefits:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Minimization of code duplication</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A mechanism for providing common facilities, such as reference counting</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <a id="filepos1153447"></a>The capability to enumerate all the devices in the system, view their status, and see to what bus they attach</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The capability to generate a complete and valid tree of the entire device structure of the system, including all buses and interconnections</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The capability to link devices to their drivers and vice versa</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The capability to categorize devices by their class, such as input device, without the need to understand the physical device topology</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The capability to walk the tree of devices from the leaves up to the root, powering down devices in the correct order</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The initial motivation for the device model was this final point: providing an accurate device tree to facilitate power management. To implement device-level power management in the kernel, you need to build a tree representing the device topology in the system: for example, what drive connects to what controller, and what device connects to what bus. When powering down, the kernel must power down the lower (leaf) nodes of the tree before the higher nodes. For example, the kernel needs to turn off a USB mouse before it turns off the USB controller, and the kernel must power down the USB controller before the PCI bus. To do this accurately and efficiently for the entire system, the kernel needs a tree of devices.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1155188"> </div>
<h4 class="calibre_27"><span class="calibre3">Kobjects</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">At the heart of the device model is the <em class="calibre4">kobject</em>, short for <em class="calibre4">kernel object</em>, which is represented by <code class="calibre6"><span class="calibre7">struct kobject</span></code> and defined in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>. The kobject is similar to the <code class="calibre6"><span class="calibre7">Object</span></code> class in object-oriented languages such as C# or Java. It provides basic facilities, such as reference counting, a name, and a parent pointer, enabling the creation of a hierarchy of objects.</p><div class="calibre_3"> </div>
<p class="calibre_2">Without further ado:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00236.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">name</span></code> pointer points to the name of this kobject.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1156150"></a>The <code class="calibre6"><span class="calibre7">parent</span></code> pointer points to this kobject’s parent. In this manner, kobjects build an object hierarchy in the kernel and enable the expression of the relationship between multiple objects. As you shall see, this is actually all that sysfs is: a user-space filesystem representation of the kobject object hierarchy inside the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">sd</span></code> pointer points to a <code class="calibre6"><span class="calibre7">sysfs_dirent</span></code> structure that represents this kobject in sysfs. Inside this structure is an <code class="calibre6"><span class="calibre7">inode</span></code> structure representing the kobject in the sysfs filesystem.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">kref</span></code> structure provides reference counting. The <code class="calibre6"><span class="calibre7">ktype</span></code> and <code class="calibre6"><span class="calibre7">kset</span></code> structures describe and group kobjects. We look at them in the next two subsections.</p><div class="calibre_3"> </div>
<p class="calibre_2">Kobjects are usually embedded in other structures and are generally not interesting on their own. Instead, a more important structure, such as <code class="calibre6"><span class="calibre7">struct cdev</span></code>, defined in <code class="calibre6"><span class="calibre7">&lt;linux/cdev.h&gt;</span></code>, has a <code class="calibre6"><span class="calibre7">kobj</span></code> member:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00237.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">When kobjects are embedded inside other structures, the structures receive the standardized functions that a kobject provides. Most important, the structure’s embedded kobject now enables the structure to become part of an object hierarchy. For example, the <code class="calibre6"><span class="calibre7">cdev</span></code> structure is presentable in an object hierarchy via the parent pointer <code class="calibre6"><span class="calibre7">cdev-&gt;kobj.parent</span></code> and the list <code class="calibre6"><span class="calibre7">cdev-&gt;kobj.entry</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1158220"> </div>
<h4 class="calibre_27"><span class="calibre3">Ktypes</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Kobjects are associated with a specific type, called a <em class="calibre4">ktype</em>, short for <em class="calibre4">kernel object type</em>. Ktypes are represented by <code class="calibre6"><span class="calibre7">struct kobj_type</span></code> and defined in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00238.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Ktypes have the simple job of describing default behavior for a family of kobjects. Instead of each kobject defining its own behavior, the behavior is stored in a ktype, and kobjects of the same “type” point at the same <code class="calibre6"><span class="calibre7">ktype</span></code> structure, thus sharing the same behavior.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">release</span></code> pointer points to the deconstructor called when a kobject’s reference count reaches zero. This function is responsible for freeing any memory associated with this kobject and otherwise cleaning up.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1159396"></a>The <code class="calibre6"><span class="calibre7">sysfs_ops</span></code> variable points to a <code class="calibre6"><span class="calibre7">sysfs_ops</span></code> structure. This structure describes the behavior of sysfs files on read and write. It’s covered in more detail in the section “<a href="#filepos1183518">Adding Files to sysfs</a>.”</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, <code class="calibre6"><span class="calibre7">default_attrs</span></code> points to an array of <code class="calibre6"><span class="calibre7">attribute</span></code> structures. These structures define the default <em class="calibre4">attributes</em> associated with this kobject. Attributes represent properties related to a given object. If this kobject is exported to sysfs, the attributes are exported as files. The last entry in the array must be <code class="calibre6"><span class="calibre7">NULL</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1160242"> </div>
<h4 class="calibre_27"><span class="calibre3">Ksets</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"><em class="calibre4">Ksets</em>, short for <em class="calibre4">kernel object sets</em>, are aggregate collections of kobjects. Ksets work as the base container class for a set of kernel objects, collecting related kobjects, such as “all block devices,” together in a single place. Ksets might sound similar to ktypes and prompt the question, “Why have both?” Ksets group related kernel objects together, whereas ktypes enable kernel objects (functionally related or not) to share common operations. The distinction is kept to allow kobjects of identical ktypes to be grouped into different ksets. That is, there are only a handful of ktypes, but many ksets, in the Linux kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">kset</span></code> pointer points at a kobject’s associated kset. ksets are represented by the <code class="calibre6"><span class="calibre7">kset</span></code> structure, which is declared in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00239.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">In this structure, <code class="calibre6"><span class="calibre7">list</span></code> is a linked list of all kobjects in this kset, <code class="calibre6"><span class="calibre7">list_lock</span></code> is a spinlock protecting this entry in the list (see <a href="index_split_019.html#filepos613760">Chapter 10</a>, “Kernel Synchronization Methods,” for a discussion on spinlocks), <code class="calibre6"><span class="calibre7">kobj</span></code> is a kobject representing the base class for this set, and <code class="calibre6"><span class="calibre7">uevent_ops</span></code> points to a structure that describes the hotplug behavior of kobjects in this kset. <em class="calibre4">Uevent</em>, short for <em class="calibre4">user events</em>, is a mechanism for communicating with user-space information about the hotplugging and hot removal of devices from a system.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1162239"> </div>
<h4 class="calibre_27"><span class="calibre3">Interrelation of Kobjects, Ktypes, and Ksets</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The handful of structures thus far discussed is confusing not because of their number (there are only three) or their complexity (they are all fairly simple), but because they are all interrelated. In the world of kobjects, it is hard to discuss one structure without discussing the others. With the basics of each structure covered, however, you can develop a firm understanding of their relationships.</p><div class="calibre_3"> </div>
<p class="calibre_2">The important key object is the kobject, represented by <code class="calibre6"><span class="calibre7">struct kobject</span></code>. The kobject introduces basic object properties—such as reference counting, parent-child relationship, and naming—to kernel data structures. The <code class="calibre6"><span class="calibre7">kobject</span></code> structure provides these features in a standard unified way. Kobjects, in and of themselves, are not particularly useful. Instead, <a id="filepos1163276"></a>kobjects are typically embedded in other data structures, giving those containing structures the features of the kobject.</p><div class="calibre_3"> </div>
<p class="calibre_2">Kobjects are associated with a specific ktype, which is represented by <code class="calibre6"><span class="calibre7">struct kobj_type</span></code> and pointed at by the <code class="calibre6"><span class="calibre7">ktype</span></code> variable inside of the kobject. ktypes define some default properties of related kobjects: destruction behavior, sysfs behavior, and default attributes. The <code class="calibre6"><span class="calibre7">ktype</span></code> structure is not well named; think of ktypes not as a grouping but as a set of shared operations.</p><div class="calibre_3"> </div>
<p class="calibre_2">Kobjects are then grouped into sets, called ksets, which are represented by <code class="calibre6"><span class="calibre7">struct kset</span></code>. Ksets provide two functions. First, their embedded kobject acts as a base class for a group of kobjects. Second, ksets aggregate together related kobjects. In sysfs, kobjects are the individual directories in the filesystem. Related directories—say, perhaps all subdirectories of a given directory—might be in the same kset.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a href="#filepos1164636">Figure 17.1</a> depicts the relationship between these data structures.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1164636"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 17.1. Relationship between kobjects, ksets, and subsystems.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00240.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1164952"> </div>
<h4 class="calibre_27"><span class="calibre3">Managing and Manipulating Kobjects</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">With the basic internals of kobjects and friends behind you, it’s time to look at the exported interfaces used for managing and manipulating kobjects. Most of the time, driver writers do not have to deal with kobjects directly. Instead, kobjects are embedded in some class-specific structure (as you saw with the character device structure) and managed “behind the scenes” by the associated driver subsystem. Nonetheless, kobjects are not intended to remain hidden and can seep through into driver code or you might be hacking on the driver subsystem itself.</p><div class="calibre_3"> </div>
<p class="calibre_2">The first step in using a kobject is declaring and initializing it. kobjects are initialized via the function <code class="calibre6"><span class="calibre7">kobject_init</span></code>, which is declared in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1166005"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void kobject_init(struct kobject *kobj, struct kobj_type *ktype);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The function’s first parameter is the kobject to initialize. Before calling this function, the kobject must be zeroed. This might normally happen during the initialization of the larger function in which the kobject is embedded. If not, a simple call to <code class="calibre6"><span class="calibre7">memset()</span></code>does the trick:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">memset(kobj, 0, sizeof (*kobj));</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">It is safe to initialize <code class="calibre6"><span class="calibre7">parent</span></code> and <code class="calibre6"><span class="calibre7">kset</span></code> after the zeroing. For example</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct kobject *kobj;<br class="calibre1"/><br class="calibre1"/>kobj = kmalloc(sizeof (*kobj), GFP_KERNEL);<br class="calibre1"/>if (!kobj)<br class="calibre1"/>        return -ENOMEM;<br class="calibre1"/>memset(kobj, 0, sizeof (*kobj));<br class="calibre1"/>kobj-&gt;kset = my_kset;<br class="calibre1"/>kobject_init(kobj, my_ktype);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This multistep effort is handled automatically by <code class="calibre6"><span class="calibre7">kobject_create()</span></code>, which returns a newly allocated kobject:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct kobject * kobject_create(void);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Usage is simple:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct kobject *kobj;<br class="calibre1"/><br class="calibre1"/>kobj = kobject_create();<br class="calibre1"/>if (!kobj)<br class="calibre1"/>        return –ENOMEM;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Most uses of kobjects should favor <code class="calibre6"><span class="calibre7">kobject_create()</span></code> or a related helper function rather than directly manipulate the structure.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1168142"> </div>
<h4 class="calibre_27"><span class="calibre3">Reference Counts</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">One of the primary features provided by kobjects is a unified reference counting system. After initialization, the kobject’s reference count is set to one. So long as the reference count is nonzero, the object continues to exist in memory and is said to be <em class="calibre4">pinned</em>. Any code that holds a reference to the object first elevates the reference count. When the code is finished with the object, the reference count is decremented. Bumping the reference count is called <em class="calibre4">getting</em> a reference to the object, and decrementing the reference count is called <em class="calibre4">putting</em> a reference to the object. When the reference count reaches zero, the object can be destroyed and any associated memory freed.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1169024"> </div>
<h5 class="calibre_29"><span class="calibre3">Incrementing and Decrementing Reference Counts</span></h5><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1169172"> </div>
<p class="calibre_2">Incrementing the reference count is done via <code class="calibre6"><span class="calibre7">kobject_get()</span></code>, declared in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct kobject * kobject_get(struct kobject *kobj);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function returns a pointer to the kobject or <code class="calibre6"><span class="calibre7">NULL</span></code> on failure.</p><div class="calibre_3"> </div>
<p class="calibre_2">Decrementing the reference count is done via <code class="calibre6"><span class="calibre7">kobject_put()</span></code>, also declared in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void kobject_put(struct kobject *kobj);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If the provided kobject’s reference count reaches zero, the release function pointed at by the ktype associated with the kobject is invoked, any associated memory is freed, and the object is no longer valid.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1170374"> </div>
<h5 class="calibre_29"><span class="calibre3">Krefs</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">Internally, the kobject reference counting is provided by the <code class="calibre6"><span class="calibre7">kref</span></code> structure, which is defined in <code class="calibre6"><span class="calibre7">&lt;linux/kref.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct kref {<br class="calibre1"/>        atomic_t refcount;<br class="calibre1"/>};</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The lone member is an atomic variable used to hold the reference count. A structure is used simply to provide type checking. Before using a kref, you must initialize it via <code class="calibre6"><span class="calibre7">kref_init()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void kref_init(struct kref *kref)<br class="calibre1"/>{<br class="calibre1"/>        atomic_set(&amp;kref-&gt;refcount, 1);<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">As you can see, this function simply initializes the internal <code class="calibre6"><span class="calibre7">atomic_t</span></code> to one. Consequently, krefs are pinned with a reference count of one as soon as they are initialized; this is the same behavior as kobjects.</p><div class="calibre_3"> </div>
<p class="calibre_2">To obtain a reference to a kref, use <code class="calibre6"><span class="calibre7">kref_get()</span></code>, declared in <code class="calibre6"><span class="calibre7">&lt;linux/kref.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void kref_get(struct kref *kref)<br class="calibre1"/>{<br class="calibre1"/>        WARN_ON(!atomic_read(&amp;kref-&gt;refcount));<br class="calibre1"/>        atomic_inc(&amp;kref-&gt;refcount);<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function bumps the reference count. It has no return value. To drop a reference to a kref, use <code class="calibre6"><span class="calibre7">kref_put()</span></code>, declared in <code class="calibre6"><span class="calibre7">&lt;linux/kref.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00241.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos1172613"></a>This function drops the reference count by one and calls the provided <code class="calibre6"><span class="calibre7">release()</span></code> function if the count is now zero. As noted by the ominous <code class="calibre6"><span class="calibre7">WARN_ON()</span></code> statement, the provided <code class="calibre6"><span class="calibre7">release()</span></code> function cannot simply be <code class="calibre6"><span class="calibre7">kfree()</span></code> but must be a specialized function that accepts <code class="calibre6"><span class="calibre7">struct kref</span></code> as its lone argument and has no return value. The function returns zero, unless the put reference was the last reference to the object, in which case it returns one. Normally, callers of <code class="calibre6"><span class="calibre7">kref_put()</span></code> are unconcerned with the return value.</p><div class="calibre_3"> </div>
<p class="calibre_2">Rather than having kernel code implement its own reference counting via <code class="calibre6"><span class="calibre7">atomic_t</span></code> types and simple “get” and “put” wrapper functions, developers are encouraged to use the kref type and its helpers to provide a common and known-correct reference counting mechanism in the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2">All these functions are defined in <code class="calibre6"><span class="calibre7">lib/kref.c</span></code> and declared in <code class="calibre6"><span class="calibre7">&lt;linux/kref.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1173978"> </div>
<h3 class="calibre_21"><span class="bold">sysfs</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The <em class="calibre4">sysfs filesystem</em> is an in-memory virtual filesystem that provides a view of the kobject hierarchy. It enables users to view the device topology of their system as a simple filesystem. Using attributes, kobjects can export files that enable kernel variables to be read from and optionally written to.</p><div class="calibre_3"> </div>
<p class="calibre_2">Although the intended purpose of the device model was initially to provide a device topology for power management reasons, an offshoot was sysfs. To facilitate debugging, the device model’s developer decided to export the tree as a filesystem. This quickly proved quite useful, at first as a replacement for device-related files that previously found themselves in <code class="calibre6"><span class="calibre7">/proc</span></code>, and later as a powerful view into the system’s object hierarchy. Indeed, sysfs, originally called driverfs, predated kobjects. Eventually sysfs made it clear that a new object model would be quite beneficial, and kobject was born. Today, every system with a 2.6 kernel has sysfs. Most systems mount it at <code class="calibre6"><span class="calibre7">/sys</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The magic behind sysfs is simply tying kobjects to directory entries via the <code class="calibre6"><span class="calibre7">dentry</span></code> member inside each kobject. Recall from <a href="index_split_021.html#filepos778361">Chapter 12</a> that the <code class="calibre6"><span class="calibre7">dentry</span></code> structure represents directory entries. By linking kobjects to dentries, kobjects trivially map to directories. Exporting the kobjects as a filesystem is now as easy as building a tree of the dentries in memory. But wait! kobjects already form a tree, our beloved device model. With kobjects mapping to dentries and the object hierarchy already forming an in-memory tree, sysfs became trivial.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a href="#filepos1176193">Figure 17.2</a> is a partial view of the sysfs filesystem as mounted at <code class="calibre6"><span class="calibre7">/sys</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1176193"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 17.2. A partial view of the <code class="calibre6"><span class="calibre15">/sys</span></code> tree.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00242.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos1176523"></a>The root of the sysfs contains at least 10 directories: <code class="calibre6"><span class="calibre7">block</span></code>, <code class="calibre6"><span class="calibre7">bus</span></code>, <code class="calibre6"><span class="calibre7">class</span></code>, <code class="calibre6"><span class="calibre7">dev</span></code>, <code class="calibre6"><span class="calibre7">devices</span></code>, <code class="calibre6"><span class="calibre7">firmware</span></code>, <code class="calibre6"><span class="calibre7">fs</span></code>, <code class="calibre6"><span class="calibre7">kernel</span></code>, <code class="calibre6"><span class="calibre7">module</span></code>, and <code class="calibre6"><span class="calibre7">power</span></code>. The <code class="calibre6"><span class="calibre7">block</span></code> directory contains one directory for each of the registered block devices on the system. Each of those directories, in turn, contains any partitions on the block device. The <code class="calibre6"><span class="calibre7">bus</span></code> directory provides a view of the system buses. The <code class="calibre6"><span class="calibre7">class</span></code> directory contains a view of the devices on the system organized by high-level function. The <code class="calibre6"><span class="calibre7">dev</span></code> directory is a view of registered device nodes. The <code class="calibre6"><span class="calibre7">devices</span></code> directory is a view of the device topology of the system. It maps directly to the hierarchy of device structures inside the kernel. The <code class="calibre6"><span class="calibre7">firmware</span></code> directory contains a system-specific tree of low-level subsystems such as ACPI, EDD, EFI, and so on. The <code class="calibre6"><span class="calibre7">fs</span></code> directory contains a view of registered filesystems. The <code class="calibre6"><span class="calibre7">kernel</span></code> directory contains kernel configuration options and status information while the <code class="calibre6"><span class="calibre7">modules</span></code> directory contains a view of the system’s loaded modules. The <code class="calibre6"><span class="calibre7">power</span></code> directory contains systemwide power management data. Not all systems have all directories and yet other systems have directories not mentioned here.</p><div class="calibre_3"> </div>
<p class="calibre_2">The most important directory is <code class="calibre6"><span class="calibre7">devices</span></code>, which exports the device model to the world. The directory structure is the actual device topology of the system. Much of the data in other directories is simply alternative organizations of the data in the <code class="calibre6"><span class="calibre7">devices</span></code> directory. For example, <code class="calibre6"><span class="calibre7">/sys/class/net/</span></code> organizes devices by the high-level concept of registered network interfaces. Inside this directory might be the subdirectory <code class="calibre6"><span class="calibre7">eth0</span></code>, which contains the symlink <code class="calibre6"><span class="calibre7">device</span></code> back to the actual device directory in <code class="calibre6"><span class="calibre7">devices</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Take a look at <code class="calibre6"><span class="calibre7">/sys</span></code> on a Linux system that you have access to. Such an accurate view into the system’s device is neat, and seeing the interconnection between the high-level concepts in <code class="calibre6"><span class="calibre7">class</span></code> versus the low-level physical devices in <code class="calibre6"><span class="calibre7">devices</span></code> and the actual drivers in <code class="calibre6"><span class="calibre7">bus</span></code> is informative. The whole experience is even more rewarding when you realize that this data is provided <em class="calibre4">free</em>, as a side effect of the kernel maintaining a device hierarchy, and that this is the representation of the system as maintained inside the kernel.<sup class="calibre8"><a id="filepos1179889" href="#filepos1179993">1</a></sup></p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1179993" href="#filepos1179889">1</a></sup>
<em class="calibre4">If you find sysfs interesting, you might be interested in HAL, a hardware abstraction layer, which can be found at <a href="http://www.freedesktop.org/wiki/Software/hal">http://www.freedesktop.org/wiki/Software/hal</a>. HAL builds an in-memory database based on the data in sysfs, linking together the concepts of class, device, and driver. On top of this data, HAL provides a rich API enabling for smarter, more hardware-aware applications.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1180547"> </div>
<h4 class="calibre_27"><span class="calibre3">Adding and Removing kobjects from sysfs</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Initialized kobjects are not automatically exported to sysfs. To represent a kobject to sysfs, you use <code class="calibre6"><span class="calibre7">kobject_add()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int kobject_add(struct kobject *kobj, struct kobject *parent, const char *fmt, ...);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">A given kobject’s location in sysfs depends on the kobject’s location in the object hierarchy. If the kobject’s <code class="calibre6"><span class="calibre7">parent</span></code> pointer is set, the kobject maps to a subdirectory in sysfs inside its parent. If the <code class="calibre6"><span class="calibre7">parent</span></code> pointer is not set, the kobject maps to a subdirectory inside <code id="filepos1181440" class="calibre6"><span class="calibre7">kset-&gt;kobj</span></code>. If neither the <code class="calibre6"><span class="calibre7">parent</span></code> nor the <code class="calibre6"><span class="calibre7">kset</span></code> fields are set in the given kobject, the kobject is assumed to have no parent and maps to a root-level directory in sysfs. In most use cases, one or both of <code class="calibre6"><span class="calibre7">parent</span></code> and <code class="calibre6"><span class="calibre7">kset</span></code> should be set appropriately before <code class="calibre6"><span class="calibre7">kobject_add()</span></code> is called. Regardless, the name of the directory representing the kobject in sysfs is given by <code class="calibre6"><span class="calibre7">fmt</span></code>, which accepts a <code class="calibre6"><span class="calibre7">printf()</span></code>-style format string.</p><div class="calibre_3"> </div>
<p class="calibre_2">The helper function <code class="calibre6"><span class="calibre7">kobject_create_and_add()</span></code> combines the work of <code class="calibre6"><span class="calibre7">kobject_create()</span></code> and <code class="calibre6"><span class="calibre7">kobject_add()</span></code> into one function:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct kobject * kobject_create_and_add(const char *name, struct kobject *parent);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Note that <code class="calibre6"><span class="calibre7">kobject_create_and_add()</span></code> receives the name of the kobject’s directory as a direct pointer, <code class="calibre6"><span class="calibre7">name</span></code>, while <code class="calibre6"><span class="calibre7">kobject_add()</span></code> uses <code class="calibre6"><span class="calibre7">printf()</span></code>-style formatting.</p><div class="calibre_3"> </div>
<p class="calibre_2">Removing a kobject’s sysfs representation is done via <code class="calibre6"><span class="calibre7">kobject_del()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void kobject_del(struct kobject *kobj);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">All of these functions are defined in <code class="calibre6"><span class="calibre7">lib/kobject.c</span></code> and declared in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1183518"> </div>
<h4 class="calibre_27"><span class="calibre3">Adding Files to sysfs</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Kobjects map to directories, and the complete object hierarchy maps nicely to the complete sysfs directory structure, but what about files? Sysfs is nothing but a pretty tree without files to provide actual data.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1183904"> </div>
<h5 class="calibre_29"><span class="calibre3">Default Attributes</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">A default set of files is provided via the <code class="calibre6"><span class="calibre7">ktype</span></code> field in kobjects and ksets. Consequently, all kobjects of the same type have the same default set of files populating their sysfs directories. The <code class="calibre6"><span class="calibre7">kobj_type</span></code> structure contains a member, <code class="calibre6"><span class="calibre7">default_attrs</span></code>, that is an array of <code class="calibre6"><span class="calibre7">attribute</span></code> structures. Attributes map kernel data to files in sysfs.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">attribute</span></code> structure is defined in <code class="calibre6"><span class="calibre7">&lt;linux/sysfs.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00243.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">name</span></code> member provides the name of this attribute. This will be the filename of the resulting file in sysfs. The <code class="calibre6"><span class="calibre7">owner</span></code> member points to a <code class="calibre6"><span class="calibre7">module</span></code> structure representing the owning module, if any. If a module does not own this attribute, this field is <code class="calibre6"><span class="calibre7">NULL</span></code>. The <code class="calibre6"><span class="calibre7">mode</span></code> member is a <code class="calibre6"><span class="calibre7">mode_t</span></code> type that specifies the permissions for the file in sysfs. Read-only attributes probably want to set this to <code class="calibre6"><span class="calibre7">S_IRUGO</span></code> if they are world-readable and <code class="calibre6"><span class="calibre7">S_IRUSR</span></code> if they are only owner-readable. Writable attributes probably want to set <code class="calibre6"><span class="calibre7">mode</span></code> to <code class="calibre6"><span class="calibre7">S_IRUGO | S_IWUSR</span></code>. All files and directories in sysfs are owned by uid zero and gid zero.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1185836"></a>Although <code class="calibre6"><span class="calibre7">default_attrs</span></code> lists the default attributes, <code class="calibre6"><span class="calibre7">sysfs_ops</span></code> describes how to use them. The <code class="calibre6"><span class="calibre7">sysfs_ops</span></code> member is a pointer to a structure of the same name, which is defined in <code class="calibre6"><span class="calibre7">&lt;linux/sysfs.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00244.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">show()</span></code> method is invoked when the sysfs entry is read from user-space. It must copy the value of the attribute given by <code class="calibre6"><span class="calibre7">attr</span></code> into the buffer provided by <code class="calibre6"><span class="calibre7">buffer</span></code>. The buffer is <code class="calibre6"><span class="calibre7">PAGE_SIZE</span></code> bytes in length; on x86, <code class="calibre6"><span class="calibre7">PAGE_SIZE</span></code> is 4096 bytes. The function should return the size in bytes of data actually written into <code class="calibre6"><span class="calibre7">buffer</span></code> on success or a negative error code on failure.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">store()</span></code> method is invoked on write. It must read the <code class="calibre6"><span class="calibre7">size</span></code> bytes from <code class="calibre6"><span class="calibre7">buffer</span></code> into the variable represented by the attribute <code class="calibre6"><span class="calibre7">attr</span></code>. The size of the buffer is always <code class="calibre6"><span class="calibre7">PAGE_SIZE</span></code> or smaller. The function should return the size in bytes of data read from <code class="calibre6"><span class="calibre7">buffer</span></code> on success or a negative error code on failure.</p><div class="calibre_3"> </div>
<p class="calibre_2">Because this single set of functions must handle file I/O requests on <em class="calibre4">all</em> attributes, they typically need to maintain some sort of generic mapping to invoke a handler specific to each attribute.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1187763"> </div>
<h5 class="calibre_29"><span class="calibre3">Creating New Attributes</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">Generally, the default attributes provided by the ktype associated with a kobject are sufficient. Indeed, the purpose of ktype is to provide common operations to kobjects. Sharing ktypes between kobjects not only simplifies programming, but also provides code consolidation and a uniform look and feel to sysfs directories of related objects.</p><div class="calibre_3"> </div>
<p class="calibre_2">Nonetheless, often some specific instance of a kobject is somehow special. It wants or even needs its own attributes—perhaps to provide data or functionality not shared by the more general ktype. To this end, the kernel provides the <code class="calibre6"><span class="calibre7">sysfs_create_file()</span></code> interface for adding new attributes on top of the default set:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int sysfs_create_file(struct kobject *kobj, const struct attribute *attr);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function associates the <code class="calibre6"><span class="calibre7">attribute</span></code> structure pointed at by <code class="calibre6"><span class="calibre7">attr</span></code> with the kobject pointed at by <code class="calibre6"><span class="calibre7">kobj</span></code>. Before it is invoked, the given attribute should be filled out. This function returns zero on success and a negative error code otherwise.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1189264"></a>Note that the <code class="calibre6"><span class="calibre7">sysfs_ops</span></code> specified in the kobject’s ktype is invoked to handle this new attribute. The existing default <code class="calibre6"><span class="calibre7">show()</span></code> and <code class="calibre6"><span class="calibre7">store()</span></code> methods must be capable of handling the newly created attribute.</p><div class="calibre_3"> </div>
<p class="calibre_2">In addition to creating actual files, it is possible to create symbolic links. Creating a symlink in sysfs is easy:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int sysfs_create_link(struct kobject *kobj, struct kobject *target, char *name);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function creates a link named <code class="calibre6"><span class="calibre7">name</span></code> in the directory mapped from <code class="calibre6"><span class="calibre7">kobj</span></code> to the directory mapped from <code class="calibre6"><span class="calibre7">target</span></code>. This function returns zero on success and a negative error code otherwise.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1190318"> </div>
<h5 class="calibre_29"><span class="calibre3">Destroying Attributes</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">Removing an attribute is handled via <code class="calibre6"><span class="calibre7">sysfs_remove_file()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void sysfs_remove_file(struct kobject *kobj, const struct attribute *attr);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Upon call return, the given attribute no longer appears in the given kobject’s directory.</p><div class="calibre_3"> </div>
<p class="calibre_2">Symbolic links created with <code class="calibre6"><span class="calibre7">sysfs_create_link()</span></code> can be removed with <code class="calibre6"><span class="calibre7">sysfs_remove_link()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void sysfs_remove_link(struct kobject *kobj, char *name);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Upon return, the symbolic link <code class="calibre6"><span class="calibre7">name</span></code> in the directory mapped from <code class="calibre6"><span class="calibre7">kobj</span></code> is removed.</p><div class="calibre_3"> </div>
<p class="calibre_2">All four of these functions are declared in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>. The <code class="calibre6"><span class="calibre7">sysfs_create_file()</span></code> and <code class="calibre6"><span class="calibre7">sysfs_remove_file()</span></code> functions are defined in <code class="calibre6"><span class="calibre7">fs/sysfs/file.c</span></code>. The <code class="calibre6"><span class="calibre7">sysfs_create_link()</span></code> and <code class="calibre6"><span class="calibre7">sysfs_remove_link()</span></code> functions are defined in <code class="calibre6"><span class="calibre7">fs/sysfs/symlink.c</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1192026"> </div>
<h5 class="calibre_29"><span class="calibre3">sysfs Conventions</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The sysfs filesystem is currently <em class="calibre4">the place</em> for implementing functionality previously reserved for <code class="calibre6"><span class="calibre7">ioctl()</span></code> calls on device nodes or the procfs filesystem. Instead of these deprecated kernel interfaces, today kernel developers implement such functionality as sysfs attributes in the appropriate directory. For example, instead of a new <code class="calibre6"><span class="calibre7">ioctl()</span></code> on a device node, add a sysfs attribute in the driver’s sysfs directory. Such an approach avoids the type-unsafe use of obscure <code class="calibre6"><span class="calibre7">ioctl()</span></code> arguments and the haphazard mess of <code class="calibre6"><span class="calibre7">/proc</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">To keep sysfs clean and intuitive, however, developers must follow certain conventions. First, sysfs attributes should export one value per file. Values should be text-based and map to simple C types. The goal is to avoid the highly structured or highly messy representation of data we have today in <code class="calibre6"><span class="calibre7">/proc</span></code>. Providing one value per file makes reading and writing trivial from the command line and enables C programs to easily slurp the kernel’s data from sysfs into their own variables. In situations in which the one-value-per-file rule results in an inefficient representation of data, it is acceptable to place multiple values of the same type in one file. Delineate them as appropriate; a simple space probably makes the most sense. Ultimately, think of sysfs attributes as mapping to individual kernel <a id="filepos1193719"></a>variables (as they usually do), and keep in mind ease of manipulation from user-space, particularly from the shell.</p><div class="calibre_3"> </div>
<p class="calibre_2">Second, organize data in sysfs in a clean hierarchy. Correctly parent kobjects so that they map intuitively into the sysfs tree. Associate attributes with the correct kobject and keep in mind that the kobject hierarchy exists not only in the kernel, but also as an exported tree to user-space. Keep the sysfs tree organized and hierarchical.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, remember that sysfs provides a kernel-to-user service and is thus a sort of user-space ABI. User programs can rely on the existence, location, value, and behavior of sysfs directories and files. Changing existing files in any way is discouraged, and modifying the <em class="calibre4">behavior</em> of a given attribute but keeping its name and location is surely begging for trouble.</p><div class="calibre_3"> </div>
<p class="calibre_2">These simple conventions should enable sysfs to provide a rich and intuitive interface to user-space. Use sysfs correctly and user-space developers can have a simple and clean, yet powerful and intuitive, interface to the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1194984"> </div>
<h4 class="calibre_27"><span class="calibre3">The Kernel Events Layer</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The Kernel Event Layer implements a kernel-to-user notification system on top of kobjects. After the release of 2.6.0, it became clear that a mechanism for pushing events out of the kernel and up into user-space was needed, particularly for desktop systems that needed a more integrated and asynchronous system. The idea was to have the kernel push events up the stack: Hard drive full! Processor is overheating! Partition mounted!</p><div class="calibre_3"> </div>
<p class="calibre_2">Early revisions of the event layer came and went, and it was not long before the whole thing was tied intimately to kobjects and sysfs. The result, it turns out, is pretty neat. The Kernel Event Layer models events as <em class="calibre4">signals</em> emitting from objects—specifically, kobjects. Because kobjects map to sysfs paths, the <em class="calibre4">source</em> of each event is a sysfs path. If the event in question has to do with your first hard drive, <code class="calibre6"><span class="calibre7">/sys/block/hda</span></code> is the source address. Internally, inside the kernel, we model the event as originating from the backing kobject.</p><div class="calibre_3"> </div>
<p class="calibre_2">Each event is given a <em class="calibre4">verb</em> or <em class="calibre4">action</em> string representing the signal. The strings are terms such as <em class="calibre4">modified</em> or <em class="calibre4">unmounted</em> that describe <em class="calibre4">what</em> happened.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, each event has an optional payload. Rather than pass an arbitrary string to user-space that provides the payload, the kernel event layer represents payloads as sysfs attributes.</p><div class="calibre_3"> </div>
<p class="calibre_2">Internally, the kernel events go from kernel-space out to user-space via netlink. Netlink is a high-speed multicast socket that transmits networking information. Using netlink means that obtaining kernel events from user-space is as simple as blocking on a socket. The intention is for user-space to implement a system daemon that listens on the socket, processes any read events, and transmits the events up the system stack. One possible proposal for such a user-space daemon is to tie the events into D-BUS,<sup class="calibre8"><a id="filepos1197240" href="#filepos1197484">2</a></sup> which <a id="filepos1197295"></a>already implements a systemwide messaging bus. In this manner, the kernel can emit signals just as any other component in the system.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1197484" href="#filepos1197240">2</a></sup>
<em class="calibre4">More information on D-BUS is available at <a href="http://dbus.freedesktop.org/">http://dbus.freedesktop.org/</a>.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">To send events out to user-space from your kernel code, use <code class="calibre6"><span class="calibre7">kobject_uevent()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int kobject_uevent(struct kobject *kobj, enum kobject_action action);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The first parameter specifies the kobject emitting this signal. The actual kernel event contains the sysfs path to which this kobject maps.</p><div class="calibre_3"> </div>
<p class="calibre_2">The second parameter specifies the <em class="calibre4">action</em> or <em class="calibre4">verb</em> describing this signal. The actual kernel event contains a string that maps to the provided <code class="calibre6"><span class="calibre7">enum kobject_action</span></code> value. Rather than directly provide the string, the function uses an enumeration to encourage value reuse, provide type safety, and prevent typos and other mistakes. The enumerations are defined in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code> and have the form <code class="calibre6"><span class="calibre7">KOBJ_</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">foo</span></code></em>. Current values include <code class="calibre6"><span class="calibre7">KOBJ_MOVE</span></code>, <code class="calibre6"><span class="calibre7">KOBJ_ONLINE</span></code>, <code class="calibre6"><span class="calibre7">KOBJ_OFFLINE</span></code>, <code class="calibre6"><span class="calibre7">KOBJ_ADD</span></code>, <code class="calibre6"><span class="calibre7">KOBJ_REMOVE</span></code>, and <code class="calibre6"><span class="calibre7">KOBJ_CHANGE</span></code>. These values map to the strings “move,” “online,” “offline,” “add,” “remove,” and “change,” respectively. Adding new action values is acceptable, so long as an existing value is insufficient.</p><div class="calibre_3"> </div>
<p class="calibre_2">Using kobjects and attributes not only encourages events that fit nicely in a sysfs-based world, but also encourages the creation of new kobjects and attributes to represent objects and data not yet exposed through sysfs.</p><div class="calibre_3"> </div>
<p class="calibre_2">This and related functions are defined in <code class="calibre6"><span class="calibre7">lib/kobject_uevent.c</span></code> and declared in <code class="calibre6"><span class="calibre7">&lt;linux/kobject.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1199936"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">In this chapter, we looked at the kernel functionality used to implement device drivers and manage the device tree, including modules, kobjects (and the related ksets and ktypes), and sysfs. This functionality is important to device driver authors because it enables them to write modular, advanced drivers.</p><div class="calibre_3"> </div>
<p class="calibre_2">In the final three chapters, we switch the discussion from specific Linux kernel subsystems to general kernel issues, starting in the next chapter with a treatment on debugging the Linux kernel.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_75"></div>
</body></html>
