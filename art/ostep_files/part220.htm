<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>21.5 Page Fault Control Flow</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part219.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part221.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">21.5 Page Fault Control Flow</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">With all of this knowledge in place, we can now roughly sketch the complete control flow of memory access. In other words, when some- body asks you “what happens when a program fetches some data from memory?”, you should have a pretty good idea of all the different pos- sibilities. See the control flow in Figures <span style=" color: #00AEEF;">21.2 </span>and <span style=" color: #00AEEF;">21.3 </span>for more details; the first figure shows what the hardware does during translation, and the second what the OS does upon a page fault.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">From the hardware control flow diagram in Figure <span style=" color: #00AEEF;">21.2</span>, notice that there are now three important cases to understand when a TLB miss oc- curs. First, that the page was both <b>present </b>and <b>valid </b>(Lines 18–21); in this case, the TLB miss handler can simply grab the PFN from the PTE, retry the instruction (this time resulting in a TLB hit), and thus continue as described (many times) before. In the second case (Lines 22–23), the page fault handler must be run; although this was a legitimate page for the process to access (it is valid, after all), it is not present in physical memory. Third (and finally), the access could be to an invalid page, due for example to a bug in the program (Lines 13–14). In this case, no other bits in the PTE really matter; the hardware traps this invalid access, and the OS trap handler runs, likely terminating the offending process.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">From the software control flow in Figure <span style=" color: #00AEEF;">21.3</span>, we can see what the OS roughly must do in order to service the page fault. First, the OS must find a physical frame for the soon-to-be-faulted-in page to reside within; if there is no such page, we’ll have to wait for the replacement algorithm to run and kick some pages out of memory, thus freeing them for use here.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">PFN = FindFreePhysicalPage()</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">if (PFN == -1)      // no free page found</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3     <span class="s38">PFN = EvictPage()   // run replacement algorithm</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4  <span class="s119">DiskRead(PTE.DiskAddr, pfn) </span><span class="s38">// sleep (waiting for I/O)</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">PTE.present = True    // update page table with present</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6  <span class="s38">PTE.PFN  = PFN     // bit and translation (PFN)</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">7  <span class="s38">RetryInstruction()    // retry instruction</span></p><p style="padding-top: 2pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">Figure 21.3: <b>Page-Fault Control Flow Algorithm (Software)</b></p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">With a physical frame in hand, the handler then issues the I/O request to read in the page from swap space. Finally, when that slow operation completes, the OS updates the page table and retries the instruction. The retry will result in a TLB miss, and then, upon another retry, a TLB hit, at which point the hardware will be able to access the desired item.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part219.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part221.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
