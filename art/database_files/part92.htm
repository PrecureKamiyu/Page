<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3.8   Nested Subqueries</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part91.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part93.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark52">3.8   </a><span style=" color: #00AEEF;">Nested Subqueries</span><a name="bookmark94">&zwnj;</a></p><p class="s46" style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">provides a mechanism for nesting subqueries. A subquery is a </span>select<span class="p">-</span>from<span class="p">-</span>where <span class="p">expression that is nested within another query. A common use of subqueries is to per- form tests for set membership, make set comparisons, and determine set cardinality by nesting subqueries in the </span>where <span class="p">clause. We study such uses of nested subqueries in the </span>where <span class="p">clause in Section 3.8.1 through Section 3.8.4. In Section 3.8.5, we study nesting of subqueries in the </span>from <span class="p">clause. In Section 3.8.7, we see how a class of sub- queries called scalar subqueries can appear wherever an expression returning a value can occur.</span></p><p class="s68" style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">3.8.1 Set Membership</p><p class="s46" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">allows testing tuples for membership in a relation. The </span>in <span class="p">connective tests for set membership, where the set is a collection of values produced by a </span>select <span class="p">clause. The </span>not in <span class="p">connective tests for the absence of set membership.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As an illustration, reconsider the query “Find all the courses taught in the both the Fall 2017 and Spring 2018 semesters.” Earlier, we wrote such a query by intersecting two sets: the set of courses taught in Fall 2017 and the set of courses taught in Spring 2018. We can take the alternative approach of ﬁnding all courses that were taught in Fall 2017 and that are also members of the set of courses taught in Spring 2018. This formulation generates the same results as the previous one did, but it leads us to write our query using the <b>in </b>connective of <span class="s44">SQL</span>. We begin by ﬁnding all courses taught in Spring 2018, and we write the subquery:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_413.png"/></span></p><p style="padding-top: 10pt;padding-left: 182pt;text-indent: 0pt;text-align: left;">(<b>select </b><i>course id</i></p><p class="s46" style="padding-left: 185pt;text-indent: 0pt;text-align: left;">from <i>section</i></p><p class="s46" style="padding-left: 185pt;text-indent: 0pt;text-align: left;">where <i>semester </i><span class="s15">= </span><span class="p">&#39;Spring&#39; </span>and <i>year</i><span class="s15">= </span><span class="p">2018)</span></p><p style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We then need to ﬁnd those courses that were taught in the Fall 2017 and that appear in the set of courses obtained in the subquery. We do so by nesting the subquery in the <b>where </b>clause of an outer query. The resulting query is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_414.png"/></span></p><p class="s46" style="padding-left: 140pt;text-indent: 0pt;text-align: left;">select distinct <i>course id</i></p><p class="s46" style="padding-left: 140pt;text-indent: 0pt;text-align: left;">from <i>section</i></p><p class="s46" style="padding-left: 140pt;text-indent: 0pt;text-align: left;">where <i>semester </i><span class="s15">= </span><span class="p">&#39;Fall&#39; </span>and <i>year</i><span class="s15">= </span><span class="p">2017 </span>and</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_415.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_416.png"/></span></p><p class="s46" style="padding-left: 168pt;text-indent: 0pt;text-align: left;"><i>course id </i>in <span class="p">(</span>select <i>course id</i></p><p class="s46" style="padding-left: 224pt;text-indent: 0pt;text-align: left;">from <i>section</i></p><p class="s46" style="padding-left: 224pt;text-indent: 0pt;text-align: left;">where <i>semester </i><span class="s15">= </span><span class="p">&#39;Spring&#39; </span>and <i>year</i><span class="s15">= </span><span class="p">2018);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Note that we need to use <b>distinct </b>here because the <b>intersect </b>operation removes dupli- cates by default.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">This example shows that it is possible to write the same query several ways in <span class="s44">SQL</span>. This ﬂexibility is beneﬁcial, since it allows a user to think about the query in the way</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">that seems most natural. We shall see that there is a substantial amount of redundancy in <span class="s44">SQL</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We use the <b>not in </b>construct in a way similar to the <b>in </b>construct. For example, to ﬁnd all the courses taught in the Fall 2017 semester but not in the Spring 2018 semester, which we expressed earlier using the <b>except </b>operation, we can write:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_417.png"/></span></p><p class="s46" style="padding-left: 177pt;text-indent: 0pt;text-align: left;">select distinct <i>course id</i></p><p class="s46" style="padding-left: 177pt;text-indent: 0pt;text-align: left;">from <i>section</i></p><p class="s46" style="padding-left: 177pt;text-indent: 0pt;text-align: left;">where <i>semester </i><span class="s15">= </span><span class="p">&#39;Fall&#39; </span>and <i>year</i><span class="s15">= </span><span class="p">2017 </span>and</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_418.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_419.png"/></span></p><p class="s46" style="padding-left: 177pt;text-indent: 0pt;text-align: left;"><i>course id </i>not in <span class="p">(</span>select <i>course id</i></p><p class="s46" style="padding-left: 249pt;text-indent: 0pt;text-align: left;">from <i>section</i></p><p class="s46" style="padding-left: 249pt;text-indent: 0pt;text-align: left;">where <i>semester </i><span class="s15">= </span><span class="p">&#39;Spring&#39; </span>and <i>year</i><span class="s15">= </span><span class="p">2018);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <b>in </b>and <b>not in </b>operators can also be used on enumerated sets. The following query selects the names of instructors whose names are neither “Mozart” nor “Ein- stein”.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 219pt;text-indent: 0pt;text-align: left;">select distinct <i>name</i></p><p class="s46" style="padding-left: 219pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 219pt;text-indent: 0pt;text-align: left;">where <i>name </i>not in <span class="p">(&#39;Mozart&#39;, &#39;Einstein&#39;);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In the preceding examples, we tested membership in a one-attribute relation. It is also possible to test for membership in an arbitrary relation in <span class="s44">SQL</span>. For example, we can write the query “ﬁnd the total number of (distinct) students who have taken course sections taught by the instructor with <span class="s69">ID </span>110011” as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 135pt;text-indent: 0pt;text-align: left;">select count <span class="p">(</span>distinct <span class="s69">ID</span><span class="p">)</span></p><p class="s46" style="padding-left: 135pt;text-indent: 0pt;text-align: left;">from <i>takes</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_420.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_421.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_422.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_423.png"/></span></p><p style="padding-left: 135pt;text-indent: 0pt;text-align: left;"><b>where </b>(<i>course id</i>, <i>sec id</i>, <i>semester</i>, <i>year</i>) <b>in </b>(<b>select </b><i>course id</i>, <i>sec id</i>, <i>semester</i>, <i>year</i></p><p class="s46" style="padding-left: 320pt;text-indent: 0pt;text-align: left;">from <i>teaches</i></p><p style="padding-left: 320pt;text-indent: 0pt;text-align: left;"><b>where </b><i>teaches</i>.<span class="s69">ID</span>= &#39;10101&#39;);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_424.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_425.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note, however, that some <span class="s44">SQL </span>implementations do not support the row construc- tion syntax “(<i>course id</i>, <i>sec id</i>, <i>semester</i>, <i>year</i>)” used above. We will see alternative ways of writing this query in Section 3.8.3.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">3.8.2 Set Comparison</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">As an example of the ability of a nested subquery to compare sets, consider the query “Find the names of all instructors whose salary is greater than at least one instructor in the Biology department.” In Section 3.4.1, we wrote this query as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 158pt;text-indent: 0pt;text-align: left;"><b>select distinct </b>T <span class="p">.</span>name</p><p class="s13" style="padding-left: 158pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><b>from </b>instructor <b>as </b>T <span class="p">, </span>instructor <b>as </b>S</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_426.png"/></span></p><p class="s13" style="padding-left: 158pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><b>where </b>T.salary <span class="s83">&gt; </span>S.salary <b>and </b>S.dept name <span class="s15">= </span><span class="p">&#39;Biology&#39;;</span></p><p class="s42" style="padding-top: 8pt;padding-left: 88pt;text-indent: 0pt;line-height: 76%;text-align: justify;">SQL <span class="s43">does, however, oﬀer an alternative style for writing the preceding query. The phrase “greater than at least one” is represented in </span>SQL <span class="s43">by </span><span class="s83">&gt; </span><span class="s63">some</span><span class="p">. This construct allows us to rewrite the query in a form that resembles closely our formulation of the query in</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">English.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 8pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">The subquery:</p><p class="s46" style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 11pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 11pt;text-indent: 0pt;line-height: 17pt;text-align: left;">where <i>salary </i><span class="s83">&gt; </span>some <span class="p">(</span>select <i>salary</i></p><p class="s46" style="padding-left: 106pt;text-indent: 0pt;line-height: 10pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_427.png"/></span></p><p class="s46" style="padding-left: 106pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="s15">= </span><span class="p">&#39;Biology&#39;);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 59pt;text-indent: 0pt;text-align: left;">(<b>select </b><i>salary</i></p><p class="s46" style="padding-left: 61pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_428.png"/></span></p><p class="s46" style="padding-left: 61pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="s15">= </span><span class="p">&#39;Biology&#39;)</span></p><p style="padding-top: 5pt;padding-left: 88pt;text-indent: 0pt;line-height: 19pt;text-align: left;">generates the set of all salary values of all instructors in the Biology department. The <span class="s83">&gt;</span></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><b>some </b>comparison in the <b>where </b>clause of the outer <b>select </b>is true if the <i>salary </i>value of the</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">tuple is greater than at least one member of the set of all salary values for instructors in Biology.</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 65%;text-align: justify;"><span class="s42">SQL </span><span class="s43">also allows </span><span class="s83">&lt; </span><b>some</b>, <span class="s83">&lt;</span><span class="s15">= </span><b>some</b>, <span class="s83">&gt;</span><span class="s15">= </span><b>some</b>, <span class="s15">= </span><b>some</b>, and <span class="s83">&lt;&gt; </span><b>some </b>comparisons. As an exercise, verify that <span class="s15">= </span><b>some </b>is identical to <b>in</b>, whereas <span class="s83">&lt;&gt; </span><b>some </b>is <i>not </i>the same as <b>not in</b>.<span class="s76">10</span></p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Now we modify our query slightly. Let us ﬁnd the names of all instructors that have a salary value greater than that of each instructor in the Biology department. The</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 70%;text-align: justify;">construct <span class="s83">&gt; </span><span class="s63">all </span>corresponds to the phrase “greater than all.” Using this construct, we write the query as follows:</p><p class="s46" style="padding-top: 10pt;padding-left: 169pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;line-height: 17pt;text-align: left;">where <i>salary </i><span class="s83">&gt; </span>all <span class="p">(</span>select <i>salary</i></p><p class="s46" style="padding-left: 253pt;text-indent: 0pt;line-height: 10pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_429.png"/></span></p><p class="s46" style="padding-left: 253pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="s15">= </span><span class="p">&#39;Biology&#39;);</span></p><p style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;line-height: 65%;text-align: justify;">As it does for <b>some</b>, <span class="s44">SQL </span>also allows <span class="s83">&lt; </span><b>all</b>, <span class="s83">&lt;</span><span class="s15">= </span><b>all</b>, <span class="s83">&gt;</span><span class="s15">= </span><b>all</b>, <span class="s15">= </span><b>all</b>, and <span class="s83">&lt;&gt; </span><b>all </b>comparisons. As an exercise, verify that <span class="s83">&lt;&gt; </span><b>all </b>is identical to <b>not in</b>, whereas <span class="s15">= </span><b>all </b>is <i>not </i>the same as <b>in</b>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_430.png"/></span></p><p class="s80" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s77">10</span><span class="s78">The keyword </span><b>any </b>is synonymous to <b>some </b>in <span class="s161">SQL</span>. Early versions of <span class="s161">SQL </span>allowed only <b>any</b>. Later versions added the alternative <b>some </b>to avoid the linguistic ambiguity of the word <i>any </i>in English.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">As another example of set comparisons, consider the query “Find the departments that have the highest average salary.” We begin by writing a query to ﬁnd all average salaries, and then nest it as a subquery of a larger query that ﬁnds those departments for which the average salary is greater than or equal to all average salaries:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_431.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_432.png"/></span></p><p class="s46" style="padding-left: 202pt;text-indent: 0pt;text-align: left;">select <i>dept name </i>from <i>instructor </i>group by <i>dept name</i></p><p style="padding-left: 202pt;text-indent: 0pt;line-height: 16pt;text-align: left;"><b>having avg </b>(<i>salary</i>) <span class="s83">&gt;</span><span class="s15">= </span><b>all </b>(<b>select avg </b>(<i>salary</i>)</p><p class="s46" style="padding-left: 321pt;text-indent: 0pt;line-height: 10pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_433.png"/></span></p><p class="s46" style="padding-left: 321pt;text-indent: 0pt;text-align: left;">group by <i>dept name</i><span class="p">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">3.8.3 Test for Empty Relations</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">includes a feature for testing whether a subquery has any tuples in its result. The </span><span class="s63">exists </span>construct returns the value <b>true </b>if the argument subquery is nonempty. Using the <b>exists </b>construct, we can write the query “Find all courses taught in both the Fall 2017 semester and in the Spring 2018 semester” in still another way:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_434.png"/></span></p><p class="s46" style="padding-left: 178pt;text-indent: 0pt;text-align: left;">select <i>course id</i></p><p class="s46" style="padding-left: 178pt;text-indent: 0pt;text-align: left;">from <i>section </i>as <i>S</i></p><p class="s46" style="padding-left: 206pt;text-indent: -27pt;text-align: left;">where <i>semester </i><span class="s15">= </span><span class="p">&#39;Fall&#39; </span>and <i>year</i><span class="s15">= </span><span class="p">2017 </span>and exists <span class="p">(</span>select <span class="p">*</span></p><p class="s46" style="padding-left: 237pt;text-indent: 0pt;text-align: left;">from <i>section </i>as <i>T</i></p><p class="s46" style="padding-left: 237pt;text-indent: 0pt;text-align: left;">where <i>semester </i><span class="s15">= </span><span class="p">&#39;Spring&#39; </span>and <i>year</i><span class="s15">= </span><span class="p">2018 </span>and</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_435.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_436.png"/></span></p><p class="s13" style="padding-left: 265pt;text-indent: 0pt;text-align: left;">S<span class="p">.</span>course id<span class="s15">= </span>T <span class="p">.</span>course id<span class="p">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The above query also illustrates a feature of <span class="s44">SQL </span>where a <span class="s63">correlation name </span>from an outer query (<i>S </i>in the above query), can be used in a subquery in the <b>where </b>clause. A subquery that uses a correlation name from an outer query is called a <span class="s63">correlated subquery</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In queries that contain subqueries, a scoping rule applies for correlation names. In a subquery, according to the rule, it is legal to use only correlation names deﬁned in the subquery itself or in any query that contains the subquery. If a correlation name is deﬁned both locally in a subquery and globally in a containing query, the local def- inition applies. This rule is analogous to the usual scoping rules used for variables in programming languages.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We can test for the nonexistence of tuples in a subquery by using the <b>not exists </b>construct. We can use the <b>not exists </b>construct to simulate the set containment (that is, superset) operation: We can write “relation <i>A </i>contains relation <i>B</i>” as “<b>not exists </b>(<i>B </i><b>except </b><i>A</i>).” (Although it is not part of the current <span class="s44">SQL </span>standards, the <b>contains </b>opera- tor was present in some early relational systems.) To illustrate the <b>not exists </b>operator,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">consider the query “Find all students who have taken all courses oﬀered in the Biology department.” Using the <b>except </b>construct, we can write the query as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 168pt;text-indent: 0pt;text-align: left;"><b>select </b><i>S</i>.<span class="s69">ID</span>, <i>S</i>.<i>name</i></p><p class="s46" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">from <i>student </i>as <i>S</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_437.png"/></span></p><p class="s46" style="padding-left: 168pt;text-indent: 0pt;text-align: left;">where not exists <span class="p">((</span>select <i>course id</i></p><p class="s46" style="padding-left: 253pt;text-indent: 0pt;text-align: left;">from <i>course</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_438.png"/></span></p><p class="s46" style="padding-left: 253pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="s15">= </span><span class="p">&#39;Biology&#39;)</span></p><p class="s46" style="padding-left: 253pt;text-indent: 0pt;text-align: left;">except</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_439.png"/></span></p><p class="s13" style="padding-left: 253pt;text-indent: 0pt;text-align: left;"><span class="p">(</span><b>select </b>T <span class="p">.</span>course id <b>from </b>takes <b>as </b>T <b>where </b>S<span class="p">.</span><span class="s69">ID </span><span class="s15">= </span>T <span class="p">.</span><span class="s69">ID</span><span class="p">));</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">Here, the subquery:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_440.png"/></span></p><p style="padding-left: 211pt;text-indent: 0pt;text-align: left;">(<b>select </b><i>course id</i></p><p class="s46" style="padding-left: 213pt;text-indent: 0pt;text-align: left;">from <i>course</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_441.png"/></span></p><p class="s46" style="padding-left: 213pt;text-indent: 0pt;text-align: left;">where <i>dept name </i><span class="s15">= </span><span class="p">&#39;Biology&#39;)</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">ﬁnds the set of all courses oﬀered in the Biology department. The subquery:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_442.png"/></span></p><p class="s13" style="padding-left: 235pt;text-indent: -2pt;text-align: left;"><span class="p">(</span><b>select </b>T <span class="p">.</span>course id <b>from </b>takes <b>as </b>T <b>where </b>S<span class="p">.</span><span class="s69">ID </span><span class="s15">= </span>T <span class="p">.</span><span class="s69">ID</span><span class="p">)</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">ﬁnds all the courses that student <i>S</i>.<span class="s69">ID </span>has taken. Thus, the outer <b>select </b>takes each stu- dent and tests whether the set of all courses that the student has taken contains the set of all courses oﬀered in the Biology department.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We saw in Section 3.8.1, an <span class="s44">SQL </span>query to “ﬁnd the total number of (distinct) stu- dents who have taken course sections taught by the instructor with <span class="s69">ID </span>110011”. That query used a tuple constructor syntax that is not supported by some databases. An alternative way to write the query, using the <b>exists </b>construct, is as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 152pt;text-indent: 0pt;text-align: left;">select count <span class="p">(</span>distinct <span class="s69">ID</span><span class="p">)</span></p><p class="s46" style="padding-left: 152pt;text-indent: 0pt;text-align: left;">from <i>takes</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_443.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_444.png"/></span></p><p style="padding-left: 152pt;text-indent: 0pt;text-align: left;"><b>where exists </b>(<b>select </b><i>course id</i>, <i>sec id</i>, <i>semester</i>, <i>year</i></p><p class="s46" style="padding-left: 210pt;text-indent: 0pt;text-align: left;">from <i>teaches</i></p><p style="padding-left: 210pt;text-indent: 0pt;text-align: left;"><b>where </b><i>teaches</i>.<span class="s69">ID</span>= &#39;10101&#39;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_445.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_446.png"/></span></p><p class="s13" style="padding-left: 237pt;text-indent: 0pt;text-align: left;"><b>and </b>takes<span class="p">.</span>course id <span class="p">= </span>teaches<span class="p">.</span>course id</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_447.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_448.png"/></span></p><p class="s13" style="padding-left: 237pt;text-indent: 0pt;text-align: left;"><b>and </b>takes<span class="p">.</span>sec id <span class="p">= </span>teaches<span class="p">.</span>sec id</p><p class="s13" style="padding-left: 237pt;text-indent: 0pt;text-align: left;"><b>and </b>takes<span class="p">.</span>semester <span class="p">= </span>teaches<span class="p">.</span>semester</p><p class="s13" style="padding-left: 237pt;text-indent: 0pt;text-align: left;"><b>and </b>takes<span class="p">.</span>year <span class="p">= </span>teaches<span class="p">.</span>year</p><p style="padding-left: 28pt;text-indent: 0pt;text-align: center;">);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">3.8.4 Test for the Absence of Duplicate Tuples</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">includes a Boolean function for testing whether a subquery has duplicate tuples in its result. The </span><span class="s63">unique </span>construct<span class="s76">11</span> returns the value <b>true </b>if the argument subquery contains no duplicate tuples. Using the <b>unique </b>construct, we can write the query “Find all courses that were oﬀered at most once in 2017” as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_449.png"/></span></p><p class="s13" style="padding-left: 200pt;text-indent: 0pt;text-align: left;"><b>select </b>T <span class="p">.</span>course id</p><p class="s46" style="padding-left: 200pt;text-indent: 0pt;text-align: left;">from <i>course </i>as <i>T</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_450.png"/></span></p><p class="s46" style="padding-left: 200pt;text-indent: 0pt;text-align: left;">where unique <span class="p">(</span>select <i>R</i><span class="p">.</span><i>course id</i></p><p class="s46" style="padding-left: 262pt;text-indent: 0pt;text-align: left;">from <i>section </i>as <i>R</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_451.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_452.png"/></span></p><p class="s13" style="padding-left: 262pt;text-indent: 0pt;text-align: left;"><b>where </b>T <span class="p">.</span>course id<span class="s15">= </span>R<span class="p">.</span>course id <b>and</b></p><p class="s13" style="padding-left: 290pt;text-indent: 0pt;text-align: left;">R<span class="p">.</span>year <span class="s15">= </span><span class="p">2017);</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Note that if a course were not oﬀered in 2017, the subquery would return an empty result, and the <b>unique </b>predicate would evaluate to true on the empty set.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: left;">An equivalent version of this query not using the <b>unique </b>construct is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_453.png"/></span></p><p class="s13" style="padding-left: 202pt;text-indent: 0pt;text-align: left;"><b>select </b>T <span class="p">.</span>course id</p><p class="s46" style="padding-left: 202pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>course </i>as <i>T</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_454.png"/></span></p><p style="padding-left: 202pt;text-indent: 0pt;line-height: 17pt;text-align: left;"><b>where </b>1 <span class="s83">&gt;</span><span class="s15">= </span>(<b>select count</b>(<i>R</i>.<i>course id</i>)</p><p class="s46" style="padding-left: 260pt;text-indent: 0pt;line-height: 10pt;text-align: left;">from <i>section </i>as <i>R</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_455.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_456.png"/></span></p><p class="s13" style="padding-left: 260pt;text-indent: 0pt;text-align: left;"><b>where </b>T <span class="p">.</span>course id<span class="s15">= </span>R<span class="p">.</span>course id <b>and</b></p><p class="s13" style="padding-left: 288pt;text-indent: 0pt;text-align: left;">R<span class="p">.</span>year <span class="s15">= </span><span class="p">2017);</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">We can test for the existence of duplicate tuples in a subquery by using the <b>not unique </b>construct. To illustrate this construct, consider the query “Find all courses that were oﬀered at least twice in 2017” as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_457.png"/></span></p><p class="s13" style="padding-left: 191pt;text-indent: 0pt;text-align: left;"><b>select </b>T <span class="p">.</span>course id</p><p class="s46" style="padding-left: 191pt;text-indent: 0pt;text-align: left;">from <i>course </i>as <i>T</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_458.png"/></span></p><p class="s46" style="padding-left: 191pt;text-indent: 0pt;text-align: left;">where not unique <span class="p">(</span>select <i>R</i><span class="p">.</span><i>course id</i></p><p class="s46" style="padding-left: 271pt;text-indent: 0pt;text-align: left;">from <i>section </i>as <i>R</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_459.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_460.png"/></span></p><p class="s13" style="padding-left: 271pt;text-indent: 0pt;text-align: left;"><b>where </b>T <span class="p">.</span>course id<span class="s15">= </span>R<span class="p">.</span>course id <b>and</b></p><p class="s13" style="padding-left: 298pt;text-indent: 0pt;text-align: left;">R<span class="p">.</span>year <span class="s15">= </span><span class="p">2017);</span></p><p class="s13" style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;line-height: 13pt;text-align: justify;"><span class="p">Formally, the </span><b>unique </b><span class="p">test on a relation is deﬁned to fail if and only if the relation contains two distinct tuples </span>t<span class="s130">1 </span><span class="s94">and </span>t<span class="s130">2 </span><span class="s94">such that </span>t<span class="s130">1 </span><span class="s15">= </span>t<span class="s130">2</span><span class="s94">. Since the test </span>t<span class="s130">1 </span><span class="s15">= </span>t<span class="s130">2 </span><span class="s94">fails if any of the ﬁelds of </span>t<span class="s98">1</span><span class="p"> or </span>t<span class="s98">2</span><span class="p"> are null, it is possible for </span><b>unique </b><span class="p">to be true even if there are multiple copies of a tuple, as long as at least one of the attributes of the tuple is null.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_461.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">11 <span class="s78">This construct is not yet widely implemented.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">3.8.5 Subqueries in the From Clause</p><p class="s46" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">allows a subquery expression to be used in the </span>from <span class="p">clause. The key concept ap- plied here is that any </span>select<span class="p">-</span>from<span class="p">-</span>where <span class="p">expression returns a relation as a result and, therefore, can be inserted into another </span>select<span class="p">-</span>from<span class="p">-</span>where <span class="p">anywhere that a relation can appear.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Consider the query “Find the average instructors’ salaries of those departments where the average salary is greater than $42,000.” We wrote this query in Section 3.7 by using the <b>having </b>clause. We can now rewrite this query, without using the <b>having </b>clause, by using a subquery in the <b>from </b>clause, as follows:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_462.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_463.png"/></span></p><p class="s13" style="padding-top: 10pt;padding-left: 170pt;text-indent: 0pt;text-align: justify;"><b>select </b>dept name<span class="p">, </span>avg salary</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_464.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_465.png"/></span></p><p style="padding-left: 170pt;text-indent: 0pt;text-align: justify;"><b>from </b>(<b>select </b><i>dept name</i>, <b>avg </b>(<i>salary</i>) <b>as </b><i>avg salary</i></p><p class="s46" style="padding-left: 195pt;text-indent: 0pt;text-align: justify;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_466.png"/></span></p><p class="s46" style="padding-left: 195pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">group by <i>dept name</i><span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_467.png"/></span></p><p class="s46" style="padding-left: 170pt;text-indent: 0pt;line-height: 20pt;text-align: justify;">where <i>avg salary </i><span class="s83">&gt; </span><span class="p">42000;</span></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The subquery generates a relation consisting of the names of all departments and their corresponding average instructors’ salaries. The attributes of the subquery result can be used in the outer query, as can be seen in the above example.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Note that we do not need to use the <b>having </b>clause, since the subquery in the <b>from </b>clause computes the average salary, and the predicate that was in the <b>having </b>clause earlier is now in the <b>where </b>clause of the outer query.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We can give the subquery result relation a name, and rename the attributes, using the <b>as </b>clause, as illustrated below.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_468.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_469.png"/></span></p><p class="s13" style="padding-top: 10pt;padding-left: 188pt;text-indent: 0pt;text-align: left;"><b>select </b>dept name<span class="p">, </span>avg salary</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_470.png"/></span></p><p style="padding-left: 188pt;text-indent: 0pt;text-align: left;"><b>from </b>(<b>select </b><i>dept name</i>, <b>avg </b>(<i>salary</i>)</p><p class="s46" style="padding-left: 213pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_471.png"/></span></p><p class="s46" style="padding-left: 213pt;text-indent: 0pt;text-align: left;">group by <i>dept name</i><span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_472.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_473.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_474.png"/></span></p><p class="s13" style="padding-left: 213pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><b>as </b>dept avg <span class="p">(</span>dept name<span class="p">, </span>avg salary<span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_475.png"/></span></p><p class="s46" style="padding-left: 188pt;text-indent: 0pt;line-height: 20pt;text-align: left;">where <i>avg salary </i><span class="s83">&gt; </span><span class="p">42000;</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_476.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_477.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_478.png"/></span></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: -3pt;text-align: left;">The subquery result relation is named <i>dept avg</i>, with the attributes <i>dept name </i>and <i>avg salary</i>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Nested subqueries in the <b>from </b>clause are supported by most but not all <span class="s44">SQL </span>imple- mentations. Note that some <span class="s44">SQL </span>implementations, notably <span class="s44">M</span>y<span class="s44">SQL </span>and <span class="s44">P</span>ostgre<span class="s44">SQL</span>, require that each subquery relation in the <b>from </b>clause must be given a name, even if the name is never referenced; Oracle allows a subquery result relation to be given a name (with the keyword <b>as </b>omitted) but does not allow renaming of attributes of the relation. An easy workaround for that is to do the attribute renaming in the <b>select </b>clause of the subquery; in the above query, the <b>select </b>clause of the subquery would be replaced by</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_479.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_480.png"/></span></p><p style="padding-top: 6pt;padding-left: 137pt;text-indent: 0pt;text-align: justify;"><b>select </b><i>dept name</i>, <b>avg</b>(<i>salary</i>) <b>as </b><i>avg salary</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">and</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_481.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_482.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_483.png"/></span></p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: 0pt;text-align: left;">“<b>as </b><i>dept avg </i>(<i>dept name</i>, <i>avg salary</i>)”</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">would be replaced by</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_484.png"/></span></p><p style="padding-top: 6pt;padding-left: 168pt;text-indent: 0pt;text-align: justify;">“<b>as </b><i>dept avg</i>”.</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">As another example, suppose we wish to ﬁnd the maximum across all departments of the total of all instructors’ salaries in each department. The <b>having </b>clause does not help us in this task, but we can write this query easily by using a subquery in the <b>from </b>clause, as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_485.png"/></span></p><p style="padding-left: 172pt;text-indent: 0pt;text-align: left;"><b>select max </b>(<i>tot salary</i>)</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_486.png"/></span></p><p style="padding-left: 198pt;text-indent: -26pt;text-align: left;"><b>from </b>(<b>select </b><i>dept name</i>, <b>sum</b>(<i>salary</i>) <b>from </b><i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_487.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_488.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_489.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_490.png"/></span></p><p class="s13" style="padding-left: 198pt;text-indent: 0pt;text-align: left;"><b>group by </b>dept name<span class="p">) </span><b>as </b>dept total <span class="p">(</span>dept name<span class="p">, </span>tot salary<span class="p">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We note that nested subqueries in the <b>from </b>clause cannot use correlation variables from other relations in the same <b>from </b>clause. However, the <span class="s44">SQL </span>standard, starting with <span class="s44">SQL:2003</span>, allows a subquery in the <b>from </b>clause that is preﬁxed by the <span class="s63">lateral </span>keyword to access attributes of preceding tables or subqueries in the same <b>from </b>clause. For example, if we wish to print the names of each instructor, along with their salary and the average salary in their department, we could write the query as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_491.png"/></span></p><p class="s13" style="padding-left: 173pt;text-indent: 0pt;text-align: left;"><b>select </b>name<span class="p">, </span>salary<span class="p">, </span>avg salary</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_492.png"/></span></p><p style="padding-left: 173pt;text-indent: 0pt;text-align: left;"><b>from </b><i>instructor I1</i>, <b>lateral </b>(<b>select avg</b>(<i>salary</i>) as <i>avg salary</i></p><p class="s46" style="padding-left: 287pt;text-indent: 0pt;text-align: left;">from <i>instructor I2</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_493.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_494.png"/></span></p><p class="s13" style="padding-left: 287pt;text-indent: 0pt;text-align: left;"><b>where </b>I2<span class="p">.</span>dept name<span class="p">= </span>I1<span class="p">.</span>dept name<span class="p">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Without the <b>lateral </b>clause, the subquery cannot access the correlation variable <i>I1 </i>from the outer query. Only the more recent implementations of <span class="s44">SQL </span>support the <b>lateral </b>clause.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">3.8.6 The With Clause</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The <span class="s63">with </span>clause provides a way of deﬁning a temporary relation whose deﬁnition is available only to the query in which the <b>with </b>clause occurs. Consider the following query, which ﬁnds those departments with the maximum budget.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_495.png"/></span></p><p style="padding-left: 227pt;text-indent: -21pt;text-align: left;"><b>with </b><i>max budget </i>(<i>value</i>) <b>as </b>(<b>select max</b>(<i>budget</i>) <b>from </b><i>department</i>)</p><p class="s46" style="padding-left: 206pt;text-indent: 0pt;text-align: left;">select <i>budget</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_496.png"/></span></p><p class="s13" style="padding-left: 206pt;text-indent: 0pt;text-align: left;"><b>from </b>department<span class="p">, </span>max budget</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_497.png"/></span></p><p class="s13" style="padding-left: 206pt;text-indent: 0pt;text-align: left;"><b>where </b>department<span class="p">.</span>budget <span class="s15">= </span>max budget.value<span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_498.png"/></span></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <b>with </b>clause in the query deﬁnes the temporary relation <i>max budget </i>containing the results of the subquery deﬁning the relation. The relation is available for use only within later parts of the same query. <span class="s76">12</span> The <b>with </b>clause, introduced in <span class="s44">SQL:1999</span>, is supported by many, but not all, database systems.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We could have written the preceding query by using a nested subquery in either the <b>from </b>clause or the <b>where </b>clause. However, using nested subqueries would have made the query harder to read and understand. The <b>with </b>clause makes the query logic clearer; it also permits this temporary relation to be used in multiple places within a query.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">For example, suppose we want to ﬁnd all departments where the total salary is greater than the average of the total salary at all departments. We can write the query using the <b>with </b>clause as follows.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_499.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_500.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_501.png"/></span></p><p style="padding-left: 200pt;text-indent: -21pt;text-align: justify;"><b>with </b><i>dept total </i>(<i>dept name</i>, <i>value</i>) <b>as </b>(<b>select </b><i>dept name</i>, <b>sum</b>(<i>salary</i>) <b>from </b><i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_502.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_503.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_504.png"/></span></p><p class="s13" style="padding-left: 179pt;text-indent: 21pt;text-align: justify;"><b>group by </b>dept name<span class="p">), </span>dept total avg<span class="p">(</span>value<span class="p">) </span><b>as</b></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_505.png"/></span></p><p style="padding-left: 200pt;text-indent: 0pt;text-align: justify;">(<b>select avg</b>(<i>value</i>) <b>from </b><i>dept total</i>)</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_506.png"/></span></p><p class="s46" style="padding-left: 179pt;text-indent: 0pt;text-align: left;">select <i>dept name</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_507.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_508.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_509.png"/></span></p><p class="s13" style="padding-left: 179pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><b>from </b>dept total<span class="p">, </span>dept total avg</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_510.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_511.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_512.png"/></span></p><p class="s13" style="padding-left: 179pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><b>where </b>dept total.value <span class="s83">&gt; </span>dept total avg.value<span class="p">;</span></p><p style="padding-top: 5pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">We can create an equivalent query without the <b>with </b>clause, but it would be more com- plicated and harder to understand. You can write the equivalent query as an exercise.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">3.8.7 Scalar Subqueries</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">allows subqueries to occur wherever an expression returning a value is permitted, provided the subquery returns only one tuple containing a single attribute; such sub- queries are called </span><span class="s63">scalar subqueries</span>. For example, a subquery can be used in the <b>select </b>clause as illustrated in the following example that lists all departments along with the number of instructors in each department:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_513.png"/></span></p><p class="s46" style="padding-left: 146pt;text-indent: 0pt;text-align: left;">select <i>dept name</i><span class="p">,</span></p><p style="padding-left: 178pt;text-indent: -5pt;text-align: left;">(<b>select count</b>(*) <b>from </b><i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_514.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_515.png"/></span></p><p class="s13" style="padding-left: 178pt;text-indent: 0pt;text-align: left;"><b>where </b>department<span class="p">.</span>dept name <span class="p">= </span>instructor<span class="p">.</span>dept name<span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_516.png"/></span></p><p class="s46" style="padding-left: 172pt;text-indent: 0pt;text-align: left;">as <i>num instructors</i></p><p class="s46" style="padding-left: 146pt;text-indent: 0pt;text-align: left;">from <i>department</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_517.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;"><span class="s77">12</span>The <span class="s153">SQL </span>evaluation engine may not physically create the relation and is free to compute the overall query result in alternative ways, as long as the result of the query is the same as if the relation had been created.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_518.png"/></span></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The subquery in this example is guaranteed to return only a single value since it has a <b>count</b>(*) aggregate without a <b>group by</b>. The example also illustrates the usage of cor- relation variables, that is, attributes of relations in the <b>from </b>clause of the outer query, such as <i>department</i>.<i>dept name </i>in the above example.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Scalar subqueries can occur in <b>select</b>, <b>where</b>, and <b>having </b>clauses. Scalar subqueries may also be deﬁned without aggregates. It is not always possible to ﬁgure out at compile time if a subquery can return more than one tuple in its result; if the result has more than one tuple when the subquery is executed, a run-time error occurs.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that technically the type of a scalar subquery result is still a relation, even if it contains a single tuple. However, when a scalar subquery is used in an expression where a value is expected, <span class="s44">SQL </span>implicitly extracts the value from the single attribute of the single tuple in the relation and returns that value.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">3.8.8 Scalar Without a From Clause</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Certain queries require a calculation but no reference to any relation. Similarly, certain queries may have subqueries that contain a <b>from </b>clause without the top-level query needing a <b>from </b>clause.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As an example, suppose we wish to ﬁnd the average number of sections taught (re- gardless of year or semester) per instructor, with sections taught by multiple instructors counted once per instructor. We need to count the number of tuples in <i>teaches </i>to ﬁnd the total number of sections taught and count the number of tuples in <i>instructor </i>to ﬁnd the number of instructors. Then a simple division gives us the desired result. One might write this as:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 162pt;text-indent: 0pt;text-align: left;">(<b>select count </b>(*) <b>from </b><i>teaches</i>) / (<b>select count </b>(*) <b>from </b><i>instructor</i>);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">While this is legal in some systems, others will report an error due to the lack of a <b>from </b>clause.<span class="s76">13</span> In the latter case, a special dummy relation called, for example, <i>dual </i>can be created, containing a single tuple. This allows the preceding query to be written as:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 151pt;text-indent: 0pt;text-align: left;">select <span class="p">(</span>select count <span class="p">(*) </span>from <i>teaches</i><span class="p">) / (</span>select count <span class="p">(*) </span>from <i>instructor</i><span class="p">)</span></p><p class="s46" style="padding-left: 151pt;text-indent: 0pt;text-align: left;">from <i>dual</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Oracle provides a predeﬁned relation called <i>dual</i>, containing a single tuple, for uses such as the above (the relation has a single attribute, which is not relevant for our purposes); you can create an equivalent relation if you use any other database.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Since the above queries divide one integer by another, the result would, on most databases, be an integer, which would result in loss of precision. If you wish to get the result as a ﬂoating point number, you could multiply one of the two subquery results by</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 19pt;text-align: justify;">1<span class="s83">.</span>0 to convert it to a ﬂoating point number, before the division operation is performed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_519.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 32pt;text-indent: 0pt;text-align: center;"><span class="s77">13</span>This construct is legal, for example, in <span class="s153">SQL S</span>erver, but not legal, for example, in Oracle.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="493" height="408" alt="image" src="Image_520.png"/></span></p><p class="s73" style="padding-left: 59pt;text-indent: 0pt;text-align: center;"><a name="bookmark53">Note 3.3 </a><span class="s146">SQL AND MULTISET RELATIONAL ALGEBRA - PART 3</span><a name="bookmark95">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 97pt;text-indent: 0pt;text-align: justify;">Unlike the <span class="s44">SQL </span>set and aggregation operations that we studied earlier in this chap- ter, <span class="s44">SQL </span>subqueries do not have directly equivalent operations in the relational al- gebra. Most <span class="s44">SQL </span>queries involving subqueries can be rewritten in a way that does not require the use of subqueries, and thus they have equivalent relational algebra expressions.</p><p style="padding-top: 2pt;padding-left: 97pt;text-indent: 17pt;line-height: 81%;text-align: justify;">Rewriting to relational algebra can beneﬁt from two extended relational al- gebra operations called <i>semijoin</i>, denoted <span class="s86">⋉</span>, and <i>antijoin</i>, denoted <span class="s86">⋉</span>, which are supported internally by many database implementations (the symbol <span class="s86">⊳ </span>is some- times used in place of <span class="s86">⋉ </span>to denote antijoin). For example, given relations <i>r </i>and <i>s</i>,</p><p class="s13" style="padding-left: 97pt;text-indent: 0pt;line-height: 64%;text-align: justify;">r <span class="s86">⋉</span><span class="s149">r</span><span class="s167">.</span><span class="s149">A</span><span class="s136">=</span><span class="s149">s</span><span class="s167">.</span><span class="s149">B </span><span class="s168">s </span><span class="p">outputs all tuples in </span>r <span class="p">that have at least one tuple in </span>s <span class="p">whose </span>s<span class="s83">.</span>B <span class="p">attribute value matches that tuples </span>r<span class="s83">.</span>A <span class="p">attribute value. Conversely, </span>r <span class="s86">⋉</span><span class="s169">r</span><span class="s170">.</span><span class="s169">A</span><span class="s171">=</span><span class="s169">s</span><span class="s170">.</span><span class="s169">B </span><span class="s168">s </span><span class="p">outputs all tu- ples in </span>r <span class="p">that have do not have any such matching tuple in </span>s<span class="p">. These operators can</span></p><p style="padding-top: 1pt;padding-left: 97pt;text-indent: 0pt;text-align: right;">be used to rewrite many subqueries that use the <b>exists </b>and <b>not exists </b>connectives. Semijoin and antijoin can be expressed using other relational algebra opera- tions, so they do not add any expressive power, but they are nevertheless quite</p><p style="padding-left: 97pt;text-indent: 0pt;text-align: justify;">useful in practice since they can be implemented very eﬃciently.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">However, the process of rewriting <span class="s44">SQL </span>queries that contain subqueries is in general not straightforward. Database system implementations therefore extend the relational algebra by allowing <span class="s15">σ </span>and <span class="s15">Π </span>operators to invoke subqueries in their predicates and projection lists.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part91.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part93.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
