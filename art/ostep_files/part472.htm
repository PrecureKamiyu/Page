<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Metadata Journaling</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part471.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part473.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Metadata Journaling</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Although recovery is now fast (scanning the journal and replaying a few transactions as opposed to scanning the entire disk), normal operation of the file system is slower than we might desire. In particular, for each write to disk, we are now also writing to the journal first, thus doubling write traffic; this doubling is especially painful during sequential write workloads, which now will proceed at half the peak write bandwidth of the drive. Further, between writes to the journal and writes to the main file system, there is a costly seek, which adds noticeable overhead for some workloads.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Because of the high cost of writing every data block to disk twice, peo- ple have tried a few different things in order to speed up performance. For example, the mode of journaling we described above is often called <b>data journaling </b>(as in Linux ext3), as it journals all user data (in addition to the metadata of the file system). A simpler (and more common) form of journaling is sometimes called <b>ordered journaling </b>(or just <b>metadata</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Journal</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;"><b>journaling</b>), and it is nearly the same, except that user data is <i>not </i>writ- ten to the journal. Thus, when performing the same update as above, the following information would be written to the journal:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:90.59pt" cellspacing="0"><tr style="height:29pt"><td style="width:14pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#D3D3D3"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s95" style="text-indent: 0pt;text-align: left;">TxB</p></td><td style="width:29pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s95" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">I[v2]</p></td><td style="width:29pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s95" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">B[v2]</p></td><td style="width:14pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt;border-right-style:solid;border-right-width:1pt" bgcolor="#D3D3D3"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s95" style="text-indent: 0pt;text-align: left;">TxE</p></td><td style="width:173pt;border-top-style:solid;border-top-width:1pt;border-left-style:solid;border-left-width:1pt;border-bottom-style:solid;border-bottom-width:1pt"><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 4pt;text-align: left;"><span><img width="63" height="5" alt="image" src="Image_624.png"/></span></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The data block Db, previously written to the log, would instead be written to the file system proper, avoiding the extra write; given that most I/O traffic to the disk is data, not writing data twice substantially reduces the I/O load of journaling. The modification does raise an interesting question, though: when should we write data blocks to disk?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let’s again consider our example append of a file to understand the problem better. The update consists of three blocks: I[v2], B[v2], and Db. The first two are both metadata and will be logged and then check- pointed; the latter will only be written once to the file system. When should we write Db to disk? Does it matter?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: right;">As it turns out, the ordering of the data write does matter for metadata- only journaling. For example, what if we write Db to disk <i>after </i>the trans- action (containing I[v2] and B[v2]) completes? Unfortunately, this ap- proach has a problem: the file system is consistent but I[v2] may end up pointing to garbage data. Specifically, consider the case where I[v2] and B[v2] are written but Db did not make it to disk. The file system will then try to recover. Because Db is <i>not </i>in the log, the file system will replay writes to I[v2] and B[v2], and produce a consistent file system (from the perspective of file-system metadata). However, I[v2] will be pointing to garbage data, i.e., at whatever was in the the slot where Db was headed. To ensure this situation does not arise, some file systems (e.g., Linux ext3) write data blocks (of regular files) to the disk <i>first</i>, before related</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">metadata is written to disk. Specifically, the protocol is as follows:</p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: -11pt;line-height: 89%;text-align: left;">1. <b>Data write: </b>Write data to final location; wait for completion (the wait is optional; see below for details).</p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 89%;text-align: left;">2. <b>Journal metadata write: </b>Write the begin block and metadata to the log; wait for writes to complete.</p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 89%;text-align: justify;">3. <b>Journal commit: </b>Write the transaction commit block (containing TxE) to the log; wait for the write to complete; the transaction (in- cluding data) is now <b>committed</b>.</p><p style="padding-left: 91pt;text-indent: -11pt;line-height: 89%;text-align: justify;">4. <b>Checkpoint metadata: </b>Write the contents of the metadata update to their final locations within the file system.</p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">5. <b>Free: </b>Later, mark the transaction free in journal superblock.</p><p style="padding-top: 6pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">By forcing the data write first, a file system can guarantee that a pointer will never point to garbage. Indeed, this rule of “write the pointed to ob- ject before the object with the pointer to it” is at the core of crash consis- tency, and is exploited even further by other crash consistency schemes [GP94] (see below for details).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In most systems, metadata journaling (akin to ordered journaling of ext3) is more popular than full data journaling. For example, Windows NTFS and SGI’s XFS both use non-ordered metadata journaling. Linux ext3 gives you the option of choosing either data, ordered, or unordered modes (in unordered mode, data can be written at any time). All of these modes keep metadata consistent; they vary in their semantics for data.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Finally, note that forcing the data write to complete (Step 1) before issuing writes to the journal (Step 2) is not required for correctness, as indicated in the protocol above. Specifically, it would be fine to issue data writes as well as the transaction-begin block and metadata to the journal; the only real requirement is that Steps 1 and 2 complete before the issuing of the journal commit block (Step 3).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part471.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part473.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
