<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Simple But Not Scalable</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part299.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part301.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Simple But Not Scalable</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">As you can see, the non-synchronized counter is a trivial data structure, requiring a tiny amount of code to implement. We now have our next challenge: how can we make this code <b>thread safe</b>? Figure <span style=" color: #00AEEF;">29.2 </span>shows how we do so.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">311</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 5pt;padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>typedef struct <span class="s75">&nbsp;</span>counter_t {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2    <span class="s38">int value;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">} counter_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">4</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">5  </span>void init(counter_t <span class="s39">*</span>c) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">6    <span class="s38">c-&gt;value = 0;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">8</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">9  </span>void increment(counter_t <span class="s39">*</span>c) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">10    <span class="s38">c-&gt;value++;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">12</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">13  </span>void decrement(counter_t <span class="s39">*</span>c) {</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;line-height: 7pt;text-align: left;">14    <span class="s38">c-&gt;value--;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">15  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">16</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">17  </span>int get(counter_t <span class="s39">*</span>c) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">18    <span class="s38">return c-&gt;value;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">19  <span class="s38">}</span></p><p style="padding-left: 136pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 29.1: <b>A Counter Without Locks</b></p><p class="s38" style="padding-top: 5pt;padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>typedef struct <span class="s75">&nbsp;</span>counter_t {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2     <span class="s38">int     value;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3    <span class="s38">pthread_lock_t lock;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38">} counter_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">5</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">6  </span>void init(counter_t <span class="s39">*</span>c) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">7    <span class="s38">c-&gt;value = 0;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8    <span class="s38">Pthread_mutex_init(&amp;c-&gt;lock, NULL);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">10</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">11  </span>void increment(counter_t <span class="s39">*</span>c) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">12    <span class="s38">Pthread_mutex_lock(&amp;c-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">13    <span class="s38">c-&gt;value++;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">14    <span class="s38">Pthread_mutex_unlock(&amp;c-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">15  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">16</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">17  </span>void decrement(counter_t <span class="s39">*</span>c) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">18    <span class="s38">Pthread_mutex_lock(&amp;c-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">19    <span class="s38">c-&gt;value--;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">20    <span class="s38">Pthread_mutex_unlock(&amp;c-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">21  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">22</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">23  </span>int get(counter_t <span class="s39">*</span>c) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">24    <span class="s38">Pthread_mutex_lock(&amp;c-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">25    <span class="s38">int rc = c-&gt;value;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">26    <span class="s38">Pthread_mutex_unlock(&amp;c-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">27    <span class="s38">return rc;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">28  <span class="s38">}</span></p><p style="padding-left: 143pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Figure 29.2: <b>A Counter With Locks</b></p><p style="padding-top: 1pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This concurrent counter is simple and works correctly. In fact, it fol- lows a design pattern common to the simplest and most basic concurrent data structures: it simply adds a single lock, which is acquired when call- ing a routine that manipulates the data structure, and is released when returning from the call. In this manner, it is similar to a data structure built with <b>monitors </b>[BH73], where locks are acquired and released auto- matically as you call and return from object methods.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="196" height="141" alt="image" src="Image_375.png"/></span></p><p class="s65" style="text-indent: 0pt;line-height: 90%;text-align: left;">Precise Sloppy</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 110pt;text-indent: 0pt;text-align: left;">15</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 1pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Time (seconds)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 110pt;text-indent: 0pt;text-align: left;">10</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 4pt;padding-left: 114pt;text-indent: 0pt;text-align: left;">5</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 4pt;text-indent: 0pt;line-height: 8pt;text-align: center;">0</p><p class="s47" style="padding-left: 42pt;text-indent: 0pt;line-height: 8pt;text-align: center;">1     2     3     4</p><p class="s47" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: center;">Threads</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 63pt;text-indent: 0pt;text-align: justify;">Figure 29.3: <b>Performance of Traditional vs. Sloppy Counters</b></p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">At this point, you have a working concurrent data structure. The prob- lem you might have is performance. If your data structure is too slow, you’ll have to do more than just add a single lock; such optimizations, if needed, are thus the topic of the rest of the chapter. Note that if the data structure is <i>not </i>too slow, you are done! No need to do something fancy if something simple will work.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To understand the performance costs of the simple approach, we run a benchmark in which each thread updates a single shared counter a fixed number of times; we then vary the number of threads. Figure <span style=" color: #00AEEF;">29.3 </span>shows the total time taken, with one to four threads active; each thread updates the counter one million times. This experiment was run upon an iMac with four Intel 2.7 GHz i5 CPUs; with more CPUs active, we hope to get more total work done per unit time.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">From the top line in the figure (labeled <i>precise</i>), you can see that the performance of the synchronized counter scales poorly. Whereas a single thread can complete the million counter updates in a tiny amount of time (roughly 0.03 seconds), having two threads each update the counter one million times concurrently leads to a massive slowdown (taking over 5 seconds!). It only gets worse with more threads.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Ideally, you’d like to see the threads complete just as quickly on mul- tiple processors as the single thread does on one. Achieving this end is called <b>perfect scaling</b>; even though more work is done, it is done in par- allel, and hence the time taken to complete the task is not increased.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part299.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part301.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
