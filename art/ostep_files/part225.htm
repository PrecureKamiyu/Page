<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>22.1 Cache Management</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part224.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part226.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">22.1 Cache Management</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Before diving into policies, we first describe the problem we are trying to solve in more detail. Given that main memory holds some subset of all the pages in the system, it can rightly be viewed as a <b>cache </b>for virtual memory pages in the system. Thus, our goal in picking a replacement policy for this cache is to minimize the number of <b>cache misses</b>; that is, to minimize the number of times that we have to go to disk to fetch the desired page. Alternately, one can view our goal as maximizing the num- ber of <b>cache hits</b>, i.e., the number of times a page that is read or written is found in memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">227</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Knowing the number of cache hits and misses let us calculate the <b>av- erage memory access time </b>(<b>AMAT</b>) for a program (a metric computer architects compute for hardware caches [HP06]). Specifically, given these values, we can compute the AMAT of a program as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s43" style="padding-left: 132pt;text-indent: 0pt;text-align: left;">AMAT <span class="s44">= (</span>Hit<span class="s122">%</span><span class="s64"> </span><span class="s4">· </span>T<span class="s56">M</span> <span class="s44">) + (</span>Miss<span class="s122">%</span><span class="s64"> </span><span class="s4">· </span>T<span class="s56">D</span><span class="s44">)      </span><span class="p">(22.1)</span></p><p class="s61" style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: left;">where <span class="s57">T</span><span class="s58">M </span>represents the cost of accessing memory, and represents <span class="s57">T</span><span class="s58">D </span>the <span class="p">cost of accessing disk.</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 90%;text-align: left;">For example, let us imagine a machine with a (tiny) address space: 4KB, with 256-byte pages. Thus, a virtual address has two components: a 4-bit VPN (the most-significant bits) and an 8-bit offset (the least-significant bits). Thus, a process in this example can access <span class="s44">2</span><span class="s101">4</span><span class="s64"> </span>or 16 total virtual pages. In this example, the process generates the following memory ref- erences (i.e., virtual addresses): 0x000, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 0x900. These virtual addresses refer to the first byte of each of the first ten pages of the address space (the page number being the first hex digit of each virtual address).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let us further assume that every page except virtual page 3 are already in memory. Thus, our sequence of memory references will encounter the following behavior: hit, hit, hit, miss, hit, hit, hit, hit, hit, hit. We can compute the <b>hit rate </b>(the percent of references found in memory): 90%, as 9 out of 10 references are in memory. The <b>miss rate </b>is obviously 10%.</p><p class="s61" style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;"><span class="p">To calculate AMAT, we simply need to know the cost of accessing memory and the cost of accessing disk. Assuming the cost of access- </span>ing memory (<span class="s57">T</span><span class="s58">M </span>) is around 100 nanoseconds, and the cost of access- ing disk (<span class="s57">T</span><span class="s58">D </span>) is about 10 milliseconds, we have the following AMAT:</p><p class="s44" style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">0<span class="s43">.</span>9 <span class="s4">· </span>100<span class="s43">ns </span>+ 0<span class="s43">.</span>1 <span class="s4">· </span>10<span class="s43">ms</span><span class="p">, which is </span>90<span class="s43">ns </span>+ 1<span class="s43">ms</span><span class="p">, or 1.00009 ms, or about 1 millisecond. If our hit rate had instead been 99.9%, the result is quite different: AMAT is 10.1 microseconds, or roughly 100 times faster. As the hit rate approaches 100%, AMAT approaches 100 nanoseconds.</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Unfortunately, as you can see in this example, the cost of disk access is so high in modern systems that even a tiny miss rate will quickly dom- inate the overall AMAT of running programs. Clearly, we need to avoid as many misses as possible or run slowly, at the rate of the disk. One way to help with this is to carefully develop a smart policy, as we now do.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part224.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part226.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
