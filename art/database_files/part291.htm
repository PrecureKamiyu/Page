<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part290.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part292.htm">下一个 &gt;</a></p><p class="s45" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">Exercises</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 155pt;text-indent: -34pt;text-align: justify;">15.17  <span class="p">Suppose you need to sort a relation of 40 gigabytes, with 4-kilobyte blocks, using a memory size of 40 megabytes. Suppose the cost of a seek is 5 millisec- onds, while the disk transfer rate is 40 megabytes per second.</span></p><p style="padding-top: 9pt;padding-left: 163pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">a.  Find the cost of sorting the relation, in seconds, with <i>b</i><span class="s97">b </span><span class="s15">= </span>1 and with</p><p class="s13" style="padding-left: 5pt;text-indent: 0pt;line-height: 14pt;text-align: center;">b<span class="s97">b </span><span class="s15">= </span><span class="p">100.</span></p><p style="padding-top: 4pt;padding-left: 162pt;text-indent: 0pt;text-align: justify;">b. In each case, how many merge passes are required?</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;line-height: 13pt;text-align: justify;">c.  Suppose a ﬂash storage device is used instead of a disk, and it has a latency of 20 microsecond and a transfer rate of 400 megabytes per sec- ond. Recompute the cost of sorting the relation, in seconds, with <i>b</i><span class="s97">b </span><span class="s15">= </span>1 and with <i>b</i><span class="s145">b </span><span class="s15">= </span>100, in this setting.</p><p style="padding-top: 9pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;"><b>15.18 </b>Why is it not desirable to force users to make an explicit choice of a query- processing strategy? Are there cases in which it <i>is </i>desirable for users to be aware of the costs of competing query-processing strategies? Explain your answer.</p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;">15.19  <span class="p">Design a variant of the hybrid merge-join algorithm for the case where both relations are not physically sorted, but both have a sorted secondary index on the join attributes.</span></p><p class="s13" style="padding-top: 7pt;padding-left: 155pt;text-indent: -36pt;line-height: 90%;text-align: justify;"><b>15.20  </b><span class="p">Estimate the number of block transfers and seeks required by your solution to Exercise 15.19 for </span>r<span class="s93">1 </span><span class="s86">⋈ </span>r<span class="s93">2</span><span class="s94">, where </span>r<span class="s93">1 </span><span class="s94">and </span>r<span class="s93">2 </span><span class="s94">are as deﬁned in Exercise 15.3.</span></p><p style="padding-top: 4pt;padding-left: 155pt;text-indent: -35pt;text-align: justify;"><b>15.21  </b>The hash-join algorithm as described in Section 15.5.5 computes the natural join of two relations. Describe how to extend the hash-join algorithm to com- pute the natural left outer join, the natural right outer join, and the natural full outer join. (Hint: Keep extra information with each tuple in the hash index to detect whether any tuple in the probe relation matches the tuple in the hash index.) Try out your algorithm on the <i>takes </i>and <i>student </i>relations.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -36pt;line-height: 90%;text-align: justify;"><a name="bookmark334"><b>15.22  </b></a>Suppose you have to compute <span class="s169">A</span><span class="s15">γ</span><i>sum</i><span class="s98">(</span><i>C</i><span class="s98">)</span>(<i>r</i>) as well as <span class="s169">A</span><span class="s93">,</span><span class="s169">B</span><span class="s15">γ</span><i>sum</i><span class="s98">(</span><i>C</i><span class="s98">)</span>(<i>r</i>). Describe how to compute these together using a single sorting of <i>r</i>.<a name="bookmark355">&zwnj;</a></p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -36pt;text-align: justify;"><b>15.23  </b>Write pseudocode for an iterator that implements a version of the sort – merge algorithm where the result of the ﬁnal merge is pipelined to its consumers. Your pseudocode must deﬁne the standard iterator functions <i>open</i>(), <i>next</i>(), and <i>close</i>(). Show what state information the iterator must maintain between calls.</p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -36pt;text-align: justify;">15.24  <span class="p">Explain how to split the hybrid hash-join operator into sub-operators to model pipelining. Also explain how this split is diﬀerent from the split for a hash-join operator.</span></p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -36pt;text-align: justify;"><b>15.25  </b>Suppose you need to sort relation <i>r </i>using sort—merge and merge—join the re- sult with an already sorted relation <i>s</i>.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -18pt;text-align: justify;">a.  Describe how the sort operator is broken into suboperators to model the pipelining in this case.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -19pt;text-align: justify;">b. The same idea is applicable even if both inputs to the merge join are the outputs of sort—merge operations. However, the available memory has to be shared between the two merge operations (the merge—join algorithm itself needs very little memory). What is the eﬀect of having to share memory on the cost of each sort-merge operation?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part290.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part292.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
