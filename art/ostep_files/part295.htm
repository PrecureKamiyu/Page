<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.16 Two-Phase Locks</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part294.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part296.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">28.16 Two-Phase Locks</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One final note: the Linux approach has the flavor of an old approach that has been used on and off for years, going at least as far back to Dahm Locks in the early 1960’s [M82], and is now referred to as a <b>two-phase lock</b>. A two-phase lock realizes that spinning can be useful, particularly if the lock is about to be released. So in the first phase, the lock spins for a while, hoping that it can acquire the lock.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">1  </span>void mutex_lock (int <span class="s39">*</span>mutex) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">2   <span class="s38">int v;</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">3    </span>/<span class="s39">* </span>Bit 31 was clear, we got the mutex (this is the fastpath) <span class="s39">*</span>/</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">4   <span class="s38">if (atomic_bit_test_set (mutex, 31) == 0)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5    <span class="s38">return;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6   <span class="s38">atomic_increment (mutex);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7   <span class="s38">while (1) {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8      <span class="s38">if (atomic_bit_test_set (mutex, 31) == 0) {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9        <span class="s38">atomic_decrement (mutex);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10        <span class="s38">return;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11     <span class="s38">}</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">12      </span>/<span class="s39">* </span>We have to wait now. First make sure the futex value</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">13        </span>we are monitoring is truly negative (i.e. locked). <span class="s39">*</span>/</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">14      </span>v = <span class="s39">*</span>mutex;</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">15      <span class="s38">if (v &gt;= 0)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">16       <span class="s38">continue;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">17      <span class="s38">futex_wait (mutex, v);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">18   <span class="s38">}</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">19  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">20</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">21  </span>void mutex_unlock (int <span class="s39">*</span>mutex) {</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 85%;text-align: left;"><span class="s37">22   </span>/<span class="s39">* </span>Adding 0x80000000 to the counter results in 0 if and only if</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">23     </span>there are not other interested threads <span class="s39">*</span>/</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">24   <span class="s38">if (atomic_add_zero (mutex, 0x80000000))</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">25    <span class="s38">return;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">26</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">27   </span>/<span class="s39">* </span>There are other threads waiting for this mutex,</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">28     </span>wake one of them up. <span class="s39">*</span>/</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">29   <span class="s38">futex_wake (mutex);</span></p><p style="padding-top: 5pt;padding-left: 137pt;text-indent: 0pt;text-align: left;">Figure 28.9: <b>Linux-based Futex Locks</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">However, if the lock is not acquired during the first spin phase, a sec- ond phase is entered, where the caller is put to sleep, and only woken up when the lock becomes free later. The Linux lock above is a form of such a lock, but it only spins once; a generalization of this could spin in a loop for a fixed amount of time before using <b>futex </b>support to sleep.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Two-phase locks are yet another instance of a <b>hybrid </b>approach, where combining two good ideas may indeed yield a better one. Of course, whether it does depends strongly on many things, including the hard- ware environment, number of threads, and other workload details. As always, making a single general-purpose lock, good for all possible use cases, is quite a challenge.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part294.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part296.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
