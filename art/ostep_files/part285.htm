<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.6 Test And Set (Atomic Exchange)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part284.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part286.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">28.6 Test And Set (Atomic Exchange)</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Because disabling interrupts does not work on multiple processors, system designers started to invent hardware support for locking. The earliest multiprocessor systems, such as the Burroughs B5000 in the early 1960’s [M82], had such support; today all systems provide this type of support, even for single CPU systems.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 5pt;padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>typedef struct <span class="s75">&nbsp; </span>lock_t { int flag; } lock_t;</p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">2</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">3  </span>void init(lock_t <span class="s39">*</span>mutex) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">4     <span class="s38">// 0 -&gt; lock is available, 1 -&gt; held</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5    <span class="s38">mutex-&gt;flag = 0;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">7</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">8  </span>void lock(lock_t <span class="s39">*</span>mutex) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">9     <span class="s38">while (mutex-&gt;flag == 1) // TEST the flag</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10       <span class="s38">; // spin-wait (do nothing)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11     <span class="s38">mutex-&gt;flag = 1;    // now SET it!</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">12  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">13</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">14  </span>void unlock(lock_t <span class="s39">*</span>mutex) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">15    <span class="s38">mutex-&gt;flag = 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">16  <span class="s38">}</span></p><p style="padding-left: 129pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 28.1: <b>First Attempt: A Simple Flag</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The simplest bit of hardware support to understand is what is known as a <b>test-and-set instruction</b>, also known as <b>atomic exchange</b>. To under- stand how test-and-set works, let’s first try to build a simple lock without it. In this failed attempt, we use a simple flag variable to denote whether the lock is held or not.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this first attempt (Figure <span style=" color: #00AEEF;">28.1</span>), the idea is quite simple: use a simple variable to indicate whether some thread has possession of a lock. The first thread that enters the critical section will call <span class="s41">lock()</span>, which <b>tests </b>whether the flag is equal to 1 (in this case, it is not), and then <b>sets </b>the flag to 1 to indicate that the thread now <b>holds </b>the lock. When finished with the critical section, the thread calls <span class="s41">unlock() </span>and clears the flag, thus indicating that the lock is no longer held.</p><p style="padding-left: 68pt;text-indent: 11pt;line-height: 88%;text-align: justify;">If another thread happens to call <span class="s41">lock() </span>while that first thread is in the critical section, it will simply <b>spin-wait </b>in the while loop for that thread to call <span class="s41">unlock() </span>and clear the flag. Once that first thread does so, the waiting thread will fall out of the while loop, set the flag to 1 for itself, and proceed into the critical section.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Unfortunately, the code has two problems: one of correctness, and an- other of performance. The correctness problem is simple to see once you get used to thinking about concurrent programming. Imagine the code interleaving in Table <span style=" color: #00AEEF;">28.1 </span>(assume <span class="s41">flag=0 </span>to begin).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 102pt;text-indent: 0pt;text-align: left;">Thread 1           Thread 2</p><p style="padding-left: 96pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="310" height="1" alt="image" src="Image_363.png"/></span></p><p class="s5" style="padding-left: 102pt;text-indent: 0pt;line-height: 8pt;text-align: left;">call <span class="s15">lock()</span></p><p class="s5" style="padding-left: 102pt;text-indent: 0pt;line-height: 9pt;text-align: left;">while (flag == 1)</p><p class="s9" style="padding-left: 102pt;text-indent: 0pt;line-height: 10pt;text-align: left;">interrupt: switch to Thread 2</p><p class="s5" style="padding-left: 218pt;text-indent: 0pt;text-align: left;">call <span class="s15">lock() </span>while (flag == 1) flag = 1;</p><p class="s9" style="padding-left: 218pt;text-indent: 0pt;line-height: 9pt;text-align: left;">interrupt: switch to Thread 1</p><p class="s5" style="padding-left: 102pt;text-indent: 0pt;line-height: 10pt;text-align: left;">flag = 1; // set flag to 1 (too!)</p><p style="padding-top: 2pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">Table 28.1: <b>Trace: No Mutual Exclusion</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: T<span class="s7">HINK </span>A<span class="s7">BOUT </span>C<span class="s7">ONCURRENCY </span>A<span class="s7">S </span>M<span class="s7">ALICIOUS </span>S<span class="s7">CHEDULER</span></p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: justify;">What we also get from this example is a sense of the approach we need to take when trying to understand concurrent execution. What you are really trying to do is to pretend you are a <b>malicious scheduler</b>, one that interrupts threads at the most inopportune of times in order to foil their feeble attempts at building synchronization primitives. Although the exact sequence of interrupts may be <i>improbable</i>, it is <i>possible</i>, and that is all we need to show to demonstrate that a particular approach does not work.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As you can see from this interleaving, with timely (untimely?) inter- rupts, we can easily produce a case where <i>both </i>threads set their flags to 1 and both threads are thus able to enter the critical section. This is bad! We have obviously failed to provide the most basic requirement: providing mutual exclusion.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The performance problem, which we will address more later on, is the fact that the way a thread waits to acquire a lock that is already held: it endlessly checks the value of flag, a technique known as <b>spin-waiting</b>. Spin-waiting wastes time waiting for another thread to release a lock. The waste is exceptionally high on a uniprocessor, where the thread that the waiter is waiting for cannot even run (at least, until a context switch oc- curs)! Thus, as we move forward and develop more sophisticated solu- tions, we should also consider ways to avoid this kind of waste.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part284.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part286.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
