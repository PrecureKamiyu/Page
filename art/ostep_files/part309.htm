<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>30.1 Definition and Routines</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part308.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part310.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">30.1 Definition and Routines</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To wait for a condition to become true, a thread can make use of what is known as a <b>condition variable</b>. A <b>condition variable </b>is an explicit queue that threads can put themselves on when some state of execution (i.e., some <b>condition</b>) is not as desired (by <b>waiting </b>on the condition); some other thread, when it changes said state, can then wake one (or more) of those waiting threads and thus allow them to continue (by <b>sig- naling </b>on the condition). The idea goes back to Dijkstra’s use of “private semaphores” [D68]; a similar idea was later named a “condition variable” by Hoare in his work on monitors [H74].</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_379.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_380.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To declare such a condition variable, one simply writes something like this: <span class="s41">pthread cond t c;</span>, which declares <span class="s41">c </span>as a condition variable (note: proper initialization is also required). A condition variable has two operations associated with it: <span class="s41">wait() </span>and <span class="s41">signal()</span>. The <span class="s41">wait() </span>call is executed when a thread wishes to put itself to sleep; the <span class="s41">signal() </span>call is executed when a thread has changed something in the program and thus wants to wake a sleeping thread waiting on this condition. Specifi- cally, the POSIX calls look like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;line-height: 90%;text-align: left;">pthread_cond_wait(pthread_cond_t <span class="s39">*</span>c, pthread_mutex_t <span class="s39">*</span>m); pthread_cond_signal(pthread_cond_t <span class="s39">*</span>c);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">int done = 0;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3  <span class="s38">pthread_cond_t c = PTHREAD_COND_INITIALIZER;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">4</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">void thr_exit() {</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6    <span class="s38">Pthread_mutex_lock(&amp;m);</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">7    <span class="s38">done = 1;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">8    <span class="s38">Pthread_cond_signal(&amp;c);</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">9    <span class="s38">Pthread_mutex_unlock(&amp;m);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">11</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">12  </span>void <span class="s39">*</span>child(void <span class="s39">*</span>arg) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">13    <span class="s38">printf(&quot;child\n&quot;);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14    <span class="s38">thr_exit();</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15    <span class="s38">return NULL;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">17</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">18  <span class="s38">void thr_join() {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19    <span class="s38">Pthread_mutex_lock(&amp;m);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">20    <span class="s38">while (done == 0)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">21       <span class="s38">Pthread_cond_wait(&amp;c, &amp;m);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">22    <span class="s38">Pthread_mutex_unlock(&amp;m);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">23  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">24</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">25  </span>int main(int argc, char <span class="s39">*</span>argv[]) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">26    <span class="s38">printf(&quot;parent: begin\n&quot;);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">27    <span class="s38">pthread_t p;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">28    <span class="s38">Pthread_create(&amp;p, NULL, child, NULL);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">29    <span class="s38">thr_join();</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">30    <span class="s38">printf(&quot;parent: end\n&quot;);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">31    <span class="s38">return 0;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">32  <span class="s38">}</span></p><p style="padding-top: 2pt;padding-left: 54pt;text-indent: 0pt;text-align: justify;">Figure 30.3: <b>Parent Waiting For Child: Use A Condition Variable</b></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We will often refer to these as <span class="s41">wait() </span>and <span class="s41">signal() </span>for simplicity. One thing you might notice about the <span class="s41">wait() </span>call is that it also takes a mutex as a parameter; it assumes that this mutex is locked when <span class="s41">wait() </span>is called. The responsibility of <span class="s41">wait() </span>is to release the lock and put the calling thread to sleep (atomically); when the thread wakes up (after some other thread has signaled it), it must re-acquire the lock before returning to the caller. This complexity stems from the desire to prevent certain race conditions from occurring when a thread is trying to put itself to sleep. Let’s take a look at the solution to the join problem (Figure <span style=" color: #00AEEF;">30.3</span>) to understand this better.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_381.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_382.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">There are two cases to consider. In the first, the parent creates the child thread but continues running itself (assume we have only a single pro- cessor) and thus immediately calls into <span class="s41">thr join() </span>to wait for the child thread to complete. In this case, it will acquire the lock, check if the child is done (it is not), and put itself to sleep by calling <span class="s41">wait() </span>(hence releas- ing the lock). The child will eventually run, print the message “child”, and call <span class="s41">thr exit() </span>to wake the parent thread; this code just grabs the lock, sets the state variable <span class="s41">done</span>, and signals the parent thus waking it. Finally, the parent will run (returning from <span class="s41">wait() </span>with the lock held), unlock the lock, and print the final message “parent: end”.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_383.png"/></span></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">In the second case, the child runs immediately upon creation, sets <span class="s41">done </span>to 1, calls signal to wake a sleeping thread (but there is none, so it just returns), and is done. The parent then runs, calls <span class="s41">thr join()</span>, sees that <span class="s41">done </span>is 1, and thus does not wait and returns.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">One last note: you might observe the parent uses a <span class="s41">while </span>loop instead of just an <span class="s41">if </span>statement when deciding whether to wait on the condition. While this does not seem strictly necessary per the logic of the program, it is always a good idea, as we will see below.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_384.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_385.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">To make sure you understand the importance of each piece of the <span class="s41">thr exit() </span>and <span class="s41">thr join() </span>code, let’s try a few alternate implemen- tations. First, you might be wondering if we need the state variable <span class="s41">done</span>. What if the code looked like the example below? Would this work?</p><p class="s37" style="padding-top: 7pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">void thr_exit() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2    <span class="s38">Pthread_mutex_lock(&amp;m);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3    <span class="s38">Pthread_cond_signal(&amp;c);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4    <span class="s38">Pthread_mutex_unlock(&amp;m);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">6</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7  <span class="s38">void thr_join() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8    <span class="s38">Pthread_mutex_lock(&amp;m);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9    <span class="s38">Pthread_cond_wait(&amp;c, &amp;m);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10    <span class="s38">Pthread_mutex_unlock(&amp;m);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_386.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Unfortunately this approach is broken. Imagine the case where the child runs immediately and calls <span class="s41">thr exit() </span>immediately; in this case, the child will signal, but there is no thread asleep on the condition. When the parent runs, it will simply call wait and be stuck; no thread will ever wake it. From this example, you should appreciate the importance of the state variable <span class="s41">done</span>; it records the value the threads are interested in knowing. The sleeping, waking, and locking all are built around it.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Here is another poor implementation. In this example, we imagine that one does not need to hold a lock in order to signal and wait. What problem could occur here? Think about it!</p><p class="s37" style="padding-top: 7pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">void thr_exit() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2    <span class="s38">done = 1;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3    <span class="s38">Pthread_cond_signal(&amp;c);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">5</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6  <span class="s38">void thr_join() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7    <span class="s38">if (done == 0)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8       <span class="s38">Pthread_cond_wait(&amp;c);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_387.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The issue here is a subtle race condition. Specifically, if the parent calls <span class="s41">thr join() </span>and then checks the value of <span class="s41">done</span>, it will see that it is 0 and thus try to go to sleep. But just before it calls wait to go to sleep, the parent is interrupted, and the child runs. The child changes the state variable <span class="s41">done </span>to 1 and signals, but no thread is waiting and thus no thread is woken. When the parent runs again, it sleeps forever, which is sad.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: A<span class="s7">LWAYS </span>H<span class="s7">OLD </span>T<span class="s7">HE </span>L<span class="s7">OCK </span>W<span class="s7">HILE </span>S<span class="s7">IGNALING</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Although it is strictly not necessary in all cases, it is likely simplest and best to hold the lock while signaling when using condition variables. The example above shows a case where you <i>must </i>hold the lock for correct- ness; however, there are some other cases where it is likely OK not to, but probably is something you should avoid. Thus, for simplicity, <b>hold the lock when calling signal</b>.</p><p style="padding-top: 3pt;padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The converse of this tip, i.e., hold the lock when calling wait, is not just a tip, but rather mandated by the semantics of wait, because wait always</p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">(a) assumes the lock is held when you call it, (b) releases said lock when putting the caller to sleep, and (c) re-acquires the lock just before return- ing. Thus, the generalization of this tip is correct: <b>hold the lock when calling signal or wait</b>, and you will always be in good shape.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Hopefully, from this simple join example, you can see some of the ba- sic requirements of using condition variables properly. To make sure you understand, we now go through a more complicated example: the <b>pro- ducer/consumer </b>or <b>bounded-buffer </b>problem.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part308.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part310.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
