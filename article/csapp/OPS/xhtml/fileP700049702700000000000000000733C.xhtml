<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>9.9 Dynamic Memory Allocation</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P700049702700000000000000000733C" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000045E03" data-uri="chapter09.xhtml#P7000497027000000000000000045E03" epub:type="title"><span class="pcalibre label pcalibre1">9.9 </span>Dynamic Memory Allocation</h1></header>
<p id="P7000497027000000000000000045E04" data-uri="chapter09.xhtml#P7000497027000000000000000045E04" class="pcalibre1 pcalibre calibre2">While it is certainly possible to use the low-level <code id="P7000497027000000000000000045E05" data-uri="chapter09.xhtml#P7000497027000000000000000045E05" class="pcalibre1 calibre8 pcalibre">mmap</code> and <code id="P7000497027000000000000000045E06" data-uri="chapter09.xhtml#P7000497027000000000000000045E06" class="pcalibre1 calibre8 pcalibre">munmap</code> functions to create and delete areas of virtual memory, C programmers typically find it more convenient and more portable to use a <i class="calibre5 pcalibre pcalibre1">dynamic memory allocator</i> when they need to acquire additional virtual memory at run time.</p>
<p id="P7000497027000000000000000045E07" data-uri="chapter09.xhtml#P7000497027000000000000000045E07" class="pcalibre1 pcalibre calibre2">A dynamic memory allocator maintains an area of a process's virtual memory known as the <i class="calibre5 pcalibre pcalibre1">heap</i> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000734A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.33</span></a>). Details vary from system to system, but without loss of generality, we will assume that the heap is an area of demand-zero memory that begins immediately after the uninitialized data area and grows upward (toward higher addresses). For each process, the kernel maintains a variable <code id="P7000497027000000000000000045E08" data-uri="chapter09.xhtml#P7000497027000000000000000045E08" class="pcalibre1 calibre8 pcalibre">brk</code> (pronounced "break") that points to the top of the heap.</p>
<p id="P7000497027000000000000000045E09" data-uri="chapter09.xhtml#P7000497027000000000000000045E09" class="pcalibre1 pcalibre calibre2">An allocator maintains the heap as a collection of various-size <i class="calibre5 pcalibre pcalibre1">blocks.</i> Each block is a contiguous chunk of virtual memory that is either <i class="calibre5 pcalibre pcalibre1">allocated</i> or <i class="calibre5 pcalibre pcalibre1">free.</i> An allocated block has been explicitly reserved for use by the application. A free block is available to be allocated. A free block remains free until it is explicitly allocated by the application. An allocated block remains allocated until it is freed, either explicitly by the application or implicitly by the memory allocator itself.</p>
<p id="P7000497027000000000000000045E0A" data-uri="chapter09.xhtml#P7000497027000000000000000045E0A" class="pcalibre1 pcalibre calibre2">Allocators come in two basic styles. Both styles require the application to explicitly allocate blocks. They differ about which entity is responsible for freeing allocated blocks.</p>
<ul id="P7000497027000000000000000045E0B" data-uri="chapter09.xhtml#P7000497027000000000000000045E0B" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000045E0C" data-uri="chapter09.xhtml#P7000497027000000000000000045E0C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E0D" data-uri="chapter09.xhtml#P7000497027000000000000000045E0D" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Explicit allocators </span>require the application to explicitly free any allocated blocks. For example, the C standard library provides an explicit allocator called the <code id="P7000497027000000000000000045E0E" data-uri="chapter09.xhtml#P7000497027000000000000000045E0E" class="pcalibre1 calibre8 pcalibre">malloc</code> package. C programs allocate a block by calling the <code id="P7000497027000000000000000045E0F" data-uri="chapter09.xhtml#P7000497027000000000000000045E0F" class="pcalibre1 calibre8 pcalibre">malloc</code></p>
<figure id="P700049702700000000000000000734A" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P700049702700000000000000000734A">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000734B" title="840" data-uri="chapter09.xhtml#P700049702700000000000000000734B" epub:type="pagebreak"></span>
<img alt="A diagram illustrates areas in the heap." id="P7000497027000000000000000045E10" data-uri="P700049702700000000000000000B79C" src="../images/p840-1.png" class="calibre292 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045E11" data-uri="chapter09.xhtml#P7000497027000000000000000045E11" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045E12" data-uri="chapter09.xhtml#P7000497027000000000000000045E12" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.33 </span>The heap.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026162" data-uri="chapter09.xhtml#P7000497027000000000000000026162">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045E13" data-uri="chapter09.xhtml#P7000497027000000000000000045E13" class="pcalibre calibre3 pcalibre1">A diagram of a stack has the following areas, listed from bottom to top:</p>
<ul id="P7000497027000000000000000045E14" data-uri="chapter09.xhtml#P7000497027000000000000000045E14" class="pcalibre calibre39 pcalibre1">
<li id="P7000497027000000000000000045E15" data-uri="chapter09.xhtml#P7000497027000000000000000045E15" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E16" data-uri="chapter09.xhtml#P7000497027000000000000000045E16" class="pcalibre calibre3 pcalibre1">Gap from 0</p></li>
<li id="P7000497027000000000000000045E17" data-uri="chapter09.xhtml#P7000497027000000000000000045E17" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E18" data-uri="chapter09.xhtml#P7000497027000000000000000045E18" class="pcalibre calibre3 pcalibre1">Code (.text)</p></li>
<li id="P7000497027000000000000000045E19" data-uri="chapter09.xhtml#P7000497027000000000000000045E19" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E1A" data-uri="chapter09.xhtml#P7000497027000000000000000045E1A" class="pcalibre calibre3 pcalibre1">Initialized data (.data)</p></li>
<li id="P7000497027000000000000000045E1B" data-uri="chapter09.xhtml#P7000497027000000000000000045E1B" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E1C" data-uri="chapter09.xhtml#P7000497027000000000000000045E1C" class="pcalibre calibre3 pcalibre1">Uninitialized data (.bss)</p></li>
<li id="P7000497027000000000000000045E1D" data-uri="chapter09.xhtml#P7000497027000000000000000045E1D" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E1E" data-uri="chapter09.xhtml#P7000497027000000000000000045E1E" class="pcalibre calibre3 pcalibre1">Heap (growing upward from top of the heap (brk ptr)</p></li>
<li id="P7000497027000000000000000045E1F" data-uri="chapter09.xhtml#P7000497027000000000000000045E1F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E20" data-uri="chapter09.xhtml#P7000497027000000000000000045E20" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P7000497027000000000000000045E21" data-uri="chapter09.xhtml#P7000497027000000000000000045E21" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E22" data-uri="chapter09.xhtml#P7000497027000000000000000045E22" class="pcalibre calibre3 pcalibre1">Memory-mapped region for shared libraries</p></li>
<li id="P7000497027000000000000000045E23" data-uri="chapter09.xhtml#P7000497027000000000000000045E23" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E24" data-uri="chapter09.xhtml#P7000497027000000000000000045E24" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P7000497027000000000000000045E25" data-uri="chapter09.xhtml#P7000497027000000000000000045E25" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E26" data-uri="chapter09.xhtml#P7000497027000000000000000045E26" class="pcalibre calibre3 pcalibre1">User stack</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre calibre3 pcalibre1" id="P7000497027000000000000000045E27" data-uri="chapter09.xhtml#P7000497027000000000000000045E27">function, and free a block by calling the free function. The <code id="P7000497027000000000000000045E28" data-uri="chapter09.xhtml#P7000497027000000000000000045E28" class="pcalibre1 calibre8 pcalibre">new</code> and <code id="P7000497027000000000000000045E29" data-uri="chapter09.xhtml#P7000497027000000000000000045E29" class="pcalibre1 calibre8 pcalibre">delete</code> calls in <code id="P7000497027000000000000000045E2A" data-uri="chapter09.xhtml#P7000497027000000000000000045E2A" class="pcalibre1 calibre8 pcalibre">C++</code> are comparable.</p></li>
<li id="P7000497027000000000000000045E2B" data-uri="chapter09.xhtml#P7000497027000000000000000045E2B" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E2C" data-uri="chapter09.xhtml#P7000497027000000000000000045E2C" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Implicit allocators, </span>on the other hand, require the allocator to detect when an allocated block is no longer being used by the program and then free the block. Implicit allocators are also known as <i class="calibre5 pcalibre pcalibre1">garbage collectors</i>, and the process of automatically freeing unused allocated blocks is known as <i class="calibre5 pcalibre pcalibre1">garbage collection.</i> For example, higher-level languages such as Lisp, ML, and Java rely on garbage collection to free allocated blocks.</p></li>
</ul>
<p id="P7000497027000000000000000045E2D" data-uri="chapter09.xhtml#P7000497027000000000000000045E2D" class="pcalibre1 pcalibre calibre2">The remainder of this section discusses the design and implementation of explicit allocators. We will discuss implicit allocators in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007565.xhtml#P7000497027000000000000000007565"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">9.10</span></a>. For concrete -ness, our discussion focuses on allocators that manage heap memory. However, you should be aware that memory allocation is a general idea that arises in a variety of contexts. For example, applications that do intensive manipulation of graphs will often use the standard allocator to acquire a large block of virtual memory and then use an application-specific allocator to manage the memory within that block as the nodes of the graph are created and destroyed.</p>
<section id="P7000497027000000000000000007356" data-uri="chapter09.xhtml#P7000497027000000000000000007356" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045E2E" data-uri="chapter09.xhtml#P7000497027000000000000000045E2E" epub:type="title"><span class="pcalibre label pcalibre1">9.9.1 </span>The <code id="P7000497027000000000000000045E2F" data-uri="chapter09.xhtml#P7000497027000000000000000045E2F" class="pcalibre1 calibre8 pcalibre">malloc</code> and <code id="P7000497027000000000000000045E30" data-uri="chapter09.xhtml#P7000497027000000000000000045E30" class="pcalibre1 calibre8 pcalibre">free</code> Functions</h1></header>
<p id="P7000497027000000000000000045E31" data-uri="chapter09.xhtml#P7000497027000000000000000045E31" class="pcalibre1 pcalibre calibre2">The C standard library provides an explicit allocator known as the <code id="P7000497027000000000000000045E32" data-uri="chapter09.xhtml#P7000497027000000000000000045E32" class="pcalibre1 calibre8 pcalibre">malloc</code> package. Programs allocate blocks from the heap by calling the <code id="P7000497027000000000000000045E33" data-uri="chapter09.xhtml#P7000497027000000000000000045E33" class="pcalibre1 calibre8 pcalibre">malloc</code> function.</p>
<pre id="P7000497027000000000000000045E34" data-uri="chapter09.xhtml#P7000497027000000000000000045E34" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045E35" data-uri="chapter09.xhtml#P7000497027000000000000000045E35" class="calibre10 pcalibre pcalibre1">
#include &lt;stdlib.h&gt;

void *malloc(size_t size);
			Returns: pointer to allocated block if OK, NULL on error
</code></pre>
<aside class="sidebar pcalibre5 pcalibre" id="P700049702700000000000000000735F" data-uri="chapter09.xhtml#P700049702700000000000000000735F"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000045E36" data-uri="chapter09.xhtml#P7000497027000000000000000045E36" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007361" title="841" data-uri="chapter09.xhtml#P7000497027000000000000000007361" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>How big is a word?</h1></header>
<p id="P7000497027000000000000000045E37" data-uri="chapter09.xhtml#P7000497027000000000000000045E37" class="pcalibre calibre3 pcalibre1">Recall from our discussion of machine code in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">3</span></a> that Intel refers to 4-byte objects as <i class="calibre5 pcalibre pcalibre1">double words.</i> However, throughout this section, we will assume that <i class="calibre5 pcalibre pcalibre1">words</i> are 4-byte objects and that <i class="calibre5 pcalibre pcalibre1">double words</i> are 8-byte objects, which is consistent with conventional terminology.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045E38" data-uri="chapter09.xhtml#P7000497027000000000000000045E38">The <code id="P7000497027000000000000000045E39" data-uri="chapter09.xhtml#P7000497027000000000000000045E39" class="pcalibre1 calibre8 pcalibre">malloc</code> function returns a pointer to a block of memory of at least size bytes that is suitably aligned for any kind of data object that might be contained in the block. In practice, the alignment depends on whether the code is compiled to run in 32-bit mode (<code id="P7000497027000000000000000045E3A" data-uri="chapter09.xhtml#P7000497027000000000000000045E3A" class="pcalibre1 calibre8 pcalibre">gcc –m32</code>) or 64-bit mode (the default). In 32-bit mode, <code id="P7000497027000000000000000045E3B" data-uri="chapter09.xhtml#P7000497027000000000000000045E3B" class="pcalibre1 calibre8 pcalibre">malloc</code> returns a block whose address is always a multiple of 8. In 64-bit mode, the address is always a multiple of 16.</p>
<p id="P7000497027000000000000000045E3C" data-uri="chapter09.xhtml#P7000497027000000000000000045E3C" class="pcalibre1 pcalibre calibre2">If <code id="P7000497027000000000000000045E3D" data-uri="chapter09.xhtml#P7000497027000000000000000045E3D" class="pcalibre1 calibre8 pcalibre">malloc</code> encounters a problem (e.g., the program requests a block of memory that is larger than the available virtual memory), then it returns NULL and sets <code id="P7000497027000000000000000045E3E" data-uri="chapter09.xhtml#P7000497027000000000000000045E3E" class="pcalibre1 calibre8 pcalibre">errno</code>. <code id="P7000497027000000000000000045E3F" data-uri="chapter09.xhtml#P7000497027000000000000000045E3F" class="pcalibre1 calibre8 pcalibre">Malloc</code> does not initialize the memory it returns. Applications that want initialized dynamic memory can use <code id="P7000497027000000000000000045E40" data-uri="chapter09.xhtml#P7000497027000000000000000045E40" class="pcalibre1 calibre8 pcalibre">calloc</code>, a thin wrapper around the <code id="P7000497027000000000000000045E41" data-uri="chapter09.xhtml#P7000497027000000000000000045E41" class="pcalibre1 calibre8 pcalibre">malloc</code> function that initializes the allocated memory to <code id="P7000497027000000000000000045E42" data-uri="chapter09.xhtml#P7000497027000000000000000045E42" class="pcalibre1 calibre8 pcalibre">zero</code>. Applications that want to change the size of a previously allocated block can use the <code id="P7000497027000000000000000045E43" data-uri="chapter09.xhtml#P7000497027000000000000000045E43" class="pcalibre1 calibre8 pcalibre">realloc</code> function.</p>
<p id="P7000497027000000000000000045E44" data-uri="chapter09.xhtml#P7000497027000000000000000045E44" class="pcalibre1 pcalibre calibre2">Dynamic memory allocators such as <code id="P7000497027000000000000000045E45" data-uri="chapter09.xhtml#P7000497027000000000000000045E45" class="pcalibre1 calibre8 pcalibre">malloc</code> can allocate or deallocate heap memory explicitly by using the <code id="P7000497027000000000000000045E46" data-uri="chapter09.xhtml#P7000497027000000000000000045E46" class="pcalibre1 calibre8 pcalibre">mmap</code> and <code id="P7000497027000000000000000045E47" data-uri="chapter09.xhtml#P7000497027000000000000000045E47" class="pcalibre1 calibre8 pcalibre">munmap</code> functions, or they can use the <code id="P7000497027000000000000000045E48" data-uri="chapter09.xhtml#P7000497027000000000000000045E48" class="pcalibre1 calibre8 pcalibre">sbrk</code> function:</p>
<pre id="P7000497027000000000000000045E49" data-uri="chapter09.xhtml#P7000497027000000000000000045E49" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045E4A" data-uri="chapter09.xhtml#P7000497027000000000000000045E4A" class="calibre10 pcalibre pcalibre1">
#include &lt;unistd.h&gt;

void *sbrk(intptr_t incr);
				Returns: old brk pointer on success, –1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045E4B" data-uri="chapter09.xhtml#P7000497027000000000000000045E4B">The <code id="P7000497027000000000000000045E4C" data-uri="chapter09.xhtml#P7000497027000000000000000045E4C" class="pcalibre1 calibre8 pcalibre">sbrk</code> function grows or shrinks the heap by adding <code id="P7000497027000000000000000045E4D" data-uri="chapter09.xhtml#P7000497027000000000000000045E4D" class="pcalibre1 calibre8 pcalibre">incr</code> to the kernel's <code id="P7000497027000000000000000045E4E" data-uri="chapter09.xhtml#P7000497027000000000000000045E4E" class="pcalibre1 calibre8 pcalibre">brk</code> pointer. If successful, it returns the old value of <code id="P7000497027000000000000000045E4F" data-uri="chapter09.xhtml#P7000497027000000000000000045E4F" class="pcalibre1 calibre8 pcalibre">brk</code>, otherwise it returns –1 and sets <code id="P7000497027000000000000000045E50" data-uri="chapter09.xhtml#P7000497027000000000000000045E50" class="pcalibre1 calibre8 pcalibre">errno</code> to ENOMEM. If <code id="P7000497027000000000000000045E51" data-uri="chapter09.xhtml#P7000497027000000000000000045E51" class="pcalibre1 calibre8 pcalibre">incr</code> is zero, then <code id="P7000497027000000000000000045E52" data-uri="chapter09.xhtml#P7000497027000000000000000045E52" class="pcalibre1 calibre8 pcalibre">sbrk</code> returns the current value of <code id="P7000497027000000000000000045E53" data-uri="chapter09.xhtml#P7000497027000000000000000045E53" class="pcalibre1 calibre8 pcalibre">brk</code>. Calling <code id="P7000497027000000000000000045E54" data-uri="chapter09.xhtml#P7000497027000000000000000045E54" class="pcalibre1 calibre8 pcalibre">sbrk</code> with a negative <code id="P7000497027000000000000000045E55" data-uri="chapter09.xhtml#P7000497027000000000000000045E55" class="pcalibre1 calibre8 pcalibre">incr</code> is legal but tricky because the return value (the old value of <code id="P7000497027000000000000000045E56" data-uri="chapter09.xhtml#P7000497027000000000000000045E56" class="pcalibre1 calibre8 pcalibre">brk</code>) points to <code id="P7000497027000000000000000045E57" data-uri="chapter09.xhtml#P7000497027000000000000000045E57" class="pcalibre1 calibre8 pcalibre">abs (incr)</code> bytes past the new top of the heap.</p>
<p id="P7000497027000000000000000045E58" data-uri="chapter09.xhtml#P7000497027000000000000000045E58" class="pcalibre1 pcalibre calibre2">Programs free allocated heap blocks by calling the free function.</p>
<pre id="P7000497027000000000000000045E59" data-uri="chapter09.xhtml#P7000497027000000000000000045E59" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045E5A" data-uri="chapter09.xhtml#P7000497027000000000000000045E5A" class="calibre10 pcalibre pcalibre1">
#include &lt;stdlib.h&gt;

void free(void *ptr);

					Returns: nothing
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045E5B" data-uri="chapter09.xhtml#P7000497027000000000000000045E5B">The <code id="P7000497027000000000000000045E5C" data-uri="chapter09.xhtml#P7000497027000000000000000045E5C" class="pcalibre1 calibre8 pcalibre">ptr</code> argument must point to the beginning of an allocated block that was obtained from <code id="P7000497027000000000000000045E5D" data-uri="chapter09.xhtml#P7000497027000000000000000045E5D" class="pcalibre1 calibre8 pcalibre">malloc, calloc</code>, or <code id="P7000497027000000000000000045E5E" data-uri="chapter09.xhtml#P7000497027000000000000000045E5E" class="pcalibre1 calibre8 pcalibre">realloc</code>. If not, then the behavior of <code id="P7000497027000000000000000045E5F" data-uri="chapter09.xhtml#P7000497027000000000000000045E5F" class="pcalibre1 calibre8 pcalibre">free</code> is undefined. Even worse, since it returns nothing, <code id="P7000497027000000000000000045E60" data-uri="chapter09.xhtml#P7000497027000000000000000045E60" class="pcalibre1 calibre8 pcalibre">free</code> gives no indication to the application that something is wrong. As we shall see in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000075E8.xhtml#P70004970270000000000000000075E8"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">9.11</span></a>, this can produce some baffling run-time errors.</p>
<figure id="P700049702700000000000000000738C" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P700049702700000000000000000738C">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000738D" title="842" data-uri="chapter09.xhtml#P700049702700000000000000000738D" epub:type="pagebreak"></span>
<img alt="Diagrams illustrate allocating and freeing block with malloc and free." id="P7000497027000000000000000045E61" data-uri="P700049702700000000000000000B79D" src="../images/p842-1.png" class="calibre293 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045E62" data-uri="chapter09.xhtml#P7000497027000000000000000045E62" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045E63" data-uri="chapter09.xhtml#P7000497027000000000000000045E63" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.34 </span>Allocating and freeing blocks with <code id="P7000497027000000000000000045E64" data-uri="chapter09.xhtml#P7000497027000000000000000045E64" class="pcalibre1 calibre8 pcalibre">malloc</code> <b class="calibre4 pcalibre pcalibre1">and</b> <code id="P7000497027000000000000000045E65" data-uri="chapter09.xhtml#P7000497027000000000000000045E65" class="pcalibre1 calibre8 pcalibre">free</code>.</h1></header><div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045E66" data-uri="chapter09.xhtml#P7000497027000000000000000045E66"><p id="P7000497027000000000000000045E67" data-uri="chapter09.xhtml#P7000497027000000000000000045E67" class="pcalibre calibre3 pcalibre1">Each square corresponds to a word. Each heavy rectangle corresponds to a block. Allocated blocks are shaded. Padded regions of allocated blocks are shaded with a darker blue. Free blocks are unshaded. Heap addresses increase from left to right.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000261B8" data-uri="chapter09.xhtml#P70004970270000000000000000261B8">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045E68" data-uri="chapter09.xhtml#P7000497027000000000000000045E68" class="pcalibre1 pcalibre calibre2">Five diagrams each have a row of 18 squares, shaded and labeled as summarized below.</p>
<ol class="pcalibre1 pcalibre ol_lower-alpha1" id="P7000497027000000000000000045E69" data-uri="chapter09.xhtml#P7000497027000000000000000045E69">
<li id="P7000497027000000000000000045E6A" data-uri="chapter09.xhtml#P7000497027000000000000000045E6A" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E6B" data-uri="chapter09.xhtml#P7000497027000000000000000045E6B" class="pcalibre calibre3 pcalibre1">P1 = malloc(4*sizeof(int)): first four squareas shaded, beginning at p1</p></li>
<li id="P7000497027000000000000000045E6C" data-uri="chapter09.xhtml#P7000497027000000000000000045E6C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E6D" data-uri="chapter09.xhtml#P7000497027000000000000000045E6D" class="pcalibre calibre3 pcalibre1">P2 = malloc(5*sizeof(int)): first four shaded from p1 and p2, with next five shaded light and sixth shaded dark</p></li>
<li id="P7000497027000000000000000045E6E" data-uri="chapter09.xhtml#P7000497027000000000000000045E6E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E6F" data-uri="chapter09.xhtml#P7000497027000000000000000045E6F" class="pcalibre calibre3 pcalibre1">P3 = malloc (6*sizeof(int)): first four shaded from p1 to p2; next 6 shaded (last one dark) from p2 to p3; next 6 shaded</p></li>
<li id="P7000497027000000000000000045E70" data-uri="chapter09.xhtml#P7000497027000000000000000045E70" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E71" data-uri="chapter09.xhtml#P7000497027000000000000000045E71" class="pcalibre calibre3 pcalibre1">Free(p2): first four shaded from p1 to p2; no shading for 6 between p2 and p3; 6 shaded from p3</p></li>
<li id="P7000497027000000000000000045E72" data-uri="chapter09.xhtml#P7000497027000000000000000045E72" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E73" data-uri="chapter09.xhtml#P7000497027000000000000000045E73" class="pcalibre calibre3 pcalibre1">P4 = malloc (2*sizeof(int)): first four shaded from p1; next two shaded, with first labeled p2 and p4; next four not shaded; next six shaded from p3.</p></li>
</ol>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000045E74" data-uri="chapter09.xhtml#P7000497027000000000000000045E74" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34</span></a> shows how an implementation of <code id="P7000497027000000000000000045E75" data-uri="chapter09.xhtml#P7000497027000000000000000045E75" class="pcalibre1 calibre8 pcalibre">malloc</code> and <code id="P7000497027000000000000000045E76" data-uri="chapter09.xhtml#P7000497027000000000000000045E76" class="pcalibre1 calibre8 pcalibre">free</code> might manage a (very) small heap of 16 words for a C program. Each box represents a 4-byte word. The heavy-lined rectangles correspond to allocated blocks (shaded) and free blocks (unshaded). Initially, the heap consists of a single 16-word double-word-aligned free block.<a class="noteref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" id="r__P7000497027000000000000000007861" epub:type="noteref" href="#P7000497027000000000000000007861"><sup class="pcalibre1 calibre21 pcalibre">1</sup></a></p><aside class="footnote pcalibre5 pcalibre" id="P7000497027000000000000000007861" data-uri="chapter09.xhtml#P7000497027000000000000000007861" epub:type="footnote"><p class="pcalibre calibre3 pcalibre1"><span class="pcalibre1 number2 pcalibre"><a href="#r__P7000497027000000000000000007861" class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1">1. </a></span>Throughout this section, we will assume that the allocator returns blocks aligned to 8-byte double-word boundaries.</p></aside>
<ul class="pcalibre ul_none pcalibre1" id="P7000497027000000000000000045E77" data-uri="chapter09.xhtml#P7000497027000000000000000045E77">
<li id="P7000497027000000000000000045E78" data-uri="chapter09.xhtml#P7000497027000000000000000045E78" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E79" data-uri="chapter09.xhtml#P7000497027000000000000000045E79" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34(a)</span></a>. </span>The program asks for a four-word block. <code id="P7000497027000000000000000045E7A" data-uri="chapter09.xhtml#P7000497027000000000000000045E7A" class="pcalibre1 calibre8 pcalibre">Malloc</code> responds by carving out a four-word block from the front of the free block and returning a pointer to the first word of the block.</p></li>
<li id="P7000497027000000000000000045E7B" data-uri="chapter09.xhtml#P7000497027000000000000000045E7B" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E7C" data-uri="chapter09.xhtml#P7000497027000000000000000045E7C" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34(b)</span></a>. </span>The program requests a five-word block. <code id="P7000497027000000000000000045E7D" data-uri="chapter09.xhtml#P7000497027000000000000000045E7D" class="pcalibre1 calibre8 pcalibre">Malloc</code> responds by allocating a six-word block from the front of the free block. In this example, <code id="P7000497027000000000000000045E7E" data-uri="chapter09.xhtml#P7000497027000000000000000045E7E" class="pcalibre1 calibre8 pcalibre">malloc</code> pads the block with an extra word in order to keep the free block aligned on a double-word boundary.</p></li>
<li id="P7000497027000000000000000045E7F" data-uri="chapter09.xhtml#P7000497027000000000000000045E7F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E80" data-uri="chapter09.xhtml#P7000497027000000000000000045E80" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34(c)</span></a>. </span>The program requests a six-word block and <code id="P7000497027000000000000000045E81" data-uri="chapter09.xhtml#P7000497027000000000000000045E81" class="pcalibre1 calibre8 pcalibre">malloc</code> responds by carving out a six-word block from the free block.</p></li>
<li id="P7000497027000000000000000045E82" data-uri="chapter09.xhtml#P7000497027000000000000000045E82" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E83" data-uri="chapter09.xhtml#P7000497027000000000000000045E83" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34(d)</span></a>. </span>The program frees the six-word block that was allocated in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34(b)</span></a>. Notice that after the call to <code id="P7000497027000000000000000045E84" data-uri="chapter09.xhtml#P7000497027000000000000000045E84" class="pcalibre1 calibre8 pcalibre">free</code> returns, the pointer <code id="P7000497027000000000000000045E85" data-uri="chapter09.xhtml#P7000497027000000000000000045E85" class="pcalibre1 calibre8 pcalibre">p2</code> <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000073A7" title="843" data-uri="chapter09.xhtml#P70004970270000000000000000073A7" epub:type="pagebreak"></span>still points to the freed block. It is the responsibility of the application not to use <code id="P7000497027000000000000000045E86" data-uri="chapter09.xhtml#P7000497027000000000000000045E86" class="pcalibre1 calibre8 pcalibre">p2</code> again until it is reinitialized by a new call to <code id="P7000497027000000000000000045E87" data-uri="chapter09.xhtml#P7000497027000000000000000045E87" class="pcalibre1 calibre8 pcalibre">malloc</code>.</p></li>
<li id="P7000497027000000000000000045E88" data-uri="chapter09.xhtml#P7000497027000000000000000045E88" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E89" data-uri="chapter09.xhtml#P7000497027000000000000000045E89" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34(e)</span></a>. </span>The program requests a two-word block. In this case, <code id="P7000497027000000000000000045E8A" data-uri="chapter09.xhtml#P7000497027000000000000000045E8A" class="pcalibre1 calibre8 pcalibre">malloc</code> allocates a portion of the block that was freed in the previous step and returns a pointer to this new block.</p></li>
</ul>
</section>
<section id="P70004970270000000000000000073AD" data-uri="chapter09.xhtml#P70004970270000000000000000073AD" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045E8B" data-uri="chapter09.xhtml#P7000497027000000000000000045E8B" epub:type="title"><span class="pcalibre label pcalibre1">9.9.2 </span>Why Dynamic Memory Allocation?</h1></header>
<p id="P7000497027000000000000000045E8C" data-uri="chapter09.xhtml#P7000497027000000000000000045E8C" class="pcalibre1 pcalibre calibre2">The most important reason that programs use dynamic memory allocation is that often they do not know the sizes of certain data structures until the program actually runs. For example, suppose we are asked to write a C program that reads a list of <var class="calibre5 pcalibre pcalibre1">n</var> ASCII integers, one integer per line, from <code id="P7000497027000000000000000045E8D" data-uri="chapter09.xhtml#P7000497027000000000000000045E8D" class="pcalibre1 calibre8 pcalibre">stdin</code> into a C array. The input consists of the integer <var class="calibre5 pcalibre pcalibre1">n</var>, followed by the <var class="calibre5 pcalibre pcalibre1">n</var> integers to be read and stored into the array. The simplest approach is to define the array statically with some hard-coded maximum array size:</p>
<pre id="P7000497027000000000000000045E8E" data-uri="chapter09.xhtml#P7000497027000000000000000045E8E" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045E8F" data-uri="chapter09.xhtml#P7000497027000000000000000045E8F" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	#define MAXN 15213
3	
4	int array [MAXN];
5	
6	int main()
7	{
8		int i, n;
9	
10		scanf(%d", &amp;n);
11		if (n &gt; MAXN)
12			app_error("Input file too big");
13		for (i = 0; i &lt; n; i++)
14			scanf (%d", &amp;array[i]);
15		exit(0);
16	}
</code></pre>
<p id="P7000497027000000000000000045E90" data-uri="chapter09.xhtml#P7000497027000000000000000045E90" class="pcalibre1 pcalibre calibre2">Allocating arrays with hard-coded sizes like this is often a bad idea. The value of MAXN is arbitrary and has no relation to the actual amount of available virtual memory on the machine. Further, if the user of this program wanted to read a file that was larger than MAXN, the only recourse would be to recompile the program with a larger value of MAXN. While not a problem for this simple example, the presence of hard-coded array bounds can become a maintenance nightmare for large software products with millions of lines of code and numerous users.</p>
<p id="P7000497027000000000000000045E91" data-uri="chapter09.xhtml#P7000497027000000000000000045E91" class="pcalibre1 pcalibre calibre2">A better approach is to allocate the array dynamically, at run time, after the value of <var class="calibre5 pcalibre pcalibre1">n</var> becomes known. With this approach, the maximum size of the array is limited only by the amount of available virtual memory.</p>
<pre id="P7000497027000000000000000045E92" data-uri="chapter09.xhtml#P7000497027000000000000000045E92" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045E93" data-uri="chapter09.xhtml#P7000497027000000000000000045E93" class="calibre10 pcalibre pcalibre1">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000073B7" title="844" data-uri="chapter09.xhtml#P70004970270000000000000000073B7" epub:type="pagebreak"></span>1	#include "csapp.h"
2	
3	int main()
4	{
5		int *array, i, n;
6	
7		scanf ("%d", &amp;n);
8		array = (int *)Malloc(n * sizeof(int));
9		for (i = 0; i &lt; n; i++)
10			scanf ("%d", &amp;array[i]);
11		free(array);
12		exit(0);
13	}
</code></pre>
<p id="P7000497027000000000000000045E94" data-uri="chapter09.xhtml#P7000497027000000000000000045E94" class="pcalibre1 pcalibre calibre2">Dynamic memory allocation is a useful and important programming technique. However, in order to use allocators correctly and efficiently, programmers need to have an understanding of how they work. We will discuss some of the gruesome errors that can result from the improper use of allocators in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000075E8.xhtml#P70004970270000000000000000075E8"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">9.11</span></a>.</p>
</section>
<section id="P70004970270000000000000000073B9" data-uri="chapter09.xhtml#P70004970270000000000000000073B9" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045E95" data-uri="chapter09.xhtml#P7000497027000000000000000045E95" epub:type="title"><span class="pcalibre label pcalibre1">9.9.3 </span>Allocator Requirements and Goals</h1></header>
<p id="P7000497027000000000000000045E96" data-uri="chapter09.xhtml#P7000497027000000000000000045E96" class="pcalibre1 pcalibre calibre2">Explicit allocators must operate within some rather stringent constraints:</p>
<ul class="pcalibre ul_none pcalibre1" id="P7000497027000000000000000045E97" data-uri="chapter09.xhtml#P7000497027000000000000000045E97">
<li id="P7000497027000000000000000045E98" data-uri="chapter09.xhtml#P7000497027000000000000000045E98" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E99" data-uri="chapter09.xhtml#P7000497027000000000000000045E99" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Handling arbitrary request sequences. </span>An application can make an arbitrary sequence of allocate and free requests, subject to the constraint that each free request must correspond to a currently allocated block obtained from a previous allocate request. Thus, the allocator cannot make any assumptions about the ordering of allocate and free requests. For example, the allocator cannot assume that all allocate requests are accompanied by a matching free request, or that matching allocate and free requests are nested.</p></li>
<li id="P7000497027000000000000000045E9A" data-uri="chapter09.xhtml#P7000497027000000000000000045E9A" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E9B" data-uri="chapter09.xhtml#P7000497027000000000000000045E9B" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Making immediate responses to requests. </span>The allocator must respond immediately to allocate requests. Thus, the allocator is not allowed to reorder or buffer requests in order to improve performance.</p></li>
<li id="P7000497027000000000000000045E9C" data-uri="chapter09.xhtml#P7000497027000000000000000045E9C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E9D" data-uri="chapter09.xhtml#P7000497027000000000000000045E9D" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Using only the heap. </span>In order for the allocator to be scalable, any nonscalar data structures used by the allocator must be stored in the heap itself.</p></li>
<li id="P7000497027000000000000000045E9E" data-uri="chapter09.xhtml#P7000497027000000000000000045E9E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045E9F" data-uri="chapter09.xhtml#P7000497027000000000000000045E9F" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Aligning blocks (alignment requirement). </span>The allocator must align blocks in such a way that they can hold any type of data object.</p></li>
<li id="P7000497027000000000000000045EA0" data-uri="chapter09.xhtml#P7000497027000000000000000045EA0" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EA1" data-uri="chapter09.xhtml#P7000497027000000000000000045EA1" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Not modifying allocated blocks. </span>Allocators can only manipulate or change free blocks. In particular, they are not allowed to modify or move blocks once they are allocated. Thus, techniques such as compaction of allocated blocks are not permitted.</p></li>
</ul>
<p id="P7000497027000000000000000045EA2" data-uri="chapter09.xhtml#P7000497027000000000000000045EA2" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000073C8" title="845" data-uri="chapter09.xhtml#P70004970270000000000000000073C8" epub:type="pagebreak"></span>Working within these constraints, the author of an allocator attempts to meet the often conflicting performance goals of maximizing throughput and memory utilization.</p>
<p id="P7000497027000000000000000045EA3" data-uri="chapter09.xhtml#P7000497027000000000000000045EA3" class="pcalibre1 pcalibre calibre2"><span class="pcalibre leadin pcalibre1">Goal 1: Maximizing throughput.</span> Given some sequence of <var class="calibre5 pcalibre pcalibre1">n</var> allocate and free requests</p>
<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000045EA4" data-uri="chapter09.xhtml#P7000497027000000000000000045EA4"><m:math display="block" alttext="" data-uri="" altimg-width="228" altimg-height="19" altimg="../images/ch09-eq6.png"><m:mrow><m:msub><m:mi>R</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mi>k</m:mi></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:math></div>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045EA5" data-uri="chapter09.xhtml#P7000497027000000000000000045EA5">we would like to maximize an allocator's <i class="calibre5 pcalibre pcalibre1">throughput</i>, which is defined as the number of requests that it completes per unit time. For example, if an allocator completes 500 allocate requests and 500 free requests in 1 second, then its throughput is 1,000 operations per second. In general, we can maximize throughput by minimizing the average time to satisfy allocate and free requests. As we'll see, it is not too difficult to develop allocators with reasonably good performance where the worst-case running time of an allocate request is linear in the number of free blocks and the running time of a free request is constant.</p>
<p id="P7000497027000000000000000045EA6" data-uri="chapter09.xhtml#P7000497027000000000000000045EA6" class="pcalibre1 pcalibre calibre2"><span class="pcalibre leadin pcalibre1">Goal 2: Maximizing memory utilization.</span> Naive programmers often incorrectly assume that virtual memory is an unlimited resource. In fact, the total amount of virtual memory allocated by all of the processes in a system is limited by the amount of swap space on disk. Good programmers know that virtual memory is a finite resource that must be used efficiently. This is especially true for a dynamic memory allocator that might be asked to allocate and free large blocks of memory.</p>
<p id="P7000497027000000000000000045EA7" data-uri="chapter09.xhtml#P7000497027000000000000000045EA7" class="pcalibre1 pcalibre calibre2">There are a number of ways to characterize how efficiently an allocator uses the heap. In our experience, the most useful metric is <i class="calibre5 pcalibre pcalibre1">peak utilization.</i> As before, we are given some sequence of <var class="calibre5 pcalibre pcalibre1">n</var> allocate and free requests</p>
<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000045EA8" data-uri="chapter09.xhtml#P7000497027000000000000000045EA8"><m:math display="block" alttext="" data-uri="" altimg-width="228" altimg-height="19" altimg="../images/ch09-eq7.png"><m:mrow><m:msub><m:mi>R</m:mi><m:mn>0</m:mn></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mn>1</m:mn></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mi>k</m:mi></m:msub><m:mo>,</m:mo><m:mo>…</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mi>R</m:mi><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:math></div>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045EA9" data-uri="chapter09.xhtml#P7000497027000000000000000045EA9">If an application requests a block of <var class="calibre5 pcalibre pcalibre1">p</var> bytes, then the resulting allocated block has a <i class="calibre5 pcalibre pcalibre1">payload</i> of <var class="calibre5 pcalibre pcalibre1">p</var> bytes. After request <i class="calibre5 pcalibre pcalibre1">R<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> has completed, let the <i class="calibre5 pcalibre pcalibre1">aggregate payload</i>, denoted <i class="calibre5 pcalibre pcalibre1">P<sub class="pcalibre1 calibre47 pcalibre">k</sub></i>, be the sum of the pay loads of the currently allocated blocks, and let <i class="calibre5 pcalibre pcalibre1">H<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> denote the current (monotonically nondecreasing) size of the heap.</p>
<p id="P7000497027000000000000000045EAA" data-uri="chapter09.xhtml#P7000497027000000000000000045EAA" class="pcalibre1 pcalibre calibre2">Then the peak utilization over the first <var class="calibre5 pcalibre pcalibre1">k</var> + 1 requests, denoted by <i class="calibre5 pcalibre pcalibre1">U<sub class="pcalibre1 calibre47 pcalibre">k</sub></i>, is given by</p>
<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000045EAB" data-uri="chapter09.xhtml#P7000497027000000000000000045EAB"><m:math display="block" alttext="" data-uri="" altimg-width="139" altimg-height="51" altimg="../images/ch09-eq8.png"><m:mrow><m:msub><m:mi>U</m:mi><m:mi>k</m:mi></m:msub><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>max</m:mi></m:mrow><m:mrow><m:mi>i</m:mi><m:mo>≤</m:mo><m:mi>k</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:msub><m:mi>P</m:mi><m:mi>i</m:mi></m:msub></m:mrow><m:mrow><m:msub><m:mi>H</m:mi><m:mi>k</m:mi></m:msub></m:mrow></m:mfrac></m:mrow></m:math></div>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045EAC" data-uri="chapter09.xhtml#P7000497027000000000000000045EAC">The objective of the allocator, then, is to maximize the peak utilization <var class="calibre5 pcalibre pcalibre1">U</var><sub class="pcalibre1 calibre47 pcalibre"><var class="calibre5 pcalibre pcalibre1">n</var>–1</sub> over the entire sequence. As we will see, there is a tension between maximizing throughput and utilization. In particular, it is easy to write an allocator that maximizes throughput at the expense of heap utilization. One of the interesting challenges in any allocator design is finding an appropriate balance between the two goals.</p>
<aside class="sidebar pcalibre5 pcalibre" id="P70004970270000000000000000073D3" data-uri="chapter09.xhtml#P70004970270000000000000000073D3"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000045EAD" data-uri="chapter09.xhtml#P7000497027000000000000000045EAD" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000073D5" title="846" data-uri="chapter09.xhtml#P70004970270000000000000000073D5" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Relaxing the monotonicity assumption</h1></header>
<p id="P7000497027000000000000000045EAE" data-uri="chapter09.xhtml#P7000497027000000000000000045EAE" class="pcalibre calibre3 pcalibre1">We could relax the monotonically nondecreasing assumption in our definition of <i class="calibre5 pcalibre pcalibre1">U<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> and allow the heap to grow up and down by letting <i class="calibre5 pcalibre pcalibre1">H<sub class="pcalibre1 calibre47 pcalibre">k</sub></i> be the high-water mark over the first <var class="calibre5 pcalibre pcalibre1">k</var> + 1 requests.</p>
</aside>
</section>
<section id="P70004970270000000000000000073D7" data-uri="chapter09.xhtml#P70004970270000000000000000073D7" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045EAF" data-uri="chapter09.xhtml#P7000497027000000000000000045EAF" epub:type="title"><span class="pcalibre label pcalibre1">9.9.4 </span>Fragmentation</h1></header>
<p id="P7000497027000000000000000045EB0" data-uri="chapter09.xhtml#P7000497027000000000000000045EB0" class="pcalibre1 pcalibre calibre2">The primary cause of poor heap utilization is a phenomenon known as <i class="calibre5 pcalibre pcalibre1">fragmentation</i>, which occurs when otherwise unused memory is not available to satisfy allocate requests. There are two forms of fragmentation: <i class="calibre5 pcalibre pcalibre1">internal fragmentation</i> and <i class="calibre5 pcalibre pcalibre1">external fragmentation.</i></p>
<p id="P7000497027000000000000000045EB1" data-uri="chapter09.xhtml#P7000497027000000000000000045EB1" class="pcalibre1 pcalibre calibre2"><i class="calibre5 pcalibre pcalibre1">Internal fragmentation</i> occurs when an allocated block is larger than the pay-load. This might happen for a number of reasons. For example, the implementation of an allocator might impose a minimum size on allocated blocks that is greater than some requested payload. Or, as we saw in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34(b)</span></a>, the allocator might increase the block size in order to satisfy alignment constraints.</p>
<p id="P7000497027000000000000000045EB2" data-uri="chapter09.xhtml#P7000497027000000000000000045EB2" class="pcalibre1 pcalibre calibre2">Internal fragmentation is straightforward to quantify. It is simply the sum of the differences between the sizes of the allocated blocks and their payloads. Thus, at any point in time, the amount of internal fragmentation depends only on the pattern of previous requests and the allocator implementation.</p>
<p id="P7000497027000000000000000045EB3" data-uri="chapter09.xhtml#P7000497027000000000000000045EB3" class="pcalibre1 pcalibre calibre2"><i class="calibre5 pcalibre pcalibre1">External fragmentation</i> occurs when there <i class="calibre5 pcalibre pcalibre1">is</i> enough aggregate free memory to satisfy an allocate request, but no single free block is large enough to handle the request. For example, if the request in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000738C"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.34(e)</span></a> were for eight words rather than two words, then the request could not be satisfied without requesting additional virtual memory from the kernel, even though there are eight free words remaining in the heap. The problem arises because these eight words are spread over two free blocks.</p>
<p id="P7000497027000000000000000045EB4" data-uri="chapter09.xhtml#P7000497027000000000000000045EB4" class="pcalibre1 pcalibre calibre2">External fragmentation is much more difficult to quantify than internal fragmentation because it depends not only on the pattern of previous requests and the allocator implementation but also on the pattern of <i class="calibre5 pcalibre pcalibre1">future</i> requests. For example, suppose that after <var class="calibre5 pcalibre pcalibre1">k</var> requests all of the free blocks are exactly four words in size. Does this heap suffer from external fragmentation? The answer depends on the pattern of future requests. If all of the future allocate requests are for blocks that are smaller than or equal to four words, then there is no external fragmentation. On the other hand, if one or more requests ask for blocks larger than four words, then the heap does suffer from external fragmentation.</p>
<p id="P7000497027000000000000000045EB5" data-uri="chapter09.xhtml#P7000497027000000000000000045EB5" class="pcalibre1 pcalibre calibre2">Since external fragmentation is difficult to quantify and impossible to predict, allocators typically employ heuristics that attempt to maintain small numbers of larger free blocks rather than large numbers of smaller free blocks.</p>
</section>
<section id="P70004970270000000000000000073DF" data-uri="chapter09.xhtml#P70004970270000000000000000073DF" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045EB6" data-uri="chapter09.xhtml#P7000497027000000000000000045EB6" epub:type="title"><span class="pcalibre label pcalibre1">9.9.5 </span>Implementation Issues</h1></header>
<p id="P7000497027000000000000000045EB7" data-uri="chapter09.xhtml#P7000497027000000000000000045EB7" class="pcalibre1 pcalibre calibre2">The simplest imaginable allocator would organize the heap as a large array of bytes and a pointer <code id="P7000497027000000000000000045EB8" data-uri="chapter09.xhtml#P7000497027000000000000000045EB8" class="pcalibre1 calibre8 pcalibre">p</code> that initially points to the first byte of the array. To allocate <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000073E3" title="847" data-uri="chapter09.xhtml#P70004970270000000000000000073E3" epub:type="pagebreak"></span><code id="P7000497027000000000000000045EB9" data-uri="chapter09.xhtml#P7000497027000000000000000045EB9" class="pcalibre1 calibre8 pcalibre">size</code> bytes, <code id="P7000497027000000000000000045EBA" data-uri="chapter09.xhtml#P7000497027000000000000000045EBA" class="pcalibre1 calibre8 pcalibre">malloc</code> would save the current value of <code id="P7000497027000000000000000045EBB" data-uri="chapter09.xhtml#P7000497027000000000000000045EBB" class="pcalibre1 calibre8 pcalibre">p</code> on the stack, increment <code id="P7000497027000000000000000045EBC" data-uri="chapter09.xhtml#P7000497027000000000000000045EBC" class="pcalibre1 calibre8 pcalibre">p</code> by <code id="P7000497027000000000000000045EBD" data-uri="chapter09.xhtml#P7000497027000000000000000045EBD" class="pcalibre1 calibre8 pcalibre">size</code>, and return the old value of <code id="P7000497027000000000000000045EBE" data-uri="chapter09.xhtml#P7000497027000000000000000045EBE" class="pcalibre1 calibre8 pcalibre">p</code> to the caller. <code id="P7000497027000000000000000045EBF" data-uri="chapter09.xhtml#P7000497027000000000000000045EBF" class="pcalibre1 calibre8 pcalibre">Free</code> would simply return to the caller without doing anything.</p>
<p id="P7000497027000000000000000045EC0" data-uri="chapter09.xhtml#P7000497027000000000000000045EC0" class="pcalibre1 pcalibre calibre2">This naive allocator is an extreme point in the design space. Since each <code id="P7000497027000000000000000045EC1" data-uri="chapter09.xhtml#P7000497027000000000000000045EC1" class="pcalibre1 calibre8 pcalibre">malloc</code> and <code id="P7000497027000000000000000045EC2" data-uri="chapter09.xhtml#P7000497027000000000000000045EC2" class="pcalibre1 calibre8 pcalibre">free</code> execute only a handful of instructions, throughput would be extremely good. However, since the allocator never reuses any blocks, memory utilization would be extremely bad. A practical allocator that strikes a better balance between throughput and utilization must consider the following issues:</p>
<ul class="pcalibre ul_none pcalibre1" id="P7000497027000000000000000045EC3" data-uri="chapter09.xhtml#P7000497027000000000000000045EC3">
<li id="P7000497027000000000000000045EC4" data-uri="chapter09.xhtml#P7000497027000000000000000045EC4" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EC5" data-uri="chapter09.xhtml#P7000497027000000000000000045EC5" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Free block organization. </span>How do we keep track of free blocks?</p></li>
<li id="P7000497027000000000000000045EC6" data-uri="chapter09.xhtml#P7000497027000000000000000045EC6" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EC7" data-uri="chapter09.xhtml#P7000497027000000000000000045EC7" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Placement. </span>How do we choose an appropriate free block in which to place a newly allocated block?</p></li>
<li id="P7000497027000000000000000045EC8" data-uri="chapter09.xhtml#P7000497027000000000000000045EC8" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EC9" data-uri="chapter09.xhtml#P7000497027000000000000000045EC9" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Splitting. </span>After we place a newly allocated block in some free block, what do we do with the remainder of the free block?</p></li>
<li id="P7000497027000000000000000045ECA" data-uri="chapter09.xhtml#P7000497027000000000000000045ECA" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045ECB" data-uri="chapter09.xhtml#P7000497027000000000000000045ECB" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Coalescing. </span>What do we do with a block that has just been freed?</p></li>
</ul>
<p id="P7000497027000000000000000045ECC" data-uri="chapter09.xhtml#P7000497027000000000000000045ECC" class="pcalibre1 pcalibre calibre2">The rest of this section looks at these issues in more detail. Since the basic techniques of placement, splitting, and coalescing cut across many different free block organizations, we will introduce them in the context of a simple free block organization known as an implicit free list.</p>
</section>
<section id="P70004970270000000000000000073F8" data-uri="chapter09.xhtml#P70004970270000000000000000073F8" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045ECD" data-uri="chapter09.xhtml#P7000497027000000000000000045ECD" epub:type="title"><span class="pcalibre label pcalibre1">9.9.6 </span>Implicit Free Lists</h1></header>
<p id="P7000497027000000000000000045ECE" data-uri="chapter09.xhtml#P7000497027000000000000000045ECE" class="pcalibre1 pcalibre calibre2">Any practical allocator needs some data structure that allows it to distinguish block boundaries and to distinguish between allocated and free blocks. Most allocators embed this information in the blocks themselves. One simple approach is shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000073FC"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.35</span></a>.</p>
<p id="P7000497027000000000000000045ECF" data-uri="chapter09.xhtml#P7000497027000000000000000045ECF" class="pcalibre1 pcalibre calibre2">In this case, a block consists of a one-word <i class="calibre5 pcalibre pcalibre1">header</i>, the payload, and possibly some additional <i class="calibre5 pcalibre pcalibre1">padding.</i> The header encodes the block size (including the header and any padding) as well as whether the block is allocated or free. If we impose a double-word alignment constraint, then the block size is always a multiple of 8 and the 3 low-order bits of the block size are always zero. Thus, we need to store only the 29 high-order bits of the block size, freeing the remaining 3 bits to encode other information. In this case, we are using the least significant of these bits</p>
<figure id="P70004970270000000000000000073FC" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000073FC">
<img alt="A diagram illustrates the format of a simple heap block." id="P7000497027000000000000000045ED0" data-uri="P700049702700000000000000000B79E" src="../images/p847-1.png" class="pcalibre calibre294 pcalibre1"/>
<figcaption id="P7000497027000000000000000045ED1" data-uri="chapter09.xhtml#P7000497027000000000000000045ED1" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045ED2" data-uri="chapter09.xhtml#P7000497027000000000000000045ED2" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.35 </span>Format of a simple heap block.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026224" data-uri="chapter09.xhtml#P7000497027000000000000000026224">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045ED3" data-uri="chapter09.xhtml#P7000497027000000000000000045ED3" class="pcalibre1 pcalibre calibre2">A diagram has three sections, each from 31 to 0 bits, from top to bottom as follows:</p>
<ul id="P7000497027000000000000000045ED4" data-uri="chapter09.xhtml#P7000497027000000000000000045ED4" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045ED5" data-uri="chapter09.xhtml#P7000497027000000000000000045ED5" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045ED6" data-uri="chapter09.xhtml#P7000497027000000000000000045ED6" class="pcalibre calibre3 pcalibre1">Header: block size from bit 31 to 3, with 0 under bits 2 and 1 and a under bit 0 (a = 1: Allocated; a = 0: Free)</p></li>
<li id="P7000497027000000000000000045ED7" data-uri="chapter09.xhtml#P7000497027000000000000000045ED7" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045ED8" data-uri="chapter09.xhtml#P7000497027000000000000000045ED8" class="pcalibre calibre3 pcalibre1">Payload (allocated block only); malloc returns a pointer to the beginning of the payload</p></li>
<li id="P7000497027000000000000000045ED9" data-uri="chapter09.xhtml#P7000497027000000000000000045ED9" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EDA" data-uri="chapter09.xhtml#P7000497027000000000000000045EDA" class="pcalibre calibre3 pcalibre1">Padding (optional)</p></li>
</ul>
</details>
</figcaption>
</figure>
<figure id="P7000497027000000000000000007400" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007400">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007401" title="848" data-uri="chapter09.xhtml#P7000497027000000000000000007401" epub:type="pagebreak"></span>
<img alt="A diagram illustrates organizing the heap with an implicit free list." id="P7000497027000000000000000045EDB" data-uri="P700049702700000000000000000B79F" src="../images/p848-1.png" class="pcalibre1 pcalibre calibre295"/>
<figcaption id="P7000497027000000000000000045EDC" data-uri="chapter09.xhtml#P7000497027000000000000000045EDC" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045EDD" data-uri="chapter09.xhtml#P7000497027000000000000000045EDD" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.36 </span>Organizing the heap with an implicit free list.</h1></header><div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045EDE" data-uri="chapter09.xhtml#P7000497027000000000000000045EDE"><p id="P7000497027000000000000000045EDF" data-uri="chapter09.xhtml#P7000497027000000000000000045EDF" class="pcalibre calibre3 pcalibre1">Allocated blocks are shaded. Free blocks are unshaded. Headers are labeled with (size (bytes)/allocated bit).</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026232" data-uri="chapter09.xhtml#P7000497027000000000000000026232">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045EE0" data-uri="chapter09.xhtml#P7000497027000000000000000045EE0" class="pcalibre1 pcalibre calibre2">A diagram has a row of shaded and unshaded blocks, from start of heap on the left to double-word aligned on the right. Arrows jump between groups of shaded blocks. The blocks are summarized from left to right below.</p>
<ul id="P7000497027000000000000000045EE1" data-uri="chapter09.xhtml#P7000497027000000000000000045EE1" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045EE2" data-uri="chapter09.xhtml#P7000497027000000000000000045EE2" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EE3" data-uri="chapter09.xhtml#P7000497027000000000000000045EE3" class="pcalibre calibre3 pcalibre1">Shaded, labeled unused</p></li>
<li id="P7000497027000000000000000045EE4" data-uri="chapter09.xhtml#P7000497027000000000000000045EE4" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EE5" data-uri="chapter09.xhtml#P7000497027000000000000000045EE5" class="pcalibre calibre3 pcalibre1">Two unshaded, first labeled 8/0</p></li>
<li id="P7000497027000000000000000045EE6" data-uri="chapter09.xhtml#P7000497027000000000000000045EE6" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EE7" data-uri="chapter09.xhtml#P7000497027000000000000000045EE7" class="pcalibre calibre3 pcalibre1">Four shaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045EE8" data-uri="chapter09.xhtml#P7000497027000000000000000045EE8" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EE9" data-uri="chapter09.xhtml#P7000497027000000000000000045EE9" class="pcalibre calibre3 pcalibre1">Eight unshaded, first labeled 32/0</p></li>
<li id="P7000497027000000000000000045EEA" data-uri="chapter09.xhtml#P7000497027000000000000000045EEA" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045EEB" data-uri="chapter09.xhtml#P7000497027000000000000000045EEB" class="pcalibre calibre3 pcalibre1">Five shaded, first labeled 16/1 and last labeled 0/1</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045EEC" data-uri="chapter09.xhtml#P7000497027000000000000000045EEC">(the <i class="calibre5 pcalibre pcalibre1">allocated bit)</i> to indicate whether the block is allocated or free. For example, suppose we have an allocated block with a block size of 24 (<code id="P7000497027000000000000000045EED" data-uri="chapter09.xhtml#P7000497027000000000000000045EED" class="pcalibre1 calibre8 pcalibre">0x18</code>) bytes. Then its header would be</p>
<pre id="P7000497027000000000000000045EEE" data-uri="chapter09.xhtml#P7000497027000000000000000045EEE" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045EEF" data-uri="chapter09.xhtml#P7000497027000000000000000045EEF" class="calibre10 pcalibre pcalibre1">
0x00000018 | 0x1 = 0x00000019
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045EF0" data-uri="chapter09.xhtml#P7000497027000000000000000045EF0">Similarly, a free block with a block size of 40 (<code id="P7000497027000000000000000045EF1" data-uri="chapter09.xhtml#P7000497027000000000000000045EF1" class="pcalibre1 calibre8 pcalibre">0x28</code>) bytes would have a header of</p>
<pre id="P7000497027000000000000000045EF2" data-uri="chapter09.xhtml#P7000497027000000000000000045EF2" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045EF3" data-uri="chapter09.xhtml#P7000497027000000000000000045EF3" class="calibre10 pcalibre pcalibre1">
0x00000028 | 0x0 = 0x00000028
</code></pre>
<p id="P7000497027000000000000000045EF4" data-uri="chapter09.xhtml#P7000497027000000000000000045EF4" class="pcalibre1 pcalibre calibre2">The header is followed by the payload that the application requested when it called <code id="P7000497027000000000000000045EF5" data-uri="chapter09.xhtml#P7000497027000000000000000045EF5" class="pcalibre1 calibre8 pcalibre">malloc</code>. The payload is followed by a chunk of unused padding that can be any size. There are a number of reasons for the padding. For example, the padding might be part of an allocator's strategy for combating external fragmentation. Or it might be needed to satisfy the alignment requirement.</p>
<p id="P7000497027000000000000000045EF6" data-uri="chapter09.xhtml#P7000497027000000000000000045EF6" class="pcalibre1 pcalibre calibre2">Given the block format in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000073FC"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.35</span></a>, we can organize the heap as a sequence of contiguous allocated and free blocks, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007400"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.36</span></a>.</p>
<p id="P7000497027000000000000000045EF7" data-uri="chapter09.xhtml#P7000497027000000000000000045EF7" class="pcalibre1 pcalibre calibre2">We call this organization an <i class="calibre5 pcalibre pcalibre1">implicit free list</i> because the free blocks are linked implicitly by the size fields in the headers. The allocator can indirectly traverse the entire set of free blocks by traversing <i class="calibre5 pcalibre pcalibre1">all</i> of the blocks in the heap. Notice that we need some kind of specially marked end block—in this example, a terminating header with the allocated bit set and a size of zero. (As we will see in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000748F"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">9.9.12</span></a>, setting the allocated bit simplifies the coalescing of free blocks.)</p>
<p id="P7000497027000000000000000045EF8" data-uri="chapter09.xhtml#P7000497027000000000000000045EF8" class="pcalibre1 pcalibre calibre2">The advantage of an implicit free list is simplicity. A significant disadvantage is that the cost of any operation that requires a search of the free list, such as placing allocated blocks, will be linear in the <i class="calibre5 pcalibre pcalibre1">total</i> number of allocated and free blocks in the heap.</p>
<p id="P7000497027000000000000000045EF9" data-uri="chapter09.xhtml#P7000497027000000000000000045EF9" class="pcalibre1 pcalibre calibre2">It is important to realize that the system's alignment requirement and the allocator's choice of block format impose a <i class="calibre5 pcalibre pcalibre1">minimum block size</i> on the allocator. No allocated or free block may be smaller than this minimum. For example, if we assume a double-word alignment requirement, then the size of each block must be a multiple of two words (8 bytes). Thus, the block format in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000073FC"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.35</span></a> induces a minimum block size of two words: one word for the header and another to maintain the alignment requirement. Even if the application were to request a single byte, the allocator would still create a two-word block.</p>
<section id="P7000497027000000000000000007415" data-uri="chapter09.xhtml#P7000497027000000000000000007415" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045EFA" data-uri="chapter09.xhtml#P7000497027000000000000000045EFA" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007417" title="849" data-uri="chapter09.xhtml#P7000497027000000000000000007417" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">9.6 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P700049702700000000000000000780C">883</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000045EFB" data-uri="chapter09.xhtml#P7000497027000000000000000045EFB">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000045EFC" data-uri="chapter09.xhtml#P7000497027000000000000000045EFC">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045EFD" data-uri="chapter09.xhtml#P7000497027000000000000000045EFD"><p id="P7000497027000000000000000045EFE" data-uri="chapter09.xhtml#P7000497027000000000000000045EFE" class="pcalibre calibre3 pcalibre1">Determine the block sizes and header values that would result from the following sequence of <code id="P7000497027000000000000000045EFF" data-uri="chapter09.xhtml#P7000497027000000000000000045EFF" class="pcalibre1 calibre8 pcalibre">malloc</code> requests. Assumptions: (1) The allocator maintains double-word alignment and uses an implicit free list with the block format from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000073FC"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.35</span></a>. (2) Block sizes are rounded up to the nearest multiple of 8 bytes.</p>
<table id="P7000497027000000000000000045F00" data-uri="chapter09.xhtml#P7000497027000000000000000045F00" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000045F01" data-uri="chapter09.xhtml#P7000497027000000000000000045F01" class="calibre18 pcalibre pcalibre1">Request</th>
<th id="P7000497027000000000000000045F02" data-uri="chapter09.xhtml#P7000497027000000000000000045F02" class="calibre18 pcalibre pcalibre1">Block size (decimal bytes)</th>
<th id="P7000497027000000000000000045F03" data-uri="chapter09.xhtml#P7000497027000000000000000045F03" class="calibre18 pcalibre pcalibre1">Block header (hex)</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000045F04" data-uri="chapter09.xhtml#P7000497027000000000000000045F04" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000045F05" data-uri="chapter09.xhtml#P7000497027000000000000000045F05" class="calibre10 pcalibre pcalibre1">malloc(1)</code></td>
<td id="P7000497027000000000000000045F06" data-uri="chapter09.xhtml#P7000497027000000000000000045F06" class="calibre20 pcalibre pcalibre1">_____</td>
<td id="P7000497027000000000000000045F07" data-uri="chapter09.xhtml#P7000497027000000000000000045F07" class="calibre20 pcalibre pcalibre1">_____</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000045F08" data-uri="chapter09.xhtml#P7000497027000000000000000045F08" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000045F09" data-uri="chapter09.xhtml#P7000497027000000000000000045F09" class="calibre10 pcalibre pcalibre1">malloc(5)</code></td>
<td id="P7000497027000000000000000045F0A" data-uri="chapter09.xhtml#P7000497027000000000000000045F0A" class="calibre20 pcalibre pcalibre1">_____</td>
<td id="P7000497027000000000000000045F0B" data-uri="chapter09.xhtml#P7000497027000000000000000045F0B" class="calibre20 pcalibre pcalibre1">_____</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000045F0C" data-uri="chapter09.xhtml#P7000497027000000000000000045F0C" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000045F0D" data-uri="chapter09.xhtml#P7000497027000000000000000045F0D" class="calibre10 pcalibre pcalibre1">malloc(12)</code></td>
<td id="P7000497027000000000000000045F0E" data-uri="chapter09.xhtml#P7000497027000000000000000045F0E" class="calibre20 pcalibre pcalibre1">_____</td>
<td id="P7000497027000000000000000045F0F" data-uri="chapter09.xhtml#P7000497027000000000000000045F0F" class="calibre20 pcalibre pcalibre1">_____</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000045F10" data-uri="chapter09.xhtml#P7000497027000000000000000045F10" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000045F11" data-uri="chapter09.xhtml#P7000497027000000000000000045F11" class="calibre10 pcalibre pcalibre1">malloc(13)</code></td>
<td id="P7000497027000000000000000045F12" data-uri="chapter09.xhtml#P7000497027000000000000000045F12" class="calibre20 pcalibre pcalibre1">_____</td>
<td id="P7000497027000000000000000045F13" data-uri="chapter09.xhtml#P7000497027000000000000000045F13" class="calibre20 pcalibre pcalibre1">_____</td>
</tr>
</tbody>
</table>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000007431" data-uri="chapter09.xhtml#P7000497027000000000000000007431" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045F14" data-uri="chapter09.xhtml#P7000497027000000000000000045F14" epub:type="title"><span class="pcalibre label pcalibre1">9.9.7 </span>Placing Allocated Blocks</h1></header>
<p id="P7000497027000000000000000045F15" data-uri="chapter09.xhtml#P7000497027000000000000000045F15" class="pcalibre1 pcalibre calibre2">When an application requests a block of <var class="calibre5 pcalibre pcalibre1">k</var> bytes, the allocator searches the free list for a free block that is large enough to hold the requested block. The manner in which the allocator performs this search is determined by the <i class="calibre5 pcalibre pcalibre1">placement policy.</i> Some common policies are first fit, next fit, and best fit.</p>
<p id="P7000497027000000000000000045F16" data-uri="chapter09.xhtml#P7000497027000000000000000045F16" class="pcalibre1 pcalibre calibre2"><i class="calibre5 pcalibre pcalibre1">First fit</i> searches the free list from the beginning and chooses the first free block that fits. <i class="calibre5 pcalibre pcalibre1">Next fit</i> is similar to first fit, but instead of starting each search at the beginning of the list, it starts each search where the previous search left off. <i class="calibre5 pcalibre pcalibre1">Best fit</i> examines every free block and chooses the free block with the smallest size that fits.</p>
<p id="P7000497027000000000000000045F17" data-uri="chapter09.xhtml#P7000497027000000000000000045F17" class="pcalibre1 pcalibre calibre2">An advantage of first fit is that it tends to retain large free blocks at the end of the list. A disadvantage is that it tends to leave "splinters" of small free blocks toward the beginning of the list, which will increase the search time for larger blocks. Next fit was first proposed by Donald Knuth as an alternative to first fit, motivated by the idea that if we found a fit in some free block the last time, there is a good chance that we will find a fit the next time in the remainder of the block. Next fit can run significantly faster than first fit, especially if the front of the list becomes littered with many small splinters. However, some studies suggest that next fit suffers from worse memory utilization than first fit. Studies have found that best fit generally enjoys better memory utilization than either first fit or next fit. However, the disadvantage of using best fit with simple free list organizations such as the implicit free list is that it requires an exhaustive search of the heap. Later, we will look at more sophisticated segregated free list organizations that approximate a best-fit policy without an exhaustive search of the heap.</p>
</section>
<section id="P7000497027000000000000000007436" data-uri="chapter09.xhtml#P7000497027000000000000000007436" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045F18" data-uri="chapter09.xhtml#P7000497027000000000000000045F18" epub:type="title"><span class="pcalibre label pcalibre1">9.9.8 </span>Splitting Free Blocks</h1></header>
<p id="P7000497027000000000000000045F19" data-uri="chapter09.xhtml#P7000497027000000000000000045F19" class="pcalibre1 pcalibre calibre2">Once the allocator has located a free block that fits, it must make another policy decision about how much of the free block to allocate. One option is to use the entire free block. Although simple and fast, the main disadvantage is that it</p>
<figure id="P7000497027000000000000000007439" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007439">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000743A" title="850" data-uri="chapter09.xhtml#P700049702700000000000000000743A" epub:type="pagebreak"></span>
<img alt="A diagram illustrates splitting a free block to satisfy a three-word allocation request." id="P7000497027000000000000000045F1A" data-uri="P700049702700000000000000000B7A1" src="../images/p850-1.png" class="calibre296 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045F1B" data-uri="chapter09.xhtml#P7000497027000000000000000045F1B" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045F1C" data-uri="chapter09.xhtml#P7000497027000000000000000045F1C" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.37 </span>Splitting a free block to satisfy a three-word allocation request.</h1></header><div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045F1D" data-uri="chapter09.xhtml#P7000497027000000000000000045F1D"><p id="P7000497027000000000000000045F1E" data-uri="chapter09.xhtml#P7000497027000000000000000045F1E" class="pcalibre calibre3 pcalibre1">Allocated blocks are shaded. Free blocks are unshaded. Headers are labeled with (size (bytes)/allocated bit).</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026272" data-uri="chapter09.xhtml#P7000497027000000000000000026272">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045F1F" data-uri="chapter09.xhtml#P7000497027000000000000000045F1F" class="pcalibre1 pcalibre calibre2">A diagram has a row of shaded and unshaded blocks, from start of heap on the left to double-word aligned on the right. Arrows jump between groups of shaded blocks. The blocks are summarized from left to right below.</p>
<ul id="P7000497027000000000000000045F20" data-uri="chapter09.xhtml#P7000497027000000000000000045F20" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045F21" data-uri="chapter09.xhtml#P7000497027000000000000000045F21" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F22" data-uri="chapter09.xhtml#P7000497027000000000000000045F22" class="pcalibre calibre3 pcalibre1">Shaded, labeled unused</p></li>
<li id="P7000497027000000000000000045F23" data-uri="chapter09.xhtml#P7000497027000000000000000045F23" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F24" data-uri="chapter09.xhtml#P7000497027000000000000000045F24" class="pcalibre calibre3 pcalibre1">Two unshaded, first labeled 8/0</p></li>
<li id="P7000497027000000000000000045F25" data-uri="chapter09.xhtml#P7000497027000000000000000045F25" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F26" data-uri="chapter09.xhtml#P7000497027000000000000000045F26" class="pcalibre calibre3 pcalibre1">Four shaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F27" data-uri="chapter09.xhtml#P7000497027000000000000000045F27" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F28" data-uri="chapter09.xhtml#P7000497027000000000000000045F28" class="pcalibre calibre3 pcalibre1">Four shaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F29" data-uri="chapter09.xhtml#P7000497027000000000000000045F29" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F2A" data-uri="chapter09.xhtml#P7000497027000000000000000045F2A" class="pcalibre calibre3 pcalibre1">Four unshaded, first labeled 16/0</p></li>
<li id="P7000497027000000000000000045F2B" data-uri="chapter09.xhtml#P7000497027000000000000000045F2B" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F2C" data-uri="chapter09.xhtml#P7000497027000000000000000045F2C" class="pcalibre calibre3 pcalibre1">Five shaded, first labeled 16/1 and last labeled 0/1</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045F2D" data-uri="chapter09.xhtml#P7000497027000000000000000045F2D">introduces internal fragmentation. If the placement policy tends to produce good fits, then some additional internal fragmentation might be acceptable.</p>
<p id="P7000497027000000000000000045F2E" data-uri="chapter09.xhtml#P7000497027000000000000000045F2E" class="pcalibre1 pcalibre calibre2">However, if the fit is not good, then the allocator will usually opt to <i class="calibre5 pcalibre pcalibre1">split</i> the free block into two parts. The first part becomes the allocated block, and the remainder becomes a new free block. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007439"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.37</span></a> shows how the allocator might split the eight-word free block in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007400"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.36</span></a> to satisfy an application's request for three words of heap memory.</p>
</section>
<section id="P7000497027000000000000000007442" data-uri="chapter09.xhtml#P7000497027000000000000000007442" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045F2F" data-uri="chapter09.xhtml#P7000497027000000000000000045F2F" epub:type="title"><span class="pcalibre label pcalibre1">9.9.9 </span>Getting Additional Heap Memory</h1></header>
<p id="P7000497027000000000000000045F30" data-uri="chapter09.xhtml#P7000497027000000000000000045F30" class="pcalibre1 pcalibre calibre2">What happens if the allocator is unable to find a fit for the requested block? One option is to try to create some larger free blocks by merging (coalescing) free blocks that are physically adjacent in memory (next section). However, if this does not yield a sufficiently large block, or if the free blocks are already maximally coalesced, then the allocator asks the kernel for additional heap memory by calling the <code id="P7000497027000000000000000045F31" data-uri="chapter09.xhtml#P7000497027000000000000000045F31" class="pcalibre1 calibre8 pcalibre">sbrk</code> function. The allocator transforms the additional memory into one large free block, inserts the block into the free list, and then places the requested block in this new free block.</p>
</section>
<section id="P7000497027000000000000000007446" data-uri="chapter09.xhtml#P7000497027000000000000000007446" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045F32" data-uri="chapter09.xhtml#P7000497027000000000000000045F32" epub:type="title"><span class="pcalibre label pcalibre1">9.9.10 </span>Coalescing Free Blocks</h1></header>
<p id="P7000497027000000000000000045F33" data-uri="chapter09.xhtml#P7000497027000000000000000045F33" class="pcalibre1 pcalibre calibre2">When the allocator frees an allocated block, there might be other free blocks that are adjacent to the newly freed block. Such adjacent free blocks can cause a phenomenon known as, <i class="calibre5 pcalibre pcalibre1">false fragmentation</i>, where there is a lot of available free memory chopped up into small, unusable free blocks. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000744A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.38</span></a> shows the result of freeing the block that was allocated in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007439"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.37</span></a>. The result is two adjacent free blocks with payloads of three words each. As a result, a subsequent request for a payload of four words would fail, even though the aggregate size of the two free blocks is large enough to satisfy the request.</p>
<p id="P7000497027000000000000000045F34" data-uri="chapter09.xhtml#P7000497027000000000000000045F34" class="pcalibre1 pcalibre calibre2">To combat false fragmentation, any practical allocator must merge adjacent free blocks in a process known as <i class="calibre5 pcalibre pcalibre1">coalescing.</i> This raises an important policy decision about when to perform coalescing. The allocator can opt for <i class="calibre5 pcalibre pcalibre1">immediate coalescing</i> by merging any adjacent blocks each time a block is freed. Or it can opt for <i class="calibre5 pcalibre pcalibre1">deferred coalescing</i> by waiting to coalesce free blocks at some later time. For example, the allocator might defer coalescing until some allocation request fails, and then scan the entire heap, coalescing all free blocks.</p>
<figure id="P700049702700000000000000000744A" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P700049702700000000000000000744A">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000744B" title="851" data-uri="chapter09.xhtml#P700049702700000000000000000744B" epub:type="pagebreak"></span>
<img alt="A diagram illustrates an example of false fragmentation." id="P7000497027000000000000000045F35" data-uri="P700049702700000000000000000B7A2" src="../images/p851-1.png" class="calibre296 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045F36" data-uri="chapter09.xhtml#P7000497027000000000000000045F36" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045F37" data-uri="chapter09.xhtml#P7000497027000000000000000045F37" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.38 </span>An example of false fragmentation.</h1></header><div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045F38" data-uri="chapter09.xhtml#P7000497027000000000000000045F38"><p id="P7000497027000000000000000045F39" data-uri="chapter09.xhtml#P7000497027000000000000000045F39" class="pcalibre calibre3 pcalibre1">Allocated blocks are shaded. Free blocks are unshaded. Headers are labeled with (size (bytes)/allocated bit).</p></div>
<details class="longdesc pcalibre pcalibre1" id="P700049702700000000000000002628E" data-uri="chapter09.xhtml#P700049702700000000000000002628E">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045F3A" data-uri="chapter09.xhtml#P7000497027000000000000000045F3A" class="pcalibre1 pcalibre calibre2">A diagram has a row of shaded and unshaded blocks, from start of heap on the left to double-word aligned on the right. Arrows jump between groups of blocks. The blocks are summarized from left to right below.</p>
<ul id="P7000497027000000000000000045F3B" data-uri="chapter09.xhtml#P7000497027000000000000000045F3B" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045F3C" data-uri="chapter09.xhtml#P7000497027000000000000000045F3C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F3D" data-uri="chapter09.xhtml#P7000497027000000000000000045F3D" class="pcalibre calibre3 pcalibre1">Shaded, labeled unused</p></li>
<li id="P7000497027000000000000000045F3E" data-uri="chapter09.xhtml#P7000497027000000000000000045F3E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F3F" data-uri="chapter09.xhtml#P7000497027000000000000000045F3F" class="pcalibre calibre3 pcalibre1">Two unshaded, first labeled 8/0</p></li>
<li id="P7000497027000000000000000045F40" data-uri="chapter09.xhtml#P7000497027000000000000000045F40" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F41" data-uri="chapter09.xhtml#P7000497027000000000000000045F41" class="pcalibre calibre3 pcalibre1">Four shaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F42" data-uri="chapter09.xhtml#P7000497027000000000000000045F42" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F43" data-uri="chapter09.xhtml#P7000497027000000000000000045F43" class="pcalibre calibre3 pcalibre1">Four unshaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F44" data-uri="chapter09.xhtml#P7000497027000000000000000045F44" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F45" data-uri="chapter09.xhtml#P7000497027000000000000000045F45" class="pcalibre calibre3 pcalibre1">Four unshaded, the first labeled 16/1</p></li>
<li id="P7000497027000000000000000045F46" data-uri="chapter09.xhtml#P7000497027000000000000000045F46" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F47" data-uri="chapter09.xhtml#P7000497027000000000000000045F47" class="pcalibre calibre3 pcalibre1">Five shaded, first labeled 16/1 and last labeled 0/1</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000045F48" data-uri="chapter09.xhtml#P7000497027000000000000000045F48" class="pcalibre1 pcalibre calibre2">Immediate coalescing is straightforward and can be performed in constant time, but with some request patterns it can introduce a form of thrashing where a block is repeatedly coalesced and then split soon thereafter. For example, in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000744A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.38</span></a>, a repeated pattern of allocating and freeing a three-word block would introduce a lot of unnecessary splitting and coalescing. In our discussion of allocators, we will assume immediate coalescing, but you should be aware that fast allocators often opt for some form of deferred coalescing.</p>
</section>
<section id="P7000497027000000000000000007452" data-uri="chapter09.xhtml#P7000497027000000000000000007452" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045F49" data-uri="chapter09.xhtml#P7000497027000000000000000045F49" epub:type="title"><span class="pcalibre label pcalibre1">9.9.11 </span>Coalescing with Boundary Tags</h1></header>
<p id="P7000497027000000000000000045F4A" data-uri="chapter09.xhtml#P7000497027000000000000000045F4A" class="pcalibre1 pcalibre calibre2">How does an allocator implement coalescing? Let us refer to the block we want to free as the <i class="calibre5 pcalibre pcalibre1">current block.</i> Then coalescing the next free block (in memory) is straightforward and efficient. The header of the current block points to the header of the next block, which can be checked to determine if the next block is free. If so, its size is simply added to the size of the current header and the blocks are coalesced in constant time.</p>
<p id="P7000497027000000000000000045F4B" data-uri="chapter09.xhtml#P7000497027000000000000000045F4B" class="pcalibre1 pcalibre calibre2">But how would we coalesce the previous block? Given an implicit free list of blocks with headers, the only option would be to search the entire list, remembering the location of the previous block, until we reached the current block. With an implicit free list, this means that each call to free would require time linear in the size of the heap. Even with more sophisticated free list organizations, the search time would not be constant.</p>
<p id="P7000497027000000000000000045F4C" data-uri="chapter09.xhtml#P7000497027000000000000000045F4C" class="pcalibre1 pcalibre calibre2">Knuth developed a clever and general technique, known as <i class="calibre5 pcalibre pcalibre1">boundary tags</i>, that allows for constant-time coalescing of the previous block. The idea, which is shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007461"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.39</span></a>, is to add <i class="calibre5 pcalibre pcalibre1">&amp; footer</i> (the boundary tag) at the end of each block, where the footer is a replica of the header. If each block includes such a footer, then the allocator can determine the starting location and status of the previous block by inspecting its footer, which is always one word away from the start of the current block.</p>
<p id="P7000497027000000000000000045F4D" data-uri="chapter09.xhtml#P7000497027000000000000000045F4D" class="pcalibre1 pcalibre calibre2">Consider all the cases that can exist when the allocator frees the current block:</p>
<ol id="P7000497027000000000000000045F4E" data-uri="chapter09.xhtml#P7000497027000000000000000045F4E" class="calibre72 pcalibre pcalibre1">
<li id="P7000497027000000000000000045F4F" data-uri="chapter09.xhtml#P7000497027000000000000000045F4F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F50" data-uri="chapter09.xhtml#P7000497027000000000000000045F50" class="pcalibre calibre3 pcalibre1">The previous and next blocks are both allocated.</p></li>
<li id="P7000497027000000000000000045F51" data-uri="chapter09.xhtml#P7000497027000000000000000045F51" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F52" data-uri="chapter09.xhtml#P7000497027000000000000000045F52" class="pcalibre calibre3 pcalibre1">The previous block is allocated and the next block is free.</p></li>
<li id="P7000497027000000000000000045F53" data-uri="chapter09.xhtml#P7000497027000000000000000045F53" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F54" data-uri="chapter09.xhtml#P7000497027000000000000000045F54" class="pcalibre calibre3 pcalibre1">The previous block is free and the next block is allocated.</p></li>
<li id="P7000497027000000000000000045F55" data-uri="chapter09.xhtml#P7000497027000000000000000045F55" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F56" data-uri="chapter09.xhtml#P7000497027000000000000000045F56" class="pcalibre calibre3 pcalibre1">The previous and next blocks are both free.</p></li>
</ol>
<figure id="P7000497027000000000000000007461" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007461">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007462" title="852" data-uri="chapter09.xhtml#P7000497027000000000000000007462" epub:type="pagebreak"></span>
<img alt="A diagram illustrates the format of a heap block that uses a boundary tab." id="P7000497027000000000000000045F57" data-uri="P700049702700000000000000000B7A3" src="../images/p852-1.png" class="pcalibre1 calibre297 pcalibre"/>
<figcaption id="P7000497027000000000000000045F58" data-uri="chapter09.xhtml#P7000497027000000000000000045F58" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045F59" data-uri="chapter09.xhtml#P7000497027000000000000000045F59" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.39 </span>Format of heap block that uses a boundary tag.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000262AF" data-uri="chapter09.xhtml#P70004970270000000000000000262AF">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045F5A" data-uri="chapter09.xhtml#P7000497027000000000000000045F5A" class="pcalibre1 pcalibre calibre2">A diagram has three sections, each from 31 to 0 bits, from top to bottom as follows:</p>
<ul id="P7000497027000000000000000045F5B" data-uri="chapter09.xhtml#P7000497027000000000000000045F5B" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045F5C" data-uri="chapter09.xhtml#P7000497027000000000000000045F5C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F5D" data-uri="chapter09.xhtml#P7000497027000000000000000045F5D" class="pcalibre calibre3 pcalibre1">Header: Block size from bit 31 to 3, with a/f under bits 2 to 0 (a = 001: Allocated; a = 000: Free)</p></li>
<li id="P7000497027000000000000000045F5E" data-uri="chapter09.xhtml#P7000497027000000000000000045F5E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F5F" data-uri="chapter09.xhtml#P7000497027000000000000000045F5F" class="pcalibre calibre3 pcalibre1">Payload (allocated block only)</p></li>
<li id="P7000497027000000000000000045F60" data-uri="chapter09.xhtml#P7000497027000000000000000045F60" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F61" data-uri="chapter09.xhtml#P7000497027000000000000000045F61" class="pcalibre calibre3 pcalibre1">Padding (optional)</p></li>
<li id="P7000497027000000000000000045F62" data-uri="chapter09.xhtml#P7000497027000000000000000045F62" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F63" data-uri="chapter09.xhtml#P7000497027000000000000000045F63" class="pcalibre calibre3 pcalibre1">Foot: block size from bit 31 to 3, with a/f under bits 2 to 0</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000045F64" data-uri="chapter09.xhtml#P7000497027000000000000000045F64" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007472"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.40</span></a> shows how we would coalesce each of the four cases.</p>
<p id="P7000497027000000000000000045F65" data-uri="chapter09.xhtml#P7000497027000000000000000045F65" class="pcalibre1 pcalibre calibre2">In case 1, both adjacent blocks are allocated and thus no coalescing is possible. So the status of the current block is simply changed from allocated to free. In case 2, the current block is merged with the next block. The header of the current block and the footer of the next block are updated with the combined sizes of the current and next blocks. In case 3, the previous block is merged with the current block. The header of the previous block and the footer of the current block are updated with the combined sizes of the two blocks. In case 4, all three blocks are merged to form a single free block, with the header of the previous block and the footer of the next block updated with the combined sizes of the three blocks. In each case, the coalescing is performed in constant time.</p>
<p id="P7000497027000000000000000045F66" data-uri="chapter09.xhtml#P7000497027000000000000000045F66" class="pcalibre1 pcalibre calibre2">The idea of boundary tags is a simple and elegant one that generalizes to many different types of allocators and free list organizations. However, there is a potential disadvantage. Requiring each block to contain both a header and a footer can introduce significant memory overhead if an application manipulates many small blocks. For example, if a graph application dynamically creates and destroys graph nodes by making repeated calls to <code id="P7000497027000000000000000045F67" data-uri="chapter09.xhtml#P7000497027000000000000000045F67" class="pcalibre1 calibre8 pcalibre">malloc</code> and <code id="P7000497027000000000000000045F68" data-uri="chapter09.xhtml#P7000497027000000000000000045F68" class="pcalibre1 calibre8 pcalibre">free</code>, and each graph node requires only a couple of words of memory, then the header and the footer will consume half of each allocated block.</p>
<p id="P7000497027000000000000000045F69" data-uri="chapter09.xhtml#P7000497027000000000000000045F69" class="pcalibre1 pcalibre calibre2">Fortunately, there is a clever optimization of boundary tags that eliminates the need for a footer in allocated blocks. Recall that when we attempt to coalesce the current block with the previous and next blocks in memory, the size field in the footer of the previous block is only needed if the previous block is <i class="calibre5 pcalibre pcalibre1">free.</i> If we were to store the allocated/free bit of the previous block in one of the excess low-order bits of the current block, then allocated blocks would not need footers, and we could use that extra space for payload. Note, however, that free blocks would still need footers.</p>
<section id="P700049702700000000000000000746C" data-uri="chapter09.xhtml#P700049702700000000000000000746C" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045F6A" data-uri="chapter09.xhtml#P7000497027000000000000000045F6A" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">9.7 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P700049702700000000000000000780C">883</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000045F6B" data-uri="chapter09.xhtml#P7000497027000000000000000045F6B">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000045F6C" data-uri="chapter09.xhtml#P7000497027000000000000000045F6C">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045F6D" data-uri="chapter09.xhtml#P7000497027000000000000000045F6D"><p id="P7000497027000000000000000045F6E" data-uri="chapter09.xhtml#P7000497027000000000000000045F6E" class="pcalibre calibre3 pcalibre1">Determine the minimum block size for each of the following combinations of alignment requirements and block formats. Assumptions: Implicit free list, zero-size payloads are not allowed, and headers and footers are stored in 4-byte words.</p>
<figure id="P7000497027000000000000000007472" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007472">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007473" title="853" data-uri="chapter09.xhtml#P7000497027000000000000000007473" epub:type="pagebreak"></span>
<img alt="A diagram illustrates four cases of coalescing with boundary tags." id="P7000497027000000000000000045F6F" data-uri="P700049702700000000000000000B7A4" src="../images/p853-1.png" class="calibre298 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045F70" data-uri="chapter09.xhtml#P7000497027000000000000000045F70" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045F71" data-uri="chapter09.xhtml#P7000497027000000000000000045F71" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.40 </span>Coalescing with boundary tags.</h1></header><div class="edition pcalibre pcalibre1" id="P7000497027000000000000000045F72" data-uri="chapter09.xhtml#P7000497027000000000000000045F72"><p id="P7000497027000000000000000045F73" data-uri="chapter09.xhtml#P7000497027000000000000000045F73" class="pcalibre calibre3 pcalibre1">Case 1 : prev and next allocated. Case 2: prev allocated, next free. Case 3: prev free, next allocated. Case 4: next and prev free.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000262CA" data-uri="chapter09.xhtml#P70004970270000000000000000262CA">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045F74" data-uri="chapter09.xhtml#P7000497027000000000000000045F74" class="pcalibre calibre3 pcalibre1">A diagram illustrates four cases as heap blocks, beginning with a block with sections summarized below, from top to bottom:</p>
<ul id="P7000497027000000000000000045F75" data-uri="chapter09.xhtml#P7000497027000000000000000045F75" class="calibre79 pcalibre pcalibre1">
<li id="P7000497027000000000000000045F76" data-uri="chapter09.xhtml#P7000497027000000000000000045F76" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F77" data-uri="chapter09.xhtml#P7000497027000000000000000045F77" class="pcalibre calibre3 pcalibre1">M1 and a</p></li>
<li id="P7000497027000000000000000045F78" data-uri="chapter09.xhtml#P7000497027000000000000000045F78" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F79" data-uri="chapter09.xhtml#P7000497027000000000000000045F79" class="pcalibre calibre3 pcalibre1">Blank</p></li>
<li id="P7000497027000000000000000045F7A" data-uri="chapter09.xhtml#P7000497027000000000000000045F7A" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F7B" data-uri="chapter09.xhtml#P7000497027000000000000000045F7B" class="pcalibre calibre3 pcalibre1">M1 and a</p></li>
<li id="P7000497027000000000000000045F7C" data-uri="chapter09.xhtml#P7000497027000000000000000045F7C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F7D" data-uri="chapter09.xhtml#P7000497027000000000000000045F7D" class="pcalibre calibre3 pcalibre1">N and a</p></li>
<li id="P7000497027000000000000000045F7E" data-uri="chapter09.xhtml#P7000497027000000000000000045F7E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F7F" data-uri="chapter09.xhtml#P7000497027000000000000000045F7F" class="pcalibre calibre3 pcalibre1">Blank shaded</p></li>
<li id="P7000497027000000000000000045F80" data-uri="chapter09.xhtml#P7000497027000000000000000045F80" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F81" data-uri="chapter09.xhtml#P7000497027000000000000000045F81" class="pcalibre calibre3 pcalibre1">N and a</p></li>
<li id="P7000497027000000000000000045F82" data-uri="chapter09.xhtml#P7000497027000000000000000045F82" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F83" data-uri="chapter09.xhtml#P7000497027000000000000000045F83" class="pcalibre calibre3 pcalibre1">M2 and a</p></li>
<li id="P7000497027000000000000000045F84" data-uri="chapter09.xhtml#P7000497027000000000000000045F84" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F85" data-uri="chapter09.xhtml#P7000497027000000000000000045F85" class="pcalibre calibre3 pcalibre1">Blank</p></li>
<li id="P7000497027000000000000000045F86" data-uri="chapter09.xhtml#P7000497027000000000000000045F86" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F87" data-uri="chapter09.xhtml#P7000497027000000000000000045F87" class="pcalibre calibre3 pcalibre1">M2 and a</p></li>
</ul>
<p id="P7000497027000000000000000045F88" data-uri="chapter09.xhtml#P7000497027000000000000000045F88" class="pcalibre calibre3 pcalibre1">The changed blocks for each case are summarized below.</p>
<ul id="P7000497027000000000000000045F89" data-uri="chapter09.xhtml#P7000497027000000000000000045F89" class="pcalibre calibre39 pcalibre1">
<li id="P7000497027000000000000000045F8A" data-uri="chapter09.xhtml#P7000497027000000000000000045F8A" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F8B" data-uri="chapter09.xhtml#P7000497027000000000000000045F8B" class="pcalibre calibre3 pcalibre1">Case 1: above and below shaded blank, a is changed to f</p></li>
<li id="P7000497027000000000000000045F8C" data-uri="chapter09.xhtml#P7000497027000000000000000045F8C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F8D" data-uri="chapter09.xhtml#P7000497027000000000000000045F8D" class="pcalibre calibre3 pcalibre1">Case 2: shaded blank now extends down to bottom blank; above and below this blank is n+m2 and f</p></li>
<li id="P7000497027000000000000000045F8E" data-uri="chapter09.xhtml#P7000497027000000000000000045F8E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F8F" data-uri="chapter09.xhtml#P7000497027000000000000000045F8F" class="pcalibre calibre3 pcalibre1">Case 3: shaded blank now extends up to top blank; above and below this blank is n+m1 and f</p></li>
<li id="P7000497027000000000000000045F90" data-uri="chapter09.xhtml#P7000497027000000000000000045F90" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045F91" data-uri="chapter09.xhtml#P7000497027000000000000000045F91" class="pcalibre calibre3 pcalibre1">Case 4: shaded blank now extends between the top and bottom blanks; above and below this blank is n+m1+m2 and f</p></li>
</ul>
</details>
</figcaption>
</figure>
<table id="P7000497027000000000000000045F92" data-uri="chapter09.xhtml#P7000497027000000000000000045F92" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000045F93" data-uri="chapter09.xhtml#P7000497027000000000000000045F93" class="calibre18 pcalibre pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000747B" title="854" data-uri="chapter09.xhtml#P700049702700000000000000000747B" epub:type="pagebreak"></span>Alignment</th>
<th id="P7000497027000000000000000045F94" data-uri="chapter09.xhtml#P7000497027000000000000000045F94" class="calibre18 pcalibre pcalibre1">Allocated block</th>
<th id="P7000497027000000000000000045F95" data-uri="chapter09.xhtml#P7000497027000000000000000045F95" class="calibre18 pcalibre pcalibre1">Free block</th>
<th id="P7000497027000000000000000045F96" data-uri="chapter09.xhtml#P7000497027000000000000000045F96" class="calibre18 pcalibre pcalibre1">Minimum block size (bytes)</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000045F97" data-uri="chapter09.xhtml#P7000497027000000000000000045F97" class="calibre20 pcalibre pcalibre1">Single word</td>
<td id="P7000497027000000000000000045F98" data-uri="chapter09.xhtml#P7000497027000000000000000045F98" class="calibre20 pcalibre pcalibre1">Header and footer</td>
<td id="P7000497027000000000000000045F99" data-uri="chapter09.xhtml#P7000497027000000000000000045F99" class="calibre20 pcalibre pcalibre1">Header and footer</td>
<td id="P7000497027000000000000000045F9A" data-uri="chapter09.xhtml#P7000497027000000000000000045F9A" class="calibre20 pcalibre pcalibre1">_____</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000045F9B" data-uri="chapter09.xhtml#P7000497027000000000000000045F9B" class="calibre20 pcalibre pcalibre1">Single word</td>
<td id="P7000497027000000000000000045F9C" data-uri="chapter09.xhtml#P7000497027000000000000000045F9C" class="calibre20 pcalibre pcalibre1">Header, but no footer</td>
<td id="P7000497027000000000000000045F9D" data-uri="chapter09.xhtml#P7000497027000000000000000045F9D" class="calibre20 pcalibre pcalibre1">Header and footer</td>
<td id="P7000497027000000000000000045F9E" data-uri="chapter09.xhtml#P7000497027000000000000000045F9E" class="calibre20 pcalibre pcalibre1">_____</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000045F9F" data-uri="chapter09.xhtml#P7000497027000000000000000045F9F" class="calibre20 pcalibre pcalibre1">Double word</td>
<td id="P7000497027000000000000000045FA0" data-uri="chapter09.xhtml#P7000497027000000000000000045FA0" class="calibre20 pcalibre pcalibre1">Header and footer</td>
<td id="P7000497027000000000000000045FA1" data-uri="chapter09.xhtml#P7000497027000000000000000045FA1" class="calibre20 pcalibre pcalibre1">Header and footer</td>
<td id="P7000497027000000000000000045FA2" data-uri="chapter09.xhtml#P7000497027000000000000000045FA2" class="calibre20 pcalibre pcalibre1">_____</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000045FA3" data-uri="chapter09.xhtml#P7000497027000000000000000045FA3" class="calibre20 pcalibre pcalibre1">Double word</td>
<td id="P7000497027000000000000000045FA4" data-uri="chapter09.xhtml#P7000497027000000000000000045FA4" class="calibre20 pcalibre pcalibre1">Header, but no footer</td>
<td id="P7000497027000000000000000045FA5" data-uri="chapter09.xhtml#P7000497027000000000000000045FA5" class="calibre20 pcalibre pcalibre1">Header and footer</td>
<td id="P7000497027000000000000000045FA6" data-uri="chapter09.xhtml#P7000497027000000000000000045FA6" class="calibre20 pcalibre pcalibre1">_____</td>
</tr>
</tbody>
</table>
</div></li></ol>
</section>
</section>
<section id="P700049702700000000000000000748F" data-uri="chapter09.xhtml#P700049702700000000000000000748F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045FA7" data-uri="chapter09.xhtml#P7000497027000000000000000045FA7" epub:type="title"><span class="pcalibre label pcalibre1">9.9.12 </span>Putting It Together: Implementing a Simple Allocator</h1></header>
<p id="P7000497027000000000000000045FA8" data-uri="chapter09.xhtml#P7000497027000000000000000045FA8" class="pcalibre1 pcalibre calibre2">Building an allocator is a challenging task. The design space is large, with numerous alternatives for block format and free list format, as well as placement, splitting, and coalescing policies. Another challenge is that you are often forced to program outside the safe, familiar confines of the type system, relying on the error-prone pointer casting and pointer arithmetic that is typical of low-level systems programming.</p>
<p id="P7000497027000000000000000045FA9" data-uri="chapter09.xhtml#P7000497027000000000000000045FA9" class="pcalibre1 pcalibre calibre2">While allocators do not require enormous amounts of code, they are subtle and unforgiving. Students familiar with higher-level languages such as C++ or Java often hit a conceptual wall when they first encounter this style of programming. To help you clear this hurdle, we will work through the implementation of a simple allocator based on an implicit free list with immediate boundary-tag coalescing. The maximum block size is 2<sup class="calibre51 pcalibre pcalibre1">32</sup> = 4 GB. The code is 64-bit clean, running without modification in 32-bit (<code id="P7000497027000000000000000045FAA" data-uri="chapter09.xhtml#P7000497027000000000000000045FAA" class="pcalibre1 calibre8 pcalibre">gcc -m32</code>) or 64-bit (<code id="P7000497027000000000000000045FAB" data-uri="chapter09.xhtml#P7000497027000000000000000045FAB" class="pcalibre1 calibre8 pcalibre">gcc -m64</code>) processes.</p>
<section id="P7000497027000000000000000007495" data-uri="chapter09.xhtml#P7000497027000000000000000007495" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045FAC" data-uri="chapter09.xhtml#P7000497027000000000000000045FAC" epub:type="title">General Allocator Design</h1></header>
<p id="P7000497027000000000000000045FAD" data-uri="chapter09.xhtml#P7000497027000000000000000045FAD" class="pcalibre1 pcalibre calibre2">Our allocator uses a model of the memory system provided by the <code id="P7000497027000000000000000045FAE" data-uri="chapter09.xhtml#P7000497027000000000000000045FAE" class="pcalibre1 calibre8 pcalibre">memlib.c</code> package shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000074A9"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.41</span></a>. The purpose of the model is to allow us to run our allocator without interfering with the existing system-level <code id="P7000497027000000000000000045FAF" data-uri="chapter09.xhtml#P7000497027000000000000000045FAF" class="pcalibre1 calibre8 pcalibre">malloc</code> package.</p>
<p id="P7000497027000000000000000045FB0" data-uri="chapter09.xhtml#P7000497027000000000000000045FB0" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045FB1" data-uri="chapter09.xhtml#P7000497027000000000000000045FB1" class="pcalibre1 calibre8 pcalibre">mem_init</code> function models the virtual memory available to the heap as a large double-word aligned array of bytes. The bytes between <code id="P7000497027000000000000000045FB2" data-uri="chapter09.xhtml#P7000497027000000000000000045FB2" class="pcalibre1 calibre8 pcalibre">mem_heap</code> and <code id="P7000497027000000000000000045FB3" data-uri="chapter09.xhtml#P7000497027000000000000000045FB3" class="pcalibre1 calibre8 pcalibre">mem_brk</code> represent allocated virtual memory. The bytes following <code id="P7000497027000000000000000045FB4" data-uri="chapter09.xhtml#P7000497027000000000000000045FB4" class="pcalibre1 calibre8 pcalibre">mem_brk</code> represent unallocated virtual memory. The allocator requests additional heap memory by calling the <code id="P7000497027000000000000000045FB5" data-uri="chapter09.xhtml#P7000497027000000000000000045FB5" class="pcalibre1 calibre8 pcalibre">mem_sbrk</code> function, which has the same interface as the system's <code id="P7000497027000000000000000045FB6" data-uri="chapter09.xhtml#P7000497027000000000000000045FB6" class="pcalibre1 calibre8 pcalibre">sbrk</code> function, as well as the same semantics, except that it rejects requests to shrink the heap.</p>
<p id="P7000497027000000000000000045FB7" data-uri="chapter09.xhtml#P7000497027000000000000000045FB7" class="pcalibre1 pcalibre calibre2">The allocator itself is contained in a source file (<code id="P7000497027000000000000000045FB8" data-uri="chapter09.xhtml#P7000497027000000000000000045FB8" class="pcalibre1 calibre8 pcalibre">mm. c</code>) that users can compile and link into their applications. The allocator exports three functions to application programs:</p>
<pre id="P7000497027000000000000000045FB9" data-uri="chapter09.xhtml#P7000497027000000000000000045FB9" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045FBA" data-uri="chapter09.xhtml#P7000497027000000000000000045FBA" class="calibre10 pcalibre pcalibre1">
1	extern int mm_init(void);
2	extern void *mm_malloc (size_t size);
3	extern void mm_free (void *ptr);
</code></pre>
<p id="P7000497027000000000000000045FBB" data-uri="chapter09.xhtml#P7000497027000000000000000045FBB" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045FBC" data-uri="chapter09.xhtml#P7000497027000000000000000045FBC" class="pcalibre1 calibre8 pcalibre">mm_init</code> function initializes the allocator, returning 0 if successful and –1 otherwise. The <code id="P7000497027000000000000000045FBD" data-uri="chapter09.xhtml#P7000497027000000000000000045FBD" class="pcalibre1 calibre8 pcalibre">mm_malloc</code> and <code id="P7000497027000000000000000045FBE" data-uri="chapter09.xhtml#P7000497027000000000000000045FBE" class="pcalibre1 calibre8 pcalibre">mm_free</code> functions have the same interfaces and semantics as their system counterparts. The allocator uses the block format</p>
<figure id="P70004970270000000000000000074A9" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000074A9">
<p id="P7000497027000000000000000045FBF" data-uri="chapter09.xhtml#P7000497027000000000000000045FBF" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000074AB" title="855" data-uri="chapter09.xhtml#P70004970270000000000000000074AB" epub:type="pagebreak"></span>_______________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/memlib.c</i></p>
<pre id="P7000497027000000000000000045FC0" data-uri="chapter09.xhtml#P7000497027000000000000000045FC0" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045FC1" data-uri="chapter09.xhtml#P7000497027000000000000000045FC1" class="calibre10 pcalibre pcalibre1">

1	/* Private global variables */
2	static char *mem_heap;		/* Points to first byte of heap */
3	static char *mem_brk;		/* Points to last byte of heap plus 1 */
4	static char *mem_max_addr;	/* Max legal heap addr plus 1*/
5	
6	/*
7	* mem_init - Initialize the memory system model
8	*/
9	void mem_init(void)
10	{
11		mem_heap = (char *)Malloc(MAX_HEAP);
12		mem_brk = (char *)mem_heap;
13		mem_max_addr = (char *)(mem_heap + MAX_HEAP);
14	}
15	
16	/*
17	* mem_sbrk - Simple model of the sbrk function. Extends the heap
18	*	by incr bytes and returns the start address of the new area. In
19	*	this model, the heap cannot be shrunk.
20	*/
21	void *mem_sbrk(int incr)
22	{
23		char *old_brk = mem_brk;
24	
25		if ( (incr &lt; 0)|| ((mem_brk + incr) &gt; mem_max_addr)) {
26			errno = ENOMEM;
27			fprintf(stderr, "ERROR: mem_sbrk failed. Ran out of memory...\n");
28			return (void *)–1l;
29		}
30		mem_brk += incr;
31		return (void *)old_brk;
32	}
</code></pre>
<p id="P7000497027000000000000000045FC2" data-uri="chapter09.xhtml#P7000497027000000000000000045FC2" class="pcalibre1 pcalibre calibre2">___________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/memlib.c</i></p>
<figcaption id="P7000497027000000000000000045FC3" data-uri="chapter09.xhtml#P7000497027000000000000000045FC3" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045FC4" data-uri="chapter09.xhtml#P7000497027000000000000000045FC4" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.41 </span><code id="P7000497027000000000000000045FC5" data-uri="chapter09.xhtml#P7000497027000000000000000045FC5" class="pcalibre1 calibre8 pcalibre">memlib. c</code>: Memory system model.</h1></header></figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045FC6" data-uri="chapter09.xhtml#P7000497027000000000000000045FC6">shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007461"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.39</span></a>. The minimum block size is 16 bytes. The free list is organized as an implicit free list, with the invariant form shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000074B6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.42</span></a>.</p>
<p id="P7000497027000000000000000045FC7" data-uri="chapter09.xhtml#P7000497027000000000000000045FC7" class="pcalibre1 pcalibre calibre2">The first word is an unused padding word aligned to a double-word boundary. The padding is followed by a special <i class="calibre5 pcalibre pcalibre1">prologue block</i>, which is an 8-byte allocated block consisting of only a header and a footer. The prologue block is created during initialization and is never freed. Following the prologue block are zero or more regular blocks that are created by calls to <code id="P7000497027000000000000000045FC8" data-uri="chapter09.xhtml#P7000497027000000000000000045FC8" class="pcalibre1 calibre8 pcalibre">malloc</code> or <code id="P7000497027000000000000000045FC9" data-uri="chapter09.xhtml#P7000497027000000000000000045FC9" class="pcalibre1 calibre8 pcalibre">free</code>. The heap always ends with a special <i class="calibre5 pcalibre pcalibre1">epilogue block</i>, which is a zero-size allocated block</p>
<figure id="P70004970270000000000000000074B6" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000074B6">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000074B7" title="856" data-uri="chapter09.xhtml#P70004970270000000000000000074B7" epub:type="pagebreak"></span>
<img alt="A diagram illustrates an invarian t form of the implicit free list." id="P7000497027000000000000000045FCA" data-uri="P700049702700000000000000000B7A5" src="../images/p856-1.png" class="calibre299 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000045FCB" data-uri="chapter09.xhtml#P7000497027000000000000000045FCB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045FCC" data-uri="chapter09.xhtml#P7000497027000000000000000045FCC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.42 </span>Invariant form of the implicit free list.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026324" data-uri="chapter09.xhtml#P7000497027000000000000000026324">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000045FCD" data-uri="chapter09.xhtml#P7000497027000000000000000045FCD" class="pcalibre1 pcalibre calibre2">A diagram has a row of shaded and unshaded blocks, from start of heap on the left to double-word aligned on the right, as summarized below.</p>
<ul id="P7000497027000000000000000045FCE" data-uri="chapter09.xhtml#P7000497027000000000000000045FCE" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000045FCF" data-uri="chapter09.xhtml#P7000497027000000000000000045FCF" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045FD0" data-uri="chapter09.xhtml#P7000497027000000000000000045FD0" class="pcalibre calibre3 pcalibre1">Three shaded blocks, beginning at static, the second two each labeled 8/1, together representing prologue block with char *heap_listp between.</p></li>
<li id="P7000497027000000000000000045FD1" data-uri="chapter09.xhtml#P7000497027000000000000000045FD1" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045FD2" data-uri="chapter09.xhtml#P7000497027000000000000000045FD2" class="pcalibre calibre3 pcalibre1">Three unshaded, together as regular block 1, the first containing hdr and the third ftr</p></li>
<li id="P7000497027000000000000000045FD3" data-uri="chapter09.xhtml#P7000497027000000000000000045FD3" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045FD4" data-uri="chapter09.xhtml#P7000497027000000000000000045FD4" class="pcalibre calibre3 pcalibre1">Three unshaded, together as regular block 2, the first containing hdr and the third ftr</p></li>
<li id="P7000497027000000000000000045FD5" data-uri="chapter09.xhtml#P7000497027000000000000000045FD5" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045FD6" data-uri="chapter09.xhtml#P7000497027000000000000000045FD6" class="pcalibre calibre3 pcalibre1">…</p></li>
<li id="P7000497027000000000000000045FD7" data-uri="chapter09.xhtml#P7000497027000000000000000045FD7" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045FD8" data-uri="chapter09.xhtml#P7000497027000000000000000045FD8" class="pcalibre calibre3 pcalibre1">Three unshaded, together as regular block n, the first containing hdr and the third ftr</p></li>
<li id="P7000497027000000000000000045FD9" data-uri="chapter09.xhtml#P7000497027000000000000000045FD9" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045FDA" data-uri="chapter09.xhtml#P7000497027000000000000000045FDA" class="pcalibre calibre3 pcalibre1">One shaded as epilogue block hdr, containing 0/1</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045FDB" data-uri="chapter09.xhtml#P7000497027000000000000000045FDB">that consists of only a header. The prologue and epilogue blocks are tricks that eliminate the edge conditions during coalescing. The allocator uses a single private (<code id="P7000497027000000000000000045FDC" data-uri="chapter09.xhtml#P7000497027000000000000000045FDC" class="pcalibre1 calibre8 pcalibre">static</code>) global variable (<code id="P7000497027000000000000000045FDD" data-uri="chapter09.xhtml#P7000497027000000000000000045FDD" class="pcalibre1 calibre8 pcalibre">heap_listp</code>) that always points to the prologue block. (As a minor optimization, we could make it point to the next block instead of the prologue block.)</p>
</section>
<section id="P70004970270000000000000000074BE" data-uri="chapter09.xhtml#P70004970270000000000000000074BE" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045FDE" data-uri="chapter09.xhtml#P7000497027000000000000000045FDE" epub:type="title">Basic Constants and Macros for Manipulating the Free List</h1></header>
<p id="P7000497027000000000000000045FDF" data-uri="chapter09.xhtml#P7000497027000000000000000045FDF" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000074D0"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.43</span></a> shows some basic constants and macros that we will use throughout the allocator code. Lines 2–4 define some basic size constants: the sizes of words (WSIZE) and double words (DSIZE), and the size of the initial free block and the default size for expanding the heap (CHUNKSIZE).</p>
<p id="P7000497027000000000000000045FE0" data-uri="chapter09.xhtml#P7000497027000000000000000045FE0" class="pcalibre1 pcalibre calibre2">Manipulating the headers and footers in the free list can be troublesome because it demands extensive use of casting and pointer arithmetic. Thus, we find it helpful to define a small set of macros for accessing and traversing the free list (lines 9–25). The PACK macro (line 9) combines a size and an allocate bit and returns a value that can be stored in a header or footer.</p>
<p id="P7000497027000000000000000045FE1" data-uri="chapter09.xhtml#P7000497027000000000000000045FE1" class="pcalibre1 pcalibre calibre2">The GET macro (line 12) reads and returns the word referenced by argument <code id="P7000497027000000000000000045FE2" data-uri="chapter09.xhtml#P7000497027000000000000000045FE2" class="pcalibre1 calibre8 pcalibre">p</code>. The casting here is crucial. The argument <code id="P7000497027000000000000000045FE3" data-uri="chapter09.xhtml#P7000497027000000000000000045FE3" class="pcalibre1 calibre8 pcalibre">p</code> is typically a (<code id="P7000497027000000000000000045FE4" data-uri="chapter09.xhtml#P7000497027000000000000000045FE4" class="pcalibre1 calibre8 pcalibre">void *</code>) pointer, which cannot be dereferenced directly. Similarly, the PUT macro (line 13) stores <code id="P7000497027000000000000000045FE5" data-uri="chapter09.xhtml#P7000497027000000000000000045FE5" class="pcalibre1 calibre8 pcalibre">val</code> in the word pointed at by argument <code id="P7000497027000000000000000045FE6" data-uri="chapter09.xhtml#P7000497027000000000000000045FE6" class="pcalibre1 calibre8 pcalibre">p</code>.</p>
<p id="P7000497027000000000000000045FE7" data-uri="chapter09.xhtml#P7000497027000000000000000045FE7" class="pcalibre1 pcalibre calibre2">The GET_SIZE and GET_ALLOC macros (lines 16–17) return the size and allocated bit, respectively, from a header or footer at address <code id="P7000497027000000000000000045FE8" data-uri="chapter09.xhtml#P7000497027000000000000000045FE8" class="pcalibre1 calibre8 pcalibre">p</code>. The remaining macros operate on <i class="calibre5 pcalibre pcalibre1">block pointers</i> (denoted <code id="P7000497027000000000000000045FE9" data-uri="chapter09.xhtml#P7000497027000000000000000045FE9" class="pcalibre1 calibre8 pcalibre">bp</code>) that point to the first payload byte. Given a block pointer <code id="P7000497027000000000000000045FEA" data-uri="chapter09.xhtml#P7000497027000000000000000045FEA" class="pcalibre1 calibre8 pcalibre">bp</code>, the HDRP and FTRP macros (lines 20–21) return pointers to the block header and footer, respectively. The NEXT_BLKP and PREV_BLKP macros (lines 24–25) return the block pointers of the next and previous blocks, respectively.</p>
<p id="P7000497027000000000000000045FEB" data-uri="chapter09.xhtml#P7000497027000000000000000045FEB" class="pcalibre1 pcalibre calibre2">The macros can be composed in various ways to manipulate the free list. For example, given a pointer <code id="P7000497027000000000000000045FEC" data-uri="chapter09.xhtml#P7000497027000000000000000045FEC" class="pcalibre1 calibre8 pcalibre">bp</code> to the current block, we could use the following line of code to determine the size of the next block in memory:</p>
<pre id="P7000497027000000000000000045FED" data-uri="chapter09.xhtml#P7000497027000000000000000045FED" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045FEE" data-uri="chapter09.xhtml#P7000497027000000000000000045FEE" class="calibre10 pcalibre pcalibre1">
size_t size = GET_SIZE(HDRP(NEXT_BLKP(bp)));
</code></pre>
<figure id="P70004970270000000000000000074D0" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000074D0">
<p id="P7000497027000000000000000045FEF" data-uri="chapter09.xhtml#P7000497027000000000000000045FEF" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000074D2" title="857" data-uri="chapter09.xhtml#P70004970270000000000000000074D2" epub:type="pagebreak"></span>_________________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000045FF0" data-uri="chapter09.xhtml#P7000497027000000000000000045FF0" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045FF1" data-uri="chapter09.xhtml#P7000497027000000000000000045FF1" class="calibre10 pcalibre pcalibre1">
1	/* Basic constants and macros */
2	#define WSIZE	4	 /* Word and header/footer size (bytes) */
3	#define DSIZE	8	/* Double word size (bytes) */
4	#define CHUNKSIZE (1&lt;&lt;12) /* Extend heap by this amount (bytes) */
5	
6	#define MAX(x, y) ((x) &gt; (y)? (x) : (y))
7	
8	/* Pack a size and allocated bit into a word */
9	#define PACK(size, alloc) ((size)	|	(alloc))
10	
11	/* Read and write a word at address p */
12	#define GET(p)	(* (unsigned int *)(p))
13	#define PUT(p, val)		(*(unsigned int *)(p) = (val))
14	
15	/* Read the size and allocated fields from address p */
16	#define GET_SIZE(p)	(GET(p) &amp; ~0x7)
17	#define GET_ALL0C(p)	(GET(p) &amp; 0x1)
18	
19	/* Given block ptr bp, compute address of its header and footer */
20	#define HDRP(bp)	((char *) (bp) - WSIZE)
21	#define FTRP(bp)	((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
22	
23	/* Given block ptr bp, compute address of next and previous blocks */
24	#define NEXT_BLKP(bp)	((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))
25	#define PREV_BLKP(bp)	((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))
</code></pre>
<p id="P7000497027000000000000000045FF2" data-uri="chapter09.xhtml#P7000497027000000000000000045FF2" class="pcalibre1 pcalibre calibre2">________________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P7000497027000000000000000045FF3" data-uri="chapter09.xhtml#P7000497027000000000000000045FF3" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045FF4" data-uri="chapter09.xhtml#P7000497027000000000000000045FF4" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.43 </span>Basic constants and macros for manipulating the free list.</h1></header></figcaption>
</figure>
</section>
<section id="P70004970270000000000000000074D8" data-uri="chapter09.xhtml#P70004970270000000000000000074D8" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045FF5" data-uri="chapter09.xhtml#P7000497027000000000000000045FF5" epub:type="title">Creating the Initial Free List</h1></header>
<p id="P7000497027000000000000000045FF6" data-uri="chapter09.xhtml#P7000497027000000000000000045FF6" class="pcalibre1 pcalibre calibre2">Before calling <code id="P7000497027000000000000000045FF7" data-uri="chapter09.xhtml#P7000497027000000000000000045FF7" class="pcalibre1 calibre8 pcalibre">mm_malloc</code> or <code id="P7000497027000000000000000045FF8" data-uri="chapter09.xhtml#P7000497027000000000000000045FF8" class="pcalibre1 calibre8 pcalibre">mm_free</code>, the application must initialize the heap by calling the <code id="P7000497027000000000000000045FF9" data-uri="chapter09.xhtml#P7000497027000000000000000045FF9" class="pcalibre1 calibre8 pcalibre">mm_init</code> function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000074E5"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.44</span></a>).</p>
<p id="P7000497027000000000000000045FFA" data-uri="chapter09.xhtml#P7000497027000000000000000045FFA" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045FFB" data-uri="chapter09.xhtml#P7000497027000000000000000045FFB" class="pcalibre1 calibre8 pcalibre">mm_init</code> function gets four words from the memory system and initializes them to create the empty free list (lines 4–10). It then calls the <code id="P7000497027000000000000000045FFC" data-uri="chapter09.xhtml#P7000497027000000000000000045FFC" class="pcalibre1 calibre8 pcalibre">extend_heap</code> function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000074EE"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.45</span></a>), which extends the heap by CHUNKSIZE bytes and creates the initial free block. At this point, the allocator is initialized and ready to accept allocate and free requests from the application.</p>
<p id="P7000497027000000000000000045FFD" data-uri="chapter09.xhtml#P7000497027000000000000000045FFD" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045FFE" data-uri="chapter09.xhtml#P7000497027000000000000000045FFE" class="pcalibre1 calibre8 pcalibre">extend_heap</code> function is invoked in two different circumstances: (1) when the heap is initialized and (2) when <code id="P7000497027000000000000000045FFF" data-uri="chapter09.xhtml#P7000497027000000000000000045FFF" class="pcalibre1 calibre8 pcalibre">mm_malloc</code> is unable to find a suitable fit. To maintain alignment, <code id="P7000497027000000000000000046000" data-uri="chapter09.xhtml#P7000497027000000000000000046000" class="pcalibre1 calibre8 pcalibre">extend_heap</code> rounds up the requested size to the nearest</p>
<figure id="P70004970270000000000000000074E5" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000074E5">
<p id="P7000497027000000000000000046001" data-uri="chapter09.xhtml#P7000497027000000000000000046001" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000074E7" title="858" data-uri="chapter09.xhtml#P70004970270000000000000000074E7" epub:type="pagebreak"></span>_________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000046002" data-uri="chapter09.xhtml#P7000497027000000000000000046002" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046003" data-uri="chapter09.xhtml#P7000497027000000000000000046003" class="calibre10 pcalibre pcalibre1">
1	int mm_init(void)
2	{
3		/* Create the initial empty heap */
4		if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)–1)
5			return –1;
6		PUT(heap_listp, 0);				/* Alignment padding */
7		PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1));	/* Prologue header */
8		PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1));	/* Prologue footer */
9		PUT(heap_listp + (3*WSIZE), PACK(0, 1));	/* Epilogue header */
10		heap_listp += (2*WSIZE);
11	
12		/* Extend the empty heap with a free block of CHUMSIZE bytes */
13		if (extend_heap(CHUMSIZE/WSIZE) == NULL)
14			return –1;
15		return 0;
16	}
</code></pre>
<p id="P7000497027000000000000000046004" data-uri="chapter09.xhtml#P7000497027000000000000000046004" class="pcalibre1 pcalibre calibre2">_______________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P7000497027000000000000000046005" data-uri="chapter09.xhtml#P7000497027000000000000000046005" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046006" data-uri="chapter09.xhtml#P7000497027000000000000000046006" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.44 </span><code id="P7000497027000000000000000046007" data-uri="chapter09.xhtml#P7000497027000000000000000046007" class="pcalibre1 calibre8 pcalibre">mm_init</code> creates a heap with an initial free block.</h1></header></figcaption>
</figure>
<figure id="P70004970270000000000000000074EE" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P70004970270000000000000000074EE">
<p id="P7000497027000000000000000046008" data-uri="chapter09.xhtml#P7000497027000000000000000046008" class="pcalibre1 pcalibre calibre2">____________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000046009" data-uri="chapter09.xhtml#P7000497027000000000000000046009" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004600A" data-uri="chapter09.xhtml#P700049702700000000000000004600A" class="calibre10 pcalibre pcalibre1">
1	static void *extend_heap(size_t words)
2	{
3		char *bp;
4		size_t size;
5	
6		/* Allocate an even number of words to maintain alignment */
7		size = (words % 2) ? (words+1) * WSIZE : words * WSIZE;
8		if ((long)(bp = mem_sbrk(size)) == –1)
9			return NULL;
10	
11		/* Initialize free block header/footer and the epilogue header */
12		PUT(HDRP(bp), PACK(size, 0));		/* Free block header */
13		PUT(FTRP(bp), PACK(size, 0));		/* Free block footer */
14		PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));	/* New epilogue header */
15	
16		/* Coalesce if the previous block was free */
17		return coalesce(bp);
18	}
</code></pre>
<p id="P700049702700000000000000004600B" data-uri="chapter09.xhtml#P700049702700000000000000004600B" class="pcalibre1 pcalibre calibre2">_______________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P700049702700000000000000004600C" data-uri="chapter09.xhtml#P700049702700000000000000004600C" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004600D" data-uri="chapter09.xhtml#P700049702700000000000000004600D" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.45 </span><code id="P700049702700000000000000004600E" data-uri="chapter09.xhtml#P700049702700000000000000004600E" class="pcalibre1 calibre8 pcalibre">extend_heap</code> extends the heap with a new free block.</h1></header></figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004600F" data-uri="chapter09.xhtml#P700049702700000000000000004600F"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000074F7" title="859" data-uri="chapter09.xhtml#P70004970270000000000000000074F7" epub:type="pagebreak"></span>multiple of 2 words (8 bytes) and then requests the additional heap space from the memory system (lines 7–9).</p>
<p id="P7000497027000000000000000046010" data-uri="chapter09.xhtml#P7000497027000000000000000046010" class="pcalibre1 pcalibre calibre2">The remainder of the <code id="P7000497027000000000000000046011" data-uri="chapter09.xhtml#P7000497027000000000000000046011" class="pcalibre1 calibre8 pcalibre">extend_heap</code> function (lines 12–17) is somewhat subtle. The heap begins on a double-word aligned boundary, and every call to <code id="P7000497027000000000000000046012" data-uri="chapter09.xhtml#P7000497027000000000000000046012" class="pcalibre1 calibre8 pcalibre">extend_heap</code> returns a block whose size is an integral number of double words. Thus, every call to <code id="P7000497027000000000000000046013" data-uri="chapter09.xhtml#P7000497027000000000000000046013" class="pcalibre1 calibre8 pcalibre">mem_sbrk</code> returns a double-word aligned chunk of memory immediately following the header of the epilogue block. This header becomes the header of the new free block (line 12), and the last word of the chunk becomes the new epilogue block header (line 14). Finally, in the likely case that the previous heap was terminated by a free block, we call the coalesce function to merge the two free blocks and return the block pointer of the merged blocks (line 17).</p>
</section>
<section id="P70004970270000000000000000074FC" data-uri="chapter09.xhtml#P70004970270000000000000000074FC" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046014" data-uri="chapter09.xhtml#P7000497027000000000000000046014" epub:type="title">Freeing and Coalescing Blocks</h1></header>
<p id="P7000497027000000000000000046015" data-uri="chapter09.xhtml#P7000497027000000000000000046015" class="pcalibre1 pcalibre calibre2">An application frees a previously allocated block by calling the <code id="P7000497027000000000000000046016" data-uri="chapter09.xhtml#P7000497027000000000000000046016" class="pcalibre1 calibre8 pcalibre">mm_free</code> function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007509"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.46</span></a>), which frees the requested block (<code id="P7000497027000000000000000046017" data-uri="chapter09.xhtml#P7000497027000000000000000046017" class="pcalibre1 calibre8 pcalibre">bp</code>) and then merges adjacent free blocks using the boundary-tags coalescing technique described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007452"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">9.9.11</span></a>.</p>
<p id="P7000497027000000000000000046018" data-uri="chapter09.xhtml#P7000497027000000000000000046018" class="pcalibre1 pcalibre calibre2">The code in the coalesce helper function is a straightforward implementation of the four cases outlined in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007472"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.40</span></a>. There is one somewhat subtle aspect. The free list format we have chosen—with its prologue and epilogue blocks that are always marked as allocated—allows us to ignore the potentially troublesome edge conditions where the requested block <code id="P7000497027000000000000000046019" data-uri="chapter09.xhtml#P7000497027000000000000000046019" class="pcalibre1 calibre8 pcalibre">bp</code> is at the beginning or end of the heap. Without these special blocks, the code would be messier, more error prone, and slower because we would have to check for these rare edge conditions on each and every free request.</p>
</section>
<section id="P7000497027000000000000000007503" data-uri="chapter09.xhtml#P7000497027000000000000000007503" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004601A" data-uri="chapter09.xhtml#P700049702700000000000000004601A" epub:type="title">Allocating Blocks</h1></header>
<p id="P700049702700000000000000004601B" data-uri="chapter09.xhtml#P700049702700000000000000004601B" class="pcalibre1 pcalibre calibre2">An application requests a block of size bytes of memory by calling the <code id="P700049702700000000000000004601C" data-uri="chapter09.xhtml#P700049702700000000000000004601C" class="pcalibre1 calibre8 pcalibre">mm_malloc</code> function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007512"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.47</span></a>). After checking for spurious requests, the allocator must adjust the requested block size to allow room for the header and the footer, and to satisfy the double-word alignment requirement. Lines 12–13 enforce the minimum block size of 16 bytes: 8 bytes to satisfy the alignment requirement and 8 more bytes for the overhead of the header and footer. For requests over 8 bytes (line 15), the general rule is to add in the overhead bytes and then round up to the nearest multiple of 8.</p>
<p id="P700049702700000000000000004601D" data-uri="chapter09.xhtml#P700049702700000000000000004601D" class="pcalibre1 pcalibre calibre2">Once the allocator has adjusted the requested size, it searches the free list for a suitable free block (line 18). If there is a fit, then the allocator places the requested block and optionally splits the excess (line 19) and then returns the address of the newly allocated block.</p>
<p id="P700049702700000000000000004601E" data-uri="chapter09.xhtml#P700049702700000000000000004601E" class="pcalibre1 pcalibre calibre2">If the allocator cannot find a fit, it extends the heap with a new free block (lines 24–26), places the requested block in the new free block, optionally splitting the block (line 27), and then returns a pointer to the newly allocated block.</p>
<figure id="P7000497027000000000000000007509" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007509">
<p id="P700049702700000000000000004601F" data-uri="chapter09.xhtml#P700049702700000000000000004601F" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000750B" title="860" data-uri="chapter09.xhtml#P700049702700000000000000000750B" epub:type="pagebreak"></span>______________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000046020" data-uri="chapter09.xhtml#P7000497027000000000000000046020" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046021" data-uri="chapter09.xhtml#P7000497027000000000000000046021" class="calibre10 pcalibre pcalibre1">
1	void mm_free(void *bp)
2	{
3		size_t size = GET_SIZE(HDRP(bp));
4	
5		PUT(HDRP(bp), PACKCsize, 0));
6		PUT(FTRPCbp), PACKCsize, 0));
7		coalesce(bp);
8	}
9	
10	static void *coalesce(void *bp)
11	{
12		size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
13		size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
14		size_t size = GET_SIZE(HDRP(bp));
15	
16		if (prev_alloc &amp;&amp; next_alloc) {			/* Case 1 */
17			return bp;
18		}
19	
20		else if (prev_alloc &amp;&amp; !next_alloc) {		/* Case 2 */
21			size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
22			PUT(HDRP(bp), PACK(size, 0));
23			PUT (FTRP(bp), PACK(size,0));
24		}
25	
26		else if (!prev_alloc &amp;&amp; next_alloc) {		/* Case 3 */
27			size += GET_SIZE(HDRP(PREV_BLKP(bp)));
28			PUT(FTRPCbp), PACKCsize, 0));
29			PUT(HDRP(PREV_BLKP(bp)), PACKCsize, 0));
30			bp = PREV_BLKP(bp);
31		}
32	
33		else {						/* Case 4 */
34			size += GET_SIZE(HDRP(PREV_BLKP(bp))) +
35				GET_SIZE(FTRP(NEXT_BLKP(bp)));
36			PUT(HDRP(PREV_BLKP(bp)), PACKCsize, 0));
37			PUT(FTRP(NEXT_BLKP(bp)), PACKCsize, 0));
38			bp = PREV_BLKP(bp);
39		}
40		return bp;
41	}
</code></pre>
<p id="P7000497027000000000000000046022" data-uri="chapter09.xhtml#P7000497027000000000000000046022" class="pcalibre1 pcalibre calibre2">__________________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P7000497027000000000000000046023" data-uri="chapter09.xhtml#P7000497027000000000000000046023" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046024" data-uri="chapter09.xhtml#P7000497027000000000000000046024" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.46 </span><code id="P7000497027000000000000000046025" data-uri="chapter09.xhtml#P7000497027000000000000000046025" class="pcalibre1 calibre8 pcalibre">mm_free</code> frees a block and uses boundary-tag coalescing to merge it with any adjacent free blocks in constant time.</h1></header></figcaption>
</figure>
<figure id="P7000497027000000000000000007512" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007512">
<p id="P7000497027000000000000000046026" data-uri="chapter09.xhtml#P7000497027000000000000000046026" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007514" title="861" data-uri="chapter09.xhtml#P7000497027000000000000000007514" epub:type="pagebreak"></span>____________________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<pre id="P7000497027000000000000000046027" data-uri="chapter09.xhtml#P7000497027000000000000000046027" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046028" data-uri="chapter09.xhtml#P7000497027000000000000000046028" class="calibre10 pcalibre pcalibre1">
1	void *mm_malloc(size_t size)
2	{
3		size_t asize;	/* Adjusted block size */
4		size_t extendsize;	/* Amount to extend heap if no fit */
5		char *bp;
6	
7		/* Ignore spurious requests */
8		if (size == 0)
9			return NULL;
10	
11		/* Adjust block size to include overhead and alignment reqs. */
12		if (size &lt;= DSIZE)
13			asize = 2*DSIZE;
14		else
15			asize = DSIZE * ((size + (DSIZE) + (DSIZE-1)) / DSIZE);
16	
17		/* Search the free list for a fit */
18		if ((bp = find_fit(asize)) != NULL) {
19			place(bp, asize);
20			return bp;
21		}
22	
23		/* No fit found. Get more memory and place the block */
24		extendsize = MAX(asize,CHUNKSIZE);
25		if ((bp = extend_heap(extendsize/WSIZE)) == NULL)
26		return NULL;
27		place(bp, asize);
28		return bp;
29	}
</code></pre>
<p id="P7000497027000000000000000046029" data-uri="chapter09.xhtml#P7000497027000000000000000046029" class="pcalibre1 pcalibre calibre2">____________________________________________________________________<i class="calibre5 pcalibre pcalibre1">code/vm/malloc/mm.c</i></p>
<figcaption id="P700049702700000000000000004602A" data-uri="chapter09.xhtml#P700049702700000000000000004602A" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004602B" data-uri="chapter09.xhtml#P700049702700000000000000004602B" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">9.47 </span><code id="P700049702700000000000000004602C" data-uri="chapter09.xhtml#P700049702700000000000000004602C" class="pcalibre1 calibre8 pcalibre">mm_malloc</code> allocates a block from the free list.</h1></header></figcaption>
</figure>
<section id="P700049702700000000000000000751B" data-uri="chapter09.xhtml#P700049702700000000000000000751B" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P700049702700000000000000004602D" data-uri="chapter09.xhtml#P700049702700000000000000004602D" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">9.8 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P7000497027000000000000000007849">884</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P700049702700000000000000004602E" data-uri="chapter09.xhtml#P700049702700000000000000004602E">
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004602F" data-uri="chapter09.xhtml#P700049702700000000000000004602F">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000046030" data-uri="chapter09.xhtml#P7000497027000000000000000046030"><p id="P7000497027000000000000000046031" data-uri="chapter09.xhtml#P7000497027000000000000000046031" class="pcalibre calibre3 pcalibre1">Implement a <code id="P7000497027000000000000000046032" data-uri="chapter09.xhtml#P7000497027000000000000000046032" class="pcalibre1 calibre8 pcalibre">find_fit</code> function for the simple allocator described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000748F"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">9.9.12</span></a>.</p>
<pre id="P7000497027000000000000000046033" data-uri="chapter09.xhtml#P7000497027000000000000000046033" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046034" data-uri="chapter09.xhtml#P7000497027000000000000000046034" class="calibre10 pcalibre pcalibre1">
static void *find_fit(size_t asize)
</code></pre>
<p id="P7000497027000000000000000046035" data-uri="chapter09.xhtml#P7000497027000000000000000046035" class="pcalibre calibre3 pcalibre1">Your solution should perform a first-fit search of the implicit free list.</p>
</div></li></ol>
</section>
<section id="P7000497027000000000000000007525" data-uri="chapter09.xhtml#P7000497027000000000000000007525" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P7000497027000000000000000046036" data-uri="chapter09.xhtml#P7000497027000000000000000046036" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">9.9 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P7000497027000000000000000007849">884</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000046037" data-uri="chapter09.xhtml#P7000497027000000000000000046037">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000046038" data-uri="chapter09.xhtml#P7000497027000000000000000046038">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000046039" data-uri="chapter09.xhtml#P7000497027000000000000000046039"><p id="P700049702700000000000000004603A" data-uri="chapter09.xhtml#P700049702700000000000000004603A" class="pcalibre calibre3 pcalibre1">Implement a place function for the example allocator.</p>
<pre id="P700049702700000000000000004603B" data-uri="chapter09.xhtml#P700049702700000000000000004603B" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004603C" data-uri="chapter09.xhtml#P700049702700000000000000004603C" class="calibre10 pcalibre pcalibre1">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000752D" title="862" data-uri="chapter09.xhtml#P700049702700000000000000000752D" epub:type="pagebreak"></span>static void place(void *bp, size_t asize)
</code></pre>
<p id="P700049702700000000000000004603D" data-uri="chapter09.xhtml#P700049702700000000000000004603D" class="pcalibre calibre3 pcalibre1">Your solution should place the requested block at the beginning of the free block, splitting only if the size of the remainder would equal or exceed the minimum block size.</p>
</div></li></ol>
</section>
</section>
</section>
<section id="P700049702700000000000000000752F" data-uri="chapter09.xhtml#P700049702700000000000000000752F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004603E" data-uri="chapter09.xhtml#P700049702700000000000000004603E" epub:type="title"><span class="pcalibre label pcalibre1">9.9.13 </span>Explicit Free Lists</h1></header>
<p id="P700049702700000000000000004603F" data-uri="chapter09.xhtml#P700049702700000000000000004603F" class="pcalibre1 pcalibre calibre2">The implicit free list provides us with a simple way to introduce some basic allocator concepts. However, because block allocation time is linear in the total number of heap blocks, the implicit free list is not appropriate for a general-purpose allocator (although it might be fine for a special-purpose allocator where the number of heap blocks is known beforehand to be small).</p>
<p id="P7000497027000000000000000046040" data-uri="chapter09.xhtml#P7000497027000000000000000046040" class="pcalibre1 pcalibre calibre2">A better approach is to organize the free blocks into some form of explicit data structure. Since by definition the body of a free block is not needed by the program, the pointers that implement the data structure can be stored within the bodies of the free blocks. For example, the heap can be organized as a doubly linked free list by including a <code id="P7000497027000000000000000046041" data-uri="chapter09.xhtml#P7000497027000000000000000046041" class="pcalibre1 calibre8 pcalibre">pred</code> (predecessor) and <code id="P7000497027000000000000000046042" data-uri="chapter09.xhtml#P7000497027000000000000000046042" class="pcalibre1 calibre8 pcalibre">succ</code> (successor) pointer in each free block, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007536"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">9.48</span></a>.</p>
<p id="P7000497027000000000000000046043" data-uri="chapter09.xhtml#P7000497027000000000000000046043" class="pcalibre1 pcalibre calibre2">Using a doubly linked list instead of an implicit free list reduces the first-fit allocation time from linear in the total number of blocks to linear in the number of <i class="calibre5 pcalibre pcalibre1">free</i> blocks. However, the time to free a block can be either linear or constant, depending on the policy we choose for ordering the blocks in the free list.</p>
<figure id="P7000497027000000000000000007536" class="pcalibre5 figure pcalibre" data-uri="chapter09.xhtml#P7000497027000000000000000007536">
<img alt="Diagrams illustrate allocated block and free block." id="P7000497027000000000000000046044" data-uri="P700049702700000000000000000B7A6" src="../images/p862-1.png" class="calibre300 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000046045" data-uri="chapter09.xhtml#P7000497027000000000000000046045" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046046" data-uri="chapter09.xhtml#P7000497027000000000000000046046" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">9.48 </span>Format of heap blocks that use doubly linked free lists.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P700049702700000000000000002639F" data-uri="chapter09.xhtml#P700049702700000000000000002639F">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000046047" data-uri="chapter09.xhtml#P7000497027000000000000000046047" class="pcalibre1 pcalibre calibre2">Two diagrams each show a block, from 31 to 0 bits. Diagram (a), of the allocated block, has the following from top to bottom:</p>
<ul id="P7000497027000000000000000046048" data-uri="chapter09.xhtml#P7000497027000000000000000046048" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000046049" data-uri="chapter09.xhtml#P7000497027000000000000000046049" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004604A" data-uri="chapter09.xhtml#P700049702700000000000000004604A" class="pcalibre calibre3 pcalibre1">Header, with block size from 31 to 3 bits and a/f from 2 to 0 bits</p></li>
<li id="P700049702700000000000000004604B" data-uri="chapter09.xhtml#P700049702700000000000000004604B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004604C" data-uri="chapter09.xhtml#P700049702700000000000000004604C" class="pcalibre calibre3 pcalibre1">Payload</p></li>
<li id="P700049702700000000000000004604D" data-uri="chapter09.xhtml#P700049702700000000000000004604D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004604E" data-uri="chapter09.xhtml#P700049702700000000000000004604E" class="pcalibre calibre3 pcalibre1">Padding (optional)</p></li>
<li id="P700049702700000000000000004604F" data-uri="chapter09.xhtml#P700049702700000000000000004604F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046050" data-uri="chapter09.xhtml#P7000497027000000000000000046050" class="pcalibre calibre3 pcalibre1">Footer, with block size and a/f as in the header</p></li>
</ul>
<p id="P7000497027000000000000000046051" data-uri="chapter09.xhtml#P7000497027000000000000000046051" class="pcalibre calibre3 pcalibre1">Diagram (b), of the free block, has the old payload section divided into pred (predecessor) and succ (successor) at the top, with a blank section below.</p>
</details>
</figcaption>
</figure>
<p id="P7000497027000000000000000046052" data-uri="chapter09.xhtml#P7000497027000000000000000046052" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000753B" title="863" data-uri="chapter09.xhtml#P700049702700000000000000000753B" epub:type="pagebreak"></span>One approach is to maintain the list in <i class="calibre5 pcalibre pcalibre1">last-in first-out</i> (LIFO) order by inserting newly freed blocks at the beginning of the list. With a LIFO ordering and a first-fit placement policy, the allocator inspects the most recently used blocks first. In this case, freeing a block can be performed in constant time. If boundary tags are used, then coalescing can also be performed in constant time.</p>
<p id="P7000497027000000000000000046053" data-uri="chapter09.xhtml#P7000497027000000000000000046053" class="pcalibre1 pcalibre calibre2">Another approach is to maintain the list in <i class="calibre5 pcalibre pcalibre1">address order</i>, where the address of each block in the list is less than the address of its successor. In this case, freeing a block requires a linear-time search to locate the appropriate predecessor. The trade-off is that address-ordered first fit enjoys better memory utilization than LIFO-ordered first fit, approaching the utilization of best fit.</p>
<p id="P7000497027000000000000000046054" data-uri="chapter09.xhtml#P7000497027000000000000000046054" class="pcalibre1 pcalibre calibre2">A disadvantage of explicit lists in general is that free blocks must be large enough to contain all of the necessary pointers, as well as the header and possibly a footer. This results in a larger minimum block size and increases the potential for internal fragmentation.</p>
</section>
<section id="P700049702700000000000000000753E" data-uri="chapter09.xhtml#P700049702700000000000000000753E" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046055" data-uri="chapter09.xhtml#P7000497027000000000000000046055" epub:type="title"><span class="pcalibre label pcalibre1">9.9.14 </span>Segregated Free Lists</h1></header>
<p id="P7000497027000000000000000046056" data-uri="chapter09.xhtml#P7000497027000000000000000046056" class="pcalibre1 pcalibre calibre2">As we have seen, an allocator that uses a single linked list of free blocks requires time linear in the number of free blocks to allocate a block. A popular approach for reducing the allocation time, known generally as <i class="calibre5 pcalibre pcalibre1">segregated storage</i>, is to maintain multiple free lists, where each list holds blocks that are roughly the same size. The general idea is to partition the set of all possible block sizes into equivalence classes called <i class="calibre5 pcalibre pcalibre1">size classes.</i> There are many ways to define the size classes. For example, we might partition the block sizes by powers of 2:</p>

<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000046057" data-uri="chapter09.xhtml#P7000497027000000000000000046057"><m:math display="block" alttext="" data-uri="" altimg-width="592" altimg-height="19" altimg="../images/ch09-eq9.png"><m:mrow><m:mrow><m:mo>{</m:mo> <m:mn>1</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mn>2</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>3</m:mn><m:mo>,</m:mo><m:mn>4</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>5</m:mn><m:mo>−</m:mo><m:mn>8</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mo>⋯</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>025</m:mn><m:mo>−</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>048</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>049</m:mn><m:mo>−</m:mo><m:mn>4</m:mn><m:mo>,</m:mo><m:mn>096</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>4</m:mn><m:mo>,</m:mo><m:mn>097</m:mn><m:mo>−</m:mo><m:mi>∞</m:mi></m:mrow> <m:mo>}</m:mo></m:mrow></m:mrow></m:math></div>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046058" data-uri="chapter09.xhtml#P7000497027000000000000000046058">Or we might assign small blocks to their own size classes and partition large blocks by powers of 2:</p>
<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000046059" data-uri="chapter09.xhtml#P7000497027000000000000000046059"><m:math display="block" alttext="" data-uri="" altimg-width="661" altimg-height="19" altimg="../images/ch09-eq10.png"><m:mrow><m:mrow><m:mo>{</m:mo> <m:mn>1</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mn>2</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mn>3</m:mn> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mo>⋯</m:mo><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>023</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>024</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>1</m:mn><m:mo>,</m:mo><m:mn>025</m:mn><m:mo>−</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>048</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>2</m:mn><m:mo>,</m:mo><m:mn>049</m:mn><m:mo>−</m:mo><m:mn>4</m:mn><m:mo>,</m:mo><m:mn>096</m:mn></m:mrow> <m:mo>}</m:mo></m:mrow><m:mo>,</m:mo><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mrow><m:mo>{</m:mo> <m:mrow><m:mn>4</m:mn><m:mo>,</m:mo><m:mn>097</m:mn><m:mo>−</m:mo><m:mi>∞</m:mi></m:mrow> <m:mo>}</m:mo></m:mrow></m:mrow></m:math></div>
<p id="P700049702700000000000000004605A" data-uri="chapter09.xhtml#P700049702700000000000000004605A" class="pcalibre1 pcalibre calibre2">The allocator maintains an array of free lists, with one free list per size class, ordered by increasing size. When the allocator needs a block of size <var class="calibre5 pcalibre pcalibre1">n</var>, it searches the appropriate free list. If it cannot find a block that fits, it searches the next list, and so on.</p>
<p id="P700049702700000000000000004605B" data-uri="chapter09.xhtml#P700049702700000000000000004605B" class="pcalibre1 pcalibre calibre2">The dynamic storage allocation literature describes dozens of variants of segregated storage that differ in how they define size classes, when they perform coalescing, when they request additional heap memory from the operating system, whether they allow splitting, and so forth. To give you a sense of what is possible, we will describe two of the basic approaches: <i class="calibre5 pcalibre pcalibre1">simple segregated storage</i> and <i class="calibre5 pcalibre pcalibre1">segregated fits.</i></p>
<section id="P7000497027000000000000000007546" data-uri="chapter09.xhtml#P7000497027000000000000000007546" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004605C" data-uri="chapter09.xhtml#P700049702700000000000000004605C" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007548" title="864" data-uri="chapter09.xhtml#P7000497027000000000000000007548" epub:type="pagebreak"></span>Simple Segregated Storage</h1></header>
<p id="P700049702700000000000000004605D" data-uri="chapter09.xhtml#P700049702700000000000000004605D" class="pcalibre1 pcalibre calibre2">With simple segregated storage, the free list for each size class contains same-size blocks, each the size of the largest element of the size class. For example, if some size class is defined as {17–32}, then the free list for that class consists entirely of blocks of size 32.</p>
<p id="P700049702700000000000000004605E" data-uri="chapter09.xhtml#P700049702700000000000000004605E" class="pcalibre1 pcalibre calibre2">To allocate a block of some given size, we check the appropriate free list. If the list is not empty, we simply allocate the first block in its entirety. Free blocks are never split to satisfy allocation requests. If the list is empty, the allocator requests a fixed-size chunk of additional memory from the operating system (typically a multiple of the page size), divides the chunk into equal-size blocks, and links the blocks together to form the new free list. To free a block, the allocator simply inserts the block at the front of the appropriate free list.</p>
<p id="P700049702700000000000000004605F" data-uri="chapter09.xhtml#P700049702700000000000000004605F" class="pcalibre1 pcalibre calibre2">There are a number of advantages to this simple scheme. Allocating and freeing blocks are both fast constant-time operations. Further, the combination of the same-size blocks in each chunk, no splitting, and no coalescing means that there is very little per-block memory overhead. Since each chunk has only same-size blocks, the size of an allocated block can be inferred from its address. Since there is no coalescing, allocated blocks do not need an allocated/free flag in the header. Thus, allocated blocks require no headers, and since there is no coalescing, they do not require any footers either. Since allocate and free operations insert and delete blocks at the beginning of the free list, the list need only be singly linked instead of doubly linked. The bottom line is that the only required field in any block is a one-word <code id="P7000497027000000000000000046060" data-uri="chapter09.xhtml#P7000497027000000000000000046060" class="pcalibre1 calibre8 pcalibre">succ</code> pointer in each free block, and thus the minimum block size is only one word.</p>
<p id="P7000497027000000000000000046061" data-uri="chapter09.xhtml#P7000497027000000000000000046061" class="pcalibre1 pcalibre calibre2">A significant disadvantage is that simple segregated storage is susceptible to internal and external fragmentation. Internal fragmentation is possible because free blocks are never split. Worse, certain reference patterns can cause extreme external fragmentation because free blocks are never coalesced (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000754E"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">9.10</span></a>).</p>
<section id="P700049702700000000000000000754E" data-uri="chapter09.xhtml#P700049702700000000000000000754E" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P7000497027000000000000000046062" data-uri="chapter09.xhtml#P7000497027000000000000000046062" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">9.10 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000777C.xhtml#P700049702700000000000000000785C">885</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000046063" data-uri="chapter09.xhtml#P7000497027000000000000000046063">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000046064" data-uri="chapter09.xhtml#P7000497027000000000000000046064">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000046065" data-uri="chapter09.xhtml#P7000497027000000000000000046065"><p id="P7000497027000000000000000046066" data-uri="chapter09.xhtml#P7000497027000000000000000046066" class="pcalibre calibre3 pcalibre1">Describe a reference pattern that results in severe external fragmentation in an allocator based on simple segregated storage.</p>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000007554" data-uri="chapter09.xhtml#P7000497027000000000000000007554" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046067" data-uri="chapter09.xhtml#P7000497027000000000000000046067" epub:type="title">Segregated Fits</h1></header>
<p id="P7000497027000000000000000046068" data-uri="chapter09.xhtml#P7000497027000000000000000046068" class="pcalibre1 pcalibre calibre2">With this approach, the allocator maintains an array of free lists. Each free list is associated with a size class and is organized as some kind of explicit or implicit list. Each list contains potentially different-size blocks whose sizes are members of the size class. There are many variants of segregated fits allocators. Here we describe a simple version.</p>
<p id="P7000497027000000000000000046069" data-uri="chapter09.xhtml#P7000497027000000000000000046069" class="pcalibre1 pcalibre calibre2">To allocate a block, we determine the size class of the request and do a first-fit search of the appropriate free list for a block that fits. If we find one, then we (optionally) split it and insert the fragment in the appropriate free list. If we cannot find a block that fits, then we search the free list for the next larger size class. We <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007558" title="865" data-uri="chapter09.xhtml#P7000497027000000000000000007558" epub:type="pagebreak"></span>repeat until we find a block that fits. If none of the free lists yields a block that fits, then we request additional heap memory from the operating system, allocate the block out of this new heap memory, and place the remainder in the appropriate size class. To free a block, we coalesce and place the result on the appropriate free list.</p>
<p id="P700049702700000000000000004606A" data-uri="chapter09.xhtml#P700049702700000000000000004606A" class="pcalibre1 pcalibre calibre2">The segregated fits approach is a popular choice with production-quality allocators such as the GNU <code id="P700049702700000000000000004606B" data-uri="chapter09.xhtml#P700049702700000000000000004606B" class="pcalibre1 calibre8 pcalibre">malloc</code> package provided in the C standard library because it is both fast and memory efficient. Search times are reduced because searches are limited to particular parts of the heap instead of the entire heap. Memory utilization can improve because of the interesting fact that a simple first-fit search of a segregated free list approximates a best-fit search of the entire heap.</p>
</section>
<section id="P700049702700000000000000000755B" data-uri="chapter09.xhtml#P700049702700000000000000000755B" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004606C" data-uri="chapter09.xhtml#P700049702700000000000000004606C" epub:type="title">Buddy Systems</h1></header>
<p id="P700049702700000000000000004606D" data-uri="chapter09.xhtml#P700049702700000000000000004606D" class="pcalibre1 pcalibre calibre2">A <i class="calibre5 pcalibre pcalibre1">buddy system</i> is a special case of segregated fits where each size class is a power of 2. The basic idea is that, given a heap of 2<i class="calibre5 pcalibre pcalibre1"><sup class="calibre51 pcalibre pcalibre1">m</sup></i> words, we maintain a separate free list for each block size <i class="calibre5 pcalibre pcalibre1">2<sup class="calibre51 pcalibre pcalibre1">k</sup></i>, where 0 ≤ <var class="calibre5 pcalibre pcalibre1">k</var> ≤ <var class="calibre5 pcalibre pcalibre1">m</var>. Requested block sizes are rounded up to the nearest power of 2. Originally, there is one free block of size 2<i class="calibre5 pcalibre pcalibre1"><sup class="calibre51 pcalibre pcalibre1">m</sup></i> words.</p>
<p id="P700049702700000000000000004606E" data-uri="chapter09.xhtml#P700049702700000000000000004606E" class="pcalibre1 pcalibre calibre2">To allocate a block of size 2<i class="calibre5 pcalibre pcalibre1"><sup class="calibre51 pcalibre pcalibre1">k</sup></i>, we find the first available block of size 2<sup class="calibre51 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">j</var></sup>, such that <var class="calibre5 pcalibre pcalibre1">k</var> ≤ <var class="calibre5 pcalibre pcalibre1">j</var> ≤ <var class="calibre5 pcalibre pcalibre1">m</var>. If <var class="calibre5 pcalibre pcalibre1">j</var> = <var class="calibre5 pcalibre pcalibre1">k</var>, then we are done. Otherwise, we recursively split the block in half until <var class="calibre5 pcalibre pcalibre1">j</var> = <i class="calibre5 pcalibre pcalibre1">k.</i> As we perform this splitting, each remaining half (known as a <i class="calibre5 pcalibre pcalibre1">buddy</i>) is placed on the appropriate free list. To free a block of size 2<i class="calibre5 pcalibre pcalibre1"><sup class="calibre51 pcalibre pcalibre1">k</sup></i>, we continue coalescing with the free buddies. When we encounter an allocated buddy, we stop the coalescing.</p>
<p id="P700049702700000000000000004606F" data-uri="chapter09.xhtml#P700049702700000000000000004606F" class="pcalibre1 pcalibre calibre2">A key fact about buddy systems is that, given the address and size of a block, it is easy to compute the address of its buddy. For example, a block of size 32 bytes with address</p>
<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000046070" data-uri="chapter09.xhtml#P7000497027000000000000000046070"><m:math display="block" alttext="" data-uri="" altimg-width="134" altimg-height="15" altimg="../images/ch09-eq11.png"><m:mrow><m:mi>x</m:mi><m:mi>x</m:mi><m:mi>x</m:mi><m:mtext> </m:mtext><m:mo>…</m:mo><m:mi>x</m:mi><m:mn>00000</m:mn></m:mrow></m:math></div>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046071" data-uri="chapter09.xhtml#P7000497027000000000000000046071">has its buddy at address</p>
<div class="informalequation pcalibre pcalibre1" id="P7000497027000000000000000046072" data-uri="chapter09.xhtml#P7000497027000000000000000046072"><m:math display="block" alttext="" data-uri="" altimg-width="134" altimg-height="16" altimg="../images/ch09-eq12.png"><m:mrow><m:mi>x</m:mi><m:mi>x</m:mi><m:mi>x</m:mi><m:mtext> </m:mtext><m:mo>…</m:mo><m:mi>x</m:mi><m:mn>10000</m:mn></m:mrow></m:math></div>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046073" data-uri="chapter09.xhtml#P7000497027000000000000000046073">In other words, the addresses of a block and its buddy differ in exactly one bit position.</p>
<p id="P7000497027000000000000000046074" data-uri="chapter09.xhtml#P7000497027000000000000000046074" class="pcalibre1 pcalibre calibre2">The major advantage of a buddy system allocator is its fast searching and coalescing. The major disadvantage is that the power-of-2 requirement on the block size can cause significant internal fragmentation. For this reason, buddy system allocators are not appropriate for general-purpose workloads. However, for certain application-specific workloads, where the block sizes are known in advance to be powers of 2, buddy system allocators have a certain appeal.</p>
</section>
</section>
</section></body></html>
