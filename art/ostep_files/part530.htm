<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>48.11 Implications on Server-Side Write Buffering</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part529.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part531.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">48.11 Implications on Server-Side Write Buffering</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Our focus so far has been on client caching, and that is where most of the interesting issues arise. However, NFS servers tend to be well- equipped machines with a lot of memory too, and thus they have caching concerns as well. When data (and metadata) is read from disk, NFS</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">servers will keep it in memory, and subsequent reads of said data (and metadata) will not go to disk, a potential (small) boost in performance.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">More intriguing is the case of write buffering. NFS servers absolutely may <i>not </i>return success on a WRITE protocol request until the write has been forced to stable storage (e.g., to disk or some other persistent device). While they can place a copy of the data in server memory, returning suc- cess to the client on a WRITE protocol request could result in incorrect behavior; can you figure out why?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The answer lies in our assumptions about how clients handle server failure. Imagine the following sequence of writes as issued by a client:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 81pt;text-indent: 0pt;text-align: left;">write(fd, a_buffer, size); // fill first block with a’s write(fd, b_buffer, size); // fill second block with b’s write(fd, c_buffer, size); // fill third block with c’s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">These writes overwrite the three blocks of a file with a block of a’s, then b’s, and then c’s. Thus, if the file initially looked like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 81pt;text-indent: 0pt;text-align: justify;">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">We might expect the final result after these writes to be like this, with the x’s, y’s, and z’s, would be overwritten with a’s, b’s, and c’s, respectively.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 81pt;text-indent: 0pt;text-align: justify;">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Now let’s assume for the sake of the example that these three client writes were issued to the server as three distinct WRITE protocol mes- sages. Assume the first WRITE message is received by the server and issued to the disk, and the client informed of its success. Now assume the second write is just buffered in memory, and the server also reports it success to the client <i>before </i>forcing it to disk; unfortunately, the server crashes before writing it to disk. The server quickly restarts and receives the third write request, which also succeeds.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Thus, to the client, all the requests succeeded, but we are surprised that the file contents look like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 81pt;text-indent: 0pt;text-align: left;">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy &lt;--- oops cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Yikes! Because the server told the client that the second write was successful before committing it to disk, an old chunk is left in the file, which, depending on the application, might be catastrophic.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To avoid this problem, NFS servers <i>must </i>commit each write to stable (persistent) storage before informing the client of success; doing so en- ables the client to detect server failure during a write, and thus retry until</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">it finally succeeds. Doing so ensures we will never end up with file con- tents intermingled as in the above example.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The problem that this requirement gives rise to in NFS server im- plementation is that write performance, without great care, can be <i>the </i>major performance bottleneck. Indeed, some companies (e.g., Network Appliance) came into existence with the simple objective of building an NFS server that can perform writes quickly; one trick they use is to first put writes in a battery-backed memory, thus enabling to quickly reply to WRITE requests without fear of losing the data and without the cost of having to write to disk right away; the second trick is to use a file sys- tem design specifically designed to write to disk quickly when one finally needs to do so [HLM94, RO91].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part529.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part531.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
