<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.7  Multiversion Schemes</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part334.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part336.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">18.7  <span style=" color: #00AEEF;">Multiversion Schemes</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The concurrency-control schemes discussed thus far ensure serializability by either de- laying an operation or aborting the transaction that issued the operation. For example, a <span class="s49">read </span>operation may be delayed because the appropriate value has not been written yet; or it may be rejected (that is, the issuing transaction must be aborted) because the value that it was supposed to read has already been overwritten. These diﬃculties could be avoided if old copies of each data item were kept in a system.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: left;">In <span class="s63">multiversion concurrency-control </span>schemes, each <span class="s49">write</span>(<i>Q</i>) operation creates a new <span class="s63">version </span>of <i>Q</i>. When a transaction issues a <span class="s49">read</span>(<i>Q</i>) operation, the concurrency- control manager selects one of the versions of <i>Q </i>to be read. The concurrency-control scheme must ensure that the version to be read is selected in a manner that ensures serializability. It is also crucial, for performance reasons, that a transaction be able to determine easily and quickly which version of the data item should be read.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">18.7.1 Multiversion Timestamp Ordering</p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;line-height: 94%;text-align: justify;">The timestamp-ordering protocol can be extended to a multiversion protocol. With each transaction <i>T</i><span class="s145">i </span>in the system, we associate a unique static timestamp, denoted by TS(<i>T</i><span class="s145">i</span>). The database system assigns this timestamp before the transaction starts execution, as described in Section 18.5.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 16pt;text-align: justify;">With each data item <i>Q</i>, a sequence of versions <span class="s83">&lt;</span><i>Q</i><span class="s98">1</span>, <i>Q</i><span class="s98">2</span>, <span class="s15">… </span>, <i>Q</i><span class="s97">m</span><span class="s83">&gt; </span>is associated.</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 73%;text-align: justify;">Each version <i>Q</i><span class="s97">k </span>contains three data ﬁelds:</p><p style="padding-top: 11pt;padding-left: 97pt;text-indent: 0pt;text-align: left;"><span class="s63">1. </span><b>Content </b>is the value of version <i>Q</i><span class="s97">k</span>.</p><p style="padding-top: 4pt;padding-left: 96pt;text-indent: 0pt;text-align: left;"><span class="s63">2. </span><b>W-timestamp</b>(<i>Q</i><span class="s145">k </span>) is the timestamp of the transaction that created version <i>Q</i><span class="s145">k</span>.</p><p style="padding-top: 5pt;padding-left: 113pt;text-indent: -17pt;line-height: 87%;text-align: left;"><span class="s63">3. </span><b>R-timestamp</b>(<i>Q</i><span class="s97">k </span>) is the largest timestamp of any transaction that successfully read version <i>Q</i><span class="s97">k</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 79%;text-align: justify;">A transaction—say, <i>T</i><span class="s97">i</span>—creates a new version <i>Q</i><span class="s97">k </span>of data item <i>Q </i>by issuing a <span class="s49">write</span>(<i>Q</i>) operation. The content ﬁeld of the version holds the value written by <i>T</i><span class="s97">i</span>. The system initializes the W-timestamp and R-timestamp to TS(<i>T</i><span class="s97">i</span>). It updates the R-timestamp value of <i>Q</i><span class="s97">k </span>whenever a transaction <i>T</i><span class="s97">j </span>reads the content of <i>Q</i><span class="s97">k </span>and R-timestamp(<i>Q</i><span class="s97">k </span>) <span class="s83">&lt; </span>TS(<i>T</i><span class="s145">j </span>).</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">The <span class="s63">multiversion timestamp-ordering scheme </span>presented next ensures serializabil-</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 87%;text-align: justify;">ity. The scheme operates as follows: Suppose that transaction <i>T</i><span class="s97">i </span>issues a <span class="s49">read</span>(<i>Q</i>) or <span class="s49">write</span>(<i>Q</i>) operation. Let <i>Q</i><span class="s97">k </span>denote the version of <i>Q </i>whose write timestamp is the largest write timestamp less than or equal to TS(<i>T</i><span class="s97">i</span>).</p><p style="padding-top: 12pt;padding-left: 113pt;text-indent: -16pt;line-height: 87%;text-align: justify;"><span class="s63">1. </span>If transaction <i>T</i><span class="s97">i </span>issues a <span class="s49">read</span>(<i>Q</i>), then the value returned is the content of ver- sion <i>Q</i><span class="s97">k</span>.</p><p style="padding-top: 4pt;padding-left: 113pt;text-indent: -17pt;line-height: 77%;text-align: justify;"><span class="s63">2. </span>If transaction <i>T</i><span class="s145">i </span>issues <span class="s49">write</span>(<i>Q</i>), and if TS(<i>T</i><span class="s145">i</span>) <span class="s83">&lt; </span>R-timestamp(<i>Q</i><span class="s145">k </span>), then the system rolls back transaction <i>T</i><span class="s97">i</span>. On the other hand, if TS(<i>T</i><span class="s97">i</span>) <span class="s15">= </span>W- timestamp(<i>Q</i><span class="s97">k </span>), the system overwrites the contents of <i>Q</i><span class="s97">k</span>; otherwise (if TS(<i>T</i><span class="s97">i</span>)</p><p style="padding-left: 113pt;text-indent: 0pt;line-height: 17pt;text-align: justify;"><span class="s83">&gt; </span>R-timestamp(<i>Q</i><span class="s97">k </span>)), it creates a new version of <i>Q</i>.</p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 17pt;line-height: 13pt;text-align: justify;">The justiﬁcation for rule 1 is clear. A transaction reads the most recent version that comes before it in time. The second rule forces a transaction to abort if it is “too late” in doing a write. More precisely, if <i>T</i><span class="s97">i </span>attempts to write a version that some other transaction would have read, then we cannot allow that write to succeed.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 92%;text-align: justify;">The <span class="s63">valid interval </span>of a version <i>Q</i><span class="s145">i </span>of <i>Q </i>with W-timestamp <i>t </i>is deﬁned as follows: if <i>Q</i><span class="s145">i </span>is the latest version of <i>Q</i>, the interval is [<i>t</i>, <span class="s15">∞</span>]; otherwise let the next version of <i>Q </i>have timestamp <i>s</i>; then the valid interval is [<i>t</i>, <i>s</i>). You can easily verify that reads by a transaction with timestamp <i>t</i><span class="s97">i </span>return the content of the version whose valid interval contains <i>t</i><span class="s97">i</span>.</p><p style="padding-left: 87pt;text-indent: 0pt;line-height: 10pt;text-align: right;">Versions that are no longer needed are removed according to the following rule:</p><p style="text-indent: 0pt;text-align: right;">Suppose that there are two versions, <i>Q</i><span class="s97">k </span>and <i>Q</i><span class="s97">j </span>, of a data item, and that both versions</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 119pt;text-indent: 0pt;line-height: 94%;text-align: right;">have a W-timestamp less than the timestamp of the oldest transaction in the system. Then, the older of the two versions <i>Q</i><span class="s97">k </span>and <i>Q</i><span class="s97">j </span>will not be used again, and can be deleted. The multiversion timestamp-ordering scheme has the desirable property that a read</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">request never fails and is never made to wait. In typical database systems, where reading is a more frequent operation than is writing, this advantage may be of major practical signiﬁcance.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The scheme, however, suﬀers from two undesirable properties. First, the reading of a data item also requires the updating of the R-timestamp ﬁeld, resulting in two potential disk accesses, rather than one. Second, the conﬂicts between transactions are resolved through rollbacks, rather than through waits. This alternative may be expensive. Section</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">18.7.2 describes an algorithm to alleviate this problem.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">This multiversion timestamp-ordering scheme does not ensure recoverability and cascadelessness. It can be extended in the same manner as the basic timestamp- ordering scheme to make it recoverable and cascadeless.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">18.7.2 Multiversion Two-Phase Locking</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The <span class="s63">multiversion two-phase locking protocol </span>attempts to combine the advantages of mul- tiversion concurrency control with the advantages of two-phase locking. This protocol diﬀerentiates between <span class="s63">read-only transactions </span>and <span class="s63">update transactions</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Update transactions perform rigorous two-phase locking; that is, they hold all locks up to the end of the transaction. Thus, they can be serialized according to their commit order. Each version of a data item has a single timestamp. The timestamp in this case is not a real clock-based timestamp, but rather is a counter, which we will call the <span class="s49">ts- counter</span>, that is incremented during commit processing.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The database system assigns read-only transactions a timestamp by reading the current value of <span class="s49">ts-counter </span>before they start execution; they follow the multiversion timestamp-ordering protocol for performing reads. Thus, when a read-only transaction <i>T</i><span class="s97">i </span>issues a <span class="s49">read</span>(<i>Q</i>), the value returned is the contents of the version whose timestamp</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 79%;text-align: justify;">is the largest timestamp less than or equal to TS(<i>T</i><span class="s97">i</span>).</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">When an update transaction reads an item, it gets a shared lock on the item and</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: right;">reads the latest version of that item. When an update transaction wants to write an item, it ﬁrst gets an exclusive lock on the item and then creates a new version of the data item. The write is performed on the new version, and the timestamp of the new version is initially set to a value <span class="s15">∞</span>, a value greater than that of any possible timestamp. When the update transaction <i>T</i><span class="s97">i </span>completes its actions, it carries out commit pro-</p><p style="padding-left: 87pt;text-indent: 0pt;line-height: 10pt;text-align: right;">cessing; only one update transaction is allowed to perform commit processing at a time.</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">First, <i>T</i><span class="s97">i </span>sets the timestamp on every version it has created to 1 more than the value of</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;"><span class="s49">ts-counter</span>; then, <i>T</i><span class="s97">i </span>increments <span class="s49">ts-counter </span>by 1, and commits.</p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 89%;text-align: justify;">Read-only transactions see the old value of <span class="s49">ts-counter </span>until <i>T</i><span class="s145">i </span>has successfully committed. As a result, read-only transactions that start after <i>T</i><span class="s145">i </span>commits will see the values updated by <i>T</i><span class="s97">i</span>, whereas those that start before <i>T</i><span class="s97">i </span>commits will see the value before the updates by <i>T</i><span class="s97">i</span>. In either case, read-only transactions never need to wait for</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="493" height="512" alt="image" src="Image_3020.png"/></span></p><p class="s73" style="padding-left: 59pt;text-indent: 0pt;text-align: center;"><a name="bookmark388">Note 18.2 </a><span class="s146">MULTIVERSIONING AND DATABASE IMPLEMENTATION</span><a name="bookmark429">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 97pt;text-indent: 0pt;text-align: justify;">Consider a database system that implements a primary key constraint by ensuring that only one tuple exists for any value of the primary key attribute. The creation of a second version of the record with the same primary key would appear to be a violation of the primary key constraint. However, it is logically not a violation, since the two versions do not coexist at any time in the database. Therefore, primary constraint enforcement must be modiﬁed to allow multiple records with the same primary key, as long as they are diﬀerent versions of the same record.</p><p style="padding-left: 97pt;text-indent: 17pt;text-align: justify;">Next, consider the issue of deletion of tuples. This can be implemented by creating a new version of the tuple, with timestamps created as usual, but with a special marker denoting that the tuple has been deleted. Transactions that read such a tuple simply skip it, since it has been deleted.</p><p class="s13" style="padding-top: 1pt;padding-left: 97pt;text-indent: 17pt;line-height: 83%;text-align: justify;"><span class="p">Further, consider the issue of enforcing foreign-key dependencies. Consider the case of a relation </span>r <span class="p">whose attribute </span>r<span class="s83">.</span>B <span class="p">is a foreign-key referencing attribute</span></p><p class="s13" style="padding-left: 97pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">s<span class="s83">.</span>B <span class="p">of relation </span>s<span class="p">. In general, deletion of a tuple </span>t<span class="s97">s </span><span class="p">in </span>s <span class="p">or update of a primary key</span></p><p class="s13" style="padding-left: 97pt;text-indent: 0pt;line-height: 72%;text-align: justify;"><span class="p">attribute of tuple </span>t<span class="s97">s </span><span class="p">in </span>s <span class="p">causes a foreign-key violation if there is an </span>r <span class="p">tuple </span>t<span class="s97">r </span><span class="p">such that </span>t<span class="s97">r</span><span class="s83">.</span>B <span class="s15">= </span>t<span class="s97">s</span><span class="s83">.</span>B<span class="p">. With multiversioning, if the timestamp of the transaction performing the deletion/update is </span>ts<span class="s97">i</span><span class="p">, the corresponding condition for violation is the existence</span></p><p style="padding-left: 97pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">of such a tuple version <i>t</i><span class="s145">r </span>, with the additional condition that the valid interval of <i>t</i><span class="s145">r</span></p><p style="padding-left: 97pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">contains <i>ts</i><span class="s145">i</span>.</p><p class="s13" style="padding-left: 97pt;text-indent: 17pt;line-height: 76%;text-align: justify;"><span class="p">Finally, consider the case of an index on attribute </span>r<span class="s83">.</span>B <span class="p">of relation </span>r<span class="p">. If there are multiple versions of a record </span>t<span class="s97">i </span><span class="p">with the same value for </span>B<span class="p">, the index could point to the latest version of the record, and the latest version could have pointers to earlier versions. However, if an update was made to attribute </span>t<span class="s97">i</span><span class="s83">.</span>B<span class="p">, the index would need to contain separate entries for diﬀerent versions of record </span>t<span class="s97">i</span><span class="p">; one entry for the old value of </span>t<span class="s145">i</span><span class="s83">.</span>B <span class="p">and another for the new value of </span>t<span class="s145">i</span><span class="s83">.</span>B<span class="p">. When old versions of a record</span></p><p style="padding-left: 97pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">are deleted, any entry in the index for the old version must also be deleted.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">locks. Multiversion two-phase locking also ensures that schedules are recoverable and cascadeless.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">Versions are deleted in a manner like that of multiversion timestamp ordering. Suppose there are two versions, <i>Q</i><span class="s97">k </span>and <i>Q</i><span class="s97">j </span>, of a data item, and that both versions have a timestamp less than or equal to the timestamp of the oldest read-only transaction in</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 90%;text-align: justify;">the system. Then, the older of the two versions <i>Q</i><span class="s145">k </span>and <i>Q</i><span class="s145">j </span>will not be used again and it can be deleted.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part334.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part336.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
