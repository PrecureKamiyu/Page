<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>29.2 Concurrent Linked Lists</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part301.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part303.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">29.2 Concurrent Linked Lists</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We next examine a more complicated structure, the linked list. Let’s start with a basic approach once again. For simplicity, we’ll omit some of the obvious routines that such a list would have and just focus on concur- rent insert; we’ll leave it to the reader to think about lookup, delete, and so forth. Figure <span style=" color: #00AEEF;">29.6 </span>shows the code for this rudimentary data structure.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As you can see in the code, the code simply acquires a lock in the insert routine upon entry, and releases it upon exit. One small tricky issue arises if <span class="s41">malloc() </span>happens to fail (a rare case); in this case, the code must also release the lock before failing the insert.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This kind of exceptional control flow has been shown to be quite error prone; a recent study of Linux kernel patches found that a huge fraction of bugs (nearly 40%) are found on such rarely-taken code paths (indeed, this observation sparked some of our own research, in which we removed all memory-failing paths from a Linux file system, resulting in a more robust system [S+11]).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Thus, a challenge: can we rewrite the insert and lookup routines to re- main correct under concurrent insert but avoid the case where the failure path also requires us to add the call to unlock?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The answer, in this case, is yes. Specifically, we can rearrange the code a bit so that the lock and release only surround the actual critical section in the insert code, and that a common exit path is used in the lookup code. The former works because part of the lookup actually need not be locked; assuming that <span class="s41">malloc() </span>itself is thread-safe, each thread can call into it without worry of race conditions or other concurrency bugs. Only when updating the shared list does a lock need to be held. See Figure <span style=" color: #00AEEF;">29.7 </span>for the details of these modifications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:21.66pt" cellspacing="0"><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-left: 4pt;text-indent: 0pt;line-height: 5pt;text-align: left;">1</p></td><td style="width:105pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 6pt;text-align: left;">// basic node structure</p></td><td style="width:84pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">2</p></td><td style="width:105pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 7pt;text-align: left;">typedef struct <span class="s143">&nbsp;</span>node_t</p></td><td style="width:84pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">{</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;line-height: 5pt;text-align: left;">3</p></td><td style="width:105pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 7pt;text-align: left;">int</p></td><td style="width:84pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">key;</p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">4</p></td><td style="width:105pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 7pt;text-align: left;">struct <span class="s143">&nbsp;</span>node_t</p></td><td style="width:84pt"><p class="s136" style="padding-left: 18pt;text-indent: 0pt;line-height: 7pt;text-align: left;">*<span class="s42">next;</span></p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">5</p></td><td style="width:105pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 7pt;text-align: left;">} node_t;</p></td><td style="width:84pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:7pt"><td style="width:13pt"><p class="s135" style="padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">6</p></td><td style="width:105pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:84pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;line-height: 5pt;text-align: left;">7</p></td><td style="width:105pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 6pt;text-align: left;">// basic list structure</p></td><td style="width:84pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">(one used per list)</p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">8</p></td><td style="width:105pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 7pt;text-align: left;">typedef struct <span class="s143">&nbsp;</span>list_t</p></td><td style="width:84pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">{</p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">9</p></td><td style="width:105pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 7pt;text-align: left;">node_t</p></td><td style="width:84pt"><p class="s136" style="padding-left: 10pt;text-indent: 0pt;line-height: 7pt;text-align: left;">*<span class="s42">head;</span></p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">10</p></td><td style="width:105pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 6pt;text-align: left;">pthread_mutex_t</p></td><td style="width:84pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">lock;</p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">11</p></td><td style="width:105pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 8pt;text-align: left;">} list_t;</p></td><td style="width:84pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:7pt"><td style="width:13pt"><p class="s135" style="padding-left: 2pt;text-indent: 0pt;line-height: 5pt;text-align: left;">12</p></td><td style="width:105pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:84pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p class="s38" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">13  </span>void List_Init(list_t <span class="s39">*</span>L) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">14    <span class="s38">L-&gt;head = NULL;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15    <span class="s38">pthread_mutex_init(&amp;L-&gt;lock, NULL);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">17</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">18  </span>int List_Insert(list_t <span class="s39">*</span>L, int key) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">19    <span class="s38">pthread_mutex_lock(&amp;L-&gt;lock);</span></p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">20    </span>node_t <span class="s39">*</span>new = malloc(sizeof(node_t));</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">21    <span class="s38">if (new == NULL) {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">22       <span class="s38">perror(&quot;malloc&quot;);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">23       <span class="s38">pthread_mutex_unlock(&amp;L-&gt;lock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">24       <span class="s38">return -1; // fail</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">25    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">26    <span class="s38">new-&gt;key = key;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">27    <span class="s38">new-&gt;next = L-&gt;head;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">28    <span class="s38">L-&gt;head = new;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">29    <span class="s38">pthread_mutex_unlock(&amp;L-&gt;lock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">30    <span class="s38">return 0; // success</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">31  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">32</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">33  </span>int List_Lookup(list_t <span class="s39">*</span>L, int key) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">34    <span class="s38">pthread_mutex_lock(&amp;L-&gt;lock);</span></p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">35    </span>node_t <span class="s39">*</span>curr = L-&gt;head;</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">36    <span class="s38">while (curr) {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">37       <span class="s38">if (curr-&gt;key == key) {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">38          <span class="s38">pthread_mutex_unlock(&amp;L-&gt;lock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">39          <span class="s38">return 0; // success</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">40       <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">41       <span class="s38">curr = curr-&gt;next;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">42    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">43    <span class="s38">pthread_mutex_unlock(&amp;L-&gt;lock);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">44    <span class="s38">return -1; // failure</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">45  <span class="s38">}</span></p><p style="padding-left: 112pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Figure 29.6: <b>Concurrent Linked List</b></p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As for the lookup routine, it is a simple code transformation to jump out of the main search loop to a single return path. Doing so again re- duces the number of lock acquire/release points in the code, and thus decreases the chances of accidentally introducing bugs (such as forget- ting to unlock before returning) into the code.</p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part303.htm">Scaling Linked Lists</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part301.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part303.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
