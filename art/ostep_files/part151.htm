<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>16.1 Segmentation: Generalized Base/Bounds</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part150.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part152.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">16.1 Segmentation: Generalized Base/Bounds</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To solve this problem, an idea was born, and it is called <b>segmenta- tion</b>. It is quite an old idea, going at least as far back as the very early 1960’s [H61, G62]. The idea is simple: instead of having just one base and bounds pair in our MMU, why not have a base and bounds pair per logical <b>segment </b>of the address space? A segment is just a contiguous portion of the address space of a particular length, and in our canonical</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">141</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="93" height="57" alt="image" src="Image_148.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 24pt;text-indent: 0pt;text-align: center;">Heap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Program Code</p><p style="text-indent: 0pt;text-align: left;"/><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">0KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">1KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">2KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">3KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">4KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">5KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="93" height="220" alt="image" src="Image_149.png"/></span></p><p class="s91" style="text-indent: 0pt;line-height: 7pt;text-align: left;">(free)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 24pt;text-indent: 0pt;text-align: center;">Stack</p><p style="text-indent: 0pt;text-align: left;"/><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">6KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">14KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">15KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">16KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">Figure 16.1: <b>An Address Space (Again)</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">address space, we have three logically-different segments: code, stack, and heap. What segmentation allows the OS to do is to place each one of those segments in different parts of physical memory, and thus avoid filling physical memory with unused virtual address space.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let’s look at an example. Assume we want to place the address space from Figure <span style=" color: #00AEEF;">16.1 </span>into physical memory. With a base and bounds pair per segment, we can place each segment <i>independently </i>in physical memory. For example, see Figure <span style=" color: #00AEEF;">16.2</span>; there you see a 64-KB physical memory with those three segments within it (and 16KB reserved for the OS).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="97" height="172" alt="image" src="Image_150.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 18pt;text-indent: 0pt;text-align: left;">(not in use)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 17pt;text-indent: 0pt;text-align: left;">(not in use)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s88" style="padding-left: 28pt;text-indent: 0pt;line-height: 5pt;text-align: center;">Heap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s88" style="padding-left: 28pt;text-indent: 0pt;line-height: 5pt;text-align: center;">Code</p><p style="text-indent: 0pt;text-align: left;"/><p class="s88" style="padding-left: 16pt;text-indent: 0pt;line-height: 0pt;text-align: center;">Stack</p><p class="s47" style="padding-left: 16pt;text-indent: 0pt;text-align: center;">(not in use)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Operating System</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 3pt;padding-left: 130pt;text-indent: 0pt;text-align: left;">0KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 130pt;text-indent: 0pt;text-align: left;">16KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 130pt;text-indent: 0pt;text-align: left;">32KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 130pt;text-indent: 0pt;text-align: left;">48KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 130pt;text-indent: 0pt;text-align: left;">64KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 21pt;text-indent: 0pt;text-align: center;">Figure 16.2: <b>Placing Segments In Physical Memory</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As you can see in the diagram, only used memory is allocated space in physical memory, and thus large address spaces with large amounts of unused address space (which we sometimes call <b>sparse address spaces</b>) can be accommodated.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The hardware structure in our MMU required to support segmenta- tion is just what you’d expect: in this case, a set of three base and bounds register pairs. Table <span style=" color: #00AEEF;">16.1 </span>below shows the register values for the example above; each bounds register holds the size of a segment.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s92" style="padding-bottom: 1pt;text-indent: 0pt;text-align: center;"> <span class="s93">Segment  Base  Size </span></p><table style="border-collapse:collapse;margin-left:136.26pt" cellspacing="0"><tr style="height:10pt"><td style="width:37pt"><p class="s20" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Code</p></td><td style="width:36pt"><p class="s20" style="padding-right: 7pt;text-indent: 0pt;line-height: 9pt;text-align: right;">32K</p></td><td style="width:22pt"><p class="s20" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">2K</p></td></tr><tr style="height:10pt"><td style="width:37pt"><p class="s20" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Heap</p></td><td style="width:36pt"><p class="s20" style="padding-right: 7pt;text-indent: 0pt;line-height: 9pt;text-align: right;">34K</p></td><td style="width:22pt"><p class="s20" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">2K</p></td></tr><tr style="height:10pt"><td style="width:37pt"><p class="s20" style="padding-left: 2pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Stack</p></td><td style="width:36pt"><p class="s20" style="padding-right: 7pt;text-indent: 0pt;line-height: 9pt;text-align: right;">28K</p></td><td style="width:22pt"><p class="s20" style="padding-right: 2pt;text-indent: 0pt;line-height: 9pt;text-align: right;">2K</p></td></tr></table><p style="padding-top: 4pt;padding-left: 21pt;text-indent: 0pt;text-align: center;">Table 16.1: <b>Segment Register Values</b></p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">You can see from the table that the code segment is placed at physical address 32KB and has a size of 2KB and the heap segment is placed at 34KB and also has a size of 2KB.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let’s do an example translation, using the address space in Figure <span style=" color: #00AEEF;">16.1</span>. Assume a reference is made to virtual address 100 (which is in the code segment). When the reference takes place (say, on an instruction fetch), the hardware will add the base value to the <i>offset </i>into this segment (100 in this case) to arrive at the desired physical address: 100 + 32KB, or 32868. It will then check that the address is within bounds (100 is less than 2KB), find that it is, and issue the reference to physical memory address 32868.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 79pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>T<span class="s45">HE </span>S<span class="s45">EGMENTATION </span>F<span class="s45">AULT</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The term segmentation fault or violation arises from a memory access on a segmented machine to an illegal address. Humorously, the term persists, even on machines with no support for segmentation at all. Or not so humorously, if you can’t figure why your code keeps faulting.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Now let’s look at an address in the heap, virtual address 4200 (again refer to Figure <span style=" color: #00AEEF;">16.1</span>). If we just add the virtual address 4200 to the base of the heap (34KB), we get a physical address of 39016, which is <i>not </i>the correct physical address. What we need to first do is extract the <i>offset </i>into the heap, i.e., which byte(s) <i>in this segment </i>the address refers to. Because the heap starts at virtual address 4KB (4096), the offset of 4200 is actually 4200 – 4096 or 104. We then take this offset (104) and add it to the base register physical address (34K or 34816) to get the desired result: 34920.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">What if we tried to refer to an illegal address, such as 7KB which is be- yond the end of the heap? You can imagine what will happen: the hard- ware detects that the address is out of bounds, traps into the OS, likely leading to the termination of the offending process. And now you know the origin of the famous term that all C programmers learn to dread: the <b>segmentation violation </b>or <b>segmentation fault</b>.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part150.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part152.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
