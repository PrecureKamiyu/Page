<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>7.4 Shortest Job First (SJF)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part68.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part70.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">7.4 Shortest Job First (SJF)</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">It turns out that a very simple approach solves this problem; in fact it is an idea stolen from operations research [C54,PV56] and applied to scheduling of jobs in computer systems. This new scheduling discipline is known as <b>Shortest Job First (SJF)</b>, and the name should be easy to remember because it describes the policy quite completely: it runs the shortest job first, then the next shortest, and so on.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-bottom: 1pt;padding-left: 16pt;text-indent: 0pt;text-align: center;">B  C         A</p><p style="padding-left: 133pt;text-indent: 0pt;text-align: left;"><span><img width="209" height="47" alt="image" src="Image_045.png"/></span></p><p class="s47" style="padding-left: 54pt;text-indent: 0pt;text-align: center;">0   20   40   60   80   100  120</p><p class="s47" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Time</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 149pt;text-indent: 0pt;text-align: left;">Figure 7.3: <b>SJF Simple Example</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s62" style="text-indent: 0pt;line-height: 6pt;text-align: left;">3</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 68pt;text-indent: 12pt;line-height: 91%;text-align: justify;">Let’s take our example above but with SJF as our scheduling policy. Figure <span style=" color: #00AEEF;">7.3 </span>shows the results of running A, B, and C. Hopefully the dia- gram makes it clear why SJF performs much better with regards to aver- age turnaround time. Simply by running B and C before A, SJF reduces average turnaround from 110 seconds to 50 ( <span class="s63">10+20+120</span><span class="s64"> </span><span class="s44">= 50</span>), more than</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 10pt;text-align: left;">a factor of two improvement.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">In fact, given our assumptions about jobs all arriving at the same time, we could prove that SJF is indeed an <b>optimal </b>scheduling algorithm. How-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_046.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 92%;text-align: left;">2<span class="s12">Recommended action in this case: either quickly switch to a different line, or take a long, deep, and relaxing breath. That’s right, breathe in, breathe out. It will be OK, don’t worry.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 82pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A<span class="s7">SIDE</span>: <b>P</b><span class="s45">REEMPTIVE </span><b>S</b><span class="s45">CHEDULERS</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In the old days of batch computing, a number of <b>non-preemptive </b>sched- ulers were developed; such systems would run each job to completion before considering whether to run a new job. Virtually all modern sched- ulers are <b>preemptive</b>, and quite willing to stop one process from run- ning in order to run another. This implies that the scheduler employs the mechanisms we learned about previously; in particular, the scheduler can perform a <b>context switch</b>, stopping one running process temporarily and resuming (or starting) another.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">ever, you are in a systems class, not theory or operations research; no proofs are allowed.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus we arrive upon a good approach to scheduling with SJF, but our assumptions are still fairly unrealistic. Let’s relax another. In particular, we can target assumption 2, and now assume that jobs can arrive at any time instead of all at once. What problems does this lead to?</p><p class="s6" style="padding-left: 52pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">(Another pause to think ... are you thinking? Come on, you can do it)</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Here we can illustrate the problem again with an example. This time, assume A arrives at <span class="s43">t </span><span class="s44">= 0 </span>and needs to run for 100 seconds, whereas B and C arrive at <span class="s43">t </span><span class="s44">= 10 </span>and each need to run for 10 seconds. With pure SJF, we’d get the schedule seen in Figure <span style=" color: #00AEEF;">7.4</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="209" height="58" alt="image" src="Image_047.png"/></span></p><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">A</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">B C</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 5pt;padding-left: 104pt;text-indent: 0pt;text-align: left;">[B,C arrive]</p><p class="s47" style="padding-left: 22pt;text-indent: 0pt;text-align: center;">0   20   40   60   80   100  120</p><p class="s47" style="padding-top: 1pt;padding-left: 18pt;text-indent: 0pt;text-align: center;">Time</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">Figure 7.4: <b>SJF With Late Arrivals From B and C</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s62" style="text-indent: 0pt;line-height: 6pt;text-align: left;">3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s63" style="padding-left: 41pt;text-indent: 11pt;line-height: 92%;text-align: justify;"><span class="p">As you can see from the figure, even though B and C arrived shortly after A, they still are forced to wait until A has completed, and thus suffer the same convoy problem. Average turnaround time for these three jobs is 103.33 seconds ( </span>100+(110<span class="s66">−</span>10)+(120<span class="s66">−</span>10)<span class="s64"> </span><span class="p">). What can a scheduler do?</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part68.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part70.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
