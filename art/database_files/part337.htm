<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.9  Weak Levels of Consistency in Practice</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part336.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part338.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark389">18.9  </a><span style=" color: #00AEEF;">Weak Levels of Consistency in Practice</span><a name="bookmark430">&zwnj;</a></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In Section 17.8, we discussed the isolation levels speciﬁed by the <span class="s44">SQL </span>standard: seri- alizable, repeatable read, read committed, and read uncommitted. In this section, we ﬁrst brieﬂy outline some older terminology relating to consistency levels weaker than serializability and relate it to the <span class="s44">SQL </span>standard levels. We then discuss the issue of con- currency control for transactions that involve user interaction, an issue that we brieﬂy discussed in Section 17.8.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">18.9.1 Degree-Two Consistency</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The purpose of <span class="s63">degree-two consistency </span>is to avoid cascading aborts without necessarily ensuring serializability. The locking protocol for degree-two consistency uses the same two lock modes that we used for the two-phase locking protocol: shared (S) and exclu- sive (X). A transaction must hold the appropriate lock mode when it accesses a data item, but two-phase behavior is not required.</p><p class="s13" style="padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="p">In contrast to the situation in two-phase locking, S-locks may be released at any time, and locks may be acquired at any time. Exclusive locks, however, cannot be re- leased until the transaction either commits or aborts. Serializability is not ensured by this protocol. Indeed, a transaction may read the same data item twice and obtain dif- ferent results. In Figure 18.21, </span>T<span class="s98">32</span><span class="p"> reads the value of </span>Q <span class="p">before that value is written by </span>T<span class="s93">33</span><span class="s94">, and again after it is written by </span>T<span class="s93">33</span><span class="s94">.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Reads are not repeatable, but since exclusive locks are held until transaction com-</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">mit, no transaction can read an uncommitted value. Thus, degree-two consistency is one particular implementation of the read-committed isolation level.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">It is interesting to note that with degree-two consistency, a transaction that is scan- ning an index may potentially see two versions of a record that was updated while the scan was in progress and may also potentially see neither version! For example,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:214.134pt" cellspacing="0"><tr style="height:18pt"><td style="width:60pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p class="s443" style="padding-top: 3pt;padding-left: 21pt;padding-right: 22pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s352">32</span></p></td><td style="width:59pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F" bgcolor="#C6E9FA"><p class="s443" style="padding-top: 3pt;padding-left: 5pt;padding-right: 5pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s352">33</span></p></td></tr><tr style="height:43pt"><td style="width:60pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><span class="s424">lock-S</span>(<i>Q</i>)</p><p class="s72" style="padding-left: 6pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s424">read</span>(<i>Q</i>) <span class="s424">unlock</span>(<i>Q</i>)</p></td><td style="width:59pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:52pt"><td style="width:60pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:59pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: left;"><span class="s424">lock-X</span>(<i>Q</i>) <span class="s424">read</span>(<i>Q</i>) <span class="s424">write</span>(<i>Q</i>)</p><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">unlock</span>(<i>Q</i>)</p></td></tr><tr style="height:40pt"><td style="width:60pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span class="s424">lock-S</span>(<i>Q</i>) <span class="s424">read</span>(<i>Q</i>) <span class="s424">unlock</span>(<i>Q</i>)</p></td><td style="width:59pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 18.21 <span class="s74">Nonserializable schedule with degree-two consistency.</span></p><p class="s66" style="padding-top: 3pt;padding-left: 281pt;text-indent: 0pt;text-align: left;">18.9 <span style=" color: #00AEEF;">Weak Levels of Consistency in Practice  </span><span class="s164">881</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">consider a relation <i>r</i>(<i>A</i>, <i>B</i>, <i>C</i>), with primary key <i>A</i>, with an index on attribute <i>B</i>. Now consider a query that is scanning the relation <i>r </i>using the index on attribute <i>B</i>, using degree-two consistency. Suppose there is a concurrent update to a tuple <i>t</i><span class="s98">1</span> <span class="s15">∈ </span><i>r </i>that</p><p class="s13" style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 70%;text-align: justify;"><span class="p">updates attribute </span>t<span class="s98">1</span><span class="s83">.</span>B <span class="p">from </span>v<span class="s98">1</span><span class="p"> to </span>v<span class="s98">2</span><span class="p">. Such an update requires deletion of an entry corre- sponding to value </span>v<span class="s98">1</span><span class="p"> from the index and insertion of a new entry corresponding to </span>v<span class="s98">2</span><span class="p">.</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Now, the scan of <i>r </i>could possibly scan the index node corresponding to <i>v</i><span class="s98">1</span> after the old tuple is deleted there but visit the index node corresponding to <i>v</i><span class="s98">2</span> before the updated tuple is inserted in that node. Then, the scan would completely miss the tuple, even though it should have seen either the old value or the new value of <i>t</i><span class="s98">1</span>. Further, a scan using degree-two consistency could possibly visit the node corresponding to <i>v</i><span class="s98">1</span> before the delete, and the node corresponding to <i>v</i><span class="s98">2</span> after the insert, and thereby see two ver- sions of <i>t</i><span class="s98">1</span>, one from before the update and one from after the update. (This problem would not arise if the scan and the update both used two-phase locking.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">18.9.2 Cursor Stability</p><p class="s63" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Cursor stability <span class="p">is a form of degree-two consistency designed for programs that iterate over tuples of a relation by using cursors. Instead of locking the entire relation, cursor stability ensures that:</span></p><p class="s39" style="padding-top: 10pt;padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s40">The tuple that is currently being processed by the iteration is locked in shared mode. Once the tuple is processed, the lock on the tuple can be released.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;text-align: left;">• <span class="s40">Any modiﬁed tuples are locked in exclusive mode until the transaction commits.</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">These rules ensure that degree-two consistency is obtained. But locking is not done in a two-phase manner, and serializability is not guaranteed. Cursor stability is used in practice on heavily accessed relations as a means of increasing concurrency and improving system performance. Applications that use cursor stability must be coded in a way that ensures database consistency despite the possibility of nonserializable schedules. Thus, the use of cursor stability is limited to specialized situations with simple consistency constraints.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">When supported by the database, snapshot isolation is a better alternative to degree-two consistency as well as cursor stability, since it oﬀers a similar or even better level of concurrency while reducing the risk of nonserializable executions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">18.9.3 Concurrency Control Across User Interactions</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Concurrency-control protocols usually consider transactions that do not involve user interaction. Consider the airline seat selection example from Section 17.8, which in- volved user interaction. Suppose we treat all the steps from when the seat availability is initially shown to the user, until the seat selection is conﬁrmed, as a single transaction. If two-phase locking is used, the entire set of seats on a ﬂight would be locked in shared mode until the user has completed the seat selection, and no other transaction would be able to update the seat allocation information in this period. Such locking</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">would be a very bad idea since a user may take a long time to make a selection, or even just abandon the transaction without explicitly cancelling it. Timestamp protocols or validation could be used instead, which avoid the problem of locking, but both these protocols would abort the transaction for a user <i>A </i>if any other user <i>B </i>has updated the seat allocation information, even if the seat selected by <i>B </i>does not conﬂict with the seat selected by user <i>A</i>. Snapshot isolation is a good option in this situation, since it would not abort the transaction of user <i>A </i>as long as <i>B </i>did not select the same seat as <i>A</i>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">However, snapshot isolation requires the database to remember information about updates performed by a transaction even after it has committed, as long as any other concurrent transaction is still active, which can be problematic for long-duration trans- actions.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Another option is to split a transaction that involves user interaction into two or more transactions, such that no transaction spans a user interaction. If our seat se- lection transaction is split thus, the ﬁrst transaction would read the seat availability, while the second transaction would complete the allocation of the selected seat. If the second transaction is written carelessly, it could assign the selected seat to the user, without checking if the seat was meanwhile assigned to some other user, resulting in a lost-update problem. To avoid the problem, as we outlined in Section 17.8, the sec- ond transaction should perform the seat allocation only if the seat was not meanwhile assigned to some other user.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3024.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The above idea has been generalized in an alternative concurrency control scheme, which uses version numbers stored in tuples to avoid lost updates. The schema of each relation is altered by adding an extra <i>version number </i>attribute, which is initialized to 0 when the tuple is created. When a transaction reads (for the ﬁrst time) a tuple that it intends to update, it remembers the version number of that tuple. The read is performed as a stand-alone transaction on the database, and hence any locks that may be obtained are released immediately. Updates are done locally and copied to the database as part of commit processing, using the following steps which are executed atomically (i.e., as part of a single database transaction):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">For each updated tuple, the transaction checks if the current version number is the same as the version number of the tuple when it was ﬁrst read by the transaction.</span></p><p class="s63" style="padding-top: 8pt;padding-left: 133pt;text-indent: -11pt;text-align: justify;">1. <span class="p">If the version numbers match, the update is performed on the tuple in the database, and its version number is incremented by 1.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 133pt;text-indent: -11pt;text-align: justify;">2. <span class="p">If the version numbers do not match, the transaction is aborted, rolling back all the updates it performed.</span></p><p class="s39" style="padding-top: 5pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">If the version number check succeeds for all updated tuples, the transaction com- mits. It is worth noting that a timestamp could be used instead of the version number without impacting the scheme in any way.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;"><a name="bookmark390">Observe the close similarity between the preceding scheme and snapshot isolation. The version number check implements the ﬁrst-committer-wins rule used in snapshot isolation, and it can be used even if the transaction was active for a very long time. However, unlike snapshot isolation, the reads performed by a transaction may not cor- respond to a snapshot of the database; and unlike the validation-based protocol, reads performed by the transaction are not validated.</a><a name="bookmark431">&zwnj;</a></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We refer to the above scheme as <span class="s63">optimistic concurrency control without read valida- tion</span>. Optimistic concurrency control without read validation provides a weak level of serializability, and it does not ensure serializability. A variant of this scheme uses ver- sion numbers to validate reads at the time of commit, in addition to validating writes, to ensure that the tuples read by the transaction were not updated subsequent to the initial read; this scheme is equivalent to the optimistic concurrency-control scheme which we saw earlier.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">This scheme has been widely used by application developers to handle transac- tions that involve user interaction. An attractive feature of the scheme is that it can be implemented easily on top of a database system. The validation and update steps performed as part of commit processing are then executed as a single transaction in the database, using the concurrency-control scheme of the database to ensure atomic- ity for commit processing. The scheme is also used by the Hibernate object-relational mapping system (Section 9.6.2), and other object-relational mapping systems, where it is referred to as optimistic concurrency control (even though reads are not validated by default). Hibernate and other object-relational mapping systems therefore perform the version number checks transparently as part of commit processing. (Transactions that involve user interaction are called <span class="s63">conversations </span>in Hibernate to diﬀerentiate them from regular transactions; validation using version numbers is particularly useful for such transactions.)</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Application developers must, however, be aware of the potential for non- serializable execution, and they must restrict their usage of the scheme to applications where non-serializability does not cause serious problems.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part336.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part338.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
