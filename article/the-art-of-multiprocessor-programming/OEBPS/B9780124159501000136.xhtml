<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 75" epub:type="pagebreak" id="page_75" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 4: Foundations of shared memory</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter begins our study of the foundations of concurrent computation by examining its most basic primitive, the read–write register. A register is a single location of shared memory. We characterize a register by the values it can store, the number of threads that can access it and what operations they can do, and the properties it guarantees. Starting from a one-bit register that supports only a single reader and a single writer, and guarantees the values read only if the read does not overlap a write, we present a series of constructions of increasingly powerful registers, culminating in an arbitrary-sized atomic multi-reader, multi-writer register. We also show how to use atomic registers to implement an atomic snapshot object, which can read multiple registers atomically.</p><p class="abspara">Although most of the algorithms presented in this chapter are impractical for real systems, they illustrate useful techniques for designing and reasoning about concurrent systems.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">read–write shared memory; atomic register; atomic snapshot; regular register; safe register; multi-reader multi-writer (MRMW) register; multi-reader single-writer (MRSW) register; single-reader single-writer (SRSW) register; concurrent computability</p></section></header><p class="textfl" id="p0010">For millennia, chicken farmers around the world were forced to wait 5 to 6 weeks before they could tell male and female chickens apart. This delay meant weeks of wasted time and money, because unlike females, which grow to maturity, lay eggs, and can ultimately be fried Kentucky style, the young males have no value, and are discarded. Then, in the 1920s, Japanese scientists discovered an invaluable trick: Male chicks have a small bump in their vent (anus) that females lack. If you press on a chick's behind and examine it, you can tell immediately which chicks should be discarded (no need to wait 5 weeks). The trouble was that a sizable fraction of males and females had bumps that were not clearcut, and could be either male or female. Thus began the profession of “chicken sexing.” Japan opened schools for training specialists who could sex on the order of 1000 chicks an hour with almost perfect accuracy. After proper training, expert chicken sexers could reliably determine the sex of day-old chicks at a glance using a collection of subtle perceptual cues. This profession continues to this day. In interviews, chicken sexers claim that in many cases they have no idea how they make their decisions. There is a technical name for this ability: <i>intuition</i>. Our unsettling example suggests that training and practice can enhance your intuition.</p><p class="text" id="p0015">In this chapter, we begin our study of the foundations of <i>concurrent shared-memory computation</i>. As you read through the algorithms, you might question their “real-world value.” If you do, remember that their value is in training you, the reader, to tell which types of algorithmic approaches work in a concurrent shared-memory setting, and which do not, even when it is hard to tell. This will help you discard bad ideas earlier, saving time and money.</p><p class="text" id="p0020">The foundations of sequential computing were established in the 1930s by Alan Turing and Alonzo Church, who independently formulated what has come to be known as the <i>Church–Turing thesis</i>: Anything that <i>can</i> be computed, can be computed by a Turing machine (or, equivalently, by Church's lambda calculus). Any problem that cannot be solved by a Turing machine (such as deciding whether a program halts on any input) is universally considered to be unsolvable by any kind of practical computing device. The Church–Turing thesis is a <i>thesis</i>, not a theorem, because the notion of “what is computable” is not defined in a precise, mathematically rigorous way. Nevertheless, just about everyone believes this thesis.</p><p class="text" id="p0025">To study concurrent shared-memory computation, we begin with a computational model. A shared-memory computation consists of multiple <i>threads</i>, each of which is a sequential program in its <span aria-label="Page 76" epub:type="pagebreak" id="page_76" role="doc-pagebreak"/>own right. These threads communicate by calling methods of objects that reside in a shared memory. Threads are <i>asynchronous</i>, meaning that they may run at different speeds, and any thread can halt for an unpredictable duration at any time. This notion of asynchrony reflects the realities of modern multiprocessor architectures, where thread delays are unpredictable, ranging from microseconds (cache misses) to milliseconds (page faults) to seconds (scheduling interruptions).</p><p class="text" id="p0030">The classical theory of sequential computability proceeds in stages. It starts with finite-state automata, moves on to push-down automata, and culminates in Turing machines. We, too, consider a progression of models for concurrent computing. We start with the simplest form of shared-memory computation: Concurrent threads read and write shared memory locations, which are called <i>registers</i> for historical reasons. We start with very simple registers, and we show how to use them to construct a series of more complex registers.</p><p class="text" id="p0035">The classical theory of sequential computability is, for the most part, not concerned with efficiency: To show that a problem is computable, it is enough to show that it can be solved by a Turing machine. There is little incentive to make such a Turing machine efficient, because a Turing machine is not a practical model of computation. In the same way, we make little attempt to make our register constructions efficient. We are interested in understanding whether such constructions exist and how they work. They are not intended to be practical. We prefer inefficient but easy-to-understand constructions over efficient but complicated ones.</p><p class="text" id="p0040">In particular, some of our constructions use <i>timestamps</i> (i.e., counter values) to distinguish older values from newer values. The problem with timestamps is that they grow without bound, and eventually overflow any fixed-size variable. Bounded solutions (such as the one in Section <a href="B9780124159501000112.xhtml">2.8</a>) are (arguably) more intellectually satisfying, and we encourage readers to investigate them further through the references provided in the chapter notes. Here, however, we focus on simpler, unbounded constructions, because they illustrate the fundamental principles of concurrent programming with less danger of becoming distracted by technicalities.</p><section><h2 class="h1hd" id="s0010"><a id="st0020"/>4.1 The space of registers</h2><p class="textfl" id="p0045">At the hardware level, threads communicate by reading and writing shared memory. A good way to understand interthread communication is to abstract away from hardware primitives, and to think about communication as happening through <i>shared concurrent objects</i>. Chapter <a href="B9780124159501000124.xhtml">3</a> provides a detailed description of shared objects. For now, it suffices to recall the two key properties of their design: <i>safety</i>, defined by consistency conditions, and <i>liveness</i>, defined by progress conditions.</p><p class="text" id="p0050">A <i>read–write register</i> (or just a <i>register</i>) is an object that encapsulates a value that can be observed by a <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() method and modified by a <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() method (these methods are often called <i>load</i> and <i>store</i>). <a href="#f0010" id="cf0010">Fig. 4.1</a> shows the <img alt="Image" height="11" src="images/B9780124159501000136/fx003.jpg" width="72"/> interface implemented by all registers. The type <img alt="Image" height="9" src="images/B9780124159501000136/fx004.jpg" width="5"/> of the value is typically <img alt="Image" height="9" src="images/B9780124159501000136/fx005.jpg" width="45"/>, <img alt="Image" height="11" src="images/B9780124159501000136/fx006.jpg" width="45"/>, or a reference to an object. A register that implements the <img alt="Image" height="11" src="images/B9780124159501000136/fx007.jpg" width="113"/> interface is called a <i>Boolean</i> register (sometimes <span aria-label="Page 77" epub:type="pagebreak" id="page_77" role="doc-pagebreak"/>1 and 0 are used as synonyms for <i>true</i> and <i>false</i>). A register that implements the <img alt="Image" height="11" src="images/B9780124159501000136/fx008.jpg" width="113"/> for a range of <i>M</i> integer values is called an <i>M-valued register</i>. We do not explicitly discuss any other kind of register, except to note that any algorithm that implements integer registers can be adapted to implement registers that hold references to other objects by representing the references as integers.</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="60" src="images/B9780124159501000136/gr001.jpg" width="198"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.1</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx003.jpg" width="72"/> interface.</div></figcaption></figure></div><p class="text" id="p0055">If method calls do not overlap, a register implementation should behave as shown in <a href="#f0015" id="cf0015">Fig. 4.2</a>. On a multiprocessor, however, we expect method calls to overlap all the time, so we need to specify what the concurrent method calls mean.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="142" src="images/B9780124159501000136/gr002.jpg" width="374"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.2</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx009.jpg" width="120"/> class.</div></figcaption></figure></div><p class="text" id="p0060">An <i>atomic register</i> is a linearizable implementation of the sequential register class shown in <a href="#f0015" id="cf0020">Fig. 4.2</a>. Informally, an atomic register behaves exactly as we would expect: Each read returns the “last” value written. A model in which threads communicate by reading and writing to atomic registers is intuitively appealing, and for a long time was the standard model of concurrent computation.</p><p class="text" id="p0065">One approach to implementing atomic registers is to rely on mutual exclusion: protect each register with a mutual exclusion lock acquired by each call to <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() or <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>(). Unfortunately, we cannot use the lock algorithms of Chapter <a href="B9780124159501000112.xhtml">2</a> here; those algorithms accomplish mutual exclusion using registers, so it makes little sense to implement registers using mutual exclusion. Moreover, as we saw in Chapter <a href="B9780124159501000124.xhtml">3</a>, using mutual exclusion, even if it is deadlock- or starvation-free, would mean that the computation's progress would depend on the operating system scheduler to guarantee that threads never get stuck in critical sections. Since we wish to examine the basic building blocks of concurrent computation using shared objects, it makes little sense to assume the existence of a separate entity to provide the key progress property.</p><p class="text" id="p0070"><span aria-label="Page 78" epub:type="pagebreak" id="page_78" role="doc-pagebreak"/>Here is a different approach: Recall that an object implementation is <i>wait-free</i> if each method call finishes in a finite number of steps, independently of how its execution is interleaved with steps of other concurrent method calls. The wait-free condition may seem simple and natural, but it has far-reaching consequences. In particular, it rules out any kind of mutual exclusion, and guarantees independent progress, that is, without making assumptions about the operating system scheduler. We therefore require our register implementations to be wait-free.</p><p class="text" id="p0075">It is also important to specify how many readers and writers are expected. Not surprisingly, it is easier to implement a register that supports only a single reader and a single writer than one that supports multiple readers and writers. For brevity, we use SRSW for “single-reader, single-writer,” MRSW for “multi-reader, single-writer,” and MRMW for “multi-reader, multi-writer.”</p><p class="text" id="p0080">In this chapter, we address the following fundamental question: </p><p class="quote" id="sp0135"><i>Can any data structure implemented using the most powerful registers also be implemented using the weakest?</i></p><p class="textfl"> Recall from Chapter <a href="B9780124159501000094.xhtml">1</a> that any useful form of interthread communication must be persistent: The message sent must outlive the active participation of the sender. The weakest form of persistent synchronization is (arguably) the ability to set a single persistent bit in shared memory, and the weakest form of synchronization is (unarguably) none at all: If the act of setting a bit does not overlap the act of reading that bit, then the value read is the same as the value written. Otherwise, a read overlapping a write could return any value.</p><p class="text" id="p0085">Different kinds of registers come with different guarantees that make them more or less powerful. For example, we have seen that registers may differ in the range of values they may encapsulate (e.g., Boolean versus <i>M</i>-valued), and in the number of readers and writers they support. They may also differ in the degree of consistency they provide.</p><p class="text" id="p0090">An SRSW or MRSW register implementation is <i>safe</i> if:</p><div><ul><li class="bulllist" id="u0010">•  A <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call that does not overlap a <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call returns the value written by the most recent <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call. (The “most recent <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call” is well defined because there is a single writer.)</li><li class="bulllist" id="u0015">•  A <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call that overlaps a <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call may return any value within the register's allowed range of values (e.g., 0 to <span class="hiddenClass"><mml:math><mml:mi>M</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si1.png" style="vertical-align:middle" width="43"/></span> for an <i>M</i>-valued register).</li></ul></div><p class="textfl"> Be aware that the term “safe” is a historical accident. Because they provide such weak guarantees, “safe” registers are actually quite unsafe.</p><p class="text" id="p0105">Consider the history shown in <a href="#f0020" id="cf0025">Fig. 4.3</a>. If the register is <i>safe</i>, then the three read calls might behave as follows:</p><div><ul><li class="bulllist" id="u0020">•  <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si7.png" style="vertical-align:middle" width="19"/></span> returns 0, the most recently written value.</li><li class="bulllist" id="u0025">•  <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si8.png" style="vertical-align:middle" width="20"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si9.png" style="vertical-align:middle" width="20"/></span> are concurrent with <span class="hiddenClass"><mml:math><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si10.png" style="vertical-align:middle" width="36"/></span>, so they may return any value in the range of the register. <span aria-label="Page 79" epub:type="pagebreak" id="page_79" role="doc-pagebreak"/></li></ul></div><p class="textfl"/><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="99" src="images/B9780124159501000136/gr003.jpg" width="436"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.3</span> An SRSW register execution: <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">i</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si2.png" style="vertical-align:middle" width="17"/></span> is the <i>i</i>-th read and <i>W(v)</i> is a write of value <i>v</i>. Time flows from left to right. No matter whether the register is <i>safe</i>, <i>regular</i>, or <i>atomic</i>, <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">1</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si3.png" style="vertical-align:middle" width="20"/></span> must return 0, the most recently written value. If the register is <i>safe</i>, then because <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si4.png" style="vertical-align:middle" width="20"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">3</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si5.png" style="vertical-align:middle" width="20"/></span> are concurrent with <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">W</mml:mtext><mml:mtext mathvariant="sans-serif">(1)</mml:mtext></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si6.png" style="vertical-align:middle" width="35"/></span>, they may return any value in the range of the register. If the register is <i>regular</i>, <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si4.png" style="vertical-align:middle" width="20"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">3</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si5.png" style="vertical-align:middle" width="20"/></span> may each return either 0 or 1. If the register is <i>atomic</i>, then if <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si4.png" style="vertical-align:middle" width="20"/></span> returns 1, then <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">3</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si5.png" style="vertical-align:middle" width="20"/></span> must also return 1, and if <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si4.png" style="vertical-align:middle" width="20"/></span> returns 0, then <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="sans-serif">3</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si5.png" style="vertical-align:middle" width="20"/></span> may return 0 or 1.</div></figcaption></figure></div><p class="text" id="p0120">It is convenient to define an intermediate level of consistency between safe and atomic. A <i>regular</i> register is an SRSW or MRSW register where writes do not happen atomically. Instead, while the <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call is in progress, the value being read may “flicker” between the old and new value before finally replacing the older value. More precisely:</p><div><ul><li class="bulllist" id="u0030">•  A regular register is safe, so any <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call that does not overlap a <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call returns the most recently written value.</li><li class="bulllist" id="u0035">•  Suppose a <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call overlaps one or more <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() calls. Let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si11.png" style="vertical-align:middle" width="17"/></span> be the value written by the latest preceding <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call, and let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000136/si12.png" style="vertical-align:middle" width="67"/></span> be the sequence of values written by <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() calls that overlap the <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call. The <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call may return <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si13.png" style="vertical-align:middle" width="14"/></span> for any <i>i</i> in the range <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>…</mml:mo><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000136/si14.png" style="vertical-align:middle" width="41"/></span>.</li></ul></div><p class="textfl"> For the execution in <a href="#f0020" id="cf0030">Fig. 4.3</a>, a regular register might behave as follows:</p><div><ul><li class="bulllist" id="u0040">•  <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si7.png" style="vertical-align:middle" width="19"/></span> returns the old value, 0.</li><li class="bulllist" id="u0045">•  <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si8.png" style="vertical-align:middle" width="20"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si9.png" style="vertical-align:middle" width="20"/></span> each return either the old value 0 or the new value 1.</li></ul></div><p class="textfl"> Regular registers are quiescently consistent (Chapter <a href="B9780124159501000124.xhtml">3</a>), but not vice versa. Both safe and regular registers permit only a single writer. Note that a regular register is actually a quiescently consistent single-writer sequential register.</p><p class="text" id="p0145">For an atomic register, the execution in <a href="#f0020" id="cf0035">Fig. 4.3</a> might produce the following results:</p><div><ul><li class="bulllist" id="u0050">•  <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si7.png" style="vertical-align:middle" width="19"/></span> returns the old value, 0.</li><li class="bulllist" id="u0055">•  If <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si8.png" style="vertical-align:middle" width="20"/></span> returns 1, then <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si9.png" style="vertical-align:middle" width="20"/></span> also returns 1.</li><li class="bulllist" id="u0060">•  If <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si8.png" style="vertical-align:middle" width="20"/></span> returns 0, then <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si9.png" style="vertical-align:middle" width="20"/></span> returns either 0 or 1.</li></ul></div><p class="textfl"/><p class="text" id="p0165"><a href="#f0025" id="cf0040">Fig. 4.4</a> shows a schematic view of the range of possible registers as a three-dimensional space: The register size defines one dimension, the numbers of readers and writers define another, and the <span aria-label="Page 80" epub:type="pagebreak" id="page_80" role="doc-pagebreak"/>register's consistency property defines the third. This view should not be taken literally: There are several combinations, such as multi-writer safe registers, that are not well defined.</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="235" src="images/B9780124159501000136/gr004.jpg" width="236"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.4</span> The three-dimensional space of possible read–write register-based implementations.</div></figcaption></figure></div><p class="text" id="p0170">To reason about algorithms for implementing regular and atomic registers, it is convenient to rephrase our definitions directly in terms of object histories. From now on, we consider only histories in which each <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call returns a value written by some <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call (regular and atomic registers do not allow reads to make up return values). For simplicity, we assume values read or written are unique.<sup><a epub:type="noteref" href="#fn001" id="cf0045" role="doc-noteref">1</a></sup></p><p class="text" id="p0175">Recall that an object history is a sequence of <i>invocation</i> and <i>response</i> events, where an invocation event occurs when a thread calls a method, and a matching response event occurs when that call returns. A <i>method call</i> (or just a <i>call</i>) is the interval between matching invocation and response events (including the invocation and response events). Any history induces a partial order →  on method calls, defined as follows: If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000136/si15.png" style="vertical-align:middle" width="22"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000136/si16.png" style="vertical-align:middle" width="21"/></span> are method calls, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">→</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000136/si17.png" style="vertical-align:middle" width="65"/></span> if <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000136/si15.png" style="vertical-align:middle" width="22"/></span>'s response event precedes <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000136/si16.png" style="vertical-align:middle" width="21"/></span>'s call event. (See Chapter <a href="B9780124159501000124.xhtml">3</a> for complete definitions.)</p><p class="text" id="p0180">Any register implementation (whether safe, regular, or atomic) defines a total order on the <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() calls called the <i>write order</i>, the order in which writes “take effect” in the register. For safe and regular registers, the write order is trivial because they allow only one writer at a time. For atomic registers, method calls have a linearization order. We use this order to index the write calls: Write call <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si18.png" style="vertical-align:middle" width="23"/></span> is ordered first, <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si19.png" style="vertical-align:middle" width="22"/></span> second, and so on. We use <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si13.png" style="vertical-align:middle" width="14"/></span> to denote the unique value written by <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si20.png" style="vertical-align:middle" width="20"/></span>. Note that for SRSW or MRSW safe or regular registers, the write order is exactly the same as the precedence order on writes.</p><p class="text" id="p0185"><span aria-label="Page 81" epub:type="pagebreak" id="page_81" role="doc-pagebreak"/>We use <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si21.png" style="vertical-align:middle" width="18"/></span> to denote any read call that returns <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si13.png" style="vertical-align:middle" width="14"/></span>. Note that although a history contains at most one <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si20.png" style="vertical-align:middle" width="20"/></span> call, it might contain multiple <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si21.png" style="vertical-align:middle" width="18"/></span> calls.</p><p class="text" id="p0190">One can show that the following conditions provide a precise statement of what it means for a register to be regular. First, no read call returns a value from the future:</p><p class="hiddenClass"><mml:math><mml:mrow><mml:mtext>It is never the case that</mml:mtext><mml:mspace width="1.00em"/></mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">→</mml:mo><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="20" src="images/B9780124159501000136/si22.png" width="315"/><a id="deq1"/><span class="eqnum">(4.1.1) </span></p></div><p class="textfl"> Second, no read call returns a value from the distant past, that is, one that precedes the most recently written nonoverlapping value:</p><p class="hiddenClass"><mml:math><mml:mrow><mml:mtext>It is never the case that for some </mml:mtext><mml:mi>j</mml:mi><mml:mtext>, </mml:mtext><mml:mspace width="1.00em"/></mml:mrow><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">→</mml:mo><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">→</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="24" src="images/B9780124159501000136/si23.png" width="492"/><a id="deq2"/><span class="eqnum">(4.1.2) </span></p></div><p class="textfl"> To prove that a register implementation is regular, we must show that its histories satisfy Conditions <a href="#deq1" id="cf0050">(4.1.1)</a> and <a href="#deq2" id="cf0055">(4.1.2)</a>.</p><p class="text" id="p0195">An atomic register satisfies one additional condition:</p><p class="hiddenClass"><mml:math><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="0.25em"/><mml:mspace width="1.00em"/></mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">→</mml:mo><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mtext>then</mml:mtext><mml:mspace width="1em"/><mml:mi>i</mml:mi><mml:mo>⩽</mml:mo><mml:mi>j</mml:mi><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="24" src="images/B9780124159501000136/si24.png" width="267"/><a id="deq3"/><span class="eqnum">(4.1.3) </span></p></div><p class="textfl"> This condition states that an earlier read cannot return a value later than that returned by a later read. Regular registers are <i>not</i> required to satisfy Condition <a href="#deq3" id="cf0060">(4.1.3)</a>. To show that a register implementation is atomic, we need first to define a write order, and then to show that its histories satisfy Conditions <a href="#deq1" id="cf0065">(4.1.1)</a>–<a href="#deq3" id="cf0070">(4.1.3)</a>.</p></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>4.2 Register constructions</h2><p class="textfl" id="p0200">We now show how to implement a range of surprisingly powerful registers from simple safe Boolean SRSW registers. We consider a series of constructions, shown in <a href="#f0030" id="cf0075">Fig. 4.5</a>, that implement stronger from weaker registers. These constructions imply that all read–write register types are equivalent, at least in terms of computability.</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="154" src="images/B9780124159501000136/gr005.jpg" width="404"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.5</span> The sequence of register constructions.</div></figcaption></figure></div><p class="text" id="p0205">In the last step, we show how atomic registers (and therefore safe registers) can implement an atomic snapshot: an array of MRSW registers written by different threads that can be read atomically by any thread.</p><p class="text" id="p0210"><span aria-label="Page 82" epub:type="pagebreak" id="page_82" role="doc-pagebreak"/>Some of these constructions are more powerful than necessary to complete the sequence of derivations (for example, we do not need to provide the multi-reader property for regular and safe registers to complete the derivation of an atomic SRSW register). We present them anyway because they provide valuable insights.</p><p class="text" id="p0215">Our code samples follow these conventions. When we display an algorithm to implement a particular kind of register, say, a safe Boolean MRSW register, we present the algorithm using a form somewhat like this:</p><p class="text" id="p0220"/><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" class="img" height="59" src="images/B9780124159501000136/fx010.jpg" width="350"/></figure></div><p class="textfl"/><p class="text" id="p0225">While this notation makes clear the properties of the <img alt="Image" height="11" src="images/B9780124159501000136/fx011.jpg" width="66"/> class being implemented, it becomes cumbersome when we want to use this class to implement other classes. Instead, when describing a class implementation, we use the following conventions to indicate whether a particular field is safe, regular, or atomic: A field otherwise named <img alt="Image" height="9" src="images/B9780124159501000136/fx012.jpg" width="39"/> is called <img alt="Image" height="13" src="images/B9780124159501000136/fx013.jpg" width="52"/> if it is safe, <img alt="Image" height="13" src="images/B9780124159501000136/fx014.jpg" width="52"/> if it is regular, and <img alt="Image" height="13" src="images/B9780124159501000136/fx015.jpg" width="52"/> if it is atomic. Other important aspects of the field, such as its type and whether it supports multiple readers or writers, are noted as comments within the code, and should also be clear from the context.</p><section><h3 class="h2hd" id="s0020"><a id="st0030"/>4.2.1 Safe MRSW registers</h3><p class="textfl" id="p0230"><a href="#f0040" id="cf0080">Fig. 4.6</a> shows how to construct a safe MRSW register from safe SRSW registers.</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="208" src="images/B9780124159501000136/gr006.jpg" width="425"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.6</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx016.jpg" width="154"/> class: a safe Boolean MRSW register.</div></figcaption></figure></div><p class="text" id="p0235"/><div class="boxg1" id="enun0010"><p class="b1num">Lemma 4.2.1 </p><div><p class="b1textfl" id="p0240">The construction in <a href="#f0040" id="cf0085">Fig. 4.6</a> is a <i>safe MRSW register</i>.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0015"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0245">If <i>A</i>'s <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call does not overlap any <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call, then it does not overlap any <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call of the component register <img alt="Image" height="13" src="images/B9780124159501000136/fx017.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si25.png" style="vertical-align:middle" width="23"/></span>, <span aria-label="Page 83" epub:type="pagebreak" id="page_83" role="doc-pagebreak"/>so the <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call returns the value of <img alt="Image" height="13" src="images/B9780124159501000136/fx017.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si25.png" style="vertical-align:middle" width="23"/></span>, which is the most recently written value. If <i>A</i>'s <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call overlaps a <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call, it is allowed to return any value. □</p></div></div><p class="textfl"/></section><section><h3 class="h2hd" id="s0025"><a id="st0035"/>4.2.2 A regular Boolean MRSW register</h3><p class="textfl" id="p0250">The next construction, shown in <a href="#f0045" id="cf0090">Fig. 4.7</a>, builds a regular Boolean MRSW register from a safe Boolean MRSW register. For Boolean registers, the only difference between safe and regular registers arises when the newly written value <i>x</i> is the same as the old. A regular register can only return <i>x</i>, while a safe register may return either Boolean value. We circumvent this problem simply by ensuring that a value is written only if it is distinct from the previously written value.</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="290" src="images/B9780124159501000136/gr007.jpg" width="443"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.7</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx018.jpg" width="173"/> class: a regular Boolean MRSW register constructed from a safe Boolean MRSW register.</div></figcaption></figure></div><p class="text" id="p0255"/><div class="boxg1" id="enun0020"><p class="b1num">Lemma 4.2.2 </p><div><p class="b1textfl" id="p0260">The construction in <a href="#f0045" id="cf0095">Fig. 4.7</a> is a regular Boolean MRSW register.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0025"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0265">A <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call that does not overlap any <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call returns the most recently written value. If the calls do overlap, there are two cases to consider:</p><div><ul><li class="b1bulllist" id="u0065">•  If the value being written is the same as the last value written, then the writer avoids writing to the safe register, ensuring that the reader reads the correct value.</li><li class="b1bulllist" id="u0070">•  If the value written now is distinct from the last value written, then those values must be <i>true</i> and <i>false</i> because the register is Boolean. A concurrent read returns some value in the range of the register, namely, either <i>true</i> or <i>false</i>, either of which is correct. □<span aria-label="Page 84" epub:type="pagebreak" id="page_84" role="doc-pagebreak"/></li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/></section><section><h3 class="h2hd" id="s0030"><a id="st0040"/>4.2.3 A regular <i>M</i>-valued MRSW register</h3><p class="textfl" id="p0280">The jump from Boolean to <i>M</i>-valued registers is simple, if astonishingly inefficient: We represent the value in unary notation. In <a href="#f0050" id="cf0100">Fig. 4.8</a>, we implement an <i>M</i>-valued register as an array of <i>M</i> Boolean registers. Initially the register is set to value zero, indicated by the 0th bit being set to <i>true</i>. A write method of value <i>x</i> writes <i>true</i> in location <i>x</i> and then in descending array-index order sets all lower locations to <i>false</i>. A reading method reads the locations in ascending index order until the first time it reads the value <i>true</i> in some index <i>i</i>. It then returns <i>i</i>. The example in <a href="#f0055" id="cf0105">Fig. 4.9</a> illustrates an <i>8-valued</i> register.</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="339" src="images/B9780124159501000136/gr008.jpg" width="412"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.8</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx019.jpg" width="126"/> class: a regular <i>M</i>-valued MRSW register.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="324" src="images/B9780124159501000136/gr009.jpg" width="327"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.9</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx019.jpg" width="126"/> class: an execution of a regular <i>8-valued</i> MRSW register. The values <i>false</i> and <i>true</i> are represented by 0 and 1 respectively. In part (a), the value prior to the write was 4, and thread <i>W</i><span style="display:inline-block; width: 0.20em;"/>'s write of 7 is not read by thread <i>R</i> because <i>R</i> reaches array entry 4 before <i>W</i> overwrites <i>false</i> at that location. In part (b), entry 4 is overwritten by <i>W</i> before it is read, so the read returns 7. In part (c), <i>W</i> starts to write 5. Since it wrote array entry 5 before it was read, the reader returns 5 even though entry 7 is also set to <i>true</i>.</div></figcaption></figure></div><p class="text" id="p0285"/><div class="boxg1" id="enun0030"><p class="b1num">Lemma 4.2.3 </p><div><p class="b1textfl" id="p0290">The <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call in the construction in <a href="#f0050" id="cf0110">Fig. 4.8</a> always returns a value corresponding to a bit in 0..<span class="hiddenClass"><mml:math><mml:mi>M</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si1.png" style="vertical-align:middle" width="43"/></span> set by some <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0035"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0295">The following property is invariant: If a reading thread is reading <img alt="Image" height="13" src="images/B9780124159501000136/fx020.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si26.png" style="vertical-align:middle" width="20"/></span>, then some bit at index <i>j</i> or higher, written by a <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call, is set to <i>true</i>.</p><p class="b1text" id="p0300">When the register is initialized, there are no readers; the constructor sets <img alt="Image" height="13" src="images/B9780124159501000136/fx020.jpg" width="32"/>[0] to <i>true</i>. Assume a reader is reading <img alt="Image" height="13" src="images/B9780124159501000136/fx020.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si26.png" style="vertical-align:middle" width="20"/></span>, and that <img alt="Image" height="13" src="images/B9780124159501000136/fx020.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si27.png" style="vertical-align:middle" width="19"/></span> is <i>true</i> for <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo>⩾</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si28.png" style="vertical-align:middle" width="37"/></span>.</p><div><ul><li class="b1bulllist" id="u0075">•  If the reader advances from <i>j</i> to <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si29.png" style="vertical-align:middle" width="36"/></span>, then <img alt="Image" height="13" src="images/B9780124159501000136/fx020.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si26.png" style="vertical-align:middle" width="20"/></span> is <i>false</i>, so <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si30.png" style="vertical-align:middle" width="38"/></span> (i.e., a bit greater than or equal to <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si29.png" style="vertical-align:middle" width="36"/></span> is <i>true</i>).</li><li class="b1bulllist" id="u0080">•  The writer clears <img alt="Image" height="13" src="images/B9780124159501000136/fx020.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si27.png" style="vertical-align:middle" width="19"/></span> only if it has set a higher <img alt="Image" height="13" src="images/B9780124159501000136/fx020.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si31.png" style="vertical-align:middle" width="19"/></span> to <i>true</i> for <span class="hiddenClass"><mml:math><mml:mi>ℓ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000136/si32.png" style="vertical-align:middle" width="37"/></span>. □<span aria-label="Page 85" epub:type="pagebreak" id="page_85" role="doc-pagebreak"/></li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0315"/><div class="boxg1" id="enun0040"><p class="b1num">Lemma 4.2.4 </p><div><p class="b1textfl" id="p0320">The construction in <a href="#f0050" id="cf0115">Fig. 4.8</a> is a regular <i>M</i>-valued MRSW register.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0045"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0325">For any read, let <i>x</i> be the value written by the most recent nonoverlapping <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>(). At the time the <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() completed, <img alt="Image" height="13" src="images/B9780124159501000136/fx021.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si33.png" style="vertical-align:middle" width="20"/></span> was set to <i>true</i>, and <img alt="Image" height="13" src="images/B9780124159501000136/fx021.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si34.png" style="vertical-align:middle" width="17"/></span> is <i>false</i> for <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>x</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si35.png" style="vertical-align:middle" width="35"/></span>. By <a href="#enun0030" id="cf0120">Lemma 4.2.3</a>, if the reader returns a value that is not <i>x</i>, then it observed some <img alt="Image" height="13" src="images/B9780124159501000136/fx021.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si26.png" style="vertical-align:middle" width="20"/></span>, <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>x</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si36.png" style="vertical-align:middle" width="38"/></span>, to be <i>true</i>, and that bit must have been set by a concurrent write, proving Conditions <a href="#deq1" id="cf0125">(4.1.1)</a> and <a href="#deq2" id="cf0130">(4.1.2)</a>. □</p></div></div><p class="textfl"/></section><section><h3 class="h2hd" id="s0035"><a id="st0045"/>4.2.4 An atomic SRSW register</h3><p class="textfl" id="p0330">We show how to construct an atomic SRSW register from a regular SRSW register. (Note that our construction uses unbounded timestamps.)</p><p class="text" id="p0335">A regular register satisfies Conditions <a href="#deq1" id="cf0135">(4.1.1)</a> and <a href="#deq2" id="cf0140">(4.1.2)</a>, while an atomic register must also satisfy Condition <a href="#deq3" id="cf0145">(4.1.3)</a>. Since a regular SRSW register has no concurrent reads, the only way Condition <a href="#deq3" id="cf0150">(4.1.3)</a> can be violated is if two reads that overlap the same write read values out-of-order, the first returning <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si13.png" style="vertical-align:middle" width="14"/></span> and the latter returning <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si37.png" style="vertical-align:middle" width="17"/></span>, where <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>i</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si38.png" style="vertical-align:middle" width="34"/></span>.</p><p class="text" id="p0340"><a href="#f0060" id="cf0155">Fig. 4.10</a> describes a class of values that each have an added tag that contains a timestamp. Our implementation of an <img alt="Image" height="11" src="images/B9780124159501000136/fx022.jpg" width="120"/>, shown in <a href="#f0065" id="cf0160">Fig. 4.11</a>, <span aria-label="Page 86" epub:type="pagebreak" id="page_86" role="doc-pagebreak"/>uses these tags to order write calls so that they can be ordered properly by concurrent read calls. Each read remembers the latest (highest timestamp) timestamp/value pair ever read, so that it is available to future reads. If a later read then reads an earlier value (one having a lower timestamp), it ignores that value and simply uses the remembered latest value. Similarly, the writer remembers the latest timestamp it wrote, and tags each newly written value with a later timestamp (i.e., a timestamp greater by 1).</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="355" src="images/B9780124159501000136/gr010.jpg" width="419"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.10</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx023.jpg" width="100"/> class: allows a timestamp and a value to be read or written together.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="421" src="images/B9780124159501000136/gr011.jpg" width="469"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.11</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx022.jpg" width="120"/> class: an atomic SRSW register constructed from a regular SRSW register.</div></figcaption></figure></div><p class="text" id="p0345">This algorithm requires the ability to read or write a value and a timestamp as a single unit. In a language such as C, we would treat both the value and the timestamp as uninterpreted bits (“raw seething bits”), and use bit shifting and logical masking to pack and unpack both values in and out of one or more words. In Java, it is easier to create a <img alt="Image" height="11" src="images/B9780124159501000136/fx023.jpg" width="100"/> structure that holds a timestamp/value pair, and to store a <i>reference</i> to that structure in the register.</p><p class="text" id="p0350"/><div class="boxg1" id="enun0050"><p class="b1num">Lemma 4.2.5 </p><div><p class="b1textfl" id="p0355">The construction in <a href="#f0065" id="cf0165">Fig. 4.11</a> is an atomic SRSW register.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0055"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0360">The register is regular, so Conditions <a href="#deq1" id="cf0170">(4.1.1)</a> and <a href="#deq2" id="cf0175">(4.1.2)</a> are met. The algorithm satisfies Condition <a href="#deq3" id="cf0180">(4.1.3)</a> because writes are totally ordered by their timestamps, and if a read returns a given value, a later read cannot read an earlier written value, since it would have a lower timestamp.  □</p></div></div><p class="textfl"><span aria-label="Page 87" epub:type="pagebreak" id="page_87" role="doc-pagebreak"/><span aria-label="Page 88" epub:type="pagebreak" id="page_88" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0040"><a id="st0050"/>4.2.5 An atomic MRSW register</h3><p class="textfl" id="p0365">To understand how to construct an atomic MRSW register from atomic SRSW registers, we first consider a simple algorithm based on direct use of the construction in Section <a href="#s0020" id="cf0185">4.2.1</a>, which took us from safe SRSW to safe MRSW registers. Let the SRSW registers composing the table array <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si39.png" style="vertical-align:middle" width="63"/></span> be atomic instead of safe, with all other calls remaining the same: The writer writes the array locations in increasing index order and then each reader reads and returns its associated array entry. The result is not an atomic multi-reader register. Condition <a href="#deq3" id="cf0190">(4.1.3)</a> holds for any single reader because each reader reads from an atomic register, yet it does not hold for distinct readers. Consider, for example, a write that starts by setting the first SRSW register <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/>[0], and is delayed before writing the remaining locations <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si40.png" style="vertical-align:middle" width="63"/></span>. A subsequent read by thread 0 returns the correct new value, but a subsequent read by thread 1 that completely follows the read by thread 0 reads and returns the earlier value because the writer has yet to update <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si40.png" style="vertical-align:middle" width="63"/></span>. We address this problem by having earlier reader threads <i>help out</i> later threads by telling them which value they read.</p><p class="text" id="p0370">This implementation appears in <a href="#f0070" id="cf0195">Fig. 4.12</a>. The <i>n</i> threads share an <i>n</i>-by-<i>n</i> array <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si41.png" style="vertical-align:middle" width="126"/></span> of stamped values. As in Section <a href="#s0035" id="cf0200">4.2.4</a>, we use timestamped values to allow early reads to tell later reads which of the values read <span aria-label="Page 89" epub:type="pagebreak" id="page_89" role="doc-pagebreak"/>is the latest. The locations along the diagonal, <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si42.png" style="vertical-align:middle" width="34"/></span> for all <i>i</i>, correspond to the registers in the failed simple construction mentioned earlier. The writer simply writes the diagonal locations one after the other with a new value and a timestamp that increases from one <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call to the next. Each reader <i>A</i> first reads <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si43.png" style="vertical-align:middle" width="45"/></span> as in the earlier algorithm. It then uses the remaining SRSW locations <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si44.png" style="vertical-align:middle" width="45"/></span>, <span class="hiddenClass"><mml:math><mml:mi>A</mml:mi><mml:mo>≠</mml:mo><mml:mi>B</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si45.png" style="vertical-align:middle" width="44"/></span>, for communication between readers <i>A</i> and <i>B</i>. Each reader <i>A</i>, after reading <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si43.png" style="vertical-align:middle" width="45"/></span>, checks to see if some other reader has read a later value by traversing its corresponding column (<img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si46.png" style="vertical-align:middle" width="45"/></span> for all <i>B</i>), and checking if it contains a later value (one with a higher timestamp). The reader then lets all later readers know the latest value it read by writing this value to all locations in its corresponding row (<img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si44.png" style="vertical-align:middle" width="45"/></span> for all <i>B</i>). It thus follows that after a read by <i>A</i> is completed, every later read by <i>B</i> sees the last value <i>A</i> read (since it reads <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si44.png" style="vertical-align:middle" width="45"/></span>). <a href="#f0075" id="cf0205">Fig. 4.13</a> shows an example execution of the algorithm.</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="586" src="images/B9780124159501000136/gr012.jpg" width="499"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.12</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx025.jpg" width="120"/> class: an atomic MRSW register constructed from atomic SRSW registers.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="208" src="images/B9780124159501000136/gr013.jpg" width="487"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.13</span> An execution of the atomic MRSW register. Each reader thread has an index between 0 and 3, and we refer to each thread by its index. Here, the writer writes a new value with timestamp <i>t<span style="display:inline-block; width: 0.20em;"/>+<span style="display:inline-block; width: 0.20em;"/></i>1 to locations <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">0</mml:mtext><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">0</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si47.png" style="vertical-align:middle" width="41"/></span> and <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">1</mml:mtext><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">1</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si48.png" style="vertical-align:middle" width="41"/></span> and then halts. Then, thread 1 reads its corresponding column <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="italic">i</mml:mtext><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">1</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si49.png" style="vertical-align:middle" width="36"/></span> for all <i>i</i>, and writes its corresponding row <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">1</mml:mtext><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="italic">i</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si50.png" style="vertical-align:middle" width="36"/></span> for all <i>i</i>, returning the new value with timestamp <i>t<span style="display:inline-block; width: 0.20em;"/>+<span style="display:inline-block; width: 0.20em;"/></i>1. Threads 0 and 3 both read completely after thread 1's read. Thread 0 reads <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">0</mml:mtext><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">0</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si47.png" style="vertical-align:middle" width="41"/></span> with value <i>t<span style="display:inline-block; width: 0.20em;"/>+<span style="display:inline-block; width: 0.20em;"/></i>1. Thread 3 cannot read the new value with timestamp <i>t<span style="display:inline-block; width: 0.20em;"/>+<span style="display:inline-block; width: 0.20em;"/></i>1 because the writer has yet to write <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">3</mml:mtext><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">3</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si51.png" style="vertical-align:middle" width="41"/></span>. Nevertheless, it reads <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">1</mml:mtext><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mtext mathvariant="sans-serif">3</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si52.png" style="vertical-align:middle" width="41"/></span> and returns the correct value with timestamp <i>t<span style="display:inline-block; width: 0.20em;"/>+<span style="display:inline-block; width: 0.20em;"/></i>1 that was read by the earlier thread 1.</div></figcaption></figure></div><p class="text" id="p0375"/><div class="boxg1" id="enun0060"><p class="b1num">Lemma 4.2.6 </p><div><p class="b1textfl" id="p0380">The construction in <a href="#f0070" id="cf0210">Fig. 4.12</a> is an atomic MRSW register.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0065"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0385">First, no reader returns a value from the future, so Condition <a href="#deq1" id="cf0215">(4.1.1)</a> is clearly satisfied. By construction, <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() calls write strictly increasing timestamps. The key to understanding this algorithm is the simple observation that the maximum timestamp along any row or column is also strictly increasing. If <i>A</i> writes <i>v</i> with timestamp <i>t</i>, then any subsequent <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call by <i>B</i> (where <i>A</i>'s call completely precedes <i>B</i>'s) reads (from the diagonal of <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/>) a maximum timestamp greater than or equal to <i>t</i>, satisfying Condition <a href="#deq2" id="cf0220">(4.1.2)</a>. Finally, as noted earlier, if a read call by <i>A</i> completely precedes a read call by <i>B</i>, then <i>A</i> writes a stamped value with timestamp <i>t</i> to <i>B</i>'s row, so <i>B</i> chooses a value with a timestamp greater than or equal to <i>t</i>, satisfying Condition <a href="#deq3" id="cf0225">(4.1.3)</a>. □</p></div></div><p class="textfl"/><p class="text" id="p0390"><span aria-label="Page 90" epub:type="pagebreak" id="page_90" role="doc-pagebreak"/>On an intuitive, “chicken sexing” level, note that our counterexample that violates atomicity is caused by two read events that do not overlap, the earlier read reading an older value than the latter read. If the reads overlapped, we could have reordered their linearization points however we wanted. However, because the two reads do not overlap, the order of their linearization points is fixed, so we cannot satisfy the atomicity requirement. This is the type of counterexample we should look for when designing algorithms. (We used this same counterexample, by the way, in the single-reader atomic register construction.)</p><p class="text" id="p0395">Our solution used two algorithmic tools: timestamping, which appears later in many practical algorithms, and indirect helping, where one thread tells the others what it read. In this way, if a writer pauses after communicating information to only a subset of readers, then those readers collaborate by passing on that information.</p></section><section><h3 class="h2hd" id="s0045"><a id="st0055"/>4.2.6 An atomic MRMW register</h3><p class="textfl" id="p0400">Here is how to construct an atomic MRMW register from an array of atomic MRSW registers, one per thread.</p><p class="text" id="p0405">To write to the register, <i>A</i> reads all the array elements, chooses a timestamp higher than any it has observed, and writes a stamped value to array element <i>A</i>. To read the register, a thread reads all the array elements, and returns the one with the highest timestamp. This is exactly the timestamp algorithm used by the Bakery algorithm of Section <a href="B9780124159501000112.xhtml">2.7</a>. As in the Bakery algorithm, we resolve ties in favor of the thread with the lesser index, in other words, using a lexicographic order on pairs of timestamp and thread IDs.</p><p class="text" id="p0410"/><div class="boxg1" id="enun0070"><p class="b1num">Lemma 4.2.7 </p><div><p class="b1textfl" id="p0415">The construction in <a href="#f0080" id="cf0230">Fig. 4.14</a> is an atomic MRMW register.</p><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" height="404" src="images/B9780124159501000136/gr014.jpg" width="443"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.14</span> Atomic MRMW register.</div></figcaption></figure></div></div></div><p class="textfl"> </p><div class="boxg1" id="enun0075"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0420">Define the write order among <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() calls based on the lexicographic order of their timestamps and thread IDs so that the <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call by <i>A</i> with timestamp <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si53.png" style="vertical-align:middle" width="15"/></span> precedes the <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call by <i>B</i> with timestamp <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si54.png" style="vertical-align:middle" width="15"/></span> if <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si55.png" style="vertical-align:middle" width="48"/></span> or if <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si56.png" style="vertical-align:middle" width="48"/></span> and <span class="hiddenClass"><mml:math><mml:mi>A</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>B</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si57.png" style="vertical-align:middle" width="44"/></span>. We leave as an exercise to the reader to show that this lexicographic order is consistent with → . As usual, index <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() calls in write order: <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000136/si58.png" style="vertical-align:middle" width="78"/></span>.</p><p class="b1text" id="p0425">Clearly a <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call cannot read a value written in <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/>[] after it is completed, and any <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call completely preceded by the read has a timestamp higher than all those written before the read is completed, implying Condition <a href="#deq1" id="cf0235">(4.1.1)</a>.</p><p class="b1text" id="p0430">Consider Condition <a href="#deq2" id="cf0240">(4.1.2)</a>, which prohibits skipping over the most recent preceding <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>(). Suppose a <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call by <i>A</i> preceded a write call by <i>B</i>, which in turn preceded a <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() by <i>C</i>. If <span class="hiddenClass"><mml:math><mml:mi>A</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>B</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si59.png" style="vertical-align:middle" width="44"/></span>, then the later write overwrites <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si25.png" style="vertical-align:middle" width="23"/></span> and the <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() does not return the value of the earlier write. If <span class="hiddenClass"><mml:math><mml:mi>A</mml:mi><mml:mo>≠</mml:mo><mml:mi>B</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si45.png" style="vertical-align:middle" width="44"/></span>, then since <i>A</i>'s timestamp is smaller than <i>B</i>'s timestamp, any <i>C</i> that sees both returns <i>B</i>'s value (or one with higher timestamp), meeting Condition <a href="#deq2" id="cf0245">(4.1.2)</a>.</p><p class="b1text" id="p0435"><span aria-label="Page 91" epub:type="pagebreak" id="page_91" role="doc-pagebreak"/>Finally, we consider Condition <a href="#deq3" id="cf0250">(4.1.3)</a>, which prohibits values from being read out of write order. Consider any <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call by <i>A</i> completely preceding a <img alt="Image" height="9" src="images/B9780124159501000136/fx001.jpg" width="25"/>() call by <i>B</i>, and any <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call by <i>C</i> which is ordered before the <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() by <i>D</i> in the write order. We must show that if <i>A</i> returns <i>D</i>'s value, then <i>B</i> does not return <i>C</i>'s value. If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si60.png" style="vertical-align:middle" width="50"/></span>, then if <i>A</i> reads timestamp <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si61.png" style="vertical-align:middle" width="17"/></span> from <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si62.png" style="vertical-align:middle" width="25"/></span>, <i>B</i> reads <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si61.png" style="vertical-align:middle" width="17"/></span> or a higher timestamp from <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si62.png" style="vertical-align:middle" width="25"/></span>, and does not return the value associated with <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si63.png" style="vertical-align:middle" width="16"/></span>. If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si64.png" style="vertical-align:middle" width="50"/></span>, that is, the writes were concurrent, then from the write order, <span class="hiddenClass"><mml:math><mml:mi>C</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>D</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si65.png" style="vertical-align:middle" width="46"/></span>, so if <i>A</i> reads timestamp <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si61.png" style="vertical-align:middle" width="17"/></span> from <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si62.png" style="vertical-align:middle" width="25"/></span>, <i>B</i> also reads <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si61.png" style="vertical-align:middle" width="17"/></span> from <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si62.png" style="vertical-align:middle" width="25"/></span>, and returns the value associated with <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si61.png" style="vertical-align:middle" width="17"/></span> (or higher), even if it reads <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si63.png" style="vertical-align:middle" width="16"/></span> in <img alt="Image" height="13" src="images/B9780124159501000136/fx024.jpg" width="45"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si66.png" style="vertical-align:middle" width="23"/></span>. □</p></div></div><p class="textfl"/><p class="text" id="p0440">Our series of constructions shows that one can construct a wait-free atomic multivalued MRMW register from safe Boolean SRSW registers. Naturally, no one wants to write a concurrent algorithm using safe registers, but these constructions show that any algorithm using atomic registers can be implemented on an architecture that supports only safe registers. Later on, when we consider more realistic architectures, we return to the theme of implementing algorithms that assume strong synchronization properties on architectures that directly provide only weaker properties.<span aria-label="Page 92" epub:type="pagebreak" id="page_92" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>4.3 Atomic snapshots</h2><p class="textfl" id="p0445">We have seen how a register value can be read and written atomically. What if we want to read multiple register values atomically? We call such an operation an <i>atomic snapshot</i>.</p><p class="text" id="p0450">An atomic snapshot constructs an instantaneous view of an array of MRSW registers. We construct a wait-free snapshot, meaning that a thread can take a snapshot of the array without delaying any other thread. Atomic snapshots can be useful for backups or checkpoints.</p><p class="text" id="p0455">The <img alt="Image" height="11" src="images/B9780124159501000136/fx026.jpg" width="52"/> interface (<a href="#f0085" id="cf0255">Fig. 4.15</a>) is just an array of atomic MRSW registers, one for each thread. The <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() method writes a value <i>v</i> to the calling thread's register in that array; the <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() method returns an atomic snapshot of that array.</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="60" src="images/B9780124159501000136/gr015.jpg" width="198"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.15</span> The <img alt="Image" height="11" src="images/B9780124159501000136/fx026.jpg" width="52"/> interface.</div></figcaption></figure></div><p class="text" id="p0460">Our goal is to construct a wait-free implementation that is equivalent (that is, linearizable) to the sequential specification shown in <a href="#f0090" id="cf0260">Fig. 4.16</a>. The key property of this sequential implementation is that <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() returns a collection of values, each corresponding to the latest preceding <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>(); that is, it returns a collection of register values that existed together in the same instant.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="290" src="images/B9780124159501000136/gr016.jpg" width="334"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.16</span> A sequential snapshot.</div></figcaption></figure></div><section><h3 class="h2hd" id="s0055"><a id="st0065"/>4.3.1 An obstruction-free snapshot</h3><p class="textfl" id="p0465">We begin with a <img alt="Image" height="11" src="images/B9780124159501000136/fx029.jpg" width="92"/> class for which <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() is wait-free but <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() is obstruction-free. We then extend this algorithm to make <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() wait-free.</p><p class="text" id="p0470">As in the atomic MRSW register construction, each value is a <img alt="Image" height="11" src="images/B9780124159501000136/fx023.jpg" width="100"/> object with <img alt="Image" height="11" src="images/B9780124159501000136/fx030.jpg" width="32"/> and <img alt="Image" height="9" src="images/B9780124159501000136/fx031.jpg" width="32"/> fields. Each <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() call increments the timestamp.</p><p class="text" id="p0475">A <i>collect</i> is the nonatomic act of copying the register values one-by-one into an array. If we perform two collects one after the other, and both collects read the same set of timestamps, then we know that there was an interval during which no thread updated its register, so the result of the collect is a snapshot of the array immediately after the end of the first collect. We call such a pair of collects a <i>clean double collect</i>.</p><p class="text" id="p0480">In the construction shown in the <img alt="Image" height="11" src="images/B9780124159501000136/fx029.jpg" width="92"/>&lt;T&gt; class (<a href="#f0095" id="cf0265">Fig. 4.17</a>), each thread repeatedly calls <img alt="Image" height="9" src="images/B9780124159501000136/fx032.jpg" width="45"/>() (line 25), and returns as soon as it detects a clean double collect (one in which both sets of timestamps were identical).</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="586" src="images/B9780124159501000136/gr017.jpg" width="514"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.17</span> Simple snapshot object.</div></figcaption></figure></div><p class="text" id="p0485">This construction always returns correct values. The <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() calls are wait-free, but <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() is not because any call can be repeatedly interrupted by <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>(), and may run forever without completing. It is, however, obstruction-free: a <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() completes if it runs by itself for long enough.</p><p class="text" id="p0490"><span aria-label="Page 93" epub:type="pagebreak" id="page_93" role="doc-pagebreak"/>Note that we use timestamps to verify the double collect, and not the values in the registers. Why? We encourage the reader to come up with a counterexample in which the repeated appearance of the same value is interleaved with others so that reading the same value creates the illusion that “nothing has changed.” This is a common mistake that concurrent programmers make, trying to save the space needed for timestamps by using the values being written as indicators of a property. We advise against it: More often than not, this will lead to a bug, as in the case of the clean double collect: It must be detected by checking timestamps, not the equality of the sets of values collected.</p></section><section><h3 class="h2hd" id="s0060"><a id="st0070"/>4.3.2 A wait-free snapshot</h3><p class="textfl" id="p0495">To make the <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() method wait-free, each <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() call <i>helps</i> a potentially interfering <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() by taking a snapshot before writing to its register. A <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() that repeatedly fails to take a clean double collect can use the snapshot from one of the interfering <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() calls as its own. The tricky part is that we must make sure that the snapshot taken from the helping update is one that can be linearized within the <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() call's execution interval.</p><p class="text" id="p0500">We say that a thread <i>moves</i> if it completes an <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>(). If thread <i>A</i> fails to make a clean collect because thread <i>B</i> moved, then can <i>A</i> simply take <i>B</i>'s most recent snapshot as its own? Unfortunately, no. As illustrated in <a href="#f0100" id="cf0270">Fig. 4.18</a>, it is possible for <i>A</i> to see <i>B</i> move when <i>B</i>'s snapshot was taken before <i>A</i> started its <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() call, so the snapshot did not occur within the interval of <i>A</i>'s scan.</p><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="158" src="images/B9780124159501000136/gr018.jpg" width="470"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.18</span> Here is why a thread <i>A</i> that fails to complete a clean double collect cannot simply take the latest snapshot of a thread <i>B</i> that performed an <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() during <i>A</i>'s second collect. <i>B</i>'s snapshot was taken before <i>A</i> started its <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>(), i.e., <i>B</i>'s snapshot did not overlap <i>A</i>'s scan. The danger, illustrated here, is that a thread <i>C</i> could have called <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() after <i>B</i>'s <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() and before <i>A</i>'s <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>(), making it incorrect for <i>A</i> to use the results of <i>B</i>'s <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>().</div></figcaption></figure></div><p class="text" id="p0505"><span aria-label="Page 94" epub:type="pagebreak" id="page_94" role="doc-pagebreak"/>The wait-free construction is based on the following observation: If a scanning thread <i>A</i> sees a thread <i>B</i> move <i>twice</i> while it is performing repeated collects, then <i>B</i> executed a complete <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() call within the interval of <i>A</i>'s <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>(), so it is correct for <i>A</i> to use <i>B</i>'s snapshot.</p><p class="text" id="p0510"><a href="#f0105" id="cs0010">Figs. 4.19</a> and <a href="#f0110">4.20</a> show the wait-free snapshot algorithm. Each <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() calls <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>(), <span aria-label="Page 95" epub:type="pagebreak" id="page_95" role="doc-pagebreak"/>and appends the result of the scan to the value (in addition to the timestamp). More precisely, each value written to a register has the structure shown in <a href="#f0105" id="cf0275">Fig. 4.19</a>: a <img alt="Image" height="11" src="images/B9780124159501000136/fx030.jpg" width="32"/> field incremented each time the thread updates its value, a <img alt="Image" height="9" src="images/B9780124159501000136/fx031.jpg" width="32"/> field containing the register's actual value, and a <img alt="Image" height="9" src="images/B9780124159501000136/fx033.jpg" width="25"/> field containing that thread's most recent scan. The snapshot algorithm is described in <a href="#f0110" id="cf0280">Fig. 4.20</a>. A scanning thread creates a Boolean array called <img alt="Image" height="9" src="images/B9780124159501000136/fx034.jpg" width="32"/>[] (line 24), which records which threads have been observed to move in the course of the scan. As before, each thread performs two collects (lines 25 and 27) and tests whether any thread's timestamp has changed. If no thread's timestamp has changed, then the collect is clean, and the scan returns the result of the collect. If any thread's timestamp has changed (line 29), the scanning thread tests <span aria-label="Page 96" epub:type="pagebreak" id="page_96" role="doc-pagebreak"/><span aria-label="Page 97" epub:type="pagebreak" id="page_97" role="doc-pagebreak"/>the <img alt="Image" height="9" src="images/B9780124159501000136/fx034.jpg" width="32"/>[] array to detect whether this is the second time this thread has moved (line 30). If so, it returns that thread's scan (line 31); otherwise, it updates <img alt="Image" height="9" src="images/B9780124159501000136/fx034.jpg" width="32"/>[] and resumes the outer loop (line 32).</p><div class="pageavoid"><figure class="fig" id="f0105"><img alt="Image" height="240" src="images/B9780124159501000136/gr019.jpg" width="279"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.19</span> The stamped snapshot class.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0110"><img alt="Image" height="734" src="images/B9780124159501000136/gr020.jpg" width="502"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.20</span> Single-writer atomic snapshot class.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0065"><a id="st0075"/>4.3.3 Correctness arguments</h3><p class="textfl" id="p0515">In this section, we review the correctness arguments for the wait-free snapshot algorithm a little more carefully.</p><p class="text" id="p0520"/><div class="boxg1" id="enun0080"><p class="b1num">Lemma 4.3.1 </p><div><p class="b1textfl" id="p0525">If a scanning thread makes a clean double collect, then the values it returns were the values that existed in the registers in some state of the execution.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0085"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0530">Consider the interval between the last read of the first collect and the first read of the second collect. If any register were updated in that interval, the timestamps would not match, and the double collect would not be clean. □</p></div></div><p class="textfl"/><p class="text" id="p0535"/><div class="boxg1" id="enun0090"><p class="b1num">Lemma 4.3.2 </p><div><p class="b1textfl" id="p0540">If a scanning thread <i>A</i> observes changes in another thread <i>B</i>'s timestamp during two different double collects, then the value of <i>B</i>'s register read during the last collect was written by an <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() call that began after the first collect started.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0095"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0545">If during a <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>(), two successive reads by <i>A</i> of <i>B</i>'s register return different timestamps, then at least one write by <i>B</i> occurs between this pair of reads. Thread <i>B</i> writes to its register as the final step of an <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() call, so some <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() call by <i>B</i> ended sometime after the first read by <i>A</i>, and the write step of another <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() call occurs between the last pair of reads by <i>A</i>. The claim follows because only <i>B</i> writes to its register. □</p></div></div><p class="textfl"/><p class="text" id="p0550"/><div class="boxg1" id="enun0100"><p class="b1num">Lemma 4.3.3 </p><div><p class="b1textfl" id="p0555">The values returned by a <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() were in the registers at some state between the call's invocation and response.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0105"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0560">If the <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() call made a clean double collect, then the claim follows from <a href="#enun0080" id="cf0285">Lemma 4.3.1</a>. If the call took the scan value from another thread <i>B</i>'s register, then by <a href="#enun0090" id="cf0290">Lemma 4.3.2</a>, the scan value found in <i>B</i>'s register was obtained by a <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() call by <i>B</i> whose interval lies between <i>A</i>'s first and last reads of <i>B</i>'s register. Either <i>B</i>'s <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() call had a clean double collect, in which case the result follows from <a href="#enun0080" id="cf0295">Lemma 4.3.1</a>, or there is an embedded <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() call by a thread <i>C</i> occurring within the interval of <i>B</i>'s <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() call. This argument can be applied inductively, noting that there can be at most <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si67.png" style="vertical-align:middle" width="37"/></span> nested calls before we run out of threads, where <i>n</i> is the maximum number of threads (see <a href="#f0115" id="cf0300">Fig. 4.21</a>). Eventually, some nested <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() call must have had a clean double collect. □</p><div class="pageavoid"><figure class="fig" id="f0115"><img alt="Image" height="155" src="images/B9780124159501000136/gr021.jpg" width="402"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.21</span> There can be at most <i>n</i> − 1 nested calls of <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() before we run out of threads, where <i>n</i> is the maximum number of threads. The <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() by thread <i>n</i> − 1, contained in the intervals of all other <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() calls, must have a clean double collect.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0565"/><div class="boxg1" id="enun0110"><p class="b1num">Lemma 4.3.4 </p><div><p class="b1textfl" id="p0570">Every <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() or <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() returns after at most <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000136/si68.png" style="vertical-align:middle" width="42"/></span> reads or writes.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0115"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0575">Consider a particular <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>(). There are only <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000136/si67.png" style="vertical-align:middle" width="37"/></span> other threads, so after <i>n</i> double collects, either one double collect is clean, or some thread is observed to move twice. The claim follows because each double collect does <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si69.png" style="vertical-align:middle" width="35"/></span> reads.  □</p></div></div><p class="textfl"/><p class="text" id="p0580"><span aria-label="Page 98" epub:type="pagebreak" id="page_98" role="doc-pagebreak"/>By <a href="#enun0100" id="cf0305">Lemma 4.3.3</a>, the values returned by a <img alt="Image" height="6" src="images/B9780124159501000136/fx028.jpg" width="25"/>() form a snapshot as they are all in the registers in some state during the call: linearize the call at that point. Similarly, linearize <img alt="Image" height="11" src="images/B9780124159501000136/fx027.jpg" width="38"/>() calls at the point the register is written. </p><div class="boxg1" id="enun0120"><p class="b1num">Theorem 4.3.5 </p><div><p class="b1textfl" id="p0585">The code in <a href="#f0110" id="cf0310">Fig. 4.20</a> is a wait-free snapshot implementation.</p></div></div><p class="textfl"/><p class="text" id="p0590">Our wait-free atomic snapshot construction is another, somewhat different example of the dissemination approach we discussed in our atomic register constructions. In this example, threads tell other threads about their snapshots, and those snapshots are reused. Another useful trick is that even if one thread interrupts another and prevents it from completing, we can still guarantee wait-freedom if the interrupting thread completes the interrupted thread's operation. This helping paradigm is extremely useful in designing multiprocessor algorithms.<span aria-label="Page 99" epub:type="pagebreak" id="page_99" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0070"><a id="st0080"/>4.4 Chapter notes</h2><p class="textfl" id="p0595">Alonzo Church introduced lambda calculus around 1935 <a epub:type="noteref" href="#br0150" id="cf0315" role="doc-noteref">[30]</a>. Alan Turing defined the Turing machine in a classic paper in 1937 <a epub:type="noteref" href="#br0815" id="cf0320" role="doc-noteref">[163]</a>. Leslie Lamport defined the notions of <i>safe</i>, <i>regular</i>, and <i>atomic</i> registers and the register hierarchy, and was the first to show that one could implement nontrivial shared memory from safe bits <a epub:type="noteref" href="#br0495" id="cs0015" role="doc-noteref">[99</a>,<a epub:type="noteref" href="#br0525" role="doc-noteref">105]</a>. Gary Peterson suggested the problem of constructing atomic registers <a epub:type="noteref" href="#br0695" id="cf0325" role="doc-noteref">[139]</a>. Jaydev Misra gave an axiomatic treatment of atomic registers <a epub:type="noteref" href="#br0640" id="cf0330" role="doc-noteref">[128]</a>. The notion of <i>linearizability</i>, which generalizes Lamport's and Misra's notions of atomic registers, is due to Herlihy and Wing <a epub:type="noteref" href="#br0375" id="cf0335" role="doc-noteref">[75]</a>. Susmita Haldar and Krishnamurthy Vidyasankar gave a bounded atomic MRSW register construction from regular registers <a epub:type="noteref" href="#br0275" id="cf0340" role="doc-noteref">[55]</a>. The problem of constructing an atomic multi-reader register from atomic single-reader registers was mentioned as an open problem by Leslie Lamport <a epub:type="noteref" href="#br0495" id="cs0020" role="doc-noteref">[99</a>,<a epub:type="noteref" href="#br0525" role="doc-noteref">105]</a> and by Paul Vitányi and Baruch Awerbuch <a epub:type="noteref" href="#br0825" id="cf0345" role="doc-noteref">[165]</a>, who were the first to propose an approach for atomic MRMW register design. The first solution is due to Jim Anderson, Mohamed Gouda, and Ambuj Singh <a epub:type="noteref" href="#br0435" id="cs0025" role="doc-noteref">[87</a>,<a epub:type="noteref" href="#br0800" role="doc-noteref">160]</a>. Other atomic register constructions, to name only a few, were proposed by Jim Burns and Gary Peterson <a epub:type="noteref" href="#br0125" id="cf0350" role="doc-noteref">[25]</a>, Richard Newman-Wolfe <a epub:type="noteref" href="#br0670" id="cf0355" role="doc-noteref">[134]</a>, Lefteris Kirousis, Paul Spirakis, and Philippas Tsigas <a epub:type="noteref" href="#br0460" id="cf0360" role="doc-noteref">[92]</a>, Amos Israeli and Amnon Shaham <a epub:type="noteref" href="#br0430" id="cf0365" role="doc-noteref">[86]</a>, and Ming Li, John Tromp and Paul Vitányi <a epub:type="noteref" href="#br0565" id="cf0370" role="doc-noteref">[113]</a>. The simple timestamp-based atomic MRMW construction we present here is due to Danny Dolev and Nir Shavit <a epub:type="noteref" href="#br0195" id="cf0375" role="doc-noteref">[39]</a>.</p><p class="text" id="p0600">Collect operations were first formalized by Mike Saks, Nir Shavit, and Heather Woll <a epub:type="noteref" href="#br0760" id="cf0380" role="doc-noteref">[152]</a>. The first atomic snapshot constructions were discovered concurrently and independently by Jim Anderson <a epub:type="noteref" href="#br0050" id="cf0385" role="doc-noteref">[10]</a> and Yehuda Afek, Hagit Attiya, Danny Dolev, Eli Gafni, Michael Merritt, and Nir Shavit <a epub:type="noteref" href="#br0010" id="cf0390" role="doc-noteref">[2]</a>. The latter algorithm is the one presented here. Later snapshot algorithms are due to Elizabeth Borowsky and Eli Gafni <a epub:type="noteref" href="#br0105" id="cf0395" role="doc-noteref">[21]</a> and Yehuda Afek, Gideon Stupp, and Dan Touitou <a epub:type="noteref" href="#br0020" id="cf0400" role="doc-noteref">[4]</a>.</p><p class="text" id="p0605">The timestamps in all the algorithms mentioned in this chapter can be bounded so that the constructions themselves use registers of bounded size. Bounded timestamp systems were introduced by Amos Israeli and Ming Li <a epub:type="noteref" href="#br0425" id="cf0405" role="doc-noteref">[85]</a>, and bounded concurrent timestamp systems by Danny Dolev and Nir Shavit <a epub:type="noteref" href="#br0195" id="cf0410" role="doc-noteref">[39]</a>.</p><p class="text" id="p0610">Horsey <a epub:type="noteref" href="#br0390" id="cf0415" role="doc-noteref">[78]</a> has a beautiful article on chicken sexing and its relation to intuition.</p></section><section><h2 class="h1hd" id="s0075"><a id="st0085"/>4.5 Exercises</h2><p class="textfl" id="p0615"/><div class="boxg1" id="enun0125"><p class="b1num">Exercise 4.1 </p><div><p class="b1textfl" id="p0620">Consider the safe Boolean MRSW construction shown in <a href="#f0040" id="cf0420">Fig. 4.6</a>. True or false: If we replace the safe Boolean SRSW register array with an array of safe <i>M</i>-valued SRSW registers, then the construction yields a safe <i>M</i>-valued MRSW register. Justify your answer.</p></div></div><p class="textfl"/><p class="text" id="p0625"/><div class="boxg1" id="enun0130"><p class="b1num">Exercise 4.2 </p><div><p class="b1textfl" id="p0630">Consider the safe Boolean MRSW construction shown in <a href="#f0040" id="cf0425">Fig. 4.6</a>. True or false: If we replace the safe Boolean SRSW register array with an array of regular Boolean SRSW registers, then the construction yields a regular Boolean MRSW register. Justify your answer.</p></div></div><p class="textfl"/><p class="text" id="p0635"/><div class="boxg1" id="enun0135"><p class="b1num">Exercise 4.3 </p><div><p class="b1textfl" id="p0640">Consider the safe Boolean MRSW construction shown in <a href="#f0040" id="cf0430">Fig. 4.6</a>. True or false: If we replace the safe Boolean SRSW register array with an array of regular <i>M</i>-valued SRSW registers, then the construction yields a regular <i>M</i>-valued MRSW register. Justify your answer.</p></div></div><p class="textfl"/><p class="text" id="p0645"/><div class="boxg1" id="enun0140"><p class="b1num">Exercise 4.4 </p><div><p class="b1textfl" id="p0650">Consider the regular Boolean MRSW construction shown in <a href="#f0045" id="cf0435">Fig. 4.7</a>. True or false: If we replace the safe Boolean MRSW register with a safe <i>M</i>-valued MRSW register, then the construction yields a regular <i>M</i>-valued MRSW register. Justify your answer.</p></div></div><p class="textfl"/><p class="text" id="p0655"/><div class="boxg1" id="enun0145"><p class="b1num">Exercise 4.5 </p><div><p class="b1textfl" id="p0660">Consider the atomic MRSW construction shown in <a href="#f0070" id="cf0440">Fig. 4.12</a>. True or false: If we replace the atomic SRSW registers with regular SRSW registers, then the construction still yields an atomic MRSW register. Justify your answer.</p></div></div><p class="textfl"/><p class="text" id="p0665"/><div class="boxg1" id="enun0150"><p class="b1num">Exercise 4.6 </p><div><p class="b1textfl" id="p0670">Give an example of a quiescently consistent register execution that is not regular.</p></div></div><p class="textfl"/><p class="text" id="p0675"><span aria-label="Page 100" epub:type="pagebreak" id="page_100" role="doc-pagebreak"/></p><div class="boxg1" id="enun0155"><p class="b1num">Exercise 4.7 </p><div><p class="b1textfl" id="p0680">You are given the algorithm in <a href="#f0120" id="cf0445">Fig. 4.22</a> for constructing an atomic <i>M</i>-valued SRSW register using atomic Boolean SRSW registers. Does this proposal work? Either prove the correctness or present a counterexample.</p><div class="pageavoid"><figure class="fig" id="f0120"><img alt="Image" height="339" src="images/B9780124159501000136/gr022.jpg" width="397"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.22</span> Boolean to <i>M</i>-valued atomic SRSW register algorithm.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0685"/><div class="boxg1" id="enun0160"><p class="b1num">Exercise 4.8 </p><div><p class="b1textfl" id="p0690">Imagine running a 64-bit system on a 32-bit system, where each 64-bit memory location (register) is implemented using two atomic 32-bit memory locations (registers). A write operation is implemented by simply writing the first 32 bits in the first register and then the second 32 bits in the second register. A read, similarly, reads the first half from the first register, then reads the second half from the second register, and returns the concatenation. What is the strongest property that this 64-bit register satisfies?</p><div><ul><li class="b1bulllist" id="u0085">•  safe register,</li><li class="b1bulllist" id="u0090">•  regular register,</li><li class="b1bulllist" id="u0095">•  atomic register,</li><li class="b1bulllist" id="u0100">•  it does not satisfy any of these properties.</li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0715"/><div class="boxg1" id="enun0165"><p class="b1num">Exercise 4.9 </p><div><p class="b1textfl" id="p0720">Does Peterson's two-thread mutual exclusion algorithm work if the shared atomic <img alt="Image" height="11" src="images/B9780124159501000136/fx035.jpg" width="25"/> registers are replaced by regular registers?</p></div></div><p class="textfl"/><p class="text" id="p0725"/><div class="boxg1" id="enun0170"><p class="b1num">Exercise 4.10 </p><div><p class="b1textfl" id="p0730">Consider the following implementation of a register in a distributed, message passing system. There are <i>n</i> processors <span aria-label="Page 101" epub:type="pagebreak" id="page_101" role="doc-pagebreak"/><span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si70.png" style="vertical-align:middle" width="84"/></span> arranged in a ring, where <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000136/si71.png" style="vertical-align:middle" width="15"/></span> can send messages only to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.25em"/><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si72.png" style="vertical-align:middle" width="68"/></span>. Messages are delivered in FIFO order along each link. Each processor keeps a copy of the shared register.</p><div><ul><li class="b1bulllist" id="u0105">•  To read the register, the processor reads the copy in its local memory.</li><li class="b1bulllist" id="u0110">•  A processor <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000136/si71.png" style="vertical-align:middle" width="15"/></span> starts a <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call of value <i>v</i> to register <i>x</i>, by sending the message “<span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000136/si71.png" style="vertical-align:middle" width="15"/></span>: write <i>v</i> to <i>x</i>” to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.25em"/><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si72.png" style="vertical-align:middle" width="68"/></span>.</li><li class="b1bulllist" id="u0115">•  If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000136/si71.png" style="vertical-align:middle" width="15"/></span> receives a message “<span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000136/si73.png" style="vertical-align:middle" width="17"/></span>: write <i>v</i> to <i>x</i>,” for <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si74.png" style="vertical-align:middle" width="35"/></span>, then it writes <i>v</i> to its local copy of <i>x</i>, and forwards the message to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.25em"/><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si72.png" style="vertical-align:middle" width="68"/></span>.</li><li class="b1bulllist" id="u0120">•  If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000136/si71.png" style="vertical-align:middle" width="15"/></span> receives a message “<span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000136/si71.png" style="vertical-align:middle" width="15"/></span>: write <i>v</i> to <i>x</i>,” then it writes <i>v</i> to its local copy of <i>x</i>, and discards the message. The <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() call is now complete.</li></ul></div><p class="b1textfl"> Give a short justification or counterexample.</p><p class="b1text" id="p0755">If <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>() calls never overlap,</p><div><ul><li class="b1bulllist" id="u0125">•  is this register implementation regular?</li><li class="b1bulllist" id="u0130">•  is it atomic?</li></ul></div><p class="b1textfl"/><p class="b1text" id="p0770">If multiple processors call <img alt="Image" height="9" src="images/B9780124159501000136/fx002.jpg" width="32"/>(),</p><div><ul><li class="b1bulllist" id="u0135">•  is this register implementation safe?</li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0780"/><div class="boxg1" id="enun0175"><p class="b1num">Exercise 4.11 </p><div><p class="b1textfl" id="p0785"><a href="#f0125" id="cf0450">Fig. 4.23</a> shows an implementation of a multivalued <i>write-once</i>, MRSW register from an array of multivalued safe, MRSW registers. Remember, there is one writer, who can overwrite the register's initial value with a new value, but it can only write once. You do not know the register's initial value.</p><div class="pageavoid"><figure class="fig" id="f0125"><img alt="Image" height="273" src="images/B9780124159501000136/gr023.jpg" width="363"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 4.23</span> Write-once register.</div></figcaption></figure></div><p class="b1text" id="p0790">Is this implementation regular? Atomic?</p></div></div><p class="textfl"/><p class="text" id="p0795"><span aria-label="Page 102" epub:type="pagebreak" id="page_102" role="doc-pagebreak"/></p><div class="boxg1" id="enun0180"><p class="b1num">Exercise 4.12 </p><div><p class="b1textfl" id="p0800">A (single-writer) register is <i>1-regular</i> if the following conditions hold:</p><div><ul><li class="b1bulllist" id="u0140">•  If a read() operation does not overlap with any write() operations, then it returns the value written by the last write() operation.</li><li class="b1bulllist" id="u0145">•  If a read() operation overlaps with exactly one write() operation, then it returns a value written either by the last write() operation or the concurrent write() operation.</li><li class="b1bulllist" id="u0150">•  Otherwise, a read() operation may return an arbitrary value.</li></ul></div><p class="b1textfl"> Construct an SRSW <i>M</i>-valued 1-regular register using <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000136/si75.png" style="vertical-align:middle" width="64"/></span> SRSW Boolean regular registers. Explain why your construction works.</p></div></div><p class="textfl"/><p class="text" id="p0820"/><div class="boxg1" id="enun0185"><p class="b1num">Exercise 4.13 </p><div><p class="b1textfl" id="p0825">Prove that the safe Boolean MRSW register construction from safe Boolean SRSW registers illustrated in <a href="#f0040" id="cf0455">Fig. 4.6</a> is a correct implementation of a regular MRSW register if the component registers are regular SRSW registers.</p></div></div><p class="textfl"/><p class="text" id="p0830"/><div class="boxg1" id="enun0190"><p class="b1num">Exercise 4.14 </p><div><p class="b1textfl" id="p0835">Define a <i>wraparound</i> register that has the property that there is a value <i>k</i> such that writing the value <i>v</i> sets the value of the register to <span class="hiddenClass"><mml:math><mml:mi>v</mml:mi><mml:mspace width="0.25em"/><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000136/si76.png" style="vertical-align:middle" width="56"/></span>.</p><p class="b1text" id="p0840">If we replace the Bakery algorithm's shared variables with either (a) regular, (b) safe, or (c) atomic wraparound registers, then does it still satisfy (1) mutual exclusion and (2) FIFO ordering?</p><p class="b1text" id="p0845">You should provide six answers (some may imply others). Justify each claim.</p></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0350"><h2 class="reftitle" id="st0090">Bibliography</h2><p class="reflist" epub:type="biblioentry footnote" id="br0010" role="doc-biblioentry">[2] Yehuda Afek, Hagit Attiya, Danny Dolev, Eli Gafni, Michael Merritt, Nir Shavit,  Atomic snapshots of shared memory,   <cite><i>Journal of the ACM</i></cite> 1993;40(4):873–890.</p><p class="reflist" epub:type="biblioentry footnote" id="br0020" role="doc-biblioentry">[4] Yehuda Afek, Gideon Stupp, Dan Touitou,  Long-lived and adaptive atomic snapshot and immediate snapshot (extended abstract),   <i>Symposium on Principles of Distributed Computing</i>.  2000:71–80.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0050" role="doc-biblioentry">[10] James H. Anderson,  Composite registers,   <cite><i>Distributed Computing</i></cite> 1993;6(3):141–154.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0105" role="doc-biblioentry">[21] Elizabeth Borowsky, Eli Gafni,  Immediate atomic snapshots and fast renaming,   <i>PODC '93: Proceedings of the Twelfth Annual ACM Symposium on Principles of Distributed Computing</i>.  New York, NY, USA: ACM Press; 1993:41–51.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0125" role="doc-biblioentry">[25] James E. Burns, Gary L. Peterson,  Constructing multi-reader atomic values from non-atomic values,   <i>PODC '87: Proceedings of the Sixth Annual ACM Symposium on Principles of Distributed Computing</i>.  New York, NY, USA: ACM Press; 1987:222–231.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0150" role="doc-biblioentry">[30] Alonzo Church,  A note on the entscheidungsproblem,   <cite><i>The Journal of Symbolic Logic</i></cite> 1936.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0195" role="doc-biblioentry">[39] Danny Dolev, Nir Shavit,  Bounded concurrent time-stamping,   <cite><i>SIAM Journal on Computing</i></cite> 1997;26(2):418–455.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0275" role="doc-biblioentry">[55] S. Haldar, K. Vidyasankar,  Constructing 1-writer multireader multivalued atomic variables from regular variables,   <cite><i>Journal of the ACM</i></cite> 1995;42(1):186–203.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0375" role="doc-biblioentry">[75] Maurice P. Herlihy, Jeannette M. Wing,  Linearizability: a correctness condition for concurrent objects,   <cite><i>ACM Transactions on Programming Languages and Systems</i></cite> 1990;12(3):463–492.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0390" role="doc-biblioentry">[78] Richard Horsey,  <i>The Art of Chicken Sexing</i>.  Cogprints; 2002.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0425" role="doc-biblioentry">[85] Amos Israeli, Ming Li,  Bounded time stamps,   <cite><i>Distributed Computing</i></cite> 1993;6(5):205–209.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0430" role="doc-biblioentry">[86] Amos Israeli, Amnon Shaham,  Optimal multi-writer multi-reader atomic register,   <i>Symposium on Principles of Distributed Computing</i>.  1992:71–82.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0435" role="doc-biblioentry">[87] Mohammed Gouda, James Anderson, Ambuj Singh,  <i>The elusive atomic register</i>. [Technical Report TR 86.29] University of Texas at Austin; 1986.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0460" role="doc-biblioentry">[92] Lefteris M. Kirousis, Evangelos Kranakis, Paul M.B. Vitányi,  Atomic multireader register,   <i>Proceedings of the 2nd International Workshop on Distributed Algorithms</i>.  London, UK: Springer-Verlag; 1988:278–296.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0495" role="doc-biblioentry">[99] L. Lamport,  On interprocess communication,   <cite><i>Distributed Computing</i></cite> 1986;1:77–101.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0525" role="doc-biblioentry">[105] Leslie Lamport,  On interprocess communication (part II),   <cite><i>Distributed Computing</i></cite> January 1986;1(1):203–213.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0565" role="doc-biblioentry">[113] Li Ming, John Tromp, Paul M.B. Vitányi,  How to share concurrent wait-free variables,   <cite><i>Journal of the ACM</i></cite> 1996;43(4):723–746.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0640" role="doc-biblioentry">[128] Jaydev Misra,  Axioms for memory access in asynchronous hardware systems,   <cite><i>ACM Transactions on Programming Languages and Systems</i></cite> 1986;8(1):142–153.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0670" role="doc-biblioentry">[134] Richard Newman-Wolfe,  A protocol for wait-free, atomic, multi-reader shared variables,   <i>PODC '87: Proceedings of the Sixth Annual ACM Symposium on Principles of Distributed Computing</i>.  New York, NY, USA: ACM Press; 1987:232–248.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0695" role="doc-biblioentry">[139] Gary L. Peterson,  Concurrent reading while writing,   <cite><i>ACM Transactions on Programming Languages and Systems</i></cite> 1983;5(1):46–55.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0760" role="doc-biblioentry">[152] Michael Saks, Nir Shavit, Heather Woll,  Optimal time randomized consensus — making resilient algorithms fast in practice,   <i>SODA '91: Proceedings of the Second Annual ACM-SIAM Symposium on Discrete Algorithms</i>.  Philadelphia, PA, USA: Society for Industrial and Applied Mathematics; 1991:351–362.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0800" role="doc-biblioentry">[160] Ambuj K. Singh, James H. Anderson, Mohamed G. Gouda,  The elusive atomic register,   <cite><i>Journal of the ACM</i></cite> 1994;41(2):311–339.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0815" role="doc-biblioentry">[163] Alan Turing,  On computable numbers, with an application to the entscheidungsproblem,   <cite><i>Proceedings of the London Mathematical Society</i></cite> 1937.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0825" role="doc-biblioentry">[165] Paul Vitányi, Baruch Awerbuch,  Atomic shared register access by asynchronous hardware,   <i>27th Annual Symposium on Foundations of Computer Science</i>.  Los Angeles, Ca., USA: IEEE Computer Society Press; October 1986:233–243.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0045" role="doc-noteref">1 </a></sup> <a id="np0010"/>“If values are not inherently unique, we can use the standard technique of appending to them auxiliary values invisible to the algorithm itself, used only in our reasoning to distinguish one value from another.”</p></div></section></footer></section></body></html>