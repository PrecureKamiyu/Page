<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>4.6 Summary </title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P70004970270000000000000000045BA" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000042D04" data-uri="chapter04.xhtml#P7000497027000000000000000042D04" epub:type="title"><span class="pcalibre label pcalibre1">4.6 </span><span class="pcalibre label pcalibre1">Summary </span></h1></header>
<p id="P7000497027000000000000000042D05" data-uri="chapter04.xhtml#P7000497027000000000000000042D05" class="pcalibre1 pcalibre calibre2">We have seen that the instruction set architecture, or ISA, provides a layer of abstraction between the behavior of a processor—in terms of the set of instructions and their encodings—and how the processor is implemented. The ISA provides a very sequential view of program execution, with one instruction executed to completion before the next one begins.</p>

<aside class="sidebar pcalibre5 pcalibre" id="P70004970270000000000000000045BD" data-uri="chapter04.xhtml#P70004970270000000000000000045BD"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000042D06" data-uri="chapter04.xhtml#P7000497027000000000000000042D06" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000045BF" title="471" data-uri="chapter04.xhtml#P70004970270000000000000000045BF" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>State-of-the-art microprocessor design</h1></header>
<p id="P7000497027000000000000000042D07" data-uri="chapter04.xhtml#P7000497027000000000000000042D07" class="calibre13 pcalibre pcalibre1">A five-stage pipeline, such as we have shown with the PIPE processor, represented the state of the art in processor design in the mid-1980s. The prototype RISC processor developed by Patterson's research group at Berkeley formed the basis for the first SPARC processor, developed by Sun Microsystems in 1987. The processor developed by Hennessy's research group at Stanford was commercialized by MIPS Technologies (a company founded by Hennessy) in 1986. Both of these used five-stage pipelines. The Intel i486 processor also uses a five-stage pipeline, although with a different partitioning of responsibilities among the stages, with two decode stages and a combined execute/memory stage <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3D7">[27]</a>.</p>
<p id="P7000497027000000000000000042D08" data-uri="chapter04.xhtml#P7000497027000000000000000042D08" class="calibre13 pcalibre pcalibre1">These pipelined designs are limited to a throughput of at most one instruction per clock cycle. The CPI (for "cycles per instruction") measure described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000041EB_split_002.xhtml#P7000497027000000000000000004544"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">4.5.9</span></a> can never be less than 1.0. The different stages can only process one instruction at a time. More recent processors support <i class="calibre5 pcalibre pcalibre1">superscalar</i> operation, meaning that they can achieve a CPI less than 1.0 by fetching, decoding, and executing multiple instructions in parallel. As superscalar processors have become widespread, the accepted performance measure has shifted from CPI to its reciprocal—the average number of instructions executed per cycle, or IPC. It can exceed 1.0 for superscalar processors. The most advanced designs use a technique known as <i class="calibre5 pcalibre pcalibre1">out-of-order</i> execution to execute multiple instructions in parallel, possibly in a totally different order than they occur in the program, while preserving the overall behavior implied by the sequential ISA model. This form of execution is described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004893.xhtml#P7000497027000000000000000004893"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">5</span></a> as part of our discussion of program optimization.</p>
<p id="P7000497027000000000000000042D09" data-uri="chapter04.xhtml#P7000497027000000000000000042D09" class="calibre13 pcalibre pcalibre1">Pipelined processors are not just historical artifacts, however. The majority of processors sold are used in embedded systems, controlling automotive functions, consumer products, and other devices where the processor is not directly visible to the system user. In these applications, the simplicity of a pipelined processor, such as the one we have explored in this chapter, reduces its cost and power requirements compared to higher-performance models.</p>
<p id="P7000497027000000000000000042D0A" data-uri="chapter04.xhtml#P7000497027000000000000000042D0A" class="pcalibre calibre3 pcalibre1">More recently, as multicore processors have gained a following, some have argued that we could get more overall computing power by integrating many simple processors on a single chip rather than a smaller number of more complex ones. This strategy is sometimes referred to as "many-core" processors <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3B4">[10]</a>.</p>
</aside>
<p id="P7000497027000000000000000042D0B" data-uri="chapter04.xhtml#P7000497027000000000000000042D0B" class="pcalibre1 pcalibre calibre2">We defined the Y86-64 instruction set by starting with the x86-64 instructions and simplifying the data types, address modes, and instruction encoding considerably. The resulting ISA has attributes of both RISC and CISC instruction sets. We then organized the processing required for the different instructions into a series of five stages, where the operations at each stage vary according to the instruction being executed. From this, we constructed the SEQ processor, in which an entire instruction is executed every clock cycle by having it flow through all five stages.</p>
<p id="P7000497027000000000000000042D0C" data-uri="chapter04.xhtml#P7000497027000000000000000042D0C" class="pcalibre1 pcalibre calibre2">Pipelining improves the throughput performance of a system by letting the different stages operate concurrently. At any given time, multiple operations are being processed by the different stages. In introducing this concurrency, we must be careful to provide the same program-level behavior as would a sequential execution of the program. We introduced pipelining by reordering parts of SEQ to get SEQ+ and then adding pipeline registers to create the PIPE— pipeline.</p>

<aside class="sidebar pcalibre5 pcalibre" id="P70004970270000000000000000045C6" data-uri="chapter04.xhtml#P70004970270000000000000000045C6"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000042D0D" data-uri="chapter04.xhtml#P7000497027000000000000000042D0D" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000045C8" title="472" data-uri="chapter04.xhtml#P70004970270000000000000000045C8" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Web Aside ARCH:HCL </span>HCL descriptions of Y86-64 processors</h1></header>
<p id="P7000497027000000000000000042D0E" data-uri="chapter04.xhtml#P7000497027000000000000000042D0E" class="pcalibre calibre3 pcalibre1">In this chapter, we have looked at portions of the HCL code for several simple logic designs and for the control logic for Y86-64 processors SEQ and PIPE. For reference, we provide documentation of the HCL language and complete HCL descriptions for the control logic of the two processors. Each of these descriptions requires only five to seven pages of HCL code, and it is worthwhile to study them in their entirety.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000042D0F" data-uri="chapter04.xhtml#P7000497027000000000000000042D0F">We enhanced the pipeline performance by adding forwarding logic to speed the sending of a result from one instruction to another. Several special cases require additional pipeline control logic to stall or cancel some of the pipeline stages.</p>
<p id="P7000497027000000000000000042D10" data-uri="chapter04.xhtml#P7000497027000000000000000042D10" class="pcalibre1 pcalibre calibre2">Our design included rudimentary mechanisms to handle exceptions, where we make sure that only instructions up to the excepting instruction affect the programmer-visible state. Implementing a complete handling of exceptions would be significantly more challenging. Properly handling exceptions gets even more complex in systems that employ greater degrees of pipelining and parallelism.</p>
<p id="P7000497027000000000000000042D11" data-uri="chapter04.xhtml#P7000497027000000000000000042D11" class="pcalibre1 pcalibre calibre2">In this chapter, we have learned several important lessons about processor design:</p>
<ul id="P7000497027000000000000000042D12" data-uri="chapter04.xhtml#P7000497027000000000000000042D12" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000042D13" data-uri="chapter04.xhtml#P7000497027000000000000000042D13" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000042D14" data-uri="chapter04.xhtml#P7000497027000000000000000042D14" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Managing complexity is a top priority. </span>We want to make optimum use of the hardware resources to get maximum performance at minimum cost. We did this by creating a very simple and uniform framework for processing all of the different instruction types. With this framework, we could share the hardware units among the logic for processing the different instruction types.</p></li>
<li id="P7000497027000000000000000042D15" data-uri="chapter04.xhtml#P7000497027000000000000000042D15" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000042D16" data-uri="chapter04.xhtml#P7000497027000000000000000042D16" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">We do not need to implement the ISA directly. </span>A direct implementation of the ISA would imply a very sequential design. To achieve higher performance, we want to exploit the ability in hardware to perform many operations simultaneously. This led to the use of a pipelined design. By careful design and analysis, we can handle the various pipeline hazards, so that the overall effect of running a program exactly matches what would be obtained with the ISA model.</p></li>
<li id="P7000497027000000000000000042D17" data-uri="chapter04.xhtml#P7000497027000000000000000042D17" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000042D18" data-uri="chapter04.xhtml#P7000497027000000000000000042D18" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Hardware designers must be meticulous. </span>Once a chip has been fabricated, it is nearly impossible to correct any errors. It is very important to get the design right on the first try. This means carefully analyzing different instruction types and combinations, even ones that do not seem to make sense, such as popping to the stack pointer. Designs must be thoroughly tested with systematic simulation test programs. In developing the control logic for PIPE, our design had a subtle bug that was uncovered only after a careful and systematic analysis of control combinations.</p></li>
</ul>

<section id="P70004970270000000000000000045D4" data-uri="chapter04.xhtml#P70004970270000000000000000045D4" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000042D19" data-uri="chapter04.xhtml#P7000497027000000000000000042D19" epub:type="title"><span class="pcalibre label pcalibre1">4.6.1 </span>Y86-64 Simulators</h1></header>
<p id="P7000497027000000000000000042D1A" data-uri="chapter04.xhtml#P7000497027000000000000000042D1A" class="pcalibre1 pcalibre calibre2">The lab materials for this chapter include simulators for the SEQ and PIPE processors. Each simulator has two versions:</p>
<ul id="P7000497027000000000000000042D1B" data-uri="chapter04.xhtml#P7000497027000000000000000042D1B" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000042D1C" data-uri="chapter04.xhtml#P7000497027000000000000000042D1C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000042D1D" data-uri="chapter04.xhtml#P7000497027000000000000000042D1D" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000045DA" title="473" data-uri="chapter04.xhtml#P70004970270000000000000000045DA" epub:type="pagebreak"></span>The GUI (graphic user interface) version displays the memory, program code, and processor state in graphic windows. This provides a way to readily see how the instructions flow through the processors. The control panel also allows you to reset, single-step, or run the simulator interactively.</p></li>
<li id="P7000497027000000000000000042D1E" data-uri="chapter04.xhtml#P7000497027000000000000000042D1E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000042D1F" data-uri="chapter04.xhtml#P7000497027000000000000000042D1F" class="pcalibre calibre3 pcalibre1">The text version runs the same simulator, but it only displays information by printing to the terminal. This version is not as useful for debugging, but it allows automated testing of the processor.</p></li>
</ul>
<p id="P7000497027000000000000000042D20" data-uri="chapter04.xhtml#P7000497027000000000000000042D20" class="pcalibre1 pcalibre calibre2">The control logic for the simulators is generated by translating the HCL declarations of the logic blocks into C code. This code is then compiled and linked with the rest of the simulation code. This combination makes it possible for you to test out variants of the original designs using the simulators. Testing scripts are also available that thoroughly exercise the different instructions and the different hazard possibilities.</p>
</section>
</section></body></html>
