<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>7.5 Shortest Time-to-Completion First (STCF)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part69.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part71.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 5pt;padding-left: 16pt;text-indent: 0pt;text-align: justify;">7.5 Shortest Time-to-Completion First (STCF)</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">As you might have guessed, given our previous discussion about mech- anisms such as timer interrupts and context switching, the scheduler can certainly do something else when B and C arrive: it can <b>preempt </b>job A and decide to run another job, perhaps continuing A later. SJF by our defi- nition is a <b>non-preemptive </b>scheduler, and thus suffers from the problems described above.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="209" height="58" alt="image" src="Image_048.png"/></span></p><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">A B C</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="text-indent: 0pt;line-height: 7pt;text-align: left;">A</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">[B,C arrive]</p><p class="s47" style="padding-left: 54pt;text-indent: 0pt;text-align: center;">0   20   40   60   80   100  120</p><p class="s47" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Time</p><p style="padding-top: 3pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Figure 7.5: <b>STCF Simple Example</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Fortunately, there is a scheduler which does exactly that: add preemp- tion to SJF, known as the <b>Shortest Time-to-Completion First </b>(<b>STCF</b>) or <b>Preemptive Shortest Job First </b>(<b>PSJF</b>) scheduler [CK68]. Any time a new job enters the system, it determines of the remaining jobs and new job, which has the least time left, and then schedules that one. Thus, in our example, STCF would preempt A and run B and C to completion; only when they are finished would A’s remaining time be scheduled. Figure</p><p class="s28" style="padding-left: 68pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">7.5 <span style=" color: #231F20;">shows an example.</span></p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">The result is a much-improved average turnaround time: 50 seconds</p><p class="s62" style="text-indent: 0pt;line-height: 6pt;text-align: left;">3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s63" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;line-height: 85%;text-align: justify;"><span class="p">( </span>(120<span class="s66">−</span>0)+(20<span class="s66">−</span>10)+(30<span class="s66">−</span>10)<span class="s64"> </span><span class="p">). And as before, given our new assumptions, STCF is provably optimal; given that SJF is optimal if all jobs arrive at the same time, you should probably be able to see the intuition behind the optimality of STCF.</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Thus, if we knew that job lengths, and jobs only used the CPU, and our only metric was turnaround time, STCF would be a great policy. In fact, for a number of early batch computing systems, these types of scheduling algorithms made some sense. However, the introduction of time-shared machines changed all that. Now users would sit at a terminal and de- mand interactive performance from the system as well. And thus, a new metric was born: <b>response time</b>.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Response time is defined as the time from when the job arrives in a system to the first time it is scheduled. More formally:</p><p class="s57" style="padding-top: 7pt;padding-left: 80pt;text-indent: 69pt;text-align: left;">T<span class="s58">response </span><span class="s59">= </span>T<span class="s58">firstrun </span><span class="s60">− </span>T<span class="s58">arrival         </span><span class="s61">(7.2)</span></p><p style="padding-top: 8pt;padding-left: 68pt;text-indent: 12pt;line-height: 90%;text-align: justify;">For example, if we had the schedule above (with A arriving at time 0, and B and C at time 10), the response time of each job is as follows: 0 for job A, 0 for B, and 10 for C (average: 3.33).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As you might be thinking, STCF and related disciplines are not par- ticularly good for response time. If three jobs arrive at the same time, for example, the third job has to wait for the previous two jobs to run <i>in their entirety </i>before being scheduled just once. While great for turnaround time, this approach is quite bad for response time and interactivity. In- deed, imagine sitting at a terminal, typing, and having to wait 10 seconds to see a response from the system just because some other job got sched- uled in front of yours: not too pleasant.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Thus, we are left with another problem: how can we build a scheduler that is sensitive to response time?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 4pt;padding-bottom: 1pt;padding-left: 116pt;text-indent: 0pt;text-align: left;">A   B   C</p><p style="padding-left: 105pt;text-indent: 0pt;text-align: left;"><span><img width="209" height="47" alt="image" src="Image_049.png"/></span></p><p class="s47" style="padding-left: 20pt;text-indent: 0pt;text-align: center;">0   5   10   15   20   25   30</p><p class="s47" style="padding-top: 1pt;padding-left: 18pt;text-indent: 0pt;text-align: center;">Time</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 90pt;text-indent: 0pt;text-align: left;">Figure 7.6: <b>SJF Again (Bad for Response Time)</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-top: 4pt;padding-bottom: 1pt;padding-left: 105pt;text-indent: 0pt;text-align: left;">ABCABCABCABCABC</p><p style="padding-left: 105pt;text-indent: 0pt;text-align: left;"><span><img width="211" height="48" alt="image" src="Image_050.png"/></span></p><p class="s47" style="padding-left: 20pt;text-indent: 0pt;text-align: center;">0   5   10   15   20   25   30</p><p class="s47" style="padding-top: 1pt;padding-left: 18pt;text-indent: 0pt;text-align: center;">Time</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 80pt;text-indent: 0pt;text-align: left;">Figure 7.7: <b>Round Robin (Good for Response Time)</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part69.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part71.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
