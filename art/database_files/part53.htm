<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>1.2   Purpose of Database Systems</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part52.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part54.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">1.2   <span style=" color: #00AEEF;">Purpose of Database Systems</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">To understand the purpose of database systems, consider part of a university organiza- tion that, among other data, keeps information about all instructors, students, depart- ments, and course oﬀerings. One way to keep the information on a computer is to store it in operating-system ﬁles. To allow users to manipulate the information, the system has a number of application programs that manipulate the ﬁles, including programs to:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 123pt;text-indent: 0pt;text-align: left;">• <span class="s40">Add new students, instructors, and courses.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;text-align: left;">• <span class="s40">Register students for courses and generate class rosters.</span></p><p class="s40" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: left;"><span class="s39">• </span>Assign grades to students, compute grade point averages (<span class="s41">GPA</span>), and generate tran- scripts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: right;">Programmers develop these application programs to meet the needs of the university. New application programs are added to the system as the need arises. For exam- ple, suppose that a university decides to create a new major. As a result, the university creates a new department and creates new permanent ﬁles (or adds information to existing ﬁles) to record information about all the instructors in the department, stu- dents in that major, course oﬀerings, degree requirements, and so on. The university may have to write new application programs to deal with rules speciﬁc to the new ma- jor. New application programs may also have to be written to handle new rules in the university. Thus, as time goes by, the system acquires more ﬁles and more application</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">programs.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">This typical <span class="s63">ﬁle-processing system </span>is supported by a conventional operating system. The system stores permanent records in various ﬁles, and it needs diﬀerent application programs to extract records from, and add records to, the appropriate ﬁles.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Keeping organizational information in a ﬁle-processing system has a number of major disadvantages:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Data redundancy and inconsistency</b>. Since diﬀerent programmers create the ﬁles and application programs over a long period, the various ﬁles are likely to have diﬀerent structures, and the programs may be written in several programming lan- guages. Moreover, the same information may be duplicated in several places (ﬁles). For example, if a student has a double major (say, music and mathematics), the address and telephone number of that student may appear in a ﬁle that consists of student records of students in the Music department and in a ﬁle that consists of student records of students in the Mathematics department. This redundancy leads to higher storage and access cost. In addition, it may lead to <span class="s63">data inconsistency</span>; that is, the various copies of the same data may no longer agree. For example, a changed student address may be reﬂected in the Music department records but not elsewhere in the system.</p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Diﬃculty in accessing data</b>. Suppose that one of the university clerks needs to ﬁnd out the names of all students who live within a particular postal-code area. The clerk asks the data-processing department to generate such a list. Because the designers of the original system did not anticipate this request, there is no application program on hand to meet it. There is, however, an application program to generate the list of <i>all </i>students. The university clerk now has two choices: either obtain the list of all students and extract the needed information manually or ask a programmer to write the necessary application program. Both alternatives are obviously unsatisfactory. Suppose that such a program is written and that, several days later, the same clerk needs to trim that list to include only those students who have taken at least 60 credit hours. As expected, a program to generate such a list does not exist. Again, the clerk has the preceding two options, neither of which is satisfactory.</p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">The point here is that conventional ﬁle-processing environments do not allow needed data to be retrieved in a convenient and eﬃcient manner. More responsive data-retrieval systems are required for general use.</p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s46">Data isolation</span><span class="p">. Because data are scattered in various ﬁles, and ﬁles may be in dif- ferent formats, writing new application programs to retrieve the appropriate data is diﬃcult.</span></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Integrity problems</b>. The data values stored in the database must satisfy certain types of <span class="s63">consistency constraints</span>. Suppose the university maintains an account for each department, and records the balance amount in each account. Suppose also that the university requires that the account balance of a department may never fall below zero. Developers enforce these constraints in the system by adding appro- priate code in the various application programs. However, when new constraints are added, it is diﬃcult to change the programs to enforce them. The problem is compounded when constraints involve several data items from diﬀerent ﬁles.</p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s46">Atomicity problems</span><span class="p">. A computer system, like any other device, is subject to failure. In many applications, it is crucial that, if a failure occurs, the data be restored to the</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;">consistent state that existed prior to the failure. Consider a banking system with a program to transfer $500 from account <i>A </i>to account <i>B</i>. If a system failure occurs during the execution of the program, it is possible that the $500 was removed from the balance of account <i>A </i>but was not credited to the balance of account <i>B</i>, resulting in an inconsistent database state. Clearly, it is essential to database consistency that either both the credit and debit occur, or that neither occur. That is, the funds transfer must be <i>atomic </i>— it must happen in its entirety or not at all. It is diﬃcult to ensure atomicity in a conventional ﬁle-processing system.</p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Concurrent-access anomalies</b>. For the sake of overall performance of the system and faster response, many systems allow multiple users to update the data simulta- neously. Indeed, today, the largest internet retailers may have millions of accesses per day to their data by shoppers. In such an environment, interaction of concur- rent updates is possible and may result in inconsistent data. Consider account <i>A</i>, with a balance of $10,000. If two bank clerks debit the account balance (by say</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">$500 and $100, respectively) of account <i>A </i>at almost exactly the same time, the re- sult of the concurrent executions may leave the account balance in an incorrect (or inconsistent) state. Suppose that the programs executing on behalf of each with- drawal read the old balance, reduce that value by the amount being withdrawn, and write the result back. If the two programs run concurrently, they may both read the value $10,000, and write back $9500 and $9900, respectively. Depending on which one writes the value last, the balance of account <i>A </i>may contain either $9500 or $9900, rather than the correct value of $9400. To guard against this possibility, the system must maintain some form of supervision. But supervision is diﬃcult to provide because data may be accessed by many diﬀerent application programs that have not been coordinated previously.</p><p style="padding-left: 139pt;text-indent: 22pt;text-align: justify;">As another example, suppose a registration program maintains a count of students registered for a course in order to enforce limits on the number of students registered. When a student registers, the program reads the current count for the courses, veriﬁes that the count is not already at the limit, adds one to the count, and stores the count back in the database. Suppose two students register concurrently, with the count at 39. The two program executions may both read the value 39, and both would then write back 40, leading to an incorrect increase of only 1, even though two students successfully registered for the course and the count should be 41. Furthermore, suppose the course registration limit was 40; in the above case both students would be able to register, leading to a violation of the limit of 40 students.</p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s46">Security problems</span><span class="p">. Not every user of the database system should be able to access all the data. For example, in a university, payroll personnel need to see only that part of the database that has ﬁnancial information. They do not need access to information about academic records. But since application programs are added to the ﬁle-processing system in an ad hoc manner, enforcing such security constraints is diﬃcult.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;"><a name="bookmark11">These diﬃculties, among others, prompted both the initial development of database systems and the transition of ﬁle-based applications to database systems, back in the 1960s and 1970s.</a><a name="bookmark23">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In what follows, we shall see the concepts and algorithms that enable database systems to solve the problems with ﬁle-processing systems. In most of this book, we use a university organization as a running example of a typical data-processing application.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part52.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part54.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
