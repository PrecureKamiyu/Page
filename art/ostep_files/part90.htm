<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>8.6 MLFQ: Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part89.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part91.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 16pt;text-indent: 0pt;text-align: left;">8.6 MLFQ: Summary</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We have described a scheduling approach known as the Multi-Level Feedback Queue (MLFQ). Hopefully you can now see why it is called that: it has <i>multiple levels </i>of queues, and uses <i>feedback </i>to determine the priority of a given job. History is its guide: pay attention to how jobs behave over time and treat them accordingly.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 81pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: U<span class="s7">SE </span>A<span class="s7">DVICE </span>W<span class="s7">HERE </span>P<span class="s7">OSSIBLE</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">As the operating system rarely knows what is best for each and every process of the system, it is often useful to provide interfaces to allow users or administrators to provide some <b>hints </b>to the OS. We often call such hints <b>advice</b>, as the OS need not necessarily pay attention to it, but rather might take the advice into account in order to make a better decision. Such hints are useful in many parts of the OS, including the scheduler (e.g., with <span class="s41">nice</span>), memory manager (e.g., <span class="s41">madvise</span>), and file system (e.g., TIP [P+95]).</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The refined set of MLFQ rules, spread throughout the chapter, are re- produced here for your viewing pleasure:</p><p style="padding-top: 7pt;padding-left: 82pt;text-indent: 0pt;line-height: 11pt;text-align: justify;"><span class="s4">• </span><b>Rule 1: </b>If Priority(A) <span class="s43">&gt; </span>Priority(B), A runs (B doesn’t).</p><p style="padding-left: 82pt;text-indent: 0pt;line-height: 10pt;text-align: justify;"><span class="s4">• </span><b>Rule 2: </b>If Priority(A) <span class="s44">= </span>Priority(B), A &amp; B run in RR.</p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 90%;text-align: justify;">• <span class="s27">Rule 3: </span><span class="p">When a job enters the system, it is placed at the highest priority (the topmost queue).</span></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Rule 4: </span><span class="p">Once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).</span></p><p style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><b>Rule 5: </b>After some time period <span class="s43">S</span>, move all the jobs in the system to the topmost queue.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">MLFQ is interesting because instead of demanding <i>a priori </i>knowledge of the nature of a job, it instead observes the execution of a job and pri- oritizes it accordingly. In this way, it manages to achieve the best of both worlds: it can deliver excellent overall performance (similar to SJF/STCF) for short-running interactive jobs, and is fair and makes progress for long- running CPU-intensive workloads. For this reason, many systems, in- cluding BSD U<span class="s7">NIX </span>derivatives [LM+89, B86], Solaris [M06], and Win- dows NT and subsequent Windows operating systems [CS97] use a form of MLFQ as their base scheduler.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part89.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part91.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
