<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>36.3 The Canonical Protocol</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part368.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part370.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 7pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">36.3 The Canonical Protocol</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In the picture above, the (simplified) device interface is comprised of three registers: a <b>status </b>register, which can be read to see the current sta- tus of the device; a <b>command </b>register, to tell the device to perform a cer- tain task; and a <b>data </b>register to pass data to the device, or get data from the device. By reading and writing these registers, the operating system can control device behavior.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let us now describe a typical interaction that the OS might have with the device in order to get the device to do something on its behalf. The protocol is as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">While (STATUS == BUSY)</p><p class="s38" style="padding-left: 53pt;text-indent: 16pt;text-align: left;">; // wait until device is not busy Write data to DATA register</p><p class="s38" style="padding-left: 53pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Write command to COMMAND register</p><p class="s38" style="padding-left: 53pt;text-indent: 16pt;text-align: left;">(Doing so starts the device and executes the command) While (STATUS == BUSY)</p><p class="s38" style="padding-left: 70pt;text-indent: 0pt;line-height: 8pt;text-align: left;">; // wait until device is done with your request</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The protocol has four steps. In the first, the OS waits until the device is ready to receive a command by repeatedly reading the status register; we call this <b>polling </b>the device (basically, just asking it what is going on). Sec- ond, the OS sends some data down to the data register; one can imagine that if this were a disk, for example, that multiple writes would need to take place to transfer a disk block (say 4KB) to the device. When the main CPU is involved with the data movement (as in this example protocol), we refer to it as <b>programmed I/O (PIO)</b>. Third, the OS writes a command to the command register; doing so implicitly lets the device know that both the data is present and that it should begin working on the com- mand. Finally, the OS waits for the device to finish by again polling it in a loop, waiting to see if it is finished (it may then get an error code to indicate success or failure).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">This basic protocol has the positive aspect of being simple and work- ing. However, there are some inefficiencies and inconveniences involved. The first problem you might notice in the protocol is that polling seems inefficient; specifically, it wastes a great deal of CPU time just waiting for the (potentially slow) device to complete its activity, instead of switching to another ready process and thus better utilizing the CPU.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>A<span class="s7">VOID </span>T<span class="s7">HE </span>C<span class="s7">OSTS </span>O<span class="s7">F </span>P<span class="s7">OLLING</span></p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: left;">How can the OS check device status without frequent polling, and thus lower the CPU overhead required to manage the device?</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part368.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part370.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
