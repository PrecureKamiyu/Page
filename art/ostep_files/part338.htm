<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Order-Violation Bugs</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part337.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part339.htm">下一个 &gt;</a></p><p class="s32" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Order-Violation Bugs</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Another common type of non-deadlock bug found by Lu et al. is known as an <b>order violation</b>. Here is another simple example; once again, see if you can figure out why the code below has a bug in it.</p><p class="s37" style="padding-top: 7pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">Thread 1::</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">void init() {</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3   <span class="s38">...</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4    <span class="s38">mThread = PR_CreateThread(mMain, ...);</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5   <span class="s38">...</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">7</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">8  <span class="s38">Thread 2::</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">9  <span class="s38">void mMain(...) {</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">10    <span class="s38">...</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11    <span class="s38">mState = mThread-&gt;State;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12    <span class="s38">...</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">13  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As you probably figured out, the code in Thread 2 seems to assume that the variable <span class="s41">mThread </span>has already been initialized (and is not NULL); however, if Thread 1 does not happen to run first, we are out of luck, and Thread 2 will likely crash with a NULL pointer dereference (assuming</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: justify;">that the value of <span class="s41">mThread </span>is initially NULL; if not, even stranger things could happen as arbitrary memory locations are read through the deref- erence in Thread 2).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The more formal definition of an order violation is this: “The desired order between two (groups of) memory accesses is flipped (i.e., <span class="s43">A </span>should always be executed before <span class="s43">B</span>, but the order is not enforced during execu- tion).” [L+08]</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The fix to this type of bug is generally to enforce ordering. As we discussed in detail previously, using <b>condition variables </b>is an easy and robust way to add this style of synchronization into modern code bases. In the example above, we could thus rewrite the code as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">pthread_mutex_t mtLock = PTHREAD_MUTEX_INITIALIZER;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2  <span class="s38">pthread_cond_t mtCond = PTHREAD_COND_INITIALIZER;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">int mtInit     = 0;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">4</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5  <span class="s38">Thread 1::</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6  <span class="s38">void init() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7   <span class="s38">...</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8    <span class="s38">mThread = PR_CreateThread(mMain, ...);</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">9</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">10    <span class="s38">// signal that the thread has been created...</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">11   <span class="s38">pthread_mutex_lock(&amp;mtLock);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">12    <span class="s38">mtInit = 1;</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">13   <span class="s38">pthread_cond_signal(&amp;mtCond);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">14   <span class="s38">pthread_mutex_unlock(&amp;mtLock);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">15   <span class="s38">...</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">16  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">17</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">18  <span class="s38">Thread 2::</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">19  <span class="s38">void mMain(...) {</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">20    <span class="s38">...</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">21     <span class="s38">// wait for the thread to be initialized...</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">22    <span class="s38">pthread_mutex_lock(&amp;mtLock);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">23    <span class="s38">while (mtInit == 0)</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">24       <span class="s38">pthread_cond_wait(&amp;mtCond, &amp;mtLock);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">25    <span class="s38">pthread_mutex_unlock(&amp;mtLock);</span></p><p class="s37" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">26</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">27    <span class="s38">mState = mThread-&gt;State;</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">28    <span class="s38">...</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">29  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">In this fixed-up code sequence, we have added a lock (<span class="s41">mtLock</span>) and corresponding condition variable (<span class="s41">mtCond</span>), as well as a state variable (<span class="s41">mtInit</span>). When the initialization code runs, it sets the state of <span class="s41">mtInit </span>to 1 and signals that it has done so. If Thread 2 had run before this point, it will be waiting for this signal and corresponding state change; if it runs later, it will check the state and see that the initialization has already oc- curred (i.e., <span class="s41">mtInit </span>is set to 1), and thus continue as is proper. Note that we could likely use <span class="s41">mThread </span>as the state variable itself, but do not do so for the sake of simplicity here. When ordering matters between threads, condition variables (or semaphores) can come to the rescue.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part337.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part339.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
