<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Log-structured File Systems</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part477.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part479.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 150pt;text-indent: 0pt;text-align: left;">Log-structured File Systems</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In the early 90’s, a group at Berkeley led by Professor John Ousterhout and graduate student Mendel Rosenblum developed a new file system known as the log-structured file system [RO91]. Their motivation to do so was based on the following observations:</p><p class="s4" style="padding-top: 4pt;padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Memory sizes were growing</span><span class="p">: As memory got bigger, more data could be cached in memory. As more data is cached, disk traffic would increasingly consist of writes, as reads would be serviced in the cache. Thus, file system performance would largely be deter- mined by its performance for writes.</span></p><p class="s4" style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">There was a large and growing gap between random I/O perfor- mance and sequential I/O performance</span><span class="p">: Transfer bandwidth in- creases roughly 50%-100% every year; seek and rotational delay costs decrease much more slowly, maybe at 5%-10% per year [P98]. Thus, if one is able to use disks in a sequential manner, one gets a huge performance advantage, which grows over time.</span></p><p class="s4" style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Existing file systems perform poorly on many common workloads</span><span class="p">: For example, FFS [MJLF84] would perform a large number of writes to create a new file of size one block: one for a new inode, one to update the inode bitmap, one to the directory data block that the file is in, one to the directory inode to update it, one to the new data block that is apart of the new file, and one to the data bitmap to mark the data block as allocated. Thus, although FFS would place all of these blocks within the same block group, FFS would incur many short seeks and subsequent rotational delays and thus per- formance would fall far short of peak sequential bandwidth.</span></p><p class="s27" style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: left;"><span class="s4">• </span>File systems were not RAID-aware<span class="p">: For example, RAID-4 and RAID- 5 have the </span>small-write problem <span class="p">where a logical write to a single block causes 4 physical I/Os to take place. Existing file systems do not try to avoid this worst-case RAID writing behavior.</span></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">An ideal file system would thus focus on write performance, and try to make use of the sequential bandwidth of the disk. Further, it would perform well on common workloads that not only write out data but also</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">511</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">update on-disk metadata structures frequently. Finally, it would work well on RAIDs as well as single disks.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The new type of file system Rosenblum and Ousterhout introduced was called <b>LFS</b>, short for the <b>Log-structured File System</b>. When writ- ing to disk, LFS first buffers all updates (including metadata!) in an in- memory <b>segment</b>; when the segment is full, it is written to disk in one long, sequential transfer to an unused part of the disk, i.e., LFS never overwrites existing data, but rather <i>always </i>writes segments to free loca- tions. Because segments are large, the disk is used efficiently, and perfor- mance of the file system approaches its zenith.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>:</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: center;">H<span class="s7">OW </span>T<span class="s7">O </span>M<span class="s7">AKE </span>A<span class="s7">LL </span>W<span class="s7">RITES </span>S<span class="s7">EQUENTIAL </span>W<span class="s7">RITES</span>?</p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: justify;">How can a file system turns all writes into sequential writes? For reads, this task is impossible, as the desired block to be read may be any- where on disk. For writes, however, the file system always has a choice, and it is exactly this choice we hope to exploit.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part479.htm">43.1 Writing To Disk Sequentially</a><a class="toc0" href="part480.htm">43.2 Writing Sequentially And Effectively</a><a class="toc0" href="part481.htm">43.3 How Much To Buffer?</a><a class="toc0" href="part482.htm">43.4 Problem: Finding Inodes</a><a class="toc0" href="part483.htm">43.5 Solution Through Indirection: The Inode Map</a><a class="toc0" href="part484.htm">43.6 The Checkpoint Region</a><a class="toc0" href="part485.htm">43.7 Reading A File From Disk: A Recap</a><a class="toc0" href="part486.htm">43.8 What About Directories?</a><a class="toc0" href="part487.htm">43.9 A New Problem: Garbage Collection</a><a class="toc0" href="part488.htm">43.10 Determining Block Liveness</a><a class="toc0" href="part489.htm">43.11 A Policy Question: Which Blocks To Clean, And When?</a><a class="toc0" href="part490.htm">43.12 Crash Recovery And The Log</a><a class="toc0" href="part491.htm">43.13 Summary</a><a class="toc0" href="part492.htm">References</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part477.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part479.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
