<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>31.7 How To Implement Semaphores</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part330.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part332.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">31.7 How To Implement Semaphores</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Finally, let’s use our low-level synchronization primitives, locks and condition variables, to build our own version of semaphores called ... <i>(drum roll here) </i>... <b>Zemaphores</b>. This task is fairly straightforward, as you can see in Figure <span style=" color: #00AEEF;">31.12</span>.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As you can see from the figure, we use just one lock and one condition variable, plus a state variable to track the value of the semaphore. Study the code for yourself until you really understand it. Do it!</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One subtle difference between our Zemaphore and pure semaphores as defined by Dijkstra is that we don’t maintain the invariant that the value of the semaphore, when negative, reflects the number of waiting threads; indeed, the value will never be lower than zero. This behavior is easier to implement and matches the current Linux implementation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 67pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: B<span class="s7">E </span>C<span class="s7">AREFUL </span>W<span class="s7">ITH </span>G<span class="s7">ENERALIZATION</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The abstract technique of generalization can thus be quite useful in sys- tems design, where one good idea can be made slightly broader and thus solve a larger class of problems. However, be careful when generalizing; as Lampson warns us “Don’t generalize; generalizations are generally wrong” [L83].</p><p style="padding-top: 2pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">One could view semaphores as a generalization of locks and condition variables; however, is such a generalization needed? And, given the dif- ficulty of realizing a condition variable on top of a semaphore, perhaps this generalization is not as general as you might think.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Curiously, building locks and condition variables out of semaphores is a much trickier proposition. Some highly experienced concurrent pro- grammers tried to do this in the Windows environment, and many differ- ent bugs ensued [B04]. Try it yourself, and see if you can figure out why building condition variables out of semaphores is more challenging than it might appear.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part330.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part332.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
