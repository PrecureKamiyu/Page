<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>48.5 The NFSv2 Protocol</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part523.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part525.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">48.5 The NFSv2 Protocol</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We thus arrive at the NFSv2 protocol definition. Our problem state- ment is simple:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>D<span class="s7">EFINE </span>A S<span class="s7">TATELESS </span>F<span class="s7">ILE </span>P<span class="s7">ROTOCOL</span></p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: justify;">How can we define the network protocol to enable stateless operation? Clearly, stateful calls like <span class="s41">open() </span>can’t be a part of the discussion (as it would require the server to track open files); however, the client appli- cation will want to call <span class="s41">open()</span>, <span class="s41">read()</span>, <span class="s41">write()</span>, <span class="s41">close() </span>and other standard API calls to access files and directories. Thus, as a refined ques- tion, how do we define the protocol to both be stateless <i>and </i>support the POSIX file system API?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One key to understanding the design of the NFS protocol is under- standing the <b>file handle</b>. File handles are used to uniquely describe the file or directory a particular operation is going to operate upon; thus, many of the protocol requests include a file handle.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">You can think of a file handle as having three important components: a <i>volume identifier</i>, an <i>inode number</i>, and a <i>generation number</i>; together, these three items comprise a unique identifier for a file or directory that a client wishes to access. The volume identifier informs the server which file sys- tem the request refers to (an NFS server can export more than one file system); the inode number tells the server which file within that partition the request is accessing. Finally, the generation number is needed when reusing an inode number; by incrementing it whenever an inode num- ber is reused, the server ensures that a client with an old file handle can’t accidentally access the newly-allocated file.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Here is a summary of some of the important pieces of the protocol; the full protocol is available elsewhere (see Callaghan’s book for an excellent and detailed overview of NFS [C00]).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">NFSPROC_GETATTR</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: file handle returns: attributes</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">NFSPROC_SETATTR</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: file handle, attributes returns: nothing</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">NFSPROC_LOOKUP</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: directory file handle, name of file/directory to look up returns: file handle</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">NFSPROC_READ</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: file handle, offset, count returns: data, attributes</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">NFSPROC_WRITE</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: file handle, offset, count, data returns: attributes</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">NFSPROC_CREATE</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: directory file handle, name of file, attributes returns: nothing</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">NFSPROC_REMOVE</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: directory file handle, name of file to be removed returns: nothing</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">NFSPROC_MKDIR</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: directory file handle, name of directory, attributes returns: file handle</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">NFSPROC_RMDIR</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: directory file handle, name of directory to be removed returns: nothing</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">NFSPROC_READDIR</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">expects: directory handle, count of bytes to read, cookie returns: directory entries, cookie (to get more entries)</p><p style="padding-top: 5pt;padding-left: 130pt;text-indent: 0pt;text-align: left;">Figure 48.4: <b>The NFS Protocol: Examples</b></p><p style="padding-top: 6pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: right;">We briefly highlight the important components of the protocol. First, the LOOKUP protocol message is used to obtain a file handle, which is then subsequently used to access file data. The client passes a directory file handle and name of a file to look up, and the handle to that file (or directory) plus its attributes are passed back to the client from the server. For example, assume the client already has a directory file handle for the root directory of a file system (<span class="s41">/</span>) (indeed, this would be obtained through the NFS <b>mount protocol</b>, which is how clients and servers first are connected together; we do not discuss the mount protocol here for sake of brevity). If an application running on the client opens the file</p><p class="s41" style="padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: justify;">/foo.txt<span class="p">, the client-side file system sends a lookup request to the server, passing it the root file handle and the name </span>foo.txt<span class="p">; if successful, the file handle (and attributes) for </span>foo.txt <span class="p">will be returned.</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In case you are wondering, attributes are just the metadata that the file system tracks about each file, including fields such as file creation time, last modification time, size, ownership and permissions information, and so forth, i.e., the same type of information that you would get back if you called <span class="s41">stat() </span>on a file.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Once a file handle is available, the client can issue READ and WRITE protocol messages on a file to read or write the file, respectively. The READ protocol message requires the protocol to pass along the file handle</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">of the file along with the offset within the file and number of bytes to read. The server then will be able to issue the read (after all, the handle tells the server which volume and which inode to read from, and the offset and count tells it which bytes of the file to read) and return the data to the client (or an error if there was a failure). WRITE is handled similarly, except the data is passed from the client to the server, and just a success code is returned.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One last interesting protocol message is the GETATTR request; given a file handle, it simply fetches the attributes for that file, including the last modified time of the file. We will see why this protocol request is impor- tant in NFSv2 below when we discuss caching (can you guess why?).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part523.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part525.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
