<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Practice Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part272.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part274.htm">下一个 &gt;</a></p><p class="s45" style="padding-top: 4pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">Practice Exercises</p><p class="s46" style="padding-top: 12pt;padding-left: 155pt;text-indent: -29pt;text-align: justify;">14.1  <span class="p">Indices speed query processing, but it is usually a bad idea to create indices on every attribute, and every combination of attributes, that are potential search keys. Explain why.</span></p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;">14.2  <span class="p">Is it possible in general to have two clustering indices on the same relation for diﬀerent search keys? Explain your answer.</span></p><p style="padding-top: 5pt;padding-left: 125pt;text-indent: 0pt;text-align: justify;"><b>14.3  </b>Construct a B<span class="s181">+</span>-tree for the following set of key values:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 255pt;text-indent: 0pt;text-align: left;">(2, 3, 5, 7, 11, 17, 19, 23, 29, 31)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 124pt;text-indent: 0pt;text-align: justify;">Assume that the tree is initially empty and values are added in ascending order. Construct B<span class="s181">+</span>-trees for the cases where the number of pointers that will ﬁt in one node is as follows:</p><p style="padding-top: 7pt;padding-left: 131pt;text-indent: 0pt;text-align: left;">a. Four</p><p style="padding-top: 6pt;padding-left: 130pt;text-indent: 0pt;text-align: left;">b. Six</p><p style="padding-top: 6pt;padding-left: 131pt;text-indent: 0pt;text-align: left;">c. Eight</p><p style="padding-top: 7pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;"><b>14.4 </b>For each B<span class="s181">+</span>-tree of Exercise 14.3, show the form of the tree after each of the following series of operations:</p><p style="padding-top: 7pt;padding-left: 131pt;text-indent: 0pt;text-align: left;">a. Insert 9.</p><p style="padding-top: 6pt;padding-left: 130pt;text-indent: 0pt;text-align: left;">b. Insert 10.</p><p style="padding-top: 6pt;padding-left: 131pt;text-indent: 0pt;text-align: left;">c. Insert 8.</p><p style="padding-top: 6pt;padding-left: 130pt;text-indent: 0pt;text-align: left;">d. Delete 23.</p><p style="padding-top: 6pt;padding-left: 131pt;text-indent: 0pt;text-align: left;">e. Delete 19.</p><p style="padding-top: 7pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;"><b>14.5  </b>Consider the modiﬁed redistribution scheme for B<span class="s181">+</span>-trees described on page 651. What is the expected height of the tree as a function of <i>n</i>?</p><p style="padding-top: 5pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;"><b>14.6  </b>Give pseudocode for a B<span class="s181">+</span>-tree function <span class="s49">findRangeIterator</span>(), which is like the function <span class="s49">findRange</span>(), except that it returns an iterator object, as described in Section 14.3.2. Also give pseudocode for the iterator class, including the variables in the iterator object, and the <span class="s49">next</span>() method.</p><p style="padding-top: 5pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;"><b>14.7  </b>What would the occupancy of each leaf node of a B<span class="s181">+</span>-tree be if index entries were inserted in sorted order? Explain why.</p><p style="padding-top: 6pt;padding-left: 124pt;text-indent: -30pt;line-height: 90%;text-align: justify;"><b>14.8 </b>Suppose you have a relation <i>r </i>with <i>n</i><span class="s145">r </span>tuples on which a secondary B<span class="s181">+</span>-tree is to be constructed.</p><p style="padding-top: 7pt;padding-left: 149pt;text-indent: -18pt;text-align: justify;">a. Give a formula for the cost of building the B<span class="s181">+</span>-tree index by inserting one record at a time. Assume each block will hold an average of <i>f </i>entries and that all levels of the tree above the leaf are in memory.</p><p style="padding-top: 6pt;padding-left: 150pt;text-indent: -19pt;text-align: justify;">b. Assuming a random disk access takes 10 milliseconds, what is the cost of index construction on a relation with 10 million records?</p><p style="padding-top: 5pt;padding-left: 149pt;text-indent: -18pt;text-align: justify;">c. Write pseudocode for bottom-up construction of a B<span class="s181">+</span>-tree, which was outlined in Section 14.4.4. You can assume that a function to eﬃciently sort a large ﬁle is available.</p><p style="padding-top: 7pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;"><b>14.9 </b>The leaf nodes of a B<span class="s181">+</span>-tree ﬁle organization may lose sequentiality after a se- quence of inserts.</p><p style="padding-top: 7pt;padding-left: 131pt;text-indent: 0pt;text-align: left;">a. Explain why sequentiality may be lost.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 181pt;text-indent: -19pt;text-align: justify;">b. To minimize the number of seeks in a sequential scan, many databases allocate leaf pages in extents of <i>n </i>blocks, for some reasonably large <i>n</i>. When the ﬁrst leaf of a B<span class="s181">+</span>-tree is allocated, only one block of an <i>n</i>-block unit is used, and the remaining pages are free. If a page splits, and its <i>n</i>-block unit has a free page, that space is used for the new page. If the <i>n</i>-block unit is full, another <i>n</i>-block unit is allocated, and the ﬁrst <i>n</i><span class="s15">∕</span>2 leaf pages are placed in one <i>n</i>-block unit and the remaining one in the second <i>n</i>-block unit. For simplicity, assume that there are no delete operations.</p><p style="padding-top: 2pt;padding-left: 197pt;text-indent: -16pt;text-align: justify;">i. What is the worst-case occupancy of allocated space, assuming no delete operations, after the ﬁrst <i>n</i>-block unit is full?</p><p style="padding-top: 2pt;padding-left: 197pt;text-indent: -19pt;text-align: justify;">ii.  Is it possible that leaf nodes allocated to an <i>n</i>-node block unit are not consecutive, that is, is it possible that two leaf nodes are allocated to one <i>n</i>-node block, but another leaf node in between the two is allocated to a diﬀerent <i>n</i>-node block?</p><p style="padding-top: 2pt;padding-left: 197pt;text-indent: -22pt;text-align: justify;">iii.  Under the reasonable assumption that buﬀer space is suﬃcient to store an <i>n</i>-page block, how many seeks would be required for a leaf- level scan of the B<span class="s181">+</span>-tree, in the worst case? Compare this number with the worst case if leaf pages are allocated a block at a time.</p><p style="padding-top: 2pt;padding-left: 197pt;text-indent: -20pt;text-align: justify;">iv. The technique of redistributing values to siblings to improve space utilization is likely to be more eﬃcient when used with the preceding allocation scheme for leaf blocks. Explain why.</p><p class="s46" style="padding-top: 6pt;padding-left: 155pt;text-indent: -34pt;text-align: justify;">14.10 <span class="p">Suppose you are given a database schema and some queries that are executed frequently. How would you use the above information to decide what indices to create?</span></p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -34pt;text-align: justify;"><b>14.11  </b>In write-optimized trees such as the <span class="s44">LSM </span>tree or the stepped-merge index, en- tries in one level are merged into the next level only when the level is full. Suggest how this policy can be changed to improve read performance during periods when there are many reads but no updates.</p><p style="padding-top: 6pt;padding-left: 120pt;text-indent: 0pt;text-align: justify;"><b>14.12  </b>What trade oﬀs do buﬀer trees pose as compared to <span class="s44">LSM </span>trees?</p><p style="padding-top: 6pt;padding-left: 120pt;text-indent: 0pt;text-align: justify;"><b>14.13 </b>Consider the <i>instructor </i>relation shown in Figure 14.1.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: justify;">a. Construct a bitmap index on the attribute <i>salary</i>, dividing <i>salary </i>values into four ranges: below 50,000, 50,000 to below 60,000, 60,000 to below 70,000, and 70,000 and above.</p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -19pt;text-align: justify;">b.  Consider a query that requests all instructors in the Finance department with salary of 80,000 or more. Outline the steps in answering the query, and show the ﬁnal and intermediate bitmaps constructed to answer the query.</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -34pt;text-align: justify;"><b>14.14  </b>Suppose you have a relation containing the <i>x</i>, <i>y </i>coordinates and names of restaurants. Suppose also that the only queries that will be asked are of the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 124pt;text-indent: 0pt;text-align: justify;">following form: The query speciﬁes a point and asks if there is a restaurant ex- actly at that point. Which type of index would be preferable, R-tree or B-tree? Why?</p><p class="s46" style="padding-top: 6pt;padding-left: 124pt;text-indent: -34pt;text-align: justify;">14.15  <span class="p">Suppose you have a spatial database that supports region queries with circular regions, but not nearest-neighbor queries. Describe an algorithm to ﬁnd the nearest neighbor by making use of multiple region queries.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part272.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part274.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
