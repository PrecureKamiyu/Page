<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.11 Fetch-And-Add</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part289.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part291.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 5pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">28.11 Fetch-And-Add</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One final hardware primitive is the <b>fetch-and-add </b>instruction, which atomically increments a value while returning the old value at a partic- ular address. The C pseudocode for the fetch-and-add instruction looks like this:</p><p class="s38" style="padding-top: 7pt;padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">1  </span>int FetchAndAdd(int <span class="s39">*</span>ptr) {</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">2    </span>int old = <span class="s39">*</span>ptr;</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 85%;text-align: left;">3    <span class="s39">*</span><span class="s38">ptr = old + 1;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">4    <span class="s38">return old;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this example, we’ll use fetch-and-add to build a more interesting <b>ticket lock</b>, as introduced by Mellor-Crummey and Scott [MS91]. The lock and unlock code looks like what you see in Figure <span style=" color: #00AEEF;">28.6</span>.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Instead of a single value, this solution uses a ticket and turn variable in combination to build a lock. The basic operation is pretty simple: when a thread wishes to acquire a lock, it first does an atomic fetch-and-add on the ticket value; that value is now considered this thread’s “turn” (<span class="s41">myturn</span>). The globally shared <span class="s41">lock-&gt;turn </span>is then used to determine which thread’s turn it is; when <span class="s41">(myturn == turn) </span>for a given thread,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 5pt;padding-left: 26pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>typedef struct <span class="s75">&nbsp;</span>lock_t {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2    <span class="s38">int ticket;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3    <span class="s38">int turn;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4  <span class="s38">} lock_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">5</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">6  </span>void lock_init(lock_t <span class="s39">*</span>lock) {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">7    <span class="s38">lock-&gt;ticket = 0;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">8     <span class="s38">lock-&gt;turn = 0;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">9  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">10</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">11  </span>void lock(lock_t <span class="s39">*</span>lock) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">12    <span class="s38">int myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">13    <span class="s38">while (lock-&gt;turn != myturn)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14       <span class="s38">; // spin</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">16</p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">17  </span>void unlock(lock_t <span class="s39">*</span>lock) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">18    <span class="s38">FetchAndAdd(&amp;lock-&gt;turn);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19  <span class="s38">}</span></p><p style="padding-left: 134pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Figure 28.6: <b>Ticket Locks</b></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">it is that thread’s turn to enter the critical section. Unlock is accomplished simply by incrementing the turn such that the next waiting thread (if there is one) can now enter the critical section.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Note one important difference with this solution versus our previous attempts: it ensures progress for all threads. Once a thread is assigned its ticket value, it will be scheduled at some point in the future (once those in front of it have passed through the critical section and released the lock). In our previous attempts, no such guarantee existed; a thread spinning on test-and-set (for example) could spin forever even as other threads acquire and release the lock.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part289.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part291.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
