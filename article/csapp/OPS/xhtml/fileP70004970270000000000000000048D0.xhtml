<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.1 Capabilities and Limitations of Optimizing Compilers</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P70004970270000000000000000048D0" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P700049702700000000000000004301E" data-uri="chapter05.xhtml#P700049702700000000000000004301E" epub:type="title"><span class="pcalibre label pcalibre1">5.1 </span>Capabilities and Limitations of Optimizing Compilers</h1></header>
<p id="P700049702700000000000000004301F" data-uri="chapter05.xhtml#P700049702700000000000000004301F" class="pcalibre1 pcalibre calibre2">Modern compilers employ sophisticated algorithms to determine what values are computed in a program and how they are used. They can then exploit opportunities to simplify expressions, to use a single computation in several different places, and to reduce the number of times a given computation must be performed. Most compilers, including <span class="smallcaps pcalibre pcalibre1">gcc</span>, provide users with some control over which optimizations they apply. As discussed in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">3</span></a>, the simplest control is to specify the <i class="calibre5 pcalibre pcalibre1">optimization level.</i> For example, invoking <span class="smallcaps pcalibre pcalibre1">gcc </span>with the command-line option <code id="P7000497027000000000000000043020" data-uri="chapter05.xhtml#P7000497027000000000000000043020" class="pcalibre1 calibre8 pcalibre">−0g</code> specifies that it should apply a basic set of optimizations.</p>
<p id="P7000497027000000000000000043021" data-uri="chapter05.xhtml#P7000497027000000000000000043021" class="pcalibre1 pcalibre calibre2">Invoking <span class="smallcaps pcalibre pcalibre1">gcc </span>with option <code id="P7000497027000000000000000043022" data-uri="chapter05.xhtml#P7000497027000000000000000043022" class="pcalibre1 calibre8 pcalibre">−01</code> or higher (e.g., <code id="P7000497027000000000000000043023" data-uri="chapter05.xhtml#P7000497027000000000000000043023" class="pcalibre1 calibre8 pcalibre">−02</code> or <code id="P7000497027000000000000000043024" data-uri="chapter05.xhtml#P7000497027000000000000000043024" class="pcalibre1 calibre8 pcalibre">−03</code>) will cause it to apply more extensive optimizations. These can further improve program performance, but they may expand the program size and they may make the program more difficult to debug using standard debugging tools. For our presentation, we will mostly consider code compiled with optimization level <code id="P7000497027000000000000000043025" data-uri="chapter05.xhtml#P7000497027000000000000000043025" class="pcalibre1 calibre8 pcalibre">−01</code>, even though level <code id="P7000497027000000000000000043026" data-uri="chapter05.xhtml#P7000497027000000000000000043026" class="pcalibre1 calibre8 pcalibre">−02</code> has become the accepted standard for most software projects that use <span class="smallcaps pcalibre pcalibre1">gcc</span>. We purposely limit the level of optimization to demonstrate how different ways of writing a function in C can affect the efficiency of the code generated by a compiler. We will find that we can write C code that, when compiled just with option <code id="P7000497027000000000000000043027" data-uri="chapter05.xhtml#P7000497027000000000000000043027" class="pcalibre1 calibre8 pcalibre">−01</code>, vastly outperforms a more naive version compiled with the highest possible optimization levels.</p>
<p id="P7000497027000000000000000043028" data-uri="chapter05.xhtml#P7000497027000000000000000043028" class="pcalibre1 pcalibre calibre2">Compilers must be careful to apply only <i class="calibre5 pcalibre pcalibre1">safe</i> optimizations to a program, meaning that the resulting program will have the exact same behavior as would an unoptimized version for all possible cases the program may encounter, up to the limits of the guarantees provided by the C language standards. Constraining <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000048DC" title="499" data-uri="chapter05.xhtml#P70004970270000000000000000048DC" epub:type="pagebreak"></span>the compiler to perform only safe optimizations eliminates possible sources of undesired run-time behavior, but it also means that the programmer must make more of an effort to write programs in a way that the compiler can then transform into efficient machine-level code. To appreciate the challenges of deciding which program transformations are safe or not, consider the following two procedures:</p>
<pre id="P7000497027000000000000000043029" data-uri="chapter05.xhtml#P7000497027000000000000000043029" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004302A" data-uri="chapter05.xhtml#P700049702700000000000000004302A" class="calibre10 pcalibre pcalibre1">
1	void twiddlel(long *xp, long *yp)
2	{
3		*xp += *yp;
4		*xp += *yp;
5	}
6	
7	void twiddle2(long *xp, long *yp)
8	{
9		*xp += 2* *yp;
10	}
</code></pre>
<p id="P700049702700000000000000004302B" data-uri="chapter05.xhtml#P700049702700000000000000004302B" class="pcalibre1 pcalibre calibre2">At first glance, both procedures seem to have identical behavior. They both add twice the value stored at the location designated by pointer <code id="P700049702700000000000000004302C" data-uri="chapter05.xhtml#P700049702700000000000000004302C" class="pcalibre1 calibre8 pcalibre">yp</code> to that designated by pointer <code id="P700049702700000000000000004302D" data-uri="chapter05.xhtml#P700049702700000000000000004302D" class="pcalibre1 calibre8 pcalibre">xp</code>. On the other hand, function <code id="P700049702700000000000000004302E" data-uri="chapter05.xhtml#P700049702700000000000000004302E" class="pcalibre1 calibre8 pcalibre">twiddle2</code> is more efficient. It requires only three memory references (read <code id="P700049702700000000000000004302F" data-uri="chapter05.xhtml#P700049702700000000000000004302F" class="pcalibre1 calibre8 pcalibre">*xp</code>, read <code id="P7000497027000000000000000043030" data-uri="chapter05.xhtml#P7000497027000000000000000043030" class="pcalibre1 calibre8 pcalibre">*yp</code>, write <code id="P7000497027000000000000000043031" data-uri="chapter05.xhtml#P7000497027000000000000000043031" class="pcalibre1 calibre8 pcalibre">*xp</code>), whereas <code id="P7000497027000000000000000043032" data-uri="chapter05.xhtml#P7000497027000000000000000043032" class="pcalibre1 calibre8 pcalibre">twiddle1</code> requires six (two reads of <code id="P7000497027000000000000000043033" data-uri="chapter05.xhtml#P7000497027000000000000000043033" class="pcalibre1 calibre8 pcalibre">*xp</code>, two reads of <code id="P7000497027000000000000000043034" data-uri="chapter05.xhtml#P7000497027000000000000000043034" class="pcalibre1 calibre8 pcalibre">*yp</code>, and two writes of <code id="P7000497027000000000000000043035" data-uri="chapter05.xhtml#P7000497027000000000000000043035" class="pcalibre1 calibre8 pcalibre">*xp</code>). Hence, if a compiler is given procedure <code id="P7000497027000000000000000043036" data-uri="chapter05.xhtml#P7000497027000000000000000043036" class="pcalibre1 calibre8 pcalibre">twiddle1</code> to compile, one might think it could generate more efficient code based on the computations performed by <code id="P7000497027000000000000000043037" data-uri="chapter05.xhtml#P7000497027000000000000000043037" class="pcalibre1 calibre8 pcalibre">twiddle2</code>.</p>
<p id="P7000497027000000000000000043038" data-uri="chapter05.xhtml#P7000497027000000000000000043038" class="pcalibre1 pcalibre calibre2">Consider, however, the case in which <code id="P7000497027000000000000000043039" data-uri="chapter05.xhtml#P7000497027000000000000000043039" class="pcalibre1 calibre8 pcalibre">xp</code> and <code id="P700049702700000000000000004303A" data-uri="chapter05.xhtml#P700049702700000000000000004303A" class="pcalibre1 calibre8 pcalibre">yp</code> are equal. Then function <code id="P700049702700000000000000004303B" data-uri="chapter05.xhtml#P700049702700000000000000004303B" class="pcalibre1 calibre8 pcalibre">twiddle1</code> will perform the following computations:</p>
<pre id="P700049702700000000000000004303C" data-uri="chapter05.xhtml#P700049702700000000000000004303C" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004303D" data-uri="chapter05.xhtml#P700049702700000000000000004303D" class="calibre10 pcalibre pcalibre1">
3	*xp += *xp; /* Double value at xp */
4	*xp += *xp; /* Double value at xp */
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004303E" data-uri="chapter05.xhtml#P700049702700000000000000004303E">The result will be that the value at <code id="P700049702700000000000000004303F" data-uri="chapter05.xhtml#P700049702700000000000000004303F" class="pcalibre1 calibre8 pcalibre">xp</code> will be increased by a factor of 4. On the other hand, function <code id="P7000497027000000000000000043040" data-uri="chapter05.xhtml#P7000497027000000000000000043040" class="pcalibre1 calibre8 pcalibre">twiddle2</code> will perform the following computation:</p>
<pre id="P7000497027000000000000000043041" data-uri="chapter05.xhtml#P7000497027000000000000000043041" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043042" data-uri="chapter05.xhtml#P7000497027000000000000000043042" class="calibre10 pcalibre pcalibre1">
9	*xp += 2* *xp; /* Triple value at xp */
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043043" data-uri="chapter05.xhtml#P7000497027000000000000000043043">The result will be that the value at <code id="P7000497027000000000000000043044" data-uri="chapter05.xhtml#P7000497027000000000000000043044" class="pcalibre1 calibre8 pcalibre">xp</code> will be increased by a factor of 3. The compiler knows nothing about how <code id="P7000497027000000000000000043045" data-uri="chapter05.xhtml#P7000497027000000000000000043045" class="pcalibre1 calibre8 pcalibre">twiddle1</code> will be called, and so it must assume that arguments <code id="P7000497027000000000000000043046" data-uri="chapter05.xhtml#P7000497027000000000000000043046" class="pcalibre1 calibre8 pcalibre">xp</code> and <code id="P7000497027000000000000000043047" data-uri="chapter05.xhtml#P7000497027000000000000000043047" class="pcalibre1 calibre8 pcalibre">yp</code> can be equal. It therefore cannot generate code in the style of <code id="P7000497027000000000000000043048" data-uri="chapter05.xhtml#P7000497027000000000000000043048" class="pcalibre1 calibre8 pcalibre">twiddle2</code> as an optimized version of <code id="P7000497027000000000000000043049" data-uri="chapter05.xhtml#P7000497027000000000000000043049" class="pcalibre1 calibre8 pcalibre">twiddle1</code>.</p>
<p id="P700049702700000000000000004304A" data-uri="chapter05.xhtml#P700049702700000000000000004304A" class="pcalibre1 pcalibre calibre2">The case where two pointers may designate the same memory location is known as <i class="calibre5 pcalibre pcalibre1">memory aliasing.</i> In performing only safe optimizations, the compiler must assume that different pointers may be aliased. As another example, for a program with pointer variables <code id="P700049702700000000000000004304B" data-uri="chapter05.xhtml#P700049702700000000000000004304B" class="pcalibre1 calibre8 pcalibre">p</code> and <code id="P700049702700000000000000004304C" data-uri="chapter05.xhtml#P700049702700000000000000004304C" class="pcalibre1 calibre8 pcalibre">q</code>, consider the following code sequence:</p>
<pre id="P700049702700000000000000004304D" data-uri="chapter05.xhtml#P700049702700000000000000004304D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004304E" data-uri="chapter05.xhtml#P700049702700000000000000004304E" class="calibre10 pcalibre pcalibre1">
x = 1000; y = 3000;
*q = y; /* 3000 */
*p = x; /* 1000 */
t1 = *q; /* 1000 or 3000 */
</code></pre>
<p id="P700049702700000000000000004304F" data-uri="chapter05.xhtml#P700049702700000000000000004304F" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004904" title="500" data-uri="chapter05.xhtml#P7000497027000000000000000004904" epub:type="pagebreak"></span>The value computed for <code id="P7000497027000000000000000043050" data-uri="chapter05.xhtml#P7000497027000000000000000043050" class="pcalibre1 calibre8 pcalibre">t1</code> depends on whether or not pointers <code id="P7000497027000000000000000043051" data-uri="chapter05.xhtml#P7000497027000000000000000043051" class="pcalibre1 calibre8 pcalibre">p</code> and <code id="P7000497027000000000000000043052" data-uri="chapter05.xhtml#P7000497027000000000000000043052" class="pcalibre1 calibre8 pcalibre">q</code> are aliased—if not, it will equal 3,000, but if so it will equal 1,000. This leads to one of the major <i class="calibre5 pcalibre pcalibre1">optimization blockers</i>, aspects of programs that can severely limit the opportunities for a compiler to generate optimized code. If a compiler cannot determine whether or not two pointers may be aliased, it must assume that either case is possible, limiting the set of possible optimizations.</p>
<section id="P7000497027000000000000000004908" data-uri="chapter05.xhtml#P7000497027000000000000000004908" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000043053" data-uri="chapter05.xhtml#P7000497027000000000000000043053" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.1 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000005090.xhtml#P70004970270000000000000000050DD">573</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000043054" data-uri="chapter05.xhtml#P7000497027000000000000000043054">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000043055" data-uri="chapter05.xhtml#P7000497027000000000000000043055">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043056" data-uri="chapter05.xhtml#P7000497027000000000000000043056"><p id="P7000497027000000000000000043057" data-uri="chapter05.xhtml#P7000497027000000000000000043057" class="pcalibre calibre3 pcalibre1">The following problem illustrates the way memory aliasing can cause unexpected program behavior. Consider the following procedure to swap two values:</p>
<pre id="P7000497027000000000000000043058" data-uri="chapter05.xhtml#P7000497027000000000000000043058" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043059" data-uri="chapter05.xhtml#P7000497027000000000000000043059" class="calibre10 pcalibre pcalibre1">
1	/* Swap value x at xp with value y at yp */
2	void swap(long *xp, long *yp)
3	{
4		*xp = *xp + *yp; /* x+y */
5		*yp = *xp - *yp; /* x+y-y = x */
6		*xp = *xp - *yp; /* x+y-x = y */
7	}
</code></pre>
<p id="P700049702700000000000000004305A" data-uri="chapter05.xhtml#P700049702700000000000000004305A" class="pcalibre calibre3 pcalibre1">If this procedure is called with <code id="P700049702700000000000000004305B" data-uri="chapter05.xhtml#P700049702700000000000000004305B" class="pcalibre1 calibre8 pcalibre">xp</code> equal to <code id="P700049702700000000000000004305C" data-uri="chapter05.xhtml#P700049702700000000000000004305C" class="pcalibre1 calibre8 pcalibre">yp</code>, what effect will it have?</p></div></li>
</ol>
</section>
<p id="P700049702700000000000000004305D" data-uri="chapter05.xhtml#P700049702700000000000000004305D" class="pcalibre1 pcalibre calibre2">A second optimization blocker is due to function calls. As an example, consider the following two procedures:</p>
<pre id="P700049702700000000000000004305E" data-uri="chapter05.xhtml#P700049702700000000000000004305E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004305F" data-uri="chapter05.xhtml#P700049702700000000000000004305F" class="calibre10 pcalibre pcalibre1">
1	long f();
2	
3	long func1() {
4		return f ()+ f ()+ f ()+ f () ;
5	}
6	
7	long func2() {
8		return 4*f();
9	}
</code></pre>
<p id="P7000497027000000000000000043060" data-uri="chapter05.xhtml#P7000497027000000000000000043060" class="pcalibre1 pcalibre calibre2">It might seem at first that both compute the same result, but with <code id="P7000497027000000000000000043061" data-uri="chapter05.xhtml#P7000497027000000000000000043061" class="pcalibre1 calibre8 pcalibre">func2</code> calling <code id="P7000497027000000000000000043062" data-uri="chapter05.xhtml#P7000497027000000000000000043062" class="pcalibre1 calibre8 pcalibre">f</code> only once, whereas <code id="P7000497027000000000000000043063" data-uri="chapter05.xhtml#P7000497027000000000000000043063" class="pcalibre1 calibre8 pcalibre">func1</code> calls it four times. It is tempting to generate code in the style of <code id="P7000497027000000000000000043064" data-uri="chapter05.xhtml#P7000497027000000000000000043064" class="pcalibre1 calibre8 pcalibre">func2</code> when given <code id="P7000497027000000000000000043065" data-uri="chapter05.xhtml#P7000497027000000000000000043065" class="pcalibre1 calibre8 pcalibre">func1</code> as the source.</p>
<p id="P7000497027000000000000000043066" data-uri="chapter05.xhtml#P7000497027000000000000000043066" class="pcalibre1 pcalibre calibre2">Consider, however, the following code for f:</p>
<pre id="P7000497027000000000000000043067" data-uri="chapter05.xhtml#P7000497027000000000000000043067" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043068" data-uri="chapter05.xhtml#P7000497027000000000000000043068" class="calibre10 pcalibre pcalibre1">
1	long counter = 0;
2	
3	long f() {
4		return counter++;
5	}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043069" data-uri="chapter05.xhtml#P7000497027000000000000000043069">This function has a <i class="calibre5 pcalibre pcalibre1">side effect</i>—it modifies some part of the global program state. Changing the number of times it gets called changes the program behavior. In</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000004920" data-uri="chapter05.xhtml#P7000497027000000000000000004920"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P700049702700000000000000004306A" data-uri="chapter05.xhtml#P700049702700000000000000004306A" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004922" title="501" data-uri="chapter05.xhtml#P7000497027000000000000000004922" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Optimizing function calls by inline substitution</h1></header>
<p id="P700049702700000000000000004306B" data-uri="chapter05.xhtml#P700049702700000000000000004306B" class="calibre13 pcalibre pcalibre1">Code involving function calls can be optimized by a process known as <i class="calibre5 pcalibre pcalibre1">inline substitution</i> (or simply "inlining"), where the function call is replaced by the code for the body of the function. For example, we can expand the code for <code id="P700049702700000000000000004306C" data-uri="chapter05.xhtml#P700049702700000000000000004306C" class="pcalibre1 calibre8 pcalibre">func1</code> by substituting four instantiations of function <code id="P700049702700000000000000004306D" data-uri="chapter05.xhtml#P700049702700000000000000004306D" class="pcalibre1 calibre8 pcalibre">f</code>:</p>
<pre id="P700049702700000000000000004306E" data-uri="chapter05.xhtml#P700049702700000000000000004306E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004306F" data-uri="chapter05.xhtml#P700049702700000000000000004306F" class="calibre10 pcalibre pcalibre1">
1	/* Result of inlining f in func1 */
2	long func1in() {
3		long t = counter++; /* +0 */
4		t += counter++; /* +1 */
5		t += counter++; /* +2 */
6		t += counter++; /* +3 */
7		return t;
8	}
</code></pre>
<p class="calibre13 pcalibre pcalibre1" id="P7000497027000000000000000043070" data-uri="chapter05.xhtml#P7000497027000000000000000043070">This transformation both reduces the overhead of the function calls and allows further optimization of the expanded code. For example, the compiler can consolidate the updates of global variable <code id="P7000497027000000000000000043071" data-uri="chapter05.xhtml#P7000497027000000000000000043071" class="pcalibre1 calibre8 pcalibre">counter</code> in <code id="P7000497027000000000000000043072" data-uri="chapter05.xhtml#P7000497027000000000000000043072" class="pcalibre1 calibre8 pcalibre">func1</code> in to generate an optimized version of the function:</p>
<pre id="P7000497027000000000000000043073" data-uri="chapter05.xhtml#P7000497027000000000000000043073" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043074" data-uri="chapter05.xhtml#P7000497027000000000000000043074" class="calibre10 pcalibre pcalibre1">
1	/* Optimization of inlined code */
2	long func1opt() {
3		long t = 4 * counter + 6;
4		counter += 4;
5		return t;
6	}
</code></pre>
<p class="calibre13 pcalibre pcalibre1" id="P7000497027000000000000000043075" data-uri="chapter05.xhtml#P7000497027000000000000000043075">This code faithfully reproduces the behavior of <code id="P7000497027000000000000000043076" data-uri="chapter05.xhtml#P7000497027000000000000000043076" class="pcalibre1 calibre8 pcalibre">func1</code> for this particular definition of function <code id="P7000497027000000000000000043077" data-uri="chapter05.xhtml#P7000497027000000000000000043077" class="pcalibre1 calibre8 pcalibre">f</code>.</p>
<p id="P7000497027000000000000000043078" data-uri="chapter05.xhtml#P7000497027000000000000000043078" class="calibre13 pcalibre pcalibre1">Recent versions of <span class="smallcaps pcalibre pcalibre1">gcc </span>attempt this form of optimization, either when directed to with the command-line option <code id="P7000497027000000000000000043079" data-uri="chapter05.xhtml#P7000497027000000000000000043079" class="pcalibre1 calibre8 pcalibre">-finline</code> or for optimization level <code id="P700049702700000000000000004307A" data-uri="chapter05.xhtml#P700049702700000000000000004307A" class="pcalibre1 calibre8 pcalibre">−01</code> and higher. Unfortunately, <span class="smallcaps pcalibre pcalibre1">gcc </span>only attempts inlining for functions defined within a single file. That means it will not be applied in the common case where a set of library functions is defined in one file but invoked by functions in other files.</p>
<p id="P700049702700000000000000004307B" data-uri="chapter05.xhtml#P700049702700000000000000004307B" class="pcalibre calibre3 pcalibre1">There are times when it is best to prevent a compiler from performing inline substitution. One is when the code will be evaluated using a symbolic debugger, such as <span class="smallcaps pcalibre pcalibre1">gdb</span>, as described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002E6D.xhtml#P7000497027000000000000000002EC0"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">3.10.2</span></a>. If a function call has been optimized away via inline substitution, then any attempt to trace or set a breakpoint for that call will fail. The second is when evaluating the performance of a program by profiling, as is discussed in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000500C.xhtml#P700049702700000000000000000500F"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">5.14.1</span></a>. Calls to functions that have been eliminated by inline substitution will not be profiled correctly.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004307C" data-uri="chapter05.xhtml#P700049702700000000000000004307C">particular, a call to <code id="P700049702700000000000000004307D" data-uri="chapter05.xhtml#P700049702700000000000000004307D" class="pcalibre1 calibre8 pcalibre">func1</code> would return 0 + 1 + 2 + 3 = 6, whereas a call to <code id="P700049702700000000000000004307E" data-uri="chapter05.xhtml#P700049702700000000000000004307E" class="pcalibre1 calibre8 pcalibre">func2</code> would return 4 · 0 = 0, assuming both started with global variable counter set to zero.</p>
<p id="P700049702700000000000000004307F" data-uri="chapter05.xhtml#P700049702700000000000000004307F" class="pcalibre1 pcalibre calibre2">Most compilers do not try to determine whether a function is free of side effects and hence is a candidate for optimizations such as those attempted in <code id="P7000497027000000000000000043080" data-uri="chapter05.xhtml#P7000497027000000000000000043080" class="pcalibre1 calibre8 pcalibre">func2</code>. Instead, the compiler assumes the worst case and leaves function calls intact.</p>
<p id="P7000497027000000000000000043081" data-uri="chapter05.xhtml#P7000497027000000000000000043081" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000493A" title="502" data-uri="chapter05.xhtml#P700049702700000000000000000493A" epub:type="pagebreak"></span>Among compilers, <span class="smallcaps pcalibre pcalibre1">gcc </span>is considered adequate, but not exceptional, in terms of its optimization capabilities. It performs basic optimizations, but it does not perform the radical transformations on programs that more "aggressive" compilers do. As a consequence, programmers using <span class="smallcaps pcalibre pcalibre1">gcc </span>must put more effort into writing programs in a way that simplifies the compiler's task of generating efficient code.</p>
</section></body></html>
