<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>To Everyone</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part1.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part3.htm">下一个 &gt;</a></p><h4 style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">To Everyone</h4><p class="s5" style="padding-top: 6pt;padding-left: 41pt;text-indent: 11pt;text-align: justify;">Welcome to this book! We hope you’ll enjoy reading it as much as we enjoyed writing it. The book is called <b>Operating Systems: Three Easy Pieces</b>, and the title is obviously an homage to one of the greatest sets of lecture notes ever created, by one Richard Feynman on the topic of Physics [F96]. While this book will undoubt- edly fall short of the high standard set by that famous physicist, perhaps it will be good enough for you in your quest to understand what operating systems (and more generally, systems) are all about.</p><p class="s5" style="padding-left: 41pt;text-indent: 11pt;text-align: justify;">The three easy pieces refer to the three major thematic elements the book is organized around: <b>virtualization</b>, <b>concurrency</b>, and <b>persistence</b>. In discussing these concepts, we’ll end up discussing most of the important things an operating system does; hopefully, you’ll also have some fun along the way. Learning new things is fun, right? At least, it should be.</p><p class="s5" style="padding-left: 41pt;text-indent: 11pt;text-align: justify;">Each major concept is divided into a set of chapters, most of which present a particular problem and then show how to solve it. The chapters are short, and try (as best as possible) to reference the source material where the ideas really came from. One of our goals in writing this book is to make the paths of history as clear as possible, as we think that helps a student understand what is, what was, and what will be more clearly. In this case, seeing how the sausage was made is nearly as important as understanding what the sausage is good for<span class="s10">1</span>.</p><p class="s5" style="padding-left: 41pt;text-indent: 11pt;text-align: justify;">There are a couple devices we use throughout the book which are probably worth introducing here. The first is the <b>crux </b>of the problem. Anytime we are trying to solve a problem, we first try to state what the most important issue is; such a <b>crux of the problem </b>is explicitly called out in the text, and hopefully solved via the techniques, algorithms, and ideas presented in the rest of the text.</p><p class="s5" style="padding-left: 41pt;text-indent: 11pt;text-align: justify;">There are also numerous <b>asides </b>and <b>tips </b>throughout the text, adding a little color to the mainline presentation. Asides tend to discuss something relevant (but perhaps not essential) to the main text; tips tend to be general lessons that can be applied to systems you build. An index at the end of the book lists all of these tips and asides (as well as cruces, the odd plural of crux) for your convenience.</p><p class="s5" style="padding-left: 41pt;text-indent: 11pt;text-align: justify;">We use one of the oldest didactic methods, the <b>dialogue</b>, throughout the book, as a way of presenting some of the material in a different light. These are used to introduce the major thematic concepts (in a peachy way, as we will see), as well as to review material every now and then. They are also a chance to write in a more</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_003.png"/></span></p><p class="s11" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1<span class="s12">Hint: eating! Or if you’re a vegetarian, running away from.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">iii</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;text-align: justify;">humorous style. Whether you find them useful, or humorous, well, that’s another matter entirely.</p><p class="s5" style="padding-left: 68pt;text-indent: 12pt;text-align: justify;">At the beginning of each major section, we’ll first present an <b>abstraction </b>that an operating system provides, and then work in subsequent chapters on the mecha- nisms, policies, and other support needed to provide the abstraction. Abstractions are fundamental to all aspects of Computer Science, so it is perhaps no surprise that they are also essential in operating systems.</p><p class="s5" style="padding-left: 68pt;text-indent: 12pt;text-align: justify;">Throughout the chapters, we try to use <b>real code </b>(not <b>pseudocode</b>) where pos- sible, so for virtually all examples, you should be able to type them up yourself and run them. Running real code on real systems is the best way to learn about operating systems, so we encourage you to do so when you can.</p><p class="s5" style="padding-left: 68pt;text-indent: 11pt;text-align: justify;">In various parts of the text, we have sprinkled in a few <b>homeworks </b>to ensure that you are understanding what is going on. Many of these homeworks are little <b>simulations </b>of pieces of the operating system; you should download the home- works, and run them to quiz yourself. The homework simulators have the follow- ing feature: by giving them a different random seed, you can generate a virtually infinite set of problems; the simulators can also be told to solve the problems for you. Thus, you can test and re-test yourself until you have achieved a good level of understanding.</p><p class="s5" style="padding-left: 68pt;text-indent: 12pt;text-align: justify;">The most important addendum to this book is a set of <b>projects </b>in which you learn about how real systems work by designing, implementing, and testing your own code. All projects (as well as the code examples, mentioned above) are in the <b>C programming language </b>[KR88]; C is a simple and powerful language that underlies most operating systems, and thus worth adding to your tool-chest of languages. Two types of projects are available (see the online appendix for ideas). The first are <b>systems programming </b>projects; these projects are great for those who are new to C and U<span class="s13">NIX </span>and want to learn how to do low-level C programming. The second type are based on a real operating system kernel developed at MIT called xv6 [CK+08]; these projects are great for students that already have some C and want to get their hands dirty inside the OS. At Wisconsin, we’ve run the course in three different ways: either all systems programming, all xv6 programming, or a mix of both.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part1.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part3.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
