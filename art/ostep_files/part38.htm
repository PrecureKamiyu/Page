<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>4.3 Process Creation: A Little More Detail</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part37.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part39.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 7pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">4.3 Process Creation: A Little More Detail</p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One mystery that we should unmask a bit is how programs are trans- formed into processes. Specifically, how does the OS get a program up and running? How does process creation actually work?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The first thing that the OS must do to run a program is to <b>load </b>its code and any static data (e.g., initialized variables) into memory, into the ad- dress space of the process. Programs initially reside on <b>disk </b>(or, in some modern systems, <b>flash-based SSDs</b>) in some kind of <b>executable format</b>; thus, the process of loading a program and static data into memory re- quires the OS to read those bytes from disk and place them in memory somewhere (as shown in Figure <span style=" color: #00AEEF;">4.1</span>).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In early (or simple) operating systems, the loading process is done <b>ea- gerly</b>, i.e., all at once before running the program; modern OSes perform the process <b>lazily</b>, i.e., by loading pieces of code or data only as they are needed during program execution. To truly understand how lazy loading of pieces of code and data works, you’ll have to understand more about the machinery of <b>paging </b>and <b>swapping</b>, topics we’ll cover in the future when we discuss the virtualization of memory. For now, just remember that before running anything, the OS clearly must do some work to get the important program bits from disk into memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Once the code and static data are loaded into memory, there are a few other things the OS needs to do before running the process. Some mem- ory must be allocated for the program’s <b>run-time stack </b>(or just <b>stack</b>). As you should likely already know, C programs use the stack for local variables, function parameters, and return addresses; the OS allocates this memory and gives it to the process. The OS will also likely initial- ize the stack with arguments; specifically, it will fill in the parameters to the <span class="s41">main() </span>function, i.e., <span class="s41">argc </span>and the <span class="s41">argv </span>array.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">The OS may also create some initial memory for the program’s <b>heap</b>. In C programs, the heap is used for explicitly requested dynamically- allocated data; programs request such space by calling <span class="s41">malloc() </span>and free it explicitly by calling <span class="s41">free()</span>. The heap is needed for data struc- tures such as linked lists, hash tables, trees, and other interesting data structures. The heap will be small at first; as the program runs, and re- quests more memory via the <span class="s41">malloc() </span>library API, the OS may get in- volved and allocate more memory to the process to help satisfy such calls. The OS will also do some other initialization tasks, particularly as re- lated to input/output (I/O). For example, in U<span class="s7">NIX </span>systems, each process by default has three open <b>file descriptors</b>, for standard input, output, and error; these descriptors let programs easily read input from the terminal as well as print output to the screen. We’ll learn more about I/O, file</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">descriptors, and the like in the third part of the book on <b>persistence</b>.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">By loading the code and static data into memory, by creating and ini- tializing a stack, and by doing other work as related to I/O setup, the OS has now (finally) set the stage for program execution. It thus has one last task: to start the program running at the entry point, namely <span class="s41">main()</span>. By jumping to the <span class="s41">main() </span>routine (through a specialized mechanism that we will discuss next chapter), the OS transfers control of the CPU to the newly-created process, and thus the program begins its execution.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part37.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part39.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
