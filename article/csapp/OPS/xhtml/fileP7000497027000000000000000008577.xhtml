<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>12.7 Other Concurrency Issues</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000008577" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000047026" data-uri="chapter12.xhtml#P7000497027000000000000000047026" epub:type="title"><span class="pcalibre label pcalibre1">12.7 </span>Other Concurrency Issues</h1></header>
<p id="P7000497027000000000000000047027" data-uri="chapter12.xhtml#P7000497027000000000000000047027" class="pcalibre1 pcalibre calibre2">You probably noticed that life got much more complicated once we were asked to synchronize accesses to shared data. So far, we have looked at techniques for mutual exclusion and producer-consumer synchronization, but this is only the tip of the iceberg. Synchronization is a fundamentally difficult problem that raises issues that simply do not arise in ordinary sequential programs. This section is a survey (by no means complete) of some of the issues you need to be aware of when you write concurrent programs. To keep things concrete, we will couch our discussion in terms of threads. Keep in mind, however, that these are typical of the issues that arise when concurrent flows of any kind manipulate shared resources.</p>
<section id="P700049702700000000000000000857A" data-uri="chapter12.xhtml#P700049702700000000000000000857A" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000047028" data-uri="chapter12.xhtml#P7000497027000000000000000047028" epub:type="title"><span class="pcalibre label pcalibre1">12.7.1 </span>Thread Safety</h1></header>
<p id="P7000497027000000000000000047029" data-uri="chapter12.xhtml#P7000497027000000000000000047029" class="pcalibre1 pcalibre calibre2">When we program with threads, we must be careful to write functions that have a property called thread safety. A function is said to be <i class="calibre5 pcalibre pcalibre1">thread-safe</i> if and only if it will always produce correct results when called repeatedly from multiple concurrent threads. If a function is not thread-safe, then we say it is <i class="calibre5 pcalibre pcalibre1">thread-unsafe</i>.</p>
<p id="P700049702700000000000000004702A" data-uri="chapter12.xhtml#P700049702700000000000000004702A" class="pcalibre1 pcalibre calibre2">We can identify four (nondisjoint) classes of thread-unsafe functions:</p>
<ul class="pcalibre ul_none pcalibre1" id="P700049702700000000000000004702B" data-uri="chapter12.xhtml#P700049702700000000000000004702B">
<li id="P700049702700000000000000004702C" data-uri="chapter12.xhtml#P700049702700000000000000004702C" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004702D" data-uri="chapter12.xhtml#P700049702700000000000000004702D" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Class 1: </span><i class="calibre5 pcalibre pcalibre1">Functions that do not protect shared variables.</i> We have already encountered this problem with the thread function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008286"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.16</span></a>, which</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008581" data-uri="chapter12.xhtml#P7000497027000000000000000008581">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008582" title="1021" data-uri="chapter12.xhtml#P7000497027000000000000000008582" epub:type="pagebreak"></span>
<p id="P700049702700000000000000004702E" data-uri="chapter12.xhtml#P700049702700000000000000004702E" class="calibre13 pcalibre pcalibre1">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/rand.c</i></p>
<pre id="P700049702700000000000000004702F" data-uri="chapter12.xhtml#P700049702700000000000000004702F" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000047030" data-uri="chapter12.xhtml#P7000497027000000000000000047030" class="calibre10 pcalibre pcalibre1">
1	unsigned next_seed = 1;
2
3	/* rand - return pseudorandom integer in the range 0..32767 */
4	unsigned rand(void)
5	{
6		next_seed = next_seed*1103515245 + 12543;
7		return (unsigned)(next_seed&gt;&gt;16) % 32768;
8	}
9
10	/* srand - set the initial seed for rand() */
11	void srand(unsigned new_seed)
12	{
13		next_seed = new_seed;
14	}
</code></pre>
<p id="P7000497027000000000000000047031" data-uri="chapter12.xhtml#P7000497027000000000000000047031" class="calibre13 pcalibre pcalibre1">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/rand.c</i></p>
<figcaption id="P7000497027000000000000000047032" data-uri="chapter12.xhtml#P7000497027000000000000000047032" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000047033" data-uri="chapter12.xhtml#P7000497027000000000000000047033" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.37 </span>A thread-unsafe pseudorandom number generator.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000047034" data-uri="chapter12.xhtml#P7000497027000000000000000047034"><p id="P7000497027000000000000000047035" data-uri="chapter12.xhtml#P7000497027000000000000000047035" class="pcalibre calibre3 pcalibre1">(Based on [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41C">61</a>])</p></div></figcaption>
</figure>
<p class="calibre13 pcalibre pcalibre1" id="P7000497027000000000000000047036" data-uri="chapter12.xhtml#P7000497027000000000000000047036">increments an unprotected global counter variable. This class of thread-unsafe functions is relatively easy to make thread-safe: protect the shared variables with synchronization operations such as <var class="calibre5 pcalibre pcalibre1">P</var> and <var class="calibre5 pcalibre pcalibre1">V</var>. An advantage is that it does not require any changes in the calling program. A disadvantage is that the synchronization operations slow down the function.</p></li>
<li id="P7000497027000000000000000047037" data-uri="chapter12.xhtml#P7000497027000000000000000047037" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000047038" data-uri="chapter12.xhtml#P7000497027000000000000000047038" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Class 2: </span><i class="calibre5 pcalibre pcalibre1">Functions that keep state across multiple invocations.</i> A pseudorandom number generator is a simple example of this class of thread-unsafe functions. Consider the pseudorandom number generator package in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008581"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.37</span></a>.</p>
<p id="P7000497027000000000000000047039" data-uri="chapter12.xhtml#P7000497027000000000000000047039" class="calibre15 pcalibre pcalibre1">The <code id="P700049702700000000000000004703A" data-uri="chapter12.xhtml#P700049702700000000000000004703A" class="pcalibre1 calibre8 pcalibre">rand</code> function is thread-unsafe because the result of the current invocation depends on an intermediate result from the previous iteration. When we call <code id="P700049702700000000000000004703B" data-uri="chapter12.xhtml#P700049702700000000000000004703B" class="pcalibre1 calibre8 pcalibre">rand</code> repeatedly from a single thread after seeding it with a call to <code id="P700049702700000000000000004703C" data-uri="chapter12.xhtml#P700049702700000000000000004703C" class="pcalibre1 calibre8 pcalibre">srand</code>, we can expect a repeatable sequence of numbers. However, this assumption no longer holds if multiple threads are calling <code id="P700049702700000000000000004703D" data-uri="chapter12.xhtml#P700049702700000000000000004703D" class="pcalibre1 calibre8 pcalibre">rand</code>.</p>
<p id="P700049702700000000000000004703E" data-uri="chapter12.xhtml#P700049702700000000000000004703E" class="calibre15 pcalibre pcalibre1">The only way to make a function such as <code id="P700049702700000000000000004703F" data-uri="chapter12.xhtml#P700049702700000000000000004703F" class="pcalibre1 calibre8 pcalibre">rand</code> thread-safe is to rewrite it so that it does not use any <code id="P7000497027000000000000000047040" data-uri="chapter12.xhtml#P7000497027000000000000000047040" class="pcalibre1 calibre8 pcalibre">static</code> data, relying instead on the caller to pass the state information in arguments. The disadvantage is that the programmer is now forced to change the code in the calling routine as well. In a large program where there are potentially hundreds of different call sites, making such modifications could be nontrivial and prone to error.</p></li>
<li id="P7000497027000000000000000047041" data-uri="chapter12.xhtml#P7000497027000000000000000047041" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000047042" data-uri="chapter12.xhtml#P7000497027000000000000000047042" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Class 3: </span><i class="calibre5 pcalibre pcalibre1">Functions that return a pointer to a static variable.</i> Some functions, such as <code id="P7000497027000000000000000047043" data-uri="chapter12.xhtml#P7000497027000000000000000047043" class="pcalibre1 calibre8 pcalibre">ctime</code> and <code id="P7000497027000000000000000047044" data-uri="chapter12.xhtml#P7000497027000000000000000047044" class="pcalibre1 calibre8 pcalibre">gethostbyname</code>, compute a result in a <code id="P7000497027000000000000000047045" data-uri="chapter12.xhtml#P7000497027000000000000000047045" class="pcalibre1 calibre8 pcalibre">static</code> variable and then return a pointer to that variable. If we call such functions from</p>
<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000859B" data-uri="chapter12.xhtml#P700049702700000000000000000859B">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000859C" title="1022" data-uri="chapter12.xhtml#P700049702700000000000000000859C" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000047046" data-uri="chapter12.xhtml#P7000497027000000000000000047046" class="calibre13 pcalibre pcalibre1">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/ctime-ts.c</i></p>
<pre id="P7000497027000000000000000047047" data-uri="chapter12.xhtml#P7000497027000000000000000047047" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000047048" data-uri="chapter12.xhtml#P7000497027000000000000000047048" class="calibre10 pcalibre pcalibre1">
1	char *ctime_ts(const time_t *timep, char *privatep)
2	{
3		char *sharedp;
4
5		P(&amp;mutex);
6		sharedp = ctime(timep);
7		strcpy(privatep, sharedp); /* Copy string from shared to private */
8		V(&amp;mutex);
9		return privatep;
10	}
</code></pre>
<p id="P7000497027000000000000000047049" data-uri="chapter12.xhtml#P7000497027000000000000000047049" class="calibre13 pcalibre pcalibre1">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/ctime-ts.c</i></p>
<figcaption id="P700049702700000000000000004704A" data-uri="chapter12.xhtml#P700049702700000000000000004704A" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004704B" data-uri="chapter12.xhtml#P700049702700000000000000004704B" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">12.38 </span>Thread-safe wrapper function for the C standard library <code id="P700049702700000000000000004704C" data-uri="chapter12.xhtml#P700049702700000000000000004704C" class="pcalibre1 calibre8 pcalibre">ctime</code> function.</h1></header>
<div class="caption pcalibre pcalibre1" id="P700049702700000000000000004704D" data-uri="chapter12.xhtml#P700049702700000000000000004704D"><p id="P700049702700000000000000004704E" data-uri="chapter12.xhtml#P700049702700000000000000004704E" class="pcalibre calibre3 pcalibre1">This example uses the lock-and-copy technique to call a class 3 thread-unsafe function.</p></div></figcaption>
</figure>
<p class="calibre13 pcalibre pcalibre1" id="P700049702700000000000000004704F" data-uri="chapter12.xhtml#P700049702700000000000000004704F">concurrent threads, then disaster is likely, as results being used by one thread are silently overwritten by another thread.</p>
<p id="P7000497027000000000000000047050" data-uri="chapter12.xhtml#P7000497027000000000000000047050" class="calibre15 pcalibre pcalibre1">There are two ways to deal with this class of thread-unsafe functions. One option is to rewrite the function so that the caller passes the address of the variable in which to store the results. This eliminates all shared data, but it requires the programmer to have access to the function source code.</p>
<p id="P7000497027000000000000000047051" data-uri="chapter12.xhtml#P7000497027000000000000000047051" class="calibre15 pcalibre pcalibre1">If the thread-unsafe function is difficult or impossible to modify (e.g., the code is very complex or there is no source code available), then another option is to use the <i class="calibre5 pcalibre pcalibre1">lock-and-copy</i> technique. The basic idea is to associate a mutex with the thread-unsafe function. At each call site, lock the mutex, call the thread-unsafe function, copy the result returned by the function to a private memory location, and then unlock the mutex. To minimize changes to the caller, you should define a thread-safe wrapper function that performs the lock-and-copy and then replace all calls to the thread-unsafe function with calls to the wrapper. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000859B"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.38</span></a> shows a thread-safe wrapper for <code id="P7000497027000000000000000047052" data-uri="chapter12.xhtml#P7000497027000000000000000047052" class="pcalibre1 calibre8 pcalibre">ctime</code> that uses the lock-and-copy technique.</p></li>
<li id="P7000497027000000000000000047053" data-uri="chapter12.xhtml#P7000497027000000000000000047053" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000047054" data-uri="chapter12.xhtml#P7000497027000000000000000047054" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Class 4: </span><i class="calibre5 pcalibre pcalibre1">Functions that call thread-unsafe functions.</i> If a function <var class="calibre5 pcalibre pcalibre1">f</var> calls a thread-unsafe function <var class="calibre5 pcalibre pcalibre1">g</var>, is <var class="calibre5 pcalibre pcalibre1">f</var> thread-unsafe? It depends. If <var class="calibre5 pcalibre pcalibre1">g</var> is a class 2 function that relies on state across multiple invocations, then <var class="calibre5 pcalibre pcalibre1">f</var> is also thread-unsafe and there is no recourse short of rewriting <var class="calibre5 pcalibre pcalibre1">g</var>. However, if <var class="calibre5 pcalibre pcalibre1">g</var> is a class 1 or class 3 function, then <var class="calibre5 pcalibre pcalibre1">f</var> can still be thread-safe if you protect the call site and any resulting shared data with a mutex. We see a good example of this in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000859B"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.38</span></a>, where we use lock-and-copy to write a thread-safe function that calls a thread-unsafe function.</p></li>
</ul>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000085AC" data-uri="chapter12.xhtml#P70004970270000000000000000085AC">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000085AD" title="1023" data-uri="chapter12.xhtml#P70004970270000000000000000085AD" epub:type="pagebreak"></span>
<img alt="A diagram shows all functions divided among thread-safe functions and thread-unsafe functions. Reentrant functions are within thread-safe functions." id="P7000497027000000000000000047055" data-uri="P700049702700000000000000000B69B" src="../images/p1023-1.png" class="pcalibre1 calibre345 pcalibre"/>
<figcaption id="P7000497027000000000000000047056" data-uri="chapter12.xhtml#P7000497027000000000000000047056" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000047057" data-uri="chapter12.xhtml#P7000497027000000000000000047057" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.39 </span>Relationships between the sets of reentrant, thread-safe, and thread-unsafe functions.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000085B1" data-uri="chapter12.xhtml#P70004970270000000000000000085B1">
<p id="P7000497027000000000000000047058" data-uri="chapter12.xhtml#P7000497027000000000000000047058" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/rand-r.c</i></p>
<pre id="P7000497027000000000000000047059" data-uri="chapter12.xhtml#P7000497027000000000000000047059" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004705A" data-uri="chapter12.xhtml#P700049702700000000000000004705A" class="calibre10 pcalibre pcalibre1">
1	/* rand_r - return a pseudorandom integer on 0..32767 */
2	int rand_r(unsigned int *nextp)
3	{
4		*nextp = *nextp * 1103515245 + 12345;
5		return (unsigned int)(*nextp / 65536) % 32768;
6	}
</code></pre>
<p id="P700049702700000000000000004705B" data-uri="chapter12.xhtml#P700049702700000000000000004705B" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/rand-r.c</i></p>
<figcaption id="P700049702700000000000000004705C" data-uri="chapter12.xhtml#P700049702700000000000000004705C" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004705D" data-uri="chapter12.xhtml#P700049702700000000000000004705D" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">12.40 </span><code id="P700049702700000000000000004705E" data-uri="chapter12.xhtml#P700049702700000000000000004705E" class="pcalibre1 calibre8 pcalibre">rand_r</code>: A reentrant version of the <code id="P700049702700000000000000004705F" data-uri="chapter12.xhtml#P700049702700000000000000004705F" class="pcalibre1 calibre8 pcalibre">rand</code> function from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008581"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.37</span></a>.</h1></header>
</figcaption>
</figure>
</section>
<section id="P70004970270000000000000000085BA" data-uri="chapter12.xhtml#P70004970270000000000000000085BA" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000047060" data-uri="chapter12.xhtml#P7000497027000000000000000047060" epub:type="title"><span class="pcalibre label pcalibre1">12.7.2 </span>Reentrancy</h1></header>
<p id="P7000497027000000000000000047061" data-uri="chapter12.xhtml#P7000497027000000000000000047061" class="pcalibre1 pcalibre calibre2">There is an important class of thread-safe functions, known as <i class="calibre5 pcalibre pcalibre1">reentrant functions</i>, that are characterized by the property that they do not reference <i class="calibre5 pcalibre pcalibre1">any</i> shared data when they are called by multiple threads. Although the terms <i class="calibre5 pcalibre pcalibre1">thread-safe</i> and <i class="calibre5 pcalibre pcalibre1">reentrant</i> are sometimes used (incorrectly) as synonyms, there is a clear technical distinction that is worth preserving. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000085AC"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.39</span></a> shows the set relationships between reentrant, thread-safe, and thread-unsafe functions. The set of all functions is partitioned into the disjoint sets of thread-safe and thread-unsafe functions. The set of reentrant functions is a proper subset of the thread-safe functions.</p>
<p id="P7000497027000000000000000047062" data-uri="chapter12.xhtml#P7000497027000000000000000047062" class="pcalibre1 pcalibre calibre2">Reentrant functions are typically more efficient than non-reentrant thread-safe functions because they require no synchronization operations. Furthermore, the only way to convert a class 2 thread-unsafe function into a thread-safe one is to rewrite it so that it is reentrant. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000085B1"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.40</span></a> shows a reentrant version of the <code id="P7000497027000000000000000047063" data-uri="chapter12.xhtml#P7000497027000000000000000047063" class="pcalibre1 calibre8 pcalibre">rand</code> function from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008581"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.37</span></a>. The key idea is that we have replaced the static <code id="P7000497027000000000000000047064" data-uri="chapter12.xhtml#P7000497027000000000000000047064" class="pcalibre1 calibre8 pcalibre">next</code> variable with a pointer that is passed in by the caller.</p>
<p id="P7000497027000000000000000047065" data-uri="chapter12.xhtml#P7000497027000000000000000047065" class="pcalibre1 pcalibre calibre2">Is it possible to inspect the code of some function and declare a priori that it is reentrant? Unfortunately, it depends. If all function arguments are passed by value (i.e., no pointers) and all data references are to local automatic stack variables (i.e., no references to static or global variables), then the function is <i class="calibre5 pcalibre pcalibre1">explicitly reentrant</i>, in the sense that we can assert its reentrancy regardless of how it is called.</p>
<p id="P7000497027000000000000000047066" data-uri="chapter12.xhtml#P7000497027000000000000000047066" class="pcalibre1 pcalibre calibre2">However, if we loosen our assumptions a bit and allow some parameters in our otherwise explicitly reentrant function to be passed by reference (i.e., we allow them to pass pointers), then we have an <i class="calibre5 pcalibre pcalibre1">implicitly reentrant</i> function, in the sense that it is only reentrant if the calling threads are careful to pass pointers <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000085C2" title="1024" data-uri="chapter12.xhtml#P70004970270000000000000000085C2" epub:type="pagebreak"></span>to nonshared data. For example, the <code id="P7000497027000000000000000047067" data-uri="chapter12.xhtml#P7000497027000000000000000047067" class="pcalibre1 calibre8 pcalibre">rand_r</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000085B1"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.40</span></a> is implicitly reentrant.</p>
<p id="P7000497027000000000000000047068" data-uri="chapter12.xhtml#P7000497027000000000000000047068" class="pcalibre1 pcalibre calibre2">We always use the term <i class="calibre5 pcalibre pcalibre1">reentrant</i> to include both explicit and implicit reentrant functions. However, it is important to realize that reentrancy is sometimes a property of both the caller and the callee, and not just the callee alone.</p>
<section id="P70004970270000000000000000085C5" data-uri="chapter12.xhtml#P70004970270000000000000000085C5" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000047069" data-uri="chapter12.xhtml#P7000497027000000000000000047069" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.12 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008803">1038</a>)</h1></header> 
<ol class="practicelist pcalibre pcalibre1" id="P700049702700000000000000004706A" data-uri="chapter12.xhtml#P700049702700000000000000004706A">
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004706B" data-uri="chapter12.xhtml#P700049702700000000000000004706B">
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000004706C" data-uri="chapter12.xhtml#P700049702700000000000000004706C"><p id="P700049702700000000000000004706D" data-uri="chapter12.xhtml#P700049702700000000000000004706D" class="pcalibre calibre3 pcalibre1">The <code id="P700049702700000000000000004706E" data-uri="chapter12.xhtml#P700049702700000000000000004706E" class="pcalibre1 calibre8 pcalibre">ctime_ts</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000859B"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.38</span></a> is thread-safe but not reentrant. Explain.</p></div></li>
</ol>
</section>
</section>
<section id="P70004970270000000000000000085CC" data-uri="chapter12.xhtml#P70004970270000000000000000085CC" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004706F" data-uri="chapter12.xhtml#P700049702700000000000000004706F" epub:type="title"><span class="pcalibre label pcalibre1">12.7.3 </span>Using Existing Library Functions in Threaded Programs</h1></header>
<p id="P7000497027000000000000000047070" data-uri="chapter12.xhtml#P7000497027000000000000000047070" class="pcalibre1 pcalibre calibre2">Most Linux functions, including the functions defined in the standard C library (such as <code id="P7000497027000000000000000047071" data-uri="chapter12.xhtml#P7000497027000000000000000047071" class="pcalibre1 calibre8 pcalibre">malloc, free, realloc, printf</code>, and <code id="P7000497027000000000000000047072" data-uri="chapter12.xhtml#P7000497027000000000000000047072" class="pcalibre1 calibre8 pcalibre">scanf</code>), are thread-safe, with only a few exceptions. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000085DB"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.41</span></a> lists some common exceptions. (See [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>] for a complete list.) The <code id="P7000497027000000000000000047073" data-uri="chapter12.xhtml#P7000497027000000000000000047073" class="pcalibre1 calibre8 pcalibre">strtok</code> function is a deprecated function (one whose use is discouraged) for parsing strings. The <code id="P7000497027000000000000000047074" data-uri="chapter12.xhtml#P7000497027000000000000000047074" class="pcalibre1 calibre8 pcalibre">asctime, ctime</code>, and <code id="P7000497027000000000000000047075" data-uri="chapter12.xhtml#P7000497027000000000000000047075" class="pcalibre1 calibre8 pcalibre">localtime</code> functions are popular functions for converting back and forth between different time and date formats. The <code id="P7000497027000000000000000047076" data-uri="chapter12.xhtml#P7000497027000000000000000047076" class="pcalibre1 calibre8 pcalibre">gethostbyaddr, gethostbyname</code>, and <code id="P7000497027000000000000000047077" data-uri="chapter12.xhtml#P7000497027000000000000000047077" class="pcalibre1 calibre8 pcalibre">inet_ntoa</code> functions are obsolete network programming functions that have been replaced by the reentrant getaddrinfo, <code id="P7000497027000000000000000047078" data-uri="chapter12.xhtml#P7000497027000000000000000047078" class="pcalibre1 calibre8 pcalibre">getnameinfo</code>, and <code id="P7000497027000000000000000047079" data-uri="chapter12.xhtml#P7000497027000000000000000047079" class="pcalibre1 calibre8 pcalibre">inet_ntop</code> functions, respectively (see <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">11</span></a>). With the exceptions of <code id="P700049702700000000000000004707A" data-uri="chapter12.xhtml#P700049702700000000000000004707A" class="pcalibre1 calibre8 pcalibre">rand</code> and <code id="P700049702700000000000000004707B" data-uri="chapter12.xhtml#P700049702700000000000000004707B" class="pcalibre1 calibre8 pcalibre">strtok</code>, they are of the class 3 variety that return a pointer to a static variable. If we need to call one of these functions in a threaded program, the least disruptive approach to the caller is to lock and copy. However, the lock-and-copy approach has a number of disadvantages. First, the additional synchronization slows down the program. Second, functions that return pointers to complex structures of structures require a <i class="calibre5 pcalibre pcalibre1">deep copy</i> of the structures in order to copy the entire structure hierarchy. Third, the lock-and-copy approach will not work for a class 2 thread-unsafe function such as <code id="P700049702700000000000000004707C" data-uri="chapter12.xhtml#P700049702700000000000000004707C" class="pcalibre1 calibre8 pcalibre">rand</code> that relies on static state across calls.</p>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000085DB" data-uri="chapter12.xhtml#P70004970270000000000000000085DB">
<table id="P700049702700000000000000004707D" data-uri="chapter12.xhtml#P700049702700000000000000004707D" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P700049702700000000000000004707E" data-uri="chapter12.xhtml#P700049702700000000000000004707E" class="calibre18 pcalibre pcalibre1">Thread-unsafe function</th>
<th id="P700049702700000000000000004707F" data-uri="chapter12.xhtml#P700049702700000000000000004707F" class="calibre18 pcalibre pcalibre1">Thread-unsafe class</th>
<th id="P7000497027000000000000000047080" data-uri="chapter12.xhtml#P7000497027000000000000000047080" class="calibre18 pcalibre pcalibre1">Linux thread-safe version</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000047081" data-uri="chapter12.xhtml#P7000497027000000000000000047081" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000047082" data-uri="chapter12.xhtml#P7000497027000000000000000047082" class="calibre10 pcalibre pcalibre1">rand</code></td>
<td id="P7000497027000000000000000047083" data-uri="chapter12.xhtml#P7000497027000000000000000047083" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P7000497027000000000000000047084" data-uri="chapter12.xhtml#P7000497027000000000000000047084" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000047085" data-uri="chapter12.xhtml#P7000497027000000000000000047085" class="calibre10 pcalibre pcalibre1">rand_r</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000047086" data-uri="chapter12.xhtml#P7000497027000000000000000047086" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000047087" data-uri="chapter12.xhtml#P7000497027000000000000000047087" class="calibre10 pcalibre pcalibre1">strtok</code></td>
<td id="P7000497027000000000000000047088" data-uri="chapter12.xhtml#P7000497027000000000000000047088" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P7000497027000000000000000047089" data-uri="chapter12.xhtml#P7000497027000000000000000047089" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004708A" data-uri="chapter12.xhtml#P700049702700000000000000004708A" class="calibre10 pcalibre pcalibre1">strtok_r</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004708B" data-uri="chapter12.xhtml#P700049702700000000000000004708B" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004708C" data-uri="chapter12.xhtml#P700049702700000000000000004708C" class="calibre10 pcalibre pcalibre1">asctime</code></td>
<td id="P700049702700000000000000004708D" data-uri="chapter12.xhtml#P700049702700000000000000004708D" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P700049702700000000000000004708E" data-uri="chapter12.xhtml#P700049702700000000000000004708E" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004708F" data-uri="chapter12.xhtml#P700049702700000000000000004708F" class="calibre10 pcalibre pcalibre1">asctime_r</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000047090" data-uri="chapter12.xhtml#P7000497027000000000000000047090" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000047091" data-uri="chapter12.xhtml#P7000497027000000000000000047091" class="calibre10 pcalibre pcalibre1">ctime</code></td>
<td id="P7000497027000000000000000047092" data-uri="chapter12.xhtml#P7000497027000000000000000047092" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P7000497027000000000000000047093" data-uri="chapter12.xhtml#P7000497027000000000000000047093" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000047094" data-uri="chapter12.xhtml#P7000497027000000000000000047094" class="calibre10 pcalibre pcalibre1">ctime_r</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000047095" data-uri="chapter12.xhtml#P7000497027000000000000000047095" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000047096" data-uri="chapter12.xhtml#P7000497027000000000000000047096" class="calibre10 pcalibre pcalibre1">gethostbyaddr</code></td>
<td id="P7000497027000000000000000047097" data-uri="chapter12.xhtml#P7000497027000000000000000047097" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P7000497027000000000000000047098" data-uri="chapter12.xhtml#P7000497027000000000000000047098" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000047099" data-uri="chapter12.xhtml#P7000497027000000000000000047099" class="calibre10 pcalibre pcalibre1">gethostbyaddr_r</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004709A" data-uri="chapter12.xhtml#P700049702700000000000000004709A" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004709B" data-uri="chapter12.xhtml#P700049702700000000000000004709B" class="calibre10 pcalibre pcalibre1">gethostbyname</code></td>
<td id="P700049702700000000000000004709C" data-uri="chapter12.xhtml#P700049702700000000000000004709C" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P700049702700000000000000004709D" data-uri="chapter12.xhtml#P700049702700000000000000004709D" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004709E" data-uri="chapter12.xhtml#P700049702700000000000000004709E" class="calibre10 pcalibre pcalibre1">gethostbyname_r</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004709F" data-uri="chapter12.xhtml#P700049702700000000000000004709F" class="calibre20 pcalibre pcalibre1"><code id="P70004970270000000000000000470A0" data-uri="chapter12.xhtml#P70004970270000000000000000470A0" class="calibre10 pcalibre pcalibre1">inet_ntoa</code></td>
<td id="P70004970270000000000000000470A1" data-uri="chapter12.xhtml#P70004970270000000000000000470A1" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P70004970270000000000000000470A2" data-uri="chapter12.xhtml#P70004970270000000000000000470A2" class="calibre20 pcalibre pcalibre1">(none)</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P70004970270000000000000000470A3" data-uri="chapter12.xhtml#P70004970270000000000000000470A3" class="calibre20 pcalibre pcalibre1"><code id="P70004970270000000000000000470A4" data-uri="chapter12.xhtml#P70004970270000000000000000470A4" class="calibre10 pcalibre pcalibre1">localtime</code></td>
<td id="P70004970270000000000000000470A5" data-uri="chapter12.xhtml#P70004970270000000000000000470A5" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P70004970270000000000000000470A6" data-uri="chapter12.xhtml#P70004970270000000000000000470A6" class="calibre20 pcalibre pcalibre1"><code id="P70004970270000000000000000470A7" data-uri="chapter12.xhtml#P70004970270000000000000000470A7" class="calibre10 pcalibre pcalibre1">localtime_r</code></td>
</tr>
</tbody>
</table>
<figcaption id="P70004970270000000000000000470A8" data-uri="chapter12.xhtml#P70004970270000000000000000470A8" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000470A9" data-uri="chapter12.xhtml#P70004970270000000000000000470A9" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.41 </span>Common thread-unsafe library functions.</h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000470AA" data-uri="chapter12.xhtml#P70004970270000000000000000470AA"><p id="P70004970270000000000000000470AB" data-uri="chapter12.xhtml#P70004970270000000000000000470AB" class="pcalibre calibre3 pcalibre1"></p></div></figcaption>
</figure>
<p id="P70004970270000000000000000470AC" data-uri="chapter12.xhtml#P70004970270000000000000000470AC" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000860C" title="1025" data-uri="chapter12.xhtml#P700049702700000000000000000860C" epub:type="pagebreak"></span>Therefore, Linux systems provide reentrant versions of most thread-unsafe functions. The names of the reentrant versions always end with the <code id="P70004970270000000000000000470AD" data-uri="chapter12.xhtml#P70004970270000000000000000470AD" class="pcalibre1 calibre8 pcalibre">_r</code> suffix. For example, the reentrant version of <code id="P70004970270000000000000000470AE" data-uri="chapter12.xhtml#P70004970270000000000000000470AE" class="pcalibre1 calibre8 pcalibre">asctime</code> is called <code id="P70004970270000000000000000470AF" data-uri="chapter12.xhtml#P70004970270000000000000000470AF" class="pcalibre1 calibre8 pcalibre">asctime_r</code>. We recommend using these functions whenever possible.</p>
</section>
<section id="P7000497027000000000000000008610" data-uri="chapter12.xhtml#P7000497027000000000000000008610" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000470B0" data-uri="chapter12.xhtml#P70004970270000000000000000470B0" epub:type="title"><span class="pcalibre label pcalibre1">12.7.4 </span>Races</h1></header>
<p id="P70004970270000000000000000470B1" data-uri="chapter12.xhtml#P70004970270000000000000000470B1" class="pcalibre1 pcalibre calibre2">A <i class="calibre5 pcalibre pcalibre1">race</i> occurs when the correctness of a program depends on one thread reaching point <var class="calibre5 pcalibre pcalibre1">x</var> in its control flow before another thread reaches point <var class="calibre5 pcalibre pcalibre1">y</var>. Races usually occur because programmers assume that threads will take some particular trajectory through the execution state space, forgetting the golden rule that threaded programs must work correctly for any feasible trajectory.</p>
<p id="P70004970270000000000000000470B2" data-uri="chapter12.xhtml#P70004970270000000000000000470B2" class="pcalibre1 pcalibre calibre2">An example is the easiest way to understand the nature of races. Consider the simple program in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008614"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.42</span></a>. The main thread creates four peer threads and passes a pointer to a unique integer ID to each one. Each peer thread copies the</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008614" data-uri="chapter12.xhtml#P7000497027000000000000000008614">
<p id="P70004970270000000000000000470B3" data-uri="chapter12.xhtml#P70004970270000000000000000470B3" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/race.c</i></p>
<pre id="P70004970270000000000000000470B4" data-uri="chapter12.xhtml#P70004970270000000000000000470B4" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000470B5" data-uri="chapter12.xhtml#P70004970270000000000000000470B5" class="calibre10 pcalibre pcalibre1">
1	/* WARNING: This code is buggy! */
2	#include "csapp.h"
3	#define N 4
4
5	void *thread(void *vargp);
6
7	int main()
8	{
9		pthread_t tid[N];
10		int i;
11
12		for (i = 0; i &lt; N; i++)
13			Pthread_create(&amp;tid[i], NULL, thread, &amp;i);
14		for (i = 0; i &lt; N; i++)
15			Pthread_join(tid[i], NULL);
16		exit(0);
17	}
18
19	/* Thread routine */
20	void *thread(void *vargp)
21	{
22		int myid = *((int *)vargp);
23		printf("Hello from thread %d\n", myid);
24		return NULL;
25	}
</code></pre>
<p id="P70004970270000000000000000470B6" data-uri="chapter12.xhtml#P70004970270000000000000000470B6" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/race.c</i></p>
<figcaption id="P70004970270000000000000000470B7" data-uri="chapter12.xhtml#P70004970270000000000000000470B7" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000470B8" data-uri="chapter12.xhtml#P70004970270000000000000000470B8" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.42 </span>program with a race.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000470B9" data-uri="chapter12.xhtml#P70004970270000000000000000470B9"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000861C" title="1026" data-uri="chapter12.xhtml#P700049702700000000000000000861C" epub:type="pagebreak"></span>ID passed in its argument to a local variable (line 22) and then prints a message containing the ID. It looks simple enough, but when we run this program on our system, we get the following incorrect result:</p>
<pre id="P70004970270000000000000000470BA" data-uri="chapter12.xhtml#P70004970270000000000000000470BA" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000470BB" data-uri="chapter12.xhtml#P70004970270000000000000000470BB" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">./race</i>
Hello from thread 1
Hello from thread 3
Hello from thread 2
Hello from thread 3</code></pre>
<p id="P70004970270000000000000000470BC" data-uri="chapter12.xhtml#P70004970270000000000000000470BC" class="pcalibre1 pcalibre calibre2">The problem is caused by a race between each peer thread and the main thread. Can you spot the race? Here is what happens. When the main thread creates a peer thread in line 13, it passes a pointer to the local stack variable <var class="calibre5 pcalibre pcalibre1">i</var>. At this point, the race is on between the next increment of <code id="P70004970270000000000000000470BD" data-uri="chapter12.xhtml#P70004970270000000000000000470BD" class="pcalibre1 calibre8 pcalibre">i</code> in line 12 and the dereferencing and assignment of the argument in line 22. If the peer thread executes line 22 before the main thread increments <code id="P70004970270000000000000000470BE" data-uri="chapter12.xhtml#P70004970270000000000000000470BE" class="pcalibre1 calibre8 pcalibre">i</code> in line 12, then the <code id="P70004970270000000000000000470BF" data-uri="chapter12.xhtml#P70004970270000000000000000470BF" class="pcalibre1 calibre8 pcalibre">myid</code> variable gets the correct ID. Otherwise, it will contain the ID of some other thread. The scary thing is that whether we get the correct answer depends on how the kernel schedules the execution of the threads. On our system it fails, but on other systems it might work correctly, leaving the programmer blissfully unaware of a serious bug.</p>
<p id="P70004970270000000000000000470C0" data-uri="chapter12.xhtml#P70004970270000000000000000470C0" class="pcalibre1 pcalibre calibre2">To eliminate the race, we can dynamically allocate a separate block for each integer ID and pass the thread routine a pointer to this block, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008638"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.43</span></a> (lines 12−14). Notice that the thread routine must free the block in order to avoid a memory leak.</p>
<p id="P70004970270000000000000000470C1" data-uri="chapter12.xhtml#P70004970270000000000000000470C1" class="pcalibre1 pcalibre calibre2">When we run this program on our system, we now get the correct result:</p>
<pre id="P70004970270000000000000000470C2" data-uri="chapter12.xhtml#P70004970270000000000000000470C2" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000470C3" data-uri="chapter12.xhtml#P70004970270000000000000000470C3" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">./norace</i>
Hello from thread 0
Hello from thread 1
Hello from thread 2
Hello from thread 3</code></pre>
<section id="P7000497027000000000000000008627" data-uri="chapter12.xhtml#P7000497027000000000000000008627" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000470C4" data-uri="chapter12.xhtml#P70004970270000000000000000470C4" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.13 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000470C5" data-uri="chapter12.xhtml#P70004970270000000000000000470C5">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000470C6" data-uri="chapter12.xhtml#P70004970270000000000000000470C6">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000470C7" data-uri="chapter12.xhtml#P70004970270000000000000000470C7"><p id="P70004970270000000000000000470C8" data-uri="chapter12.xhtml#P70004970270000000000000000470C8" class="pcalibre calibre3 pcalibre1">In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008638"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.43</span></a>, we might be tempted to free the allocated memory block immediately after line 14 in the main thread, instead of freeing it in the peer thread. But this would be a bad idea. Why?</p></div></li>
</ol>
</section>
<section id="P700049702700000000000000000862D" data-uri="chapter12.xhtml#P700049702700000000000000000862D" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000470C9" data-uri="chapter12.xhtml#P70004970270000000000000000470C9" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.14 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="practicelist2 pcalibre pcalibre1" id="P70004970270000000000000000470CA" data-uri="chapter12.xhtml#P70004970270000000000000000470CA">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000470CB" data-uri="chapter12.xhtml#P70004970270000000000000000470CB">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000470CC" data-uri="chapter12.xhtml#P70004970270000000000000000470CC"><p id="P70004970270000000000000000470CD" data-uri="chapter12.xhtml#P70004970270000000000000000470CD" class="pcalibre calibre3 pcalibre1">In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008638"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.43</span></a>, we eliminated the race by allocating a separate block for each integer ID. Outline a different approach that does not call the <code id="P70004970270000000000000000470CE" data-uri="chapter12.xhtml#P70004970270000000000000000470CE" class="pcalibre1 calibre8 pcalibre">malloc</code> or <code id="P70004970270000000000000000470CF" data-uri="chapter12.xhtml#P70004970270000000000000000470CF" class="pcalibre1 calibre8 pcalibre">free</code> functions.</p></div></li>
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000470D0" data-uri="chapter12.xhtml#P70004970270000000000000000470D0">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000470D1" data-uri="chapter12.xhtml#P70004970270000000000000000470D1"><p id="P70004970270000000000000000470D2" data-uri="chapter12.xhtml#P70004970270000000000000000470D2" class="pcalibre calibre3 pcalibre1">What are the advantages and disadvantages of this approach?</p></div></li>
</ol>
</section>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008638" data-uri="chapter12.xhtml#P7000497027000000000000000008638">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008639" title="1027" data-uri="chapter12.xhtml#P7000497027000000000000000008639" epub:type="pagebreak"></span>
<p id="P70004970270000000000000000470D3" data-uri="chapter12.xhtml#P70004970270000000000000000470D3" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/norace.c</i></p>
<pre id="P70004970270000000000000000470D4" data-uri="chapter12.xhtml#P70004970270000000000000000470D4" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000470D5" data-uri="chapter12.xhtml#P70004970270000000000000000470D5" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	#define N 4
3
4	void *thread(void *vargp);
5
6	int main()
7	{
8		pthread_t tid[N];
9		int i, *ptr;
10
11		for (i = 0; i &lt; N; i++) {
12			ptr = Malloc(sizeof(int));
13			*ptr = i;
14			Pthread_create(&amp;tid[i], NULL, thread, ptr);
15		}
16		for (i = 0; i &lt; N; i++)
17			Pthread_join(tid[i], NULL);
18		exit(0);
19	}
20
21	/* Thread routine */
22	void *thread(void *vargp)
23	{
24		int myid = *((int *)vargp);
25		Free(vargp);
26		printf("Hello from thread %d\n", myid);
27		return NULL;
28	}
</code></pre>
<p id="P70004970270000000000000000470D6" data-uri="chapter12.xhtml#P70004970270000000000000000470D6" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/norace.c</i></p>
<figcaption id="P70004970270000000000000000470D7" data-uri="chapter12.xhtml#P70004970270000000000000000470D7" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000470D8" data-uri="chapter12.xhtml#P70004970270000000000000000470D8" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.43 </span></h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000470D9" data-uri="chapter12.xhtml#P70004970270000000000000000470D9"><p id="P70004970270000000000000000470DA" data-uri="chapter12.xhtml#P70004970270000000000000000470DA" class="pcalibre calibre3 pcalibre1">A correct version of the program in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008614"><span class="pcalibre label pcalibre1">Figure </span><span class="number pcalibre pcalibre1">12.42</span></a> without a race.</p></div></figcaption>
</figure>
</section>
<section id="P7000497027000000000000000008642" data-uri="chapter12.xhtml#P7000497027000000000000000008642" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000470DB" data-uri="chapter12.xhtml#P70004970270000000000000000470DB" epub:type="title"><span class="pcalibre label pcalibre1">12.7.5 </span>Deadlocks</h1></header>
<p id="P70004970270000000000000000470DC" data-uri="chapter12.xhtml#P70004970270000000000000000470DC" class="pcalibre1 pcalibre calibre2">Semaphores introduce the potential for a nasty kind of run-time error, called <i class="calibre5 pcalibre pcalibre1">deadlock</i>, where a collection of threads is blocked, waiting for a condition that will never be true. The progress graph is an invaluable tool for understanding deadlock. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008648"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.44</span></a> shows the progress graph for a pair of threads that use two semaphores for mutual exclusion. From this graph, we can glean some important insights about deadlock:</p>
<ul id="P70004970270000000000000000470DD" data-uri="chapter12.xhtml#P70004970270000000000000000470DD" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000470DE" data-uri="chapter12.xhtml#P70004970270000000000000000470DE" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000470DF" data-uri="chapter12.xhtml#P70004970270000000000000000470DF" class="pcalibre calibre3 pcalibre1">The programmer has incorrectly ordered the <var class="calibre5 pcalibre pcalibre1">P</var> and <var class="calibre5 pcalibre pcalibre1">V</var> operations such that the forbidden regions for the two semaphores overlap. If some execution trajectory happens to reach the <i class="calibre5 pcalibre pcalibre1">deadlock state d</i>, then no further progress is</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008648" data-uri="chapter12.xhtml#P7000497027000000000000000008648">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008649" title="1028" data-uri="chapter12.xhtml#P7000497027000000000000000008649" epub:type="pagebreak"></span>
<img alt="A graph shows trajectories and regions for a program that can deadlock." id="P70004970270000000000000000470E0" data-uri="P700049702700000000000000000B69C" src="../images/p1028-1.png" class="pcalibre calibre346 pcalibre1"/>
<figcaption id="P70004970270000000000000000470E1" data-uri="chapter12.xhtml#P70004970270000000000000000470E1" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000470E2" data-uri="chapter12.xhtml#P70004970270000000000000000470E2" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.44 </span>Progress graph for a program that can deadlock.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000027455" data-uri="chapter12.xhtml#P7000497027000000000000000027455">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000470E3" data-uri="chapter12.xhtml#P70004970270000000000000000470E3" class="pcalibre calibre3 pcalibre1">A graph of thread 2 versus thread 1 shows P(s), P(t), V(s), and V(t) on the thread 1 axis and P(t), P(s), V(t), and V(s) on the thread 2 axis (initially s = 1 and t = 1). Regions include a forbidden region for s (from P(s) to V(s) on each axis) and a forbidden region for t (from P(t) to V(t) on each axis). The deadlock state d extends from P(s) to P(t). A trajectory that does not deadlock extends vertical to P(s), right to P(s), up to V(s) and then right, outside the regions. A trajectory that deadlocks extends right to P(s), up to P(t), right to the end of P(s), up to the end of P(t), right to P(t), and up into the deadlock state.</p>
</details>
</figcaption>
</figure>
<p class="pcalibre calibre3 pcalibre1" id="P70004970270000000000000000470E4" data-uri="chapter12.xhtml#P70004970270000000000000000470E4">possible because the overlapping forbidden regions block progress in every legal direction. In other words, the program is deadlocked because each thread is waiting for the other to do a <var class="calibre5 pcalibre pcalibre1">V</var> operation that will never occur.</p></li>
<li id="P70004970270000000000000000470E5" data-uri="chapter12.xhtml#P70004970270000000000000000470E5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000470E6" data-uri="chapter12.xhtml#P70004970270000000000000000470E6" class="pcalibre calibre3 pcalibre1">The overlapping forbidden regions induce a set of states called the <i class="calibre5 pcalibre pcalibre1">deadlock region</i>. If a trajectory happens to touch a state in the deadlock region, then deadlock is inevitable. Trajectories can enter deadlock regions, but they can never leave.</p></li>
<li id="P70004970270000000000000000470E7" data-uri="chapter12.xhtml#P70004970270000000000000000470E7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000470E8" data-uri="chapter12.xhtml#P70004970270000000000000000470E8" class="pcalibre calibre3 pcalibre1">Deadlock is an especially difficult issue because it is not always predictable. Some lucky execution trajectories will skirt the deadlock region, while others will be trapped by it. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008648"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.44</span></a> shows an example of each. The implications for a programmer are scary. You might run the same program a thousand times without any problem, but then the next time it deadlocks. Or the program might work fine on one machine but deadlock on another. Worst of all, the error is often not repeatable because different executions have different trajectories.</p></li>
</ul>
<p id="P70004970270000000000000000470E9" data-uri="chapter12.xhtml#P70004970270000000000000000470E9" class="pcalibre1 pcalibre calibre2">Programs deadlock for many reasons, and preventing them is a difficult problem in general. However, when binary semaphores are used for mutual exclusion, as in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008648"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.44</span></a>, then you can apply the following simple and effective rule to prevent deadlocks:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008653" data-uri="chapter12.xhtml#P7000497027000000000000000008653">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008654" title="1029" data-uri="chapter12.xhtml#P7000497027000000000000000008654" epub:type="pagebreak"></span>
<img alt="A graph shows regions for a dead-lock free program." id="P70004970270000000000000000470EA" data-uri="P700049702700000000000000000B69D" src="../images/p1029-1.png" class="pcalibre1 pcalibre calibre347"/>
<figcaption id="P70004970270000000000000000470EB" data-uri="chapter12.xhtml#P70004970270000000000000000470EB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000470EC" data-uri="chapter12.xhtml#P70004970270000000000000000470EC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.45 </span>Progress graph for a deadlock-free program.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000027460" data-uri="chapter12.xhtml#P7000497027000000000000000027460">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000470ED" data-uri="chapter12.xhtml#P70004970270000000000000000470ED" class="pcalibre calibre3 pcalibre1">A graph of thread 2 versus thread 1 shows P(s), P(t), V(s), and V(t) on the thread 1 axis and P(s), P(t), V(t), and V(s) on the thread 2 axis (initially s = 1 and t = 1). Regions include a forbidden region for s from P(s) to V(s) on each axis and a forbidden region for t from P(t) to V(t) on each axis.</p>
</details>
</figcaption>
</figure>
<ul class="pcalibre ul_none pcalibre1" id="P70004970270000000000000000470EE" data-uri="chapter12.xhtml#P70004970270000000000000000470EE">
<li id="P70004970270000000000000000470EF" data-uri="chapter12.xhtml#P70004970270000000000000000470EF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000470F0" data-uri="chapter12.xhtml#P70004970270000000000000000470F0" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Mutex lock ordering rule: </span>Given a total ordering of all mutexes, a program is deadlock-free if each thread acquires its mutexes in order and releases them in reverse order.</p></li>
</ul>
<p id="P70004970270000000000000000470F1" data-uri="chapter12.xhtml#P70004970270000000000000000470F1" class="pcalibre1 pcalibre calibre2">For example, we can fix the deadlock in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008648"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.44</span></a> by locking <var class="calibre5 pcalibre pcalibre1">s</var> first, then <var class="calibre5 pcalibre pcalibre1">t</var>, in each thread. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008653"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.45</span></a> shows the resulting progress graph.</p>
<section id="P700049702700000000000000000865C" data-uri="chapter12.xhtml#P700049702700000000000000000865C" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000470F2" data-uri="chapter12.xhtml#P70004970270000000000000000470F2" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.15 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000875E.xhtml#P7000497027000000000000000008837">1039</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000470F3" data-uri="chapter12.xhtml#P70004970270000000000000000470F3">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000470F4" data-uri="chapter12.xhtml#P70004970270000000000000000470F4">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000470F5" data-uri="chapter12.xhtml#P70004970270000000000000000470F5"><p id="P70004970270000000000000000470F6" data-uri="chapter12.xhtml#P70004970270000000000000000470F6" class="pcalibre calibre3 pcalibre1">Consider the following program, which attempts to use a pair of semaphores for mutual exclusion.</p>
<pre id="P70004970270000000000000000470F7" data-uri="chapter12.xhtml#P70004970270000000000000000470F7" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000470F8" data-uri="chapter12.xhtml#P70004970270000000000000000470F8" class="calibre10 pcalibre pcalibre1">Initially: s = 1, t = 0.</code></pre>
<pre id="P70004970270000000000000000470F9" data-uri="chapter12.xhtml#P70004970270000000000000000470F9" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000470FA" data-uri="chapter12.xhtml#P70004970270000000000000000470FA" class="calibre10 pcalibre pcalibre1">
      Thread 1:	      Thread 2:
	P(s);		P(s);
	V(s);		V(s);
	P(t);		P(t);
	V(t);		V(t);
</code></pre>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P70004970270000000000000000470FB" data-uri="chapter12.xhtml#P70004970270000000000000000470FB">
<li id="P70004970270000000000000000470FC" data-uri="chapter12.xhtml#P70004970270000000000000000470FC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000470FD" data-uri="chapter12.xhtml#P70004970270000000000000000470FD" class="pcalibre calibre3 pcalibre1">Draw the progress graph for this program.</p></li>
<li id="P70004970270000000000000000470FE" data-uri="chapter12.xhtml#P70004970270000000000000000470FE" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000470FF" data-uri="chapter12.xhtml#P70004970270000000000000000470FF" class="pcalibre calibre3 pcalibre1">Does it always deadlock?</p></li>
<li id="P7000497027000000000000000047100" data-uri="chapter12.xhtml#P7000497027000000000000000047100" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000047101" data-uri="chapter12.xhtml#P7000497027000000000000000047101" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000866D" title="1030" data-uri="chapter12.xhtml#P700049702700000000000000000866D" epub:type="pagebreak"></span>If so, what simple change to the initial semaphore values will eliminate the potential for deadlock?</p></li>
<li id="P7000497027000000000000000047102" data-uri="chapter12.xhtml#P7000497027000000000000000047102" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000047103" data-uri="chapter12.xhtml#P7000497027000000000000000047103" class="pcalibre calibre3 pcalibre1">Draw the progress graph for the resulting deadlock-free program.</p></li>
</ol></div></li>
</ol>
</section>
</section>
</section></body></html>
