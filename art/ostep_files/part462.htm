<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Crash Consistency: FSCK and Journaling</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part461.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part463.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 43pt;text-indent: 0pt;text-align: center;">Crash Consistency: FSCK and Journaling</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">As we’ve seen thus far, the file system manages a set of data structures to implement the expected abstractions: files, directories, and all of the other metadata needed to support the basic abstraction that we expect from a file system. Unlike most data structures (for example, those found in memory of a running program), file system data structures must <b>persist</b>, i.e., they must survive over the long haul, stored on devices that retain data despite power loss (such as hard disks or flash-based SSDs).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One major challenge faced by a file system is how to update persis- tent data structures despite the presence of a <b>power loss </b>or <b>system crash</b>. Specifically, what happens if, right in the middle of updating on-disk structures, someone trips over the power cord and the machine loses power? Or the operating system encounters a bug and crashes? Because of power losses and crashes, updating a persistent data structure can be quite tricky, and leads to a new and interesting problem in file system implementation, known as the <b>crash-consistency problem</b>.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">This problem is quite simple to understand. Imagine you have to up- date two on-disk structures, <span class="s43">A </span>and <span class="s43">B</span>, in order to complete a particular operation. Because the disk only services a single request at a time, one of these requests will reach the disk first (either <span class="s43">A </span>or <span class="s43">B</span>). If the system crashes or loses power after one write completes, the on-disk structure will be left in an <b>inconsistent </b>state. And thus, we have a problem that all file systems need to solve:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 34pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>U<span class="s7">PDATE </span>T<span class="s7">HE </span>D<span class="s7">ISK </span>D<span class="s7">ESPITE </span>C<span class="s7">RASHES</span></p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The system may crash or lose power between any two writes, and thus the on-disk state may only partially get updated. After the crash, the system boots and wishes to mount the file system again (in order to access files and such). Given that crashes can occur at arbitrary points in time, how do we ensure the file system keeps the on-disk image in a reasonable state?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 21pt;text-indent: 0pt;text-align: center;">491</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this chapter, we’ll describe this problem in more detail, and look at some methods file systems have used to overcome it. We’ll begin by examining the approach taken by older file systems, known as <b>fsck </b>or the <b>file system checker</b>. We’ll then turn our attention to another approach, known as <b>journaling </b>(also known as <b>write-ahead logging</b>), a technique which adds a little bit of overhead to each write but recovers more quickly from crashes or power losses. We will discuss the basic machinery of journaling, including a few different flavors of journaling that Linux ext3 [T98,PAA05] (a relatively modern journaling file system) implements.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part463.htm">42.1 A Detailed Example</a><a class="toc1" href="part464.htm">Crash Scenarios</a><a class="toc1" href="part465.htm">The Crash Consistency Problem</a><a class="toc0" href="part466.htm">42.2 Solution #1: The File System Checker</a><a class="toc0" href="part467.htm">42.3 Solution #2: Journaling (or Write-Ahead Logging)</a><a class="toc1" href="part468.htm">Data Journaling</a><a class="toc1" href="part469.htm">Recovery</a><a class="toc1" href="part470.htm">Batching Log Updates</a><a class="toc1" href="part471.htm">Making The Log Finite</a><a class="toc1" href="part472.htm">Metadata Journaling</a><a class="toc1" href="part473.htm">Tricky Case: Block Reuse</a><a class="toc1" href="part474.htm">Wrapping Up Journaling: A Timeline</a><a class="toc0" href="part475.htm">42.4 Solution #3: Other Approaches</a><a class="toc0" href="part476.htm">42.5 Summary</a><a class="toc0" href="part477.htm">References</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part461.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part463.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
