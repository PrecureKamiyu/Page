<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Practice Exercises</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part210.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part212.htm">下一个 &gt;</a></p><p class="s45" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">Practice Exercises</p><p class="s46" style="padding-top: 12pt;padding-left: 155pt;text-indent: -29pt;text-align: justify;">10.1 <span class="p">Suppose you need to store a very large number of small ﬁles, each of size say 2 kilobytes. If your choice is between a distributed ﬁle system and a distributed key-value store, which would you prefer, and explain why.</span></p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;"><b>10.2  </b>Suppose you need to store data for a very large number of students in a dis- tributed document store such as MongoDB. Suppose also that the data for each student correspond to the data in the <i>student </i>and the <i>takes </i>relations. How would you represent the above data about students, ensuring that all the data for a particular student can be accessed eﬃciently? Give an example of the data representation for one student.</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;"><b>10.3  </b>Suppose you wish to store utility bills for a large number of users, where each bill is identiﬁed by a customer <span class="s44">ID </span>and a date. How would you store the bills in a key-value store that supports range queries, if queries request the bills of a speciﬁed customer for a speciﬁed date range.</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;line-height: 69%;text-align: justify;"><b>10.4  </b>Give pseudocode for computing a join <i>r </i><span class="s86">⋈</span><span class="s149">r</span><span class="s167">.</span><span class="s149">A</span><span class="s136">=</span><span class="s149">s</span><span class="s167">.</span><span class="s149">A </span><i>s </i>using a single MapReduce step, assuming that the <span class="s49">map() </span>function is invoked on each tuple of <i>r </i>and <i>s</i>.</p><p style="padding-top: 1pt;padding-left: 155pt;text-indent: 0pt;text-align: justify;">Assume that the <span class="s49">map() </span>function can ﬁnd the name of the relation using <span class="s49">con- text.relname()</span>.</p><p style="padding-top: 6pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;"><b>10.5  </b>What is the conceptual problem with the following snippet of Apache Spark code meant to work on very large data. Note that the <span class="s49">collect() </span>function returns a Java collection, and Java collections (from Java 8 onwards) support map and reduce functions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-top: 7pt;padding-left: 206pt;text-indent: 0pt;line-height: 62%;text-align: center;">JavaRDD<span class="s186">&lt;</span>String<span class="s186">&lt; </span>lines = sc.textFile(&quot;logDirectory&quot;); int totalLength = lines.collect().map(s <span class="s185">−</span><span class="s186">&gt; </span>s.length())</p><p class="s49" style="padding-left: 160pt;text-indent: 0pt;line-height: 15pt;text-align: center;">.reduce(0,(a,b) <span class="s185">−</span><span class="s186">&gt; </span>a+b);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 125pt;text-indent: 0pt;text-align: left;">10.6 <span class="p">Apache Spark:</span></p><p style="padding-top: 9pt;padding-left: 163pt;text-indent: 0pt;text-align: left;">a. How does Apache Spark perform computations in parallel?</p><p style="padding-top: 6pt;padding-left: 162pt;text-indent: 0pt;text-align: left;">b. Explain the statement: “Apache Spark performs transformations on</p><p class="s42" style="padding-left: 181pt;text-indent: 0pt;text-align: left;">RDD<span class="s43">s in a lazy manner.”</span></p><p style="padding-top: 6pt;padding-left: 181pt;text-indent: -18pt;text-align: left;">c.  What are some of the beneﬁts of lazy evaluation of operations in Apache Spark?</p><p style="padding-top: 9pt;padding-left: 155pt;text-indent: -30pt;text-align: justify;"><b>10.7  </b>Given a collection of documents, for each word <i>w</i><span class="s145">i</span>, let <i>n</i><span class="s145">i </span>denote the number of times the word occurs in the collection. Let <i>N </i>be the total number of word oc- currences across all documents. Next, consider all pairs of consecutive words</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 124pt;text-indent: 0pt;line-height: 90%;text-align: justify;">(<i>w</i><span class="s145">i</span>, <i>w</i><span class="s145">j </span>) in the document; let <i>n</i><span class="s145">i</span><span class="s93">,</span><span class="s169">j </span>denote the number of occurrences of the word pair (<i>w</i><span class="s97">i</span>, <i>w</i><span class="s97">j </span>) across all documents.</p><p style="padding-left: 138pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Write an Apache Spark program that, given a collection of documents in a</p><p class="s13" style="padding-top: 1pt;padding-left: 124pt;text-indent: 0pt;line-height: 82%;text-align: justify;"><span class="p">directory, computes </span>N <span class="p">, all pairs (</span>w<span class="s97">i</span><span class="p">, </span>n<span class="s97">i</span><span class="p">), and all pairs ((</span>w<span class="s97">i </span><span class="p">, </span>w<span class="s97">j </span><span class="p">), </span>n<span class="s97">i</span><span class="s130">,</span><span class="s149">j </span><span class="p">). Then output all word pairs such that </span>n<span class="s97">i</span><span class="s130">,</span><span class="s149">j </span><span class="s15">∕</span>N <span class="s86">≥ </span><span class="p">10 </span><span class="s15">∗ </span><span class="p">(</span>n<span class="s97">i</span><span class="s15">∕</span>N <span class="p">) </span><span class="s15">∗ </span><span class="p">(</span>n<span class="s97">j </span><span class="s15">∕</span>N <span class="p">). These are word pairs that occur 10 times or more as frequently as they would be expected to occur</span></p><p style="padding-left: 124pt;text-indent: 0pt;text-align: justify;">if the two words occurred independently of each other.</p><p style="padding-left: 124pt;text-indent: 14pt;text-align: justify;">You will ﬁnd the join operation on <span class="s44">RDD</span>s useful for the last step, to bring related counts together. For simplicity, do not bother about word pairs that cross lines. Also assume for simplicity that words only occur in lowercase and that there are no punctuation marks.</p><p class="s46" style="padding-top: 6pt;padding-left: 93pt;text-indent: 0pt;text-align: justify;">10.8  <span class="p">Consider the following query using the tumbling window operator:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2371.png"/></span></p><p class="s13" style="padding-left: 163pt;text-indent: 0pt;text-align: left;"><b>select </b>item<span class="p">, </span>System.Timestamp <b>as </b>window end<span class="p">, </span><b>sum</b><span class="p">(</span>amount<span class="p">) </span><b>from </b>order <b>timestamp by </b>datetime</p><p style="padding-left: 163pt;text-indent: 0pt;text-align: left;"><b>group by </b><i>itemid</i>, <b>tumblingwindow</b>(<i>hour</i>, 1)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2372.png"/></span></p><p style="padding-left: 124pt;text-indent: 0pt;text-align: justify;">Give an equivalent query using normal <span class="s44">SQL </span>constructs, without using the tum- bling window operator. You can assume that the timestamp can be converted to an integer value that represents the number of seconds elapsed since (say) midnight, January 1, 1970, using the function <i>to seconds</i>(<i>timestamp</i>). You can</p><p style="padding-top: 1pt;padding-left: 124pt;text-indent: 0pt;line-height: 90%;text-align: justify;">also assume that the usual arithmetic functions are available, along with the function <i>floor</i>(<i>a</i>) which returns the largest integer <span class="s86">≤ </span><i>a</i>.</p><p class="s46" style="padding-top: 4pt;padding-left: 124pt;text-indent: -30pt;text-align: justify;">10.9  <span class="p">Suppose you wish to model the university schema as a graph. For each of the following relations, explain whether the relation would be modeled as a node or as an edge:</span></p><p style="padding-left: 124pt;text-indent: 16pt;text-align: justify;">(i) <i>student</i>, (ii) <i>instructor</i>, (iii) <i>course</i>, (iv) <i>section</i>, (v) <i>takes</i>, (vi) <i>teaches</i>. Does the model capture connections between sections and courses?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part210.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part212.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
