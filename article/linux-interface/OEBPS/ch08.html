<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 8. Users and Groups</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch07.html" title="Chapter 7. Memory Allocation"/><link rel="next" href="ch09.html" title="Chapter 9. Process Credentials"/></head><body><section class="chapter" title="Chapter 8. Users and Groups" epub:type="chapter" id="users_and_groups-id1"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Users and Groups</h2></div></div></div><p>Every user has a unique login name and an associated numeric user identifier (UID).
            Users can belong to one or more groups. Each group also has a unique name and a group
            identifier (GID).<a id="IDX-CHP-8-1064" class="indexterm"/></p><p>The primary purpose of user and group IDs is to determine ownership of various system
            resources and to control the permissions granted to processes accessing those resources.
            For example, each file belongs to a particular user and group, and each process has a
            number of user and group IDs that determine who owns the process and what permissions it
            has when accessing a file (see <a class="xref" href="ch09.html" title="Chapter 9. Process Credentials">Chapter 9</a> for
            details).</p><p>In this chapter, we look at the system files that are used to define the users and
            groups on the system, and then describe the library functions used to retrieve
            information from these files. We conclude with a discussion of the
                <span class="emphasis"><em>crypt()</em></span> function, which is used to encrypt and authenticate
            login passwords.</p><div class="sect1" title="The Password File: /etc/passwd"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_password_file_colon__solidus_etc_sol">The Password File: <code class="literal">/etc/passwd</code></h2></div></div></div><p>The system <span class="emphasis"><em>password file</em></span>, <code class="literal">/etc/passwd</code>, contains one line for each user account on the system.
                Each line is composed of seven fields separated by colons (<code class="literal">:</code>), as in the following example:<a id="IDX-CHP-8-1065" class="indexterm"/><a id="IDX-CHP-8-1066" class="indexterm"/><a id="IDX-CHP-8-1067" class="indexterm"/><a id="IDX-CHP-8-1068" class="indexterm"/><a id="IDX-CHP-8-1069" class="indexterm"/><a id="IDX-CHP-8-1070" class="indexterm"/><a id="IDX-CHP-8-1071" class="indexterm"/><a id="IDX-CHP-8-1072" class="indexterm"/><a id="IDX-CHP-8-1073" class="indexterm"/></p><a id="I_programlisting8_d1e18158"/><pre class="programlisting">mtk:x:1000:100:Michael Kerrisk:/home/mtk:/bin/bash</pre><p>In order, these fields are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Login name</em></span>: This is the unique name that the user
                        must enter in order to log in. Often, this is also called the username. We
                        can also consider the login name to be the human-readable (symbolic)
                        identifier corresponding to the numeric user identifier (described in a
                        moment). Programs such as <span class="emphasis"><em>ls(1)</em></span> display this name,
                        rather than the numeric user ID associated with the file, when asked to show
                        the ownership of a file (as in <span class="emphasis"><em>ls -l</em></span>).<a id="IDX-CHP-8-1074" class="indexterm"/><a id="IDX-CHP-8-1075" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Encrypted password</em></span>: This field contains a
                        13-character encrypted password, which we describe in more detail in Section
                        8.5. If the password field contains any other string—in particular, a string
                        of other than 13 characters—then logins to this account are disabled, since
                        such a string can’t represent a valid encrypted password. Note, however,
                        that this field is ignored if shadow passwords have been enabled (which is
                        typical). In this case, the password field in <code class="literal">etc/passwd</code> conventionally contains the letter
                            <span class="emphasis"><em>x</em></span> (although any nonempty character string may
                        appear), and the encrypted password is instead stored in the shadow password
                        file (<a class="xref" href="ch08.html#the_shadow_password_file_colon__solidus" title="The Shadow Password File: /etc/shadow">The Shadow Password File: <code class="literal">/etc/shadow</code></a>). If the
                        password field in <code class="literal">/etc/passwd</code> is empty,
                        then no password is required to log in to this account (this is true even if
                        shadow passwords are enabled).</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Here, we assume that passwords are encrypted using Data Encryption Standard
                    (DES), the historical and still widely used UNIX password-encryption scheme. It
                    is possible to replace DES with other schemes, such as MD5, which produces a
                    128-bit <span class="emphasis"><em>message digest</em></span> (a kind of hash) of its input. This
                    value is stored as a 34-character string in the password (or shadow password)
                    file.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>User ID</em></span> (UID): This is the numeric ID for this user.
                        If this field has the value 0, then this account has superuser privileges.
                        There is normally one such account, with the login name
                            <span class="emphasis"><em>root</em></span>. On Linux 2.2 and earlier, user IDs are
                        maintained as 16-bit values, allowing the range 0 through to 65,535; on
                        Linux 2.4 and later, they are stored using 32 bits, allowing a much larger
                        range.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>It is possible (but unusual) to have more than one record in the password file
                    with the same user ID, thus permitting multiple login names for the same user
                    ID. This allows multiple users to access the same resources (e.g., files) using
                    different passwords. The different login names can be associated with different
                    sets of group IDs.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Group ID</em></span> (GID): This is the numeric ID of the first
                        of the groups of which this user is a member. Further group memberships for
                        this user are defined in the system group file.</p></li><li class="listitem"><p><span class="emphasis"><em>Comment</em></span>: This field holds text about the user. This
                        text is displayed by various programs, such as
                            <span class="emphasis"><em>finger(1)</em></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>Home directory</em></span>: This is the initial directory into
                        which the user is placed after logging in. This field becomes the value of
                        the <code class="literal">HOME</code> environment variable.<a id="IDX-CHP-8-1076" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Login shell</em></span>: This is the program to which control is
                        transferred once the user is logged in. Usually, this is one of the shells,
                        such as <span class="emphasis"><em>bash</em></span>, but it can be any program. If this field
                        is empty, then the login shell defaults to <code class="literal">/bin/sh</code>, the Bourne shell. This field becomes the value of
                        the <code class="literal">SHELL</code> environment variable.<a id="IDX-CHP-8-1077" class="indexterm"/><a id="IDX-CHP-8-1078" class="indexterm"/></p></li></ul></div><p>On a stand-alone system, all the password information resides in the file <code class="literal">/etc/passwd</code>. However, if we are using a system such as
                Network Information System (NIS) or Lightweight Directory Access Protocol (LDAP) to
                distribute passwords in a network environment, part or all of this information
                resides on a remote system. As long as programs accessing password information
                employ the functions described later in this chapter
                    (<span class="emphasis"><em>getpwnam()</em></span>, <span class="emphasis"><em>getpwuid()</em></span>, and so on),
                the use of NIS or LDAP is transparent to applications. Similar comments apply
                regarding the shadow password and group files discussed in the following
                sections.</p></div><div class="sect1" title="The Shadow Password File: /etc/shadow"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_shadow_password_file_colon__solidus">The Shadow Password File: <code class="literal">/etc/shadow</code></h2></div></div></div><p>Historically, UNIX systems maintained all user information, including the
                encrypted password, in <code class="literal">/etc/passwd</code>. This
                presented a security problem. Since various unprivileged system utilities needed to
                have read access to other information in the password file, it had to be made
                readable to all users. This opened the door for password-cracking programs, which
                try encrypting large lists of likely passwords (e.g., standard dictionary words or
                people’s names) to see if they match the encrypted password of a user. The
                    <span class="emphasis"><em>shadow password file</em></span>, <code class="literal">/etc/shadow</code>, was devised as a method of preventing such attacks. The
                idea is that all of the nonsensitive user information resides in the publicly
                readable password file, while encrypted passwords are maintained in the shadow
                password file, which is readable only by privileged programs.<a id="IDX-CHP-8-1079" class="indexterm"/><a id="IDX-CHP-8-1080" class="indexterm"/><a id="IDX-CHP-8-1081" class="indexterm"/><a id="IDX-CHP-8-1082" class="indexterm"/><a id="IDX-CHP-8-1083" class="indexterm"/></p><p>In addition to the login name, which provides the match to the corresponding
                record in the password file, and the encrypted password, the shadow password file
                also contains a number of other security-related fields. Further details on these
                fields can be found in the <span class="emphasis"><em>shadow(5)</em></span> manual page. We’ll concern
                ourselves mainly with the encrypted password field, which we discuss in greater
                detail when looking at the <span class="emphasis"><em>crypt()</em></span> library function later in
                Section 8.5.</p><p>SUSv3 doesn’t specify shadow passwords. Not all UNIX implementations provide this
                feature, and on implementations where it is provided the details of the file
                locations and APIs vary.</p></div><div class="sect1" title="The Group File: /etc/group"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_group_file_colon__solidus_etc_solidu">The Group File: <code class="literal">/etc/group</code></h2></div></div></div><p>For various administrative purposes, in particular, controlling access to files
                and other system resources, it is useful to organize users into
                    <span class="emphasis"><em>groups</em></span>.</p><p>The set of groups to which a user belongs is defined by the combination of the
                group ID field in the user’s password entry and the groups under which the user is
                listed in the group file. This strange split of information across two files is
                historical in origin. In early UNIX implementations, a user could be a member of
                only one group at a time. A user’s initial group membership at login was determined
                by the group ID field of the password file and could be changed thereafter using the
                    <span class="emphasis"><em>newgrp(1)</em></span> command, which required the user to supply the
                group password (if the group was password protected). 4.2BSD introduced the concept
                of multiple simultaneous group memberships, which was later standardized in
                POSIX.1-1990. Under this scheme, the group file listed the extra group memberships
                of each user. (The <span class="emphasis"><em>groups(1)</em></span> command displays the groups of
                which the shell process is a member, or, if one or more usernames are supplied as
                command-line arguments, then the group memberships of those users.)<a id="IDX-CHP-8-1084" class="indexterm"/><a id="IDX-CHP-8-1085" class="indexterm"/></p><p>The <span class="emphasis"><em>group file</em></span>, <code class="literal">/etc/group</code>, contains one line for each group in the system. Each line
                consists of four colon-separated fields, as in the following examples:</p><a id="I_programlisting8_d1e18356"/><pre class="programlisting">users:x:100:
jambit:x:106:claus,felli,frank,harti,markus,martin,mtk,paul</pre><p>In order, these fields are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Group name</em></span>: This is the name of the group. Like the
                        login name in the password file, we can consider this to be the
                        human-readable (symbolic) identifier corresponding to the numeric group
                        identifier.</p></li><li class="listitem"><p><span class="emphasis"><em>Encrypted password</em></span>: This field contains an optional
                        password for the group. With the advent of multiple group memberships, group
                        passwords are nowadays rarely used on UNIX systems. Nevertheless, it is
                        possible to place a password on a group (a privileged user can do this using
                        the <span class="emphasis"><em>gpasswd</em></span> command). If a user is not a member of the
                        group, <span class="emphasis"><em>newgrp(1)</em></span> requests this password before starting
                        a new shell whose group memberships include that group. If password
                        shadowing is enabled, then this field is ignored (in this case,
                        conventionally it contains just the letter <span class="emphasis"><em>x</em></span>, but any
                        string, including an empty string, may appear) and the encrypted passwords
                        are actually kept in the <span class="emphasis"><em>shadow group file</em></span>, <code class="literal">/etc/gshadow</code>, which can be accessed only by
                        privileged users and programs. Group passwords are encrypted in a similar
                        fashion to user passwords (<a class="xref" href="ch08.html#password_encryption_and_user_authenticat" title="Password Encryption and User Authentication">Password Encryption and User Authentication</a>).<a id="IDX-CHP-8-1086" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Group ID</em></span> (GID): This is the numeric ID for this
                        group. There is normally one group defined with the group ID 0, named
                            <span class="emphasis"><em>root</em></span> (like the <code class="literal">/etc/passwd</code> record with user ID of 0, but unlike the user ID
                        0, this group has no special privileges). On Linux 2.2 and earlier, group
                        IDs are maintained as 16-bit values, allowing the range 0 through to 65,535;
                        on Linux 2.4 and later, they are stored using 32 bits.<a id="IDX-CHP-8-1087" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>User list</em></span>: This is a comma-separated list of names of
                        users who are members of this group. (This list consists of usernames rather
                        than user IDs, since, as noted earlier, user IDs are not necessarily unique
                        in the password file.)</p></li></ul></div><p>To record that the user <span class="emphasis"><em>avr</em></span> is a member of the groups
                    <span class="emphasis"><em>users</em></span>, <span class="emphasis"><em>staff</em></span>, and
                    <span class="emphasis"><em>teach</em></span>, we would see the following record in the password
                file:</p><a id="I_programlisting8_d1e18425"/><pre class="programlisting">avr:x:1001:100:Anthony Robins:/home/avr:/bin/bash</pre><p>And the following records would appear in the group file:</p><a id="I_programlisting8_d1e18429"/><pre class="programlisting">users:x:100:
staff:x:101:mtk,avr,martinl
teach:x:104:avr,rlb,alc</pre><p>The fourth field of the password record, containing the group ID 100, specifies
                membership of the group <span class="emphasis"><em>users</em></span>. The remaining group memberships
                are indicated by listing <span class="emphasis"><em>avr</em></span> once in each of the relevant
                records in the group file.</p></div><div class="sect1" title="Retrieving User and Group Information"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="retrieving_user_and_group_information">Retrieving User and Group Information</h2></div></div></div><p>In this section, we look at library functions that permit us to retrieve
                individual records from the password, shadow password, and group files, and to scan
                all of the records in each of these files.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="retrieving_records_from_the_password"/></div></div></div><div class="sect3" title="Retrieving records from the password file"><div class="titlepage"><div><div><h4 class="title" id="retrieving_records_from_the_password-id1">Retrieving records from the password file</h4></div></div></div><p>The <span class="emphasis"><em>getpwnam()</em></span> and <span class="emphasis"><em>getpwuid()</em></span>
                        functions retrieve records from the password file.<a id="IDX-CHP-8-1088" class="indexterm"/><a id="IDX-CHP-8-1089" class="indexterm"/><a id="IDX-CHP-8-1090" class="indexterm"/><a id="IDX-CHP-8-1091" class="indexterm"/><a id="IDX-CHP-8-1092" class="indexterm"/><a id="IDX-CHP-8-1093" class="indexterm"/><a id="IDX-CHP-8-1094" class="indexterm"/></p><a id="I_programlisting8_d1e18501"/><pre class="programlisting">#include &lt;pwd.h&gt;

struct passwd *<strong class="userinput"><code>getpwnam</code></strong>(const char *<span class="emphasis"><em>name</em></span>);
struct passwd *<strong class="userinput"><code>getpwuid</code></strong>(uid_t <span class="emphasis"><em>uid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return a pointer on success, or <code class="literal">NULL</code> on error; see main text for description of the “not
                            found” case</p></div><p>Given a login name in <span class="emphasis"><em>name</em></span>, the
                            <span class="emphasis"><em>getpwnam()</em></span> function returns a pointer to a
                        structure of the following type, containing the corresponding information
                        from the password record:</p><a id="I_programlisting8_d1e18529"/><pre class="programlisting">struct passwd {
    char *pw_name;      /* Login name (username) */
    char *pw_passwd;    /* Encrypted password */
    uid_t pw_uid;       /* User ID */
    gid_t pw_gid;       /* Group ID */
    char *pw_gecos;     /* Comment (user information) */
    char *pw_dir;       /* Initial working (home) directory */
    char *pw_shell;     /* Login shell */
};</pre><p>The <span class="emphasis"><em>pw_gecos</em></span> and <span class="emphasis"><em>pw_passwd</em></span>
                        fields of the <span class="emphasis"><em>passwd</em></span> structure are not defined in
                        SUSv3, but are available on all UNIX implementations. The
                            <span class="emphasis"><em>pw_passwd</em></span> field contains valid information only if
                        password shadowing is not enabled. (Programmatically, the simplest way to
                        determine whether password shadowing is enabled is to follow a successful
                            <span class="emphasis"><em>getpwnam()</em></span> call with a call to
                            <span class="emphasis"><em>getspnam()</em></span>, described shortly, to see if it returns
                        a shadow password record for the same username.) Some other implementations
                        provide additional, nonstandard fields in this structure.<a id="IDX-CHP-8-1095" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>pw_gecos</em></span> field derives its name from early
                            UNIX implementations, where this field contained information that was
                            used for communicating with a machine running the General Electric
                            Comprehensive Operating System (GECOS). Although this usage has long
                            since become obsolete, the field name has survived, and the field is
                            used for recording information about the user.</p></div><p>The <span class="emphasis"><em>getpwuid()</em></span> function returns exactly the same
                        information as <span class="emphasis"><em>getpwnam()</em></span>, but does a lookup using the
                        numeric user ID supplied in the argument <span class="emphasis"><em>uid</em></span>.</p><p>Both <span class="emphasis"><em>getpwnam()</em></span> and <span class="emphasis"><em>getpwuid()</em></span>
                        return a pointer to a statically allocated structure. This structure is
                        overwritten on each call to either of these functions (or to the
                            <span class="emphasis"><em>getpwent()</em></span> function described below).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Because they return a pointer to statically allocated memory,
                                <span class="emphasis"><em>getpwnam()</em></span> and <span class="emphasis"><em>getpwuid()</em></span>
                            are not reentrant. In fact, the situation is even more complex, since
                            the returned <span class="emphasis"><em>passwd</em></span> structure contains pointers to
                            other information (e.g., the <span class="emphasis"><em>pw_name</em></span> field) that is
                            also statically allocated. (We explain reentrancy in <a class="xref" href="ch21.html#reentrant_and_async-signal-safe_function" title="Reentrant and Async-Signal-Safe Functions">Reentrant and Async-Signal-Safe Functions</a>.) Similar
                            statements apply to the <span class="emphasis"><em>getgrnam()</em></span> and
                                <span class="emphasis"><em>getgrgid()</em></span> functions (described
                                shortly).<a id="IDX-CHP-8-1096" class="indexterm"/></p><p>SUSv3 specifies an equivalent set of reentrant
                                functions—<span class="emphasis"><em>getpwnam_r()</em></span>,
                                <span class="emphasis"><em>getpwuid_r()</em></span>,
                            <span class="emphasis"><em>getgrnam_r()</em></span>, and
                            <span class="emphasis"><em>getgrgid_r()</em></span>—that include as arguments both a
                                <span class="emphasis"><em>passwd</em></span> (or <span class="emphasis"><em>group</em></span>)
                            structure and a buffer area to hold the other structures to which the
                            fields of the <span class="emphasis"><em>passwd (group)</em></span> structure point. The
                            number of bytes required for this additional buffer can be obtained
                            using the call <span class="emphasis"><em>sysconf(_SC_GETPW_R_SIZE_MAX)</em></span> (or
                                <span class="emphasis"><em>sysconf(_SC_GETGR_R_SIZE_MAX)</em></span> in the case of
                            the group-related functions). See the manual pages for details of these
                                functions.<a id="IDX-CHP-8-1097" class="indexterm"/><a id="IDX-CHP-8-1098" class="indexterm"/><a id="IDX-CHP-8-1099" class="indexterm"/><a id="IDX-CHP-8-1100" class="indexterm"/></p></div><p>According to SUSv3, if a matching <span class="emphasis"><em>passwd</em></span> record can’t
                        be found, then <span class="emphasis"><em>getpwnam()</em></span> and
                            <span class="emphasis"><em>getpwuid()</em></span> should return <code class="literal">NULL</code> and leave <span class="emphasis"><em>errno</em></span> unchanged. This
                        means that we should be able to distinguish the error and the “not found”
                        cases using code such as the following:</p><a id="I_programlisting8_d1e18678"/><pre class="programlisting">struct passwd *pwd;

errno = 0;
pwd = getpwnam(name);
if (pwd == NULL) {
    if (errno == 0)
        /* Not found */;
    else
        /* Error */;
 }</pre><p>However, a number of UNIX implementations don’t conform to SUSv3 on this
                        point. If a matching <span class="emphasis"><em>passwd</em></span> record is not found, then
                        these functions return <code class="literal">NULL</code> and set
                            <span class="emphasis"><em>errno</em></span> to a nonzero value, such as <code class="literal">ENOENT</code> or <code class="literal">ESRCH</code>. Before version 2.7, <span class="emphasis"><em>glibc</em></span>
                        produced the error <code class="literal">ENOENT</code> for this case,
                        but since version 2.7, <span class="emphasis"><em>glibc</em></span> conforms to the SUSv3
                        requirements. This variation across implementations arises in part because
                        POSIX.1-1990 did not require these functions to set
                            <span class="emphasis"><em>errno</em></span> on error and allowed them to set
                            <span class="emphasis"><em>errno</em></span> for the “not found” case. The upshot of all
                        of this is that it isn’t really possible to portably distinguish the error
                        and “not found” cases when using these functions.</p></div><div class="sect3" title="Retrieving records from the group file"><div class="titlepage"><div><div><h4 class="title" id="retrieving_records_from_the_group_file">Retrieving records from the group file</h4></div></div></div><p>The <span class="emphasis"><em>getgrnam()</em></span> and <span class="emphasis"><em>getgrgid()</em></span>
                        functions retrieve records from the group file.<a id="IDX-CHP-8-1101" class="indexterm"/><a id="IDX-CHP-8-1102" class="indexterm"/><a id="IDX-CHP-8-1103" class="indexterm"/><a id="IDX-CHP-8-1104" class="indexterm"/><a id="IDX-CHP-8-1105" class="indexterm"/><a id="IDX-CHP-8-1106" class="indexterm"/><a id="IDX-CHP-8-1107" class="indexterm"/></p><a id="I_programlisting8_d1e18765"/><pre class="programlisting">#include &lt;grp.h&gt;
struct group *<strong class="userinput"><code>getgrnam</code></strong>(const char *<span class="emphasis"><em>name</em></span>);
struct group *<strong class="userinput"><code>getgrgid</code></strong>(gid_t <span class="emphasis"><em>gid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return a pointer on success, or <code class="literal">NULL</code> on error; see main text for description of the “not
                            found” case</p></div><p>The <span class="emphasis"><em>getgrnam()</em></span> function looks up group information by
                        group name, and the <span class="emphasis"><em>getgrgid()</em></span> function performs
                        lookups by group ID. Both functions return a pointer to a structure of the
                        following type:</p><a id="I_programlisting8_d1e18793"/><pre class="programlisting">struct group {
    char  *gr_name;     /* Group name */
    char  *gr_passwd;   /* Encrypted password (if not password shadowing) */
    gid_t  gr_gid;      /* Group ID */
    char **gr_mem;      /* NULL-terminated array of pointers to names
                           of members listed in /etc/group */
};</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>gr_passwd</em></span> field of the
                                <span class="emphasis"><em>group</em></span> structure is not specified in SUSv3, but
                            is available on most UNIX implementations.<a id="IDX-CHP-8-1108" class="indexterm"/></p></div><p>As with the corresponding password functions described above, this
                        structure is overwritten on each call to one of these functions.</p><p>If these functions can’t find a matching <span class="emphasis"><em>group</em></span>
                        record, then they show the same variations in behavior that we described for
                            <span class="emphasis"><em>getpwnam()</em></span> and
                        <span class="emphasis"><em>getpwuid()</em></span>.</p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id5">Example program</h4></div></div></div><p>One common use of the functions that we have already described in this
                        section is to convert symbolic user and group names into numeric IDs and
                        vice versa. <a class="xref" href="ch08.html#functions_to_convert_user_and_group_ids" title="Example 8-1. Functions to convert user and group IDs to and from user and group names">Example 8-1</a>
                        demonstrates these conversions, in the form of four functions:
                            <span class="emphasis"><em>userNameFromId()</em></span>,
                            <span class="emphasis"><em>userIdFromName()</em></span>,
                            <span class="emphasis"><em>groupNameFromId()</em></span>, and
                            <span class="emphasis"><em>groupIdFromName()</em></span>. As a convenience to the caller,
                            <span class="emphasis"><em>userIdFromName()</em></span> and
                            <span class="emphasis"><em>groupIdFromName()</em></span> also allow the
                            <span class="emphasis"><em>name</em></span> argument to be a (purely) numeric string; in
                        that case, the string is converted directly to a number and returned to the
                        caller. We employ these functions in some example programs later in this
                            book.<a id="IDX-CHP-8-1109" class="indexterm"/><a id="IDX-CHP-8-1110" class="indexterm"/><a id="IDX-CHP-8-1111" class="indexterm"/><a id="IDX-CHP-8-1112" class="indexterm"/><a id="IDX-CHP-8-1113" class="indexterm"/><a id="IDX-CHP-8-1114" class="indexterm"/><a id="IDX-CHP-8-1115" class="indexterm"/><a id="IDX-CHP-8-1116" class="indexterm"/><a id="IDX-CHP-8-1117" class="indexterm"/><a id="IDX-CHP-8-1118" class="indexterm"/><a id="IDX-CHP-8-1119" class="indexterm"/></p><div class="example"><a id="functions_to_convert_user_and_group_ids"/><div class="example-title">Example 8-1. Functions to convert user and group IDs to and from user and group
                            names</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>users_groups/ugid_functions.c</code></strong>
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;
#include &lt;ctype.h&gt;
#include "ugid_functions.h"     /* Declares functions defined here */

char *          /* Return name corresponding to 'uid', or NULL on error */
userNameFromId(uid_t uid)
{
    struct passwd *pwd;

    pwd = getpwuid(uid);
    return (pwd == NULL) ? NULL : pwd-&gt;pw_name;
}

uid_t           /* Return UID corresponding to 'name', or -1 on error */
userIdFromName(const char *name)
{
    struct passwd *pwd;
    uid_t u;
    char *endptr;

    if (name == NULL || *name == '\0')  /* On NULL or empty string */
        return -1;                      /* return an error */

    u = strtol(name, &amp;endptr, 10);      /* As a convenience to caller */
    if (*endptr == '\0')                /* allow a numeric string */
        return u;

    pwd = getpwnam(name);
    if (pwd == NULL)
        return -1;

    return pwd-&gt;pw_uid;
}

char *          /* Return name corresponding to 'gid', or NULL on error */
groupNameFromId(gid_t gid)
{
    struct group *grp;

    grp = getgrgid(gid);
    return (grp == NULL) ? NULL : grp-&gt;gr_name;
}

gid_t           /* Return GID corresponding to 'name', or -1 on error */
groupIdFromName(const char *name)
{
    struct group *grp;
    gid_t g;
    char *endptr;

    if (name == NULL || *name == '\0')  /* On NULL or empty string */
        return -1;                      /* return an error */

    g = strtol(name, &amp;endptr, 10);      /* As a convenience to caller */
    if (*endptr == '\0')                /* allow a numeric string */
        return g;

    grp = getgrnam(name);
    if (grp == NULL)
        return -1;

    return grp-&gt;gr_gid;
}
     <strong class="userinput"><code>users_groups/ugid_functions.c</code></strong></pre></div></div></div><div class="sect3" title="Scanning all records in the password and group files"><div class="titlepage"><div><div><h4 class="title" id="scanning_all_records_in_the_password_and">Scanning all records in the password and group files</h4></div></div></div><p>The <span class="emphasis"><em>setpwent()</em></span>, <span class="emphasis"><em>getpwent()</em></span>, and
                            <span class="emphasis"><em>endpwent()</em></span> functions are used to perform sequential
                        scans of the records in the password file.<a id="IDX-CHP-8-1120" class="indexterm"/><a id="IDX-CHP-8-1121" class="indexterm"/><a id="IDX-CHP-8-1122" class="indexterm"/><a id="IDX-CHP-8-1123" class="indexterm"/><a id="IDX-CHP-8-1124" class="indexterm"/><a id="IDX-CHP-8-1125" class="indexterm"/><a id="IDX-CHP-8-1126" class="indexterm"/><a id="IDX-CHP-8-1127" class="indexterm"/><a id="IDX-CHP-8-1128" class="indexterm"/></p><a id="I_programlisting8_d1e18996"/><pre class="programlisting">#include &lt;pwd.h&gt;

struct passwd *<strong class="userinput"><code>getpwent</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer on success, or <code class="literal">NULL</code>
                            on end of stream or error</p></div><a id="I_programlisting8_d1e19007"/><pre class="programlisting">void <strong class="userinput"><code>setpwent</code></strong>(void);
void <strong class="userinput"><code>endpwent</code></strong>(void);</pre><p>The <span class="emphasis"><em>getpwent()</em></span> function returns records from the
                        password file one by one, returning <code class="literal">NULL</code>
                        when there are no more records (or an error occurs). On the first call,
                            <span class="emphasis"><em>getpwent()</em></span> automatically opens the password file.
                        When we have finished with the file, we call <span class="emphasis"><em>endpwent()</em></span>
                        to close it.<a id="IDX-CHP-8-1129" class="indexterm"/></p><p>We can walk through the entire password file printing login names and user
                        IDs with the following code:</p><a id="I_programlisting8_d1e19035"/><pre class="programlisting">struct passwd *pwd;

while ((pwd = getpwent()) != NULL)
    printf("%-8s %5ld\n", pwd-&gt;pw_name, (long) pwd-&gt;pw_uid);

endpwent();</pre><p>The <span class="emphasis"><em>endpwent()</em></span> call is necessary so that any
                        subsequent <span class="emphasis"><em>getpwent()</em></span> call (perhaps in some other part
                        of our program or in some library function that we call) will reopen the
                        password file and start from the beginning. On the other hand, if we are
                        part-way through the file, we can use the <span class="emphasis"><em>setpwent()</em></span>
                        function to restart from the beginning.</p><p>The <span class="emphasis"><em>getgrent()</em></span>, <span class="emphasis"><em>setgrent()</em></span>, and
                            <span class="emphasis"><em>endgrent()</em></span> functions perform analogous tasks for
                        the group file. We omit the prototypes for these functions because they are
                        similar to those of the password file functions described above; see the
                        manual pages for details.<a id="IDX-CHP-8-1130" class="indexterm"/><a id="IDX-CHP-8-1131" class="indexterm"/><a id="IDX-CHP-8-1132" class="indexterm"/></p></div><div class="sect3" title="Retrieving records from the shadow password file"><div class="titlepage"><div><div><h4 class="title" id="retrieving_records_from_the_shadow_passw">Retrieving records from the shadow password file</h4></div></div></div><p>The following functions are used to retrieve individual records from the
                        shadow password file and to scan all records in that file.<a id="IDX-CHP-8-1133" class="indexterm"/><a id="IDX-CHP-8-1134" class="indexterm"/><a id="IDX-CHP-8-1135" class="indexterm"/><a id="IDX-CHP-8-1136" class="indexterm"/><a id="IDX-CHP-8-1137" class="indexterm"/><a id="IDX-CHP-8-1138" class="indexterm"/><a id="IDX-CHP-8-1139" class="indexterm"/><a id="IDX-CHP-8-1140" class="indexterm"/><a id="IDX-CHP-8-1141" class="indexterm"/><a id="IDX-CHP-8-1142" class="indexterm"/><a id="IDX-CHP-8-1143" class="indexterm"/><a id="IDX-CHP-8-1144" class="indexterm"/><a id="IDX-CHP-8-1145" class="indexterm"/></p><a id="I_programlisting8_d1e19152"/><pre class="programlisting">#include &lt;shadow.h&gt;

struct spwd *<strong class="userinput"><code>getspnam</code></strong>(const char *<span class="emphasis"><em>name</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer on success, or <code class="literal">NULL</code>
                            on not found or error</p></div><a id="I_programlisting8_d1e19166"/><pre class="programlisting">struct spwd *<strong class="userinput"><code>getspent</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer on success, or <code class="literal">NULL</code>
                            on end of stream or error</p></div><a id="I_programlisting8_d1e19177"/><pre class="programlisting">void <strong class="userinput"><code>setspent</code></strong>(void);
void <strong class="userinput"><code>endspent</code></strong>(void);</pre><p>We won’t describe these functions in detail, since their operation is
                        similar to the corresponding password file functions. (These functions
                        aren’t specified in SUSv3, and aren’t present on all UNIX
                        implementations.)</p><p>The <span class="emphasis"><em>getspnam()</em></span> and <span class="emphasis"><em>getspent()</em></span>
                        functions return pointers to a structure of type <span class="emphasis"><em>spwd</em></span>.
                        This structure has the following form:</p><a id="I_programlisting8_d1e19198"/><pre class="programlisting">struct spwd {
    char *sp_namp;          /* Login name (username) */
    char *sp_pwdp;          /* Encrypted password */

    /* Remaining fields support "password aging", an optional
       feature that forces users to regularly change their
       passwords, so that even if an attacker manages to obtain
       a password, it will eventually cease to be usable. */

    long sp_lstchg;         /* Time of last password change
                               (days since 1 Jan 1970) */
    long sp_min;            /* Min. number of days between password changes */
    long sp_max;            /* Max. number of days before change required */
    long sp_warn;           /* Number of days beforehand that user is
                               warned of upcoming password expiration */
    long sp_inact;          /* Number of days after expiration that account
                               is considered inactive and locked */
    long sp_expire;         /* Date when account expires
                               (days since 1 Jan 1970) */
    unsigned long sp_flag;  /* Reserved for future use */
};</pre><p>We demonstrate the use of <span class="emphasis"><em>getspnam()</em></span> in <a class="xref" href="ch08.html#authenticating_a_user_against_the_shadow" title="Example 8-2. Authenticating a user against the shadow password file">Example 8-2</a>.</p></div></div></div><div class="sect1" title="Password Encryption and User Authentication"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="password_encryption_and_user_authenticat">Password Encryption and User Authentication</h2></div></div></div><p>Some applications require that users authenticate themselves. Authentication
                typically takes the form of a username (login name) and password. An application may
                maintain its own database of usernames and passwords for this purpose. Sometimes,
                however, it is necessary or convenient to allow users to enter their standard
                username and password as defined in <code class="literal">/etc/passwd</code>
                and <code class="literal">/etc/shadow</code>. (For the remainder of this
                section, we assume a system where password shadowing is enabled, and thus that the
                encrypted password is stored in <code class="literal">/etc/shadow</code>.)
                Network applications that provide some form of login to a remote system, such as
                    <span class="emphasis"><em>ssh</em></span> and <span class="emphasis"><em>ftp</em></span>, are typical examples of
                such programs. These applications must validate a username and password in the same
                way that the standard <span class="emphasis"><em>login</em></span> program does.<a id="IDX-CHP-8-1146" class="indexterm"/><a id="IDX-CHP-8-1147" class="indexterm"/><a id="IDX-CHP-8-1148" class="indexterm"/><a id="IDX-CHP-8-1149" class="indexterm"/></p><p>For security reasons, UNIX systems encrypt passwords using a <span class="emphasis"><em>one-way
                    encryption</em></span> algorithm, which means that there is no method of
                re-creating the original password from its encrypted form. Therefore, the only way
                of validating a candidate password is to encrypt it using the same method and see if
                the encrypted result matches the value stored in <code class="literal">/etc/shadow</code>. The encryption algorithm is encapsulated in the
                    <span class="emphasis"><em>crypt()</em></span> function.<a id="IDX-CHP-8-1150" class="indexterm"/></p><a id="I_programlisting8_d1e19265"/><pre class="programlisting">#define _XOPEN_SOURCE
#include &lt;unistd.h&gt;

char *<strong class="userinput"><code>crypt</code></strong>(const char *<span class="emphasis"><em>key</em></span>, const char *<span class="emphasis"><em>salt</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to statically allocated string containing encrypted password
                    on success, or <code class="literal">NULL</code> on error</p></div><p>The <span class="emphasis"><em>crypt()</em></span> algorithm takes a <span class="emphasis"><em>key</em></span> (i.e.,
                a password) of up to 8 characters, and applies a variation of the Data Encryption
                Standard (DES) algorithm to it. The <span class="emphasis"><em>salt</em></span> argument is a
                2-character string whose value is used to perturb (vary) the algorithm, a technique
                designed to make it more difficult to crack the encrypted password. The function
                returns a pointer to a statically allocated 13-character string that is the
                encrypted password.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Details of DES can be found at <a class="ulink" href="http://www.itl.nist.gov/fipspubs/fip46-2.htm" target="_top">http://www.itl.nist.gov/fipspubs/fip46-2.htm</a>. As noted earlier,
                    other algorithms may be used instead of DES. For example, MD5 yields a
                    34-character string starting with a dollar sign (<code class="literal">$</code>), which allows <span class="emphasis"><em>crypt()</em></span> to distinguish
                    DES-encrypted passwords from MD5-encrypted passwords.</p><p>In our discussion of password encryption, we are using the word “encryption”
                    somewhat loosely. Accurately, DES uses the given password string as an
                    encryption key to encode a fixed bit string, while MD5 is a complex type of
                    hashing function. The result in both cases is the same: an undecipherable and
                    irreversible transformation of the input password.</p></div><p>Both the <span class="emphasis"><em>salt</em></span> argument and the encrypted password are
                composed of characters selected from the 64-character set <code class="literal">[a-zA-Z0-9/.]</code>. Thus, the 2-character <span class="emphasis"><em>salt</em></span>
                argument can cause the encryption algorithm to vary in any of 64 * 64 = 4096
                different ways. This means that instead of preencrypting an entire dictionary and
                checking the encrypted password against all words in the dictionary, a cracker would
                need to check the password against 4096 encrypted versions of the dictionary.</p><p>The encrypted password returned by <span class="emphasis"><em>crypt()</em></span> contains a copy of
                the original <span class="emphasis"><em>salt</em></span> value as its first two characters. This means
                that when encrypting a candidate password, we can obtain the appropriate
                    <span class="emphasis"><em>salt</em></span> value from the encrypted password value already stored
                in <code class="literal">/etc/shadow</code>. (Programs such as
                    <span class="emphasis"><em>passwd(1)</em></span> generate a random <span class="emphasis"><em>salt</em></span> value
                when encrypting a new password.) In fact, the <span class="emphasis"><em>crypt()</em></span> function
                ignores any characters in the <span class="emphasis"><em>salt</em></span> string beyond the first two.
                Therefore, we can specify the encrypted password itself as the
                    <span class="emphasis"><em>salt</em></span> argument.</p><p>In order to use <span class="emphasis"><em>crypt()</em></span> on Linux, we must compile programs
                with the <span class="emphasis"><em>-lcrypt</em></span> option, so that they are linked against the
                    <span class="emphasis"><em>crypt</em></span> library.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_program-id6"/></div></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id7">Example program</h4></div></div></div><p><a class="xref" href="ch08.html#authenticating_a_user_against_the_shadow" title="Example 8-2. Authenticating a user against the shadow password file">Example 8-2</a> demonstrates
                        how to use <span class="emphasis"><em>crypt()</em></span> to authenticate a user. This program
                        first reads a username and then retrieves the corresponding password record
                        and (if it exists) shadow password record. The program prints an error
                        message and exits if no password record is found, or if the program doesn’t
                        have permission to read from the shadow password file (this requires either
                        superuser privilege or membership of the <span class="emphasis"><em>shadow</em></span> group).
                        The program then reads the user’s password, using the
                            <span class="emphasis"><em>getpass()</em></span> function.<a id="IDX-CHP-8-1151" class="indexterm"/><a id="IDX-CHP-8-1152" class="indexterm"/><a id="IDX-CHP-8-1153" class="indexterm"/><a id="IDX-CHP-8-1154" class="indexterm"/><a id="IDX-CHP-8-1155" class="indexterm"/><a id="IDX-CHP-8-1156" class="indexterm"/><a id="IDX-CHP-8-1157" class="indexterm"/><a id="IDX-CHP-8-1158" class="indexterm"/><a id="IDX-CHP-8-1159" class="indexterm"/></p><a id="I_programlisting8_d1e19435"/><pre class="programlisting">#define _BSD_SOURCE
#include &lt;unistd.h&gt;
char *<strong class="userinput"><code>getpass</code></strong>(const char *<span class="emphasis"><em>prompt</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to statically allocated input password string on
                            success, or <code class="literal">NULL</code> on error</p></div><p>The <span class="emphasis"><em>getpass()</em></span> function first disables echoing and all
                        processing of terminal special characters (such as the
                            <span class="emphasis"><em>interrupt</em></span> character, normally
                            <span class="emphasis"><em>Control-C</em></span>). (We explain how to change these
                        terminal settings in <a class="xref" href="ch62.html" title="Chapter 62. Terminals">Chapter 62</a>.) It then prints the string
                        pointed to by <span class="emphasis"><em>prompt</em></span>, and reads a line of input,
                        returning the null-terminated input string with the trailing newline
                        stripped, as its function result. (This string is statically allocated, and
                        so will be overwritten on a subsequent call to
                            <span class="emphasis"><em>getpass()</em></span>.) Before returning,
                            <span class="emphasis"><em>getpass()</em></span> restores the terminal settings to their
                        original states.<a id="IDX-CHP-8-1160" class="indexterm"/></p><p>Having read a password with <span class="emphasis"><em>getpass()</em></span>, the program in
                            <a class="xref" href="ch08.html#authenticating_a_user_against_the_shadow" title="Example 8-2. Authenticating a user against the shadow password file">Example 8-2</a> then
                        validates that password by using <span class="emphasis"><em>crypt()</em></span> to encrypt it
                        and checking that the resulting string matches the encrypted password
                        recorded in the shadow password file. If the password matches, then the ID
                        of the user is displayed, as in the following example:</p><a id="I_programlisting8_d1e19486"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>                            <em class="lineannotation"><span class="lineannotation">Need privilege to read shadow password file</span></em>

Password:
# <strong class="userinput"><code>./check_password</code></strong>

Username: <strong class="userinput"><code>mtk</code></strong>

Password:                       <em class="lineannotation"><span class="lineannotation">We type in password, which is not echoed</span></em>

Successfully authenticated: UID=1000</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The program in <a class="xref" href="ch08.html#authenticating_a_user_against_the_shadow" title="Example 8-2. Authenticating a user against the shadow password file">Example 8-2</a> sizes the
                            character array holding a username using the value returned by
                                <span class="emphasis"><em>sysconf(_SC_LOGIN_NAME_MAX)</em></span>, which yields the
                            maximum size of a username on the host system. We explain the use of
                                <span class="emphasis"><em>sysconf()</em></span> in Section 11.2.</p></div><div class="example"><a id="authenticating_a_user_against_the_shadow"/><div class="example-title">Example 8-2. Authenticating a user against the shadow password file</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>users_groups/check_password.c</code></strong>
#define _BSD_SOURCE     /* Get getpass() declaration from &lt;unistd.h&gt; */
#define _XOPEN_SOURCE   /* Get crypt() declaration from &lt;unistd.h&gt; */
#include &lt;unistd.h&gt;
#include &lt;limits.h&gt;
#include &lt;pwd.h&gt;
#include &lt;shadow.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    char *username, *password, *encrypted, *p;
    struct passwd *pwd;
    struct spwd *spwd;
    Boolean authOk;
    size_t len;
    long lnmax;

    lnmax = sysconf(_SC_LOGIN_NAME_MAX);
    if (lnmax == -1)                    /* If limit is indeterminate */
        lnmax = 256;                    /* make a guess */

    username = malloc(lnmax);
    if (username == NULL)
        errExit("malloc");

    printf("Username: ");
    fflush(stdout);
    if (fgets(username, lnmax, stdin) == NULL)
        exit(EXIT_FAILURE);             /* Exit on EOF */

    len = strlen(username);
    if (username[len - 1] == '\n')
        username[len - 1] = '\0';       /* Remove trailing '\n' */

    pwd = getpwnam(username);
    if (pwd == NULL)
        fatal("couldn't get password record");
    spwd = getspnam(username);
    if (spwd == NULL &amp;&amp; errno == EACCES)
        fatal("no permission to read shadow password file");

    if (spwd != NULL)           /* If there is a shadow password record */
        pwd-&gt;pw_passwd = spwd-&gt;sp_pwdp;     /* Use the shadow password */

    password = getpass("Password: ");

    /* Encrypt password and erase cleartext version immediately */

    encrypted = crypt(password, pwd-&gt;pw_passwd);
    for (p = password; *p != '\0'; )
        *p++ = '\0';

    if (encrypted == NULL)
        errExit("crypt");

    authOk = strcmp(encrypted, pwd-&gt;pw_passwd) == 0;
    if (!authOk) {
        printf("Incorrect password\n");
        exit(EXIT_FAILURE);
    }

    printf("Successfully authenticated: UID=%ld\n", (long) pwd-&gt;pw_uid);

    /* Now do authenticated work... */

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>users_groups/check_password.c</code></strong></pre></div></div><p><a class="xref" href="ch08.html#authenticating_a_user_against_the_shadow" title="Example 8-2. Authenticating a user against the shadow password file">Example 8-2</a> illustrates an
                        important security point. Programs that read a password should immediately
                        encrypt that password and erase the unencrypted version from memory. This
                        minimizes the possibility of a program crash producing a core dump file that
                        could be read to discover the password.<a id="IDX-CHP-8-1161" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>There are other possible ways in which the unencrypted password could
                            be exposed. For example, the password could be read from the swap file
                            by a privileged program if the virtual memory page containing the
                            password is swapped out. Alternatively, a process with sufficient
                            privilege could read <code class="literal">/dev/mem</code> (a
                            virtual device that presents the physical memory of a computer as a
                            sequential stream of bytes) in an attempt to discover the
                            password.</p><p>The <span class="emphasis"><em>getpass()</em></span> function appeared in SUSv2, which
                            marked it LEGACY, noting that the name was misleading and the function
                            provided functionality that was in any case easy to implement. The
                            specification of <span class="emphasis"><em>getpass()</em></span> was removed in SUSv3. It
                            nevertheless appears on most UNIX implementations.<a id="IDX-CHP-8-1162" class="indexterm"/></p></div></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id7">Summary</h2></div></div></div><p>Each user has a unique login name and an associated numeric user ID. Users can
                belong to one or more groups, each of which also has a unique name and an associated
                numeric identifier. The primary purpose of these identifiers is to establish
                ownership of various system resources (e.g., files) and permissions for accessing
                    them.<a id="IDX-CHP-8-1163" class="indexterm"/></p><p>A user’s name and ID are defined in the <code class="literal">/etc/passwd</code> file, which also contains other information about the
                user. A user’s group memberships are defined by fields in the <code class="literal">/etc/passwd</code> and <code class="literal">/etc/group</code> files. A further file, <code class="literal">/etc/shadow</code>, which can be read only by privileged processes, is used
                to separate the sensitive password information from the publicly available user
                information in <code class="literal">/etc/passwd</code>. Various library
                functions are provided for retrieving information from each of these files.</p><p>The <span class="emphasis"><em>crypt()</em></span> function encrypts a password in the same manner
                as the standard <span class="emphasis"><em>login</em></span> program, which is useful for programs
                that need to authenticate users.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id5">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>When we execute the following code, we find that it displays the same
                        number twice, even though the two users have different IDs in the password
                        file. Why is this?</p><a id="I_programlisting8_d1e19589"/><pre class="programlisting">printf("%ld %ld\n", (long) (getpwnam("avr")-&gt;pw_uid),
                    (long) (getpwnam("tsr")-&gt;pw_uid));</pre></li><li class="listitem"><p>Implement <span class="emphasis"><em>getpwnam()</em></span> using
                            <span class="emphasis"><em>setpwent()</em></span>, <span class="emphasis"><em>getpwent()</em></span>, and
                            <span class="emphasis"><em>endpwent()</em></span>.</p></li></ol></div></div></section></body></html>
