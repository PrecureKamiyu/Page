<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 25. Process Termination</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch24.html" title="Chapter 24. Process Creation"/><link rel="next" href="ch26.html" title="Chapter 26. Monitoring Child Processes"/></head><body><section class="chapter" title="Chapter 25. Process Termination" epub:type="chapter" id="process_termination"><div class="titlepage"><div><div><h2 class="title">Chapter 25. Process Termination</h2></div></div></div><p>This chapter describes what happens when a process terminates. We begin by describing
            the use of <span class="emphasis"><em>exit()</em></span> and <span class="emphasis"><em>_exit()</em></span> to terminate a
            process. We then discuss the use of exit handlers to automatically perform cleanups when
            a process calls <span class="emphasis"><em>exit()</em></span>. We conclude by considering some
            interactions between <span class="emphasis"><em>fork()</em></span>, <span class="emphasis"><em>stdio</em></span> buffers,
            and <span class="emphasis"><em>exit()</em></span>.<a id="IDX-CHP-25-3837" class="indexterm"/><a id="IDX-CHP-25-3838" class="indexterm"/></p><div class="sect1" title="Terminating a Process: _exit() and exit()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="terminating_a_process_colon__underscore">Terminating a Process: <span class="emphasis"><em>_exit()</em></span> and
                    <span class="emphasis"><em>exit()</em></span></h2></div></div></div><p>A process may terminate in two general ways. One of these is
                    <span class="emphasis"><em>abnormal</em></span> termination, caused by the delivery of a signal
                whose default action is to terminate the process (with or without a core dump), as
                described in Section 20.1. Alternatively, a process can terminate
                    <span class="emphasis"><em>normally</em></span>, using the <span class="emphasis"><em>_exit()</em></span> system
                    call.<a id="IDX-CHP-25-3839" class="indexterm"/><a id="IDX-CHP-25-3840" class="indexterm"/><a id="IDX-CHP-25-3841" class="indexterm"/><a id="IDX-CHP-25-3842" class="indexterm"/><a id="IDX-CHP-25-3843" class="indexterm"/><a id="IDX-CHP-25-3844" class="indexterm"/><a id="IDX-CHP-25-3845" class="indexterm"/><a id="IDX-CHP-25-3846" class="indexterm"/><a id="IDX-CHP-25-3847" class="indexterm"/><a id="IDX-CHP-25-3848" class="indexterm"/></p><a id="I_programlisting25_d1e71451"/><pre class="programlisting">#include &lt;unistd.h&gt;

void _<strong class="userinput"><code>exit</code></strong>(int <span class="emphasis"><em>status</em></span>);</pre><p>The <span class="emphasis"><em>status</em></span> argument given to <span class="emphasis"><em>_exit()</em></span>
                defines the <span class="emphasis"><em>termination status</em></span> of the process, which is
                available to the parent of this process when it calls <span class="emphasis"><em>wait()</em></span>.
                Although defined as an <span class="emphasis"><em>int</em></span>, only the bottom 8 bits of
                    <span class="emphasis"><em>status</em></span> are actually made available to the parent. By
                convention, a termination status of 0 indicates that a process completed
                successfully, and a nonzero status value indicates that the process terminated
                unsuccessfully. There are no fixed rules about how nonzero status values are to be
                interpreted; different applications follow their own conventions, which should be
                described in their documentation. SUSv3 specifies two constants, <code class="literal">EXIT_SUCCESS</code> (0) and <code class="literal">EXIT_FAILURE</code> (1), that are used in most programs in this
                    book.<a id="IDX-CHP-25-3849" class="indexterm"/></p><p>A process is always successfully terminated by <span class="emphasis"><em>_exit()</em></span> (i.e.,
                    <span class="emphasis"><em>_exit()</em></span> never returns).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although any value in the range 0 to 255 can be passed to the parent via the
                        <span class="emphasis"><em>status</em></span> argument to <span class="emphasis"><em>_exit()</em></span>,
                    specifying values greater than 128 can cause confusion in shell scripts. The
                    reason is that, when a command is terminated by a signal, the shell indicates
                    this fact by setting the value of the variable <span class="emphasis"><em>$?</em></span> to 128
                    plus the signal number, and this value is indistinguishable from that yielded
                    when a process calls <span class="emphasis"><em>_exit()</em></span> with the same
                        <span class="emphasis"><em>status</em></span> value.</p></div><p>Programs generally don’t call <span class="emphasis"><em>_exit()</em></span> directly, but instead
                call the <span class="emphasis"><em>exit()</em></span> library function, which performs various
                actions before calling <span class="emphasis"><em>_exit()</em></span>.</p><a id="I_programlisting25_d1e71528"/><pre class="programlisting">#include &lt;stdlib.h&gt;

void <strong class="userinput"><code>exit</code></strong>(int <span class="emphasis"><em>status</em></span>);</pre><p>The following actions are performed by <span class="emphasis"><em>exit()</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Exit handlers (functions registered with <span class="emphasis"><em>atexit()</em></span> and
                            <span class="emphasis"><em>on_exit()</em></span>) are called, in reverse order of their
                        registration (<a class="xref" href="ch25.html#exit_handlers" title="Exit Handlers">Exit Handlers</a>).<a id="IDX-CHP-25-3850" class="indexterm"/><a id="IDX-CHP-25-3851" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>stdio</em></span> stream buffers are flushed.</p></li><li class="listitem"><p>The <span class="emphasis"><em>_exit()</em></span> system call is invoked, using the value
                        supplied in <span class="emphasis"><em>status</em></span>.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Unlike <span class="emphasis"><em>_exit()</em></span>, which is UNIX-specific,
                        <span class="emphasis"><em>exit()</em></span> is defined as part of the standard C library;
                    that is, it is available with every C implementation.</p></div><p>One other way in which a process may terminate is to return from
                    <span class="emphasis"><em>main()</em></span>, either explicitly, or implicitly, by falling off
                the end of the <span class="emphasis"><em>main()</em></span> function. Performing an explicit
                    <span class="emphasis"><em>return n</em></span> is generally equivalent to calling
                    <span class="emphasis"><em>exit(n)</em></span>, since the run-time function that invokes
                    <span class="emphasis"><em>main()</em></span> uses the return value from
                    <span class="emphasis"><em>main()</em></span> in a call to <span class="emphasis"><em>exit()</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>There is one circumstance in which calling <span class="emphasis"><em>exit()</em></span> and
                    returning from <span class="emphasis"><em>main()</em></span> are not equivalent. If any steps
                    performed during exit processing access variables local to
                        <span class="emphasis"><em>main()</em></span>, then doing a <code class="literal">return</code> from <span class="emphasis"><em>main()</em></span> results in undefined
                    behavior. For example, this could occur if a variable that is local to
                        <span class="emphasis"><em>main()</em></span> is specified in a call to
                        <span class="emphasis"><em>setvbuf()</em></span> or <span class="emphasis"><em>setbuf()</em></span> (<a class="xref" href="ch13.html#buffering_in_the_stdio_library" title="Buffering in the stdio Library">Buffering in the <span class="emphasis"><em>stdio</em></span> Library</a>).<a id="IDX-CHP-25-3852" class="indexterm"/><a id="IDX-CHP-25-3853" class="indexterm"/></p></div><p>Performing a return without specifying a value, or falling off the end of the
                    <span class="emphasis"><em>main()</em></span> function, also results in the caller of
                    <span class="emphasis"><em>main()</em></span> invoking <span class="emphasis"><em>exit()</em></span>, but with
                results that vary depending on the version of the C standard supported and the
                compilation options employed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In C89, the behavior in these circumstances is undefined; the program can
                        terminate with an arbitrary <span class="emphasis"><em>status</em></span> value. This is the
                        behavior that occurs by default with <span class="emphasis"><em>gcc</em></span> on Linux,
                        where the exit status of the program is taken from some random value lying
                        on the stack or in a particular CPU register. Terminating a program in this
                        way should be avoided.</p></li><li class="listitem"><p>The C99 standard requires that falling off the end of the main program
                        should be equivalent to calling <span class="emphasis"><em>exit(0)</em></span>. This is the
                        behavior we obtain on Linux if we compile a program using <span class="emphasis"><em>gcc
                            -std=c99</em></span>.</p></li></ul></div></div><div class="sect1" title="Details of Process Termination"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="details_of_process_termination">Details of Process Termination</h2></div></div></div><p>During both normal and abnormal termination of a process, the following actions
                    occur:<a id="IDX-CHP-25-3854" class="indexterm"/><a id="IDX-CHP-25-3855" class="indexterm"/><a id="IDX-CHP-25-3856" class="indexterm"/><a id="IDX-CHP-25-3857" class="indexterm"/><a id="IDX-CHP-25-3858" class="indexterm"/><a id="IDX-CHP-25-3859" class="indexterm"/><a id="IDX-CHP-25-3860" class="indexterm"/><a id="IDX-CHP-25-3861" class="indexterm"/><a id="IDX-CHP-25-3862" class="indexterm"/><a id="IDX-CHP-25-3863" class="indexterm"/><a id="IDX-CHP-25-3864" class="indexterm"/><a id="IDX-CHP-25-3865" class="indexterm"/><a id="IDX-CHP-25-3866" class="indexterm"/><a id="IDX-CHP-25-3867" class="indexterm"/><a id="IDX-CHP-25-3868" class="indexterm"/><a id="IDX-CHP-25-3869" class="indexterm"/><a id="IDX-CHP-25-3870" class="indexterm"/><a id="IDX-CHP-25-3871" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Open file descriptors, directory streams (<a class="xref" href="ch18.html#reading_directories_colon_opendir_open_p" title="Reading Directories: opendir() and readdir()">Reading Directories: <span class="emphasis"><em>opendir()</em></span> and
                    <span class="emphasis"><em>readdir()</em></span></a>), message catalog
                        descriptors (see the <span class="emphasis"><em>catopen(3)</em></span> and
                            <span class="emphasis"><em>catgets(3)</em></span> manual pages), and conversion
                        descriptors (see the <span class="emphasis"><em>iconv_open(3)</em></span> manual page) are
                        closed.</p></li><li class="listitem"><p>As a consequence of closing file descriptors, any file locks (<a class="xref" href="ch55.html" title="Chapter 55. File Locking">Chapter 55</a>) held by this process are released.</p></li><li class="listitem"><p>Any attached System V shared memory segments are detached, and the
                            <span class="emphasis"><em>shm_nattch</em></span> counter corresponding to each segment is
                        decremented by one. (Refer to Section 48.8.)</p></li><li class="listitem"><p>For each System V semaphore for which a <span class="emphasis"><em>semadj</em></span> value
                        has been set by the process, that <span class="emphasis"><em>semadj</em></span> value is added
                        to the semaphore value. (Refer to Section 47.8.)</p></li><li class="listitem"><p>If this is the controlling process for a controlling terminal, then the
                            <code class="literal">SIGHUP</code> signal is sent to each process
                        in the controlling terminal’s foreground process group, and the terminal is
                        disassociated from the session. We consider this point further in Section
                            34.6.<a id="IDX-CHP-25-3872" class="indexterm"/><a id="IDX-CHP-25-3873" class="indexterm"/></p></li><li class="listitem"><p>Any POSIX named semaphores that are open in the calling process are closed
                        as though <span class="emphasis"><em>sem_close()</em></span> were called.</p></li><li class="listitem"><p>Any POSIX message queues that are open in the calling process are closed
                        as though <span class="emphasis"><em>mq_close()</em></span> were called.</p></li><li class="listitem"><p>If, as a consequence of this process exiting, a process group becomes
                        orphaned and there are any stopped processes in that group, then all
                        processes in the group are sent a <code class="literal">SIGHUP</code>
                        signal followed by a <code class="literal">SIGCONT</code> signal. We
                        consider this point further in <a class="xref" href="ch34.html#orphaned_process_groups_open_parenthesis" title="Orphaned Process Groups (and SIGHUP Revisited)">Orphaned Process Groups (and <code class="literal">SIGHUP</code>
                    Revisited)</a>.</p></li><li class="listitem"><p>Any memory locks established by this process using
                            <span class="emphasis"><em>mlock()</em></span> or <span class="emphasis"><em>mlockall()</em></span> (<a class="xref" href="ch50.html#memory_locking_colon_mlock_open_parenthe" title="Memory Locking: mlock() and mlockall()">Memory Locking: <span class="emphasis"><em>mlock()</em></span> and
                <span class="emphasis"><em>mlockall()</em></span></a>) are
                        removed.</p></li><li class="listitem"><p>Any memory mappings established by this process using
                            <span class="emphasis"><em>mmap()</em></span> are unmapped.</p></li></ul></div></div><div class="sect1" title="Exit Handlers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exit_handlers">Exit Handlers</h2></div></div></div><p>Sometimes, an application needs to automatically perform some operations on
                process termination. Consider the example of an application library that, if used
                during the life of the process, needs to have some cleanup actions performed
                automatically when the process exits. Since the library doesn’t have control of when
                and how the process exits, and can’t mandate that the main program call a
                library-specific cleanup function before exiting, cleanup is not guaranteed to
                occur. One approach in such situations is to use an <span class="emphasis"><em>exit
                    handler</em></span> (older System V manuals used the term <span class="emphasis"><em>program
                    termination routine</em></span>).<a id="IDX-CHP-25-3874" class="indexterm"/><a id="IDX-CHP-25-3875" class="indexterm"/></p><p>An exit handler is a programmer-supplied function that is registered at some point
                during the life of the process and is then automatically called during
                    <span class="emphasis"><em>normal</em></span> process termination via <span class="emphasis"><em>exit()</em></span>.
                Exit handlers are not called if a program calls <span class="emphasis"><em>_exit()</em></span>
                directly or if the process is terminated abnormally by a signal.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To some extent, the fact that exit handlers are not called when a process is
                    terminated by a signal limits their utility. The best we can do is to establish
                    handlers for the signals that might be sent to the process, and have these
                    handlers set a flag that causes the main program to call
                        <span class="emphasis"><em>exit()</em></span>. (Because <span class="emphasis"><em>exit()</em></span> is not one
                    of the async-signal-safe functions listed in <a class="xref" href="ch21.html#functions_required_to_be_async-signal-sa" title="Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3">Table 21-1</a>, in <a class="xref" href="ch21.html#use_of_errno_inside_signal_handlers" title="Use of errno inside signal handlers">Use of <span class="emphasis"><em>errno</em></span> inside signal handlers</a>, we generally can’t call it
                    from a signal handler.) Even then, this doesn’t handle the case of <code class="literal">SIGKILL</code>, whose default action can’t be changed.
                    This is one more reason we should avoid using <code class="literal">SIGKILL</code> to terminate a process (as noted in <a class="xref" href="ch20.html#signal_types_and_default_actions" title="Signal Types and Default Actions">Signal Types and Default Actions</a>), and instead use <code class="literal">SIGTERM</code>, which is the default signal sent by the
                        <span class="emphasis"><em>kill</em></span> command.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="registering_exit_handlers"/></div></div></div><div class="sect3" title="Registering exit handlers"><div class="titlepage"><div><div><h4 class="title" id="registering_exit_handlers-id1">Registering exit handlers</h4></div></div></div><p>The GNU C library provides two ways of registering exit handlers. The
                        first method, specified in SUSv3, is to use the
                            <span class="emphasis"><em>atexit()</em></span> function.<a id="IDX-CHP-25-3876" class="indexterm"/><a id="IDX-CHP-25-3877" class="indexterm"/><a id="IDX-CHP-25-3878" class="indexterm"/><a id="IDX-CHP-25-3879" class="indexterm"/></p><a id="I_programlisting25_d1e71956"/><pre class="programlisting">#include &lt;stdlib.h&gt;

int <strong class="userinput"><code>atexit</code></strong>(void (*<span class="emphasis"><em>func</em></span>)(void));</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or nonzero on error</p></div><p>The <span class="emphasis"><em>atexit()</em></span> function adds <span class="emphasis"><em>func</em></span>
                        to a list of functions that are called when the process terminates. The
                        function <span class="emphasis"><em>func</em></span> should be defined to take no arguments
                        and return no value, thus having the following general form:</p><a id="I_programlisting25_d1e71978"/><pre class="programlisting">void
func(void)
{
    /* Perform some actions */
}</pre><p>Note that <span class="emphasis"><em>atexit()</em></span> returns a nonzero value (not
                        necessarily -1) on error.</p><p>It is possible to register multiple exit handlers (and even the same exit
                        handler multiple times). When the program invokes
                            <span class="emphasis"><em>exit()</em></span>, these functions are called <span class="emphasis"><em>in
                            reverse order</em></span> of registration. This ordering is logical
                        because, typically, functions that are registered earlier are those that
                        carry out more fundamental types of cleanups that may need to be performed
                        after later-registered functions.</p><p>Essentially, any desired action can be performed inside an exit handler,
                        including registering additional exit handlers, which are placed at the head
                        of the list of exit handlers that remain to be called. However, if one of
                        the exit handlers fails to return—either because it called
                            <span class="emphasis"><em>_exit()</em></span> or because the process was terminated by a
                        signal (e.g., the exit handler called <span class="emphasis"><em>raise()</em></span>)—then the
                        remaining exit handlers are not called. In addition, the remaining actions
                        that would normally be performed by <span class="emphasis"><em>exit()</em></span> (i.e.,
                        flushing <span class="emphasis"><em>stdio</em></span> buffers) are not performed.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 states that if an exit handler itself calls
                                <span class="emphasis"><em>exit()</em></span>, the results are undefined. On Linux,
                            the remaining exit handlers are invoked as normal. However, on some
                            systems, this causes all of the exit handlers to once more be invoked,
                            which can result in an infinite recursion (until a stack overflow kills
                            the process). Portable applications should avoid calling
                                <span class="emphasis"><em>exit()</em></span> inside an exit handler.</p></div><p>SUSv3 requires that an implementation allow a process to be able to
                        register at least 32 exit handlers. Using the call
                            <span class="emphasis"><em>sysconf(_SC_ATEXIT_MAX)</em></span>, a program can determine
                        the implementation-defined upper limit on the number of exit handlers that
                        can be registered. (However, there is no way to find out how many exit
                        handlers have already been registered.) By chaining the registered exit
                        handlers in a dynamically allocated linked list, <span class="emphasis"><em>glibc</em></span>
                        allows a virtually unlimited number of exit handlers to be registered. On
                        Linux, <span class="emphasis"><em>sysconf(_SC_ATEXIT_MAX)</em></span> returns 2,147,482,647
                        (i.e., the maximum signed 32-bit integer). In other words, something else
                        will break (e.g., lack of memory) before we reach the limit on the number of
                        functions that can be registered.</p><p>A child process created via <span class="emphasis"><em>fork()</em></span> inherits a copy of
                        its parent’s exit handler registrations. When a process performs an
                            <span class="emphasis"><em>exec()</em></span>, all exit handler registrations are removed.
                        (This is necessarily so, since an <span class="emphasis"><em>exec()</em></span> replaces the
                        code of the exit handlers along with the rest of the existing program
                        code.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We can’t deregister an exit handler that has been registered with
                                <span class="emphasis"><em>atexit()</em></span> (or <span class="emphasis"><em>on_exit()</em></span>,
                            described below). However, we can have the exit handler check whether a
                            global flag is set before it performs its actions, and disable the exit
                            handler by clearing the flag.<a id="IDX-CHP-25-3880" class="indexterm"/></p></div><p>Exit handlers registered with <span class="emphasis"><em>atexit()</em></span> suffer a
                        couple of limitations. The first is that when called, an exit handler
                        doesn’t know what status was passed to <span class="emphasis"><em>exit()</em></span>.
                        Occasionally, knowing the status could be useful; for example, we may like
                        to perform different actions depending on whether the process is exiting
                        successfully or unsuccessfully. The second limitation is that we can’t
                        specify an argument to the exit handler when it is called. Such a facility
                        could be useful to define an exit handler that performs different actions
                        depending on its argument, or to register a function multiple times, each
                        time with a different argument.</p><p>To address these limitations, <span class="emphasis"><em>glibc</em></span> provides a
                        (nonstandard) alternative method of registering exit handlers:
                            <span class="emphasis"><em>on_exit()</em></span>.</p><a id="I_programlisting25_d1e72068"/><pre class="programlisting">#define _BSD_SOURCE           /* Or: #define _SVID_SOURCE */
#include &lt;stdlib.h&gt;

int <strong class="userinput"><code>on_exit</code></strong>(void (*<span class="emphasis"><em>func</em></span>)(int, void *), void *<span class="emphasis"><em>arg</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or nonzero on error</p></div><p>The <span class="emphasis"><em>func</em></span> argument of <span class="emphasis"><em>on_exit()</em></span>
                        is a pointer to a function of the following type:</p><a id="I_programlisting25_d1e72090"/><pre class="programlisting">void
func(int status, void *arg)
{
    /* Perform cleanup actions */
}</pre><p>When called, <span class="emphasis"><em>func()</em></span> is passed two arguments: the
                            <span class="emphasis"><em>status</em></span> argument supplied to
                            <span class="emphasis"><em>exit()</em></span>, and a copy of the <span class="emphasis"><em>arg</em></span>
                        argument supplied to <span class="emphasis"><em>on_exit()</em></span> at the time the function
                        was registered. Although defined as a pointer type, <span class="emphasis"><em>arg</em></span>
                        is open to programmer-defined interpretation. It could be used as a pointer
                        to some structure; equally, through judicious use of casting, it could be
                        treated as an integer or other scalar type.</p><p>Like <span class="emphasis"><em>atexit()</em></span>, <span class="emphasis"><em>on_exit()</em></span> returns
                        a nonzero value (not necessarily -1) on error.</p><p>As with <span class="emphasis"><em>atexit()</em></span>, multiple exit handlers can be
                        registered with <span class="emphasis"><em>on_exit()</em></span>. Functions registered using
                            <span class="emphasis"><em>atexit()</em></span> and <span class="emphasis"><em>on_exit()</em></span> are
                        placed on the same list. If both methods are used in the same program, then
                        the exit handlers are called in reverse order of their registration using
                        the two methods.</p><p>Although more flexible than <span class="emphasis"><em>atexit()</em></span>,
                            <span class="emphasis"><em>on_exit()</em></span> should be avoided in programs intended to
                        be portable, since it is not covered by any standards and is available on
                        few other UNIX implementations.</p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id30">Example program</h4></div></div></div><p><a class="xref" href="ch25.html#using_exit_handlers" title="Example 25-1. Using exit handlers">Example 25-1</a> demonstrates the use of
                            <span class="emphasis"><em>atexit()</em></span> and <span class="emphasis"><em>on_exit()</em></span> to
                        register exit handlers. When we run this program, we see the following
                            output:<a id="IDX-CHP-25-3881" class="indexterm"/></p><a id="I_programlisting25_d1e72160"/><pre class="programlisting">$ <strong class="userinput"><code>./exit_handlers</code></strong>
on_exit function called: status=2, arg=20
atexit function 2 called
atexit function 1 called
on_exit function called: status=2, arg=10</pre><div class="example"><a id="using_exit_handlers"/><div class="example-title">Example 25-1. Using exit handlers</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procexec/exit_handlers.c</code></strong>
#define _BSD_SOURCE     /* Get on_exit() declaration from &lt;stdlib.h&gt; */
#include &lt;stdlib.h&gt;
#include "tlpi_hdr.h"

static void
atexitFunc1(void)
{
    printf("atexit function 1 called\n");
}

static void
atexitFunc2(void)
{
    printf("atexit function 2 called\n");
}

static void
onexitFunc(int exitStatus, void *arg)
{
    printf("on_exit function called: status=%d, arg=%ld\n",
                exitStatus, (long) arg);
}

int
main(int argc, char *argv[])
{
    if (on_exit(onexitFunc, (void *) 10) != 0)
        fatal("on_exit 1");
    if (atexit(atexitFunc1) != 0)
        fatal("atexit 1");
    if (atexit(atexitFunc2) != 0)
        fatal("atexit 2");
    if (on_exit(onexitFunc, (void *) 20) != 0)
        fatal("on_exit 2");

    exit(2);
}
      <strong class="userinput"><code>procexec/exit_handlers.c</code></strong></pre></div></div></div></div></div><div class="sect1" title="Interactions Between fork(), stdio Buffers, and _exit()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="interactions_between_fork_open_parenthes">Interactions Between <span class="emphasis"><em>fork()</em></span>, <span class="emphasis"><em>stdio</em></span>
                Buffers, and <span class="emphasis"><em>_exit()</em></span></h2></div></div></div><p>The output yielded by the program in <a class="xref" href="ch25.html#interaction_of_fork_open_parenthesis_clo" title="Example 25-2. Interaction of fork() and stdio buffering">Example 25-2</a> demonstrates a phenomenon
                that is at first puzzling. When we run this program with standard output directed to
                the terminal, we see the expected result:<a id="IDX-CHP-25-3882" class="indexterm"/><a id="IDX-CHP-25-3883" class="indexterm"/><a id="IDX-CHP-25-3884" class="indexterm"/><a id="IDX-CHP-25-3885" class="indexterm"/><a id="IDX-CHP-25-3886" class="indexterm"/></p><a id="I_programlisting25_d1e72222"/><pre class="programlisting">$ <strong class="userinput"><code>./fork_stdio_buf</code></strong>
Hello world
Ciao</pre><p>However, when we redirect standard output to a file, we see the following:</p><a id="I_programlisting25_d1e72229"/><pre class="programlisting">$ <strong class="userinput"><code>./fork_stdio_buf &gt; a</code></strong>
$ <strong class="userinput"><code>cat a</code></strong>
Ciao
Hello world
Hello world</pre><p>In the above output, we see two strange things: the line written by
                    <span class="emphasis"><em>printf()</em></span> appears twice, and the output of
                    <span class="emphasis"><em>write()</em></span> precedes that of
                <span class="emphasis"><em>printf()</em></span>.</p><div class="example"><a id="interaction_of_fork_open_parenthesis_clo"/><div class="example-title">Example 25-2. Interaction of <span class="emphasis"><em>fork()</em></span> and <span class="emphasis"><em>stdio</em></span>
                    buffering</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procexec/fork_stdio_buf.c</code></strong>
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    printf("Hello world\n");
    write(STDOUT_FILENO, "Ciao\n", 5);

    if (fork() == -1)
        errExit("fork");

    /* Both child and parent continue execution here */

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>procexec/fork_stdio_buf.c</code></strong></pre></div></div><p>To understand why the message written with <span class="emphasis"><em>printf()</em></span> appears
                twice, recall that the <span class="emphasis"><em>stdio</em></span> buffers are maintained in a
                process’s user-space memory (refer to <a class="xref" href="ch13.html#buffering_in_the_stdio_library" title="Buffering in the stdio Library">Buffering in the <span class="emphasis"><em>stdio</em></span> Library</a>). Therefore, these buffers are duplicated in the child by
                    <span class="emphasis"><em>fork()</em></span>. When standard output is directed to a terminal, it
                is line-buffered by default, with the result that the newline-terminated string
                written by <span class="emphasis"><em>printf()</em></span> appears immediately. However, when standard
                output is directed to a file, it is block-buffered by default. Thus, in our example,
                the string written by <span class="emphasis"><em>printf()</em></span> is still in the parent’s
                    <span class="emphasis"><em>stdio</em></span> buffer at the time of the
                <span class="emphasis"><em>fork()</em></span>, and this string is duplicated in the child. When the
                parent and the child later call <span class="emphasis"><em>exit()</em></span>, they both flush their
                copies of the <span class="emphasis"><em>stdio</em></span> buffers, resulting in duplicate
                    output.<a id="IDX-CHP-25-3887" class="indexterm"/></p><p>We can prevent this duplicated output from occurring in one of the following
                ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>As a specific solution to the <span class="emphasis"><em>stdio</em></span> buffering issue,
                        we can use <span class="emphasis"><em>fflush()</em></span> to flush the
                            <span class="emphasis"><em>stdio</em></span> buffer prior to a <span class="emphasis"><em>fork()</em></span>
                        call. Alternatively, we could use <span class="emphasis"><em>setvbuf()</em></span> or
                            <span class="emphasis"><em>setbuf()</em></span> to disable buffering on the
                            <span class="emphasis"><em>stdio</em></span> stream.<a id="IDX-CHP-25-3888" class="indexterm"/></p></li><li class="listitem"><p>Instead of calling <span class="emphasis"><em>exit()</em></span>, the child can call
                            <span class="emphasis"><em>_exit()</em></span>, so that it doesn’t flush
                            <span class="emphasis"><em>stdio</em></span> buffers. This technique exemplifies a more
                        general principle: in an application that creates child processes that don’t
                        exec new programs, typically only one of the processes (most often the
                        parent) should terminate via <span class="emphasis"><em>exit()</em></span>, while the other
                        processes should terminate via <span class="emphasis"><em>_exit()</em></span>. This ensures
                        that only one process calls exit handlers and flushes
                            <span class="emphasis"><em>stdio</em></span> buffers, which is usually desirable.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Other approaches that allow both the parent and child to call
                        <span class="emphasis"><em>exit()</em></span> are possible (and sometimes necessary). For
                    example, it may be possible to design exit handlers so that they operate
                    correctly even if called from multiple processes, or to have the application
                    install exit handlers only after the call to <span class="emphasis"><em>fork()</em></span>.
                    Furthermore, sometimes we may actually want all processes to flush their
                        <span class="emphasis"><em>stdio</em></span> buffers after a <span class="emphasis"><em>fork()</em></span>. In
                    this case, we may choose to terminate the processes using
                        <span class="emphasis"><em>exit()</em></span>, or use explicit calls to
                        <span class="emphasis"><em>fflush()</em></span> in each process, as appropriate.</p></div><p>The output of the <span class="emphasis"><em>write()</em></span> in the program in <a class="xref" href="ch25.html#interaction_of_fork_open_parenthesis_clo" title="Example 25-2. Interaction of fork() and stdio buffering">Example 25-2</a> doesn’t appear twice,
                because <span class="emphasis"><em>write()</em></span> transfers data directly to a kernel buffer, and
                this buffer is not duplicated during a <span class="emphasis"><em>fork()</em></span>.</p><p>By now, the reason for the second strange aspect of the program’s output when
                redirected to a file should be clear. The output of <span class="emphasis"><em>write()</em></span>
                appears before that from <span class="emphasis"><em>printf()</em></span> because the output of
                    <span class="emphasis"><em>write()</em></span> is immediately transferred to the kernel buffer
                cache, while the output from <span class="emphasis"><em>printf()</em></span> is transferred only when
                the <span class="emphasis"><em>stdio</em></span> buffers are flushed by the call to
                    <span class="emphasis"><em>exit()</em></span>. (In general, care is required when mixing
                    <span class="emphasis"><em>stdio</em></span> functions and system calls to perform I/O on the same
                file, as described in Section 13.7.)</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id24">Summary</h2></div></div></div><p>A process can terminate either abnormally or normally. Abnormal termination occurs
                on delivery of certain signals, some of which also cause the process to produce a
                core dump file.</p><p>Normal termination is accomplished by calling <span class="emphasis"><em>_exit()</em></span> or,
                more usually, <span class="emphasis"><em>exit()</em></span>, which is layered on top of
                    <span class="emphasis"><em>_exit()</em></span>. Both <span class="emphasis"><em>_exit()</em></span> and
                    <span class="emphasis"><em>exit()</em></span> take an integer argument whose least significant 8
                bits define the termination status of the process. By convention, a status of 0 is
                used to indicate successful termination, and a nonzero status indicates unsuccessful
                termination.</p><p>As part of both normal and abnormal process termination, the kernel performs
                various cleanup steps. Terminating a process normally by calling
                    <span class="emphasis"><em>exit()</em></span> additionally causes exit handlers registered using
                    <span class="emphasis"><em>atexit()</em></span> and <span class="emphasis"><em>on_exit()</em></span> to be called
                (in reverse order of registration), and causes <span class="emphasis"><em>stdio</em></span> buffers to
                be flushed.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id27"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id28">Further information</h4></div></div></div><p>Refer to the sources of further information listed in Section 24.6.</p></div></div></div><div class="sect1" title="Exercise"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercise-id8">Exercise</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>If a child process makes the call exit(-1), what exit status (as returned
                        by <code class="literal">WEXITSTATUS()</code>) will be seen by the
                        parent?</p></li></ol></div></div></section></body></html>
