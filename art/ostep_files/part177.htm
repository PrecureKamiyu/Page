<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Buddy Allocation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part176.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part178.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">Buddy Allocation</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Because coalescing is critical for an allocator, some approaches have been designed around making coalescing simple. One good example is found in the <b>binary buddy allocator </b>[K65].</p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">In such a system, free memory is first conceptually thought of as one</p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="13" alt="image" src="Image_213.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="13" alt="image" src="Image_214.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="13" alt="image" src="Image_215.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="13" alt="image" src="Image_216.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="13" alt="image" src="Image_217.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="13" alt="image" src="Image_218.png"/></span></p><p class="s65" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">8 KB</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">8 KB</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">16 KB</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">16 KB</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: center;">32 KB</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-left: 24pt;text-indent: 0pt;text-align: center;">32 KB</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">big space of size <span class="s44">2</span><span class="s100">N</span><span class="s43"> </span>. When a request for memory is made, the search for free space recursively divides free space by two until a block that is big enough to accommodate the request is found (and a further split into two would result in a space that is too small). At this point, the requested block is returned to the user. Here is an example of a 64KB free space getting divided in the search for a 7KB block:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-top: 4pt;padding-left: 58pt;text-indent: 0pt;text-align: center;">64 KB</p><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In the example, the leftmost 8KB block is allocated (as indicated by the darker shade of gray) and returned to the user; note that this scheme can suffer from <b>internal fragmentation</b>, as you are only allowed to give out power-of-two-sized blocks.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The beauty of buddy allocation is found in what happens when that block is freed. When returning the 8KB block to the free list, the allocator checks whether the “buddy” 8KB is free; if so, it coalesces the two blocks into a 16KB block. The allocator then checks if the buddy of the 16KB block is still free; if so, it coalesces those two blocks. This recursive coa- lescing process continues up the tree, either restoring the entire free space or stopping when a buddy is found to be in use.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The reason buddy allocation works so well is that it is simple to de- termine the buddy of a particular block. How, you ask? Think about the addresses of the blocks in the free space above. If you think carefully enough, you’ll see that the address of each buddy pair only differs by a single bit; which bit is determined by the level in the buddy tree. And thus you have a basic idea of how binary buddy allocation schemes work. For more detail, as always, see the Wilson survey [W+95].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part176.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part178.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
