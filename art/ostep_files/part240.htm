<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Cache Size (Blocks)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part239.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part241.htm">下一个 &gt;</a></p><p class="s76" style="padding-left: 41pt;text-indent: 0pt;text-align: center;">Cache Size (Blocks)</p><p style="padding-top: 2pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">Figure 22.5: <b>The 80-20 Workload With Clock</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The behavior of a clock algorithm variant is shown in Figure <span style=" color: #00AEEF;">22.5</span>. This variant randomly scans pages when doing a replacement; when it en- counters a page with a reference bit set to 1, it clears the bit (i.e., sets it to 0); when it finds a page with the reference bit set to 0, it chooses it as its victim. As you can see, although it doesn’t do quite as well as perfect LRU, it does better than approaches that don’t consider history at all.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part239.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part241.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
