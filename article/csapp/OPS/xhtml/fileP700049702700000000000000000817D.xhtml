<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>12.3 Concurrent Programming with Threads</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P700049702700000000000000000817D" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000046C62" data-uri="chapter12.xhtml#P7000497027000000000000000046C62" epub:type="title"><span class="pcalibre label pcalibre1">12.3 </span>Concurrent Programming with Threads</h1></header>
<p id="P7000497027000000000000000046C63" data-uri="chapter12.xhtml#P7000497027000000000000000046C63" class="pcalibre1 pcalibre calibre2">To this point, we have looked at two approaches for creating concurrent logical flows. With the first approach, we use a separate process for each flow. The kernel schedules each process automatically, and each process has its own private address space, which makes it difficult for flows to share data. With the second approach, we create our own logical flows and use I/O multiplexing to explicitly schedule the flows. Because there is only one process, flows share the entire address space. <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008180" title="986" data-uri="chapter12.xhtml#P7000497027000000000000000008180" epub:type="pagebreak"></span>This section introduces a third approach—based on threads—that is a hybrid of these two.</p>
<p id="P7000497027000000000000000046C64" data-uri="chapter12.xhtml#P7000497027000000000000000046C64" class="pcalibre1 pcalibre calibre2">A <i class="calibre5 pcalibre pcalibre1">thread</i> is a logical flow that runs in the context of a process. Thus far in this book, our programs have consisted of a single thread per process. But modern systems also allow us to write programs that have multiple threads running concurrently in a single process. The threads are scheduled automatically by the kernel. Each thread has its own <i class="calibre5 pcalibre pcalibre1">thread context</i>, including a unique integer <i class="calibre5 pcalibre pcalibre1">thread ID (TID)</i>, stack, stack pointer, program counter, general-purpose registers, and condition codes. All threads running in a process share the entire virtual address space of that process.</p>
<p id="P7000497027000000000000000046C65" data-uri="chapter12.xhtml#P7000497027000000000000000046C65" class="pcalibre1 pcalibre calibre2">Logical flows based on threads combine qualities of flows based on processes and I/O multiplexing. Like processes, threads are scheduled automatically by the kernel and are known to the kernel by an integer ID. Like flows based on I/O multiplexing, multiple threads run in the context of a single process, and thus they share the entire contents of the process virtual address space, including its code, data, heap, shared libraries, and open files.</p>
<section id="P7000497027000000000000000008183" data-uri="chapter12.xhtml#P7000497027000000000000000008183" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046C66" data-uri="chapter12.xhtml#P7000497027000000000000000046C66" epub:type="title"><span class="pcalibre label pcalibre1">12.3.1 </span>Thread Execution Model</h1></header>
<p id="P7000497027000000000000000046C67" data-uri="chapter12.xhtml#P7000497027000000000000000046C67" class="pcalibre1 pcalibre calibre2">The execution model for multiple threads is similar in some ways to the execution model for multiple processes. Consider the example in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008189"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.12</span></a>. Each process begins life as a single thread called the <i class="calibre5 pcalibre pcalibre1">main thread</i>. At some point, the main thread creates a <i class="calibre5 pcalibre pcalibre1">peer thread</i>, and from this point in time the two threads run concurrently. Eventually, control passes to the peer thread via a context switch, either because the main thread executes a slow system call such as <code id="P7000497027000000000000000046C68" data-uri="chapter12.xhtml#P7000497027000000000000000046C68" class="pcalibre1 calibre8 pcalibre">read</code> or <code id="P7000497027000000000000000046C69" data-uri="chapter12.xhtml#P7000497027000000000000000046C69" class="pcalibre1 calibre8 pcalibre">sleep</code> or because it is interrupted by the system's interval timer. The peer thread executes for a while before control passes back to the main thread, and so on.</p>
<p id="P7000497027000000000000000046C6A" data-uri="chapter12.xhtml#P7000497027000000000000000046C6A" class="pcalibre1 pcalibre calibre2">Thread execution differs from processes in some important ways. Because a thread context is much smaller than a process context, a thread context switch is faster than a process context switch. Another difference is that threads, unlike processes, are not organized in a rigid parent-child hierarchy. The threads associated</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008189" data-uri="chapter12.xhtml#P7000497027000000000000000008189">
<img alt="A diagram of concurrent thread execution shows a progression over time from thread 1 (main thread) to thread 2 (peer thread) within the thread context switch, and proceeding in this pattern." id="P7000497027000000000000000046C6B" data-uri="P700049702700000000000000000B7D0" src="../images/p986-1.png" class="calibre335 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000046C6C" data-uri="chapter12.xhtml#P7000497027000000000000000046C6C" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046C6D" data-uri="chapter12.xhtml#P7000497027000000000000000046C6D" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.12 </span>Concurrent thread execution.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046C6E" data-uri="chapter12.xhtml#P7000497027000000000000000046C6E"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000818E" title="987" data-uri="chapter12.xhtml#P700049702700000000000000000818E" epub:type="pagebreak"></span>with a process form a <i class="calibre5 pcalibre pcalibre1">pool</i> of peers, independent of which threads were created by which other threads. The main thread is distinguished from other threads only in the sense that it is always the first thread to run in the process. The main impact of this notion of a pool of peers is that a thread can kill any of its peers or wait for any of its peers to terminate. Further, each peer can read and write the same shared data.</p>
</section>
<section id="P700049702700000000000000000818F" data-uri="chapter12.xhtml#P700049702700000000000000000818F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046C6F" data-uri="chapter12.xhtml#P7000497027000000000000000046C6F" epub:type="title"><span class="pcalibre label pcalibre1">12.3.2 </span>Posix Threads</h1></header>
<p id="P7000497027000000000000000046C70" data-uri="chapter12.xhtml#P7000497027000000000000000046C70" class="pcalibre1 pcalibre calibre2">Posix threads (Pthreads) is a standard interface for manipulating threads from C programs. It was adopted in 1995 and is available on all Linux systems. Pthreads defines about 60 functions that allow programs to create, kill, and reap threads, to share data safely with peer threads, and to notify peers about changes in the system state.</p>
<p id="P7000497027000000000000000046C71" data-uri="chapter12.xhtml#P7000497027000000000000000046C71" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008195"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.13</span></a> shows a simple Pthreads program. The main thread creates a peer thread and then waits for it to terminate. The peer thread prints <code id="P7000497027000000000000000046C72" data-uri="chapter12.xhtml#P7000497027000000000000000046C72" class="pcalibre1 calibre8 pcalibre">Hello, world!\n</code> and terminates. When the main thread detects that the peer thread has terminated, it terminates the process by calling <code id="P7000497027000000000000000046C73" data-uri="chapter12.xhtml#P7000497027000000000000000046C73" class="pcalibre1 calibre8 pcalibre">exit</code>. This is the first threaded program we have seen, so let us dissect it carefully. The code and local data for a thread are encapsulated in a <i class="calibre5 pcalibre pcalibre1">thread routine</i>. As shown by the prototype in line 2, each thread routine takes as input a single generic pointer and returns a generic pointer. If you want to pass multiple arguments to a thread routine, then you should put the arguments into a structure and pass a pointer to the structure. Similarly, if you</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008195" data-uri="chapter12.xhtml#P7000497027000000000000000008195">
<p id="P7000497027000000000000000046C74" data-uri="chapter12.xhtml#P7000497027000000000000000046C74" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/hello.c</i></p>
<pre id="P7000497027000000000000000046C75" data-uri="chapter12.xhtml#P7000497027000000000000000046C75" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046C76" data-uri="chapter12.xhtml#P7000497027000000000000000046C76" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	void *thread(void *vargp);
3	
4	int main()
5	{
6		pthread_t tid;
7		Pthread_create(&amp;tid, NULL, thread, NULL);
8		Pthread_join(tid, NULL);
9		exit(0);
10	}
11	
12	void *thread(void *vargp) /* Thread routine */
13	{
14		printf("Hello, world!\n");
15		return NULL;
16	}
</code></pre>
<p id="P7000497027000000000000000046C77" data-uri="chapter12.xhtml#P7000497027000000000000000046C77" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/hello.c</i></p>
<figcaption id="P7000497027000000000000000046C78" data-uri="chapter12.xhtml#P7000497027000000000000000046C78" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046C79" data-uri="chapter12.xhtml#P7000497027000000000000000046C79" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">12.13 </span><code id="P7000497027000000000000000046C7A" data-uri="chapter12.xhtml#P7000497027000000000000000046C7A" class="pcalibre1 calibre8 pcalibre">hello.c</code>: The Pthreads "Hello, world!" program.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046C7B" data-uri="chapter12.xhtml#P7000497027000000000000000046C7B"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000819E" title="988" data-uri="chapter12.xhtml#P700049702700000000000000000819E" epub:type="pagebreak"></span>want the thread routine to return multiple arguments, you can return a pointer to a structure.</p>
<p id="P7000497027000000000000000046C7C" data-uri="chapter12.xhtml#P7000497027000000000000000046C7C" class="pcalibre1 pcalibre calibre2">Line 4 marks the beginning of the code for the main thread. The main thread declares a single local variable <code id="P7000497027000000000000000046C7D" data-uri="chapter12.xhtml#P7000497027000000000000000046C7D" class="pcalibre1 calibre8 pcalibre">tid</code>, which will be used to store the thread ID of the peer thread (line 6). The main thread creates a new peer thread by calling the <code id="P7000497027000000000000000046C7E" data-uri="chapter12.xhtml#P7000497027000000000000000046C7E" class="pcalibre1 calibre8 pcalibre">pthread_create</code> function (line 7). When the call to <code id="P7000497027000000000000000046C7F" data-uri="chapter12.xhtml#P7000497027000000000000000046C7F" class="pcalibre1 calibre8 pcalibre">pthread_create</code> returns, the main thread and the newly created peer thread are running concurrently, and <code id="P7000497027000000000000000046C80" data-uri="chapter12.xhtml#P7000497027000000000000000046C80" class="pcalibre1 calibre8 pcalibre">tid</code> contains the ID of the new thread. The main thread waits for the peer thread to terminate with the call to <code id="P7000497027000000000000000046C81" data-uri="chapter12.xhtml#P7000497027000000000000000046C81" class="pcalibre1 calibre8 pcalibre">pthread_join</code> in line 8. Finally, the main thread calls <code id="P7000497027000000000000000046C82" data-uri="chapter12.xhtml#P7000497027000000000000000046C82" class="pcalibre1 calibre8 pcalibre">exit</code> (line 9), which terminates all threads (in this case, just the main thread) currently running in the process.</p>
<p id="P7000497027000000000000000046C83" data-uri="chapter12.xhtml#P7000497027000000000000000046C83" class="pcalibre1 pcalibre calibre2">Lines 12−16 define the thread routine for the peer thread. It simply prints a string and then terminates the peer thread by executing the <code id="P7000497027000000000000000046C84" data-uri="chapter12.xhtml#P7000497027000000000000000046C84" class="pcalibre1 calibre8 pcalibre">return</code> statement in line 15.</p>
</section>
<section id="P70004970270000000000000000081A8" data-uri="chapter12.xhtml#P70004970270000000000000000081A8" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046C85" data-uri="chapter12.xhtml#P7000497027000000000000000046C85" epub:type="title"><span class="pcalibre label pcalibre1">12.3.3 </span>Creating Threads</h1></header>
<p id="P7000497027000000000000000046C86" data-uri="chapter12.xhtml#P7000497027000000000000000046C86" class="pcalibre1 pcalibre calibre2">Threads create other threads by calling the <code id="P7000497027000000000000000046C87" data-uri="chapter12.xhtml#P7000497027000000000000000046C87" class="pcalibre1 calibre8 pcalibre">pthread_create</code> function.</p>
<pre id="P7000497027000000000000000046C88" data-uri="chapter12.xhtml#P7000497027000000000000000046C88" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046C89" data-uri="chapter12.xhtml#P7000497027000000000000000046C89" class="calibre10 pcalibre pcalibre1">
#include &lt;pthread.h&gt;
typedef void *(func)(void *);
int pthread_create(pthread_t *tid, pthread_attr_t *attr,
		   func *f, void *arg);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046C8A" data-uri="chapter12.xhtml#P7000497027000000000000000046C8A">The <code id="P7000497027000000000000000046C8B" data-uri="chapter12.xhtml#P7000497027000000000000000046C8B" class="pcalibre1 calibre8 pcalibre">pthread_create</code> function creates a new thread and runs the <i class="calibre5 pcalibre pcalibre1">thread routine</i> <code id="P7000497027000000000000000046C8C" data-uri="chapter12.xhtml#P7000497027000000000000000046C8C" class="pcalibre1 calibre8 pcalibre">f</code> in the context of the new thread and with an input argument of <code id="P7000497027000000000000000046C8D" data-uri="chapter12.xhtml#P7000497027000000000000000046C8D" class="pcalibre1 calibre8 pcalibre">arg</code>. The <code id="P7000497027000000000000000046C8E" data-uri="chapter12.xhtml#P7000497027000000000000000046C8E" class="pcalibre1 calibre8 pcalibre">attr</code> argument can be used to change the default attributes of the newly created thread. Changing these attributes is beyond our scope, and in our examples, we will always call <code id="P7000497027000000000000000046C8F" data-uri="chapter12.xhtml#P7000497027000000000000000046C8F" class="pcalibre1 calibre8 pcalibre">pthread_create</code> with a NULL <code id="P7000497027000000000000000046C90" data-uri="chapter12.xhtml#P7000497027000000000000000046C90" class="pcalibre1 calibre8 pcalibre">attr</code> argument.</p>
<p id="P7000497027000000000000000046C91" data-uri="chapter12.xhtml#P7000497027000000000000000046C91" class="pcalibre1 pcalibre calibre2">When <code id="P7000497027000000000000000046C92" data-uri="chapter12.xhtml#P7000497027000000000000000046C92" class="pcalibre1 calibre8 pcalibre">pthread_create</code> returns, argument <code id="P7000497027000000000000000046C93" data-uri="chapter12.xhtml#P7000497027000000000000000046C93" class="pcalibre1 calibre8 pcalibre">tid</code> contains the ID of the newly created thread. The new thread can determine its own thread ID by calling the <code id="P7000497027000000000000000046C94" data-uri="chapter12.xhtml#P7000497027000000000000000046C94" class="pcalibre1 calibre8 pcalibre">pthread_self</code> function.</p>
<pre id="P7000497027000000000000000046C95" data-uri="chapter12.xhtml#P7000497027000000000000000046C95" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046C96" data-uri="chapter12.xhtml#P7000497027000000000000000046C96" class="calibre10 pcalibre pcalibre1">
#include &lt;pthread.h&gt;
pthread_t pthread_self(void);
						Returns: thread ID of caller
</code></pre>
</section>
<section id="P70004970270000000000000000081BB" data-uri="chapter12.xhtml#P70004970270000000000000000081BB" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046C97" data-uri="chapter12.xhtml#P7000497027000000000000000046C97" epub:type="title"><span class="pcalibre label pcalibre1">12.3.4 </span>Terminating Threads</h1></header>
<p id="P7000497027000000000000000046C98" data-uri="chapter12.xhtml#P7000497027000000000000000046C98" class="pcalibre1 pcalibre calibre2">A thread terminates in one of the following ways:</p>
<ul id="P7000497027000000000000000046C99" data-uri="chapter12.xhtml#P7000497027000000000000000046C99" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000046C9A" data-uri="chapter12.xhtml#P7000497027000000000000000046C9A" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046C9B" data-uri="chapter12.xhtml#P7000497027000000000000000046C9B" class="pcalibre calibre3 pcalibre1">The thread terminates <i class="calibre5 pcalibre pcalibre1">implicitly</i> when its top-level thread routine returns.</p></li>
<li id="P7000497027000000000000000046C9C" data-uri="chapter12.xhtml#P7000497027000000000000000046C9C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046C9D" data-uri="chapter12.xhtml#P7000497027000000000000000046C9D" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000081C3" title="989" data-uri="chapter12.xhtml#P70004970270000000000000000081C3" epub:type="pagebreak"></span>The thread terminates <i class="calibre5 pcalibre pcalibre1">explicitly</i> by calling the <code id="P7000497027000000000000000046C9E" data-uri="chapter12.xhtml#P7000497027000000000000000046C9E" class="pcalibre1 calibre8 pcalibre">pthread_exit</code> function. If the main thread calls <code id="P7000497027000000000000000046C9F" data-uri="chapter12.xhtml#P7000497027000000000000000046C9F" class="pcalibre1 calibre8 pcalibre">pthread_exit</code>, it waits for all other peer threads to terminate and then terminates the main thread and the entire process with a return value of <code id="P7000497027000000000000000046CA0" data-uri="chapter12.xhtml#P7000497027000000000000000046CA0" class="pcalibre1 calibre8 pcalibre">thread_return</code>.</p>
<pre id="P7000497027000000000000000046CA1" data-uri="chapter12.xhtml#P7000497027000000000000000046CA1" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046CA2" data-uri="chapter12.xhtml#P7000497027000000000000000046CA2" class="calibre10 pcalibre pcalibre1">
#include &lt;pthread.h&gt;
void pthread_exit(void *thread_return);
						Never returns
</code></pre></li>
<li id="P7000497027000000000000000046CA3" data-uri="chapter12.xhtml#P7000497027000000000000000046CA3" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046CA4" data-uri="chapter12.xhtml#P7000497027000000000000000046CA4" class="pcalibre calibre3 pcalibre1">Some peer thread calls the Linux <code id="P7000497027000000000000000046CA5" data-uri="chapter12.xhtml#P7000497027000000000000000046CA5" class="pcalibre1 calibre8 pcalibre">exit</code> function, which terminates the process and all threads associated with the process.</p></li>
<li id="P7000497027000000000000000046CA6" data-uri="chapter12.xhtml#P7000497027000000000000000046CA6" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046CA7" data-uri="chapter12.xhtml#P7000497027000000000000000046CA7" class="pcalibre calibre3 pcalibre1">Another peer thread terminates the current thread by calling the <code id="P7000497027000000000000000046CA8" data-uri="chapter12.xhtml#P7000497027000000000000000046CA8" class="pcalibre1 calibre8 pcalibre">pthread_cancel</code> function with the ID of the current thread.</p>
<pre id="P7000497027000000000000000046CA9" data-uri="chapter12.xhtml#P7000497027000000000000000046CA9" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046CAA" data-uri="chapter12.xhtml#P7000497027000000000000000046CAA" class="calibre10 pcalibre pcalibre1">
#include &lt;pthread.h&gt;
int pthread_cancel(pthread_t tid);
					Returns: 0 if OK, nonzero on error
</code></pre></li>
</ul>
</section>
<section id="P70004970270000000000000000081D1" data-uri="chapter12.xhtml#P70004970270000000000000000081D1" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046CAB" data-uri="chapter12.xhtml#P7000497027000000000000000046CAB" epub:type="title"><span class="pcalibre label pcalibre1">12.3.5 </span>Reaping Terminated Threads</h1></header>
<p id="P7000497027000000000000000046CAC" data-uri="chapter12.xhtml#P7000497027000000000000000046CAC" class="pcalibre1 pcalibre calibre2">Threads wait for other threads to terminate by calling the <code id="P7000497027000000000000000046CAD" data-uri="chapter12.xhtml#P7000497027000000000000000046CAD" class="pcalibre1 calibre8 pcalibre">pthread_join</code> function.</p>
<pre id="P7000497027000000000000000046CAE" data-uri="chapter12.xhtml#P7000497027000000000000000046CAE" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046CAF" data-uri="chapter12.xhtml#P7000497027000000000000000046CAF" class="calibre10 pcalibre pcalibre1">
#include &lt;pthread.h&gt;
int pthread_join(pthread_t tid, void **thread_return);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046CB0" data-uri="chapter12.xhtml#P7000497027000000000000000046CB0">The <code id="P7000497027000000000000000046CB1" data-uri="chapter12.xhtml#P7000497027000000000000000046CB1" class="pcalibre1 calibre8 pcalibre">pthread_join</code> function blocks until thread <code id="P7000497027000000000000000046CB2" data-uri="chapter12.xhtml#P7000497027000000000000000046CB2" class="pcalibre1 calibre8 pcalibre">tid</code> terminates, assigns the generic (<code id="P7000497027000000000000000046CB3" data-uri="chapter12.xhtml#P7000497027000000000000000046CB3" class="pcalibre1 calibre8 pcalibre">void *</code>) pointer returned by the thread routine to the location pointed to by <code id="P7000497027000000000000000046CB4" data-uri="chapter12.xhtml#P7000497027000000000000000046CB4" class="pcalibre1 calibre8 pcalibre">thread_return</code>, and then <i class="calibre5 pcalibre pcalibre1">reaps</i> any memory resources held by the terminated thread.</p>
<p id="P7000497027000000000000000046CB5" data-uri="chapter12.xhtml#P7000497027000000000000000046CB5" class="pcalibre1 pcalibre calibre2">Notice that, unlike the Linux <code id="P7000497027000000000000000046CB6" data-uri="chapter12.xhtml#P7000497027000000000000000046CB6" class="pcalibre1 calibre8 pcalibre">wait</code> function, the <code id="P7000497027000000000000000046CB7" data-uri="chapter12.xhtml#P7000497027000000000000000046CB7" class="pcalibre1 calibre8 pcalibre">pthread_join</code> function can only wait for a specific thread to terminate. There is no way to instruct <code id="P7000497027000000000000000046CB8" data-uri="chapter12.xhtml#P7000497027000000000000000046CB8" class="pcalibre1 calibre8 pcalibre">pthread_join</code> to wait for an <i class="calibre5 pcalibre pcalibre1">arbitrary</i> thread to terminate. This can complicate our code by forcing us to use other, less intuitive mechanisms to detect process termination. Indeed, Stevens argues convincingly that this is a bug in the specification [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B480">110</a>].</p>
</section>
<section id="P70004970270000000000000000081E0" data-uri="chapter12.xhtml#P70004970270000000000000000081E0" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046CB9" data-uri="chapter12.xhtml#P7000497027000000000000000046CB9" epub:type="title"><span class="pcalibre label pcalibre1">12.3.6 </span>Detaching Threads</h1></header>
<p id="P7000497027000000000000000046CBA" data-uri="chapter12.xhtml#P7000497027000000000000000046CBA" class="pcalibre1 pcalibre calibre2">At any point in time, a thread is <i class="calibre5 pcalibre pcalibre1">joinable</i> or <i class="calibre5 pcalibre pcalibre1">detached</i>. A joinable thread can be reaped and killed by other threads. Its memory resources (such as the stack) are not freed until it is reaped by another thread. In contrast, a detached thread cannot <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000081E3" title="990" data-uri="chapter12.xhtml#P70004970270000000000000000081E3" epub:type="pagebreak"></span>be reaped or killed by other threads. Its memory resources are freed automatically by the system when it terminates.</p>
<p id="P7000497027000000000000000046CBB" data-uri="chapter12.xhtml#P7000497027000000000000000046CBB" class="pcalibre1 pcalibre calibre2">By default, threads are created joinable. In order to avoid memory leaks, each joinable thread should be either explicitly reaped by another thread or detached by a call to the <code id="P7000497027000000000000000046CBC" data-uri="chapter12.xhtml#P7000497027000000000000000046CBC" class="pcalibre1 calibre8 pcalibre">pthread_detach</code> function.</p>
<pre id="P7000497027000000000000000046CBD" data-uri="chapter12.xhtml#P7000497027000000000000000046CBD" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046CBE" data-uri="chapter12.xhtml#P7000497027000000000000000046CBE" class="calibre10 pcalibre pcalibre1">
#include &lt;pthread.h&gt;
int pthread_detach(pthread_t tid);
					Returns: 0 if OK, nonzero on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046CBF" data-uri="chapter12.xhtml#P7000497027000000000000000046CBF">The <code id="P7000497027000000000000000046CC0" data-uri="chapter12.xhtml#P7000497027000000000000000046CC0" class="pcalibre1 calibre8 pcalibre">pthread_detach</code> function detaches the joinable thread <code id="P7000497027000000000000000046CC1" data-uri="chapter12.xhtml#P7000497027000000000000000046CC1" class="pcalibre1 calibre8 pcalibre">tid</code>. Threads can detach themselves by calling <code id="P7000497027000000000000000046CC2" data-uri="chapter12.xhtml#P7000497027000000000000000046CC2" class="pcalibre1 calibre8 pcalibre">pthread_detach</code> with an argument of <code id="P7000497027000000000000000046CC3" data-uri="chapter12.xhtml#P7000497027000000000000000046CC3" class="pcalibre1 calibre8 pcalibre">pthread_self()</code>.</p>
<p id="P7000497027000000000000000046CC4" data-uri="chapter12.xhtml#P7000497027000000000000000046CC4" class="pcalibre1 pcalibre calibre2">Although some of our examples will use joinable threads, there are good reasons to use detached threads in real programs. For example, a high-performance Web server might create a new peer thread each time it receives a connection request from a Web browser. Since each connection is handled independently by a separate thread, it is unnecessary—and indeed undesirable—for the server to explicitly wait for each peer thread to terminate. In this case, each peer thread should detach itself before it begins processing the request so that its memory resources can be reclaimed after it terminates.</p>
</section>
<section id="P70004970270000000000000000081EE" data-uri="chapter12.xhtml#P70004970270000000000000000081EE" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046CC5" data-uri="chapter12.xhtml#P7000497027000000000000000046CC5" epub:type="title"><span class="pcalibre label pcalibre1">12.3.7 </span>Initializing Threads</h1></header>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046CC6" data-uri="chapter12.xhtml#P7000497027000000000000000046CC6">The <code id="P7000497027000000000000000046CC7" data-uri="chapter12.xhtml#P7000497027000000000000000046CC7" class="pcalibre1 calibre8 pcalibre">pthread_once</code> function allows you to initialize the state associated with a thread routine.</p>
<pre id="P7000497027000000000000000046CC8" data-uri="chapter12.xhtml#P7000497027000000000000000046CC8" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046CC9" data-uri="chapter12.xhtml#P7000497027000000000000000046CC9" class="calibre10 pcalibre pcalibre1">
#include &lt;pthread.h&gt;
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control,
		void (*init_routine)(void));
						Always returns 0
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046CCA" data-uri="chapter12.xhtml#P7000497027000000000000000046CCA">The <code id="P7000497027000000000000000046CCB" data-uri="chapter12.xhtml#P7000497027000000000000000046CCB" class="pcalibre1 calibre8 pcalibre">once_control</code> variable is a global or static variable that is always initialized to PTHREAD_ONCE_INIT. The first time you call <code id="P7000497027000000000000000046CCC" data-uri="chapter12.xhtml#P7000497027000000000000000046CCC" class="pcalibre1 calibre8 pcalibre">pthread_once</code> with an argument of <code id="P7000497027000000000000000046CCD" data-uri="chapter12.xhtml#P7000497027000000000000000046CCD" class="pcalibre1 calibre8 pcalibre">once_control</code>, it invokes <code id="P7000497027000000000000000046CCE" data-uri="chapter12.xhtml#P7000497027000000000000000046CCE" class="pcalibre1 calibre8 pcalibre">init_routine</code>, which is a function with no input arguments that returns nothing. Subsequent calls to <code id="P7000497027000000000000000046CCF" data-uri="chapter12.xhtml#P7000497027000000000000000046CCF" class="pcalibre1 calibre8 pcalibre">pthread_once</code> with the same <code id="P7000497027000000000000000046CD0" data-uri="chapter12.xhtml#P7000497027000000000000000046CD0" class="pcalibre1 calibre8 pcalibre">once_control</code> variable do nothing. The <code id="P7000497027000000000000000046CD1" data-uri="chapter12.xhtml#P7000497027000000000000000046CD1" class="pcalibre1 calibre8 pcalibre">pthread_once</code> function is useful whenever you need to dynamically initialize global variables that are shared by multiple threads. We will look at an example in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000827E.xhtml#P7000497027000000000000000008456"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">12.5.5</span></a>.</p>
</section>
<section id="P70004970270000000000000000081FC" data-uri="chapter12.xhtml#P70004970270000000000000000081FC" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046CD2" data-uri="chapter12.xhtml#P7000497027000000000000000046CD2" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000081FE" title="991" data-uri="chapter12.xhtml#P70004970270000000000000000081FE" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">12.3.8 </span>A Concurrent Server Based on Threads</h1></header>
<p id="P7000497027000000000000000046CD3" data-uri="chapter12.xhtml#P7000497027000000000000000046CD3" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008200"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.14</span></a> shows the code for a concurrent echo server based on threads. The overall structure is similar to the process-based design. The main thread repeatedly waits for a connection request and then creates a peer thread to handle the request. While the code looks simple, there are a couple of general and somewhat subtle issues we need to look at more closely. The first issue is how to pass</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000008200" data-uri="chapter12.xhtml#P7000497027000000000000000008200">
<p id="P7000497027000000000000000046CD4" data-uri="chapter12.xhtml#P7000497027000000000000000046CD4" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservert.c</i></p>
<pre id="P7000497027000000000000000046CD5" data-uri="chapter12.xhtml#P7000497027000000000000000046CD5" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046CD6" data-uri="chapter12.xhtml#P7000497027000000000000000046CD6" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	
3	void echo(int connfd);
4	void *thread(void *vargp);
5	
6	int main(int argc, char **argv)
7	{
8		int listenfd, *connfdp;
9		socklen_t clientlen;
10		struct sockaddr_storage clientaddr;
11		pthread_t tid;
12	
13		if (argc != 2) {
14			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
15			exit(0);
16		}
17		listenfd = Open_listenfd(argv[1]); 18
19		while (1) {
20			clientlen=sizeof(struct sockaddr_storage);
21			connfdp = Malloc(sizeof(int));
22			*connfdp = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
23			Pthread_create(&amp;tid, NULL, thread, connfdp);
24		}
25	}
26	
27	/* Thread routine */
28	void *thread(void *vargp)
29	{
30		int connfd = *((int *)vargp);
31		Pthread_detach(pthread_self());
32		Free(vargp);
33		echo(connfd);
34		Close(connfd);
35		return NULL;
36	}
</code></pre>
<p id="P7000497027000000000000000046CD7" data-uri="chapter12.xhtml#P7000497027000000000000000046CD7" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoservert.c</i></p>
<figcaption id="P7000497027000000000000000046CD8" data-uri="chapter12.xhtml#P7000497027000000000000000046CD8" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046CD9" data-uri="chapter12.xhtml#P7000497027000000000000000046CD9" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.14 </span>Concurrent echo server based on threads.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046CDA" data-uri="chapter12.xhtml#P7000497027000000000000000046CDA"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000008208" title="992" data-uri="chapter12.xhtml#P7000497027000000000000000008208" epub:type="pagebreak"></span>the connected descriptor to the peer thread when we call <code id="P7000497027000000000000000046CDB" data-uri="chapter12.xhtml#P7000497027000000000000000046CDB" class="pcalibre1 calibre8 pcalibre">pthread_create</code>. The obvious approach is to pass a pointer to the descriptor, as in the following:</p>
<pre id="P7000497027000000000000000046CDC" data-uri="chapter12.xhtml#P7000497027000000000000000046CDC" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046CDD" data-uri="chapter12.xhtml#P7000497027000000000000000046CDD" class="calibre10 pcalibre pcalibre1">
connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
Pthread_create(&amp;tid, NULL, thread, &amp;connfd);
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046CDE" data-uri="chapter12.xhtml#P7000497027000000000000000046CDE">Then we have the peer thread dereference the pointer and assign it to a local variable, as follows:</p>
<pre id="P7000497027000000000000000046CDF" data-uri="chapter12.xhtml#P7000497027000000000000000046CDF" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046CE0" data-uri="chapter12.xhtml#P7000497027000000000000000046CE0" class="calibre10 pcalibre pcalibre1">
void *thread(void *vargp) {
	int connfd = *((int *)vargp);
	⋮
}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046CE1" data-uri="chapter12.xhtml#P7000497027000000000000000046CE1">This would be wrong, however, because it introduces a <i class="calibre5 pcalibre pcalibre1">race</i> between the assignment statement in the peer thread and the <code id="P7000497027000000000000000046CE2" data-uri="chapter12.xhtml#P7000497027000000000000000046CE2" class="pcalibre1 calibre8 pcalibre">accept</code> statement in the main thread. If the assignment statement completes before the next <code id="P7000497027000000000000000046CE3" data-uri="chapter12.xhtml#P7000497027000000000000000046CE3" class="pcalibre1 calibre8 pcalibre">accept</code>, then the local <code id="P7000497027000000000000000046CE4" data-uri="chapter12.xhtml#P7000497027000000000000000046CE4" class="pcalibre1 calibre8 pcalibre">connfd</code> variable in the peer thread gets the correct descriptor value. However, if the assignment completes <i class="calibre5 pcalibre pcalibre1">after</i> the <code id="P7000497027000000000000000046CE5" data-uri="chapter12.xhtml#P7000497027000000000000000046CE5" class="pcalibre1 calibre8 pcalibre">accept</code>, then the local <code id="P7000497027000000000000000046CE6" data-uri="chapter12.xhtml#P7000497027000000000000000046CE6" class="pcalibre1 calibre8 pcalibre">connfd</code> variable in the peer thread gets the descriptor number of the <i class="calibre5 pcalibre pcalibre1">next</i> connection. The unhappy result is that two threads are now performing input and output on the same descriptor. In order to avoid the potentially deadly race, we must assign each connected descriptor returned by <code id="P7000497027000000000000000046CE7" data-uri="chapter12.xhtml#P7000497027000000000000000046CE7" class="pcalibre1 calibre8 pcalibre">accept</code> to its own dynamically allocated memory block, as shown in lines 21−22. We will return to the issue of races in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000008577.xhtml#P7000497027000000000000000008610"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">12.7.4</span></a>.</p>
<p id="P7000497027000000000000000046CE8" data-uri="chapter12.xhtml#P7000497027000000000000000046CE8" class="pcalibre1 pcalibre calibre2">Another issue is avoiding memory leaks in the thread routine. Since we are not explicitly reaping threads, we must detach each thread so that its memory resources will be reclaimed when it terminates (line 31). Further, we must be careful to free the memory block that was allocated by the main thread (line 32).</p>
<section id="P7000497027000000000000000008217" data-uri="chapter12.xhtml#P7000497027000000000000000008217" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046CE9" data-uri="chapter12.xhtml#P7000497027000000000000000046CE9" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.5 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000046CEA" data-uri="chapter12.xhtml#P7000497027000000000000000046CEA">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000046CEB" data-uri="chapter12.xhtml#P7000497027000000000000000046CEB">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000046CEC" data-uri="chapter12.xhtml#P7000497027000000000000000046CEC"><p id="P7000497027000000000000000046CED" data-uri="chapter12.xhtml#P7000497027000000000000000046CED" class="pcalibre calibre3 pcalibre1">In the process-based server in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000008097.xhtml#P70004970270000000000000000080CF"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.5</span></a>, we were careful to close the connected descriptor in two places: the parent process and the child process. However, in the threads-based server in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000008200"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.14</span></a>, we only closed the connected descriptor in one place: the peer thread. Why?</p></div></li>
</ol>
</section>
</section>
</section></body></html>
