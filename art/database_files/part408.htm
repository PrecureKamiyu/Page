<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>22.9  Distributed Query Processing</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part407.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part409.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">22.9  <span style=" color: #00AEEF;">Distributed Query Processing</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The need for distributed query processing originally arose when organizations needed to execute queries across multiple databases that were often geographically distributed. However, today the same need arises because organizations have data stored in multiple diﬀerent databases and data storage systems, and they need to execute queries that access multiples of these databases and data storage systems.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">22.9.1 Data Integration from Multiple Data Sources</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Diﬀerent parts of an enterprise may use diﬀerent databases, either because of a legacy of how they were automated, or because of mergers of companies. Migrating an entire organization to a common system may be an expensive and time-consuming operation. An alternative is to keep data in individual databases, but to provide users with a logical view of integrated data. The local database systems may employ diﬀerent logical mod- els, diﬀerent data-deﬁnition and data-manipulation languages, and may diﬀer in their concurrency-control and transaction-management mechanisms. Some of the sources of data may not be full-ﬂedged database systems but may instead be data storage sys- tems, or even just ﬁles in a ﬁle system. Yet another possibility is that the data source may be on the cloud and accessed as a web service. Queries may need access to data stored across multiple databases and data sources.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Manipulation of information located in multiple databases and other data sources requires an additional software layer on top of existing database systems. This layer creates the illusion of logical database integration without requiring physical database integration and is sometimes called a <span class="s63">federated database system</span>.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">Database integration can be done in several diﬀerent ways:</p><p class="s63" style="padding-top: 10pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">The </span>federated database <span class="p">approach creates a common schema, called a </span>global schema<span class="p">, for data from all the databases/data sources; each database has its own </span>local schema<span class="p">. The task of creating a uniﬁed global schema from multiple local schemas is referred to as </span>schema integration<span class="p">.</span></p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">Users can issue queries against the global schema. A query on a global schema must be translated into queries on the local schemas at each of the sites where the query has to be executed. The query results have to be translated back into the global schema and combined to get the ﬁnal result.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 14pt;text-align: justify;">In general, updates to the common schema also need to be mapped to updates to the individual databases; systems that support a common schema and queries, but not updates, against the schema are sometimes referred to as <span class="s63">mediator </span>systems.</p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The </span><span class="s63">data virtualization </span><span class="p">approach allows applications to access data from multiple databases/data sources, but it does not try to enforce a common schema. Users have to be aware of the diﬀerent schemas used in diﬀerent databases, but they do not need to worry about which data are stored on which database system, or about how to combine information from multiple databases.</span></p><p class="s63" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">The </span>external data <span class="p">approach allows database administrators to provide schema in- formation about data that are stored in other databases, along with other informa- tion, such as connection and authorization information needed to access the data. Data stored in external sources that can be accessed from a database are referred to as </span>external data<span class="p">. </span>Foreign tables <span class="p">are views deﬁned in a database whose actual data are stored in an external data source. Such tables can be read as well as up- dated, depending on what operations the external data source supports. Updates on foreign tables, if supported, must be translated into updates on the external data source.</span></p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">Unlike the earlier-mentioned approaches, the goal here is not to create a full- ﬂedged distributed database, but merely to facilitate access to data from other data sources. The <span class="s44">SQL </span>Management of External Data (<span class="s44">SQL MED</span>) component of the <span class="s44">SQL </span>standard deﬁnes standards for accessing external data sources from a database.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">If a data source is a database that supports <span class="s44">SQL</span>, its data can be easily accessed using <span class="s44">ODBC </span>or <span class="s44">JDBC </span>connections. Data in parallel data storage systems that do not support <span class="s44">SQL</span>, such as HBase, can be accessed using the <span class="s44">API </span>methods that they provide. A <span class="s63">wrapper </span>provides a view of data stored at a data source, in a desired schema. For example, if the system has a global schema, and the local database schema is diﬀerent from the global schema, a wrapper can provide a view of the data in the global schema. Wrappers can even be used to provide a relational view of nonrelational data sources,</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">such as web services, ﬂat ﬁles (e.g., web logs), and directory systems.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Wrappers can also translate queries on the global schema into queries on the lo- cal schema, and translate results back into the global schema. Wrappers may be pro- vided by individual sites, they may be written as part of the federated database system. Many relational databases today support wrappers that provide a relational view of data stored in ﬁle systems; such wrappers are speciﬁc to the type of data stored in the ﬁles.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If the goal of data integration is solely to run decision support queries, <i>data ware- houses</i>, which we saw in Section 11.2, are a widely used alternative to database inte- gration. Data warehouses import data from multiple sources into a single (possibly parallel) system, with a centralized schema. Data are typically imported periodically,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">for example, once in a day or once in a few hours, although continuous import is also increasingly used. Raw data imported from the data sources are typically processed and cleaned before being stored in the data warehouse.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">However, with the scale at which data are generated by some applications, creating and maintaining such a warehouse can be expensive. Furthermore, queries cannot ac- cess the most recent data, since there is a delay between updates on the source database and import of the updates to the data warehouse. On the other hand, query processing can be done more eﬃciently in a data warehouse; further, queries at a data warehouse do not aﬀect the performance of other queries and transactions at the data source. Whether to use a data warehouse architecture, or to directly access data from the data sources in response to individual queries, is a decision that each enterprise has to make based on its needs.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The term <span class="s63">data lake </span>is used to refer to an architecture where data are stored in multiple data storage systems and in diﬀerent formats, including in ﬁle systems, but can be queried from a single system. Data lakes are viewed as an alternative to data warehouses, since they do not require up-front eﬀort to preprocess data, although they do require more eﬀort when creating queries.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">22.9.2 Schema and Data Integration</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The ﬁrst task in providing a uniﬁed view of data lies in creating a uniﬁed conceptual schema, a task that is referred to as <span class="s63">schema integration</span>. Each local system provides its own conceptual schema. The database system must integrate these separate schemas into one common schema. Schema integration is a complicated task, mainly because of the semantic heterogeneity. The same attribute names may appear in diﬀerent local databases but with diﬀerent meanings.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Schema integration requires the creation of a <span class="s63">global schema</span>, which provides a uni- ﬁed view of data in diﬀerent databases. Schema integration also requires a way to deﬁne how data are mapped from the local schema representation at each database, to the global schema. This step can be done by deﬁning views at each site which, transform data from the local schema to the global schema. Data in the global schema is then treated as the union of the global views at the individual site. This approach is called the <span class="s63">global-as-view </span>(<span class="s63">GAV</span>) approach.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Consider an example with two sites which store student information in two diﬀer- ent ways:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3227.png"/></span></p><p style="padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s39">• </span><span class="s40">Site </span><i>s1 </i>which uses the relation <i>student1</i>(<span class="s69">ID</span>, <i>name</i>, <i>dept name</i>), and the relation</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3228.png"/></span></p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><i>studentCreds</i>(<span class="s69">ID</span>, <i>tot cred</i>).</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3229.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3230.png"/></span></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: left;"><span class="s39">• </span><span class="s40">Site </span><i>s2 </i>which uses the relation <i>student2</i>(<span class="s69">ID</span>, <i>name</i>, <i>tot cred</i>), and the relation <i>stu- dentDept</i>(<span class="s69">ID</span>, <i>dept name</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3231.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3232.png"/></span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Let the global schema chosen be <i>student</i>(<span class="s69">ID</span>, <i>name</i>, <i>dept name</i>, <i>tot cred</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 137pt;text-indent: 0pt;text-align: left;">Then, the global schema view at site <i>s1 </i>would be deﬁned as the view:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3233.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3234.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3235.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3236.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3237.png"/></span></p><p style="padding-left: 188pt;text-indent: 0pt;text-align: left;"><b>create view </b><i>student s1</i>(<span class="s69">ID</span>, <i>name</i>, <i>dept name</i>, <i>tot cred</i>) <b>as select </b><span class="s69">ID</span>, <i>name</i>, <i>dept name</i>, <i>tot cred</i></p><p class="s13" style="padding-left: 188pt;text-indent: 0pt;text-align: left;"><b>from </b>student1<span class="p">, </span>studentCreds</p><p style="padding-left: 188pt;text-indent: 0pt;text-align: left;"><b>where </b><i>student1</i>.<span class="s69">ID</span><span class="s15">= </span><i>studentCreds</i>.<span class="s69">ID</span>;</p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">While the global schema view at site <i>s2 </i>would be deﬁned as the view:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3238.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3239.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3240.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3241.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3242.png"/></span></p><p style="padding-left: 188pt;text-indent: 0pt;text-align: left;"><b>create view </b><i>student s2</i>(<span class="s69">ID</span>, <i>name</i>, <i>dept name</i>, <i>tot cred</i>) <b>as select </b><span class="s69">ID</span>, <i>name</i>, <i>dept name</i>, <i>tot cred</i></p><p class="s13" style="padding-left: 188pt;text-indent: 0pt;text-align: left;"><b>from </b>student2<span class="p">, </span>studentDept</p><p style="padding-left: 188pt;text-indent: 0pt;text-align: left;"><b>where </b><i>student2</i>.<span class="s69">ID</span><span class="s15">= </span><i>studentDept</i>.<span class="s69">ID</span>;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3243.png"/></span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Finally, the global schema <i>student </i>would be deﬁned as the union of <i>student s1 </i>and</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3244.png"/></span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">student s2<span class="p">.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">Note that with the above view deﬁnition, a query on the global schema relation <i>student </i>can be easily translated into queries on the local schema relations at the sites <i>s1 </i>and <i>s2</i>. It is harder to translate updates on the global schema into updates on the local schema, since there may not be a unique way to do so as discussed in Section 4.2. There are more complex mapping schemes that are designed to deal with dupli- cation of information across sites and to allow translation of updates on the global schema into updates on the local schema. The <span class="s63">local-as-view </span>(<span class="s63">LAV</span>) approach, which deﬁnes local data in each site as a view on a conceptual uniﬁed global relation, is one</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">such approach.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3245.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3246.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3247.png"/></span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Consider for example a situation where the <i>student </i>relation is partitioned between two sites based on the <i>dept name </i>attribute, with all students in the “Comp. Sci.” depart- ment at site <i>s</i>3 and all students in other departments in site <i>s</i>4. This can be speciﬁed using the local-as-view approach by deﬁning the relations <i>student s3 </i>and <i>student s4</i>, which are actually stored at the sites <i>s3 </i>and <i>s4</i>, as equivalent to views deﬁned on the global relation <i>student</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3248.png"/></span></p><p class="s46" style="padding-top: 4pt;padding-left: 220pt;text-indent: 0pt;text-align: left;">create view <i>student s3 </i>as select <span class="s15">∗</span></p><p class="s46" style="padding-left: 220pt;text-indent: 0pt;text-align: left;">from <i>student</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3249.png"/></span></p><p class="s13" style="padding-left: 220pt;text-indent: 0pt;text-align: left;"><b>where </b>student<span class="p">.</span>dept name <span class="s15">= </span><span class="p">&#39;Comp. Sci.&#39;;</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">and</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3250.png"/></span></p><p class="s46" style="padding-top: 4pt;padding-left: 217pt;text-indent: 0pt;text-align: left;">create view <i>student s4 </i>as select <span class="s15">∗</span></p><p class="s46" style="padding-left: 217pt;text-indent: 0pt;text-align: left;">from <i>student</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3251.png"/></span></p><p class="s13" style="padding-left: 217pt;text-indent: 0pt;text-align: left;"><b>where </b>student<span class="p">.</span>dept name <span class="s15">! = </span><span class="p">&#39;Comp. Sci.&#39;;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">With this extra information, the query optimizer can ﬁgure out that a query that seeks to retrieve students in the Comp. Sci. department need only be executed at site <i>s3 </i>and need not be executed at site <i>s4</i>. More information on schema integration may be found in the bibliographic notes for this chapter, available online.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The second task in providing a uniﬁed view of data from multiple sources lies in dealing with diﬀerences in data types and values. For example, the data types used in one system may not be supported by other systems, and translation between types may not be simple. Even for identical data types, problems may arise from the phys- ical representation of data: One system may use 8-bit <span class="s44">ASCII</span>, while another may use 16-bit Unicode; ﬂoating-point representations may diﬀer; integers may be represented in <i>big-endian </i>or <i>little-endian </i>form. At the semantic level, an integer value for length may be inches in one system and millimeters in another; when integrating the data, a single representation must be used, and values converted to the chosen representation. Mapping between types can be done as part of the view deﬁnitions that translate data between the local schemas and the global schema.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A deeper problem is that the same conceptual entity may have diﬀerent names in diﬀerent systems. For example, a system based in the United States may refer to the city “Cologne,” whereas one in Germany refers to it as “K¨oln.” One approach to deal with this problem is to have a globally unique naming system, and map values to the unique names as part of the view deﬁnitions used for schema mappings. For example, the International Standards Organization has a unique code for country names, and for states/provinces within the countries. The GeoNames database (<span class="s49">www.geonames.org</span>) provides unique names for several million locations such as cities, geographical fea- tures, roads, buildings, and so forth.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When such standard naming systems are not available, some systems allow the speciﬁcation of name equivalences; for example, such a system could allow a user to say that “Cologne” is the same as “K¨oln”. This approach is used in the <span class="s63">Linked Data </span>project, which supports the integration of a very large number of databases that use the <span class="s44">RDF </span>representation of data (the <span class="s44">RDF </span>representation is described in Section 8.1.4). However, querying is more complicated in such a scenario.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In our description of the view deﬁnitions above, we assumed that data are stored in local databases, and the view deﬁnitions are used to provide a global view of the data, without actually materializing the data in the global schema. However, such views can also be used to materialize the data in the global schema, which can then be stored in a data warehouse. In the latter case, updates on underlying data must be propagated to the data warehouse.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">22.9.3 Query Processing Across Multiple Data Sources</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">A naive way to execute a query that accesses data from multiple data sources is to fetch all required data to one database, which then executes the query. But suppose, for example, that the query has a selection condition that is satisﬁed by only one or a few records out of a large relation. If the data source allows the selection to be performed at</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">the data source, it makes no sense to retrieve the entire relation; instead, the selection operation should be performed at the data source, while other operations, if any, may be performed at the database where the query was issued.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In general, diﬀerent data sources may support diﬀerent query capabilities. For ex- ample, if the source is a data storage system, it may support selections on key attributes only. Web data sources may restrict which ﬁelds selections are allowed on and may ad- ditionally require that selections be present on certain ﬁelds. On the other hand, if the source is a database that supports SQL, operations such as join or aggregation could be performed at the source and only the result brought over to the database that issues the query. In general, queries may have to be broken up and performed partly at the data source and partly at the site issuing the query.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The cost of processing a query that accesses multiple data sources depends on the local execution costs, as well as on the data transfer cost. If the network is a low bandwidth wide-area network, particular attention must be paid to minimizing data transfer.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">In this section, we study issues in distributed query processing and optimization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">22.9.3.1 Join Locations and Join Ordering</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Consider the following relational-algebra expression:</p><p class="s13" style="padding-top: 10pt;padding-left: 84pt;text-indent: 0pt;text-align: center;">r<span class="s93">1 </span><span class="s86">⋈ </span>r<span class="s93">2 </span><span class="s86">⋈ </span>r<span class="s93">3</span></p><p class="s13" style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;line-height: 90%;text-align: justify;"><span class="p">Assume that </span>r<span class="s93">1 </span><span class="s94">is stored at site </span>S<span class="s93">1</span><span class="s94">, </span>r<span class="s93">2 </span><span class="s94">at </span>S<span class="s93">2</span><span class="s94">, and </span>r<span class="s93">3 </span><span class="s94">at </span>S<span class="s93">3</span><span class="s94">. Let </span>S<span class="s145">I </span><span class="p">denote the site at which the query was issued. The system needs to produce the result at site </span>S<span class="s145">I </span><span class="p">. Among the possible strategies for processing this query are these:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 139pt;text-indent: -16pt;line-height: 87%;text-align: justify;"><span class="s39">• </span><span class="s40">Ship copies of all three relations to site </span>S<span class="s97">I </span><span class="p">. Using the techniques of Chapter 16, choose a strategy for processing the entire query locally at site </span>S<span class="s97">I </span><span class="p">.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;line-height: 81%;text-align: justify;"><span class="s39">• </span><span class="s40">Ship a copy of the </span>r<span class="s93">1 </span><span class="s94">relation to site </span>S<span class="s93">2</span><span class="s94">, and compute </span>temp<span class="s93">1 </span><span class="s94">= </span>r<span class="s93">1 </span><span class="s86">⋈ </span>r<span class="s93">2 </span><span class="s94">at </span>S<span class="s93">2</span><span class="s94">. Ship </span>temp<span class="s93">1 </span><span class="s94">from </span>S<span class="s93">2 </span><span class="s94">to </span>S<span class="s93">3</span><span class="s94">, and compute </span>temp<span class="s93">2 </span><span class="s94">= </span>temp<span class="s93">1 </span><span class="s86">⋈ </span>r<span class="s93">3 </span><span class="s94">at </span>S<span class="s93">3</span><span class="s94">. Ship the result </span>temp<span class="s93">2 </span><span class="s94">to </span>S<span class="s97">I </span><span class="p">.</span></p><p class="s13" style="padding-top: 2pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Devise strategies similar to the previous one, with the roles of </span>S<span class="s98">1</span><span class="p">, </span>S<span class="s98">2</span><span class="p">, </span>S<span class="s98">3</span><span class="p"> exchanged.</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">There are several other possible strategies.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">No one strategy is always the best one. Among the factors that must be considered are the volume of data being shipped, the cost of transmitting a block of data between a pair of sites, and the relative speed of processing at each site. Consider the ﬁrst strategy. Suppose indices present at <i>S</i><span class="s98">2</span> and <i>S</i><span class="s98">3</span> are useful for computing the join. If we ship all three relations to <i>S</i><span class="s97">I </span>, we would need to either re-create these indices at <i>S</i><span class="s97">I </span>or use a</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">diﬀerent, possibly more expensive, join strategy. Re-creation of indices entails extra</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">processing overhead and extra disk accesses. There are many variants of the second strategy, which process joins in diﬀerent orders.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">The cost of each of the strategies depends on the sizes of the intermediate results, the network transmission costs, and the costs of processing at each node. The query optimizer needs to choose the best strategy, based on cost estimates.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">22.9.3.2 Semijoin Strategy</p><p class="s13" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;line-height: 86%;text-align: justify;"><span class="p">Suppose that we wish to evaluate the expression </span>r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2</span><span class="s94">, where </span>r<span class="s130">1 </span><span class="s94">and </span>r<span class="s130">2 </span><span class="s94">are stored at sites </span>S<span class="s130">1 </span><span class="s94">and </span>S<span class="s130">2</span><span class="s94">, respectively. Let the schemas of </span>r<span class="s130">1 </span><span class="s94">and </span>r<span class="s130">2 </span><span class="s94">be </span>R<span class="s130">1 </span><span class="s94">and </span>R<span class="s130">2</span><span class="s94">. Suppose that we wish to obtain the result at </span>S<span class="s98">1</span><span class="p">. If there are many tuples of </span>r<span class="s98">2</span><span class="p"> that do not join with</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">any tuple of <i>r</i><span class="s98">1</span>, then shipping <i>r</i><span class="s98">2</span> to <i>S</i><span class="s98">1</span> entails shipping tuples that fail to contribute to the result. We want to remove such tuples before shipping data to <i>S</i><span class="s98">1</span>, particularly if network costs are high.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">A possible strategy to accomplish all this is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1  2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-left: 97pt;text-indent: 0pt;text-align: left;"><span class="s63">1. </span><span class="p">Compute </span>temp<span class="s130">1 </span><span class="s86">← </span><span class="s15">Π</span><span class="s123">R</span> <span class="s137">∩</span><span class="s15"> </span><span class="s123">R</span> <span class="p">(</span>r<span class="s130">1</span><span class="s94">) at </span>S<span class="s130">1</span><span class="s94">.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 96pt;text-indent: 0pt;text-align: left;"><span class="s63">2. </span><span class="p">Ship </span>temp<span class="s93">1 </span><span class="s94">from </span>S<span class="s93">1 </span><span class="s94">to </span>S<span class="s93">2</span><span class="s94">.</span></p><p class="s13" style="padding-left: 96pt;text-indent: 0pt;text-align: left;"><span class="s63">3. </span><span class="p">Compute </span>temp<span class="s130">2 </span><span class="s86">← </span>r<span class="s130">2 </span><span class="s86">⋈ </span>temp<span class="s130">1 </span><span class="s94">at </span>S<span class="s130">2</span><span class="s94">.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 96pt;text-indent: 0pt;text-align: left;"><span class="s63">4. </span><span class="p">Ship </span>temp<span class="s130">2 </span><span class="s94">from </span>S<span class="s130">2 </span><span class="s94">to </span>S<span class="s130">1</span><span class="s94">.</span></p><p class="s13" style="padding-left: 96pt;text-indent: 0pt;text-align: left;"><span class="s63">5. </span><span class="p">Compute </span>r<span class="s130">1 </span><span class="s86">⋈ </span>temp<span class="s130">2 </span><span class="s94">at </span>S<span class="s130">1</span><span class="s94">. The resulting relation is the same as </span>r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2</span><span class="s94">.</span></p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1  2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;line-height: 88%;text-align: justify;"><span class="p">Before considering the eﬃciency of this strategy, let us verify that the strategy computes the correct answer. In step 3, </span>temp<span class="s93">2 </span><span class="s94">has the result of </span>r<span class="s93">2 </span><span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">R</span> <span class="s137">∩</span><span class="s15"> </span><span class="s123">R</span> <span class="p">(</span>r<span class="s93">1</span><span class="s94">). In step 5, we compute:</span></p><p class="s13" style="padding-top: 1pt;padding-left: 64pt;text-indent: 0pt;text-align: center;">r<span class="s93">1 </span><span class="s86">⋈ </span>r<span class="s93">2 </span><span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">R</span><span class="s158">1 </span><span class="s171">∩ </span><span class="s169">R</span><span class="s158">2 </span><span class="s388">(</span>r<span class="s93">1</span><span class="s94">)</span></p><p style="padding-top: 9pt;padding-left: 18pt;text-indent: 0pt;text-align: center;">Since join is associative and commutative, we can rewrite this expression as:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1  2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-left: 63pt;text-indent: 0pt;text-align: center;"><span class="p">(</span>r<span class="s130">1 </span><span class="s86">⋈ </span><span class="s15">Π</span><span class="s123">R</span> <span class="s137">∩</span><span class="s15"> </span><span class="s123">R</span> <span class="p">(</span>r<span class="s130">1</span><span class="s94">)) </span><span class="s86">⋈ </span>r<span class="s130">2</span></p><p class="s13" style="padding-top: 9pt;padding-left: 59pt;text-indent: 0pt;line-height: 12pt;text-align: center;"><span class="p">Since </span>r<span class="s130">1  </span><span class="s86">⋈ </span><span class="s15">Π</span><span class="s98">(</span><span class="s123">R</span> <span class="s137">∩</span><span class="s15"> </span><span class="s123">R</span> <span class="s98">)</span><span class="p"> (</span>r<span class="s130">1</span><span class="s94">) </span><span class="s15">= </span>r<span class="s130">1</span><span class="s94">, the expression is, indeed, equal to </span>r<span class="s130">1  </span><span class="s86">⋈ </span>r<span class="s130">2</span><span class="s94">, the</span></p><p class="s150" style="padding-left: 165pt;text-indent: 0pt;line-height: 3pt;text-align: left;">1  2</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">expression we are trying to evaluate.</p><p style="padding-top: 2pt;padding-left: 88pt;text-indent: 17pt;line-height: 83%;text-align: justify;">This strategy is called a <span class="s63">semijoin strategy</span>, after the semijoin operator of the rela- tional algebra, denoted <span class="s86">⋉</span>, which we saw in Section 16.4.4. The <i>natural semijoin </i>of <i>r</i><span class="s98">1</span> with <i>r</i><span class="s93">2</span><span class="s94">, denoted </span><i>r</i><span class="s93">1 </span><span class="s86">⋉ </span><i>r</i><span class="s93">2</span><span class="s94">, is deﬁned as:</span></p><p class="s13" style="padding-top: 9pt;padding-left: 64pt;text-indent: 0pt;text-align: center;">r<span class="s130">1 </span><span class="s86">⋉ </span>r<span class="s130">2 </span><span class="s86">≝ </span><span class="s15">Π</span><span class="s123">R</span><span class="s158">1 </span><span class="s388">(</span>r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2</span><span class="s94">)</span></p><p class="s13" style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;line-height: 77%;text-align: justify;"><span class="p">Thus, </span>r<span class="s130">1 </span><span class="s86">⋉ </span>r<span class="s130">2 </span><span class="s94">selects those tuples of relation </span>r<span class="s130">1 </span><span class="s94">that contributed to </span>r<span class="s130">1 </span><span class="s86">⋈ </span>r<span class="s130">2</span><span class="s94">. In step 3, </span>temp<span class="s98">2</span><span class="p"> = </span>r<span class="s98">2</span><span class="p"> </span><span class="s86">⋉ </span>r<span class="s98">1</span><span class="p">. The semijoin operation is easily extended to theta-joins. The </span>theta semijoin <span class="p">of </span>r<span class="s130">1 </span><span class="s94">with </span>r<span class="s130">2</span><span class="s94">, denoted </span>r<span class="s130">1 </span><span class="s86">⋉</span><span class="s136">θ </span>r<span class="s130">2</span><span class="s94">, is deﬁned as:</span></p><p class="s13" style="padding-top: 9pt;padding-left: 64pt;text-indent: 0pt;text-align: center;">r<span class="s130">1 </span><span class="s86">⋉</span><span class="s136">θ </span>r<span class="s130">2 </span><span class="s86">≝ </span><span class="s15">Π</span><span class="s123">R</span><span class="s158">1 </span><span class="s388">(</span>r<span class="s130">1 </span><span class="s86">⋈</span><span class="s136">θ </span>r<span class="s130">2</span><span class="s94">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">For joins of several relations, the semijoin strategy can be extended to a series of semijoin steps. It is the job of the query optimizer to choose the best strategy based on cost estimates.</p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;line-height: 92%;text-align: justify;"><span class="p">This strategy is particularly advantageous when relatively few tuples of </span>r<span class="s98">2</span><span class="p"> contribute to the join. This situation is likely to occur if </span>r<span class="s98">1</span><span class="p"> is the result of a relational-algebra ex- pression involving selection. In such a case, </span>temp<span class="s98">2</span><span class="p">, that is, </span>r<span class="s98">2</span><span class="s86">⋉</span>r<span class="s98">1</span><span class="p">, may have signiﬁcantly fewer tuples than </span>r<span class="s98">2</span><span class="p">. The cost savings of the strategy result from having to ship only</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">r<span class="s93">2 </span><span class="s86">⋉ </span>r<span class="s93">1</span><span class="s94">, rather than all of </span>r<span class="s93">2</span><span class="s94">, to </span>S<span class="s93">1</span><span class="s94">.</span></p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-left: 137pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p">Some additional cost is incurred in shipping </span>temp<span class="s130">1</span><span class="s94">, that is </span><span class="s15">Π</span><span class="s123">R</span> <span class="s137">∩</span><span class="s15"> </span><span class="s123">R</span> <span class="p">(</span>r<span class="s130">1</span><span class="s94">) to </span>S<span class="s130">2</span><span class="s94">. If a </span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">suﬃciently small fraction of tuples in <i>r</i><span class="s98">2</span> contribute to the join, the overhead of shipping <i>temp</i><span class="s98">1</span> will be dominated by the savings of shipping only a fraction of the tuples in <i>r</i><span class="s98">2</span>. The overhead of sending <i>temp</i><span class="s98">1</span> tuples from <i>s</i><span class="s98">1</span> to <i>s</i><span class="s98">2</span> can be reduced as follows. For the purpose of optimization of join processing, the semijoin operation can be implemented in a manner that overapproximates the true semijoin result. That is, the result should contain all the tuples in the actual semijoin result, but it may contain a few extra tuples. The extra tuples will get eliminated later by the join operation.</p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 94%;text-align: justify;">An eﬃcient overapproximation of the semijoin result can be computed by using a probabilistic data structure called a <span class="s63">Bloom filter</span>, which uses bitmaps. Bloom ﬁlters are described in more detail in Section 24.1. To implement <i>r</i><span class="s98">2</span> <span class="s86">⋉ </span><i>r</i><span class="s98">1</span>, a Bloom ﬁlter with a bitmap <i>b </i>of size <i>m</i>, initialized with all bits set to 0 is used. The join attributes of each tuple of <i>r</i><span class="s98">1</span> are hashed to a value in the range 0 <span class="s15">… </span>(<i>m </i><span class="s15">− </span>1), and the corresponding bit</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">of <i>b </i>is set to 1. The bitmap <i>b</i>, which is much smaller than the relation <i>r</i><span class="s98">1</span>, can now be sent to the site containing <i>r</i><span class="s98">2</span>. There, the same hash function is computed on the join attributes of each tuple of <i>r</i><span class="s98">2</span>. If the corresponding bit is set to 1 in <i>b</i>, that <i>r</i><span class="s98">2</span> tuple is accepted (added to the <i>result </i>relation), and otherwise it is rejected.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that it is possible for diﬀerent join attribute values, say <i>v</i><span class="s98">1</span> and <i>v</i><span class="s98">2</span> to have the same hash value; even if <i>r</i><span class="s98">1</span> has a tuple with value <i>v</i><span class="s98">1</span>, but does not have any tuple with value <i>v</i><span class="s98">2</span>, the result of the above procedure may include <i>r</i><span class="s98">2</span> tuples whose join attribute value is <i>v</i><span class="s98">2</span>. Such a situation is referred to as a <span class="s63">false positive</span>. However, if <i>v</i><span class="s98">1</span> is present in <i>r</i><span class="s98">1</span>, the technique will never reject a tuple in <i>r</i><span class="s98">2</span> that has join attribute value <i>v</i><span class="s98">1</span>, which is important for correctness.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 79%;text-align: justify;">The <i>result </i>relation computed above, which is a superset of or equal to <i>r</i><span class="s98">2</span> <span class="s86">⋉ </span><i>r</i><span class="s98">1</span>, is sent to site <i>s</i><span class="s98">1</span>. The join <i>r</i><span class="s98">1</span> <span class="s86">⋈ </span><i>result </i>is then computed at site <i>s</i><span class="s98">1</span> to get the required join result. False positives may result in extra tuples in <i>result </i>that are not present in <i>r</i><span class="s98">2</span> <span class="s86">⋉ </span><i>r</i><span class="s98">1</span>, but such tuples would be eliminated by the join.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 92%;text-align: justify;">To keep the probability of false positives low, the number of bits in the Bloom ﬁlter is usually set to a few times the estimated number of distinct join attribute values. Further, it is possible to use <i>k </i>independent hash functions, for some <i>k </i><span class="s83">&gt; </span>1, to identify</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">k <span class="p">bit positions for a given value, and set all of them to 1 when creating the bitmap.</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">When querying it with a given value, the same <i>k </i>hash functions are used to identify <i>k </i>bit locations, and the value is determined to be absent if even one of the <i>k </i>bits has a 0 value. For example, if the bitmap has 10<i>n </i>bits, where <i>n </i>is the number of distinct join</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">attribute values, and <i>k </i><span class="s15">= </span>7 hash functions are used, the false positive rate would be about 1%.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">22.9.3.3 Distributed Query Optimization</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Several extensions need to be made to existing query optimization techniques in order to optimize distributed query plans.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The ﬁrst extension is to record the location of data as a <i>physical property </i>of the data; recall that optimizers already deal with other physical properties such as the sort order of results. Just as the sort operation is used to create diﬀerent sort orders, an exchange operation is used to transfer data between diﬀerent sites.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The second extension is to track where an operator is executed; optimizers already consider diﬀerent algorithms, such as hash join or merge join, for a given logical oper- ator, in this case, the join operator. The optimizer is extended to additionally consider alternative sites for execution of each algorithm. Note that to execute an operator at a given site, its inputs must satisfy the physical property of being located at that site.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The third extension is to consider semijoin operations to reduce data transfer costs. Semijoin operations can be introduced as logical transformation rules; however, if done naively, the search space increases greatly, making this approach infeasible. Optimiza- tion cost can be reduced by restricting, as a heuristic, semijoins to be applied only on database tables, and never on intermediate join results.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3252.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3253.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A fourth extension is to use schema information to restrict the set of nodes at which a query needs to be executed. Recall from Section 22.9.2 that the local-as-view approach can be used to specify that a relation is partitioned in a particular way. In the example we saw there, site <i>s3 </i>contains all student tuples with <i>dept name </i>being Comp. Sci., while <i>s4 </i>contains all the other student tuples. Suppose a query has a selection “<i>dept name</i>=&#39;Comp. Sci.&#39;” on <i>student</i>; then, the optimizer should recognize that there is no need to involve site <i>s4 </i>when executing this query.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As another example, if the student data at site <i>s5 </i>is a replica of the data at site <i>s3</i>, then the optimizer can choose to execute the query at either of the sites, depending on which is cheaper; there is no need to execute the query at both sites.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">22.9.4 Distributed Directory Systems</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: right;">A directory is a listing of information about some class of objects such as persons. Directories can be used to ﬁnd information about a speciﬁc object, or in the reverse direction to ﬁnd objects that meet a certain requirement. Several <span class="s63">directory access proto- cols </span>have been developed to provide a standardized way of accessing data in a directory. A very widely used distributed directory system is the internet <span class="s63">Domain Name Ser- vice </span>(<span class="s64">DNS</span>) system, which provides a standardized way to map domain names (such as <span class="s49">db-book.com </span>or <span class="s49">www.cs.yale.edu</span>, to the <span class="s44">IP </span>addresses of the machines. (Although users see only the domain names, the underlying network routes messages based on <span class="s44">IP </span>addresses, and hence a way to convert domain names to <span class="s44">IP </span>addresses is critical for</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">the functioning of the internet.) The <span class="s63">Lightweight Directory Access Protocol </span>(<span class="s64">LDAP</span>) is another very widely used protocol designed for storing organizational data.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Data stored in directories can be represented in the relational model, stored in a relational database, and accessed through standard protocols such as <span class="s44">JDBC </span>or <span class="s44">ODBC</span>. The question then is, why come up with a specialized protocol for accessing directory information? There are several reasons.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">First, directory access protocols are simpliﬁed protocols that cater to a limited type of access to data. They evolved in parallel with the database access protocol standards.</span></p><p class="s49" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">Second, directory systems were designed to support a hierarchical naming system for objects, similar to ﬁle system directory names. Such a naming system is im- portant in many applications. For example, all computers whose names end in </span>yale.edu <span class="p">belong to Yale, while those whose names end in </span>iitb.ac.in <span class="p">belong to IIT Bombay. Within the </span>yale.edu <span class="p">domain, there are subdomains such as </span>cs.yale.edu<span class="p">, which corresponds to the CS department in Yale, and </span>math.yale.edu <span class="p">which cor- responds to the Math department at Yale.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Third, and most important from a distributed systems perspective, the data in a distributed directory system are stored and controlled in a distributed, hierarchical, manner.</span></p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">For example, a <span class="s44">DNS </span>server at Yale would store information about names of computers at Yale, along with associated information such as their <span class="s44">IP </span>addresses. Similarly, <span class="s44">DNS </span>servers at Lehigh and IIT Bombay would store information about computers in their respective domains. The <span class="s44">DNS </span>servers store information in a hierarchical fashion; for example, the information provided by the Yale <span class="s44">DNS </span>server may be stored in a distributed fashion across subdomains at Yale, such as the CS and Math <span class="s44">DNS </span>servers.</p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">Distributed directory systems automatically forward queries submitted at a site to the site where the required information is actually stored, to give a uniﬁed view of data to users and applications.</p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">Further, distributed directory implementations typically support replication to ensure the availability of data even if some nodes have failed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Another example of usage of directory systems is for organization data. Such sys- tems store information about employees, such as the employee identiﬁer, name, email, organization unit (such as department), room number, phone number, and (encrypted) password of each employee. The schema of such organizational data are standardized as part of the Lightweight Directory Access Protocol (<span class="s44">LDAP</span>). Directory systems based on the <span class="s44">LDAP </span>protocol are widely used to authenticate users, using the encrypted pass- words stored for each user. (More information about the <span class="s44">LDAP </span>data representation may be found in Section 25.5.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;"><a name="bookmark481">Although distributed data storage across organizational units was important at one time, such directory systems are often centralized these days. In fact, several direc- tory implementations use relational databases to store data, instead of creating special- purpose storage systems. However, the fact that the data representation and protocol to access the data are standardized has meant that these protocols continue to be widely used.</a><a name="bookmark526">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part407.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part409.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
