<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>42.2 Solution #1: The File System Checker</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part465.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part467.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 6pt;padding-left: 11pt;text-indent: 0pt;text-align: justify;">42.2 Solution #1: The File System Checker</p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 92%;text-align: justify;">Early file systems took a simple approach to crash consistency. Basi- cally, they decided to let inconsistencies happen and then fix them later (when rebooting). A classic example of this lazy approach is found in a tool that does this: <b>fsck</b><span class="s35">2</span>. <span class="s41">fsck </span>is a U<span class="s7">NIX </span>tool for finding such inconsis- tencies and repairing them [M86]; similar tools to check and repair a disk</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">partition exist on different systems. Note that such an approach can’t fix all problems; consider, for example, the case above where the file system looks consistent but the inode points to garbage data. The only real goal is to make sure the file system metadata is internally consistent.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">The tool <span class="s41">fsck </span>operates in a number of phases, as summarized in McKusick and Kowalski’s paper [MK96]. It is run <i>before </i>the file system is mounted and made available (<span class="s41">fsck </span>assumes that no other file-system activity is on-going while it runs); once finished, the on-disk file system should be consistent and thus can be made accessible to users.</p><p style="padding-left: 52pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Here is a basic summary of what <span class="s41">fsck </span>does:</p><p class="s4" style="padding-top: 1pt;padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Superblock: </span><span class="s41">fsck </span><span class="p">first checks if the superblock looks reasonable, mostly doing sanity checks such as making sure the file system size is greater than the number of blocks allocated. Usually the goal of these sanity checks is to find a suspect (corrupt) superblock; in this case, the system (or administrator) may decide to use an alternate copy of the superblock.</span></p><p style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><b>Free blocks: </b>Next, <span class="s41">fsck </span>scans the inodes, indirect blocks, double indirect blocks, etc., to build an understanding of which blocks are currently allocated within the file system. It uses this knowledge to produce a correct version of the allocation bitmaps; thus, if there is any inconsistency between bitmaps and inodes, it is resolved by trusting the information within the inodes. The same type of check is performed for all the inodes, making sure that all inodes that look like they are in use are marked as such in the inode bitmaps.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_615.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 92%;text-align: justify;">2<span class="s12">Pronounced either “eff-ess-see-kay”, “eff-ess-check”, or, if you don’t like the tool, “eff- suck”. Yes, serious professional people use this term.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><b>Inode state: </b>Each inode is checked for corruption or other prob- lems. For example, <span class="s41">fsck </span>makes sure that each allocated inode has a valid type field (e.g., regular file, directory, symbolic link, etc.). If there are problems with the inode fields that are not easily fixed, the inode is considered suspect and cleared by <span class="s41">fsck</span>; the inode bitmap is correspondingly updated.</p><p class="s41" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><span class="s27">Inode links: </span>fsck <span class="p">also verifies the link count of each allocated in- ode. As you may recall, the link count indicates the number of dif- ferent directories that contain a reference (i.e., a link) to this par- ticular file. To verify the link count, </span>fsck <span class="p">scans through the en- tire directory tree, starting at the root directory, and builds its own link counts for every file and directory in the file system. If there is a mismatch between the newly-calculated count and that found within an inode, corrective action must be taken, usually by fixing the count within the inode. If an allocated inode is discovered but no directory refers to it, it is moved to the </span>lost+found <span class="p">directory.</span></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: left;">• <span class="s27">Duplicates: </span><span class="s41">fsck </span><span class="p">also checks for duplicate pointers, i.e., cases where two different inodes refer to the same block. If one inode is obvi- ously bad, it may be cleared. Alternately, the pointed-to block could be copied, thus giving each inode its own copy as desired.</span></p><p style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><b>Bad blocks: </b>A check for bad block pointers is also performed while scanning through the list of all pointers. A pointer is considered “bad” if it obviously points to something outside its valid range, e.g., it has an address that refers to a block greater than the parti- tion size. In this case, <span class="s41">fsck </span>can’t do anything too intelligent; it just removes (clears) the pointer from the inode or indirect block.</p><p class="s41" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><span class="s27">Directory checks: </span>fsck <span class="p">does not understand the contents of user files; however, directories hold specifically formatted information created by the file system itself. Thus, </span>fsck <span class="p">performs additional integrity checks on the contents of each directory, making sure that “.” and “..” are the first entries, that each inode referred to in a directory entry is allocated, and ensuring that no directory is linked to more than once in the entire hierarchy.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: right;">As you can see, building a working <span class="s41">fsck </span>requires intricate knowledge of the file system; making sure such a piece of code works correctly in all cases can be challenging [G+08]. However, fsck (and similar approaches) have a bigger and perhaps more fundamental problem: they are <i>too slow</i>. With a very large disk volume, scanning the entire disk to find all the allocated blocks and read the entire directory tree may take many minutes or hours. Performance of <span class="s41">fsck</span>, as disks grew in capacity and RAIDs grew in popularity, became prohibitive (despite recent advances [M+13]). At a higher level, the basic premise of <span class="s41">fsck </span>seems just a tad irra- tional. Consider our example above, where just three blocks are written to the disk; it is incredibly expensive to scan the entire disk to fix prob- lems that occurred during an update of just three blocks. This situation is akin to dropping your keys on the floor in your bedroom, and then com-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">mencing a <i>search-the-entire-house-for-keys </i>recovery algorithm, starting in the basement and working your way through every room. It works but is wasteful. Thus, as disks (and RAIDs) grew, researchers and practitioners started to look for other solutions.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part465.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part467.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
