<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.5  Timestamp-Based Protocols</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part332.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part334.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">18.5  <span style=" color: #00AEEF;">Timestamp-Based Protocols</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The locking protocols that we have described thus far determine the order between ev- ery pair of conﬂicting transactions at execution time by the ﬁrst lock that both members of the pair request that involves incompatible modes. Another method for determining the serializability order is to select an ordering among transactions in advance. The most common method for doing so is to use a <i>timestamp-ordering </i>scheme.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">18.5.1 Timestamps</p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;line-height: 79%;text-align: justify;">With each transaction <i>T</i><span class="s97">i </span>in the system, we associate a unique ﬁxed timestamp, denoted by TS(<i>T</i><span class="s97">i</span>). This timestamp is assigned by the database system before the transaction <i>T</i><span class="s97">i </span>starts execution. If a transaction <i>T</i><span class="s97">i </span>has been assigned timestamp TS(<i>T</i><span class="s97">i</span>), and a new transaction <i>T</i><span class="s145">j </span>enters the system, then TS(<i>T</i><span class="s145">i</span>) <span class="s83">&lt; </span>TS(<i>T</i><span class="s145">j </span>). There are two simple methods for implementing this scheme:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_3018.png"/></span></p><p class="s80" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s77">1</span><span class="s78">The term </span><i>predicate locking </i>was used for a version of the protocol that used shared and exclusive locks on predicates, and was thus more complicated. The version we present here, with only shared locks on predicates, is also referred to as <span class="s162">precision locking</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-top: 4pt;padding-left: 113pt;text-indent: -16pt;text-align: justify;">1. <span class="p">Use the value of the </span>system clock <span class="p">as the timestamp; that is, a transaction’s time- stamp is equal to the value of the clock when the transaction enters the system.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">2. <span class="p">Use a </span>logical counter <span class="p">that is incremented after a new timestamp has been as- signed; that is, a transaction’s timestamp is equal to the value of the counter when the transaction enters the system.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 76%;text-align: justify;">The timestamps of the transactions determine the serializability order. Thus, if TS(<i>T</i><span class="s97">i</span>) <span class="s83">&lt; </span>TS(<i>T</i><span class="s97">j </span>), then the system must ensure that the produced schedule is equivalent to a serial schedule in which transaction <i>T</i><span class="s97">i </span>appears before transaction <i>T</i><span class="s97">j </span>.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">To implement this scheme, we associate with each data item <i>Q </i>two timestamp</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">values:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;text-align: center;"><span class="s63">1. W-timestamp</span>(<i>Q</i>) denotes the largest timestamp of any transaction that executed</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;"><span class="s49">write</span>(<i>Q</i>) successfully.</p><p style="padding-top: 6pt;padding-left: 67pt;text-indent: 0pt;text-align: center;"><span class="s63">2. R-timestamp</span>(<i>Q</i>) denotes the largest timestamp of any transaction that executed</p><p style="padding-left: 18pt;text-indent: 0pt;text-align: center;"><span class="s49">read</span>(<i>Q</i>) successfully.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">These timestamps are updated whenever a new <span class="s49">read</span>(<i>Q</i>) or <span class="s49">write</span>(<i>Q</i>) instruction is executed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">18.5.2 The Timestamp-Ordering Protocol</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">The <span class="s63">timestamp-ordering protocol </span>ensures that any conﬂicting <span class="s49">read </span>and <span class="s49">write </span>operations are executed in timestamp order. This protocol operates as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Suppose that transaction </span><i>T</i><span class="s145">i </span>issues <span class="s49">read</span>(<i>Q</i>).</p><p style="padding-top: 7pt;padding-left: 122pt;text-indent: -8pt;line-height: 70%;text-align: left;"><span class="s50">° </span><span class="s51">If TS(</span><i>T</i><span class="s97">i</span>) <span class="s83">&lt; </span>W-timestamp(<i>Q</i>), then <i>T</i><span class="s97">i </span>needs to read a value of <i>Q </i>that was already overwritten. Hence, the <span class="s49">read </span>operation is rejected, and <i>T</i><span class="s97">i </span>is rolled back.</p><p style="padding-top: 5pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: left;"><span class="s50">° </span><span class="s51">If TS(</span><i>T</i><span class="s145">i</span>) <span class="s86">≥ </span>W-timestamp(<i>Q</i>), then the <span class="s49">read </span>operation is executed, and R- timestamp(<i>Q</i>) is set to the maximum of R-timestamp(<i>Q</i>) and TS(<i>T</i><span class="s145">i</span>).</p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Suppose that transaction </span><i>T</i><span class="s97">i </span>issues <span class="s49">write</span>(<i>Q</i>).</p><p style="padding-top: 6pt;padding-left: 122pt;text-indent: -8pt;line-height: 70%;text-align: left;"><span class="s50">° </span><span class="s51">If TS(</span><i>T</i><span class="s145">i</span>) <span class="s83">&lt; </span>R-timestamp(<i>Q</i>), then the value of <i>Q </i>that <i>T</i><span class="s145">i </span>is producing was needed previously, and the system assumed that that value would never be pro-</p><p style="padding-top: 1pt;padding-left: 122pt;text-indent: 0pt;text-align: left;">duced. Hence, the system rejects the <span class="s49">write </span>operation and rolls <i>T</i><span class="s97">i </span>back.</p><p style="padding-top: 5pt;padding-left: 122pt;text-indent: -8pt;line-height: 70%;text-align: left;"><span class="s50">° </span><span class="s51">If TS(</span><i>T</i><span class="s97">i</span>) <span class="s83">&lt; </span>W-timestamp(<i>Q</i>), then <i>T</i><span class="s97">i </span>is attempting to write an obsolete value of <i>Q</i>. Hence, the system rejects this <span class="s49">write </span>operation and rolls <i>T</i><span class="s145">i </span>back.</p><p style="padding-top: 7pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: left;"><span class="s50">° </span><span class="s51">Otherwise, the system executes the </span><span class="s49">write </span>operation and sets W-time- stamp(<i>Q</i>) to TS(<i>T</i><span class="s97">i</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">If a transaction <i>T</i><span class="s145">i </span>is rolled back by the concurrency-control scheme as result of issuance of either a <span class="s49">read </span>or <span class="s49">write </span>operation, the system assigns it a new timestamp and restarts it.</p><p class="s13" style="padding-left: 137pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p">To illustrate this protocol, we consider transactions </span>T<span class="s130">25 </span><span class="s94">and </span>T<span class="s130">26</span><span class="s94">. Transaction </span>T<span class="s130">25</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: left;">displays the contents of accounts <i>A </i>and <i>B</i>:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;"><i>T</i><span class="s98">25</span>: <span class="s49">read</span>(<i>B</i>);</p><p style="padding-left: 285pt;text-indent: 0pt;text-align: left;"><span class="s49">read</span>(<i>A</i>); <span class="s49">display</span>(<i>A </i>+ <i>B</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">Transaction <i>T</i><span class="s98">26</span> transfers $50 from account <i>B </i>to account <i>A</i>, and then displays the con- tents of both:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 84pt;text-indent: 0pt;text-align: center;"><i>T</i><span class="s98">26</span>: <span class="s49">read</span>(<i>B</i>);</p><p class="s13" style="padding-left: 285pt;text-indent: 0pt;text-align: left;">B <span class="p">:= </span>B <span class="s15">− </span><span class="p">50;</span></p><p style="padding-left: 285pt;text-indent: 0pt;text-align: left;"><span class="s49">write</span>(<i>B</i>);</p><p style="padding-left: 285pt;text-indent: 0pt;text-align: left;"><span class="s49">read</span>(<i>A</i>);</p><p class="s13" style="padding-left: 285pt;text-indent: 0pt;text-align: left;">A <span class="p">:= </span>A <span class="p">+ 50;</span></p><p style="padding-left: 285pt;text-indent: 0pt;text-align: left;"><span class="s49">write</span>(<i>A</i>); <span class="s49">display</span>(<i>A </i>+ <i>B</i>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 92%;text-align: justify;">In presenting schedules under the timestamp protocol, we shall assume that a transac- tion is assigned a timestamp immediately before its ﬁrst instruction. Thus, in schedule 3 of Figure 18.17, TS(<i>T</i><span class="s130">25</span><span class="s94">) </span><span class="s83">&lt; </span>TS(<i>T</i><span class="s130">26</span><span class="s94">), and the schedule is possible under the timestamp</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 8pt;text-align: left;">protocol.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We note that the preceding execution can also be produced by the two-phase lock- ing protocol. There are, however, schedules that are possible under the two-phase lock- ing protocol, but are not possible under the timestamp protocol, and vice versa (see Exercise 18.27).</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The timestamp-ordering protocol ensures conﬂict serializability. This is because conﬂicting operations are processed in timestamp order.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The protocol ensures freedom from deadlock, since no transaction ever waits. How- ever, there is a possibility of starvation of long transactions if a sequence of conﬂict- ing short transactions causes repeated restarting of the long transaction. If a transac- tion is suﬀering from repeated restarts, conﬂicting transactions need to be temporarily blocked to enable the transaction to ﬁnish.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The protocol can generate schedules that are not recoverable. However, it can be extended to make the schedules recoverable, in one of several ways:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Recoverability and cascadelessness can be ensured by performing all writes to- gether at the end of the transaction. The writes must be atomic in the following sense: While the writes are in progress, no transaction is permitted to access any of the data items that have been written.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:195.654pt" cellspacing="0"><tr style="height:18pt"><td style="width:78pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p class="s426" style="padding-top: 2pt;padding-left: 31pt;padding-right: 31pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s352">25</span></p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F" bgcolor="#C6E9FA"><p class="s426" style="padding-top: 2pt;padding-left: 31pt;padding-right: 31pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s352">26</span></p></td></tr><tr style="height:18pt"><td style="width:78pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>B</i>)</p></td><td style="width:78pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:13pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="s424">read</span>(<i>B</i>)</p></td></tr><tr style="height:15pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s71" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">B <span class="s72">:= </span>B <span class="s365">− </span><span class="s72">50</span></p></td></tr><tr style="height:13pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">write</span>(<i>B</i>)</p></td></tr><tr style="height:13pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>A</i>)</p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:13pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">read</span>(<i>A</i>)</p></td></tr><tr style="height:27pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">display</span>(<i>A+ B</i>)</p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s71" style="padding-top: 12pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">A <span class="s72">:= </span>A <span class="s365">+ </span><span class="s72">50</span></p></td></tr><tr style="height:13pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">write</span>(<i>A</i>)</p></td></tr><tr style="height:14pt"><td style="width:78pt;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:78pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p class="s72" style="padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s424">display</span>(<i>A+ B</i>)</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 18.17 <span class="s74">Schedule 3.</span></p><p class="s39" style="padding-top: 6pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Recoverability and cascadelessness can also be guaranteed by using a limited form of locking, whereby reads of uncommitted items are postponed until the transac- tion that updated the item commits (see Exercise 18.28).</span></p><p class="s13" style="padding-top: 5pt;padding-left: 107pt;text-indent: -16pt;line-height: 90%;text-align: justify;"><span class="s39">• </span><span class="s40">Recoverability alone can be ensured by tracking uncommitted writes and allowing a transaction </span>T<span class="s97">i </span><span class="p">to commit only after the commit of any transaction that wrote a value that </span>T<span class="s97">i </span><span class="p">read. Commit dependencies, outlined in Section 18.1.5, can be used for this purpose.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">If the timestamp-ordering protocol is applied only to tuples, the protocol would be vulnerable to the phantom problems that we saw in Section 17.10 and Section 18.4.3. To avoid this problem, the timestamp-ordering protocol could be applied to all data that is read by a transaction, including relation metadata and index data. In the context of locking-based concurrency control, the index-locking protocol, described in Section 18.4.3, is a more eﬃcient alternative for avoiding the phantom problem; recall that the index-locking protocol obtains locks on index nodes, in addition to obtaining locks on tuples. The timestamp-ordering protocol can be similarly modiﬁed to treat each index node as a data item, with associated read and write timestamps, and to apply the timestamp-ordering tests on these data items, too. This extended version of the timestamp-ordering protocol avoids phantom problems and ensures serializability</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">even with predicate reads.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">18.5.3 Thomas’ Write Rule</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We now present a modiﬁcation to the timestamp-ordering protocol that allows greater potential concurrency than does the protocol of Section 18.5.2. Let us consider sched- ule 4 of Figure 18.18 and apply the timestamp-ordering protocol. Since <i>T</i><span class="s98">27</span> starts before</p><p class="s13" style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 70%;text-align: justify;">T<span class="s130">28</span><span class="s94">, we shall assume that TS(</span>T<span class="s130">27</span><span class="s94">) </span><span class="s83">&lt; </span><span class="p">TS(</span>T<span class="s130">28</span><span class="s94">). The </span><span class="s49">read</span><span class="p">(</span>Q<span class="p">) operation of </span>T<span class="s130">27 </span><span class="s94">succeeds, as does the </span><span class="s49">write</span><span class="p">(</span>Q<span class="p">) operation of </span>T<span class="s130">28</span><span class="s94">. When </span>T<span class="s130">27 </span><span class="s94">attempts its </span><span class="s49">write</span><span class="p">(</span>Q<span class="p">) operation,</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:251.634pt" cellspacing="0"><tr style="height:18pt"><td style="width:54pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p class="s426" style="padding-top: 2pt;padding-left: 5pt;padding-right: 6pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s352">27</span></p></td><td style="width:53pt;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F" bgcolor="#C6E9FA"><p class="s426" style="padding-top: 2pt;padding-left: 6pt;padding-right: 6pt;text-indent: 0pt;line-height: 14pt;text-align: center;">T<span class="s352">28</span></p></td></tr><tr style="height:44pt"><td style="width:54pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><span class="s424">read</span>(<i>Q</i>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s72" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span class="s424">write</span>(<i>Q</i>)</p></td><td style="width:53pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s72" style="padding-left: 6pt;padding-right: 6pt;text-indent: 0pt;text-align: center;"><span class="s424">write</span>(<i>Q</i>)</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 250pt;text-indent: 0pt;text-align: left;">Figure 18.18 <span class="s74">Schedule 4.</span></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;line-height: 19pt;text-align: justify;">we ﬁnd that TS(<i>T</i><span class="s130">27</span><span class="s94">) </span><span class="s83">&lt; </span>W-timestamp(<i>Q</i>), since W-timestamp(<i>Q</i>) = TS(<i>T</i><span class="s130">28</span><span class="s94">). Thus, the</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 73%;text-align: justify;"><span class="s49">write</span><span class="p">(</span>Q<span class="p">) by </span>T<span class="s130">27 </span><span class="s94">is rejected and transaction </span>T<span class="s130">27 </span><span class="s94">must be rolled back.</span></p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">Although the rollback of <i>T</i><span class="s98">27</span> is required by the timestamp-ordering protocol, it</p><p class="s13" style="padding-top: 2pt;padding-left: 119pt;text-indent: 0pt;line-height: 66%;text-align: justify;"><span class="p">is unnecessary. Since </span>T<span class="s93">28 </span><span class="s94">has already written </span>Q<span class="p">, the value that </span>T<span class="s93">27 </span><span class="s94">is attempting to write is one that will never need to be read. Any transaction </span>T<span class="s97">i </span><span class="p">with TS(</span>T<span class="s97">i</span><span class="p">) </span><span class="s83">&lt; </span><span class="p">TS(</span>T<span class="s130">28</span><span class="s94">) that attempts a </span><span class="s49">read</span><span class="p">(</span>Q<span class="p">) will be rolled back, since TS(</span>T<span class="s97">i</span><span class="p">) </span><span class="s83">&lt; </span><span class="p">W-timestamp(</span>Q<span class="p">). Any transaction </span>T<span class="s97">j </span><span class="p">with TS(</span>T<span class="s97">j </span><span class="p">) </span><span class="s83">&gt; </span><span class="p">TS(</span>T<span class="s130">28</span><span class="s94">) must read the value of </span>Q <span class="p">written by </span>T<span class="s130">28</span><span class="s94">, rather than the value that </span>T<span class="s130">27 </span><span class="s94">is attempting to write.</span></p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">This observation leads to a modiﬁed version of the timestamp-ordering protocol in</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">which obsolete <span class="s49">write </span>operations can be ignored under certain circumstances. The pro- tocol rules for <span class="s49">read </span>operations remain unchanged. The protocol rules for <span class="s49">write </span>opera- tions, however, are slightly diﬀerent from the timestamp-ordering protocol of Section 18.5.2.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The modiﬁcation to the timestamp-ordering protocol, called <span class="s63">Thomas’ write rule</span>, is this: Suppose that transaction <i>T</i><span class="s97">i </span>issues <span class="s49">write</span>(<i>Q</i>).</p><p style="padding-top: 11pt;padding-left: 145pt;text-indent: -16pt;line-height: 70%;text-align: left;"><span class="s63">1. </span>If TS(<i>T</i><span class="s97">i</span>) <span class="s83">&lt; </span>R-timestamp(<i>Q</i>), then the value of <i>Q </i>that <i>T</i><span class="s97">i </span>is producing was previ- ously needed, and it had been assumed that the value would never be produced.</p><p style="padding-top: 1pt;padding-left: 145pt;text-indent: 0pt;text-align: left;">Hence, the system rejects the <span class="s49">write </span>operation and rolls <i>T</i><span class="s97">i </span>back.</p><p style="padding-top: 1pt;padding-left: 128pt;text-indent: 0pt;line-height: 19pt;text-align: left;"><span class="s63">2. </span>If TS(<i>T</i><span class="s145">i</span>) <span class="s83">&lt; </span>W-timestamp(<i>Q</i>), then <i>T</i><span class="s145">i </span>is attempting to write an obsolete value of</p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><i>Q</i>. Hence, this <span class="s49">write </span>operation can be ignored.</p><p style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: left;"><span class="s63">3. </span>Otherwise, the system executes the <span class="s49">write </span>operation and sets W-timestamp(<i>Q</i>) to TS(<i>T</i><span class="s145">i</span>).</p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The diﬀerence between these rules and those of Section 18.5.2 lies in the sec- ond rule. The timestamp-ordering protocol requires that <i>T</i><span class="s145">i </span>be rolled back if <i>T</i><span class="s145">i </span>issues</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;"><span class="s49">write</span>(<i>Q</i>) and TS(<i>T</i><span class="s145">i</span>) <span class="s83">&lt; </span>W-timestamp(<i>Q</i>). However, here, in those cases where TS(<i>T</i><span class="s145">i</span>)</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: justify;"><span class="s86">≥ </span>R-timestamp(<i>Q</i>), we ignore the obsolete <span class="s49">write</span>.</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">By ignoring the write, Thomas’ write rule allows schedules that are not conﬂict seri-</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">alizable but are nevertheless correct. Those non-conﬂict-serializable schedules allowed satisfy the deﬁnition of <i>view serializable </i>schedules (see Note 18.1 on page 867). Thomas’ write rule makes use of view serializability by, in eﬀect, deleting obsolete <span class="s49">write </span>opera- tions from the transactions that issue them. This modiﬁcation of transactions makes it possible to generate serializable schedules that would not be possible under the other</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><a name="bookmark386">protocols presented in this chapter. For example, schedule 4 of Figure 18.18 is not con- ﬂict serializable and, thus, is not possible under the two-phase locking protocol, the tree protocol, or the timestamp-ordering protocol. Under Thomas’ write rule, the </a><span class="s49">write</span>(<i>Q</i>) operation of <i>T</i><span class="s98">27</span> would be ignored. The result is a schedule that is <i>view equivalent </i>to the<a name="bookmark427">&zwnj;</a></p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 19pt;text-align: justify;"><span class="p">serial schedule </span><span class="s83">&lt;</span>T<span class="s130">27</span><span class="s94">, </span>T<span class="s130">28</span><span class="s83">&gt;</span><span class="p">.</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part332.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part334.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
