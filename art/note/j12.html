<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-04-24 Mon 17:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chapter 12: Network</title>
<meta name="generator" content="Org mode" />
<link rel = "stylesheet" type="text/css" href ="style_for_org.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Chapter 12: Network</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga957f44">1. 网络通信</a>
<ul>
<li><a href="#org0aa774a">1.1. IP</a></li>
<li><a href="#org29e1fd0">1.2. 域名系统 (DNS)</a></li>
<li><a href="#org7943d92">1.3. 网络协议层级</a></li>
<li><a href="#orgc9a3a03">1.4. TCP 和 UDP</a></li>
<li><a href="#orga5952ab">1.5. Socket</a></li>
<li><a href="#orgea6f3a0">1.6. Socket 客户端和服务器</a></li>
<li><a href="#org23c6ce4">1.7. socket 流</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga957f44" class="outline-2">
<h2 id="orga957f44"><span class="section-number-2">1</span> 网络通信</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org0aa774a" class="outline-3">
<h3 id="org0aa774a"><span class="section-number-3">1.1</span> IP</h3>
<div class="outline-text-3" id="text-1-1">
<p>
IP 地址是 Internet Protocol Address 的缩写，指的是网络中设备的标识符。
它是一个由 32 位二进制数字组成的地址，在人类可读的形式下被表示为 4 个
十进制数（每个数在 0-255 之间），用点号分隔开来。
</p>

<p>
IP 地址分为两种类型：IPv4 和 IPv6。IPv4 地址由 32 位二进制数字组成，而
IPv6 地址则由 128 位二进制数字组成。目前，IPv4 地址仍然是互联网上最常
用的地址类型。IPv4 地址共有 4294967296 个，但由于一些保留地址和私有地
址的存在，实际可用的公共 IPv4 地址数量要少得多。
</p>

<p>
IP 地址的作用是唯一地标识连接到 Internet 上的设备，并且它是 Internet
通信过程中的基本单元。每次从一台计算机向另一台计算机发送数据时，数据包
都会携带源 IP 地址和目标 IP 地址，以确保数据传输到正确的设备上。
</p>

<p>
本机地址为: 127.0.0.1
</p>
</div>
</div>

<div id="outline-container-org29e1fd0" class="outline-3">
<h3 id="org29e1fd0"><span class="section-number-3">1.2</span> 域名系统 (DNS)</h3>
<div class="outline-text-3" id="text-1-2">
<p>
DNS 代表域名系统（Domain Name System），是一个用于将易于记忆的域名转换
为 IP 地址的分布式数据库系统。因为互联网上存在数以亿计的设备和计算机，
用 IP 地址来访问它们是不方便的，而且很难记住众多的数字地址。DNS 解决了
这个问题，它允许我们使用易于记忆的域名，例如 <code>www.example.com</code> ，而不是记
住其对应的 IP 地址。
</p>

<p>
当您在浏览器中输入 URL 或域名时，DNS 服务器会将该域名映射到相应的 IP
地址，并将其返回给您的计算机，然后您的计算机可以使用该地址连接到目标服
务器。DNS 系统是一个分层的系统，由许多不同的 DNS 服务器组成，每个 DNS
服务器都存储了一部分域名和 IP 地址的映射关系。当一个 DNS 服务器无法找
到所请求的域名和 IP 地址的映射时，它会向其他 DNS 服务器发送请求，直到
找到匹配的映射为止。
</p>
</div>
</div>

<div id="outline-container-org7943d92" class="outline-3">
<h3 id="org7943d92"><span class="section-number-3">1.3</span> 网络协议层级</h3>
<div class="outline-text-3" id="text-1-3">
<p>
TCP/IP 是一个网络通信协议族，它包含了许多不同的协议，按照功能可以分为四个层级：
</p>

<ol class="org-ol">
<li><b>应用层</b> ：应用层协议处理特定应用程序之间的通信，例如 Web 浏览器、电子
邮件客户端和文件传输协议（FTP）客户端等。常见的应用层协议包括 HTTP、
SMTP、POP3、FTP 等。</li>

<li><b>传输层</b> ：传输层协议负责在源和目标设备之间提供端到端的可靠数据传输服
务。TCP 是最常用的传输层协议，它提供流控制、拥塞控制和错误检测等功
能。另一个传输层协议是用户数据报协议（UDP），它提供无连接的数据传输
服务。</li>

<li><b>网络层</b> ：网络层协议负责在互联网上路由数据包，确保它们到达正确的目标。
IP协议是最常用的网络层协议，它定义了网络地址和路由选择，并将传输层
的数据封装在 IP 数据包中以进行传输。</li>

<li><b>链路层(网络接口层)</b> ：链路层协议负责在物理网络上传输数据帧。它确保
数据从一个网络节点传输到下一个网络节点，并提供对物理层面的控制和管
理。常见的链路层协议包括以太网和 Wi-Fi。</li>
</ol>

<p>
总之，TCP/IP 协议族是一个四层网络通信协议体系结构，它包括了应用层、传
输层、网络层和链路层。不同层级的协议协同工作，为数据在网络中的传输提供
了完整的解决方案。
</p>
</div>
</div>

<div id="outline-container-orgc9a3a03" class="outline-3">
<h3 id="orgc9a3a03"><span class="section-number-3">1.4</span> TCP 和 UDP</h3>
<div class="outline-text-3" id="text-1-4">
<p>
TCP 是在传输层的东西. TCP 是最常用的传输层协议，它提供 <b>流控制、拥塞控制 和错误检测</b> 等功能。另一个传输层协议是用户数据报协议（UDP），它提供无连
接的数据传输服务.
</p>

<p>
UDP 是用户数据报协议（User Datagram Protocol）的缩写。它是一种无连接协
议，用于在计算机网络上发送数据包。相对于 TCP 协议，UDP 协议具有更快的
传输速度，但是不保证数据包的 <b>可靠性和顺序性</b> 。因此，在某些应用场景中，如
实时音视频传输、在线游戏等，UDP 协议更为适用。
</p>
</div>
</div>

<div id="outline-container-orga5952ab" class="outline-3">
<h3 id="orga5952ab"><span class="section-number-3">1.5</span> Socket</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Socket（套接字）是一种在计算机网络中进行进程间通信或传输数据的机制。它
提供了一种标准的接口，使得应用程序能够通过网络协议与其他应用程序进行通
信。
</p>

<p>
Socket 有两个部分组成, 1. <span class="underline">IP地址</span>; 2. <span class="underline">端口号</span>.
</p>

<p>
Socket 通常被用于实现客户端 / 服务器模型，其中服务器监听来自客户端的连
接请求，并向客户端提供服务。客户端则通过 Socket 与服务器建立连接并发送
请求，以获取服务响应。
</p>

<p>
在编程中，Socket 可以使用各种编程语言和网络库进行实现。常见的 Socket
类型有 TCP Socket 和 UDP Socket。
</p>




<p>
在局域网中 <b>多</b> 台计算机可能共享同一个公网IP地址，这是通过网络地址转换
技术（NAT）实现的。NAT技术允许多台计算机共享同一个公网IP地址，从而节省
了有限的IPv4地址资源。当使用NAT技术时， <b>路由器</b> 会在转发数据包时修改
数据包中的源IP地址和源端口号，以便外部网络可以正确地将响应数据发送回路
由器。
</p>

<p>
当路由器接收到来自外部网络的响应数据时，它会根据之前保存的NAT映射表，
将数据包中的目的IP地址和目的端口号修改为内部网络中计算机的IP地址和端口
号，然后将数据包 <b>转发</b> 给内部网络中的计算机。因此，在使用NAT技术时，
外部网络无法直接根据IP地址和端口号确定数据来自或发送给内部网络中的哪台
计算机。只有路由器才能根据NAT映射表确定数据来自或发送给内部网络中的哪
台计算机
</p>
</div>
</div>

<div id="outline-container-orgea6f3a0" class="outline-3">
<h3 id="orgea6f3a0"><span class="section-number-3">1.6</span> Socket 客户端和服务器</h3>
<div class="outline-text-3" id="text-1-6">
<p>
当然可以，以下是一个简单的 Java Socket 客户端和服务器端通信的例子：
</p>

<p>
Server.java:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">IOException</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">net</span>.<span style="color: #df005f; font-weight: bold;">ServerSocket</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">net</span>.<span style="color: #df005f; font-weight: bold;">Socket</span>;

<span style="color: #268bd2; font-weight: bold;">public</span> <span style="color: #268bd2; font-weight: bold;">class</span> <span style="color: #df005f; font-weight: bold;">Server</span> {
    <span style="color: #268bd2; font-weight: bold;">public</span> <span style="color: #268bd2; font-weight: bold;">static</span> <span style="color: #df005f; font-weight: bold;">void</span> <span style="color: #d75fd7; font-weight: bold;">main</span>(<span style="color: #df005f; font-weight: bold;">String</span>[] <span style="color: #8787d7;">args</span>) <span style="color: #268bd2; font-weight: bold;">throws</span> <span style="color: #df005f; font-weight: bold;">IOException</span> {
        <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">port</span> = 12345;
        <span style="color: #df005f; font-weight: bold;">ServerSocket</span> <span style="color: #8787d7;">serverSocket</span> = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">ServerSocket</span>(port);
        System.out.println(<span style="color: #2aa198;">"Server started on port "</span> + port);

        <span style="color: #268bd2; font-weight: bold;">while</span> (<span style="color: #d75fd7;">true</span>) {
            <span style="color: #df005f; font-weight: bold;">Socket</span> <span style="color: #8787d7;">socket</span> = serverSocket.accept();
            System.out.println(<span style="color: #2aa198;">"New client connected: "</span> + socket.getInetAddress().getHostAddress());

            <span style="color: #df005f; font-weight: bold;">ClientHandler</span> <span style="color: #8787d7;">clientHandler</span> = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">ClientHandler</span>(socket);
            clientHandler.start();
        }
    }
}
</pre>
</div>
<p>
ClientHandler.java:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">BufferedReader</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">IOException</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">InputStreamReader</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">PrintWriter</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">net</span>.<span style="color: #df005f; font-weight: bold;">Socket</span>;

<span style="color: #268bd2; font-weight: bold;">public</span> <span style="color: #268bd2; font-weight: bold;">class</span> <span style="color: #df005f; font-weight: bold;">ClientHandler</span> <span style="color: #268bd2; font-weight: bold;">extends</span> <span style="color: #df005f; font-weight: bold;">Thread</span> {
    <span style="color: #268bd2; font-weight: bold;">private</span> <span style="color: #268bd2; font-weight: bold;">final</span> <span style="color: #df005f; font-weight: bold;">Socket</span> <span style="color: #8787d7;">socket</span>;
    <span style="color: #268bd2; font-weight: bold;">private</span> <span style="color: #df005f; font-weight: bold;">BufferedReader</span> <span style="color: #8787d7;">input</span>;
    <span style="color: #268bd2; font-weight: bold;">private</span> <span style="color: #df005f; font-weight: bold;">PrintWriter</span> <span style="color: #8787d7;">output</span>;

    <span style="color: #268bd2; font-weight: bold;">public</span> <span style="color: #d75fd7; font-weight: bold;">ClientHandler</span>(<span style="color: #df005f; font-weight: bold;">Socket</span> <span style="color: #8787d7;">socket</span>) {
        <span style="color: #268bd2; font-weight: bold;">this</span>.socket = socket;
    }

    <span style="color: #d75fd7;">@Override</span>
    <span style="color: #268bd2; font-weight: bold;">public</span> <span style="color: #df005f; font-weight: bold;">void</span> <span style="color: #d75fd7; font-weight: bold;">run</span>() {
        <span style="color: #268bd2; font-weight: bold;">try</span> {
            input = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">BufferedReader</span>(<span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">InputStreamReader</span>(socket.getInputStream()));
            output = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">PrintWriter</span>(socket.getOutputStream(), <span style="color: #d75fd7;">true</span>);

            <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">message</span>;
            <span style="color: #268bd2; font-weight: bold;">while</span> ((message = input.readLine()) != <span style="color: #d75fd7;">null</span>) {
                System.out.println(<span style="color: #2aa198;">"Received message from client: "</span> + message);
                output.println(<span style="color: #2aa198;">"Echo: "</span> + message);
            }
        } <span style="color: #268bd2; font-weight: bold;">catch</span> (<span style="color: #df005f; font-weight: bold;">IOException</span> <span style="color: #8787d7;">e</span>) {
            System.err.println(<span style="color: #2aa198;">"Error handling client: "</span> + e.getMessage());
        } <span style="color: #268bd2; font-weight: bold;">finally</span> {
            <span style="color: #268bd2; font-weight: bold;">try</span> {
                socket.close();
            } <span style="color: #268bd2; font-weight: bold;">catch</span> (<span style="color: #df005f; font-weight: bold;">IOException</span> <span style="color: #8787d7;">e</span>) {
                System.err.println(<span style="color: #2aa198;">"Error closing socket: "</span> + e.getMessage());
            }
        }
    }
}
</pre>
</div>

<p>
Client.java:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">BufferedReader</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">IOException</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">InputStreamReader</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">io</span>.<span style="color: #df005f; font-weight: bold;">PrintWriter</span>;
<span style="color: #268bd2; font-weight: bold;">import</span> <span style="color: #d75fd7;">java</span>.<span style="color: #d75fd7;">net</span>.<span style="color: #df005f; font-weight: bold;">Socket</span>;

<span style="color: #268bd2; font-weight: bold;">public</span> <span style="color: #268bd2; font-weight: bold;">class</span> <span style="color: #df005f; font-weight: bold;">Client</span> {
    <span style="color: #268bd2; font-weight: bold;">public</span> <span style="color: #268bd2; font-weight: bold;">static</span> <span style="color: #df005f; font-weight: bold;">void</span> <span style="color: #d75fd7; font-weight: bold;">main</span>(<span style="color: #df005f; font-weight: bold;">String</span>[] <span style="color: #8787d7;">args</span>) <span style="color: #268bd2; font-weight: bold;">throws</span> <span style="color: #df005f; font-weight: bold;">IOException</span> {
        <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">host</span> = <span style="color: #2aa198;">"localhost"</span>;
        <span style="color: #df005f; font-weight: bold;">int</span> <span style="color: #8787d7;">port</span> = 12345;

        <span style="color: #df005f; font-weight: bold;">Socket</span> <span style="color: #8787d7;">socket</span> = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">Socket</span>(host, port);
        System.out.println(<span style="color: #2aa198;">"Connected to server on "</span> + host + <span style="color: #2aa198;">":"</span> + port);

        <span style="color: #df005f; font-weight: bold;">BufferedReader</span> <span style="color: #8787d7;">input</span> = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">BufferedReader</span>(<span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">InputStreamReader</span>(System.in));
        <span style="color: #df005f; font-weight: bold;">BufferedReader</span> <span style="color: #8787d7;">serverInput</span> = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">BufferedReader</span>(<span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">InputStreamReader</span>(socket.getInputStream()));
        <span style="color: #df005f; font-weight: bold;">PrintWriter</span> <span style="color: #8787d7;">output</span> = <span style="color: #268bd2; font-weight: bold;">new</span> <span style="color: #df005f; font-weight: bold;">PrintWriter</span>(socket.getOutputStream(), <span style="color: #d75fd7;">true</span>);

        <span style="color: #df005f; font-weight: bold;">String</span> <span style="color: #8787d7;">message</span>;
        <span style="color: #268bd2; font-weight: bold;">while</span> ((message = input.readLine()) != <span style="color: #d75fd7;">null</span>) {
            output.println(message);
            System.out.println(<span style="color: #2aa198;">"Received from server: "</span> + serverInput.readLine());
        }

        socket.close();
    }
}
</pre>
</div>

<p>
这个例子中，服务器程序在端口 12345 上监听客户端连接请求。每当有一个新
的客户端连接时，它会启动一个新的线程来处理该客户端的请求。客户端程序通
过 IP 地址和端口号连接到服务器，并输入要发送的消息。在服务器程序中，新
的线程接收到客户端发送的消息并将其打印到控制台上，然后将其作为回显发送
给客户端。
</p>
</div>
</div>


<div id="outline-container-org23c6ce4" class="outline-3">
<h3 id="org23c6ce4"><span class="section-number-3">1.7</span> socket 流</h3>
<div class="outline-text-3" id="text-1-7">
<p>
<code>sock.getInputStream();</code> 就能够得到一个 input 流, 这是用来从服务器处读
取数据用的. 然后又, <code>sock.getOutputStream()</code> 能够到的一个 output 流,
用来向 socket 里面写数据的.
</p>

<p>
我们常用 BufferedReader 来封装这个 input, 使用 PrintWriter 来封装这个
output 流.</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2023-04-24 Mon 17:08</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>