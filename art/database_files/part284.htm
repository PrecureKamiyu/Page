<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>15.5  Join Operation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part283.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part285.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">15.5  <span style=" color: #00AEEF;">Join Operation</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In this section, we study several algorithms for computing the join of relations, and we analyze their respective costs.</p><p class="s169" style="padding-top: 1pt;padding-left: 106pt;text-indent: 0pt;line-height: 66%;text-align: justify;"><span class="p">We use the term </span><span class="s63">equi-join </span><span class="p">to refer to a join of the form </span><span class="s13">r </span><span class="s86">⋈</span>r<span class="s170">.</span>A<span class="s171">=</span>s<span class="s170">.</span>B <span class="s168">s</span><span class="p">, where </span><span class="s13">A </span><span class="p">and </span><span class="s13">B</span></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">are attributes or sets of attributes of relations <i>r </i>and <i>s</i>, respectively.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">We use as a running example the expression:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 60pt;text-indent: 0pt;text-align: center;">student <span class="s86">⋈ </span>takes</p><p style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">using the same relation schemas that we used in Chapter 2. We assume the following information about the two relations:</p><p class="s13" style="padding-top: 10pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Number of records of </span>student<span class="p">: </span>n<span class="s97">student </span><span class="s15">= </span><span class="p">5000.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Number of blocks of </span>student<span class="p">: </span>b<span class="s97">student </span><span class="s15">= </span><span class="p">100.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Number of records of </span>takes<span class="p">: </span>n<span class="s97">takes </span><span class="s15">= </span><span class="p">10, 000.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">Number of blocks of </span>takes<span class="p">: </span>b<span class="s97">takes </span><span class="s15">= </span><span class="p">400.</span></p><p class="s68" style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">15.5.1 Nested-Loop Join</p><p style="padding-top: 5pt;padding-left: 88pt;text-indent: 0pt;line-height: 93%;text-align: justify;">Figure 15.5 shows a simple algorithm to compute the theta join, <i>r </i><span class="s86">⋈</span><span class="s136">θ </span><i>s</i>, of two relations <i>r </i>and <i>s</i>. This algorithm is called the <span class="s63">nested-loop join </span>algorithm, since it basically consists of a pair of nested <b>for </b>loops. Relation <i>r </i>is called the <span class="s63">outer relation </span>and relation <i>s </i>the</p><p class="s13" style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 88%;text-align: justify;"><span class="s63">inner relation </span><span class="p">of the join, since the loop for </span>r <span class="p">encloses the loop for </span>s<span class="p">. The algorithm uses the notation </span>t<span class="s145">r </span><span class="s86">⋅ </span>t<span class="s145">s</span><span class="p">, where </span>t<span class="s145">r </span><span class="p">and </span>t<span class="s145">s </span><span class="p">are tuples; </span>t<span class="s145">r </span><span class="s86">⋅ </span>t<span class="s145">s </span><span class="p">denotes the tuple constructed by concatenating the attribute values of tuples </span>t<span class="s97">r </span><span class="p">and </span>t<span class="s97">s</span><span class="p">.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Like the linear ﬁle-scan algorithm for selection, the nested-loop join algorithm re-</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="p">quires no indices, and it can be used regardless of what the join condition is. Extending the algorithm to compute the natural join is straightforward, since the natural join can be expressed as a theta join followed by elimination of repeated attributes by a projec- tion. The only change required is an extra step of deleting repeated attributes from the tuple </span>t<span class="s145">r </span><span class="s86">⋅ </span>t<span class="s145">s</span><span class="p">, before adding it to the result.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">The nested-loop join algorithm is expensive, since it examines every pair of tuples</p><p class="s13" style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 93%;text-align: justify;"><span class="p">in the two relations. Consider the cost of the nested-loop join algorithm. The number of pairs of tuples to be considered is </span>n<span class="s97">r </span><span class="s15">∗ </span>n<span class="s97">s</span><span class="p">, where </span>n<span class="s97">r </span><span class="p">denotes the number of tuples in </span>r<span class="p">, and </span>n<span class="s97">s </span><span class="p">denotes the number of tuples in </span>s<span class="p">. For each record in </span>r<span class="p">, we have to perform</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2768.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 5pt;padding-left: 186pt;text-indent: -11pt;line-height: 87%;text-align: left;">for each <span class="p">tuple </span><i>t</i><span class="s97">r </span>in <i>r </i>do begin for each <span class="p">tuple </span><i>t</i><span class="s145">s </span>in <i>s </i>do begin</p><p style="padding-left: 201pt;text-indent: 0pt;line-height: 12pt;text-align: left;">test pair (<i>t</i><span class="s145">r </span>, <i>t</i><span class="s145">s</span>) to see if they satisfy the join condition <span class="s15">θ</span></p><p class="s13" style="padding-left: 201pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p">if they do, add </span>t<span class="s145">r </span><span class="s86">⋅ </span>t<span class="s145">s </span><span class="p">to the result;</span></p><p class="s46" style="padding-left: 174pt;text-indent: 11pt;text-align: left;">end end</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2769.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 240pt;text-indent: 0pt;text-align: left;">Figure 15.5 <span class="s74">Nested-loop join.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;"><span class="p">a complete scan on </span>s<span class="p">. In the worst case, the buﬀer can hold only one block of each relation, and a total of </span>n<span class="s97">r </span><span class="s15">∗ </span>b<span class="s97">s </span><span class="s15">+ </span>b<span class="s97">r </span><span class="p">block transfers would be required, where </span>b<span class="s97">r </span><span class="p">and </span>b<span class="s97">s </span><span class="p">denote the number of blocks containing tuples of </span>r <span class="p">and </span>s<span class="p">, respectively. We need only one seek for each scan on the inner relation </span>s <span class="p">since it is read sequentially, and a total of </span>b<span class="s145">r </span><span class="p">seeks to read </span>r<span class="p">, leading to a total of </span>n<span class="s145">r </span><span class="s15">+ </span>b<span class="s145">r </span><span class="p">seeks. In the best case, there is enough</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 93%;text-align: justify;"><span class="p">space for both relations to ﬁt simultaneously in memory, so each block would have to be read only once; hence, only </span>b<span class="s97">r </span><span class="s15">+ </span>b<span class="s97">s </span><span class="p">block transfers would be required, along with two seeks.</span></p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;"><span class="p">If one of the relations ﬁts entirely in main memory, it is beneﬁcial to use that relation as the inner relation, since the inner relation would then be read only once. Therefore, if </span>s <span class="p">is small enough to ﬁt in main memory, our strategy requires only a total </span>b<span class="s145">r </span><span class="s15">+ </span>b<span class="s145">s </span><span class="p">block transfers and two seeks — the same cost as that for the case where both relations ﬁt in memory.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Now consider the natural join of <i>student </i>and <i>takes</i>. Assume for now that we have no indices whatsoever on either relation, and that we are not willing to create any index. We can use the nested loops to compute the join; assume that <i>student </i>is the outer relation and <i>takes </i>is the inner relation in the join. We will have to examine 5000</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s15">∗ </span>10,000 = 50 <span class="s15">∗ </span>10<span class="s76">6</span> pairs of tuples. In the worst case, the number of block transfers is 5000 <span class="s15">∗ </span>400 <span class="s15">+ </span>100 <span class="s15">= </span>2,000,100, plus 5000 <span class="s15">+ </span>100 <span class="s15">= </span>5100 seeks. In the best-case scenario, however, we can read both relations only once and perform the computation. This computation requires at most 100 <span class="s15">+ </span>400 <span class="s15">= </span>500 block transfers, plus two seeks</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">— a signiﬁcant improvement over the worst-case scenario. If we had used <i>takes </i>as the relation for the outer loop and <i>student </i>for the inner loop, the worst-case cost of our ﬁnal strategy would have been 10,000 <span class="s15">∗ </span>100 <span class="s15">+ </span>400 <span class="s15">= </span>1,000,400 block transfers, plus 10,400 disk seeks. The number of block transfers is signiﬁcantly less, and although the number of seeks is higher, the overall cost is reduced, assuming <i>t</i><span class="s145">S </span><span class="s15">= </span>4 milliseconds</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 17pt;text-align: justify;">and <i>t</i><span class="s145">T </span><span class="s15">= </span>0<span class="s83">.</span>1 milliseconds.</p><p class="s68" style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">15.5.2 Block Nested-Loop Join</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">If the buﬀer is too small to hold either relation entirely in memory, we can still obtain a major saving in block accesses if we process the relations on a per-block basis, rather</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">than on a per-tuple basis. Figure 15.6 shows <span class="s63">block nested-loop join</span>, which is a variant of the nested-loop join where every block of the inner relation is paired with every block of the outer relation. Within each pair of blocks, every tuple in one block is paired with every tuple in the other block, to generate all pairs of tuples. As before, all pairs of tuples that satisfy the join condition are added to the result.</p><p class="s13" style="padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="p">The primary diﬀerence in cost between the block nested-loop join and the basic nested-loop join is that, in the worst case, each block in the inner relation </span>s <span class="p">is read only once for each </span>block <span class="p">in the outer relation, instead of once for each </span>tuple <span class="p">in the outer relation. Thus, in the worst case, there will be a total of </span>b<span class="s145">r </span><span class="s15">∗ </span>b<span class="s145">s </span><span class="p">+ </span>b<span class="s145">r </span><span class="p">block transfers, where </span>b<span class="s145">r </span><span class="p">and </span>b<span class="s145">s </span><span class="p">denote the number of blocks containing records of </span>r <span class="p">and </span>s<span class="p">, respectively. Each scan of the inner relation requires one seek, and the scan of the outer relation requires one seek per block, leading to a total of 2 </span><span class="s15">∗ </span>b<span class="s97">r </span><span class="p">seeks. It is more eﬃcient to use the smaller relation as the outer relation, in case neither of the relations ﬁts in</span></p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 94%;text-align: justify;"><span class="p">memory. In the best case, where the inner relation ﬁts in memory, there will be </span>b<span class="s97">r </span><span class="s15">+ </span>b<span class="s97">s </span><span class="p">block transfers and just two seeks (we would choose the smaller relation as the inner relation in this case).</span></p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 93%;text-align: justify;">Now return to our example of computing <i>student </i><span class="s86">⋈ </span><i>takes</i>, using the block nested- loop join algorithm. In the worst case, we have to read each block of <i>takes </i>once for each block of <i>student</i>. Thus, in the worst case, a total of 100 <span class="s15">∗ </span>400 <span class="s15">+ </span>100 <span class="s15">= </span>40,100 block</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">transfers plus 2 <span class="s15">∗ </span>100 <span class="s15">= </span>200 seeks are required. This cost is a signiﬁcant improvement over the 5000 <span class="s15">∗ </span>400 <span class="s15">+ </span>100 <span class="s15">= </span>2,000,100 block transfers plus 5100 seeks needed in the worst case for the basic nested-loop join. The best-case cost remains the same— namely, 100 <span class="s15">+ </span>400 <span class="s15">= </span>500 block transfers and two seeks.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The performance of the nested-loop and block nested-loop procedures can be fur- ther improved:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2770.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 5pt;padding-left: 145pt;text-indent: -12pt;line-height: 87%;text-align: left;">for each <span class="p">block </span><i>B</i><span class="s97">r </span>of <i>r </i>do begin for each <span class="p">block </span><i>B</i><span class="s145">s </span>of <i>s </i>do begin</p><p class="s46" style="padding-left: 172pt;text-indent: -11pt;line-height: 90%;text-align: left;">for each <span class="p">tuple </span><i>t</i><span class="s145">r </span>in <i>B</i><span class="s145">r </span>do begin for each <span class="p">tuple </span><i>t</i><span class="s145">s </span>in <i>B</i><span class="s145">s </span>do begin</p><p class="s13" style="padding-left: 187pt;text-indent: 0pt;line-height: 78%;text-align: left;"><span class="p">test pair (</span>t<span class="s97">r </span><span class="p">, </span>t<span class="s97">s</span><span class="p">) to see if they satisfy the join condition if they do, add </span>t<span class="s97">r </span><span class="s86">⋅ </span>t<span class="s97">s </span><span class="p">to the result;</span></p><p class="s46" style="padding-left: 172pt;text-indent: 0pt;line-height: 12pt;text-align: left;">end</p><p class="s46" style="padding-left: 160pt;text-indent: 0pt;text-align: left;">end</p><p class="s46" style="padding-left: 133pt;text-indent: 12pt;text-align: left;">end end</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2771.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 15.6 <span class="s74">Block nested-loop join.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">If the join attributes in a natural join or an equi-join form a key on the inner rela- tion, then for each outer relation tuple the inner loop can terminate as soon as the ﬁrst match is found.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">In the block nested-loop algorithm, instead of using disk blocks as the blocking unit for the outer relation, we can use the biggest size that can ﬁt in memory, while leaving enough space for the buﬀers of the inner relation and the output. In other words, if memory has </span>M <span class="p">blocks, we read in </span>M <span class="s15">− </span><span class="p">2 blocks of the outer relation at a time, and when we read each block of the inner relation we join it with all the </span>M <span class="s15">− </span><span class="p">2 blocks of the outer relation. This change reduces the number of scans of</span></p><p style="padding-left: 280pt;text-indent: 0pt;line-height: 0pt;text-align: left;"><span class="s15">∕</span>(<i>M </i><span class="s15">− </span>2) , where <i>b </i>is the number of blocks of</p><p class="s15" style="text-indent: 0pt;text-align: left;">∗</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">the outer relation. The total cost is then <span class="s15">⌈</span><i>b</i><span class="s145">r</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;line-height: 12pt;text-align: left;">(<i>M</i></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;line-height: 12pt;text-align: left;">2)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="text-indent: 0pt;line-height: 14pt;text-align: left;">b<span class="s145">s</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="text-indent: 0pt;line-height: 14pt;text-align: left;">b<span class="s145">r </span><span class="p">block transfers</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 139pt;text-indent: 0pt;line-height: 15pt;text-align: left;">the inner relation from <i>b</i><span class="s97">r </span>to <span class="s15">⌈</span><i>b</i><span class="s97">r</span></p><p class="s15" style="padding-left: 41pt;text-indent: 0pt;line-height: 25pt;text-align: left;"><span class="s248">⌉ </span>∕ − <span class="s374">r </span>⌉   +</p><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-left: 30pt;text-indent: 0pt;line-height: 6pt;text-align: center;">∕<span class="p">(</span><span class="s13">M </span>− <span class="p">2) seeks.</span></p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 38%;text-align: left;">and 2<span class="s15">⌈</span><i>b</i><span class="s145">r</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">We can scan the inner loop alternately forward and backward. This scanning method orders the requests for disk blocks so that the data remaining in the buﬀer from the previous scan can be reused, thus reducing the number of disk accesses needed.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">If an index is available on the inner loop’s join attribute, we can replace ﬁle scans with more eﬃcient index lookups. Section 15.5.3 describes this optimization.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">15.5.3 Indexed Nested-Loop Join</p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;line-height: 94%;text-align: right;">In a nested-loop join (Figure 15.5), if an index is available on the inner loop’s join attribute, index lookups can replace ﬁle scans. For each tuple <i>t</i><span class="s97">r </span>in the outer relation <i>r</i>, the index is used to look up tuples in <i>s </i>that will satisfy the join condition with tuple <i>t</i><span class="s97">r </span>. This join method is called an <span class="s63">indexed nested-loop join</span>; it can be used with existing indices, as well as with temporary indices created for the sole purpose of evaluating the</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">join.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 83%;text-align: justify;">Looking up tuples in <i>s </i>that will satisfy the join conditions with a given tuple <i>t</i><span class="s145">r </span>is essentially a selection on <i>s</i>. For example, consider <i>student </i><span class="s86">⋈ </span><i>takes</i>. Suppose that we have a <i>student </i>tuple with <span class="s69">ID </span>“00128”. Then, the relevant tuples in <i>takes </i>are those that</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">satisfy the selection “<span class="s69">ID </span>= 00128”.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The cost of an indexed nested-loop join can be computed as follows: For each tuple in the outer relation <i>r</i>, a lookup is performed on the index for <i>s</i>, and the relevant tuples are retrieved. In the worst case, there is space in the buﬀer for only one block of <i>r </i>and one block of the index. Then, <i>b</i><span class="s145">r </span><span class="s42">I/O </span><span class="s43">operations are needed to read relation </span><i>r</i>, where <i>b</i><span class="s145">r </span>denotes the number of blocks containing records of <i>r</i>; each <span class="s44">I/O </span>requires a seek and a</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;"><span class="p">block transfer, since the disk head may have moved in between each </span><span class="s44">I/O</span><span class="p">. For each tuple in </span>r<span class="p">, we perform an index lookup on </span>s<span class="p">. Then, the cost of the join can be computed as </span>b<span class="s97">r </span><span class="p">(</span>t<span class="s97">T </span><span class="s15">+ </span>t<span class="s97">S</span><span class="p">) </span><span class="s15">+ </span>n<span class="s97">r </span><span class="s15">∗ </span>c<span class="p">, where </span>n<span class="s97">r </span><span class="p">is the number of records in relation </span>r<span class="p">, and </span>c <span class="p">is the cost of a single selection on </span>s <span class="p">using the join condition. We have seen in Section 15.3 how to estimate the cost of a single selection algorithm (possibly using indices); that estimate gives us the value of </span>c<span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">The cost formula indicates that, if indices are available on both relations <i>r </i>and <i>s</i>, it is generally most eﬃcient to use the one with fewer tuples as the outer relation.</p><p class="s13" style="padding-left: 87pt;text-indent: 0pt;line-height: 14pt;text-align: right;"><span class="p">For example, consider an indexed nested-loop join of </span>student <span class="s86">⋈ </span>takes<span class="p">, with </span>student</p><p style="text-indent: 0pt;line-height: 12pt;text-align: right;">as the outer relation. Suppose also that <i>takes </i>has a clustering B<span class="s181">+</span>-tree index on the join</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">attribute <span class="s69">ID</span>, which contains 20 entries on average in each index node. Since <i>takes </i>has 10,000 tuples, the height of the tree is 4, and one more access is needed to ﬁnd the actual data. Since <i>n</i><span class="s145">student </span>is 5000, the total cost is 100 <span class="s15">+ </span>5000 <span class="s15">∗ </span>5 <span class="s15">= </span>25,100 disk accesses, each of which requires a seek and a block transfer. In contrast, as we saw before, 40,100 block transfers plus 200 seeks were needed for a block nested-loop join.</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Although the number of block transfers has been reduced, the seek cost has actually increased, increasing the total cost since a seek is considerably more expensive than a block transfer. However, if we had a selection on the <i>student </i>relation that reduces the number of rows signiﬁcantly, indexed nested-loop join could be signiﬁcantly faster than block nested-loop join.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">15.5.4 Merge Join</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <span class="s63">merge-join </span>algorithm (also called the <span class="s63">sort-merge-join </span>algorithm) can be used to compute natural joins and equi-joins. Let <i>r</i>(<i>R</i>) and <i>s</i>(<i>S</i>) be the relations whose natural join is to be computed, and let <i>R </i><span class="s15">∩ </span><i>S </i>denote their common attributes. Suppose that both relations are sorted on the attributes <i>R </i><span class="s15">∩ </span><i>S</i>. Then, their join can be computed by a process much like the merge stage in the merge–sort algorithm.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">15.5.4.1 Merge-Join Algorithm</p><p class="s13" style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;line-height: 92%;text-align: justify;"><span class="p">Figure 15.7 shows the merge-join algorithm. In the algorithm, </span>JoinAttrs <span class="p">refers to the attributes in </span>R <span class="s15">∩ </span>S<span class="p">, and </span>t<span class="s97">r </span><span class="s86">⋈ </span>t<span class="s97">s</span><span class="p">, where </span>t<span class="s97">r </span><span class="p">and </span>t<span class="s97">s </span><span class="p">are tuples that have the same values for </span>JoinAttrs<span class="p">, denotes the concatenation of the attributes of the tuples, followed by project- ing out repeated attributes. The merge-join algorithm associates one pointer with each</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">relation. These pointers point initially to the ﬁrst tuple of the respective relations. As the algorithm proceeds, the pointers move through the relation. A group of tuples of one relation with the same value on the join attributes is read into <i>S</i><span class="s97">s</span>. The algorithm</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 79%;text-align: justify;">in Figure 15.7 <i>requires </i>that every set of tuples <i>S</i><span class="s97">s </span>ﬁt in main memory; we discuss ex-</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">tensions of the algorithm to avoid this requirement shortly. Then, the corresponding</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">tuples (if any) of the other relation are read in and are processed as they are read.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Figure 15.8 shows two relations that are sorted on their join attribute <i>a</i>1. It is instructive to go through the steps of the merge-join algorithm on the relations shown in the ﬁgure.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 94%;text-align: justify;">The merge-join algorithm of Figure 15.7 requires that each set <i>S</i><span class="s97">s </span>of all tuples with the same value for the join attributes must ﬁt in main memory. This requirement can usually be met, even if the relation <i>s </i>is large. If there are some join attribute values for</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2772.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 182pt;text-indent: 0pt;text-align: left;">pr <span class="p">:= address of ﬁrst tuple of </span>r<span class="p">; </span>ps <span class="p">:= address of ﬁrst tuple of </span>s<span class="p">;</span></p><p style="padding-left: 194pt;text-indent: -12pt;line-height: 86%;text-align: left;"><b>while </b>(<i>ps </i><span class="s86">≠ </span>null <b>and </b><i>pr </i><span class="s86">≠ </span>null) <b>do begin</b></p><p class="s13" style="padding-left: 204pt;text-indent: 0pt;line-height: 14pt;text-align: left;">t<span class="s97">s </span><span class="p">:= tuple to which </span>ps <span class="p">points;</span></p><p class="s13" style="padding-left: 204pt;text-indent: 0pt;line-height: 13pt;text-align: left;">S<span class="s97">s </span><span class="p">:= </span><span class="s95">{</span>t<span class="s97">s</span><span class="s95">}</span><span class="p">;</span></p><p style="padding-left: 204pt;text-indent: 0pt;line-height: 12pt;text-align: left;">set <i>ps </i>to point to next tuple of <i>s</i>;</p><p class="s13" style="padding-left: 204pt;text-indent: 0pt;line-height: 12pt;text-align: left;">done <span class="p">:= </span>false<span class="p">;</span></p><p class="s46" style="padding-left: 216pt;text-indent: -12pt;line-height: 86%;text-align: left;">while <span class="p">(</span>not <i>done </i>and <i>ps </i><span class="s86">≠ </span><span class="p">null) </span>do begin</p><p class="s13" style="padding-left: 226pt;text-indent: 0pt;line-height: 14pt;text-align: left;">t<span class="s145">s</span><span class="s375">′ </span><span class="p">:= tuple to which </span>ps <span class="p">points;</span></p><p style="padding-left: 226pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><b>if </b>(<i>t</i><span class="s97">s</span><span class="s375">′</span>[<i>JoinAttrs</i>] <span class="s15">= </span><i>t</i><span class="s97">s</span>[<i>JoinAttrs</i>])</p><p class="s46" style="padding-left: 26pt;text-indent: 0pt;line-height: 11pt;text-align: center;">then begin</p><p class="s13" style="padding-left: 84pt;text-indent: 0pt;line-height: 15pt;text-align: center;">S<span class="s97">s </span><span class="p">:= </span>S<span class="s97">s </span><span class="s15">∪ </span><span class="s95">{</span>t<span class="s97">s</span><span class="s375">′</span><span class="s95">}</span><span class="p">;</span></p><p style="padding-left: 182pt;text-indent: 0pt;line-height: 12pt;text-align: center;">set <i>ps </i>to point to next tuple of s;</p><p class="s46" style="padding-left: 39pt;text-indent: 0pt;text-align: center;">end</p><p class="s13" style="padding-left: 53pt;text-indent: 0pt;text-align: center;"><b>else </b>done <span class="p">:= </span>true<span class="p">;</span></p><p class="s46" style="padding-left: 216pt;text-indent: 0pt;text-align: left;">end</p><p class="s13" style="padding-left: 204pt;text-indent: 0pt;line-height: 13pt;text-align: left;">t<span class="s97">r </span><span class="p">:= tuple to which </span>pr <span class="p">points;</span></p><p style="padding-top: 1pt;padding-left: 216pt;text-indent: -12pt;line-height: 70%;text-align: left;"><b>while </b>(<i>pr </i><span class="s86">≠ </span>null <b>and </b><i>t</i><span class="s97">r </span>[<i>JoinAttrs</i>] <span class="s83">&lt; </span><i>t</i><span class="s97">s</span>[<i>JoinAttrs</i>]) <b>do begin</b></p><p style="padding-top: 1pt;padding-left: 226pt;text-indent: 0pt;text-align: left;">set <i>pr </i>to point to next tuple of <i>r</i>; <i>t</i><span class="s97">r </span>:= tuple to which <i>pr </i>points;</p><p class="s46" style="padding-left: 216pt;text-indent: 0pt;line-height: 10pt;text-align: left;">end</p><p style="padding-top: 1pt;padding-left: 216pt;text-indent: -12pt;line-height: 85%;text-align: left;"><b>while </b>(<i>pr </i><span class="s86">≠ </span>null <b>and </b><i>t</i><span class="s145">r </span>[<i>JoinAttrs</i>] <span class="s15">= </span><i>t</i><span class="s145">s</span>[<i>JoinAttrs</i>]) <b>do begin</b></p><p class="s46" style="padding-top: 1pt;padding-left: 234pt;text-indent: -8pt;line-height: 87%;text-align: left;">for each <i>t</i><span class="s97">s </span>in <i>S</i><span class="s97">s </span>do begin</p><p class="s13" style="padding-left: 243pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="p">add </span>t<span class="s97">s </span><span class="s86">⋈ </span>t<span class="s97">r </span><span class="p">to result;</span></p><p class="s46" style="padding-left: 234pt;text-indent: 0pt;line-height: 12pt;text-align: left;">end</p><p style="padding-left: 226pt;text-indent: 0pt;text-align: left;">set <i>pr </i>to point to next tuple of <i>r</i>; <i>t</i><span class="s145">r </span>:= tuple to which <i>pr </i>points;</p><p class="s46" style="padding-left: 216pt;text-indent: 0pt;line-height: 11pt;text-align: left;">end</p><p class="s46" style="padding-left: 7pt;text-indent: 0pt;text-align: center;">end<span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2773.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 252pt;text-indent: 0pt;text-align: left;">Figure 15.7 <span class="s74">Merge join.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 87%;text-align: justify;">which <i>S</i><span class="s97">s </span>is larger than available memory, a block nested-loop join can be performed for such sets <i>S</i><span class="s97">s</span>, matching them with corresponding blocks of tuples in <i>r </i>with the same values for the join attributes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 83pt;text-indent: 0pt;line-height: 11pt;text-align: center;">a1 a2       a1 a3</p><table style="border-collapse:collapse" cellspacing="0"><tr style="height:17pt"><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">a</p></td><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 2pt;padding-left: 2pt;text-indent: 0pt;text-align: center;">3</p></td></tr><tr style="height:15pt"><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 5pt;text-indent: 0pt;line-height: 11pt;text-align: left;">b</p></td><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 2pt;text-indent: 0pt;line-height: 11pt;text-align: center;">1</p></td></tr><tr style="height:15pt"><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 4pt;text-indent: 0pt;line-height: 12pt;text-align: left;">d</p></td><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 2pt;text-indent: 0pt;line-height: 12pt;text-align: center;">8</p></td></tr><tr style="height:14pt"><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 4pt;text-indent: 0pt;line-height: 12pt;text-align: left;">d</p></td><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-right: 2pt;text-indent: 0pt;line-height: 12pt;text-align: center;">13</p></td></tr><tr style="height:15pt"><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">f</p></td><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;text-align: center;">7</p></td></tr><tr style="height:16pt"><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">m</p></td><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 2pt;padding-left: 2pt;text-indent: 0pt;text-align: center;">5</p></td></tr><tr style="height:15pt"><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">q</p></td><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;text-align: center;">6</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"/><table style="border-collapse:collapse" cellspacing="0"><tr style="height:17pt"><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 1pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">a</p></td><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-top: 1pt;text-indent: 0pt;text-align: center;">A</p></td></tr><tr style="height:15pt"><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">b</p></td><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 1pt;text-indent: 0pt;text-align: center;">G</p></td></tr><tr style="height:15pt"><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">c</p></td><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="text-indent: 0pt;text-align: center;">L</p></td></tr><tr style="height:14pt"><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">d</p></td><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="text-indent: 0pt;text-align: center;">N</p></td></tr><tr style="height:14pt"><td style="width:15pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">m</p></td><td style="width:16pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-left-style:solid;border-left-width:1pt;border-left-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20;border-right-style:solid;border-right-width:1pt;border-right-color:#231F20" bgcolor="#C7EAFB"><p class="s373" style="text-indent: 0pt;text-align: center;">B</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-bottom: 1pt;padding-left: 12pt;text-indent: 0pt;line-height: 11pt;text-align: center;">pr        ps</p><p class="s376" style="padding-left: 205pt;text-indent: 0pt;line-height: 4pt;text-align: left;"><span><img width="31" height="5" alt="image" src="Image_2774.png"/></span>	<span><img width="31" height="5" alt="image" src="Image_2775.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 118pt;text-indent: 0pt;text-align: center;">s</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-top: 7pt;text-indent: 0pt;text-align: center;">r</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 15.8 <span class="s74">Sorted relations for merge join.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If either of the input relations <i>r </i>and <i>s </i>is not sorted on the join attributes, they can be sorted ﬁrst, and then the merge-join algorithm can be used. The merge-join algorithm can also be easily extended from natural joins to the more general case of equi-joins.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">15.5.4.2 Cost Analysis</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Once the relations are in sorted order, tuples with the same value on the join attributes are in consecutive order. Thereby, each tuple in the sorted order needs to be read only once, and, as a result, each block is also read only once. Since it makes only a single pass through both ﬁles (assuming all sets <i>S</i><span class="s97">s </span>ﬁt in memory), the merge-join method is</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">eﬃcient; the number of block transfers is equal to the sum of the number of blocks in</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="p">both ﬁles, </span>b<span class="s97">r </span><span class="s15">+ </span>b<span class="s97">s</span><span class="p">.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Assuming that <i>b</i><span class="s97">b </span>buﬀer blocks are allocated to each relation, the number of disk</p><p class="s15" style="padding-left: 213pt;text-indent: 0pt;line-height: 0pt;text-align: left;">∕<span class="s13">b </span>+ <span class="s13">b </span>∕<span class="s13">b </span><span class="p">disk seeks. Since seeks are much more</span></p><p class="s15" style="padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p">seeks required would be </span>⌈<span class="s13">b</span><span class="s145">r  b</span>⌉  ⌈ <span class="s123">s</span><span class="s13"> </span><span class="s123">b</span>⌉</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;line-height: 76%;text-align: justify;">expensive than data transfer, it makes sense to allocate multiple buﬀer blocks to each relation, provided extra memory is available. For example, with <i>t</i><span class="s145">T </span><span class="s15">= </span>0<span class="s83">.</span>1 milliseconds per 4-kilobyte block, and <i>t</i><span class="s97">S </span><span class="s15">= </span>4 milliseconds, the buﬀer size is 400 blocks (or 1.6</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">megabytes), so the seek time would be 4 milliseconds for every 40 milliseconds of</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">transfer time; in other words, seek time would be just 10 percent of the transfer time.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If either of the input relations <i>r </i>and <i>s </i>is not sorted on the join attributes, they must be sorted ﬁrst; the cost of sorting must then be added to the above costs. If some sets <i>S</i><span class="s145">s </span>do not ﬁt in memory, the cost would increase slightly.</p><p class="s13" style="padding-left: 87pt;text-indent: 0pt;line-height: 12pt;text-align: right;"><span class="p">Suppose the merge-join scheme is applied to our example of </span>student <span class="s86">⋈ </span>takes<span class="p">.</span></p><p style="text-indent: 0pt;line-height: 12pt;text-align: right;">The join attribute here is <span class="s69">ID</span>. Suppose that the relations are already sorted on the join</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">attribute <span class="s69">ID</span>. In this case, the merge join takes a total of 400<span class="s15">+</span>100 <span class="s15">= </span>500 block transfers. If we assume that in the worst case only one buﬀer block is allocated to each input relation (that is, <i>b</i><span class="s97">b </span><span class="s15">= </span>1), a total of 400 <span class="s15">+ </span>100 <span class="s15">= </span>500 seeks would also be required; in reality <i>b</i><span class="s145">b </span>can be set much higher since we need to buﬀer blocks for only two relations, and the seek cost would be signiﬁcantly less.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: left;">Suppose the relations are not sorted, and the memory size is the worst case, only three blocks. The cost is as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 128pt;text-indent: 0pt;line-height: 12pt;text-align: left;">1. <span class="p">Using the formulae that we developed in Section 15.4, we can see that sorting</span></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-left: 297pt;text-indent: 0pt;line-height: 6pt;text-align: left;">∕<span class="p">3) </span>= <span class="p">8 merge passes. Sorting of relation</span></p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 38%;text-align: left;">relation <i>takes </i>requires <span class="s15">⌈</span>log<span class="s377">3</span><span class="s171">−</span><span class="s93">1</span><span class="s94">(400</span></p><p style="text-indent: 0pt;text-align: left;">400 more transfers to write out the result. The number of seeks required is 2 <span class="s15">∗</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌈</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 145pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><i>takes </i>then takes 400 <span class="s15">∗ </span>(2</p><p style="text-indent: 0pt;text-align: left;">log</p><p class="s119" style="padding-top: 5pt;text-indent: 0pt;text-align: left;">3<span class="s118">−</span>1</p><p style="text-indent: 0pt;line-height: 13pt;text-align: left;">(400<span class="s15">∕</span>3)</p><p class="s15" style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: left;">+ <span class="p">1), or 6800, block transfers, with</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">∕<span class="p">3</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 5pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">⌈<span class="p">400</span></p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">+ <span class="p">400 </span>∗ <span class="p">(2 </span>∗ <span class="p">8 </span>− <span class="p">1) or 6268 seeks for sorting, and 400 seeks for writing</span></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">the output, for a total of 6668 seeks, since only one buﬀer block is available for each run.</p><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 2pt;padding-left: 128pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s63">2. </span>Similarly, sorting relation <i>student </i>takes <span class="s15">⌈</span>log<span class="s291">3</span><span class="s136">−</span><span class="s130">1</span><span class="s94">(100</span></p><p class="s15" style="padding-top: 2pt;text-indent: 0pt;line-height: 12pt;text-align: left;">∕<span class="p">3)</span></p><p class="s15" style="padding-top: 2pt;padding-left: 7pt;text-indent: 0pt;line-height: 12pt;text-align: left;">= <span class="p">6 merge passes and</span></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌈</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: right;">100 <span class="s15">∗ </span>(2</p><p style="text-indent: 0pt;line-height: 12pt;text-align: left;">log<span class="s291">3</span><span class="s136">−</span><span class="s130">1</span></p><p style="text-indent: 0pt;line-height: 12pt;text-align: left;">(100<span class="s15">∕</span>3)</p><p class="s15" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">+ <span class="p">1), or 1300, block transfers, with 100 more transfers</span></p><p class="s15" style="text-indent: 0pt;text-align: left;">∕<span class="p">3 </span>+</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: right;">⌈<span class="p">100 </span>⌉</p><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;">to write it out. The number of seeks required for sorting <i>student </i>is 2 <span class="s15">∗</span></p><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;">100 <span class="s15">∗ </span>(2 <span class="s15">∗ </span>6 <span class="s15">− </span>1) <span class="s15">= </span>1168, and 100 seeks are required for writing the output, for a total of 1268 seeks.</p><p style="padding-top: 5pt;padding-left: 145pt;text-indent: -17pt;text-align: left;"><span class="s63">3. </span>Finally, merging the two relations takes 400 <span class="s15">+ </span>100 <span class="s15">= </span>500 block transfers and 500 seeks.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">Thus, the total cost is 9100 block transfers plus 8932 seeks if the relations are not sorted, and the memory size is just 3 blocks.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: left;">With a memory size of 25 blocks, and the relations not sorted, the cost of sorting followed by merge join would be as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 128pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s63">1. </span>Sorting the relation <i>takes </i>can be done with just one merge step and takesa total</p><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌈</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;">of just 400 <span class="s15">∗ </span>(2 log<span class="s98">24</span>(400<span class="s15">∕</span>25) <span class="s15">+ </span>1) = 1200 block transfers. Similarly, sorting</p><p class="s13" style="padding-left: 145pt;text-indent: 0pt;line-height: 1pt;text-align: left;">student</p><p style="padding-left: 178pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">takes 300 block transfers. Writing the sorted output to disk requires 400</p><p class="s15" style="padding-left: 145pt;text-indent: 0pt;text-align: justify;">+ <span class="p">100 </span>= <span class="p">500 block transfers, and the merge step requires 500 block transfers to read the data back. Adding up these costs gives a total cost of 2500 block transfers.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 128pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">2. <span class="p">If we assume that only one buﬀer block is allocated for each run, the number of</span></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌈    ⌉          <span class="s353">⌈    ⌉</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 145pt;text-indent: 0pt;line-height: 12pt;text-align: left;">seeks required in this case is 2 <span class="s15">∗ </span>400<span class="s15">∕</span>25 <span class="s15">+ </span>400 <span class="s15">+ </span>400 <span class="s15">= </span>832 seeks for sorting</p><p style="padding-left: 145pt;text-indent: 0pt;text-align: justify;"><i>takes </i>and writing the sorted output to disk, and similarly 2 <span class="s15">∗ </span>100<span class="s15">∕</span>25 <span class="s15">+ </span>100 <span class="s15">+ </span>100 <span class="s15">= </span>208 for <i>student</i>, plus 400 <span class="s15">+ </span>100 seeks for reading the sorted data in the merge-join step. Adding up these costs gives a total cost of 1640 seeks.</p><p style="padding-left: 145pt;text-indent: 14pt;text-align: justify;">The number of seeks can be signiﬁcantly reduced by setting aside more buﬀer blocks for each run. For example, if 5 buﬀer blocks are allocated for each run and for the output from merging the 4 runs of <i>student</i>, the cost is reduced to</p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 0pt;text-align: left;">2 <span class="s15">∗  </span>100<span class="s15">∕</span>25 <span class="s15">+  </span>100<span class="s15">∕</span>5 <span class="s15">+  </span>100<span class="s15">∕</span>5  <span class="s15">= </span>48 seeks, from 208 seeks. If the merge-</p><p class="s15" style="text-indent: 0pt;text-align: left;">+</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 145pt;text-indent: 0pt;line-height: 25pt;text-align: left;">join <span class="s248">⌈</span>step sets<span class="s248">⌉</span>asid<span class="s248">⌈</span>e 12 bl<span class="s248">⌉</span>ock<span class="s248">⌈</span>s each f<span class="s248">⌉</span>or buﬀering <i>takes </i>and <i>student</i>, the number</p><p class="s15" style="text-indent: 0pt;text-align: left;">⌈</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌈</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;">of seeks for the merge-join step goes down to 400<span class="s15">∕</span>12   100<span class="s15">∕</span>12 <span class="s15">= </span>43, from</p><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;">500. The total number of seeks is then 251.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Thus, the total cost is 2500 block transfers plus 251 seeks if the relations are not sorted, and the memory size is 25 blocks.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">15.5.4.3 Hybrid Merge Join</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: right;">It is possible to perform a variation of the merge-join operation on unsorted tuples, if secondary indices exist on both join attributes. The algorithm scans the records through the indices, resulting in their being retrieved in sorted order. This variation presents a signiﬁcant drawback, however, since records may be scattered throughout the ﬁle blocks. Hence, each tuple access could involve accessing a disk block, and that is costly. To avoid this cost, we can use a hybrid merge-join technique that combines indices with merge join. Suppose that one of the relations is sorted; the other is unsorted, but has a secondary B<span class="s181">+</span>-tree index on the join attributes. The <span class="s63">hybrid merge-join algorithm </span>merges the sorted relation with the leaf entries of the secondary B<span class="s181">+</span>-tree index. The result ﬁle contains tuples from the sorted relation and addresses for tuples of the un- sorted relation. The result ﬁle is then sorted on the addresses of tuples of the unsorted relation, allowing eﬃcient retrieval of the corresponding tuples, in physical storage or- der, to complete the join. Extensions of the technique to handle two unsorted relations</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">are left as an exercise for you.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">15.5.5 Hash Join</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Like the merge-join algorithm, the hash-join algorithm can be used to implement natu- ral joins and equi-joins. In the hash-join algorithm, a hash function <i>h </i>is used to partition tuples of both relations. The basic idea is to partition the tuples of each of the relations into sets that have the same hash value on the join attributes.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">We assume that:</p><p style="padding-top: 10pt;padding-left: 91pt;text-indent: 0pt;line-height: 16pt;text-align: left;"><span class="s39">• </span><i>h </i>is a hash function mapping <i>JoinAttrs </i>values to <span class="s15">{</span>0, 1, <span class="s15">… </span>, <i>n</i><span class="s145">h</span><span class="s15">}</span>, where <i>JoinAttrs</i></p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">denotes the common attributes of <i>r </i>and <i>s </i>used in the natural join.</p><p class="s106" style="text-indent: 0pt;line-height: 6pt;text-align: left;">h</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s39">• </span>r<span class="s130">0</span><span class="s94">, </span>r<span class="s130">1</span><span class="s94">, </span><span class="s15">… </span><span class="p">, </span>r<span class="s97">n </span><span class="p">denote partitions of </span>r <span class="p">tuples, each initially empty. Each tuple </span>t<span class="s97">r </span><span class="s15">∈ </span>r</p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;text-align: left;"><span class="p">is put in partition </span>r<span class="s97">i</span><span class="p">, where </span>i <span class="s15">= </span>h<span class="p">(</span>t<span class="s97">r </span><span class="p">[</span>JoinAttrs<span class="p">]).</span></p><p class="s106" style="text-indent: 0pt;line-height: 6pt;text-align: left;">h</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-top: 1pt;padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s39">• </span>s<span class="s130">0</span><span class="s94">, </span>s<span class="s130">1</span><span class="s94">, </span><span class="s83">...</span><span class="p">, </span>s<span class="s97">n </span><span class="p">denote partitions of </span>s <span class="p">tuples, each initially empty. Each tuple </span>t<span class="s97">s </span><span class="s15">∈ </span>s <span class="p">is</span></p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;text-align: left;"><span class="p">put in partition </span>s<span class="s97">i</span><span class="p">, where </span>i <span class="s15">= </span>h<span class="p">(</span>t<span class="s97">s</span><span class="p">[</span>JoinAttrs<span class="p">]).</span></p><p style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The hash function <i>h </i>should have the “goodness” properties of randomness and uni- formity that we discussed in Chapter 14. Figure 15.9 depicts the partitioning of the relations.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">15.5.5.1 Basics</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The idea behind the hash-join algorithm is this: Suppose that an <i>r </i>tuple and an <i>s </i>tuple satisfy the join condition; then, they have the same value for the join attributes. If that value is hashed to some value <i>i</i>, the <i>r </i>tuple has to be in <i>r</i><span class="s97">i </span>and the <i>s </i>tuple in <i>s</i><span class="s97">i</span>. Therefore,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="243" height="215" alt="image" src="Image_2776.png"/></span></p><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">0</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">0</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">.</p><p class="s185" style="text-indent: 0pt;text-align: left;">.</p><p class="s185" style="text-indent: 0pt;text-align: left;">.</p><p class="s185" style="text-indent: 0pt;line-height: 12pt;text-align: left;">.</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="text-indent: 0pt;line-height: 11pt;text-align: left;">s</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="text-indent: 0pt;line-height: 11pt;text-align: left;">r</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">4</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">4</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s185" style="padding-left: 1pt;text-indent: 0pt;text-align: center;">.</p><p class="s185" style="padding-left: 1pt;text-indent: 0pt;text-align: center;">.</p><p class="s185" style="padding-left: 1pt;text-indent: 0pt;text-align: center;">.</p><p class="s185" style="padding-left: 1pt;text-indent: 0pt;text-align: center;">.</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="padding-top: 1pt;padding-left: 272pt;text-indent: -12pt;line-height: 81%;text-align: left;">partitions of <span class="s69">r</span></p><p class="s185" style="padding-top: 1pt;padding-left: 31pt;text-indent: -12pt;line-height: 81%;text-align: left;">partitions of <span class="s69">s</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 211pt;text-indent: 0pt;text-align: left;">Figure 15.9 <span class="s74">Hash partitioning of relations.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 87%;text-align: justify;">r <span class="p">tuples in </span>r<span class="s97">i </span><span class="p">need only be compared with </span>s <span class="p">tuples in </span>s<span class="s97">i</span><span class="p">; they do not need to be compared with </span>s <span class="p">tuples in any other partition.</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 94%;text-align: justify;">For example, if <i>d </i>is a tuple in <i>student</i>, <i>c </i>a tuple in <i>takes</i>, and <i>h </i>a hash function on the <span class="s69">ID </span>attributes of the tuples, then <i>d </i>and <i>c </i>must be tested only if <i>h</i>(<i>c</i>) <span class="s15">= </span><i>h</i>(<i>d</i>). If <i>h</i>(<i>c</i>) <span class="s86">≠ </span><i>h</i>(<i>d</i>), then <i>c </i>and <i>d </i>must have diﬀerent values for <span class="s69">ID</span>. However, if <i>h</i>(<i>c</i>) <span class="s15">= </span><i>h</i>(<i>d</i>), we must test <i>c </i>and <i>d </i>to see whether the values in their join attributes are the same, since it is possible that <i>c </i>and <i>d </i>have diﬀerent <i>iid</i>s that have the same hash value.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 90%;text-align: justify;">Figure 15.10 shows the details of the <span class="s63">hash-join </span>algorithm to compute the natural join of relations <i>r </i>and <i>s</i>. As in the merge-join algorithm, <i>t</i><span class="s97">r </span><span class="s86">⋈ </span><i>t</i><span class="s97">s </span>denotes the concatena- tion of the attributes of tuples <i>t</i><span class="s145">r </span>and <i>t</i><span class="s145">s</span>, followed by projecting out repeated attributes. After the partitioning of the relations, the rest of the hash-join code performs a sepa- rate indexed nested-loop join on each of the partition pairs <i>i</i>, for <i>i </i><span class="s15">= </span>0, <span class="s15">… </span>, <i>n</i><span class="s145">h</span>. To do so, it ﬁrst <span class="s63">builds </span>a hash index on each <i>s</i><span class="s97">i</span>, and then <span class="s63">probes </span>(that is, looks up <i>s</i><span class="s97">i</span>) with tuples from <i>r</i><span class="s97">i</span>. The relation <i>s </i>is the <span class="s63">build input</span>, and <i>r </i>is the <span class="s63">probe input</span>.</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 79%;text-align: justify;">The hash index on <i>s</i><span class="s97">i </span>is built in memory, so there is no need to access the disk to</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">retrieve the tuples. The hash function used to build this hash index must be diﬀerent</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">from the hash function <i>h </i>used earlier, but it is still applied to only the join attributes. In the course of the indexed nested-loop join, the system uses this hash index to retrieve records that match records in the probe input.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The build and probe phases require only a single pass through both the build and probe inputs. It is straightforward to extend the hash-join algorithm to compute general equi-joins.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 89%;text-align: justify;">The value <i>n</i><span class="s97">h </span>must be chosen to be large enough such that, for each <i>i</i>, the tuples in the partition <i>s</i><span class="s145">i </span>of the build relation, along with the hash index on the partition, ﬁt in memory. It is not necessary for the partitions of the probe relation to ﬁt in memory. It is</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2777.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 161pt;text-indent: 0pt;text-align: left;">/* Partition <i>s </i>*/</p><p class="s46" style="padding-left: 161pt;text-indent: 0pt;line-height: 14pt;text-align: left;">for each <span class="p">tuple </span><i>t</i><span class="s145">s </span>in <i>s </i>do begin</p><p class="s13" style="padding-left: 169pt;text-indent: 0pt;line-height: 11pt;text-align: left;">i <span class="p">:= </span>h<span class="p">(</span>t<span class="s145">s</span><span class="p">[</span>JoinAttrs<span class="p">]);</span></p><p class="s13" style="padding-top: 2pt;padding-left: 119pt;text-indent: 0pt;line-height: 81%;text-align: right;">H<span class="s145">s</span><span class="s378">i</span></p><p class="s46" style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: right;">end</p><p style="padding-left: 1pt;text-indent: 0pt;text-align: left;">:= <i>H</i><span class="s145">s</span><span class="s378">i</span></p><p class="s95" style="padding-left: 1pt;text-indent: 0pt;text-align: left;"><span class="s15">∪ </span>{<span class="s13">t</span><span class="s145">s</span>}<span class="p">;</span></p><p style="padding-left: 161pt;text-indent: 0pt;text-align: left;">/* Partition <i>r </i>*/</p><p class="s46" style="padding-left: 161pt;text-indent: 0pt;line-height: 14pt;text-align: left;">for each <span class="p">tuple </span><i>t</i><span class="s97">r </span>in <i>r </i>do begin</p><p class="s13" style="padding-left: 169pt;text-indent: 0pt;line-height: 11pt;text-align: left;">i <span class="p">:= </span>h<span class="p">(</span>t<span class="s97">r </span><span class="p">[</span>JoinAttrs<span class="p">]);</span></p><p class="s13" style="padding-left: 169pt;text-indent: 0pt;line-height: 15pt;text-align: left;">H<span class="s97">r</span><span class="s378">i </span><span class="p">:= </span>H<span class="s97">r</span><span class="s378">i </span><span class="s15">∪ </span><span class="s95">{</span>t<span class="s97">r </span><span class="s95">}</span><span class="p">;</span></p><p class="s46" style="padding-left: 161pt;text-indent: 0pt;line-height: 12pt;text-align: left;">end</p><p style="padding-left: 161pt;text-indent: 0pt;text-align: left;">/* Perform join on each partition */</p><p class="s46" style="padding-left: 161pt;text-indent: 0pt;line-height: 14pt;text-align: left;">for <i>i </i><span class="p">:= 0 </span>to <i>n</i><span class="s97">h </span>do begin</p><p style="padding-left: 169pt;text-indent: 0pt;line-height: 81%;text-align: left;">read <i>H</i><span class="s145">s</span><span class="s378">i </span>and build an in-memory hash index on it;</p><p class="s46" style="padding-left: 169pt;text-indent: 0pt;line-height: 81%;text-align: left;">for each <span class="p">tuple </span><i>t</i><span class="s145">r </span>in <i>H</i><span class="s145">r</span><span class="s378">i </span>do begin</p><p style="padding-left: 178pt;text-indent: 0pt;line-height: 79%;text-align: left;">probe the hash index on <i>H</i><span class="s97">s</span><span class="s378">i </span>to locate all tuples <i>t</i><span class="s97">s</span></p><p class="s13" style="padding-left: 178pt;text-indent: 8pt;line-height: 82%;text-align: left;"><span class="p">such that </span>t<span class="s97">s</span><span class="p">[</span>JoinAttrs<span class="p">] </span><span class="s15">= </span>t<span class="s97">r </span><span class="p">[</span>JoinAttrs<span class="p">]; </span><b>for each </b><span class="p">matching tuple </span>t<span class="s97">s </span><b>in </b>H<span class="s97">s</span><span class="s378">i </span><b>do begin </b><span class="p">add </span>t<span class="s97">r </span><span class="s86">⋈ </span>t<span class="s97">s </span><span class="p">to the result;</span></p><p class="s46" style="padding-left: 178pt;text-indent: 0pt;line-height: 11pt;text-align: left;">end</p><p class="s46" style="padding-left: 161pt;text-indent: 8pt;text-align: left;">end end</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_2778.png"/></span></p><p class="s73" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 15.10 <span class="s74">Hash join.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;text-align: left;">∕<span class="s13">M</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 88pt;text-indent: 0pt;text-align: center;">best to use the smaller input relation as the build relation. If the size of the build relation is <i>b</i><span class="s97">s </span>blocks, then, for each of the <i>n</i><span class="s97">h </span>partitions to be of size less than or equal to <i>M </i>, <i>n</i><span class="s97">h</span></p><p class="s15" style="padding-left: 59pt;text-indent: 0pt;line-height: 12pt;text-align: center;"><span class="p">must be at least </span>⌈<span class="s13">b</span><span class="s145">s  </span>⌉<span class="p">. More precisely stated, we have to account for the extra space</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">occupied by the hash index on the partition as well, so <i>n</i><span class="s145">h </span>should be correspondingly larger. For simplicity, we sometimes ignore the space requirement of the hash index in our analysis.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">15.5.5.2 Recursive Partitioning</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">If the value of <i>n</i><span class="s145">h </span>is greater than or equal to the number of blocks of memory, the rela- tions cannot be partitioned in one pass, since there will not be enough buﬀer blocks. Instead, partitioning has to be done in repeated passes. In one pass, the input can be split into at most as many partitions as there are blocks available for use as output</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">buﬀers. Each bucket generated by one pass is separately read in and partitioned again in the next pass, to create smaller partitions. The hash function used in a pass is dif- ferent from the one used in the previous pass. The system repeats this splitting of the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">input until each partition of the build input ﬁts in memory. Such partitioning is called</p><p class="s63" style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">recursive partitioning<span class="p">.</span></p><p class="s15" style="text-indent: 0pt;text-align: left;">√</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-top: 2pt;padding-left: 119pt;text-indent: 17pt;line-height: 69%;text-align: justify;"><span class="p">A relation does not need recursive partitioning if </span>M <span class="s83">&gt;</span><u> </u>n<span class="s97">h </span><span class="s15">+ </span><span class="p">1, or equivalently </span>M <span class="s83">&gt; </span><span class="p">(</span>b<span class="s97">s</span><span class="s15">∕</span>M <span class="p">)</span><span class="s15">+</span><span class="p">1, which simpliﬁes (approximately) to </span>M <span class="s83">&gt;  </span>b<span class="s97">s</span><span class="p">. For example, consider a memory size of 12 megabytes, divided into 4-kilobyte blocks; it would contain a total</span></p><p class="s15" style="text-indent: 0pt;text-align: left;">√</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 119pt;text-indent: 0pt;line-height: 106%;text-align: justify;">of 3-kilobyte (3072) blocks. We can use a memory of this size to partition relations of size up to 3-kilobyte <span class="s15">∗ </span>3-kilobyte bl<u>ocks, </u>which is 36 gigabytes. Similarly, a relation of size 1 gigabyte requires just over  256K blocks, or 2 megabytes, to avoid recursive partitioning.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">15.5.5.3 Handling of Overﬂows</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s63">Hash-table overﬂow </span>occurs in partition <i>i </i>of the build relation <i>s </i>if the hash index on <i>s</i><span class="s145">i </span>is larger than main memory. Hash-table overﬂow can occur if there are many tuples in the build relation with the same values for the join attributes, or if the hash function does not have the properties of randomness and uniformity. In either case, some of the partitions will have more tuples than the average, whereas others will have fewer;</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">partitioning is then said to be <span class="s63">skewed</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We can handle a small amount of skew by increasing the number of partitions so that the expected size of each partition (including the hash index on the partition) is somewhat less than the size of memory. The number of partitions is therefore increased by a small value, called the <span class="s63">fudge factor</span>, that is usually about 20 percent of the number of hash partitions computed as described in Section 15.5.5.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Even if, by using a fudge factor, we are conservative on the sizes of the partitions, overﬂows can still occur. Hash-table overﬂows can be handled by either <i>overﬂow reso- lution </i>or <i>overﬂow avoidance</i>. <span class="s63">Overﬂow resolution </span>is performed during the build phase if a hash-index overﬂow is detected. Overﬂow resolution proceeds in this way: If <i>s</i><span class="s145">i</span>, for any <i>i</i>, is found to be too large, it is further partitioned into smaller partitions by using</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 87%;text-align: justify;">a diﬀerent hash function. Similarly, <i>r</i><span class="s97">i </span>is also partitioned using the new hash function, and only tuples in the matching partitions need to be joined.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In contrast, <span class="s63">overﬂow avoidance </span>performs the partitioning carefully, so that overﬂows never occur during the build phase. In overﬂow avoidance, the build relation <i>s </i>is initially partitioned into many small partitions, and then some partitions are combined in such a way that each combined partition ﬁts in memory. The probe relation <i>r </i>is partitioned in the same way as the combined partitions on <i>s</i>, but the sizes of <i>r</i><span class="s145">i </span>do not matter.</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">If a large number of tuples in <i>s </i>have the same value for the join attributes, the</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">resolution and avoidance techniques may fail on some partitions. In that case, instead of creating an in-memory hash index and using a nested-loop join to join the partitions, we can use other join techniques, such as block nested-loop join, on those partitions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">15.5.5.4 Cost of Hash Join</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We now consider the cost of a hash join. Our analysis assumes that there is no hash- table overﬂow. First, consider the case where recursive partitioning is not required.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 107pt;text-indent: -16pt;line-height: 93%;text-align: justify;"><span class="s39">• </span><span class="s40">The partitioning of the two relations </span>r <span class="p">and </span>s <span class="p">calls for a complete reading of both relations and a subsequent writing back of them. This operation requires 2(</span>b<span class="s97">r </span><span class="s15">+</span>b<span class="s97">s</span><span class="p">) block transfers, where </span>b<span class="s97">r </span><span class="p">and </span>b<span class="s97">s </span><span class="p">denote the number of blocks containing records of relations </span>r <span class="p">and </span>s<span class="p">, respectively. The build and probe phases read each of the partitions once, calling for further </span>b<span class="s97">r </span><span class="s15">+ </span>b<span class="s97">s </span><span class="p">block transfers. The number of blocks occupied by partitions could be slightly more than </span>b<span class="s145">r </span><span class="s15">+ </span>b<span class="s145">s</span><span class="p">, as a result of partially ﬁlled blocks. Accessing such partially ﬁlled blocks can add an overhead of at most 2</span>n<span class="s145">h </span><span class="p">for each of the relations, since each of the </span>n<span class="s145">h </span><span class="p">partitions could have a partially ﬁlled block that has to be written and read back. Thus, a hash join is estimated to require:</span></p><p style="padding-top: 9pt;padding-left: 78pt;text-indent: 0pt;text-align: center;">3(<i>b</i><span class="s97">r </span><span class="s15">+ </span><i>b</i><span class="s97">s</span>) <span class="s15">+ </span>4<i>n</i><span class="s97">h</span></p><p class="s13" style="padding-top: 8pt;padding-left: 107pt;text-indent: 0pt;line-height: 87%;text-align: left;"><span class="p">block transfers. The overhead 4</span>n<span class="s97">h </span><span class="p">is usually quite small compared to </span>b<span class="s97">r </span><span class="s15">+ </span>b<span class="s97">s </span><span class="p">and can be ignored.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;line-height: 14pt;text-align: left;">• <span class="s40">Assuming </span><span class="s13">b</span><span class="s97">b </span><span class="p">blocks are allocated for the input buﬀer and each output buﬀer, parti-</span></p><p class="s15" style="padding-left: 241pt;text-indent: 0pt;line-height: 0pt;text-align: left;">∕<span class="s13">b </span>+ <span class="s13">b </span>∕<span class="s13">b </span><span class="p">) seeks. The build and probe phases</span></p><p style="text-indent: 0pt;line-height: 14pt;text-align: left;">require only one seek for each of the <i>n</i><span class="s97">h </span>partitions of each relation, since each par-</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-left: 107pt;text-indent: 0pt;text-align: left;"><span class="p">tioning requires a total of 2(</span>⌈<span class="s13">b</span><span class="s97">r  b</span>⌉  ⌈ <span class="s123">s</span><span class="s13">  </span><span class="s123">b</span>⌉</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌈</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">∕<span class="s13">b</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">+</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="text-indent: 0pt;text-align: left;">b <span class="s15">∕</span>b</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">) <span class="s15">+</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 5pt;padding-left: 107pt;text-indent: 0pt;line-height: 14pt;text-align: left;">tition can be read sequentially. The hash join thus requires 2( <i>b</i><span class="s145">r</span></p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 14pt;text-align: left;">2<i>n</i><span class="s145">h </span>seeks.</p><p class="s123" style="padding-top: 5pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">b<span class="s15">⌉ ⌈ </span>s<span class="s13"> </span>b<span class="s15">⌉</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌋</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 15pt;text-align: left;">Now consider the case where recursive partitioning is required. Again we assume that <i>b</i><span class="s97">b </span>blocks are allocated for buﬀering each partition. Each pass then reduces the size</p><p class="s15" style="padding-left: 315pt;text-indent: 0pt;line-height: 6pt;text-align: left;">∕<span class="s13">b</span><span class="s145">b </span>− <span class="p">1; and passes are repeated</span></p><p style="text-indent: 0pt;line-height: 12pt;text-align: left;">until each partition is of size at most <i>M </i>blocks. The expected number of passes required</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 88pt;text-indent: 0pt;line-height: 6pt;text-align: left;">of each of the partitions by an expected factor of <span class="s15">⌊</span><i>M</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 5pt;padding-left: 84pt;text-indent: 0pt;line-height: 6pt;text-align: center;">∕<span class="s13">M </span><span class="p">) .</span></p><p class="s39" style="text-indent: 0pt;line-height: 15pt;text-align: left;">• <span class="s40">Since, in each pass, every block of </span><span class="s13">s </span><span class="p">is read in and written out, the total number</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 88pt;text-indent: 0pt;line-height: 38%;text-align: left;">for partitioning <i>s </i>is therefore <span class="s15">⌈</span>log<span class="s136">⌊</span><span class="s149">M </span><span class="s136">∕</span><span class="s149">b</span><span class="s160">b</span><span class="s136">⌋−</span><span class="s130">1</span><span class="s94">(</span><i>b</i><span class="s97">s</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;line-height: 12pt;text-align: left;">passes for partitioning of <i>r </i>is the same as the number of passes for partitioning of</p><p class="s13" style="text-indent: 0pt;text-align: left;">s<span class="p">, therefore the join is estimated to require</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 12pt;padding-left: 107pt;text-indent: 0pt;text-align: left;">of block transfers for partitioning of <i>s </i>is 2<i>b</i><span class="s145">s</span><span class="s15">⌈</span>log<span class="s171">⌊</span><span class="s169">M </span><span class="s171">∕</span><span class="s169">b</span><span class="s160">b</span><span class="s171">⌋−</span><span class="s93">1</span><span class="s94">(</span><i>b</i><span class="s145">s</span></p><p class="s15" style="padding-top: 12pt;text-indent: 0pt;text-align: left;">∕<span class="s13">M </span><span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 3pt;text-indent: 0pt;text-align: left;">. The number of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 119pt;text-indent: 0pt;line-height: 0pt;text-align: right;">2(<i>b</i></p><p class="s15" style="padding-top: 5pt;padding-left: 3pt;text-indent: 0pt;line-height: 0pt;text-align: left;">+ <span class="s13">b </span><span class="p">)</span></p><p style="padding-top: 5pt;padding-left: 3pt;text-indent: 0pt;line-height: 0pt;text-align: left;">log</p><p class="s13" style="padding-top: 5pt;padding-left: 32pt;text-indent: 0pt;line-height: 0pt;text-align: left;"><span class="p">(</span>b <span class="s15">∕</span>M <span class="p">)</span></p><p class="s15" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;line-height: 0pt;text-align: left;">+ <span class="s13">b </span>+ <span class="s13">b</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="text-indent: 0pt;text-align: left;">∕<span class="s109">b </span>−<span class="s119">1</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 107pt;text-indent: 0pt;text-align: left;">block transfers.</p><p class="s109" style="padding-left: 34pt;text-indent: 0pt;line-height: 15pt;text-align: left;">r  s <span class="s117">⌈</span></p><p class="s118" style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">⌊<span class="s109">M </span><span class="s144">b</span>⌋  <span class="s109">s</span></p><p class="s117" style="padding-left: 18pt;text-indent: 0pt;line-height: 15pt;text-align: left;">⌉  <span class="s109">r  s</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">Ignoring the relatively small number of seeks during the build and probe phases, hash join with recursive partitioning requires</span></p><p class="s15" style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;line-height: 0pt;text-align: right;">∕<span class="s13">b </span>+</p><p class="s13" style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 0pt;text-align: left;">b <span class="s15">∕</span>b <span class="p">) log</span></p><p class="s13" style="padding-top: 8pt;padding-left: 32pt;text-indent: 0pt;line-height: 0pt;text-align: left;"><span class="p">(</span>b <span class="s15">∕</span>M <span class="p">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="text-indent: 0pt;text-align: left;">∕<span class="s109">b </span>−<span class="s119">1</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 119pt;text-indent: 0pt;text-align: right;">disk seeks.</p><p class="s15" style="padding-left: 36pt;text-indent: 0pt;text-align: left;"><span class="p">2(</span>⌈<span class="s13">b</span><span class="s97">r  b</span>⌉</p><p class="s123" style="padding-left: 10pt;text-indent: 0pt;text-align: left;"><span class="s15">⌈ </span>s<span class="s13"> </span>b<span class="s15">⌉ ⌈</span></p><p class="s118" style="padding-left: 11pt;text-indent: 0pt;line-height: 16pt;text-align: left;">⌊<span class="s109">M </span><span class="s144">b</span>⌋   <span class="s109">s   </span><span class="s117">⌉</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 3pt;padding-left: 88pt;text-indent: 17pt;line-height: 93%;text-align: justify;"><span class="p">Consider, for example, the natural join </span>takes <span class="s86">⋈ </span>student<span class="p">. With a memory size of 20 blocks, the </span>student <span class="p">relation can be partitioned into ﬁve partitions, each of size 20 blocks, which size will ﬁt into memory. Only one pass is required for the partitioning. The</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="text-indent: 0pt;text-align: left;">+</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">relation <i>takes </i>is similarly partitioned into ﬁve partitions, each of size 80. Ignoring the cost of writing partially ﬁlled blocks, the cost is 3(100 <span class="s15">+ </span>400) <span class="s15">= </span>1500 block transfers. There is enough memory to allocate the buﬀers for the input and each of the ﬁve outputs</p><p class="s15" style="text-indent: 0pt;text-align: left;">⌈</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌉</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="text-indent: 0pt;text-align: left;">⌈</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 119pt;text-indent: 0pt;line-height: 14pt;text-align: left;">during partitioning (i.e, <i>b</i><span class="s97">b </span><span class="s15">= </span>3) leading to 2( 100<span class="s15">∕</span>3  400<span class="s15">∕</span>3 ) <span class="s15">= </span>336 seeks.</p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 94%;text-align: justify;">The hash join can be improved if the main memory size is large. When the entire build input can be kept in main memory, <i>n</i><span class="s97">h </span>can be set to 0; then, the hash-join algorithm executes quickly, without partitioning the relations into temporary ﬁles, regardless of</p><p class="s13" style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 90%;text-align: justify;"><span class="p">the probe input’s size. The cost estimate goes down to </span>b<span class="s145">r </span><span class="s15">+ </span>b<span class="s145">s </span><span class="p">block transfers and two seeks.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Indexed nested loops join can have a much lower cost than hash join in case the outer relation is small, and the index lookups fetch only a few tuples from the inner (indexed) relation. However, in case a secondary index is used, and the number of tuples in the outer relation is large, indexed nested loops join can have a very high cost, as compared to hash join. If the number of tuples in the outer relation is known at query optimization time, the best join algorithm can be chosen at that time. However, in some cases, for example, when there is a selection condition on the outer input, the optimizer makes a decision based on an estimate that may potentially be imprecise. The number of tuples in the outer relation may be found only at runtime, for example, after executing selection. Some systems allow a dynamic choice between the two algorithms at run time, after ﬁnding the number of tuples in the outer input.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">15.5.5.5 Hybrid Hash Join</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The <span class="s63">hybrid hash-join </span>algorithm performs another optimization; it is useful when mem- ory sizes are relatively large but not all of the build relation ﬁts in memory. The parti- tioning phase of the hash-join algorithm needs a minimum of one block of memory as a buﬀer for each partition that is created, and one block of memory as an input buﬀer. To reduce the impact of seeks, a larger number of blocks would be used as a buﬀer; let <i>b</i><span class="s145">b </span>denote the number of blocks used as a buﬀer for the input and for each parti-</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 87%;text-align: justify;">tion. Hence,a total of (<i>n</i><span class="s145">h </span><span class="s15">+ </span>1) <span class="s15">∗ </span><i>b</i><span class="s145">b </span>blocks of memory are needed for partitioning the two relations. If memory is larger than (<i>n</i><span class="s97">h </span><span class="s15">+ </span>1) <span class="s15">∗ </span><i>b</i><span class="s97">b</span>, we can use the rest of memory (<i>M </i><span class="s15">− </span>(<i>n</i><span class="s97">h </span><span class="s15">+ </span>1) <span class="s15">∗ </span><i>b</i><span class="s97">b </span>blocks) to buﬀer the ﬁrst partition of the build input (i.e, <i>s</i><span class="s98">0</span>) so that it will not need to be written out and read back in. Further, the hash function is</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 94%;text-align: justify;">designed in such a way that the hash index on <i>s</i><span class="s98">0</span> ﬁts in <i>M </i><span class="s15">− </span>(<i>n</i><span class="s97">h </span><span class="s15">+ </span>1) <span class="s15">∗ </span><i>b</i><span class="s97">b </span>blocks, in order that, at the end of partitioning of <i>s</i>, <i>s</i><span class="s98">0</span> is completely in memory and a hash index can be built on <i>s</i><span class="s98">0</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">When the system partitions <i>r</i>, it again does not write tuples in <i>r</i><span class="s98">0</span> to disk; instead, as it generates them, the system uses them to probe the memory-resident hash index on <i>s</i><span class="s98">0</span>, and to generate output tuples of the join. After they are used for probing, the tuples can be discarded, so the partition <i>r</i><span class="s98">0</span> does not occupy any memory space. Thus, a write and a read access have been saved for each block of both <i>r</i><span class="s98">0</span> and <i>s</i><span class="s98">0</span>. The system writes out tuples in the other partitions as usual and joins them later. The savings of hybrid hash join can be signiﬁcant if the build input is only slightly bigger than memory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="39" height="1" alt="image" src="Image_2779.png"/></span></p><p class="s15" style="text-indent: 0pt;text-align: left;">√</p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-top: 7pt;padding-left: 88pt;text-indent: 17pt;line-height: 83%;text-align: right;"><span class="p">If the size of the build relation is </span>b<span class="s145">s</span><span class="p">, </span>n<span class="s145">h </span><span class="p">is approximately equal to </span>b<span class="s145">s</span><span class="s15">∕</span>M <span class="p">. Thus, hybrid hash join is most useful if </span>M <span class="s83">&gt;&gt; </span><span class="p">(</span>b<span class="s97">s</span><span class="s15">∕</span>M <span class="p">) </span><span class="s15">∗ </span>b<span class="s97">b</span><span class="p">, or </span>M <span class="s83">&gt;&gt;  </span>b<span class="s97">s </span><span class="s15">∗ </span>b<span class="s97">b</span><span class="p">, where the notation</span></p><p style="text-indent: 0pt;line-height: 12pt;text-align: right;"><span class="s83">&gt;&gt; </span>denotes <i>much larger than</i>. For example, suppose the block size is 4 kilobytes, the</p><p style="padding-left: 87pt;text-indent: 0pt;line-height: 73%;text-align: right;">build relation size is 5 gigabytes, and <i>b</i><span class="s97">b </span>is 20. Then, the hybrid hash-join algorithm</p><p style="text-indent: 0pt;line-height: 12pt;text-align: right;">is useful if the size of memory is signiﬁcantly more than 20 megabytes; memory sizes</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">of gigabytes or more are common on computers today. If we devote 1 gigabyte for the join algorithm, <i>s</i><span class="s98">0</span> would be nearly 1 gigabyte, and hybrid hash join would be nearly 20 percent cheaper than hash join.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">15.5.6 Complex Joins</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Nested-loop and block nested-loop joins can be used regardless of the join conditions. The other join techniques are more eﬃcient than the nested-loop join and its variants, but they can handle only simple join conditions, such as natural joins or equi-joins. We can implement joins with complex join conditions, such as conjunctions and disjunc- tions, by using the eﬃcient join techniques, if we apply the techniques developed in Section 15.3.3 for handling complex selections.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">Consider the following join with a conjunctive condition:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 59pt;text-indent: 0pt;text-align: center;"><span class="s121">r </span><span class="s138">⋈</span>θ<span class="s358">1</span>∧ θ<span class="s358">2</span>∧ <span class="s371">⋯</span>∧ θ<span class="s372">n</span><span class="s109"> </span><span class="s139">s</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 81%;text-align: justify;"><span class="p">One or more of the join techniques described earlier may be applicable for joins on the individual conditions </span>r <span class="s86">⋈</span><span class="s136">θ</span><span class="s158">1 </span>s<span class="p">, </span>r <span class="s86">⋈</span><span class="s136">θ</span><span class="s158">2 </span>s<span class="p">, </span>r <span class="s86">⋈</span><span class="s136">θ</span><span class="s158">3 </span>s<span class="p">, and so on. We can compute the overall join by ﬁrst computing the result of one of these simpler joins </span>r <span class="s86">⋈</span><span class="s136">θ</span><span class="s380">i </span><span class="s381">s</span><span class="p">; each pair of tuples in the intermediate result consists of one tuple from </span>r <span class="p">and one from </span>s<span class="p">. The result</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">of the complete join consists of those tuples in the intermediate result that satisfy the remaining conditions:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="padding-left: 59pt;text-indent: 0pt;text-align: center;">θ<span class="s98">1</span><span class="p"> </span>∧ <span class="s86">⋯ </span>∧ θ<span class="s123">i</span><span class="s137">−</span><span class="s98">1</span><span class="p"> </span>∧ θ<span class="s123">i</span><span class="s137">+</span><span class="s98">1</span><span class="p"> </span>∧ <span class="s86">⋯ </span>∧ θ<span class="s123">n</span></p><p style="padding-top: 14pt;padding-left: 88pt;text-indent: 0pt;line-height: 16pt;text-align: justify;">These conditions can be tested as tuples in <i>r </i><span class="s86">⋈</span><span class="s136">θ</span><span class="s380">i </span><i>s </i>are being generated.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">A join whose condition is disjunctive can be computed in this way. Consider:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s118" style="padding-left: 59pt;text-indent: 0pt;text-align: center;"><span class="s128">r </span><span class="s147">⋈</span>θ<span class="s358">1</span><span class="s119"> </span>∨ θ<span class="s358">2</span>∨ <span class="s371">⋯</span>∨ θ<span class="s372">n</span><span class="s109"> </span><span class="s148">s</span></p><p class="s150" style="text-indent: 0pt;line-height: 6pt;text-align: left;">1        2           <i>n</i></p><p style="text-indent: 0pt;text-align: left;"/><p class="s13" style="padding-top: 12pt;padding-left: 191pt;text-indent: -103pt;line-height: 178%;text-align: left;"><span class="p">The join can be computed as the union of the records in individual joins </span>r <span class="s86">⋈</span><span class="s136">θ</span><span class="s380">i </span><span class="s381">s</span><span class="p">: (</span>r <span class="s86">⋈</span><span class="s136">θ </span>s<span class="p">) </span><span class="s15">∪ </span><span class="p">(</span>r <span class="s86">⋈</span><span class="s136">θ </span>s<span class="p">) </span><span class="s15">∪ </span><span class="s86">⋯ </span><span class="s15">∪ </span><span class="p">(</span>r <span class="s86">⋈</span><span class="s136">θ </span>s<span class="p">)</span></p><p style="padding-top: 2pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Section 15.6 describes algorithms for computing the union of relations.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;"><a name="bookmark329">15.5.7 Joins over Spatial Data</a><a name="bookmark350">&zwnj;</a></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The join algorithms we have presented make no speciﬁc assumptions about the type of data being joined, but they do assume the use of standard comparison operations such as equality, less than, or greater than, where the values are linearly ordered.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Selection and join conditions on spatial data involve comparison operators that check if one region contains or overlaps another, or whether a region contains a partic- ular point; and the regions may be multi-dimensional. Comparisons may pertain also to the distance between points, for example, ﬁnding a set of points closest to a given point in a two-dimensional space.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Merge-join cannot be used with such comparison operations, since there is no sim- ple sort order over spatial data in two or more dimensions. Partitioning of data based on hashing is also not applicable, since there is no way to ensure that tuples that sat- isfy an overlap or containment predicate are hashed to the same value. Nested loops join can always be used regardless of the complexity of the conditions, but can be very ineﬃcient on large datasets.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Indexed nested-loops join can however be used, if appropriate spatial indices are available. In Section 14.10, we saw several types of indices for spatial data, including R-trees, k-d trees, k-d-B trees, and quadtrees. Additional details on those indices appear in Section 24.4. These index structures enable eﬃcient retrieval of spatial data based on predicates such as contains, contained in, or overlaps, and can also be eﬀectively used to ﬁnd nearest neighbors.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Most major database systems today incorporate support for indexing spatial data, and make use of them when processing queries using spatial comparison conditions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part283.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part285.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
