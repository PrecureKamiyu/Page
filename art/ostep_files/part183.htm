<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.2 What’s Actually In The Page Table?</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part182.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part184.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">18.2 What’s Actually In The Page Table?</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let’s talk a little about page table organization. The page table is just a data structure that is used to map virtual addresses (or really, virtual page numbers) to physical addresses (physical page numbers). Thus, any data structure could work. The simplest form is called a <b>linear page table</b>, which is just an array. The OS <i>indexes </i>the array by the VPN, and looks up the page-table entry (PTE) at that index in order to find the desired PFN. For now, we will assume this simple linear structure; in later chapters, we will make use of more advanced data structures to help solve some problems with paging.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As for the contents of each PTE, we have a number of different bits in there worth understanding at some level. A <b>valid bit </b>is common to indicate whether the particular translation is valid; for example, when a program starts running, it will have code and heap at one end of its address space, and the stack at the other. All the unused space in-between will be marked <b>invalid</b>, and if the process tries to access such memory, it will generate a trap to the OS which will likely terminate the process. Thus, the valid bit is crucial for supporting a sparse address space; by simply marking all the unused pages in the address space invalid, we remove the need to allocate physical frames for those pages and thus save a great deal of memory.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We also might have <b>protection bits</b>, indicating whether the page could be read from, written to, or executed from. Again, accessing a page in a way not allowed by these bits will generate a trap to the OS.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="124" height="21" alt="image" src="Image_243.png"/></span></p><p class="s46" style="padding-top: 4pt;padding-left: 70pt;text-indent: 0pt;text-align: center;">PFN</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-left: 1pt;text-indent: 0pt;line-height: 122%;text-align: center;">G PAT D</p><p class="s65" style="padding-left: 1pt;text-indent: 0pt;line-height: 122%;text-align: center;">A PCD PWT</p><p class="s65" style="padding-left: 1pt;text-indent: 0pt;line-height: 122%;text-align: center;">U/S R/W P</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="padding-left: 92pt;text-indent: 0pt;text-align: left;">31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 126pt;text-indent: 0pt;text-align: left;">Figure 18.5: <b>An x86 Page Table Entry (PTE)</b></p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">There are a couple of other bits that are important but we won’t talk about much for now. A <b>present bit </b>indicates whether this page is in phys- ical memory or on disk (swapped out); we will understand this in more detail when we study how to move parts of the address space to disk and back in order to support address spaces that are larger than physical memory and allow for the pages of processes that aren’t actively being run to be swapped out. A <b>dirty bit </b>is also common, indicating whether the page has been modified since it was brought into memory.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">A <b>reference bit </b>(a.k.a. <b>accessed bit</b>) is sometimes used to track whether a page has been accessed, and is useful in determining which pages are popular and thus should be kept in memory; such knowledge is critical during <b>page replacement</b>, a topic we will study in great detail in subse- quent chapters.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Figure <span style=" color: #00AEEF;">18.5 </span>shows an example page table entry from the x86 architec- ture [I09]. It contains a present bit (P); a read/write bit (R/W) which determines if writes are allowed to this page; a user/supervisor bit (U/S) which determines if user-mode processes can access the page; a few bits (PWT, PCD, PAT, and G) that determine how hardware caching works for these pages; an accessed bit (A) and a dirty bit (D); and finally, the page frame number (PFN) itself.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Read the Intel Architecture Manuals [I09] for more details on x86 pag- ing support. Be forewarned, however; reading manuals such as these, while quite informative (and certainly necessary for those who write code to use such page tables in the OS), can be challenging at first. A little pa- tience, and a lot of desire, is required.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part182.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part184.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
