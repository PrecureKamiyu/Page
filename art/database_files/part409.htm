<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>22.10  Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part408.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part410.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 9pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">22.10  <span style=" color: #00AEEF;">Summary</span></p><p class="s39" style="padding-top: 9pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Current generation parallel systems are typically based on a hybrid architecture, where each computer has multiple cores with a shared memory, and there are multiple computers organized in a shared-nothing fashion.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">Parallel processing in a database system can be exploited in two distinct ways.</span></p><p class="s50" style="padding-top: 12pt;padding-left: 122pt;text-indent: -8pt;line-height: 76%;text-align: left;">° <span class="s51">Interquery parallelism— the execution of multiple queries in parallel with each other, across multiple nodes.</span></p><p class="s50" style="padding-top: 9pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: left;">° <span class="s51">Intraquery parallelism— the processing of diﬀerent parts of the execution of a single query, in parallel across multiple nodes.</span></p><p class="s39" style="padding-top: 8pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Interquery parallelism is essential for transaction-processing systems, while intra- query parallelism is essential for speeding up long-running queries.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Execution of a single query involves execution of multiple relational operations. The key to exploiting large-scale parallelism is to process each operation in parallel, across multiple nodes (referred to as intraoperation parallelism).</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The operations that are the most amenable to parallelism are: sort, selection, du- plicate elimination, projection, and aggregation.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Range-partitioning sort works in two steps: ﬁrst range-partitioning the relation, then sorting each partition separately.</span></p><p class="s13" style="padding-top: 5pt;padding-left: 107pt;text-indent: -16pt;line-height: 87%;text-align: justify;"><span class="s39">• </span><span class="s40">Parallel external sort-merge works in two steps: ﬁrst, each node </span>N<span class="s97">i </span><span class="p">sorts the data available at node </span>N<span class="s97">i</span><span class="p">, then the system merges the sorted runs on each node to get the ﬁnal sorted output.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Parallel join algorithms divide the tuples of the input relations over several nodes. Each node then computes part of the join locally. Then the system collects the results from each node to produce the ﬁnal result.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Skew is a major problem, especially with increasing degrees of parallelism. Bal- anced partitioning vectors, using histograms, and virtual node partitioning are among the techniques used to reduce skew.</span></p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">22.10 <span style=" color: #00AEEF;">Summary  </span><span class="s164">1087</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>The MapReduce paradigm is designed to ease the writing of parallel data process- ing programs using imperative programming languages that may not be express- ible using <span class="s41">SQL</span>. Fault-tolerant implementations of the MapReduce paradigm are important for a variety of very large scale data processing tasks. Extensions of the MapReduce model based on algebraic operations is increasingly important. The Hive <span class="s41">SQL </span>system uses a MapReduce system as its underlying execution engine, compiling <span class="s41">SQL </span>queries to MapReduce code.</p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">There are two forms of interoperation parallelism: pipelined parallelism and in- dependent parallelism. Pipelined parallelism is usually implemented using a push model, with buﬀers between operations.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The exchange operation repartitions data in a speciﬁed way. Parallel query plans can be created in such a way that data interchange between nodes is done only by the exchange operator, while all other operations work on local data, just as they would in a centralized database system.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">In the event of failure, parallel query execution plans could be restarted. However, in very large systems where there is a signiﬁcant chance of failure during the exe- cution of a query, fault tolerance techniques are important to ensure that queries complete execution without restarting, despite failures.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Parallel algorithms designed for shared-nothing architectures can be used in shared-memory architectures. Each processor can be treated as having its own par- tition of memory, and we can ignore the fact that the processors have a common shared memory. However, execution can be optimized signiﬁcantly by exploiting the fast access to shared memory from any of the processors.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Query optimization for parallel execution can be done using the traditional re- source consumption cost model, or using the response time cost model. Partition- ing of tables must be taken into account when choosing a plan, to minimize data exchange which is often a signiﬁcant factor in query execution cost. Materialized views can be important in parallel environments since they can signiﬁcantly reduce query execution cost.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">There are many streaming data applications today that require high performance processing, which can only be achieved by parallel processing of streaming data. Incoming tuples and results of operations need to be routed to other operations. The publish-subscribe model, implemented for example in Apache Kafka, has proven quite useful for such routing. Fault-tolerant processing of streaming data with exactly-once semantics for processing tuples is important in many applica- tions. Persistence provided by publish-subscribe systems helps in this regard.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Integration of schema and data from multiple databases is needed for many data processing tasks. The external data approach allows external data to be queries in a database as if it is locally resident. The global-as-view and local-as-view architec-</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: 0pt;text-align: justify;">tures allows rewriting of queries from a global schema to individual local schemas. The semijoin strategy using Bloom ﬁlters can be useful to reduce data movement for joins in a distributed database. Distributed directory systems are a type of dis- tributed database designed for distributed storage and querying of directories.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part408.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part410.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
