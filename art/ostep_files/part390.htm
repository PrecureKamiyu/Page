<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Other Scheduling Issues</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part389.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part391.htm">下一个 &gt;</a></p><p class="s32" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Other Scheduling Issues</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">There are many other issues we do not discuss in this brief description of basic disk operation, scheduling, and related topics. One such is- sue is this: <i>where </i>is disk scheduling performed on modern systems? In older systems, the operating system did all the scheduling; after looking through the set of pending requests, the OS would pick the best one, and issue it to the disk. When that request completed, the next one would be chosen, and so forth. Disks were simpler then, and so was life.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In modern systems, disks can accommodate multiple outstanding re- quests, and have sophisticated internal schedulers themselves (which can implement SPTF accurately; inside the disk controller, all relevant details are available, including exact head position). Thus, the OS scheduler usu- ally picks what it thinks the best few requests are (say 16) and issues them all to disk; the disk then uses its internal knowledge of head position and detailed track layout information to service said requests in the best pos- sible (SPTF) order.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Another important related task performed by disk schedulers is <b>I/O merging</b>. For example, imagine a series of requests to read blocks 33, then 8, then 34, as in Figure <span style=" color: #00AEEF;">37.6</span>. In this case, the scheduler should <b>merge </b>the requests for blocks 33 and 34 into a single two-block request; any re- ordering that the scheduler does is performed upon the merged requests. Merging is particularly important at the OS level, as it reduces the num- ber of requests sent to the disk and thus lowers overheads.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One final problem that modern schedulers address is this: how long should the system wait before issuing an I/O to disk? One might naively think that the disk, once it has even a single I/O, should immediately issue the request to the drive; this approach is called <b>work-conserving</b>, as the disk will never be idle if there are requests to serve. However, research on <b>anticipatory disk scheduling </b>has shown that sometimes it is better to wait for a bit [ID01], in what is called a <b>non-work-conserving </b>approach. By waiting, a new and “better” request may arrive at the disk, and thus overall efficiency is increased. Of course, deciding when to wait, and for how long, can be tricky; see the research paper for details, or check out the Linux kernel implementation to see how such ideas are transitioned into practice (if you are the ambitious sort).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part389.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part391.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
