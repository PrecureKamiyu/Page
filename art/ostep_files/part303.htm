<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Scaling Linked Lists</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part302.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part304.htm">下一个 &gt;</a></p><p class="s32" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Scaling Linked Lists</p><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Though we again have a basic concurrent linked list, once again we are in a situation where it does not scale particularly well. One technique that researchers have explored to enable more concurrency within a list is</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">1  </span>void List_Init(list_t <span class="s39">*</span>L) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">2    <span class="s38">L-&gt;head = NULL;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3    <span class="s38">pthread_mutex_init(&amp;L-&gt;lock, NULL);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">5</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">6  </span>void List_Insert(list_t <span class="s39">*</span>L, int key) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">7    <span class="s38">// synchronization not needed</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">8    </span>node_t <span class="s39">*</span>new = malloc(sizeof(node_t));</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">9    <span class="s38">if (new == NULL) {</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10       <span class="s38">perror(&quot;malloc&quot;);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11       <span class="s38">return;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">12    <span class="s38">}</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">13    <span class="s38">new-&gt;key = key;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">14</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">15    <span class="s38">// just lock critical section</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">16    <span class="s38">pthread_mutex_lock(&amp;L-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">17    <span class="s38">new-&gt;next = L-&gt;head;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">18     <span class="s38">L-&gt;head = new;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">19    <span class="s38">pthread_mutex_unlock(&amp;L-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">20  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">21</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">22  </span>int List_Lookup(list_t <span class="s39">*</span>L, int key) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">23    <span class="s38">int rv = -1;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">24    <span class="s38">pthread_mutex_lock(&amp;L-&gt;lock);</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">25    </span>node_t <span class="s39">*</span>curr = L-&gt;head;</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">26    <span class="s38">while (curr) {</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">27       <span class="s38">if (curr-&gt;key == key) {</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">28          <span class="s38">rv = 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">29          <span class="s38">break;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">30       <span class="s38">}</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">31       <span class="s38">curr = curr-&gt;next;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">32    <span class="s38">}</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">33    <span class="s38">pthread_mutex_unlock(&amp;L-&gt;lock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">34     <span class="s38">return rv; // now both success and failure</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">35  <span class="s38">}</span></p><p style="padding-top: 5pt;padding-left: 117pt;text-indent: 0pt;text-align: left;">Figure 29.7: <b>Concurrent Linked List: Rewritten</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: right;">something called <b>hand-over-hand locking </b>(a.k.a. <b>lock coupling</b>) [MS04]. The idea is pretty simple. Instead of having a single lock for the entire list, you instead add a lock per node of the list. When traversing the list, the code first grabs the next node’s lock and then releases the current</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">node’s lock (which inspires the name hand-over-hand).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Conceptually, a hand-over-hand linked list makes some sense; it en- ables a high degree of concurrency in list operations. However, in prac- tice, it is hard to make such a structure faster than the simple single lock approach, as the overheads of acquiring and releasing locks for each node of a list traversal is prohibitive. Even with very large lists, and a large number of threads, the concurrency enabled by allowing multiple on- going traversals is unlikely to be faster than simply grabbing a single lock, performing an operation, and releasing it. Perhaps some kind of hy- brid (where you grab a new lock every so many nodes) would be worth investigating.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: M<span class="s7">ORE </span>C<span class="s7">ONCURRENCY </span>I<span class="s7">SN</span>’<span class="s7">T </span>N<span class="s7">ECESSARILY </span>F<span class="s7">ASTER</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">If the scheme you design adds a lot of overhead (for example, by acquir- ing and releasing locks frequently, instead of once), the fact that it is more concurrent may not be important. Simple schemes tend to work well, especially if they use costly routines rarely. Adding more locks and com- plexity can be your downfall. All of that said, there is one way to really know: build both alternatives (simple but less concurrent, and complex but more concurrent) and measure how they do. In the end, you can’t cheat on performance; your idea is either faster, or it isn’t.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 58pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: B<span class="s7">E </span>W<span class="s7">ARY </span>O<span class="s7">F </span>L<span class="s7">OCKS AND </span>C<span class="s7">ONTROL </span>F<span class="s7">LOW</span></p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A general design tip, which is useful in concurrent code as well as elsewhere, is to be wary of control flow changes that lead to function re- turns, exits, or other similar error conditions that halt the execution of a function. Because many functions will begin by acquiring a lock, al- locating some memory, or doing other similar stateful operations, when errors arise, the code has to undo all of the state before returning, which is error-prone. Thus, it is best to structure code to minimize this pattern.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part302.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part304.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
