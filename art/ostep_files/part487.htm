<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>43.9 A New Problem: Garbage Collection</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part486.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part488.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">43.9 A New Problem: Garbage Collection</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">You may have noticed another problem with LFS; it keeps writing newer version of a file, its inode, and in fact all data to new parts of the disk. This process, while keeping writes efficient, implies that LFS leaves older versions of file structures all over the disk, scattered throughout the disk. We call such old stuff <b>garbage</b>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">For example, let’s imagine the case where we have an existing file re- ferred to by inode number <span class="s43">k</span>, which points to a single data block <span class="s43">D</span><span class="s44">0</span>. We now overwrite that block, generating both a new inode and a new data block. The resulting on-disk layout of LFS would look something like this (note we omit the imap and other structures for simplicity; a new chunk of imap would also have to be written to disk to point to the new inode):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="348" height="62" alt="image" src="Image_649.png"/></span></p><p class="s47" style="padding-left: 3pt;text-indent: 0pt;text-align: center;">blk[0]:A4</p><p class="s227" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: center;">I[k]</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s227" style="padding-left: 10pt;text-indent: 0pt;text-align: left;">D0</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: center;">blk[0]:A0</p><p class="s227" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: center;">I[k]</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s227" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">D0</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">A0  (both garbage)           A4</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In the diagram, you can see that both the inode and data block have two versions on disk, one old (the one on the left) and one current and thus <b>live </b>(the one on the right). By the simple act of overwriting a data block, a number of new structures must be persisted by LFS, thus leaving old versions of said blocks on the disk.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As another example, imagine we instead append a block to that orig- inal file <span class="s43">k</span>. In this case, a new version of the inode is generated, but the old data block is still pointed to by the inode. Thus, it is still live and very much apart of the current file system:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="348" height="74" alt="image" src="Image_650.png"/></span></p><p class="s65" style="padding-top: 1pt;padding-left: 7pt;text-indent: 0pt;line-height: 6pt;text-align: left;">blk[0]:A0</p><p class="s65" style="padding-left: 7pt;text-indent: 0pt;line-height: 5pt;text-align: left;">blk[1]:A4</p><p class="s227" style="padding-left: 10pt;text-indent: 0pt;line-height: 12pt;text-align: left;">I[k]</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s227" style="padding-left: 10pt;text-indent: 0pt;text-align: left;">D1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: center;">blk[0]:A0</p><p class="s227" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: center;">I[k]</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s227" style="padding-left: 10pt;text-indent: 0pt;text-align: left;">D0</p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">A0     (garbage)          A4</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">So what should we do with these older versions of inodes, data blocks, and so forth? One could keep those older versions around and allow users to restore old file versions (for example, when they accidentally overwrite or delete a file, it could be quite handy to do so); such a file system is known as a <b>versioning file system </b>because it keeps track of the different versions of a file.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">However, LFS instead keeps only the latest live version of a file; thus (in the background), LFS must periodically find these old dead versions of file data, inodes, and other structures, and <b>clean </b>them; cleaning should thus make blocks on disk free again for use in a subsequent writes. Note that the process of cleaning is a form of <b>garbage collection</b>, a technique that arises in programming languages that automatically free unused mem- ory for programs.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Earlier we discussed segments as important as they are the mechanism that enables large writes to disk in LFS. As it turns out, they are also quite integral to effective cleaning. Imagine what would happen if the LFS</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">cleaner simply went through and freed single data blocks, inodes, etc., during cleaning. The result: a file system with some number of free <b>holes </b>mixed between allocated space on disk. Write performance would drop considerably, as LFS would not be able to find a large contiguous region to write to disk sequentially and with high performance.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Instead, the LFS cleaner works on a segment-by-segment basis, thus clearing up large chunks of space for subsequent writing. The basic clean- ing process works as follows. Periodically, the LFS cleaner reads in a number of old (partially-used) segments, determines which blocks are live within these segments, and then write out a new set of segments with just the live blocks within them, freeing up the old ones for writing. Specifically, we expect the cleaner to read in <span class="s43">M </span>existing segments, <b>com- pact </b>their contents into <span class="s43">N </span>new segments (where <span class="s43">N &lt; M </span>), and then write the N segments to disk in new locations. The old <span class="s43">M </span>segments are then freed and can be used by the file system for subsequent writes.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We are now left with two problems, however. The first is mechanism: how can LFS tell which blocks within a segment are live, and which are dead? The second is policy: how often should the cleaner run, and which segments should it pick to clean?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part486.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part488.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
