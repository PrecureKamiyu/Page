<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 251" epub:type="pagebreak" id="page_251" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 11: Stacks and elimination</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">A stack is a last-in-first-out (LIFO) pool: threads push items on, and pop items off, the top of the stack. This chapter considers the challenge of implementing scalable concurrent stacks when every operation would seem to contend for access to the top of the stack. It presents a classic lock-free stack implementation, in which all operations do indeed conflict, and then introduces a powerful technique called elimination, which reduces contention by enabling push and pop operations to rendezvous away from the top of the stack. Matching push and pop operations cancel out each other's effects, so they can both avoid the need to access the top of the stack. Because they reduce contention, elimination-based stacks are able to scale.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">stacks; elimination; back-off; exchanger</p></section></header><section><h2 class="h1hd" id="s0010"><a id="st0020"/>11.1 Introduction</h2><p class="textfl" id="p0010">The <img alt="Image" height="9" src="images/B9780124159501000215/fx001.jpg" width="52"/> class is a collection of items (of type <img alt="Image" height="9" src="images/B9780124159501000215/fx002.jpg" width="5"/>) that provides <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() methods satisfying the <i>last-in-first-out</i> (LIFO) property: The last item pushed is the first popped. This chapter considers how to implement concurrent stacks. At first glance, stacks seem to provide little opportunity for concurrency, because <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() calls seem to need to synchronize at the top of the stack.</p><p class="text" id="p0015">Surprisingly, perhaps, stacks are not inherently sequential. In this chapter, we show how to implement concurrent stacks that can achieve a high degree of parallelism. As a first step, we consider how to build a lock-free stack in which pushes and pops synchronize at a single location.<span aria-label="Page 252" epub:type="pagebreak" id="page_252" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>11.2 An unbounded lock-free stack</h2><p class="textfl" id="p0020"><a href="#f0010" id="cf0010">Fig. 11.1</a> shows a concurrent <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> class. The lock-free stack is a linked list, where the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> field points to the first node (or <i>null</i> if the stack is empty.) For simplicity, we usually assume it is illegal to add a <i>null</i> value to a stack. Code for this class appears in <a href="#f0015" id="cs0010">Figs. 11.2</a>–<a href="#f0025">11.4</a>.</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="179" src="images/B9780124159501000215/gr001.jpg" width="288"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.1</span> A lock-free stack. In part (a), a thread pushes value <i>a</i> onto the stack by applying a <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> to the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> field. In part (b), a thread pops value <i>a</i> from the stack by applying a <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> to the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> field.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="372" src="images/B9780124159501000215/gr002.jpg" width="394"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.2</span> The <img alt="Image" height="9" src="images/B9780124159501000215/fx007.jpg" width="106"/> class: In the <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() method, threads alternate between trying to alter the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> reference by calling <img alt="Image" height="11" src="images/B9780124159501000215/fx008.jpg" width="45"/>(), and backing off using the <img alt="Image" height="9" src="images/B9780124159501000215/fx009.jpg" width="46"/> class from <a href="B9780124159501000173.xhtml">Fig. 7.5</a>.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="125" src="images/B9780124159501000215/gr003.jpg" width="175"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.3</span> Lock-free stack list node.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="356" src="images/B9780124159501000215/gr004.jpg" width="316"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.4</span> The <img alt="Image" height="9" src="images/B9780124159501000215/fx007.jpg" width="106"/> class: The <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() method alternates between trying to change the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> field and backing off.</div></figcaption></figure></div><p class="text" id="p0025">The <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() method creates a new node (line 13), and then calls <img alt="Image" height="11" src="images/B9780124159501000215/fx008.jpg" width="45"/>() to make the new node's <img alt="Image" height="8" src="images/B9780124159501000215/fx011.jpg" width="25"/> field point to the current top-of-stack and then tries to swing the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> reference <span aria-label="Page 253" epub:type="pagebreak" id="page_253" role="doc-pagebreak"/>from the current top-of-stack to the new node. If <img alt="Image" height="11" src="images/B9780124159501000215/fx008.jpg" width="45"/>() succeeds, <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() returns; if not, the <img alt="Image" height="11" src="images/B9780124159501000215/fx008.jpg" width="45"/>() attempt is repeated after backing off. The <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() method calls <img alt="Image" height="11" src="images/B9780124159501000215/fx012.jpg" width="38"/>(), which uses <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> to try to remove the first node from the stack. If it succeeds, it returns the node; otherwise it returns <i>null</i>. (It throws an exception if the stack is empty.) The <img alt="Image" height="11" src="images/B9780124159501000215/fx012.jpg" width="38"/>() method is called until it succeeds (or throws an exception), at which point <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() returns the value from the removed node.</p><p class="text" id="p0030">As we have seen in Chapter <a href="B9780124159501000173.xhtml">7</a>, one can significantly reduce contention at the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> field using exponential back-off (see <a href="B9780124159501000173.xhtml">Fig. 7.5</a>). Accordingly, both the <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() methods back off after an unsuccessful call to <img alt="Image" height="11" src="images/B9780124159501000215/fx008.jpg" width="45"/>() or <img alt="Image" height="11" src="images/B9780124159501000215/fx012.jpg" width="38"/>().</p><p class="text" id="p0035">This implementation is lock-free because a thread fails to complete a <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() or <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() method call only if there were infinitely many successful calls that modified the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> of the stack. The linearization point of both the <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and the <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() methods is the successful <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/>, or the seeing <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> equal to <i>null</i> (lines 33 and 34), in the case of a <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() on an empty stack. Note that the <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> call by <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() does not have an ABA problem (see Chapter <a href="B9780124159501000203.xhtml">10</a>) because the Java garbage collector ensures that a node cannot be reused by any thread, as long as that node is accessible to another thread. Designing a lock-free stack that avoids the ABA problem without a garbage collector is left as an exercise.<span aria-label="Page 254" epub:type="pagebreak" id="page_254" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>11.3 Elimination</h2><p class="textfl" id="p0040">The <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> implementation scales poorly, not so much because the stack's <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> field is a source of <i>contention</i>, but primarily because it is a <i>sequential bottleneck</i>: Method calls can proceed only one after the other, ordered by <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> calls successfully applied to the stack's <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> field. Although exponential back-off can reduce contention, it does nothing to alleviate the sequential bottleneck.</p><p class="text" id="p0045">To make the stack parallel, we exploit this simple observation: A <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() immediately followed by a <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() cancel each other out, and the stack's state does not change. It is as if both operations never happened. If one could somehow cause concurrent pairs of pushes and pops to cancel, then threads calling <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() could exchange values with threads calling <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>(), without ever modifying the stack itself. These two calls would <i>eliminate</i> one another.</p><p class="text" id="p0050"><a href="#f0030" id="cf0015">Fig. 11.5</a> depicts threads eliminating one another through an <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/>, in which threads pick random array entries to try to meet complementary calls. Pairs of complementary <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() calls exchange values and return. A thread whose call cannot be eliminated, either because it has failed to find a partner, or found a partner with the wrong kind of method call (such as a <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() meeting a <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>()), can either try again to find a partner at a new location, or access the shared <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/>. The combined data structure, array and shared stack, is linearizable because the shared stack is linearizable, and the eliminated calls can be ordered as if they happened at the point at which they exchanged values.</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="190" src="images/B9780124159501000215/gr005.jpg" width="478"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.5</span> The <img alt="Image" height="9" src="images/B9780124159501000215/fx013.jpg" width="173"/> class. Each thread selects a random location in the array. If thread <i>A</i>'s <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() and <i>B</i>'s <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() calls arrive at the same location at about the same time, then they exchange values without accessing the shared <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/>. Thread <i>C</i> that does not meet another thread eventually pops the shared <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/>.</div></figcaption></figure></div><p class="text" id="p0055">We can use the <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> as a back-off scheme on a shared <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/>. Each thread first accesses the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/>, and if it fails to complete its call (that is, the <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> attempt fails), it attempts to eliminate its call using the array instead of simply backing off. If it fails to eliminate itself, it calls the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> again, and so on. We call this structure an <img alt="Image" height="9" src="images/B9780124159501000215/fx015.jpg" width="153"/>.<span aria-label="Page 255" epub:type="pagebreak" id="page_255" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0025"><a id="st0035"/>11.4 The elimination back-off stack</h2><p class="textfl" id="p0060">We now show how to construct an <img alt="Image" height="9" src="images/B9780124159501000215/fx015.jpg" width="153"/>, a lock-free linearizable stack implementation.</p><p class="text" id="p0065">We are reminded of a story about two friends discussing politics on election day, each trying, to no avail, to convince the other to switch sides. Finally, one says to the other: “Look, it's clear that we are unalterably opposed on every political issue. Our votes will surely cancel out. Why not save ourselves some time and both agree to not vote today?”</p><p class="text" id="p0070">The other agrees enthusiastically and they part.</p><p class="text" id="p0075">Shortly after that, a friend of the first, who had heard the conversation, says, “That was a sporting offer you made.”</p><p class="text" id="p0080">“Not really,” came the reply. “This is the third time I've done this today.”</p><p class="text" id="p0085">The principle behind our construction is the same. We wish to allow threads with pushes and pops to coordinate and cancel out, but must avoid a situation in which a thread can make a sporting offer to more than one other thread. To do so, we implement the <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> using coordination structures called <i>exchangers</i>, objects that allow exactly two threads (and no more) to rendezvous and exchange values.</p><p class="text" id="p0090">We already saw how to exchange values using locks in the synchronous queue of Chapter <a href="B9780124159501000203.xhtml">10</a>. Here, we need a lock-free exchange, one in which threads spin rather than block, as we expect them to wait only for very short durations.</p><section><h3 class="h2hd" id="s0030"><a id="st0040"/>11.4.1 A lock-free exchanger</h3><p class="textfl" id="p0095">A <img alt="Image" height="11" src="images/B9780124159501000215/fx016.jpg" width="133"/> object permits two threads to exchange values of type <img alt="Image" height="9" src="images/B9780124159501000215/fx002.jpg" width="5"/>. If thread <i>A</i> calls the object's <img alt="Image" height="11" src="images/B9780124159501000215/fx017.jpg" width="52"/>() method with argument <i>a</i> and <i>B</i> calls the same object's <img alt="Image" height="11" src="images/B9780124159501000215/fx017.jpg" width="52"/>() method with argument <i>b</i>, then <i>A</i>'s call will return value <i>b</i> and vice versa. On a high level, the exchanger works by having the first thread arrive to write its value, and spin until a second arrives. The second then detects that the first is waiting, reads its value, and signals the exchange. They each have now read the other's value, and can return. The first thread's call may time out if the second does not show up, allowing it to leave the exchanger if it is unable to exchange a value within a reasonable duration.</p><p class="text" id="p0100">The <img alt="Image" height="11" src="images/B9780124159501000215/fx016.jpg" width="133"/> class, shown in <a href="#f0035" id="cf0020">Fig. 11.6</a>, has a single field <img alt="Image" height="9" src="images/B9780124159501000215/fx018.jpg" width="25"/> of type <img alt="Image" height="11" src="images/B9780124159501000215/fx019.jpg" width="167"/> (see <a href="B9780124159501000203.xhtml">Pragma 10.6.1</a>). The exchanger has three possible states: <img alt="Image" height="9" src="images/B9780124159501000215/fx020.jpg" width="31"/>, <img alt="Image" height="9" src="images/B9780124159501000215/fx021.jpg" width="25"/>, or <img alt="Image" height="9" src="images/B9780124159501000215/fx022.jpg" width="46"/>. The reference's stamp records the exchanger's state (line 14). The exchanger's main loop continues until the <img alt="Image" height="9" src="images/B9780124159501000215/fx023.jpg" width="45"/> limit passes, when it throws an exception (line 10). In the meantime, a thread reads the state of the <img alt="Image" height="9" src="images/B9780124159501000215/fx018.jpg" width="25"/> (line 12) and proceeds as follows:</p><div><ul><li class="bulllist" id="u0010">•  If the state is <img alt="Image" height="9" src="images/B9780124159501000215/fx020.jpg" width="31"/>, then the thread tries to place its item in the slot and set the state to <img alt="Image" height="9" src="images/B9780124159501000215/fx022.jpg" width="46"/> using <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> (line 16). If it fails, then some other thread has succeeded, so it retries. If it was successful (line 17), then its item is in the slot and the state is <img alt="Image" height="9" src="images/B9780124159501000215/fx022.jpg" width="46"/>, so it spins, waiting for another thread to complete the exchange. If another thread shows up, it will take <span aria-label="Page 256" epub:type="pagebreak" id="page_256" role="doc-pagebreak"/><span aria-label="Page 257" epub:type="pagebreak" id="page_257" role="doc-pagebreak"/>the item in the slot, replace it with its own, and set the state to <img alt="Image" height="9" src="images/B9780124159501000215/fx021.jpg" width="25"/> (line 19), indicating to the waiting thread that the exchange is complete. The waiting thread will consume the item and reset the state to <img alt="Image" height="9" src="images/B9780124159501000215/fx020.jpg" width="31"/>. Resetting to <img alt="Image" height="9" src="images/B9780124159501000215/fx020.jpg" width="31"/> can be done using a simple write because the waiting thread is the only one that can change the state from <img alt="Image" height="9" src="images/B9780124159501000215/fx021.jpg" width="25"/> to <img alt="Image" height="9" src="images/B9780124159501000215/fx020.jpg" width="31"/> (line 20). If no other thread shows up, the waiting thread needs to reset the state of the slot to <img alt="Image" height="9" src="images/B9780124159501000215/fx020.jpg" width="31"/>. This change requires a <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> because other threads might be attempting to exchange by setting the state from <img alt="Image" height="9" src="images/B9780124159501000215/fx022.jpg" width="46"/> to <img alt="Image" height="9" src="images/B9780124159501000215/fx021.jpg" width="25"/> (line 24). If the call is successful, it raises a timeout exception. If, however, the call fails, some exchanging thread must have shown up, so the waiting thread completes the exchange (line 26).</li><li class="bulllist" id="u0015">•  If the state is <img alt="Image" height="9" src="images/B9780124159501000215/fx022.jpg" width="46"/>, then some thread is waiting and the slot contains its item. The thread uses <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> to try to exchange the item with its own and change the state from <img alt="Image" height="9" src="images/B9780124159501000215/fx022.jpg" width="46"/> to <img alt="Image" height="9" src="images/B9780124159501000215/fx021.jpg" width="25"/> (line 34). If it fails, because another thread succeeds or the waiting thread resets the state to <img alt="Image" height="9" src="images/B9780124159501000215/fx020.jpg" width="31"/> following a timeout, the thread must retry. If it succeeds in exchanging items, it can return the item.</li><li class="bulllist" id="u0020">•  If the state is <img alt="Image" height="9" src="images/B9780124159501000215/fx021.jpg" width="25"/> then two other threads are currently using the slot for an exchange and the thread must retry (line 37).</li></ul></div><p class="textfl"/><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="717" src="images/B9780124159501000215/gr006.jpg" width="467"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.6</span> The <img alt="Image" height="11" src="images/B9780124159501000215/fx016.jpg" width="133"/> class.</div></figcaption></figure></div><p class="text" id="p0120">Note that the algorithm allows the inserted item to be <i>null</i>, something used later in the elimination array construction. There is no ABA problem because the <img alt="Image" height="12" src="images/B9780124159501000215/fx005.jpg" width="97"/> call that changes the state never inspects the item. The linearization point of a successful exchange occurs when the second thread to arrive changes the state from <img alt="Image" height="9" src="images/B9780124159501000215/fx022.jpg" width="46"/> to <img alt="Image" height="9" src="images/B9780124159501000215/fx021.jpg" width="25"/> (line 34). At this point both <img alt="Image" height="11" src="images/B9780124159501000215/fx017.jpg" width="52"/>() calls overlap, and the exchange is committed to being successful. The linearization point of an unsuccessful exchange occurs when the timeout exception is thrown.</p><p class="text" id="p0125">The algorithm is lock-free because overlapping <img alt="Image" height="11" src="images/B9780124159501000215/fx017.jpg" width="52"/>() calls with sufficient time to exchange will fail only if other exchanges are repeatedly succeeding. Clearly, too short an exchange time can cause a thread never to succeed, so care must be taken when choosing timeout durations.<span aria-label="Page 258" epub:type="pagebreak" id="page_258" role="doc-pagebreak"/></p></section><section><h3 class="h2hd" id="s0035"><a id="st0045"/>11.4.2 The elimination array</h3><p class="textfl" id="p0130">An <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> is implemented as an array of <img alt="Image" height="11" src="images/B9780124159501000215/fx025.jpg" width="59"/> objects. A thread attempting to perform an exchange picks an array entry at random, and calls that entry's <img alt="Image" height="11" src="images/B9780124159501000215/fx017.jpg" width="52"/>() method, providing its own input as a value for exchange with another thread. Code for the <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> appears in <a href="#f0040" id="cf0025">Fig. 11.7</a>. The constructor takes as an argument the <img alt="Image" height="11" src="images/B9780124159501000215/fx026.jpg" width="52"/> of the array (the number of distinct exchangers). The <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> class provides a single method, <img alt="Image" height="9" src="images/B9780124159501000215/fx027.jpg" width="32"/>(), which takes timeout arguments. (Following the conventions used in the <span class="sans-serif">java.util.concurrent</span> package, a timeout is expressed as a number and a time unit.) The <img alt="Image" height="9" src="images/B9780124159501000215/fx027.jpg" width="32"/>() call takes a value of type <img alt="Image" height="9" src="images/B9780124159501000215/fx002.jpg" width="5"/> and either returns the value input by its exchange partner, or throws an exception if the timeout expires without exchanging a value with another thread. At any point in time, each thread will select a random location in a subrange of the array (line 11). This subrange will be determined dynamically based on the load on the data structure, and will be passed as a parameter to the <img alt="Image" height="9" src="images/B9780124159501000215/fx027.jpg" width="32"/>() method.</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="240" src="images/B9780124159501000215/gr007.jpg" width="459"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.7</span> The <img alt="Image" height="11" src="images/B9780124159501000215/fx024.jpg" width="126"/> class: In each visit, a thread can choose dynamically the subrange of the array from which it will randomly select a slot.</div></figcaption></figure></div><p class="text" id="p0135">It is critical that each thread uses its own random number generator to select its location. As discussed in Appendix <a href="B9780124159501000318.xhtml">A.2.5</a>, if threads share a random number generator, they would introduce the contention that the elimination array is designed to avoid.</p><p class="text" id="p0140">The <img alt="Image" height="9" src="images/B9780124159501000215/fx015.jpg" width="153"/> is a subclass of <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> that overrides the <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() methods, and adds an <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> field. The new <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() methods appear in <a href="#f0045" id="cs0015">Figs. 11.8</a> and <a href="#f0050">11.9</a>. If <img alt="Image" height="11" src="images/B9780124159501000215/fx008.jpg" width="45"/>() or <img alt="Image" height="11" src="images/B9780124159501000215/fx012.jpg" width="38"/>() fails, instead of simply backing off, these methods try to use the <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> to exchange values (lines 15 and 33). A <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() call calls <img alt="Image" height="9" src="images/B9780124159501000215/fx027.jpg" width="32"/>() with its input value as argument, a <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() call with <i>null</i> as argument. Both <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() have a thread-local <img alt="Image" height="11" src="images/B9780124159501000215/fx028.jpg" width="72"/> object that determines the <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> subrange to be used.</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="421" src="images/B9780124159501000215/gr008.jpg" width="482"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.8</span> The <img alt="Image" height="9" src="images/B9780124159501000215/fx013.jpg" width="173"/> class: This <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() method overrides the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() method. Instead of using a simple <img alt="Image" height="9" src="images/B9780124159501000215/fx009.jpg" width="46"/> class, it uses an <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> and a dynamic <img alt="Image" height="11" src="images/B9780124159501000215/fx028.jpg" width="72"/> to select the subrange of the array within which to eliminate.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="273" src="images/B9780124159501000215/gr009.jpg" width="475"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.9</span> The <img alt="Image" height="9" src="images/B9780124159501000215/fx013.jpg" width="173"/> class: This <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() method overrides the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() method.</div></figcaption></figure></div><p class="text" id="p0145">When <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() calls <img alt="Image" height="9" src="images/B9780124159501000215/fx027.jpg" width="32"/>(), it selects a random array entry within its range and attempts to exchange a value with another thread. If the exchange is successful, the pushing thread checks whether the value was exchanged with a <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() method (line 17) by testing if the value exchanged was <i>null</i>. (Recall that <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() always offers <i>null</i> to the exchanger while <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() always offers a <i>nonnull</i> value.) Symmetrically, when <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() calls <img alt="Image" height="9" src="images/B9780124159501000215/fx027.jpg" width="32"/>(), it attempts an exchange, and if the exchange is successful, it checks (line 35) whether the value was exchanged with a <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() call by checking whether it is not <i>null</i>.</p><p class="text" id="p0150">The exchange may be unsuccessful, either because no exchange took place (the call to <img alt="Image" height="9" src="images/B9780124159501000215/fx027.jpg" width="32"/>() timed out) or because the exchange was with the same type of operation (e.g., a <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() with a <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>()). For brevity, we choose a simple approach to deal with such cases: we retry the <img alt="Image" height="11" src="images/B9780124159501000215/fx008.jpg" width="45"/>() or <img alt="Image" height="11" src="images/B9780124159501000215/fx012.jpg" width="38"/>() calls (lines 13 and 30).</p><p class="text" id="p0155">One important parameter is the range of the <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> from which a thread selects an <img alt="Image" height="11" src="images/B9780124159501000215/fx025.jpg" width="59"/> location. A smaller range increases the chance of a successful exchange when there are few threads, <span aria-label="Page 259" epub:type="pagebreak" id="page_259" role="doc-pagebreak"/>while a larger range lowers the chance of threads waiting on a busy <img alt="Image" height="11" src="images/B9780124159501000215/fx025.jpg" width="59"/> (recall that an <img alt="Image" height="11" src="images/B9780124159501000215/fx025.jpg" width="59"/> can only handle one exchange at a time). Thus, if few threads access the array, they should choose a small range; as the number of threads increases, so should the range. One can control the range dynamically using a <img alt="Image" height="11" src="images/B9780124159501000215/fx028.jpg" width="72"/> object that records both successful exchanges (as in line 36) and timeout failures (line 39). We ignore exchanges that fail because the operations do not match (such as <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() with <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000215/si1.png" style="vertical-align:middle" width="19"/></span>, because they account for a fixed fraction of the exchanges for any given distribution of <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() calls. One simple policy is to shrink the range as the number of failures increases and vice versa.</p><p class="text" id="p0160">There are many other possible policies. For example, one can devise a more elaborate range selection policy, vary the delays on the exchangers dynamically, add additional back-off delays before accessing the shared stack, and control whether to access the shared stack or the array dynamically. We leave these as exercises.</p><p class="text" id="p0165"><span aria-label="Page 260" epub:type="pagebreak" id="page_260" role="doc-pagebreak"/>The <img alt="Image" height="9" src="images/B9780124159501000215/fx015.jpg" width="153"/> is a linearizable stack: Any successful <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() or <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() call that completes by accessing the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> can be linearized at the point of its <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> access. Any pair of eliminated <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() calls can be linearized when they collide. As noted earlier, the method calls completed through elimination do not affect the linearizability of those completed in the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/>, because they could have taken effect in any state of the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/>, and having taken effect, the state of the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> would not have changed.</p><p class="text" id="p0170">Because the <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> is effectively used as a back-off scheme, we expect it to deliver performance comparable to the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> at low loads. Unlike the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/>, it has the potential to scale. As the load increases, the number of successful eliminations will grow, allowing many operations to complete in parallel. Moreover, contention at the <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> is reduced because eliminated operations never access the stack.<span aria-label="Page 261" epub:type="pagebreak" id="page_261" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0040"><a id="st0050"/>11.5 Chapter notes</h2><p class="textfl" id="p0175">The <img alt="Image" height="9" src="images/B9780124159501000215/fx010.jpg" width="86"/> is credited to Treiber <a epub:type="noteref" href="#br0810" id="cf0030" role="doc-noteref">[162]</a>. Actually, it predates Treiber's report in 1986. It was probably invented in the early 1970s to motivate the CAS operation on the IBM 370. The <img alt="Image" height="9" src="images/B9780124159501000215/fx015.jpg" width="153"/> is due to Danny Hendler, Nir Shavit, and Lena Yerushalmi <a epub:type="noteref" href="#br0310" id="cf0035" role="doc-noteref">[62]</a>. An efficient exchanger, which quite interestingly uses an elimination array, was introduced by Doug Lea, Michael Scott, and Bill Scherer <a epub:type="noteref" href="#br0835" id="cf0040" role="doc-noteref">[167]</a>. A variant of this exchanger appears in the <span class="sans-serif">java.util.concurrent</span> package. The <img alt="Image" height="9" src="images/B9780124159501000215/fx015.jpg" width="153"/> we present here is modular, making use of exchangers, but somewhat inefficient. Mark Moir, Daniel Nussbaum, Ori Shalev, and Nir Shavit presented a highly effective implementation of an <img alt="Image" height="11" src="images/B9780124159501000215/fx014.jpg" width="106"/> <a epub:type="noteref" href="#br0655" id="cf0045" role="doc-noteref">[131]</a>.</p></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>11.6 Exercises</h2><p class="textfl" id="p0180"/><div class="boxg1" id="enun0010"><p class="b1num">Exercise 11.1 </p><div><p class="b1textfl" id="p0185">Design an unbounded lock-based <img alt="Image" height="9" src="images/B9780124159501000215/fx001.jpg" width="52"/> implementation based on a linked list.</p></div></div><p class="textfl"/><p class="text" id="p0190"/><div class="boxg1" id="enun0015"><p class="b1num">Exercise 11.2 </p><div><p class="b1textfl" id="p0195">Design a bounded lock-based <img alt="Image" height="9" src="images/B9780124159501000215/fx001.jpg" width="52"/> using an array.</p><div><ol><li class="b1numlist" id="o0010">1.  Use a single lock and a bounded array.</li><li class="b1numlist" id="o0015">2.  Try to make your algorithm lock-free. Where do you run into difficulty?</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0210"/><div class="boxg1" id="enun0020"><p class="b1num">Exercise 11.3 </p><div><p class="b1textfl" id="p0215">Modify the unbounded lock-free stack of Section <a href="#s0015" id="cf0050">11.2</a> to work in the absence of a garbage collector. Create a thread-local pool of preallocated nodes and recycle them. To avoid the ABA problem, consider using the <img alt="Image" height="11" src="images/B9780124159501000215/fx019.jpg" width="167"/> class from <span class="sans-serif">java.util.concurrent.atomic</span> (see <a href="B9780124159501000203.xhtml">Pragma 10.6.1</a>), which encapsulates both a reference and an integer <i>stamp</i>.</p></div></div><p class="textfl"/><p class="text" id="p0220"/><div class="boxg1" id="enun0025"><p class="b1num">Exercise 11.4 </p><div><p class="b1textfl" id="p0225">Discuss the back-off policies used in our implementation. Does it make sense to use the same shared <img alt="Image" height="9" src="images/B9780124159501000215/fx009.jpg" width="46"/> object for both pushes and pops in our <img alt="Image" height="9" src="images/B9780124159501000215/fx007.jpg" width="106"/> object? How else could we structure the back-off in space and time in the <img alt="Image" height="9" src="images/B9780124159501000215/fx013.jpg" width="173"/>?</p></div></div><p class="textfl"/><p class="text" id="p0230"/><div class="boxg1" id="enun0030"><p class="b1num">Exercise 11.5 </p><div><p class="b1textfl" id="p0235">Implement a stack algorithm assuming there is a known bound on the difference between the total number of successful pushes and pops to the stack in any state of the execution.</p></div></div><p class="textfl"/><p class="text" id="p0240"/><div class="boxg1" id="enun0035"><p class="b1num">Exercise 11.6 </p><div><p class="b1textfl" id="p0245">Consider the problem of implementing a bounded stack using an array indexed by a <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> counter, initially zero. In the absence of concurrency, these methods are almost trivial. To push an item, increment <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> to reserve an array entry, and then store the item at that index. To pop an item, decrement <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/>, and return the item at the previous <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> index.</p><p class="b1text" id="p0250">Clearly, this strategy does not work for concurrent implementations, because one cannot make atomic changes to multiple memory locations. A single synchronization operation can either increment or decrement the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> counter, but not both, and there is no way atomically to increment the counter and store a value.</p><p class="b1text" id="p0255">Nevertheless, Bob D. Hacker decides to solve this problem. He decides to adapt the dual data structure approach of Chapter <a href="B9780124159501000203.xhtml">10</a> to implement a <i>dual</i> stack. His <img alt="Image" height="9" src="images/B9780124159501000215/fx029.jpg" width="79"/> class splits <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() methods into <i>reservation</i> and <i>fulfillment</i> steps. Bob's implementation appears in <a href="#f0055" id="cf0055">Fig. 11.10</a>.</p><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="700" src="images/B9780124159501000215/gr010.jpg" width="420"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.10</span> Bob's problematic dual stack.</div></figcaption></figure></div><p class="b1text" id="p0260">The stack's top is indexed by the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> field, an <img alt="Image" height="11" src="images/B9780124159501000215/fx030.jpg" width="87"/> manipulated only by <img alt="Image" height="11" src="images/B9780124159501000215/fx031.jpg" width="99"/>() and <img alt="Image" height="11" src="images/B9780124159501000215/fx032.jpg" width="99"/>() calls. Bob's <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() method's reservation step reserves a slot by applying <span aria-label="Page 262" epub:type="pagebreak" id="page_262" role="doc-pagebreak"/><span aria-label="Page 263" epub:type="pagebreak" id="page_263" role="doc-pagebreak"/><img alt="Image" height="11" src="images/B9780124159501000215/fx031.jpg" width="99"/>() to <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/>. Suppose the call returns index <i>i</i>. If <i>i</i> is in the range <img alt="Image" height="12" src="images/B9780124159501000215/fx033.jpg" width="109"/>, the reservation is complete. In the fulfillment phase, <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>(<i>x</i>) stores <i>x</i> at index <i>i</i> in the array, and raises the <img alt="Image" height="9" src="images/B9780124159501000215/fx034.jpg" width="23"/> flag to indicate that the value is ready to be read. The <img alt="Image" height="9" src="images/B9780124159501000215/fx035.jpg" width="32"/> field must be <img alt="Image" height="9" src="images/B9780124159501000215/fx036.jpg" width="53"/> to guarantee that once <img alt="Image" height="11" src="images/B9780124159501000215/fx037.jpg" width="25"/> is raised, the value has already been written to index <i>i</i> of the array.</p><p class="b1text" id="p0265">If the index returned from <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>()'s <img alt="Image" height="11" src="images/B9780124159501000215/fx031.jpg" width="99"/>() is less than 0, the <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() method repeatedly retries <img alt="Image" height="11" src="images/B9780124159501000215/fx031.jpg" width="99"/>() until it returns an index greater than or equal to 0. The index could be less than 0 due to <img alt="Image" height="11" src="images/B9780124159501000215/fx032.jpg" width="99"/>() calls of failed <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() calls to an empty stack. Each such failed <img alt="Image" height="11" src="images/B9780124159501000215/fx032.jpg" width="99"/>() decrements the <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/> by one more past the 0 array bound. If the index returned is greater than <img alt="Image" height="11" src="images/B9780124159501000215/fx026.jpg" width="52"/>−1, <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() throws an exception because the stack is full.</p><p class="b1text" id="p0270">The situation is symmetric for <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>(). It checks that the index is within the bounds and removes an item by applying <img alt="Image" height="11" src="images/B9780124159501000215/fx032.jpg" width="99"/>() to <img alt="Image" height="11" src="images/B9780124159501000215/fx006.jpg" width="18"/>, returning index <i>i</i>. If <i>i</i> is in the range <img alt="Image" height="12" src="images/B9780124159501000215/fx033.jpg" width="109"/>, the reservation is complete. For the fulfillment phase, <img alt="Image" height="9" src="images/B9780124159501000215/fx004.jpg" width="18"/>() spins on the <img alt="Image" height="9" src="images/B9780124159501000215/fx034.jpg" width="23"/> flag of array slot <i>i</i>, until it detects that the flag is true, indicating that the <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() call is successful.</p><p class="b1text" id="p0275">What is wrong with Bob's algorithm? Is this problem inherent or can you think of a way to fix it?</p></div></div><p class="textfl"/><p class="text" id="p0280"/><div class="boxg1" id="enun0040"><p class="b1num">Exercise 11.7 </p><div><p class="b1textfl" id="p0285"><a href="B9780124159501000185.xhtml">Exercise 8.7</a> asks you to implement the <img alt="Image" height="9" src="images/B9780124159501000215/fx038.jpg" width="31"/> interface, reproduced in <a href="#f0060" id="cf0060">Fig. 11.11</a>. The <img alt="Image" height="9" src="images/B9780124159501000215/fx038.jpg" width="31"/> class manages a collection of <i>rooms</i>, indexed from 0 to <i>m</i> (where <i>m</i> is a known constant). Threads can enter or exit any room in that range. Each room can hold an arbitrary number of threads simultaneously, but only one room can be occupied at a time. The last thread to leave a room triggers an <img alt="Image" height="11" src="images/B9780124159501000215/fx039.jpg" width="46"/>() handler, which runs while all rooms are empty.</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="125" src="images/B9780124159501000215/gr011.jpg" width="342"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.11</span> The <img alt="Image" height="9" src="images/B9780124159501000215/fx038.jpg" width="31"/> interface.</div></figcaption></figure></div><p class="b1text" id="p0290"><a href="#f0065" id="cf0065">Fig. 11.12</a> shows an incorrect concurrent stack implementation.</p><div><ol><li class="b1numlist" id="o0020">1.  Explain why this stack implementation does not work.</li><li class="b1numlist" id="o0025">2.  Fix it by adding calls to a two-room <img alt="Image" height="9" src="images/B9780124159501000215/fx038.jpg" width="31"/> class: one room for pushing and one for popping.</li></ol></div><p class="b1textfl"/><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="388" src="images/B9780124159501000215/gr012.jpg" width="298"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 11.12</span> Unsynchronized concurrent stack.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0305"/><div class="boxg1" id="enun0045"><p class="b1num">Exercise 11.8 </p><div><p class="b1textfl" id="p0310">This exercise is a follow-on to <a href="#enun0040" id="cf0070">Exercise 11.7</a>. Instead of having the <img alt="Image" height="11" src="images/B9780124159501000215/fx003.jpg" width="25"/>() method throw <img alt="Image" height="11" src="images/B9780124159501000215/fx040.jpg" width="85"/>, exploit the push room's exit <span aria-label="Page 264" epub:type="pagebreak" id="page_264" role="doc-pagebreak"/>handler to resize the array. Remember that no thread can be in any room when an exit handler is running, so (of course) only one exit handler can run at a time.</p></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0475"><h2 class="reftitle" id="st0060">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0310" role="doc-biblioentry">[62] Danny Hendler, Nir Shavit, Lena Yerushalmi,  A scalable lock-free stack algorithm,   <i>SPAA '04: Proceedings of the Sixteenth Annual ACM Symposium on Parallelism in Algorithms and Architectures</i>.  New York, NY, USA: ACM Press; 2004:206–215.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0655" role="doc-biblioentry">[131] Mark Moir, Daniel Nussbaum, Ori Shalev, Nir Shavit,  Using elimination to implement scalable and lock-free fifo queues,   <i>SPAA '05: Proceedings of the Seventeenth Annual ACM Symposium on Parallelism in Algorithms and Architectures</i>.  New York, NY, USA: ACM Press; 2005:253–262.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0810" role="doc-biblioentry">[162] R.K. Treiber,  <i>Systems programming: coping with parallelism</i>. [Technical Report RJ 5118] IBM Almaden Research Center; April 1986.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0835" role="doc-biblioentry">[167] William N. Scherer III, Doug Lea, Michael L. Scott,  Scalable synchronous queues,   <i>PPoPP '06: Proceedings of the Eleventh ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</i>.  New York, NY, USA: ACM Press; 2006:147–156.</p></div></section></footer></section></body></html>