<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>5.7 Understanding Modern Processors</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000004B6C" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P70004970270000000000000000432B9" data-uri="chapter05.xhtml#P70004970270000000000000000432B9" epub:type="title"><span class="pcalibre label pcalibre1">5.7 </span>Understanding Modern Processors</h1></header>
<p id="P70004970270000000000000000432BA" data-uri="chapter05.xhtml#P70004970270000000000000000432BA" class="pcalibre1 pcalibre calibre2">Up to this point, we have applied optimizations that did not rely on any features of the target machine. They simply reduced the overhead of procedure calls and eliminated some of the critical "optimization blockers" that cause difficulties for optimizing compilers. As we seek to push the performance further, we must consider optimizations that exploit the <i class="calibre5 pcalibre pcalibre1">microarchitecture</i> of the processor—that is, the underlying system design by which a processor executes instructions. Getting every last bit of performance requires a detailed analysis of the program as well as code generation tuned for the target processor. Nonetheless, we can apply some basic optimizations that will yield an overall performance improvement on a large class of processors. The detailed performance results we report here may not hold for other machines, but the general principles of operation and optimization apply to a wide variety of machines.</p>
<p id="P70004970270000000000000000432BB" data-uri="chapter05.xhtml#P70004970270000000000000000432BB" class="pcalibre1 pcalibre calibre2">To understand ways to improve performance, we require a basic understanding of the microarchitectures of modern processors. Due to the large number of transistors that can be integrated onto a single chip, modern microprocessors employ complex hardware that attempts to maximize program performance. One result is that their actual operation is far different from the view that is perceived by looking at machine-level programs. At the code level, it appears as if instructions are executed one at a time, where each instruction involves fetching values from registers or memory, performing an operation, and storing results back to a register or memory location. In the actual processor, a number of instructions <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004B70" title="518" data-uri="chapter05.xhtml#P7000497027000000000000000004B70" epub:type="pagebreak"></span>are evaluated simultaneously, a phenomenon referred to as <i class="calibre5 pcalibre pcalibre1">instruction-level parallelism</i>. In some designs, there can be 100 or more instructions "in flight." Elaborate mechanisms are employed to make sure the behavior of this parallel execution exactly captures the sequential semantic model required by the machine-level program. This is one of the remarkable feats of modern microprocessors: they employ complex and exotic microarchitectures, in which multiple instructions can be executed in parallel, while presenting an operational view of simple sequential instruction execution.</p>
<p id="P70004970270000000000000000432BC" data-uri="chapter05.xhtml#P70004970270000000000000000432BC" class="pcalibre1 pcalibre calibre2">Although the detailed design of a modern microprocessor is well beyond the scope of this book, having a general idea of the principles by which they operate suffices to understand how they achieve instruction-level parallelism. We will find that two different lower bounds characterize the maximum performance of a program. The <i class="calibre5 pcalibre pcalibre1">latency bound</i> is encountered when a series of operations must be performed in strict sequence, because the result of one operation is required before the next one can begin. This bound can limit program performance when the data dependencies in the code limit the ability of the processor to exploit instruction-level parallelism. The <i class="calibre5 pcalibre pcalibre1">throughput bound</i> characterizes the raw computing capacity of the processor's functional units. This bound becomes the ultimate limit on program performance.</p>
<section id="P7000497027000000000000000004B72" data-uri="chapter05.xhtml#P7000497027000000000000000004B72" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000432BD" data-uri="chapter05.xhtml#P70004970270000000000000000432BD" epub:type="title"><span class="pcalibre label pcalibre1">5.7.1 </span>Overall Operation</h1></header>
<p id="P70004970270000000000000000432BE" data-uri="chapter05.xhtml#P70004970270000000000000000432BE" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004B76"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.11</span></a> shows a very simplified view of a modern microprocessor. Our hypothetical processor design is based loosely on the structure of recent Intel processors. These processors are described in the industry as being <i class="calibre5 pcalibre pcalibre1">superscalar</i>, which means they can perform multiple operations on every clock cycle and <i class="calibre5 pcalibre pcalibre1">out of order</i>, meaning that the order in which instructions execute need not correspond to their ordering in the machine-level program. The overall design has two main parts: the <i class="calibre5 pcalibre pcalibre1">instruction control unit</i> (ICU), which is responsible for reading a sequence of instructions from memory and generating from these a set of primitive operations to perform on program data, and the <i class="calibre5 pcalibre pcalibre1">execution unit</i> (EU), which then executes these operations. Compared to the simple <i class="calibre5 pcalibre pcalibre1">in-order</i> pipeline we studied in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000003A76.xhtml#P7000497027000000000000000003A76"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">4</span></a>, out-of-order processors require far greater and more complex hardware, but they are better at achieving higher degrees of instruction-level parallelism.</p>
<p id="P70004970270000000000000000432BF" data-uri="chapter05.xhtml#P70004970270000000000000000432BF" class="pcalibre1 pcalibre calibre2">The ICU reads the instructions from an <i class="calibre5 pcalibre pcalibre1">instruction cache</i>—a special high-speed memory containing the most recently accessed instructions. In general, the ICU fetches well ahead of the currently executing instructions, so that it has enough time to decode these and send operations down to the EU. One problem, however, is that when a program hits a branch,<a class="noteref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" id="r__P7000497027000000000000000005188" epub:type="noteref" href="#P7000497027000000000000000005188">1</a> there are two possible directions the program might go. The branch can be <i class="calibre5 pcalibre pcalibre1">taken</i>, with control passing to the branch target. Alternatively, the branch can be <i class="calibre5 pcalibre pcalibre1">not taken</i>, with control passing to the next</p><aside class="footnote pcalibre5 pcalibre" id="P7000497027000000000000000005188" data-uri="chapter05.xhtml#P7000497027000000000000000005188" epub:type="footnote"><p class="pcalibre calibre3 pcalibre1"><span class="pcalibre1 number2 pcalibre"><a href="#r__P7000497027000000000000000005188" class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1">1. </a></span>We use the term "branch" specifically to refer to conditional jump instructions. Other instructions that can transfer control to multiple destinations, such as procedure return and indirect jumps, provide similar challenges for the processor.</p></aside>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004B76" data-uri="chapter05.xhtml#P7000497027000000000000000004B76">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004B77" title="519" data-uri="chapter05.xhtml#P7000497027000000000000000004B77" epub:type="pagebreak"></span>
<img alt="A block diagram depicts interactions between instruction control unit and execution unit." id="P70004970270000000000000000432C0" data-uri="P700049702700000000000000000B711" src="../images/p519-1.png" class="pcalibre calibre171 pcalibre1"/>
<figcaption id="P70004970270000000000000000432C1" data-uri="chapter05.xhtml#P70004970270000000000000000432C1" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000432C2" data-uri="chapter05.xhtml#P70004970270000000000000000432C2" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.11 </span>Block diagram of an out-of-order processor.</h1></header>
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000432C3" data-uri="chapter05.xhtml#P70004970270000000000000000432C3"><p id="P70004970270000000000000000432C4" data-uri="chapter05.xhtml#P70004970270000000000000000432C4" class="pcalibre calibre3 pcalibre1">The instruction control unit is responsible for reading instructions from memory and generating a sequence of primitive operations. The execution unit then performs the operations and indicates whether the branches were correctly predicted.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000235A4" data-uri="chapter05.xhtml#P70004970270000000000000000235A4">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000432C5" data-uri="chapter05.xhtml#P70004970270000000000000000432C5" class="pcalibre1 pcalibre calibre2">The components of the instruction control unit and execution unit are summarized below.</p>
<ul id="P70004970270000000000000000432C6" data-uri="chapter05.xhtml#P70004970270000000000000000432C6" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000432C7" data-uri="chapter05.xhtml#P70004970270000000000000000432C7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432C8" data-uri="chapter05.xhtml#P70004970270000000000000000432C8" class="pcalibre calibre3 pcalibre1">Instruction control unit: the register file, within the retirement unit, sends output to instruction decode. The instruction cache receives address from fetch control and sends instructions to instruction decode.</p></li>
<li id="P70004970270000000000000000432C9" data-uri="chapter05.xhtml#P70004970270000000000000000432C9" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432CA" data-uri="chapter05.xhtml#P70004970270000000000000000432CA" class="pcalibre calibre3 pcalibre1">Execution unit: the following function units interact with operation results: branch, arithmetic operations (two), load, and store. Load and store send and receive data between the data cache.</p></li>
<li id="P70004970270000000000000000432CB" data-uri="chapter05.xhtml#P70004970270000000000000000432CB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432CC" data-uri="chapter05.xhtml#P70004970270000000000000000432CC" class="pcalibre calibre3 pcalibre1">Operations from instruction decode are sent to the function units, and are also sent back to the retirement unit. Register updates are sent from operation results to the retirement unit. From branch, prediction ok? Is sent to the retirement unit and fetch control.</p></li>
</ul>
</details>
</figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000432CD" data-uri="chapter05.xhtml#P70004970270000000000000000432CD">instruction in the instruction sequence. Modern processors employ a technique known as <i class="calibre5 pcalibre pcalibre1">branch prediction</i>, in which they guess whether or not a branch will be taken and also predict the target address for the branch. Using a technique known as <i class="calibre5 pcalibre pcalibre1">speculative execution</i>, the processor begins fetching and decoding instructions at where it predicts the branch will go, and even begins executing these operations before it has been determined whether or not the branch prediction was correct. If it later determines that the branch was predicted incorrectly, it resets the state to that at the branch point and begins fetching and executing instructions in the other direction. The block labeled "Fetch control" incorporates branch prediction to perform the task of determining which instructions to fetch.</p>
<p id="P70004970270000000000000000432CE" data-uri="chapter05.xhtml#P70004970270000000000000000432CE" class="pcalibre1 pcalibre calibre2">The <i class="calibre5 pcalibre pcalibre1">instruction decoding</i> logic takes the actual program instructions and converts them into a set of primitive <i class="calibre5 pcalibre pcalibre1">operations</i> (sometimes referred to as <i class="calibre5 pcalibre pcalibre1">micro-operations</i>). Each of these operations performs some simple computational task such as adding two numbers, reading data from memory, or writing data to memory. For machines with complex instructions, such as x86 processors, an instruction <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004B7F" title="520" data-uri="chapter05.xhtml#P7000497027000000000000000004B7F" epub:type="pagebreak"></span>can be decoded into multiple operations. The details of how instructions are decoded into sequences of operations varies between machines, and this information is considered highly proprietary. Fortunately, we can optimize our programs without knowing the low-level details of a particular machine implementation.</p>
<p id="P70004970270000000000000000432CF" data-uri="chapter05.xhtml#P70004970270000000000000000432CF" class="pcalibre1 pcalibre calibre2">In a typical x86 implementation, an instruction that only operates on registers, such as</p>
<pre id="P70004970270000000000000000432D0" data-uri="chapter05.xhtml#P70004970270000000000000000432D0" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000432D1" data-uri="chapter05.xhtml#P70004970270000000000000000432D1" class="calibre10 pcalibre pcalibre1">
addq %rax,%rdx
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000432D2" data-uri="chapter05.xhtml#P70004970270000000000000000432D2">is converted into a single operation. On the other hand, an instruction involving one or more memory references, such as</p>
<pre id="P70004970270000000000000000432D3" data-uri="chapter05.xhtml#P70004970270000000000000000432D3" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000432D4" data-uri="chapter05.xhtml#P70004970270000000000000000432D4" class="calibre10 pcalibre pcalibre1">
addq %rax,8(%rdx)
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000432D5" data-uri="chapter05.xhtml#P70004970270000000000000000432D5">yields multiple operations, separating the memory references from the arithmetic operations. This particular instruction would be decoded as three operations: one to <i class="calibre5 pcalibre pcalibre1">load</i> a value from memory into the processor, one to add the loaded value to the value in register <code id="P70004970270000000000000000432D6" data-uri="chapter05.xhtml#P70004970270000000000000000432D6" class="pcalibre1 calibre8 pcalibre">%eax</code>, and one to <i class="calibre5 pcalibre pcalibre1">store</i> the result back to memory. The decoding splits instructions to allow a division of labor among a set of dedicated hardware units. These units can then execute the different parts of multiple instructions in parallel.</p>
<p id="P70004970270000000000000000432D7" data-uri="chapter05.xhtml#P70004970270000000000000000432D7" class="pcalibre1 pcalibre calibre2">The EU receives operations from the instruction fetch unit. Typically, it can receive a number of them on each clock cycle. These operations are dispatched to a set of <i class="calibre5 pcalibre pcalibre1">functional units</i> that perform the actual operations. These functional units are specialized to handle different types of operations.</p>
<p id="P70004970270000000000000000432D8" data-uri="chapter05.xhtml#P70004970270000000000000000432D8" class="pcalibre1 pcalibre calibre2">Reading and writing memory is implemented by the load and store units. The load unit handles operations that read data from the memory into the processor. This unit has an adder to perform address computations. Similarly, the store unit handles operations that write data from the processor to the memory. It also has an adder to perform address computations. As shown in the figure, the load and store units access memory via a <i class="calibre5 pcalibre pcalibre1">data cache</i>, a high-speed memory containing the most recently accessed data values.</p>
<p id="P70004970270000000000000000432D9" data-uri="chapter05.xhtml#P70004970270000000000000000432D9" class="pcalibre1 pcalibre calibre2">With speculative execution, the operations are evaluated, but the final results are not stored in the program registers or data memory until the processor can be certain that these instructions should actually have been executed. Branch operations are sent to the EU, not to determine where the branch should go, but rather to determine whether or not they were predicted correctly. If the prediction was incorrect, the EU will discard the results that have been computed beyond the branch point. It will also signal the branch unit that the prediction was incorrect and indicate the correct branch destination. In this case, the branch unit begins fetching at the new location. As we saw in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000002339_split_000.xhtml#P7000497027000000000000000002578"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">3.6.6</span></a>, such a <i class="calibre5 pcalibre pcalibre1">misprediction</i> incurs a significant cost in performance. It takes a while before the new instructions can be fetched, decoded, and sent to the functional units.</p>
<p id="P70004970270000000000000000432DA" data-uri="chapter05.xhtml#P70004970270000000000000000432DA" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004B76"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.11</span></a> indicates that the different functional units are designed to perform different operations. Those labeled as performing "arithmetic operations" are typically specialized to perform different combinations of integer and floating-point operations. As the number of transistors that can be integrated onto a single <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004B8C" title="521" data-uri="chapter05.xhtml#P7000497027000000000000000004B8C" epub:type="pagebreak"></span>microprocessor chip has grown over time, successive models of microprocessors have increased the total number of functional units, the combinations of operations each unit can perform, and the performance of each of these units. The arithmetic units are intentionally designed to be able to perform a variety of different operations, since the required operations vary widely across different programs. For example, some programs might involve many integer operations, while others require many floating-point operations. If one functional unit were specialized to perform integer operations while another could only perform floating-point operations, then none of these programs would get the full benefit of having multiple functional units.</p>
<p id="P70004970270000000000000000432DB" data-uri="chapter05.xhtml#P70004970270000000000000000432DB" class="pcalibre1 pcalibre calibre2">For example, our Intel Core i7 Has well reference machine has eight functional units, numbered 0−7. Here is a partial list of each one's capabilities:</p>
<ol start="0" id="P70004970270000000000000000432DC" data-uri="chapter05.xhtml#P70004970270000000000000000432DC" class="calibre72 pcalibre pcalibre1">
<li id="P70004970270000000000000000432DD" data-uri="chapter05.xhtml#P70004970270000000000000000432DD" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432DE" data-uri="chapter05.xhtml#P70004970270000000000000000432DE" class="pcalibre calibre3 pcalibre1">Integer arithmetic, floating-point multiplication, integer and floating-point division, branches</p></li>
<li id="P70004970270000000000000000432DF" data-uri="chapter05.xhtml#P70004970270000000000000000432DF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432E0" data-uri="chapter05.xhtml#P70004970270000000000000000432E0" class="pcalibre calibre3 pcalibre1">Integer arithmetic, floating-point addition, integer multiplication, floating-point multiplication</p></li>
<li id="P70004970270000000000000000432E1" data-uri="chapter05.xhtml#P70004970270000000000000000432E1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432E2" data-uri="chapter05.xhtml#P70004970270000000000000000432E2" class="pcalibre calibre3 pcalibre1">Load, address computation</p></li>
<li id="P70004970270000000000000000432E3" data-uri="chapter05.xhtml#P70004970270000000000000000432E3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432E4" data-uri="chapter05.xhtml#P70004970270000000000000000432E4" class="pcalibre calibre3 pcalibre1">Load, address computation</p></li>
<li id="P70004970270000000000000000432E5" data-uri="chapter05.xhtml#P70004970270000000000000000432E5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432E6" data-uri="chapter05.xhtml#P70004970270000000000000000432E6" class="pcalibre calibre3 pcalibre1">Store</p></li>
<li id="P70004970270000000000000000432E7" data-uri="chapter05.xhtml#P70004970270000000000000000432E7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432E8" data-uri="chapter05.xhtml#P70004970270000000000000000432E8" class="pcalibre calibre3 pcalibre1">Integer arithmetic</p></li>
<li id="P70004970270000000000000000432E9" data-uri="chapter05.xhtml#P70004970270000000000000000432E9" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432EA" data-uri="chapter05.xhtml#P70004970270000000000000000432EA" class="pcalibre calibre3 pcalibre1">Integer arithmetic, branches</p></li>
<li id="P70004970270000000000000000432EB" data-uri="chapter05.xhtml#P70004970270000000000000000432EB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000432EC" data-uri="chapter05.xhtml#P70004970270000000000000000432EC" class="pcalibre calibre3 pcalibre1">Store address computation</p></li>
</ol>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000432ED" data-uri="chapter05.xhtml#P70004970270000000000000000432ED">In the above list, "integer arithmetic" refers to basic operations, such as addition, bitwise operations, and shifting. Multiplication and division require more specialized resources. We see that a store operation requires two functional units—one to compute the store address and one to actually store the data. We will discuss the mechanics of store (and load) operations in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004F49"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">5.12</span></a>.</p>
<p id="P70004970270000000000000000432EE" data-uri="chapter05.xhtml#P70004970270000000000000000432EE" class="pcalibre1 pcalibre calibre2">We can see that this combination of functional units has the potential to perform multiple operations of the same type simultaneously. It has four units capable of performing integer operations, two that can perform load operations, and two that can perform floating-point multiplication. We will later see the impact these resources have on the maximum performance our programs can achieve.</p>
<p id="P70004970270000000000000000432EF" data-uri="chapter05.xhtml#P70004970270000000000000000432EF" class="pcalibre1 pcalibre calibre2">Within the ICU, the <i class="calibre5 pcalibre pcalibre1">retirement unit</i> keeps track of the ongoing processing and makes sure that it obeys the sequential semantics of the machine-level program. Our figure shows a <i class="calibre5 pcalibre pcalibre1">register file</i> containing the integer, floating-point, and, more recently, SSE and AVX registers as part of the retirement unit, because this unit controls the updating of these registers. As an instruction is decoded, information about it is placed into a first-in, first-out queue. This information remains in the queue until one of two outcomes occurs. First, once the operations for the instruction have completed and any branch points leading to this instruction are confirmed as having been correctly predicted, the instruction can be <i class="calibre5 pcalibre pcalibre1">retired</i>, with any updates to the program registers being made. If some branch point leading to this instruction was mispredicted, on the other hand, the instruction will be</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000004BA2" data-uri="chapter05.xhtml#P7000497027000000000000000004BA2"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P70004970270000000000000000432F0" data-uri="chapter05.xhtml#P70004970270000000000000000432F0" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004BA4" title="522" data-uri="chapter05.xhtml#P7000497027000000000000000004BA4" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>The history of out-of-order processing</h1></header>
<p id="P70004970270000000000000000432F1" data-uri="chapter05.xhtml#P70004970270000000000000000432F1" class="calibre13 pcalibre pcalibre1">Out-of-order processing was first implemented in the Control Data Corporation 6600 processor in 1964. Instructions were processed by 10 different functional units, each of which could be operated independently. In its day, this machine, with a clock rate of 10 MHz, was considered the premium machine for scientific computing.</p>
<p id="P70004970270000000000000000432F2" data-uri="chapter05.xhtml#P70004970270000000000000000432F2" class="pcalibre calibre3 pcalibre1">IBM first implemented out-of-order processing with the IBM 360/91 processor in 1966, but just to execute the floating-point instructions. For around 25 years, out-of-order processing was considered an exotic technology, found only in machines striving for the highest possible performance, until IBM reintroduced it in the RS/6000 line of workstations in 1990. This design became the basis for the IBM/Motorola PowerPC line, with the model 601, introduced in 1993, becoming the first single-chip microprocessor to use out-of-order processing. Intel introduced out-of-order processing with its PentiumPro model in 1995, with an underlying microarchitecture similar to that of our reference machine.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000432F3" data-uri="chapter05.xhtml#P70004970270000000000000000432F3"><i class="calibre5 pcalibre pcalibre1">flushed</i>, discarding any results that may have been computed. By this means, mispredictions will not alter the program state.</p>
<p id="P70004970270000000000000000432F4" data-uri="chapter05.xhtml#P70004970270000000000000000432F4" class="pcalibre1 pcalibre calibre2">As we have described, any updates to the program registers occur only as instructions are being retired, and this takes place only after the processor can be certain that any branches leading to this instruction have been correctly predicted. To expedite the communication of results from one instruction to another, much of this information is exchanged among the execution units, shown in the figure as "Operation results." As the arrows in the figure show, the execution units can send results directly to each other. This is a more elaborate form of the data-forwarding techniques we incorporated into our simple processor design in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000041EB_split_000.xhtml#P7000497027000000000000000004251"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">4.5.5</span></a>.</p>
<p id="P70004970270000000000000000432F5" data-uri="chapter05.xhtml#P70004970270000000000000000432F5" class="pcalibre1 pcalibre calibre2">The most common mechanism for controlling the communication of operands among the execution units is called <i class="calibre5 pcalibre pcalibre1">register renaming</i>. When an instruction that updates register <var class="calibre5 pcalibre pcalibre1">r</var> is decoded, a <i class="calibre5 pcalibre pcalibre1">tag t</i> is generated giving a unique identifier to the result of the operation. An entry <i class="calibre5 pcalibre pcalibre1">(r, t)</i> is added to a table maintaining the association between program register <var class="calibre5 pcalibre pcalibre1">r</var> and tag <var class="calibre5 pcalibre pcalibre1">t</var> for an operation that will update this register. When a subsequent instruction using register <var class="calibre5 pcalibre pcalibre1">r</var> as an operand is decoded, the operation sent to the execution unit will contain <var class="calibre5 pcalibre pcalibre1">t</var> as the source for the operand value. When some execution unit completes the first operation, it generates a result <i class="calibre5 pcalibre pcalibre1">(v, t)</i>, indicating that the operation with tag <var class="calibre5 pcalibre pcalibre1">t</var> produced value <var class="calibre5 pcalibre pcalibre1">v</var>. Any operation waiting for <var class="calibre5 pcalibre pcalibre1">t</var> as a source will then use <var class="calibre5 pcalibre pcalibre1">v</var> as the source value, a form of data forwarding. By this mechanism, values can be forwarded directly from one operation to another, rather than being written to and read from the register file, enabling the second operation to begin as soon as the first has completed. The renaming table only contains entries for registers having pending write operations. When a decoded instruction requires a register <var class="calibre5 pcalibre pcalibre1">r</var>, and there is no tag associated with this register, the operand is retrieved directly from the register file. With register renaming, an entire sequence of operations can be performed speculatively, even though the registers are updated only after the processor is certain of the branch outcomes.</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004BAA" data-uri="chapter05.xhtml#P7000497027000000000000000004BAA">
<table id="P70004970270000000000000000432F6" data-uri="chapter05.xhtml#P70004970270000000000000000432F6" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P70004970270000000000000000432F7" data-uri="chapter05.xhtml#P70004970270000000000000000432F7" class="calibre18 pcalibre pcalibre1"/>
<th colspan="3" id="P70004970270000000000000000432F8" data-uri="chapter05.xhtml#P70004970270000000000000000432F8" class="calibre18 pcalibre pcalibre1"><span class="pcalibre pagebreak1 pcalibre1" id="P7000497027000000000000000004BAE" title="523" data-uri="chapter05.xhtml#P7000497027000000000000000004BAE" epub:type="pagebreak"></span>Integer</th>
<th colspan="3" id="P70004970270000000000000000432F9" data-uri="chapter05.xhtml#P70004970270000000000000000432F9" class="calibre18 pcalibre pcalibre1">Floating point</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P70004970270000000000000000432FA" data-uri="chapter05.xhtml#P70004970270000000000000000432FA" class="calibre18 pcalibre pcalibre1">Operation</th>
<th id="P70004970270000000000000000432FB" data-uri="chapter05.xhtml#P70004970270000000000000000432FB" class="calibre18 pcalibre pcalibre1">Latency</th>
<th id="P70004970270000000000000000432FC" data-uri="chapter05.xhtml#P70004970270000000000000000432FC" class="calibre18 pcalibre pcalibre1">Issue</th>
<th id="P70004970270000000000000000432FD" data-uri="chapter05.xhtml#P70004970270000000000000000432FD" class="calibre18 pcalibre pcalibre1">Capacity</th>
<th id="P70004970270000000000000000432FE" data-uri="chapter05.xhtml#P70004970270000000000000000432FE" class="calibre18 pcalibre pcalibre1">Latency</th>
<th id="P70004970270000000000000000432FF" data-uri="chapter05.xhtml#P70004970270000000000000000432FF" class="calibre18 pcalibre pcalibre1">Issue</th>
<th id="P7000497027000000000000000043300" data-uri="chapter05.xhtml#P7000497027000000000000000043300" class="calibre18 pcalibre pcalibre1">Capacity</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043301" data-uri="chapter05.xhtml#P7000497027000000000000000043301" class="calibre20 pcalibre pcalibre1">Addition</td>
<td id="P7000497027000000000000000043302" data-uri="chapter05.xhtml#P7000497027000000000000000043302" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000043303" data-uri="chapter05.xhtml#P7000497027000000000000000043303" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000043304" data-uri="chapter05.xhtml#P7000497027000000000000000043304" class="calibre20 pcalibre pcalibre1">4</td>
<td id="P7000497027000000000000000043305" data-uri="chapter05.xhtml#P7000497027000000000000000043305" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P7000497027000000000000000043306" data-uri="chapter05.xhtml#P7000497027000000000000000043306" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000043307" data-uri="chapter05.xhtml#P7000497027000000000000000043307" class="calibre20 pcalibre pcalibre1">1</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043308" data-uri="chapter05.xhtml#P7000497027000000000000000043308" class="calibre20 pcalibre pcalibre1">Multiplication</td>
<td id="P7000497027000000000000000043309" data-uri="chapter05.xhtml#P7000497027000000000000000043309" class="calibre20 pcalibre pcalibre1">3</td>
<td id="P700049702700000000000000004330A" data-uri="chapter05.xhtml#P700049702700000000000000004330A" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P700049702700000000000000004330B" data-uri="chapter05.xhtml#P700049702700000000000000004330B" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P700049702700000000000000004330C" data-uri="chapter05.xhtml#P700049702700000000000000004330C" class="calibre20 pcalibre pcalibre1">5</td>
<td id="P700049702700000000000000004330D" data-uri="chapter05.xhtml#P700049702700000000000000004330D" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P700049702700000000000000004330E" data-uri="chapter05.xhtml#P700049702700000000000000004330E" class="calibre20 pcalibre pcalibre1">2</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004330F" data-uri="chapter05.xhtml#P700049702700000000000000004330F" class="calibre20 pcalibre pcalibre1">Division</td>
<td id="P7000497027000000000000000043310" data-uri="chapter05.xhtml#P7000497027000000000000000043310" class="calibre20 pcalibre pcalibre1">3−30</td>
<td id="P7000497027000000000000000043311" data-uri="chapter05.xhtml#P7000497027000000000000000043311" class="calibre20 pcalibre pcalibre1">3−30</td>
<td id="P7000497027000000000000000043312" data-uri="chapter05.xhtml#P7000497027000000000000000043312" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000043313" data-uri="chapter05.xhtml#P7000497027000000000000000043313" class="calibre20 pcalibre pcalibre1">3−15</td>
<td id="P7000497027000000000000000043314" data-uri="chapter05.xhtml#P7000497027000000000000000043314" class="calibre20 pcalibre pcalibre1">3−15</td>
<td id="P7000497027000000000000000043315" data-uri="chapter05.xhtml#P7000497027000000000000000043315" class="calibre20 pcalibre pcalibre1">1</td>
</tr>
</tbody>
</table>
<figcaption id="P7000497027000000000000000043316" data-uri="chapter05.xhtml#P7000497027000000000000000043316" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000043317" data-uri="chapter05.xhtml#P7000497027000000000000000043317" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">5.12 </span>Latency, issue time, and capacity characteristics of reference machine operations.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000043318" data-uri="chapter05.xhtml#P7000497027000000000000000043318"><p id="P7000497027000000000000000043319" data-uri="chapter05.xhtml#P7000497027000000000000000043319" class="pcalibre calibre3 pcalibre1">Latency indicates the total number of clock cycles required to perform the actual operations, while issue time indicates the minimum number of cycles between two independent operations. The capacity indicates how many of these operations can be issued simultaneously. The times for division depend on the data values.</p></div></figcaption></figure>
</section>
<section id="P7000497027000000000000000004BD0" data-uri="chapter05.xhtml#P7000497027000000000000000004BD0" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004331A" data-uri="chapter05.xhtml#P700049702700000000000000004331A" epub:type="title"><span class="pcalibre label pcalibre1">5.7.2 </span>Functional Unit Performance</h1></header>
<p id="P700049702700000000000000004331B" data-uri="chapter05.xhtml#P700049702700000000000000004331B" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004BAA"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.12</span></a> documents the performance of some of the arithmetic operations for our Intel Core i7 Haswell reference machine, determined by both measurements and by reference to Intel literature [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B404">49</a>]. These timings are typical for other processors as well. Each operation is characterized by its <i class="calibre5 pcalibre pcalibre1">latency</i>, meaning the total time required to perform the operation, the <i class="calibre5 pcalibre pcalibre1">issue time</i>, meaning the minimum number of clock cycles between two independent operations of the same type, and the <i class="calibre5 pcalibre pcalibre1">capacity</i>, indicating the number of functional units capable of performing that operation.</p>
<p id="P700049702700000000000000004331C" data-uri="chapter05.xhtml#P700049702700000000000000004331C" class="pcalibre1 pcalibre calibre2">We see that the latencies increase in going from integer to floating-point operations. We see also that the addition and multiplication operations all have issue times of 1, meaning that on each clock cycle, the processor can start a new one of these operations. This short issue time is achieved through the use of <i class="calibre5 pcalibre pcalibre1">pipelining</i>. A pipelined function unit is implemented as a series of <i class="calibre5 pcalibre pcalibre1">stages</i>, each of which performs part of the operation. For example, a typical floating-point adder contains three stages (and hence the three-cycle latency): one to process the exponent values, one to add the fractions, and one to round the result. The arithmetic operations can proceed through the stages in close succession rather than waiting for one operation to complete before the next begins. This capability can be exploited only if there are successive, logically independent operations to be performed. Functional units with issue times of 1 cycle are said to be <i class="calibre5 pcalibre pcalibre1">fully pipelined:</i> they can start a new operation every clock cycle. Operations with capacity greater than 1 arise due to the capabilities of the multiple functional units, as was described earlier for the reference machine.</p>
<p id="P700049702700000000000000004331D" data-uri="chapter05.xhtml#P700049702700000000000000004331D" class="pcalibre1 pcalibre calibre2">We see also that the divider (used for integer and floating-point division, as well as floating-point square root) is not pipelined—its issue time equals its latency. What this means is that the divider must perform a complete division before it can begin anew one. We also see that the latencies and issue times for division are given as ranges, because some combinations of dividend and divisor require more steps than others. The long latency and issue times of division make it a comparatively costly operation.</p>
<p id="P700049702700000000000000004331E" data-uri="chapter05.xhtml#P700049702700000000000000004331E" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004BD6" title="524" data-uri="chapter05.xhtml#P7000497027000000000000000004BD6" epub:type="pagebreak"></span>A more common way of expressing issue time is to specify the maximum <i class="calibre5 pcalibre pcalibre1">throughput</i> of the unit, defined as the reciprocal of the issue time. A fully pipelined functional unit has a maximum throughput of 1 operation per clock cycle, while units with higher issue times have lower maximum throughput. Having multiple functional units can increase throughput even further. For an operation with capacity <var class="calibre5 pcalibre pcalibre1">C</var> and issue time <var class="calibre5 pcalibre pcalibre1">I</var>, the processor can potentially achieve a throughput of <i class="calibre5 pcalibre pcalibre1">C/I</i> operations per clock cycle. For example, our reference machine is capable of performing floating-point multiplication operations at a rate of 2 per clock cycle. We will see how this capability can be exploited to increase program performance.</p>
<p id="P700049702700000000000000004331F" data-uri="chapter05.xhtml#P700049702700000000000000004331F" class="pcalibre1 pcalibre calibre2">Circuit designers can create functional units with wide ranges of performance characteristics. Creating a unit with short latency or with pipelining requires more hardware, especially for more complex functions such as multiplication and floating-point operations. Since there is only a limited amount of space for these units on the microprocessor chip, CPU designers must carefully balance the number of functional units and their individual performance to achieve optimal overall performance. They evaluate many different benchmark programs and dedicate the most resources to the most critical operations. As <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004BAA"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.12</span></a> indicates, integer multiplication and floating-point multiplication and addition were considered important operations in the design of the Core i7 Haswell processor, even though a significant amount of hardware is required to achieve the low latencies and high degree of pipelining shown. On the other hand, division is relatively infrequent and difficult to implement with either short latency or full pipelining.</p>
<p id="P7000497027000000000000000043320" data-uri="chapter05.xhtml#P7000497027000000000000000043320" class="pcalibre1 pcalibre calibre2">The latencies, issue times, and capacities of these arithmetic operations can affect the performance of our combining functions. We can express these effects in terms of two fundamental bounds on the CPE values:</p>
<table id="P7000497027000000000000000043321" data-uri="chapter05.xhtml#P7000497027000000000000000043321" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000043322" data-uri="chapter05.xhtml#P7000497027000000000000000043322" class="calibre18 pcalibre pcalibre1"/>
<th colspan="2" id="P7000497027000000000000000043323" data-uri="chapter05.xhtml#P7000497027000000000000000043323" class="calibre18 pcalibre pcalibre1">Integer</th>
<th colspan="2" id="P7000497027000000000000000043324" data-uri="chapter05.xhtml#P7000497027000000000000000043324" class="calibre18 pcalibre pcalibre1">Floating point</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000043325" data-uri="chapter05.xhtml#P7000497027000000000000000043325" class="calibre18 pcalibre pcalibre1">Bound</th>
<th id="P7000497027000000000000000043326" data-uri="chapter05.xhtml#P7000497027000000000000000043326" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P7000497027000000000000000043327" data-uri="chapter05.xhtml#P7000497027000000000000000043327" class="calibre18 pcalibre pcalibre1">*</th>
<th id="P7000497027000000000000000043328" data-uri="chapter05.xhtml#P7000497027000000000000000043328" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P7000497027000000000000000043329" data-uri="chapter05.xhtml#P7000497027000000000000000043329" class="calibre18 pcalibre pcalibre1">*</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004332A" data-uri="chapter05.xhtml#P700049702700000000000000004332A" class="calibre20 pcalibre pcalibre1">Latency</td>
<td id="P700049702700000000000000004332B" data-uri="chapter05.xhtml#P700049702700000000000000004332B" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P700049702700000000000000004332C" data-uri="chapter05.xhtml#P700049702700000000000000004332C" class="calibre20 pcalibre pcalibre1">3.00</td>
<td id="P700049702700000000000000004332D" data-uri="chapter05.xhtml#P700049702700000000000000004332D" class="calibre20 pcalibre pcalibre1">3.00</td>
<td id="P700049702700000000000000004332E" data-uri="chapter05.xhtml#P700049702700000000000000004332E" class="calibre20 pcalibre pcalibre1">5.00</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004332F" data-uri="chapter05.xhtml#P700049702700000000000000004332F" class="calibre20 pcalibre pcalibre1">Throughput</td>
<td id="P7000497027000000000000000043330" data-uri="chapter05.xhtml#P7000497027000000000000000043330" class="calibre20 pcalibre pcalibre1">0.50</td>
<td id="P7000497027000000000000000043331" data-uri="chapter05.xhtml#P7000497027000000000000000043331" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000043332" data-uri="chapter05.xhtml#P7000497027000000000000000043332" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000043333" data-uri="chapter05.xhtml#P7000497027000000000000000043333" class="calibre20 pcalibre pcalibre1">0.50</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000043334" data-uri="chapter05.xhtml#P7000497027000000000000000043334">The <i class="calibre5 pcalibre pcalibre1">latency bound</i> gives a minimum value for the CPE for any function that must perform the combining operation in a strict sequence. The <i class="calibre5 pcalibre pcalibre1">throughput bound</i> gives a minimum bound for the CPE based on the maximum rate at which the functional units can produce results. For example, since there is only one integer multiplier, and it has an issue time of 1 clock cycle, the processor cannot possibly sustain a rate of more than 1 multiplication per clock cycle. On the other hand, with four functional units capable of performing integer addition, the processor can potentially sustain a rate of 4 operations per cycle. Unfortunately, the need to read elements from memory creates an additional throughput bound. The two load units limit the processor to reading at most 2 data values per clock cycle, yielding a throughput bound of 0.50. We will demonstrate the effect of both the latency and throughput bounds with different versions of the combining functions.</p>
</section>
<section id="P7000497027000000000000000004BED" data-uri="chapter05.xhtml#P7000497027000000000000000004BED" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000043335" data-uri="chapter05.xhtml#P7000497027000000000000000043335" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004BEF" title="525" data-uri="chapter05.xhtml#P7000497027000000000000000004BEF" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">5.7.3 </span>An Abstract Model of Processor Operation</h1></header>
<p id="P7000497027000000000000000043336" data-uri="chapter05.xhtml#P7000497027000000000000000043336" class="pcalibre1 pcalibre calibre2">As a tool for analyzing the performance of a machine-level program executing on a modern processor, we will use a <i class="calibre5 pcalibre pcalibre1">data-flow</i> representation of programs, a graphical notation showing how the data dependencies between the different operations constrain the order in which they are executed. These constraints then lead to <i class="calibre5 pcalibre pcalibre1">critical paths</i> in the graph, putting a lower bound on the number of clock cycles required to execute a set of machine instructions.</p>
<p id="P7000497027000000000000000043337" data-uri="chapter05.xhtml#P7000497027000000000000000043337" class="pcalibre1 pcalibre calibre2">Before proceeding with the technical details, it is instructive to examine the CPE measurements obtained for function <code id="P7000497027000000000000000043338" data-uri="chapter05.xhtml#P7000497027000000000000000043338" class="pcalibre1 calibre8 pcalibre">combine4</code>, our fastest code up to this point:</p>
<table id="P7000497027000000000000000043339" data-uri="chapter05.xhtml#P7000497027000000000000000043339" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P700049702700000000000000004333A" data-uri="chapter05.xhtml#P700049702700000000000000004333A" class="calibre18 pcalibre pcalibre1"/>
<th id="P700049702700000000000000004333B" data-uri="chapter05.xhtml#P700049702700000000000000004333B" class="calibre18 pcalibre pcalibre1"/>
<th id="P700049702700000000000000004333C" data-uri="chapter05.xhtml#P700049702700000000000000004333C" class="calibre18 pcalibre pcalibre1"/>
<th colspan="2" id="P700049702700000000000000004333D" data-uri="chapter05.xhtml#P700049702700000000000000004333D" class="calibre18 pcalibre pcalibre1">Integer</th>
<th colspan="2" id="P700049702700000000000000004333E" data-uri="chapter05.xhtml#P700049702700000000000000004333E" class="calibre18 pcalibre pcalibre1">Floating point</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P700049702700000000000000004333F" data-uri="chapter05.xhtml#P700049702700000000000000004333F" class="calibre18 pcalibre pcalibre1">Function</th>
<th id="P7000497027000000000000000043340" data-uri="chapter05.xhtml#P7000497027000000000000000043340" class="calibre18 pcalibre pcalibre1">Page</th>
<th id="P7000497027000000000000000043341" data-uri="chapter05.xhtml#P7000497027000000000000000043341" class="calibre18 pcalibre pcalibre1">Method</th>
<th id="P7000497027000000000000000043342" data-uri="chapter05.xhtml#P7000497027000000000000000043342" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P7000497027000000000000000043343" data-uri="chapter05.xhtml#P7000497027000000000000000043343" class="calibre18 pcalibre pcalibre1">*</th>
<th id="P7000497027000000000000000043344" data-uri="chapter05.xhtml#P7000497027000000000000000043344" class="calibre18 pcalibre pcalibre1">+</th>
<th id="P7000497027000000000000000043345" data-uri="chapter05.xhtml#P7000497027000000000000000043345" class="calibre18 pcalibre pcalibre1">*</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000043346" data-uri="chapter05.xhtml#P7000497027000000000000000043346" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000043347" data-uri="chapter05.xhtml#P7000497027000000000000000043347" class="calibre10 pcalibre pcalibre1">combine4</code></td>
<td id="P7000497027000000000000000043348" data-uri="chapter05.xhtml#P7000497027000000000000000043348" class="calibre20 pcalibre pcalibre1">515</td>
<td id="P7000497027000000000000000043349" data-uri="chapter05.xhtml#P7000497027000000000000000043349" class="calibre20 pcalibre pcalibre1">Accumulate in temporary</td>
<td id="P700049702700000000000000004334A" data-uri="chapter05.xhtml#P700049702700000000000000004334A" class="calibre20 pcalibre pcalibre1">1.27</td>
<td id="P700049702700000000000000004334B" data-uri="chapter05.xhtml#P700049702700000000000000004334B" class="calibre20 pcalibre pcalibre1">3.01</td>
<td id="P700049702700000000000000004334C" data-uri="chapter05.xhtml#P700049702700000000000000004334C" class="calibre20 pcalibre pcalibre1">3.01</td>
<td id="P700049702700000000000000004334D" data-uri="chapter05.xhtml#P700049702700000000000000004334D" class="calibre20 pcalibre pcalibre1">5.01</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="3" id="P700049702700000000000000004334E" data-uri="chapter05.xhtml#P700049702700000000000000004334E" class="calibre20 pcalibre pcalibre1">Latency bound</td>
<td id="P700049702700000000000000004334F" data-uri="chapter05.xhtml#P700049702700000000000000004334F" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000043350" data-uri="chapter05.xhtml#P7000497027000000000000000043350" class="calibre20 pcalibre pcalibre1">3.00</td>
<td id="P7000497027000000000000000043351" data-uri="chapter05.xhtml#P7000497027000000000000000043351" class="calibre20 pcalibre pcalibre1">3.00</td>
<td id="P7000497027000000000000000043352" data-uri="chapter05.xhtml#P7000497027000000000000000043352" class="calibre20 pcalibre pcalibre1">5.00</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td colspan="3" id="P7000497027000000000000000043353" data-uri="chapter05.xhtml#P7000497027000000000000000043353" class="calibre20 pcalibre pcalibre1">Throughput bound</td>
<td id="P7000497027000000000000000043354" data-uri="chapter05.xhtml#P7000497027000000000000000043354" class="calibre20 pcalibre pcalibre1">0.50</td>
<td id="P7000497027000000000000000043355" data-uri="chapter05.xhtml#P7000497027000000000000000043355" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000043356" data-uri="chapter05.xhtml#P7000497027000000000000000043356" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000043357" data-uri="chapter05.xhtml#P7000497027000000000000000043357" class="calibre20 pcalibre pcalibre1">0.50</td>
</tr>
</tbody>
</table>
<p id="P7000497027000000000000000043358" data-uri="chapter05.xhtml#P7000497027000000000000000043358" class="pcalibre1 pcalibre calibre2">We can see that these measurements match the latency bound for the processor, except for the case of integer addition. This is not a coincidence—it indicates that the performance of these functions is dictated by the latency of the sum or product computation being performed. Computing the product or sum of <var class="calibre5 pcalibre pcalibre1">n</var> elements requires around <i class="calibre5 pcalibre pcalibre1">L · n</i> + <var class="calibre5 pcalibre pcalibre1">K</var> clock cycles, where <var class="calibre5 pcalibre pcalibre1">L</var> is the latency of the combining operation and <var class="calibre5 pcalibre pcalibre1">K</var> represents the overhead of calling the function and initiating and terminating the loop. The CPE is therefore equal to the latency bound <var class="calibre5 pcalibre pcalibre1">L</var>.</p>
<section id="P7000497027000000000000000004C13" data-uri="chapter05.xhtml#P7000497027000000000000000004C13" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000043359" data-uri="chapter05.xhtml#P7000497027000000000000000043359" epub:type="title">From Machine-Level Code to Data-Flow Graphs</h1></header>
<p id="P700049702700000000000000004335A" data-uri="chapter05.xhtml#P700049702700000000000000004335A" class="pcalibre1 pcalibre calibre2">Our data-flow representation of programs is informal. We use it as a way to visualize how the data dependencies in a program dictate its performance. We present the data-flow notation by working with <code id="P700049702700000000000000004335B" data-uri="chapter05.xhtml#P700049702700000000000000004335B" class="pcalibre1 calibre8 pcalibre">combine4</code> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004AB6.xhtml#P7000497027000000000000000004AD0"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.10</span></a>) as an example. We focus just on the computation performed by the loop, since this is the dominating factor in performance for large vectors. We consider the case of data type <code id="P700049702700000000000000004335C" data-uri="chapter05.xhtml#P700049702700000000000000004335C" class="pcalibre1 calibre8 pcalibre">double</code> with multiplication as the combining operation. Other combinations of data type and operation yield similar code. The compiled code for this loop consists of four instructions, with registers <code id="P700049702700000000000000004335D" data-uri="chapter05.xhtml#P700049702700000000000000004335D" class="pcalibre1 calibre8 pcalibre">%rdx</code> holding a pointer to the <var class="calibre5 pcalibre pcalibre1">i</var>th element of array data, <code id="P700049702700000000000000004335E" data-uri="chapter05.xhtml#P700049702700000000000000004335E" class="pcalibre1 calibre8 pcalibre">%rax</code> holding a pointer to the end of the array, and <code id="P700049702700000000000000004335F" data-uri="chapter05.xhtml#P700049702700000000000000004335F" class="pcalibre1 calibre8 pcalibre">%xmm0</code> holding the accumulated value <code id="P7000497027000000000000000043360" data-uri="chapter05.xhtml#P7000497027000000000000000043360" class="pcalibre1 calibre8 pcalibre">acc</code>.</p>
<pre id="P7000497027000000000000000043361" data-uri="chapter05.xhtml#P7000497027000000000000000043361" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043362" data-uri="chapter05.xhtml#P7000497027000000000000000043362" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">Inner loop of combine4. data_t = double, OP = *</i>
	<i class="calibre5 pcalibre pcalibre1">acc in %xmm0, data+i in %rdx, data+length in %rax</i>
1	.L25:				<b class="calibre4 pcalibre pcalibre1">loop:</b>
2	  vmulsd (%rdx), %xmm0, %xmm0	  <i class="calibre5 pcalibre pcalibre1">Multiply acc by data[i]</i>
3	  addq $8, %rdx			  <i class="calibre5 pcalibre pcalibre1">Increment data+i</i>
4	  cmpq %rax, %rdx		  <i class="calibre5 pcalibre pcalibre1">Compare to data+length</i>
5	  jne .L25			  <i class="calibre5 pcalibre pcalibre1">If !=, goto</i> loop
</code></pre>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004C1E" data-uri="chapter05.xhtml#P7000497027000000000000000004C1E">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004C1F" title="526" data-uri="chapter05.xhtml#P7000497027000000000000000004C1F" epub:type="pagebreak"></span>
<img alt="A diagram depicts the graphical representation of inner-loop code for combine4." id="P7000497027000000000000000043363" data-uri="P700049702700000000000000000B712" src="../images/p526-1.png" class="pcalibre1 calibre172 pcalibre"/>
<figcaption id="P7000497027000000000000000043364" data-uri="chapter05.xhtml#P7000497027000000000000000043364" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000043365" data-uri="chapter05.xhtml#P7000497027000000000000000043365" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">5.13 </span>Graphical representation of inner-loop code for <code id="P7000497027000000000000000043366" data-uri="chapter05.xhtml#P7000497027000000000000000043366" class="pcalibre1 calibre8 pcalibre">combine4</code></h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043367" data-uri="chapter05.xhtml#P7000497027000000000000000043367"><p id="P7000497027000000000000000043368" data-uri="chapter05.xhtml#P7000497027000000000000000043368" class="pcalibre calibre3 pcalibre1">Instructions are dynamically translated into one or two operations, each of which receives values from other operations or from registers and produces values for other operations and for registers. We show the target of the final instruction as the label loop. It jumps to the first instruction shown.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000023649" data-uri="chapter05.xhtml#P7000497027000000000000000023649">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000043369" data-uri="chapter05.xhtml#P7000497027000000000000000043369" class="pcalibre1 pcalibre calibre2">A diagram has two rows of boxes, each with %rax, %rdx, and %rmm0, with output from top %rax to bottom %rax. A column of boxes includes the five operations summarized below, from top to bottom:</p>
<ul id="P700049702700000000000000004336A" data-uri="chapter05.xhtml#P700049702700000000000000004336A" class="pcalibre calibre31 pcalibre1">
<li id="P700049702700000000000000004336B" data-uri="chapter05.xhtml#P700049702700000000000000004336B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004336C" data-uri="chapter05.xhtml#P700049702700000000000000004336C" class="pcalibre calibre3 pcalibre1">load: receives input from top %rdx; sends output to mul below</p></li>
<li id="P700049702700000000000000004336D" data-uri="chapter05.xhtml#P700049702700000000000000004336D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004336E" data-uri="chapter05.xhtml#P700049702700000000000000004336E" class="pcalibre calibre3 pcalibre1">mul: receives input from load, with the two together representing vmulsd (%rdx), %rmm0, %rmm0; receives input from top %rmm0</p></li>
<li id="P700049702700000000000000004336F" data-uri="chapter05.xhtml#P700049702700000000000000004336F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043370" data-uri="chapter05.xhtml#P7000497027000000000000000043370" class="pcalibre calibre3 pcalibre1">add (addq $8, %rdx): receives input from top %rdx and sends output to bottom %rmm0</p></li>
<li id="P7000497027000000000000000043371" data-uri="chapter05.xhtml#P7000497027000000000000000043371" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043372" data-uri="chapter05.xhtml#P7000497027000000000000000043372" class="pcalibre calibre3 pcalibre1">cmp (cmpq %rax, %rdx): receives input from add above and top %rax; sends output to jne below</p></li>
<li id="P7000497027000000000000000043373" data-uri="chapter05.xhtml#P7000497027000000000000000043373" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043374" data-uri="chapter05.xhtml#P7000497027000000000000000043374" class="pcalibre calibre3 pcalibre1">jne (jne loop); receives input from cmp above and top %rax</p></li>
</ul>
</details>
</figcaption></figure>
<p id="P7000497027000000000000000043375" data-uri="chapter05.xhtml#P7000497027000000000000000043375" class="pcalibre1 pcalibre calibre2">As <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C1E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.13</span></a> indicates, with our hypothetical processor design, the four instructions are expanded by the instruction decoder into a series of five <i class="calibre5 pcalibre pcalibre1">operations</i>, with the initial multiplication instruction being expanded into a load operation to read the source operand from memory, and a mul operation to perform the multiplication.</p>
<p id="P7000497027000000000000000043376" data-uri="chapter05.xhtml#P7000497027000000000000000043376" class="pcalibre1 pcalibre calibre2">As a step toward generating a data-flow graph representation of the program, the boxes and lines along the left-hand side of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C1E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.13</span></a> show how the registers are used and updated by the different operations, with the boxes along the top representing the register values at the beginning of the loop, and those along the bottom representing the values at the end. For example, register <code id="P7000497027000000000000000043377" data-uri="chapter05.xhtml#P7000497027000000000000000043377" class="pcalibre1 calibre8 pcalibre">%rax</code> is only used as a source value by the <code id="P7000497027000000000000000043378" data-uri="chapter05.xhtml#P7000497027000000000000000043378" class="pcalibre1 calibre8 pcalibre">cmp</code> operation, and so the register has the same value at the end of the loop as at the beginning. Register <code id="P7000497027000000000000000043379" data-uri="chapter05.xhtml#P7000497027000000000000000043379" class="pcalibre1 calibre8 pcalibre">%rdx</code>, on the other hand, is both used and updated within the loop. Its initial value is used by the load and add operations; its new value is generated by the add operation, which is then used by the <code id="P700049702700000000000000004337A" data-uri="chapter05.xhtml#P700049702700000000000000004337A" class="pcalibre1 calibre8 pcalibre">cmp</code> operation. Register <code id="P700049702700000000000000004337B" data-uri="chapter05.xhtml#P700049702700000000000000004337B" class="pcalibre1 calibre8 pcalibre">%xmm0</code> is also updated within the loop by the mul operation, which first uses the initial value as a source value.</p>
<p id="P700049702700000000000000004337C" data-uri="chapter05.xhtml#P700049702700000000000000004337C" class="pcalibre1 pcalibre calibre2">Some of the operations in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C1E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.13</span></a> produce values that do not correspond to registers. We show these as arcs between operations on the right-hand side. The load operation reads a value from memory and passes it directly to the <code id="P700049702700000000000000004337D" data-uri="chapter05.xhtml#P700049702700000000000000004337D" class="pcalibre1 calibre8 pcalibre">mul</code> operation. Since these two operations arise from decoding a single <code id="P700049702700000000000000004337E" data-uri="chapter05.xhtml#P700049702700000000000000004337E" class="pcalibre1 calibre8 pcalibre">vmulsd</code> instruction, there is no register associated with the intermediate value passing between them. The <code id="P700049702700000000000000004337F" data-uri="chapter05.xhtml#P700049702700000000000000004337F" class="pcalibre1 calibre8 pcalibre">cmp</code> operation updates the condition codes, and these are then tested by the <code id="P7000497027000000000000000043380" data-uri="chapter05.xhtml#P7000497027000000000000000043380" class="pcalibre1 calibre8 pcalibre">jne</code> operation.</p>
<p id="P7000497027000000000000000043381" data-uri="chapter05.xhtml#P7000497027000000000000000043381" class="pcalibre1 pcalibre calibre2">For a code segment forming a loop, we can classify the registers that are accessed into four categories:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004C33" data-uri="chapter05.xhtml#P7000497027000000000000000004C33">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004C34" title="527" data-uri="chapter05.xhtml#P7000497027000000000000000004C34" epub:type="pagebreak"></span>
<img alt="A diagram depicts two data-flow graphs for combine4." id="P7000497027000000000000000043382" data-uri="P700049702700000000000000000B713" src="../images/p527-1.png" class="calibre173 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000043383" data-uri="chapter05.xhtml#P7000497027000000000000000043383" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000043384" data-uri="chapter05.xhtml#P7000497027000000000000000043384" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">5.14 </span>Abstracting <code id="P7000497027000000000000000043385" data-uri="chapter05.xhtml#P7000497027000000000000000043385" class="pcalibre1 calibre8 pcalibre">combine4</code> operations as a data-flow graph.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043386" data-uri="chapter05.xhtml#P7000497027000000000000000043386"><p id="P7000497027000000000000000043387" data-uri="chapter05.xhtml#P7000497027000000000000000043387" class="pcalibre calibre3 pcalibre1">We rearrange the operators of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C1E"><span class="pcalibre label pcalibre1">Figure </span><span class="number pcalibre pcalibre1">5.13</span></a> to more clearly show the data dependencies (a), and then further show only those operations that use values from one iteration to produce new values for the next (b).</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000023669" data-uri="chapter05.xhtml#P7000497027000000000000000023669">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<ol class="pcalibre1 pcalibre ol_lower-alpha1" id="P7000497027000000000000000043388" data-uri="chapter05.xhtml#P7000497027000000000000000043388">
<li id="P7000497027000000000000000043389" data-uri="chapter05.xhtml#P7000497027000000000000000043389" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004338A" data-uri="chapter05.xhtml#P700049702700000000000000004338A" class="pcalibre calibre3 pcalibre1">Data flows from top %rmm0 to mul to bottom %rmm0; from top %rax to cmp to jne; from top %rdx to load and add. From load, data is sent to mul and bottom %rmm0. From add, data is sent to bottom %rdx and to cmp, sent to jne.</p></li>
<li id="P700049702700000000000000004338B" data-uri="chapter05.xhtml#P700049702700000000000000004338B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004338C" data-uri="chapter05.xhtml#P700049702700000000000000004338C" class="pcalibre calibre3 pcalibre1">Operations within data[i]: data flows from top %rmm0 to mul to bottom %rmm0; from top %rdx to load and add, with load leading to mul and add leading to bottom %rdx.</p></li>
</ol>
</details>

</figcaption></figure>
<ul class="pcalibre ul_none pcalibre1" id="P700049702700000000000000004338D" data-uri="chapter05.xhtml#P700049702700000000000000004338D">
<li id="P700049702700000000000000004338E" data-uri="chapter05.xhtml#P700049702700000000000000004338E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004338F" data-uri="chapter05.xhtml#P700049702700000000000000004338F" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Read-only. </span>These are used as source values, either as data or to compute memory addresses, but they are not modified within the loop. The only read only register for the loop in <code id="P7000497027000000000000000043390" data-uri="chapter05.xhtml#P7000497027000000000000000043390" class="pcalibre1 calibre8 pcalibre">combine4</code> is <code id="P7000497027000000000000000043391" data-uri="chapter05.xhtml#P7000497027000000000000000043391" class="pcalibre1 calibre8 pcalibre">%rax</code>.</p></li>
<li id="P7000497027000000000000000043392" data-uri="chapter05.xhtml#P7000497027000000000000000043392" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043393" data-uri="chapter05.xhtml#P7000497027000000000000000043393" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Write-only. </span>These are used as the destinations of data-movement operations. There are no such registers in this loop.</p></li>
<li id="P7000497027000000000000000043394" data-uri="chapter05.xhtml#P7000497027000000000000000043394" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043395" data-uri="chapter05.xhtml#P7000497027000000000000000043395" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Local. </span>These are updated and used within the loop, but there is no dependency from one iteration to another. The condition code registers are examples for this loop: they are updated by the <code id="P7000497027000000000000000043396" data-uri="chapter05.xhtml#P7000497027000000000000000043396" class="pcalibre1 calibre8 pcalibre">cmp</code> operation and used by the <code id="P7000497027000000000000000043397" data-uri="chapter05.xhtml#P7000497027000000000000000043397" class="pcalibre1 calibre8 pcalibre">jne</code> operation, but this dependency is contained within individual iterations.</p></li>
<li id="P7000497027000000000000000043398" data-uri="chapter05.xhtml#P7000497027000000000000000043398" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043399" data-uri="chapter05.xhtml#P7000497027000000000000000043399" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Loop. </span>These are used both as source values and as destinations for the loop, with the value generated in one iteration being used in another. We can see that <code id="P700049702700000000000000004339A" data-uri="chapter05.xhtml#P700049702700000000000000004339A" class="pcalibre1 calibre8 pcalibre">%rdx</code> and <code id="P700049702700000000000000004339B" data-uri="chapter05.xhtml#P700049702700000000000000004339B" class="pcalibre1 calibre8 pcalibre">%xmm0</code> are loop registers for <code id="P700049702700000000000000004339C" data-uri="chapter05.xhtml#P700049702700000000000000004339C" class="pcalibre1 calibre8 pcalibre">combine4</code>, corresponding to program values <code id="P700049702700000000000000004339D" data-uri="chapter05.xhtml#P700049702700000000000000004339D" class="pcalibre1 calibre8 pcalibre">data+i</code> and <code id="P700049702700000000000000004339E" data-uri="chapter05.xhtml#P700049702700000000000000004339E" class="pcalibre1 calibre8 pcalibre">acc</code>.</p></li>
</ul>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004339F" data-uri="chapter05.xhtml#P700049702700000000000000004339F">As we will see, the chains of operations between loop registers determine the performance-limiting data dependencies.</p>
<p id="P70004970270000000000000000433A0" data-uri="chapter05.xhtml#P70004970270000000000000000433A0" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C33"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.14</span></a> shows further refinements of the graphical representation of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C1E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.13</span></a>, with a goal of showing only those operations and data dependencies that affect the program execution time. We see in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C33"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.14(a)</span></a> that we rearranged the operators to show more clearly the flow of data from the source registers at the top (both read-only and loop registers) and to the destination registers at the bottom (both write-only and loop registers).</p>
<p id="P70004970270000000000000000433A1" data-uri="chapter05.xhtml#P70004970270000000000000000433A1" class="pcalibre1 pcalibre calibre2">In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C33"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.14(a)</span></a>, we also color operators white if they are not part of some chain of dependencies between loop registers. For this example, the comparison (cmp) and branch (jne) operations do not directly affect the flow of data in the program. We assume that the instruction control unit predicts that branch will be taken, and hence the program will continue looping. The purpose of the compare and branch operations is to test the branch condition and notify the ICU if it is <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004C50" title="528" data-uri="chapter05.xhtml#P7000497027000000000000000004C50" epub:type="pagebreak"></span>not taken. We assume this checking can be done quickly enough that it does not slow down the processor.</p>
<p id="P70004970270000000000000000433A2" data-uri="chapter05.xhtml#P70004970270000000000000000433A2" class="pcalibre1 pcalibre calibre2">In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C33"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.14(b)</span></a>, we have eliminated the operators that were colored white on the left, and we have retained only the loop registers. What we have left is an abstract template showing the data dependencies that form among loop registers due to one iteration of the loop. We can see in this diagram that there are two data dependencies from one iteration to the next. Along one side, we see the dependencies between successive values of program value <code id="P70004970270000000000000000433A3" data-uri="chapter05.xhtml#P70004970270000000000000000433A3" class="pcalibre1 calibre8 pcalibre">acc</code>, stored in register <code id="P70004970270000000000000000433A4" data-uri="chapter05.xhtml#P70004970270000000000000000433A4" class="pcalibre1 calibre8 pcalibre">%xmm0</code>. The loop computes a new value for <code id="P70004970270000000000000000433A5" data-uri="chapter05.xhtml#P70004970270000000000000000433A5" class="pcalibre1 calibre8 pcalibre">acc</code> by multiplying the old value by a data element, generated by the load operation. Along the other side, we see the dependencies between successive values of the pointer to the <var class="calibre5 pcalibre pcalibre1">i</var>th data element. On each iteration, the old value is used as the address for the load operation, and it is also incremented by the add operation to compute its new value.</p>
<p id="P70004970270000000000000000433A6" data-uri="chapter05.xhtml#P70004970270000000000000000433A6" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C57"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.15</span></a> shows the data-flow representation of <var class="calibre5 pcalibre pcalibre1">n</var> iterations by the inner loop of function <code id="P70004970270000000000000000433A7" data-uri="chapter05.xhtml#P70004970270000000000000000433A7" class="pcalibre1 calibre8 pcalibre">combine4</code>. This graph was obtained by simply replicating the template shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C33"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.14(b)</span></a><var class="calibre5 pcalibre pcalibre1">n</var>times.Wecan see that the program has two chains of data</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000004C57" data-uri="chapter05.xhtml#P7000497027000000000000000004C57">
<img alt="A diagram shows a critical path extending through mul operations from data[0] to data[1] to data[n minus 2] to data[n minus 1]." id="P70004970270000000000000000433A8" data-uri="P700049702700000000000000000B714" src="../images/p528-1.png" class="calibre174 pcalibre pcalibre1"/>
<figcaption id="P70004970270000000000000000433A9" data-uri="chapter05.xhtml#P70004970270000000000000000433A9" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000433AA" data-uri="chapter05.xhtml#P70004970270000000000000000433AA" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">5.15 </span>Data-flow representation of computation by <var class="calibre5 pcalibre pcalibre1">n</var> iterations of the inner loop of <code id="P70004970270000000000000000433AB" data-uri="chapter05.xhtml#P70004970270000000000000000433AB" class="pcalibre1 calibre8 pcalibre">combine4</code>.</h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000433AC" data-uri="chapter05.xhtml#P70004970270000000000000000433AC"><p id="P70004970270000000000000000433AD" data-uri="chapter05.xhtml#P70004970270000000000000000433AD" class="pcalibre calibre3 pcalibre1">The sequence of multiplication operations forms a critical path that limits program performance.</p></div></figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000433AE" data-uri="chapter05.xhtml#P70004970270000000000000000433AE"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004C5F" title="529" data-uri="chapter05.xhtml#P7000497027000000000000000004C5F" epub:type="pagebreak"></span>dependencies, corresponding to the updating of program values <code id="P70004970270000000000000000433AF" data-uri="chapter05.xhtml#P70004970270000000000000000433AF" class="pcalibre1 calibre8 pcalibre">acc</code> and <code id="P70004970270000000000000000433B0" data-uri="chapter05.xhtml#P70004970270000000000000000433B0" class="pcalibre1 calibre8 pcalibre">data+i</code> with operations mul and add, respectively. Given that floating-point multiplication has a latency of 5 cycles, while integer addition has a latency of 1 cycle, we can see that the chain on the left will form a <i class="calibre5 pcalibre pcalibre1">critical path</i>, requiring 5<var class="calibre5 pcalibre pcalibre1">n</var> cycles to execute. The chain on the right would require only <var class="calibre5 pcalibre pcalibre1">n</var> cycles to execute, and so it does not limit the program performance.</p>
<p id="P70004970270000000000000000433B1" data-uri="chapter05.xhtml#P70004970270000000000000000433B1" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C57"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.15</span></a> demonstrates why we achieved a CPE equal to the latency bound of 5 cycles for <code id="P70004970270000000000000000433B2" data-uri="chapter05.xhtml#P70004970270000000000000000433B2" class="pcalibre1 calibre8 pcalibre">combine4</code>, when performing floating-point multiplication. When executing the function, the floating-point multiplier becomes the limiting resource. The other operations required during the loop—manipulating and testing pointer value <code id="P70004970270000000000000000433B3" data-uri="chapter05.xhtml#P70004970270000000000000000433B3" class="pcalibre1 calibre8 pcalibre">data+i</code> and reading data from memory—proceed in parallel with the multiplication. As each successive value of <code id="P70004970270000000000000000433B4" data-uri="chapter05.xhtml#P70004970270000000000000000433B4" class="pcalibre1 calibre8 pcalibre">acc</code> is computed, it is fed back around to compute the next value, but this will not occur until 5 cycles later.</p>
<p id="P70004970270000000000000000433B5" data-uri="chapter05.xhtml#P70004970270000000000000000433B5" class="pcalibre1 pcalibre calibre2">The flow for other combinations of data type and operation are identical to those shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C57"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.15</span></a>, but with a different data operation forming the chain of data dependencies shown on the left. For all of the cases where the operation has a latency <var class="calibre5 pcalibre pcalibre1">L</var> greater than 1, we see that the measured CPE is simply <var class="calibre5 pcalibre pcalibre1">L</var>, indicating that this chain forms the performance-limiting critical path.</p>
</section>
<section id="P7000497027000000000000000004C67" data-uri="chapter05.xhtml#P7000497027000000000000000004C67" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000433B6" data-uri="chapter05.xhtml#P70004970270000000000000000433B6" epub:type="title">Other Performance Factors</h1></header>
<p id="P70004970270000000000000000433B7" data-uri="chapter05.xhtml#P70004970270000000000000000433B7" class="pcalibre1 pcalibre calibre2">For the case of integer addition, on the other hand, our measurements of <code id="P70004970270000000000000000433B8" data-uri="chapter05.xhtml#P70004970270000000000000000433B8" class="pcalibre1 calibre8 pcalibre">combine4</code> show a CPE of 1.27, slower than the CPE of 1.00 we would predict based on the chains of dependencies formed along either the left- or the right-hand side of the graph of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C57"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.15</span></a>. This illustrates the principle that the critical paths in a data-flow representation provide only a <i class="calibre5 pcalibre pcalibre1">lower</i> bound on how many cycles a program will require. Other factors can also limit performance, including the total number of functional units available and the number of data values that can be passed among the functional units on any given step. For the case of integer addition as the combining operation, the data operation is sufficiently fast that the rest of the operations cannot supply data fast enough. Determining exactly why the program requires 1.27 cycles per element would require a much more detailed knowledge of the hardware design than is publicly available.</p>
<p id="P70004970270000000000000000433B9" data-uri="chapter05.xhtml#P70004970270000000000000000433B9" class="pcalibre1 pcalibre calibre2">To summarize our performance analysis of <code id="P70004970270000000000000000433BA" data-uri="chapter05.xhtml#P70004970270000000000000000433BA" class="pcalibre1 calibre8 pcalibre">combine4</code>: our abstract data-flow representation of program operation showed that <code id="P70004970270000000000000000433BB" data-uri="chapter05.xhtml#P70004970270000000000000000433BB" class="pcalibre1 calibre8 pcalibre">combine4</code> has a critical path of length <i class="calibre5 pcalibre pcalibre1">L · n</i> caused by the successive updating of program value <code id="P70004970270000000000000000433BC" data-uri="chapter05.xhtml#P70004970270000000000000000433BC" class="pcalibre1 calibre8 pcalibre">acc</code>, and this path limits the CPE to at least <var class="calibre5 pcalibre pcalibre1">L</var>. This is indeed the CPE we measure for all cases except integer addition, which has a measured CPE of 1.27 rather than the CPE of 1.00 we would expect from the critical path length.</p>
<p id="P70004970270000000000000000433BD" data-uri="chapter05.xhtml#P70004970270000000000000000433BD" class="pcalibre1 pcalibre calibre2">It may seem that the latency bound forms a fundamental limit on how fast our combining operations can be performed. Our next task will be to restructure the operations to enhance instruction-level parallelism. We want to transform the program in such a way that our only limitation becomes the throughput bound, yielding CPEs below or close to 1.00.</p>

<section id="P7000497027000000000000000004C70" data-uri="chapter05.xhtml#P7000497027000000000000000004C70" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P70004970270000000000000000433BE" data-uri="chapter05.xhtml#P70004970270000000000000000433BE" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004C72" title="530" data-uri="chapter05.xhtml#P7000497027000000000000000004C72" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.5 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005127">575</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000433BF" data-uri="chapter05.xhtml#P70004970270000000000000000433BF">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000433C0" data-uri="chapter05.xhtml#P70004970270000000000000000433C0">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000433C1" data-uri="chapter05.xhtml#P70004970270000000000000000433C1"><p id="P70004970270000000000000000433C2" data-uri="chapter05.xhtml#P70004970270000000000000000433C2" class="pcalibre calibre3 pcalibre1">Supposewewishtowriteafunctiontoevaluateapolynomial, where a polynomial of degree <var class="calibre5 pcalibre pcalibre1">n</var> is defined to have a set of coefficients <var class="calibre5 pcalibre pcalibre1">a</var><sub class="pcalibre1 calibre47 pcalibre">0</sub>, <var class="calibre5 pcalibre pcalibre1">a</var><sub class="pcalibre1 calibre47 pcalibre">1</sub>, <var class="calibre5 pcalibre pcalibre1">a</var><sub class="pcalibre1 calibre47 pcalibre">2</sub>, . . ., <i class="calibre5 pcalibre pcalibre1">a<sub class="pcalibre1 calibre47 pcalibre">n</sub></i>. For a value <var class="calibre5 pcalibre pcalibre1">x</var>, we evaluate the polynomial by computing</p>
<div class="informalequation pcalibre pcalibre1" id="P70004970270000000000000000433C3" data-uri="chapter05.xhtml#P70004970270000000000000000433C3">
<m:math display="block" alttext="" data-uri="" altimg-width="183" altimg-height="17" altimg="../images/ch05-5.png"><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mi>x</m:mi><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mn>2</m:mn></m:msub><m:msup><m:mi>x</m:mi><m:mn>2</m:mn></m:msup><m:mo>+</m:mo><m:mo>…</m:mo><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mi>n</m:mi></m:msub><m:msup><m:mi>x</m:mi><m:mi>n</m:mi></m:msup></m:mrow></m:math>
<span class="number3 pcalibre pcalibre1">(5.2)</span>
</div>
<p id="P70004970270000000000000000433C4" data-uri="chapter05.xhtml#P70004970270000000000000000433C4" class="pcalibre calibre3 pcalibre1">This evaluation can be implemented by the following function, having as arguments an array of coefficients a, a value <code id="P70004970270000000000000000433C5" data-uri="chapter05.xhtml#P70004970270000000000000000433C5" class="pcalibre1 calibre8 pcalibre">x</code>, and the polynomial degree <code id="P70004970270000000000000000433C6" data-uri="chapter05.xhtml#P70004970270000000000000000433C6" class="pcalibre1 calibre8 pcalibre">degree</code> (the value <var class="calibre5 pcalibre pcalibre1">n</var> in Equation 5.2). In this function, we compute both the successive terms of the equation and the successive powers of <var class="calibre5 pcalibre pcalibre1">x</var> within a single loop:</p>
<pre id="P70004970270000000000000000433C7" data-uri="chapter05.xhtml#P70004970270000000000000000433C7" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000433C8" data-uri="chapter05.xhtml#P70004970270000000000000000433C8" class="calibre10 pcalibre pcalibre1">
1	double poly(double a[], double x, long degree)
2	{
3		long i;
4		double result = a[0];
5		double xpwr = x; /* Equals x⁁i at start of loop */
6		for (i = 1; i &lt;= degree; i++) {
7			result += a[i] * xpwr;
8			xpwr = x * xpwr;
9		}
10		return result;
11	}
</code></pre>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P70004970270000000000000000433C9" data-uri="chapter05.xhtml#P70004970270000000000000000433C9">
<li id="P70004970270000000000000000433CA" data-uri="chapter05.xhtml#P70004970270000000000000000433CA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000433CB" data-uri="chapter05.xhtml#P70004970270000000000000000433CB" class="pcalibre calibre3 pcalibre1">For degree <var class="calibre5 pcalibre pcalibre1">n</var>, how many additions and how many multiplications does this code perform?</p></li>
<li id="P70004970270000000000000000433CC" data-uri="chapter05.xhtml#P70004970270000000000000000433CC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000433CD" data-uri="chapter05.xhtml#P70004970270000000000000000433CD" class="pcalibre calibre3 pcalibre1">On our reference machine, with arithmetic operations having the latencies shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004BAA"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.12</span></a>, we measure the CPE for this function to be 5.00. Explain how this CPE arises based on the data dependencies formed between iterations due to the operations implementing lines 7-8 of the function.</p></li>
</ol></div></li>
</ol>
</section>
<section id="P7000497027000000000000000004C82" data-uri="chapter05.xhtml#P7000497027000000000000000004C82" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P70004970270000000000000000433CE" data-uri="chapter05.xhtml#P70004970270000000000000000433CE" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.6 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000050E4.xhtml#P7000497027000000000000000005127">575</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000433CF" data-uri="chapter05.xhtml#P70004970270000000000000000433CF">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000433D0" data-uri="chapter05.xhtml#P70004970270000000000000000433D0">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000433D1" data-uri="chapter05.xhtml#P70004970270000000000000000433D1"><p id="P70004970270000000000000000433D2" data-uri="chapter05.xhtml#P70004970270000000000000000433D2" class="pcalibre calibre3 pcalibre1">Let us continue exploring ways to evaluate polynomials, as described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C70"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.5</span></a>. We can reduce the number of multiplications in evaluating a polynomial by applying <i class="calibre5 pcalibre pcalibre1">Horner's method</i>, named after British mathematician William G. Horner (1786-1837). The idea is to repeatedly factor out the powers of <var class="calibre5 pcalibre pcalibre1">x</var> to get the following evaluation:</p>
<div class="informalequation pcalibre pcalibre1" id="P70004970270000000000000000433D3" data-uri="chapter05.xhtml#P70004970270000000000000000433D3">
<m:math display="block" alttext="" data-uri="" altimg-width="280" altimg-height="13" altimg="../images/ch05-6.png"><m:mrow><m:msub><m:mi>a</m:mi><m:mn>0</m:mn></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>1</m:mn></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mn>2</m:mn></m:msub><m:mo>+</m:mo><m:mo>…</m:mo><m:mo>+</m:mo><m:mi>x</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mi>n</m:mi><m:mo>-</m:mo><m:mn>1</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:mi>x</m:mi><m:msub><m:mi>a</m:mi><m:mi>n</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>…</m:mo></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
<span class="number3 pcalibre pcalibre1">(5.3)</span>
</div>
<p id="P70004970270000000000000000433D4" data-uri="chapter05.xhtml#P70004970270000000000000000433D4" class="pcalibre calibre3 pcalibre1">Using Horner's method, we can implement polynomial evaluation using the following code:</p>
<pre id="P70004970270000000000000000433D5" data-uri="chapter05.xhtml#P70004970270000000000000000433D5" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000433D6" data-uri="chapter05.xhtml#P70004970270000000000000000433D6" class="calibre10 pcalibre pcalibre1">
1	/* Apply Horner's method */
2	double polyh(double a[], double x, long degree)
3	{
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000004C8C" title="531" data-uri="chapter05.xhtml#P7000497027000000000000000004C8C" epub:type="pagebreak"></span>4		long i;
5		double result = a[degree];
6		for (i = degree-1; i &gt;= 0; i−)
7			result = a[i] + x*result;
8		return result;
9	}
</code></pre>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P70004970270000000000000000433D7" data-uri="chapter05.xhtml#P70004970270000000000000000433D7">
<li id="P70004970270000000000000000433D8" data-uri="chapter05.xhtml#P70004970270000000000000000433D8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000433D9" data-uri="chapter05.xhtml#P70004970270000000000000000433D9" class="pcalibre calibre3 pcalibre1">For degree <var class="calibre5 pcalibre pcalibre1">n</var>, how many additions and how many multiplications does this code perform?</p></li>
<li id="P70004970270000000000000000433DA" data-uri="chapter05.xhtml#P70004970270000000000000000433DA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000433DB" data-uri="chapter05.xhtml#P70004970270000000000000000433DB" class="pcalibre calibre3 pcalibre1">On our reference machine, with the arithmetic operations having the latencies shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004BAA"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.12</span></a>, we measure the CPE for this function to be 8.00. Explain how this CPE arises based on the data dependencies formed between iterations due to the operations implementing line 7 of the function.</p></li>
<li id="P70004970270000000000000000433DC" data-uri="chapter05.xhtml#P70004970270000000000000000433DC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000433DD" data-uri="chapter05.xhtml#P70004970270000000000000000433DD" class="pcalibre calibre3 pcalibre1">Explain how the function shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000004C70"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">5.5</span></a> can run faster, even though it requires more operations.</p></li>
</ol></div></li>
</ol>
</section>
</section>
</section>
</section></body></html>
