<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 6. Processes</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch05.html" title="Chapter 5. File I/O: Further Details"/><link rel="next" href="ch07.html" title="Chapter 7. Memory Allocation"/></head><body><section class="chapter" title="Chapter 6. Processes" epub:type="chapter" id="processes-id1"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Processes</h2></div></div></div><p>In this chapter, we look at the structure of a process, paying particular attention to
            the layout and contents of a process’s virtual memory. We also examine some of the
            attributes of a process. In later chapters, we examine further process attributes (for
            example, process credentials in <a class="xref" href="ch09.html" title="Chapter 9. Process Credentials">Chapter 9</a>, and process
            priorities and scheduling in <a class="xref" href="ch35.html" title="Chapter 35. Process Priorities and Scheduling">Chapter 35</a>). In
                <a class="xref" href="ch24.html" title="Chapter 24. Process Creation">Chapter 24</a> to <a class="xref" href="ch27.html" title="Chapter 27. Program Execution">Chapter 27</a>, we look
            at how processes are created, how they terminate, and how they can be made to execute
            new programs.<a id="IDX-CHP-6-0855" class="indexterm"/></p><div class="sect1" title="Processes and Programs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="processes_and_programs">Processes and Programs</h2></div></div></div><p>A <span class="emphasis"><em>process</em></span> is an instance of an executing program. In this
                section, we elaborate on this definition and clarify the distinction between a
                program and a process.<a id="IDX-CHP-6-0856" class="indexterm"/><a id="IDX-CHP-6-0857" class="indexterm"/><a id="IDX-CHP-6-0858" class="indexterm"/><a id="IDX-CHP-6-0859" class="indexterm"/><a id="IDX-CHP-6-0860" class="indexterm"/></p><p>A <span class="emphasis"><em>program</em></span> is a file containing a range of information that
                describes how to construct a process at run time. This information includes the
                following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Binary format identification</em></span>: Each program file
                        includes metainformation describing the format of the executable file. This
                        enables the kernel to interpret the remaining information in the file.
                        Historically, two widely used formats for UNIX executable files were the
                        original <span class="emphasis"><em>a.out</em></span> (“assembler output”) format and the
                        later, more sophisticated <span class="emphasis"><em>COFF</em></span> (Common Object File
                        Format). Nowadays, most UNIX implementations (including Linux) employ the
                        Executable and Linking Format (ELF), which provides a number of advantages
                        over the older formats.<a id="IDX-CHP-6-0861" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Machine-language instructions</em></span>: These encode the
                        algorithm of the program.</p></li><li class="listitem"><p><span class="emphasis"><em>Program entry-point address</em></span>: This identifies the
                        location of the instruction at which execution of the program should
                        commence.</p></li><li class="listitem"><p><span class="emphasis"><em>Data</em></span>: The program file contains values used to
                        initialize variables and also literal constants used by the program (e.g.,
                        strings).</p></li><li class="listitem"><p><span class="emphasis"><em>Symbol and relocation tables:</em></span> These describe the
                        locations and names of functions and variables within the program. These
                        tables are used for a variety of purposes, including debugging and run-time
                        symbol resolution (dynamic linking).</p></li><li class="listitem"><p><span class="emphasis"><em>Shared-library and dynamic-linking information</em></span>: The
                        program file includes fields listing the shared libraries that the program
                        needs to use at run time and the pathname of the dynamic linker that should
                        be used to load these libraries.</p></li><li class="listitem"><p><span class="emphasis"><em>Other information</em></span>: The program file contains various
                        other information that describes how to construct a process.</p></li></ul></div><p>One program may be used to construct many processes, or, put conversely, many
                processes may be running the same program.</p><p>We can recast the definition of a process given at the start of this section as
                follows: a process is an abstract entity, defined by the kernel, to which system
                resources are allocated in order to execute a program.</p><p>From the kernel’s point of view, a process consists of user-space memory
                containing program code and variables used by that code, and a range of kernel data
                structures that maintain information about the state of the process. The information
                recorded in the kernel data structures includes various identifier numbers (IDs)
                associated with the process, virtual memory tables, the table of open file
                descriptors, information relating to signal delivery and handling, process resource
                usages and limits, the current working directory, and a host of other
                information.</p></div><div class="sect1" title="Process ID and Parent Process ID"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="process_id_and_parent_process">Process ID and Parent Process ID</h2></div></div></div><p>Each process has a process ID (PID), a positive integer that uniquely identifies
                the process on the system. Process IDs are used and returned by a variety of system
                calls. For example, the <span class="emphasis"><em>kill()</em></span> system call (<a class="xref" href="ch20.html#sending_signals_colon_kill_open_parenthe" title="Sending Signals: kill()">Sending Signals: <span class="emphasis"><em>kill()</em></span></a>) allows the caller to send
                a signal to a process with a specific process ID. The process ID is also useful if
                we need to build an identifier that is unique to a process. A common example of this
                is the use of the process ID as part of a process-unique filename.<a id="IDX-CHP-6-0863" class="indexterm"/><a id="IDX-CHP-6-0864" class="indexterm"/><a id="IDX-CHP-6-0865" class="indexterm"/><a id="IDX-CHP-6-0866" class="indexterm"/><a id="IDX-CHP-6-0862" class="indexterm"/><a id="IDX-CHP-6-0867" class="indexterm"/></p><p>The <span class="emphasis"><em>getpid()</em></span> system call returns the process ID of the
                calling process.<a id="IDX-CHP-6-0868" class="indexterm"/></p><a id="I_programlisting6_d1e13737"/><pre class="programlisting">#include &lt;unistd.h&gt;

pid_t <strong class="userinput"><code>getpid</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Always successfully returns process ID of caller</p></div><p>The <span class="emphasis"><em>pid_t</em></span> data type used for the return value of
                    <span class="emphasis"><em>getpid()</em></span> is an integer type specified by SUSv3 for the
                purpose of storing process IDs.<a id="IDX-CHP-6-0869" class="indexterm"/></p><p>With the exception of a few system processes such as <span class="emphasis"><em>init</em></span>
                (process ID 1), there is no fixed relationship between a program and the process ID
                of the process that is created to run that program.</p><p>The Linux kernel limits process IDs to being less than or equal to 32,767. When a
                new process is created, it is assigned the next sequentially available process ID.
                Each time the limit of 32,767 is reached, the kernel resets its process ID counter
                so that process IDs are assigned starting from low integer values.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Once it has reached 32,767, the process ID counter is reset to 300, rather
                    than 1. This is done because many low-numbered process IDs are in permanent use
                    by system processes and daemons, and thus time would be wasted searching for an
                    unused process ID in this range.</p><p>In Linux 2.4 and earlier, the process ID limit of 32,767 is defined by the
                    kernel constant <code class="literal">PID_MAX</code>. With Linux 2.6,
                    things change. While the default upper limit for process IDs remains 32,767,
                    this limit is adjustable via the value in the Linux-specific <code class="literal">/proc/sys/kernel/pid_max</code> file (which is one
                    greater than the maximum process ID). On 32-bit platforms, the maximum value for
                    this file is 32,768, but on 64-bit platforms, it can be adjusted to any value up
                    to 222 (approximately 4 million), making it possible to accommodate very large
                    numbers of processes.<a id="IDX-CHP-6-0870" class="indexterm"/></p></div><p>Each process has a parent—the process that created it. A process can find out the
                process ID of its parent using the <span class="emphasis"><em>getppid()</em></span> system
                    call.<a id="IDX-CHP-6-0871" class="indexterm"/></p><a id="I_programlisting6_d1e13790"/><pre class="programlisting">#include &lt;unistd.h&gt;

pid_t <strong class="userinput"><code>getppid</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Always successfully returns process ID of parent of caller</p></div><p>In effect, the parent process ID attribute of each process represents the
                tree-like relationship of all processes on the system. The parent of each process
                has its own parent, and so on, going all the way back to process 1,
                    <span class="emphasis"><em>init</em></span>, the ancestor of all processes. (This “family tree”
                can be viewed using the <span class="emphasis"><em>pstree(1)</em></span> command.)</p><p>If a child process becomes orphaned because its “birth” parent terminates, then
                the child is adopted by the <span class="emphasis"><em>init</em></span> process, and subsequent calls
                to <span class="emphasis"><em>getppid()</em></span> in the child return 1 (see <a class="xref" href="ch26.html#orphans_and_zombies" title="Orphans and Zombies">Orphans and Zombies</a>).<a id="IDX-CHP-6-0872" class="indexterm"/></p><p>The parent of any process can be found by looking at the <code class="literal">PPid</code> field provided in the Linux-specific <code class="literal">/proc/</code><em class="replaceable"><code>PID</code></em><code class="literal">/status</code> file.</p></div><div class="sect1" title="Memory Layout of a Process"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="memory_layout_of_a_process">Memory Layout of a Process</h2></div></div></div><p>The memory allocated to each process is composed of a number of parts, usually
                referred to as <span class="emphasis"><em>segments</em></span>. These segments are as
                    follows:<a id="IDX-CHP-6-0873" class="indexterm"/><a id="IDX-CHP-6-0874" class="indexterm"/><a id="IDX-CHP-6-0875" class="indexterm"/><a id="IDX-CHP-6-0876" class="indexterm"/><a id="IDX-CHP-6-0877" class="indexterm"/><a id="IDX-CHP-6-0878" class="indexterm"/><a id="IDX-CHP-6-0879" class="indexterm"/><a id="IDX-CHP-6-0880" class="indexterm"/><a id="IDX-CHP-6-0881" class="indexterm"/><a id="IDX-CHP-6-0882" class="indexterm"/><a id="IDX-CHP-6-0883" class="indexterm"/><a id="IDX-CHP-6-0884" class="indexterm"/><a id="IDX-CHP-6-0885" class="indexterm"/><a id="IDX-CHP-6-0886" class="indexterm"/><a id="IDX-CHP-6-0887" class="indexterm"/><a id="IDX-CHP-6-0888" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>text segment</em></span> contains the machine-language
                        instructions of the program run by the process. The text segment is made
                        read-only so that a process doesn’t accidentally modify its own instructions
                        via a bad pointer value. Since many processes may be running the same
                        program, the text segment is made sharable so that a single copy of the
                        program code can be mapped into the virtual address space of all of the
                            processes.<a id="IDX-CHP-6-0889" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>initialized data segment</em></span> contains global and
                        static variables that are explicitly initialized. The values of these
                        variables are read from the executable file when the program is loaded into
                            memory.<a id="IDX-CHP-6-0890" class="indexterm"/><a id="IDX-CHP-6-0891" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>uninitialized data segment</em></span> contains global and
                        static variables that are not explicitly initialized. Before starting the
                        program, the system initializes all memory in this segment to 0. For
                        historical reasons, this is often called the <span class="emphasis"><em>bss</em></span>
                        segment, a name derived from an old assembler mnemonic for “block started by
                        symbol.” The main reason for placing global and static variables that are
                        initialized into a separate segment from those that are uninitialized is
                        that, when a program is stored on disk, it is not necessary to allocate
                        space for the uninitialized data. Instead, the executable merely needs to
                        record the location and size required for the uninitialized data segment,
                        and this space is allocated by the program loader at run time.<a id="IDX-CHP-6-0892" class="indexterm"/><a id="IDX-CHP-6-0893" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>stack</em></span> is a dynamically growing and shrinking
                        segment containing stack frames. One stack frame is allocated for each
                        currently called function. A frame stores the function’s local variables
                        (so-called automatic variables), arguments, and return value. Stack frames
                        are discussed in more detail in Section 6.5.<a id="IDX-CHP-6-0894" class="indexterm"/><a id="IDX-CHP-6-0895" class="indexterm"/><a id="IDX-CHP-6-0896" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>heap</em></span> is an area from which memory (for variables)
                        can be dynamically allocated at run time. The top end of the heap is called
                        the <span class="emphasis"><em>program break</em></span>.<a id="IDX-CHP-6-0897" class="indexterm"/><a id="IDX-CHP-6-0898" class="indexterm"/></p></li></ul></div><p>Less commonly used, but more descriptive labels for the initialized and
                uninitialized data segments are <span class="emphasis"><em>user-initialized data segment</em></span>
                and <span class="emphasis"><em>zero-initialized data segment</em></span>.</p><p>The <span class="emphasis"><em>size(1)</em></span> command displays the size of the text,
                initialized data, and uninitialized data (<span class="emphasis"><em>bss</em></span>) segments of a
                binary executable.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The term <span class="emphasis"><em>segment</em></span> as used in the main text should not be
                    confused with the hardware segmentation used on some hardware architectures such
                    as x86-32. Rather, segments are logical divisions of a process’s virtual memory
                    on UNIX systems. Sometimes, the term <span class="emphasis"><em>section</em></span> is used
                    instead of <span class="emphasis"><em>segment</em></span>, since <span class="emphasis"><em>section</em></span> is
                    more consistent with the terminology used in the now ubiquitous ELF
                    specification for executable file formats.</p><p>In many places in this book, we note that a library function returns a pointer
                    to statically allocated memory. By this, we mean that the memory is allocated in
                    either the initialized or the uninitialized data segment. (In some cases, the
                    library function may instead do a one-time dynamic allocation of the memory on
                    the heap; however, this implementation detail is irrelevant to the semantic
                    point we describe here.) It is important to be aware of cases where a library
                    function returns information via statically allocated memory, since that memory
                    has an existence that is independent of the function invocation, and the memory
                    may be overwritten by subsequent calls to the same function (or in some cases,
                    by subsequent calls to related functions). The effect of using statically
                    allocated memory is to render a function nonreentrant. We say more about
                    reentrancy in <a class="xref" href="ch21.html#reentrant_and_async-signal-safe_function" title="Reentrant and Async-Signal-Safe Functions">Reentrant and Async-Signal-Safe Functions</a> and
                        <a class="xref" href="ch31.html#thread_safety_open_parenthesis_and_reent" title="Thread Safety (and Reentrancy Revisited)">Thread Safety (and Reentrancy Revisited)</a>.</p></div><p><a class="xref" href="ch06.html#locations_of_program_variables_in_proces" title="Example 6-1. Locations of program variables in process memory segments">Example 6-1</a> shows various types of
                C variables along with comments indicating in which segment each variable is
                located. These comments assume a nonoptimizing compiler and an application binary
                interface in which all arguments are passed on the stack. In practice, an optimizing
                compiler may allocate frequently used variables in registers, or optimize a variable
                out of existence altogether. Furthermore, some ABIs require function arguments and
                the function result to be passed via registers, rather than on the stack.
                Nevertheless, this example serves to demonstrate the mapping between C variables and
                the segments of a process.</p><div class="example"><a id="locations_of_program_variables_in_proces"/><div class="example-title">Example 6-1. Locations of program variables in process memory segments</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>proc/mem_segments.c</code></strong>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char globBuf[65536];            /* Uninitialized data segment */
int primes[] = { 2, 3, 5, 7 };  /* Initialized data segment */

static int
square(int x)                   /* Allocated in frame for square() */
{
    int result;                 /* Allocated in frame for square() */

    result = x * x;
    return result;              /* Return value passed via register */
}

static void
doCalc(int val)                 /* Allocated in frame for doCalc() */
{
    printf("The square of %d is %d\n", val, square(val));

    if (val &lt; 1000) {
        int t;                  /* Allocated in frame for doCalc() */

        t = val * val * val;
        printf("The cube of %d is %d\n", val, t);
    }
}

int
main(int argc, char *argv[])    /* Allocated in frame for main() */
{
    static int key = 9973;      /* Initialized data segment */
    static char mbuf[10240000]; /* Uninitialized data segment */
    char *p;                    /* Allocated in frame for main() */

    p = malloc(1024);           /* Points to memory in heap segment */

    doCalc(key);

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>proc/mem_segments.c</code></strong></pre></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>An <span class="emphasis"><em>application binary interface</em></span> (ABI) is a set of rules
                    specifying how a binary executable should exchange information with some service
                    (e.g., the kernel or a library) at run time. Among other things, an ABI
                    specifies which registers and stack locations are used to exchange this
                    information, and what meaning is attached to the exchanged values. Once compiled
                    for a particular ABI, a binary executable should be able to run on any system
                    presenting the same ABI. This contrasts with a standardized API (such as SUSv3),
                    which guarantees portability only for applications compiled from source
                        code.<a id="IDX-CHP-6-0899" class="indexterm"/><a id="IDX-CHP-6-0900" class="indexterm"/></p></div><p>Although not specified in SUSv3, the C program environment on most UNIX
                implementations (including Linux) provides three global symbols:
                    <span class="emphasis"><em>etext</em></span>, <span class="emphasis"><em>edata</em></span>, and
                    <span class="emphasis"><em>end</em></span>. These symbols can be used from within a program to
                obtain the addresses of the next byte past, respectively, the end of the program
                text, the end of the initialized data segment, and the end of the uninitialized data
                segment. To make use of these symbols, we must explicitly declare them, as
                    follows:<a id="IDX-CHP-6-0901" class="indexterm"/><a id="IDX-CHP-6-0902" class="indexterm"/></p><a id="I_programlisting6_d1e14057"/><pre class="programlisting">extern char etext, edata, end;
        /* For example, &amp;etext gives the address of the end
           of the program text / start of initialized data */</pre><p><a class="xref" href="ch06.html#typical_memory_layout_of_a_process_on_li" title="Figure 6-1. Typical memory layout of a process on Linux/x86-32">Figure 6-1</a> shows the arrangement
                of the various memory segments on the x86-32 architecture. The space labeled
                    <span class="emphasis"><em>argv, environ</em></span> at the top of this diagram holds the program
                command-line arguments (available in C via the <span class="emphasis"><em>argv</em></span> argument of
                the <span class="emphasis"><em>main()</em></span> function) and the process environment list (which we
                discuss shortly). The hexadecimal addresses shown in the diagram may vary, depending
                on kernel configuration and program linking options. The grayed-out areas represent
                invalid ranges in the process’s virtual address space; that is, areas for which page
                tables have not been created (see the following discussion of virtual memory
                    management).<a id="IDX-CHP-6-0903" class="indexterm"/></p><p>We revisit the topic of process memory layout in a little more detail in <a class="xref" href="ch48.html#location_of_shared_memory_in_virtual_mem" title="Location of Shared Memory in Virtual Memory">Location of Shared Memory in Virtual Memory</a>, where we consider where
                shared memory and shared libraries are placed in a process’s virtual memory.</p></div><div class="sect1" title="Virtual Memory Management"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="virtual_memory_management">Virtual Memory Management</h2></div></div></div><p>The previous discussion of the memory layout of a process glossed over the fact
                that we were talking about the layout in <span class="emphasis"><em>virtual memory</em></span>. Since
                an understanding of virtual memory is useful later on when we look at topics such as
                the <span class="emphasis"><em>fork()</em></span> system call, shared memory, and mapped files, we now
                consider some of the details.<a id="IDX-CHP-6-0904" class="indexterm"/><a id="IDX-CHP-6-0905" class="indexterm"/><a id="IDX-CHP-6-0906" class="indexterm"/><a id="IDX-CHP-6-0907" class="indexterm"/><a id="IDX-CHP-6-0908" class="indexterm"/><a id="IDX-CHP-6-0909" class="indexterm"/><a id="IDX-CHP-6-0910" class="indexterm"/><a id="IDX-CHP-6-0911" class="indexterm"/><a id="IDX-CHP-6-0912" class="indexterm"/><a id="IDX-CHP-6-0913" class="indexterm"/><a id="IDX-CHP-6-0914" class="indexterm"/><a id="IDX-CHP-6-0915" class="indexterm"/><a id="IDX-CHP-6-0916" class="indexterm"/><a id="IDX-CHP-6-0917" class="indexterm"/><a id="IDX-CHP-6-0918" class="indexterm"/><a id="IDX-CHP-6-0919" class="indexterm"/><a id="IDX-CHP-6-0920" class="indexterm"/><a id="IDX-CHP-6-0921" class="indexterm"/><a id="IDX-CHP-6-0922" class="indexterm"/></p><p>Like most modern kernels, Linux employs a technique known as <span class="emphasis"><em>virtual
                    memory management</em></span>. The aim of this technique is to make efficient use
                of both the CPU and RAM (physical memory) by exploiting a property that is typical
                of most programs: <span class="emphasis"><em>locality of reference</em></span>. Most programs
                demonstrate two kinds of locality:<a id="IDX-CHP-6-0923" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Spatial locality</em></span> is the tendency of a program to
                        reference memory addresses that are near those that were recently accessed
                        (because of sequential processing of instructions, and, sometimes,
                        sequential processing of data structures).</p></li><li class="listitem"><p><span class="emphasis"><em>Temporal locality</em></span> is the tendency of a program to
                        access the same memory addresses in the near future that it accessed in the
                        recent past (because of loops).</p></li></ul></div><div class="figure"><a id="typical_memory_layout_of_a_process_on_li"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e14223"/><img src="figs/web/06-1_PROCESS-memory-layout.png.jpg" alt="Typical memory layout of a process on Linux/x86-32"/></div></div><div class="figure-title">Figure 6-1. Typical memory layout of a process on Linux/x86-32</div></div><p>The upshot of locality of reference is that it is possible to execute a program
                while maintaining only part of its address space in RAM.</p><p>A virtual memory scheme splits the memory used by each program into small,
                fixed-size units called <span class="emphasis"><em>pages</em></span>. Correspondingly, RAM is divided
                into a series of <span class="emphasis"><em>page frames</em></span> of the same size. At any one time,
                only some of the pages of a program need to be resident in physical memory page
                frames; these pages form the so-called <span class="emphasis"><em>resident set</em></span>. Copies of
                the unused pages of a program are maintained in the <span class="emphasis"><em>swap area</em></span>—a
                reserved area of disk space used to supplement the computer’s RAM—and loaded into
                physical memory only as required. When a process references a page that is not
                currently resident in physical memory, a <span class="emphasis"><em>page fault</em></span> occurs, at
                which point the kernel suspends execution of the process while the page is loaded
                from disk into memory.<a id="IDX-CHP-6-0924" class="indexterm"/><a id="IDX-CHP-6-0925" class="indexterm"/><a id="IDX-CHP-6-0926" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>On x86-32, pages are 4096 bytes in size. Some other Linux implementations use
                    larger page sizes. For example, Alpha uses a page size of 8192 bytes, and IA-64
                    has a variable page size, with the usual default being 16,384 bytes. A program
                    can determine the system virtual memory page size using the call
                        <span class="emphasis"><em>sysconf(_SC_PAGESIZE)</em></span>, as described in Section
                    11.2.</p></div><div class="figure"><a id="overview_of_virtual_memory"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e14266"/><img src="figs/web/06-2_PROCESS-virtual-memory.png.jpg" alt="Overview of virtual memory"/></div></div><div class="figure-title">Figure 6-2. Overview of virtual memory</div></div><p>In order to support this organization, the kernel maintains a <span class="emphasis"><em>page
                    table</em></span> for each process (<a class="xref" href="ch06.html#overview_of_virtual_memory" title="Figure 6-2. Overview of virtual memory">Figure 6-2</a>). The page table describes the location of each page in the process’s
                    <span class="emphasis"><em>virtual address space</em></span> (the set of all virtual memory pages
                available to the process). Each entry in the page table either indicates the
                location of a virtual page in RAM or indicates that it currently resides on
                    disk.<a id="IDX-CHP-6-0927" class="indexterm"/></p><p>Not all address ranges in the process’s virtual address space require page-table
                entries. Typically, large ranges of the potential virtual address space are unused,
                so that it isn’t necessary to maintain corresponding page-table entries. If a
                process tries to access an address for which there is no corresponding page-table
                entry, it receives a <code class="literal">SIGSEGV</code> signal.<a id="IDX-CHP-6-0928" class="indexterm"/></p><p>A process’s range of valid virtual addresses can change over its lifetime, as the
                kernel allocates and deallocates pages (and page-table entries) for the process.
                This can happen in the following circumstances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>as the stack grows downward beyond limits previously reached;</p></li><li class="listitem"><p>when memory is allocated or deallocated on the heap, by raising the
                        program break using <span class="emphasis"><em>brk()</em></span>, <span class="emphasis"><em>sbrk()</em></span>,
                        or the <span class="emphasis"><em>malloc</em></span> family of functions (<a class="xref" href="ch07.html" title="Chapter 7. Memory Allocation">Chapter 7</a>);</p></li><li class="listitem"><p>when System V shared memory regions are attached using
                            <span class="emphasis"><em>shmat()</em></span> and detached using
                            <span class="emphasis"><em>shmdt()</em></span> (<a class="xref" href="ch48.html" title="Chapter 48. System V Shared Memory">Chapter 48</a>);
                        and</p></li><li class="listitem"><p>when memory mappings are created using <span class="emphasis"><em>mmap()</em></span> and
                        unmapped using <span class="emphasis"><em>munmap()</em></span> (<a class="xref" href="ch49.html" title="Chapter 49. Memory Mappings">Chapter 49</a>).</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>The implementation of virtual memory requires hardware support in the form of
                    a <span class="emphasis"><em>paged memory management unit</em></span> (PMMU). The PMMU translates
                    each virtual memory address reference into the corresponding physical memory
                    address and advises the kernel of a page fault when a particular virtual memory
                    address corresponds to a page that is not resident in RAM.</p></div><p>Virtual memory management separates the virtual address space of a process from
                the physical address space of RAM. This provides many advantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Processes are isolated from one another and from the kernel, so that one
                        process can’t read or modify the memory of another process or the kernel.
                        This is accomplished by having the page-table entries for each process point
                        to distinct sets of physical pages in RAM (or in the swap area).</p></li><li class="listitem"><p>Where appropriate, two or more processes can share memory. The kernel
                        makes this possible by having page-table entries in different processes
                        refer to the same pages of RAM. Memory sharing occurs in two common
                        circumstances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Multiple processes executing the same program can share a single
                                (read-only) copy of the program code. This type of sharing is
                                performed implicitly when multiple programs execute the same program
                                file (or load the same shared library).</p></li><li class="listitem"><p>Processes can use the <span class="emphasis"><em>shmget()</em></span> and
                                    <span class="emphasis"><em>mmap()</em></span> system calls to explicitly request
                                sharing of memory regions with other processes. This is done for the
                                purpose of interprocess communication.</p></li></ul></div></li><li class="listitem"><p>The implementation of memory protection schemes is facilitated; that is,
                        page-table entries can be marked to indicate that the contents of the
                        corresponding page are readable, writable, executable, or some combination
                        of these protections. Where multiple processes share pages of RAM, it is
                        possible to specify that each process has different protections on the
                        memory; for example, one process might have read-only access to a page,
                        while another has read-write access.</p></li><li class="listitem"><p>Programmers, and tools such as the compiler and linker, don’t need to be
                        concerned with the physical layout of the program in RAM.</p></li><li class="listitem"><p>Because only a part of a program needs to reside in memory, the program
                        loads and runs faster. Furthermore, the memory footprint (i.e., virtual
                        size) of a process can exceed the capacity of RAM.<a id="IDX-CHP-6-0929" class="indexterm"/></p></li></ul></div><p>One final advantage of virtual memory management is that since each process uses
                less RAM, more processes can simultaneously be held in RAM. This typically leads to
                better CPU utilization, since it increases the likelihood that, at any moment in
                time, there is at least one process that the CPU can execute.</p></div><div class="sect1" title="The Stack and Stack Frames"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_stack_and_stack_frames">The Stack and Stack Frames</h2></div></div></div><p>The stack grows and shrinks linearly as functions are called and return. For Linux
                on the x86-32 architecture (and on most other Linux and UNIX implementations), the
                stack resides at the high end of memory and grows downward (toward the heap). A
                special-purpose register, the <span class="emphasis"><em>stack pointer</em></span>, tracks the current
                top of the stack. Each time a function is called, an additional frame is allocated
                on the stack, and this frame is removed when the function returns.<a id="IDX-CHP-6-0930" class="indexterm"/><a id="IDX-CHP-6-0931" class="indexterm"/><a id="IDX-CHP-6-0932" class="indexterm"/><a id="IDX-CHP-6-0933" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Even though the stack grows downward, we still call the growing end of the
                    stack the <span class="emphasis"><em>top</em></span>, since, in abstract terms, that is what it
                    is. The actual direction of stack growth is a (hardware) implementation detail.
                    One Linux implementation, the HP PA-RISC, does use an upwardly growing
                    stack.</p><p>In virtual memory terms, the stack segment increases in size as stack frames
                    are allocated, but on most implementations, it won’t decrease in size after
                    these frames are deallocated (the memory is simply reused when new stack frames
                    are allocated). When we talk about the stack segment growing and shrinking, we
                    are considering things from the logical perspective of frames being added to and
                    removed from the stack.</p></div><p>Sometimes, the term <span class="emphasis"><em>user stack</em></span> is used to distinguish the
                stack we describe here from the <span class="emphasis"><em>kernel stack</em></span>. The kernel stack
                is a per-process memory region maintained in kernel memory that is used as the stack
                for execution of the functions called internally during the execution of a system
                call. (The kernel can’t employ the user stack for this purpose since it resides in
                unprotected user memory.)<a id="IDX-CHP-6-0934" class="indexterm"/><a id="IDX-CHP-6-0935" class="indexterm"/></p><p>Each (user) stack frame contains the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Function arguments and local variables</em></span>: In C these
                        are referred to as <span class="emphasis"><em>automatic</em></span> variables, since they are
                        automatically created when a function is called. These variables also
                        automatically disappear when the function returns (since the stack frame
                        disappears), and this forms the primary semantic distinction between
                        automatic and <code class="literal">static</code> (and global)
                        variables: the latter have a permanent existence independent of the
                        execution of functions.</p></li><li class="listitem"><p><span class="emphasis"><em>Call linkage information</em></span>: Each function uses certain
                        CPU registers, such as the program counter, which points to the next
                        machine-language instruction to be executed. Each time one function calls
                        another, a copy of these registers is saved in the called function’s stack
                        frame so that when the function returns, the appropriate register values can
                        be restored for the calling function.</p></li></ul></div><p>Since functions can call one another, there may be multiple frames on the stack.
                (If a function calls itself recursively, there will be multiple frames on the stack
                for that function.) Referring to <a class="xref" href="ch06.html#locations_of_program_variables_in_proces" title="Example 6-1. Locations of program variables in process memory segments">Example 6-1</a>, during the execution of
                the function <span class="emphasis"><em>square()</em></span>, the stack will contain frames as shown
                in <a class="xref" href="ch06.html#example_of_a_process_stack" title="Figure 6-3. Example of a process stack">Figure 6-3</a>.</p><div class="figure"><a id="example_of_a_process_stack"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e14454"/><img src="figs/web/06-3_PROCESS-stack-frames-scale90.png.jpg" alt="Example of a process stack"/></div></div><div class="figure-title">Figure 6-3. Example of a process stack</div></div></div><div class="sect1" title="Command-Line Arguments (argc, argv)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="command-line_arguments_open_parenthesis">Command-Line Arguments (<span class="emphasis"><em>argc, argv</em></span>)</h2></div></div></div><p>Every C program must have a function called <span class="emphasis"><em>main()</em></span>, which is
                the point where execution of the program starts. When the program is executed, the
                command-line arguments (the separate words parsed by the shell) are made available
                via two arguments to the function <span class="emphasis"><em>main()</em></span>. The first argument,
                    <span class="emphasis"><em>int argc</em></span>, indicates how many command-line arguments there
                are. The second argument, <span class="emphasis"><em>char *argv[]</em></span>, is an array of pointers
                to the command-line arguments, each of which is a null-terminated character string.
                The first of these strings, in <span class="emphasis"><em>argv[0]</em></span>, is (conventionally) the
                name of the program itself. The list of pointers in <span class="emphasis"><em>argv</em></span> is
                terminated by a <code class="literal">NULL</code> pointer (i.e.,
                    <span class="emphasis"><em>argv[argc]</em></span> is <code class="literal">NULL</code>).<a id="IDX-CHP-6-0936" class="indexterm"/><a id="IDX-CHP-6-0937" class="indexterm"/><a id="IDX-CHP-6-0938" class="indexterm"/><a id="IDX-CHP-6-0939" class="indexterm"/><a id="IDX-CHP-6-0940" class="indexterm"/><a id="IDX-CHP-6-0941" class="indexterm"/><a id="IDX-CHP-6-0942" class="indexterm"/><a id="IDX-CHP-6-0943" class="indexterm"/></p><p>The fact that <span class="emphasis"><em>argv[0]</em></span> contains the name used to invoke the
                program can be employed to perform a useful trick. We can create multiple links to
                (i.e., names for) the same program, and then have the program look at
                    <span class="emphasis"><em>argv[0]</em></span> and take different actions depending on the name
                used to invoke it. An example of this technique is provided by the
                    <span class="emphasis"><em>gzip(1)</em></span>, <span class="emphasis"><em>gunzip(1)</em></span>, and
                    <span class="emphasis"><em>zcat(1)</em></span> commands, all of which are links to the same
                executable file. (If we employ this technique, we must be careful to handle the
                possibility that the user might invoke the program via a link with a name other than
                any of those that we expect.)</p><p><a class="xref" href="ch06.html#values_of_argc_and_argv_for_the_command" title="Figure 6-4. Values of argc and argv for the command necho hello world">Figure 6-4</a> shows an example of the
                data structures associated with <span class="emphasis"><em>argc</em></span> and
                    <span class="emphasis"><em>argv</em></span> when executing the program in <a class="xref" href="ch06.html#echoing_command-line_arguments" title="Example 6-2. Echoing command-line arguments">Example 6-2</a>. In this diagram, we show the
                terminating null bytes at the end of each string using the C notation <code class="literal">\0</code>.</p><div class="figure"><a id="values_of_argc_and_argv_for_the_command"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e14588"/><img src="figs/web/06-4_PROCESS-cmd-line-args-scale90.png" alt="Values of argc and argv for the command necho hello world"/></div></div><div class="figure-title">Figure 6-4. Values of <span class="emphasis"><em>argc</em></span> and <span class="emphasis"><em>argv</em></span> for the
                    command <span class="emphasis"><em>necho hello world</em></span></div></div><p>The program in <a class="xref" href="ch06.html#echoing_command-line_arguments" title="Example 6-2. Echoing command-line arguments">Example 6-2</a> echoes its
                command-line arguments, one per line of output, preceded by a string showing which
                element of <span class="emphasis"><em>argv</em></span> is being displayed.</p><div class="example"><a id="echoing_command-line_arguments"/><div class="example-title">Example 6-2. Echoing command-line arguments</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>proc/necho.c</code></strong>
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int j;

    for (j = 0; j &lt; argc; j++)
        printf("argv[%d] = %s\n", j, argv[j]);

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>proc/necho.c</code></strong></pre></div></div><p>Since the <span class="emphasis"><em>argv</em></span> list is terminated by a <code class="literal">NULL</code> value, we could alternatively code the body of
                the program in <a class="xref" href="ch06.html#echoing_command-line_arguments" title="Example 6-2. Echoing command-line arguments">Example 6-2</a> as follows, to
                output just the command-line arguments one per line:</p><a id="I_programlisting6_d1e14619"/><pre class="programlisting">char **p;

for (p = argv; *p != NULL; p++)
    puts(*p);</pre><p>One limitation of the <span class="emphasis"><em>argc</em></span>/<span class="emphasis"><em>argv</em></span>
                mechanism is that these variables are available only as arguments to
                    <span class="emphasis"><em>main()</em></span>. To portably make the command-line arguments
                available in other functions, we must either pass <span class="emphasis"><em>argv</em></span> as an
                argument to those functions or set a global variable pointing to
                    <span class="emphasis"><em>argv</em></span>.</p><p>There are a couple of nonportable methods of accessing part or all of this
                information from anywhere in a program:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The command-line arguments of any process can be read via the
                        Linux-specific <code class="literal">/proc/</code><em class="replaceable"><code>PID</code></em><code class="literal">/cmdline</code> file, with each argument being terminated by a null
                        byte. (A program can access its own command-line arguments via <code class="literal">/proc/self/cmdline</code>.)</p></li><li class="listitem"><p>The GNU C library provides two global variables that may be used anywhere
                        in a program in order to obtain the name used to invoke the program (i.e.,
                        the first command-line argument). The first of these,
                            <span class="emphasis"><em>program_invocation_name</em></span>, provides the complete
                        pathname used to invoke the program. The second,
                            <span class="emphasis"><em>program_invocation_short_name</em></span>, provides a version
                        of this name with any directory prefix stripped off (i.e., the basename
                        component of the pathname). Declarations for these two variables can be
                        obtained from <code class="literal">&lt;errno.h&gt;</code> by
                        defining the macro <code class="literal">_GNU_SOURCE</code>.</p></li></ul></div><p>As shown in <a class="xref" href="ch06.html#typical_memory_layout_of_a_process_on_li" title="Figure 6-1. Typical memory layout of a process on Linux/x86-32">Figure 6-1</a>, the
                    <span class="emphasis"><em>argv</em></span> and <span class="emphasis"><em>environ</em></span> arrays, as well as
                the strings they initially point to, reside in a single contiguous area of memory
                just above the process stack. (We describe <span class="emphasis"><em>environ</em></span>, which holds
                the program’s environment list, in the next section.) There is an upper limit on the
                total number of bytes that can be stored in this area. SUSv3 prescribes the use of
                the <code class="literal">ARG_MAX</code> constant (defined in <code class="literal">&lt;limits.h&gt;</code>) or the call
                    <span class="emphasis"><em>sysconf(_SC_ARG_MAX)</em></span> to determine this limit. (We describe
                    <span class="emphasis"><em>sysconf()</em></span> in Section 11.2.) SUSv3 requires <code class="literal">ARG_MAX</code> to be at least <code class="literal">_POSIX_ARG_MAX</code> (4096) bytes. Most UNIX implementations allow a
                considerably higher limit than this. SUSv3 leaves it unspecified whether an
                implementation counts overhead bytes (for terminating null bytes, alignment bytes,
                and the <span class="emphasis"><em>argv</em></span> and <span class="emphasis"><em>environ</em></span> arrays of
                pointers) against the <code class="literal">ARG_MAX</code> limit.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, <code class="literal">ARG_MAX</code> was historically fixed at
                    32 pages (i.e., 131,072 bytes on Linux/x86-32), and included the space for
                    overhead bytes. Starting with kernel 2.6.23, the limit on the total space used
                    for <span class="emphasis"><em>argv</em></span> and <span class="emphasis"><em>environ</em></span> can be controlled
                    via the <code class="literal">RLIMIT_STACK</code> resource limit, and a
                    much larger limit is permitted for <span class="emphasis"><em>argv</em></span> and
                        <span class="emphasis"><em>environ</em></span>. The limit is calculated as one-quarter of the
                    soft <code class="literal">RLIMIT_STACK</code> resource limit that was in
                    force at the time of the <span class="emphasis"><em>execve()</em></span> call. For further
                    details, see the <span class="emphasis"><em>execve(2)</em></span> man page.<a id="IDX-CHP-6-0944" class="indexterm"/></p></div><p>Many programs (including several of the examples in this book) parse command-line
                options (i.e., arguments beginning with a hyphen) using the
                    <span class="emphasis"><em>getopt()</em></span> library function. We describe
                    <span class="emphasis"><em>getopt()</em></span> in <a class="xref" href="apb.html" title="Appendix B. Parsing Command-Line Options">Appendix B</a>.</p></div><div class="sect1" title="Environment List"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="environment_list-id1">Environment List</h2></div></div></div><p>Each process has an associated array of strings called the <span class="emphasis"><em>environment
                    list</em></span>, or simply the <span class="emphasis"><em>environment</em></span>. Each of these
                strings is a definition of the form <span class="emphasis"><em>name=value</em></span>. Thus, the
                environment represents a set of name-value pairs that can be used to hold arbitrary
                information. The names in the list are referred to as <span class="emphasis"><em>environment
                    variables</em></span>.<a id="IDX-CHP-6-0945" class="indexterm"/><a id="IDX-CHP-6-0946" class="indexterm"/><a id="IDX-CHP-6-0947" class="indexterm"/><a id="IDX-CHP-6-0948" class="indexterm"/><a id="IDX-CHP-6-0949" class="indexterm"/><a id="IDX-CHP-6-0950" class="indexterm"/></p><p>When a new process is created, it inherits a copy of its parent’s environment.
                This is a primitive but frequently used form of interprocess communication—the
                environment provides a way to transfer information from a parent process to its
                child(ren). Since the child gets a copy of its parent’s environment at the time it
                is created, this transfer of information is one-way and once-only. After the child
                process has been created, either process may change its own environment, and these
                changes are not seen by the other process.</p><p>A common use of environment variables is in the shell. By placing values in its
                own environment, the shell can ensure that these values are passed to the processes
                that it creates to execute user commands. For example, the environment variable
                    <code class="literal">SHELL</code> is set to be the pathname of the shell
                program itself. Many programs interpret this variable as the name of the shell that
                should be executed if the program needs to execute a shell.<a id="IDX-CHP-6-0951" class="indexterm"/></p><p>Some library functions allow their behavior to be modified by setting environment
                variables. This allows the user to control the behavior of an application using the
                function without needing to change the code of the application or relink it against
                the corresponding library. An example of this technique is provided by the
                    <span class="emphasis"><em>getopt()</em></span> function (<a class="xref" href="apb.html" title="Appendix B. Parsing Command-Line Options">Appendix B</a>), whose behavior can be modified by
                setting the <code class="literal">POSIXLY_CORRECT</code> environment
                variable.</p><p>In most shells, a value can be added to the environment using the
                    <span class="emphasis"><em>export</em></span> command:</p><a id="I_programlisting6_d1e14829"/><pre class="programlisting">$ <strong class="userinput"><code>SHELL=/bin/bash</code></strong>
               <em class="lineannotation"><span class="lineannotation">Create a shell variable</span></em>

$ <strong class="userinput"><code>export SHELL</code></strong>
                  <em class="lineannotation"><span class="lineannotation">Put variable into shell process's environment</span></em></pre><p>In <span class="emphasis"><em>bash</em></span> and the Korn shell, this can be abbreviated
                to:</p><a id="I_programlisting6_d1e14847"/><pre class="programlisting">$ <strong class="userinput"><code>export SHELL=/bin/bash</code></strong></pre><p>In the C shell, the <span class="emphasis"><em>setenv</em></span> command is used instead:</p><a id="I_programlisting6_d1e14856"/><pre class="programlisting">% <strong class="userinput"><code>setenv SHELL /bin/bash</code></strong></pre><p>The above commands permanently add a value to the shell’s environment, and this
                environment is then inherited by all child processes that the shell creates. At any
                point, an environment variable can be removed with the <span class="emphasis"><em>unset</em></span>
                command (<span class="emphasis"><em>unsetenv</em></span> in the C shell).</p><p>In the Bourne shell and its descendants (e.g., <span class="emphasis"><em>bash</em></span> and the
                Korn shell), the following syntax can be used to add values to the environment used
                to execute a single program, without affecting the parent shell (and subsequent
                commands):</p><a id="I_programlisting6_d1e14874"/><pre class="programlisting">$ <strong class="userinput"><code><em class="replaceable"><code>NAME=value</code></em></code></strong> <strong class="userinput"><code><em class="replaceable"><code>program</code></em></code></strong></pre><p>This adds a definition to the environment of just the child process executing the
                named program. If desired, multiple assignments (delimited by white space) can
                precede the program name.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>env</em></span> command runs a program using a modified copy of
                    the shell’s environment list. The environment list can be modified to both add
                    and remove definitions from the list copied from the shell. See the
                        <span class="emphasis"><em>env(1)</em></span> manual page for further details.<a id="IDX-CHP-6-0952" class="indexterm"/></p></div><p>The <span class="emphasis"><em>printenv</em></span> command displays the current environment list.
                Here is an example of its output:<a id="IDX-CHP-6-0953" class="indexterm"/></p><a id="I_programlisting6_d1e14909"/><pre class="programlisting">$ <strong class="userinput"><code>printenv</code></strong>
LOGNAME=mtk
SHELL=/bin/bash
HOME=/home/mtk
PATH=/usr/local/bin:/usr/bin:/bin:.
TERM=xterm</pre><p>We describe the purpose of most of the above environment variables at appropriate
                points in later chapters (see also the <span class="emphasis"><em>environ(7)</em></span> manual
                page).</p><p>From the above output, we can see that the environment list is not sorted; the
                order of the strings in the list is simply the arrangement that is most convenient
                for the implementation. In general, this is not a problem, since we normally want to
                access individual variables in the environment, rather than some ordered sequence of
                them.</p><p>The environment list of any process can be examined via the Linux-specific
                    /<code class="literal">proc/</code><em class="replaceable"><code>PID</code></em><code class="literal">/environ</code> file, with each
                    <span class="emphasis"><em>NAME=value</em></span> pair being terminated by a null byte.</p><div class="sect2" title="Accessing the environment from a program"><div class="titlepage"><div><div><h3 class="title" id="accessing_the_environment_from_a_program">Accessing the environment from a program</h3></div></div></div><p>Within a C program, the environment list can be accessed using the global
                    variable <span class="emphasis"><em>char **environ</em></span>. (The C run-time startup code
                    defines this variable and assigns the location of the environment list to it.)
                    Like <span class="emphasis"><em>argv</em></span>, <span class="emphasis"><em>environ</em></span> points to a
                        <code class="literal">NULL</code>-terminated list of pointers to
                    null-terminated strings. <a class="xref" href="ch06.html#example_of_process_environment_list_data" title="Figure 6-5. Example of process environment list data structures">Figure 6-5</a> shows the environment
                    list data structures as they would appear for the environment displayed by the
                        <span class="emphasis"><em>printenv</em></span> command above.<a id="IDX-CHP-6-0954" class="indexterm"/><a id="IDX-CHP-6-0955" class="indexterm"/><a id="IDX-CHP-6-0956" class="indexterm"/><a id="IDX-CHP-6-0957" class="indexterm"/><a id="IDX-CHP-6-0958" class="indexterm"/><a id="IDX-CHP-6-0959" class="indexterm"/><a id="IDX-CHP-6-0960" class="indexterm"/><a id="IDX-CHP-6-0961" class="indexterm"/><a id="IDX-CHP-6-0962" class="indexterm"/></p><div class="figure"><a id="example_of_process_environment_list_data"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e15018"/><img src="figs/web/06-5_PROCESS-environ.png" alt="Example of process environment list data structures"/></div></div><div class="figure-title">Figure 6-5. Example of process environment list data structures</div></div><p>The program in <a class="xref" href="ch06.html#displaying_the_process_environment" title="Example 6-3. Displaying the process environment">Example 6-3</a> accesses
                        <span class="emphasis"><em>environ</em></span> in order to list all of the values in the
                    process environment. This program yields the same output as the
                        <span class="emphasis"><em>printenv</em></span> command. The loop in this program relies on
                    the use of pointers to walk through <span class="emphasis"><em>environ</em></span>. While it would
                    be possible to treat <span class="emphasis"><em>environ</em></span> as an array (as we use
                        <span class="emphasis"><em>argv</em></span> in <a class="xref" href="ch06.html#echoing_command-line_arguments" title="Example 6-2. Echoing command-line arguments">Example 6-2</a>), this is less natural, since the items in the environment list are in no
                    particular order and there is no variable (corresponding to
                        <span class="emphasis"><em>argc</em></span>) that specifies the size of the environment list.
                    (For similar reasons, we don’t number the elements of the
                        <span class="emphasis"><em>environ</em></span> array in <a class="xref" href="ch06.html#example_of_process_environment_list_data" title="Figure 6-5. Example of process environment list data structures">Figure 6-5</a>.)</p><div class="example"><a id="displaying_the_process_environment"/><div class="example-title">Example 6-3. Displaying the process environment</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>proc/display_env.c</code></strong>
#include "tlpi_hdr.h"

extern char **environ;

int
main(int argc, char *argv[])
{
    char **ep;

    for (ep = environ; *ep != NULL; ep++)
        puts(*ep);

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>proc/display_env.c</code></strong></pre></div></div><p>An alternative method of accessing the environment list is to declare a third
                    argument to the <span class="emphasis"><em>main()</em></span> function:</p><a id="I_programlisting6_d1e15067"/><pre class="programlisting">int main(int argc, char *argv[], char *envp[])</pre><p>This argument can then be treated in the same way as
                        <span class="emphasis"><em>environ</em></span>, with the difference that its scope is local to
                        <span class="emphasis"><em>main()</em></span>. Although this feature is widely implemented on
                    UNIX systems, its use should be avoided since, in addition to the scope
                    limitation, it is not specified in SUSv3.</p><p>The <span class="emphasis"><em>getenv()</em></span> function retrieves individual values from
                    the process environment.<a id="IDX-CHP-6-0963" class="indexterm"/></p><a id="I_programlisting6_d1e15086"/><pre class="programlisting">#include &lt;stdlib.h&gt;

char *<strong class="userinput"><code>getenv</code></strong>(const char *<span class="emphasis"><em>name</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to (value) string, or <code class="literal">NULL</code> if no such variable</p></div><p>Given the name of an environment variable, <span class="emphasis"><em>getenv()</em></span>
                    returns a pointer to the corresponding value string. Thus, in the case of our
                    example environment shown earlier, <span class="emphasis"><em>/bin/bash</em></span> would be
                    returned if <code class="literal">SHELL</code> was specified as the
                        <span class="emphasis"><em>name</em></span> argument. If no environment variable with the
                    specified name exists, then <span class="emphasis"><em>getenv()</em></span> returns <code class="literal">NULL</code>.</p><p>Note the following portability considerations when using
                        <span class="emphasis"><em>getenv()</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>SUSv3 stipulates that an application should not modify the string
                            returned by <span class="emphasis"><em>getenv()</em></span>. This is because (in most
                            implementations) this string is actually part of the environment (i.e.,
                            the <span class="emphasis"><em>value</em></span> part of the
                                <span class="emphasis"><em>name=value</em></span> string). If we need to change the
                            value of an environment variable, then we can use the
                                <span class="emphasis"><em>setenv()</em></span> or <span class="emphasis"><em>putenv()</em></span>
                            functions (described below).</p></li><li class="listitem"><p>SUSv3 permits an implementation of <span class="emphasis"><em>getenv()</em></span> to
                            return its result using a statically allocated buffer that may be
                            overwritten by subsequent calls to <span class="emphasis"><em>getenv()</em></span>,
                                <span class="emphasis"><em>setenv()</em></span>, <span class="emphasis"><em>putenv()</em></span>, or
                                <span class="emphasis"><em>unsetenv()</em></span>. Although the
                                <span class="emphasis"><em>glibc</em></span> implementation of
                                <span class="emphasis"><em>getenv()</em></span> doesn’t use a static buffer in this
                            way, a portable program that needs to preserve the string returned by a
                            call to <span class="emphasis"><em>getenv()</em></span> should copy it to a different
                            location before making a subsequent call to one of these
                                functions.<a id="IDX-CHP-6-0964" class="indexterm"/><a id="IDX-CHP-6-0965" class="indexterm"/></p></li></ul></div><div class="sect3" title="Modifying the environment"><div class="titlepage"><div><div><h4 class="title" id="modifying_the_environment">Modifying the environment</h4></div></div></div><p>Sometimes, it is useful for a process to modify its environment. One
                        reason is to make a change that is visible in all child processes
                        subsequently created by that process. Another possibility is that we want to
                        set a variable that is visible to a new program to be loaded into the memory
                        of this process (“execed”). In this sense, the environment is not just a
                        form of interprocess communication, but also a method of interprogram
                        communication. (This point will become clearer in <a class="xref" href="ch27.html" title="Chapter 27. Program Execution">Chapter 27</a>, where we explain how the
                            <span class="emphasis"><em>exec()</em></span> functions permit a program to replace itself
                        by a new program within the same process.)<a id="IDX-CHP-6-0966" class="indexterm"/><a id="IDX-CHP-6-0967" class="indexterm"/><a id="IDX-CHP-6-0968" class="indexterm"/><a id="IDX-CHP-6-0969" class="indexterm"/><a id="IDX-CHP-6-0970" class="indexterm"/><a id="IDX-CHP-6-0971" class="indexterm"/></p><p>The <span class="emphasis"><em>putenv()</em></span> function adds a new variable to the
                        calling process’s environment or modifies the value of an existing
                        variable.</p><a id="I_programlisting6_d1e15233"/><pre class="programlisting">#include &lt;stdlib.h&gt;

int <strong class="userinput"><code>putenv</code></strong>(char *<span class="emphasis"><em>string</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or nonzero on error</p></div><p>The <span class="emphasis"><em>string</em></span> argument is a pointer to a string of the
                        form <span class="emphasis"><em>name=value</em></span>. After the
                            <span class="emphasis"><em>putenv()</em></span> call, this string is part of the
                        environment. In other words, rather than duplicating the string pointed to
                        by <span class="emphasis"><em>string</em></span>, one of the elements of
                            <span class="emphasis"><em>environ</em></span> will be set to point to the same location
                        as <span class="emphasis"><em>string</em></span>. Therefore, if we subsequently modify the
                        bytes pointed to by <span class="emphasis"><em>string</em></span>, that change will affect the
                        process environment. For this reason, <span class="emphasis"><em>string</em></span> should not
                        be an automatic variable (i.e., a character array allocated on the stack),
                        since this memory area may be overwritten once the function in which the
                        variable is defined returns.</p><p>Note that <span class="emphasis"><em>putenv()</em></span> returns a nonzero value on error,
                        rather than -1.</p><p>The <span class="emphasis"><em>glibc</em></span> implementation of
                            <span class="emphasis"><em>putenv()</em></span> provides a nonstandard extension. If
                            <span class="emphasis"><em>string</em></span> doesn’t contain an equal sign (<code class="literal">=</code>), then the environment variable identified
                        by <span class="emphasis"><em>string</em></span> is removed from the environment list.</p><p>The <span class="emphasis"><em>setenv()</em></span> function is an alternative to
                            <span class="emphasis"><em>putenv()</em></span> for adding a variable to the
                        environment.</p><a id="I_programlisting6_d1e15301"/><pre class="programlisting">#include &lt;stdlib.h&gt;
int <strong class="userinput"><code>setenv</code></strong>(const char *<span class="emphasis"><em>name</em></span>, const char *<span class="emphasis"><em>value</em></span>, int <span class="emphasis"><em>overwrite</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>setenv()</em></span> function creates a new environment
                        variable by allocating a memory buffer for a string of the form
                            <span class="emphasis"><em>name=value</em></span>, and copying the strings pointed to by
                            <span class="emphasis"><em>name</em></span> and <span class="emphasis"><em>value</em></span> into that
                        buffer. Note that we don’t need to (in fact, must not) supply an equal sign
                        at the end of <span class="emphasis"><em>name</em></span> or the start of
                            <span class="emphasis"><em>value</em></span>, because <span class="emphasis"><em>setenv()</em></span> adds
                        this character when it adds the new definition to the environment.</p><p>The <span class="emphasis"><em>setenv()</em></span> function doesn’t change the environment
                        if the variable identified by <span class="emphasis"><em>name</em></span> already exists and
                            <span class="emphasis"><em>overwrite</em></span> has the value 0. If
                            <span class="emphasis"><em>overwrite</em></span> is nonzero, the environment is always
                        changed.</p><p>The fact that <span class="emphasis"><em>setenv()</em></span> copies its arguments means
                        that, unlike with <span class="emphasis"><em>putenv()</em></span>, we can subsequently modify
                        the contents of the strings pointed to by <span class="emphasis"><em>name</em></span> and
                            <span class="emphasis"><em>value</em></span> without affecting the environment. It also
                        means that using automatic variables as arguments to
                            <span class="emphasis"><em>setenv()</em></span> doesn’t cause any problems.</p><p>The <span class="emphasis"><em>unsetenv()</em></span> function removes the variable
                        identified by <span class="emphasis"><em>name</em></span> from the environment.<a id="IDX-CHP-6-0972" class="indexterm"/></p><a id="I_programlisting6_d1e15386"/><pre class="programlisting">#include &lt;stdlib.h&gt;

int <strong class="userinput"><code>unsetenv</code></strong>(const char *<span class="emphasis"><em>name</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>As with <span class="emphasis"><em>setenv()</em></span>, <span class="emphasis"><em>name</em></span> should
                        not include an equal sign.</p><p>Both <span class="emphasis"><em>setenv()</em></span> and <span class="emphasis"><em>unsetenv()</em></span>
                        derive from BSD, and are less widespread than <span class="emphasis"><em>putenv()</em></span>.
                        Although not defined in the original POSIX.1 standard or in SUSv2, they are
                        included in SUSv3.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In versions of <span class="emphasis"><em>glibc</em></span> before 2.2.2,
                                <span class="emphasis"><em>unsetenv()</em></span> was prototyped as returning
                                <span class="emphasis"><em>void</em></span>. This was how
                                <span class="emphasis"><em>unsetenv()</em></span> was prototyped in the original BSD
                            implementation, and some UNIX implementations still follow the BSD
                            prototype.</p></div><p>On occasion, it is useful to erase the entire environment, and then
                        rebuild it with selected values. For example, we might do this in order to
                        execute set-user-ID programs in a secure manner (<a class="xref" href="ch38.html#don_apostrophy_t_trust_inputs_or_the_env" title="Don’t Trust Inputs or the Environment">Don’t Trust Inputs or the Environment</a>). We can erase the
                        environment by assigning <code class="literal">NULL</code> to
                            <span class="emphasis"><em>environ</em></span>:</p><a id="I_programlisting6_d1e15441"/><pre class="programlisting">environ = NULL;</pre><p>This is exactly the step performed by the <span class="emphasis"><em>clearenv()</em></span>
                        library function.<a id="IDX-CHP-6-0973" class="indexterm"/></p><a id="I_programlisting6_d1e15453"/><pre class="programlisting">#define _BSD_SOURCE           /* Or: #define _SVID_SOURCE */
#include &lt;stdlib.h&gt;

int <strong class="userinput"><code>clearenv</code></strong>(void)</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a nonzero on error</p></div><p>In some circumstances, the use of <span class="emphasis"><em>setenv()</em></span> and
                            <span class="emphasis"><em>clearenv()</em></span> can lead to memory leaks in a program.
                        We noted above that <span class="emphasis"><em>setenv()</em></span> allocates a memory buffer
                        that is then made part of the environment. When we call
                            <span class="emphasis"><em>clearenv()</em></span>, it doesn’t free this buffer (it can’t,
                        since it doesn’t know of the buffer’s existence). A program that repeatedly
                        employed these two functions would steadily leak memory. In practice, this
                        is unlikely to be a problem, because a program typically calls
                            <span class="emphasis"><em>clearenv()</em></span> just once on startup, in order to remove
                        all entries from the environment that it inherited from its predecessor
                        (i.e., the program that called <span class="emphasis"><em>exec()</em></span> to start this
                        program).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Many UNIX implementations provide <span class="emphasis"><em>clearenv()</em></span>, but
                            it is not specified in SUSv3. SUSv3 specifies that if an application
                            directly modifies <span class="emphasis"><em>environ</em></span>, as is done by
                                <span class="emphasis"><em>clearenv()</em></span>, then the behavior of
                                <span class="emphasis"><em>setenv()</em></span>, <span class="emphasis"><em>unsetenv()</em></span>, and
                                <span class="emphasis"><em>getenv()</em></span> is undefined. (The rationale behind
                            this is that preventing a conforming application from directly modifying
                            the environment allows the implementation full control over the data
                            structures that it uses to implement environment variables.) The only
                            way that SUSv3 permits an application to clear its environment is to
                            obtain a list of all environment variables (by getting the names from
                                <span class="emphasis"><em>environ</em></span>), and then using
                                <span class="emphasis"><em>unsetenv()</em></span> to remove each of these
                            names.</p></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id1">Example program</h4></div></div></div><p><a class="xref" href="ch06.html#modifying_the_process_environment" title="Example 6-4. Modifying the process environment">Example 6-4</a> demonstrates the use
                        of all of the functions discussed in this section. After first clearing the
                        environment, this program adds any environment definitions provided as
                        command-line arguments. It then: adds a definition for a variable called
                            <code class="literal">GREET</code>, if one doesn’t already exist
                        in the environment; removes any definition for a variable named <code class="literal">BYE</code>; and, finally, prints the current
                        environment list. Here is an example of the output produced when the program
                        is run:</p><a id="I_programlisting6_d1e15522"/><pre class="programlisting">$ <strong class="userinput"><code>./modify_env "GREET=Guten Tag" SHELL=/bin/bash BYE=Ciao</code></strong>

GREET=Guten Tag
SHELL=/bin/bash
$ <strong class="userinput"><code>./modify_env SHELL=/bin/sh BYE=byebye</code></strong>

SHELL=/bin/sh
GREET=Hello world</pre><p>If we assign <code class="literal">NULL</code> to
                            <span class="emphasis"><em>environ</em></span> (as is done by the call to
                            <span class="emphasis"><em>clearenv()</em></span> in <a class="xref" href="ch06.html#modifying_the_process_environment" title="Example 6-4. Modifying the process environment">Example 6-4</a>), then we would expect
                        that a loop of the following form (as used in the program) would fail, since
                            <span class="emphasis"><em>*environ</em></span> is invalid:</p><a id="I_programlisting6_d1e15546"/><pre class="programlisting">for (ep = environ; *ep != NULL; ep++)
    puts(*ep);</pre><p>However, if <span class="emphasis"><em>setenv()</em></span> and
                            <span class="emphasis"><em>putenv()</em></span> find that <span class="emphasis"><em>environ</em></span> is
                            <code class="literal">NULL</code>, they create a new environment
                        list and set <span class="emphasis"><em>environ</em></span> pointing to it, with the result
                        that the above loop operates correctly.<a id="IDX-CHP-6-0974" class="indexterm"/></p><div class="example"><a id="modifying_the_process_environment"/><div class="example-title">Example 6-4. Modifying the process environment</div><div class="example-contents"><pre class="programlisting">     <strong class="userinput"><code>proc/modify_env.c</code></strong>
#define _GNU_SOURCE     /* To get various declarations from &lt;stdlib.h&gt; */
#include &lt;stdlib.h&gt;
#include "tlpi_hdr.h"

extern char **environ;

int
main(int argc, char *argv[])
{
    int j;
    char **ep;

    clearenv();         /* Erase entire environment */

    for (j = 1; j &lt; argc; j++)
        if (putenv(argv[j]) != 0)
            errExit("putenv: %s", argv[j]);

    if (setenv("GREET", "Hello world", 0) == -1)
        errExit("setenv");

    unsetenv("BYE");

    for (ep = environ; *ep != NULL; ep++)
        puts(*ep);

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>proc/modify_env.c</code></strong></pre></div></div></div></div></div><div class="sect1" title="Performing a Nonlocal Goto: setjmp() and long jmp()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="performing_a_nonlocal_goto_colon_setjmp">Performing a Nonlocal Goto: <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>long
                    jmp()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>longjmp()</em></span> library
                functions are used to perform a <span class="emphasis"><em>nonlocal goto</em></span>. The term
                    <span class="emphasis"><em>nonlocal</em></span> refers to the fact that the target of the goto is
                a location somewhere outside the currently executing function.<a id="IDX-CHP-6-0976" class="indexterm"/><a id="IDX-CHP-6-0977" class="indexterm"/><a id="IDX-CHP-6-0978" class="indexterm"/><a id="IDX-CHP-6-0979" class="indexterm"/><a id="IDX-CHP-6-0980" class="indexterm"/><a id="IDX-CHP-6-0981" class="indexterm"/><a id="IDX-CHP-6-0975" class="indexterm"/><a id="IDX-CHP-6-0982" class="indexterm"/></p><p>Like many programming languages, C includes the <code class="literal">goto</code> statement, which is open to endless abuse in making programs
                difficult to read and maintain, and is occasionally useful to make a program
                simpler, faster, or both.</p><p>One restriction of C’s <code class="literal">goto</code> is that it is not
                possible to jump out of the current function into another function. However, such
                functionality can occasionally be useful. Consider the following common scenario in
                error handling: during a deeply nested function call, we encounter an error that
                should be handled by abandoning the current task, returning through multiple
                function calls, and then continuing execution in some much higher function (perhaps
                even <span class="emphasis"><em>main()</em></span>). To do this, we could have each function return a
                status value that is checked and appropriately handled by its caller. This is
                perfectly valid, and, in many cases, the desirable method for handling this kind of
                scenario. However, in some cases, coding would be simpler if we could jump from the
                middle of the nested function call back to one of the functions that called it (the
                immediate caller, or the caller of the caller, and so on). This is the functionality
                that <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>longjmp()</em></span>
                provide.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The restriction that a <code class="literal">goto</code> can’t be used
                    to jump between functions in C exists because all C functions reside at the same
                    scope level (i.e., there is no nesting of function declarations in standard C,
                    although <span class="emphasis"><em>gcc</em></span> does permit this as an extension). Thus, given
                    two functions, X and Y, the compiler has no way of knowing whether a stack frame
                    for function X might be on the stack at the time Y is invoked, and thus whether
                    a <code class="literal">goto</code> from function Y to function X would be
                    possible. In languages such as Pascal, where function declarations can be
                    nested, and a <code class="literal">goto</code> from a nested function to
                    a function that encloses it is permitted, the static scope of a function allows
                    the compiler to determine some information about the dynamic scope of the
                    function. Thus, if function Y is lexically nested within function X, then the
                    compiler knows that a stack frame for X must already be on the stack at the time
                    Y is invoked, and can generate code for a <code class="literal">goto</code> from function Y to somewhere within function X.</p></div><a id="I_programlisting6_d1e15687"/><pre class="programlisting">#include &lt;setjmp.h&gt;

int <strong class="userinput"><code>setjmp</code></strong>(jmp_buf <span class="emphasis"><em>env</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on initial call, nonzero on return via
                        <span class="emphasis"><em>longjmp()</em></span></p></div><a id="I_programlisting6_d1e15700"/><pre class="programlisting">void <strong class="userinput"><code>longjmp</code></strong>(jmp_buf <span class="emphasis"><em>env</em></span>, int <span class="emphasis"><em>val</em></span>);</pre><p>Calling <span class="emphasis"><em>setjmp()</em></span> establishes a target for a later jump
                performed by <span class="emphasis"><em>longjmp()</em></span>. This target is exactly the point in the
                program where the <span class="emphasis"><em>setjmp()</em></span> call occurred. From a programming
                point of view, after the <span class="emphasis"><em>longjmp()</em></span>, it looks exactly as though
                we have just returned from the <span class="emphasis"><em>setjmp()</em></span> call for a second time.
                The way in which we distinguish the second “return” from the initial return is by
                the integer value returned by <span class="emphasis"><em>setjmp()</em></span>. The initial
                    <span class="emphasis"><em>setjmp()</em></span> returns 0, while the later “faked” return supplies
                whatever value is specified in the <span class="emphasis"><em>val</em></span> argument of the
                    <span class="emphasis"><em>longjmp()</em></span> call. By using different values for the
                    <span class="emphasis"><em>val</em></span> argument, we can distinguish jumps to the same target
                from different points in the program.</p><p>Specifying the <span class="emphasis"><em>val</em></span> argument to <span class="emphasis"><em>longjmp()</em></span>
                as 0 would, if unchecked, cause the faked return from <span class="emphasis"><em>setjmp()</em></span>
                to look as though it were the initial return. For this reason, if
                    <span class="emphasis"><em>val</em></span> is specified as 0, <span class="emphasis"><em>longjmp()</em></span>
                actually uses the value 1.</p><p>The <span class="emphasis"><em>env</em></span> argument used by both functions supplies the glue
                enabling the jump to be accomplished. The <span class="emphasis"><em>setjmp()</em></span> call saves
                various information about the current process environment into
                    <span class="emphasis"><em>env</em></span>. This allows the <span class="emphasis"><em>longjmp()</em></span> call,
                which must specify the same <span class="emphasis"><em>env</em></span> variable, to perform the fake
                return. Since the <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>longjmp()</em></span>
                calls are in different functions (otherwise, we could use a simple <code class="literal">goto</code>), <span class="emphasis"><em>env</em></span> is declared globally
                or, less commonly, passed as a function argument.</p><p>Along with other information, <span class="emphasis"><em>env</em></span> stores a copy of the
                    <span class="emphasis"><em>program counter</em></span> register (which points to the currently
                executing machine-language instruction) and the <span class="emphasis"><em>stack pointer</em></span>
                register (which marks the top of the stack) at the time of the call to
                    <span class="emphasis"><em>setjmp()</em></span>. This information enables the subsequent
                    <span class="emphasis"><em>longjmp()</em></span> call to accomplish two key steps:<a id="IDX-CHP-6-0983" class="indexterm"/><a id="IDX-CHP-6-0984" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Strip off the stack frames for all of the intervening functions on the
                        stack between the function calling <span class="emphasis"><em>longjmp()</em></span> and the
                        function that previously called <span class="emphasis"><em>setjmp()</em></span>. This
                        procedure is sometimes called “unwinding the stack,” and is accomplished by
                        resetting the stack pointer register to the value saved in the
                            <span class="emphasis"><em>env</em></span> argument.<a id="IDX-CHP-6-0985" class="indexterm"/></p></li><li class="listitem"><p>Reset the program counter register so that the program continues execution
                        from the location of the initial <span class="emphasis"><em>setjmp()</em></span> call. Again,
                        this is accomplished using the value saved in
                        <span class="emphasis"><em>env</em></span>.</p></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_program-id2"/></div></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id3">Example program</h4></div></div></div><p><a class="xref" href="ch06.html#demonstrate_the_use_of_setjmp_open_paren" title="Example 6-5. Demonstrate the use of setjmp() and longjmp()">Example 6-5</a> demonstrates
                        the use of <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>longjmp()</em></span>.
                        This program sets up a jump target with an initial call to
                            <span class="emphasis"><em>setjmp()</em></span>. The subsequent <code class="literal">switch</code> (on the value returned by
                            <span class="emphasis"><em>setjmp()</em></span>) is the means of detecting whether we have
                        just completed the initial return from <span class="emphasis"><em>setjmp()</em></span> or
                        whether we have arrived back after a <span class="emphasis"><em>longjmp()</em></span>. In the
                        case of a 0 return—meaning we have just done the initial
                            <span class="emphasis"><em>setjmp()</em></span>—we call <span class="emphasis"><em>f1()</em></span>, which
                        either immediately calls <span class="emphasis"><em>longjmp()</em></span> or goes on to call
                            <span class="emphasis"><em>f2()</em></span>, depending on the value of
                            <span class="emphasis"><em>argc</em></span> (i.e., the number of command-line arguments).
                        If <span class="emphasis"><em>f2()</em></span> is reached, it does an immediate
                            <span class="emphasis"><em>longjmp()</em></span>. A <span class="emphasis"><em>longjmp()</em></span> from
                        either function takes us back to the point of the
                            <span class="emphasis"><em>setjmp()</em></span> call. We use different
                            <span class="emphasis"><em>val</em></span> arguments in the two
                            <span class="emphasis"><em>longjmp()</em></span> calls, so that the <code class="literal">switch</code> statement in
                            <span class="emphasis"><em>main()</em></span> can determine the function from which the
                        jump occurred and print a suitable message.<a id="IDX-CHP-6-0986" class="indexterm"/></p><p>When we run the program in <a class="xref" href="ch06.html#demonstrate_the_use_of_setjmp_open_paren" title="Example 6-5. Demonstrate the use of setjmp() and longjmp()">Example 6-5</a> without any
                        command-line arguments, this is what we see:</p><a id="I_programlisting6_d1e15921"/><pre class="programlisting">$ <strong class="userinput"><code>./longjmp</code></strong>

Calling f1() after initial setjmp()
We jumped back from f1()</pre><p>Specifying a command-line argument causes the jump to occur from
                            <span class="emphasis"><em>f 2()</em></span>:</p><a id="I_programlisting6_d1e15931"/><pre class="programlisting">$ <strong class="userinput"><code>./longjmp x</code></strong>

Calling f1() after initial setjmp()
We jumped back from f2()</pre><div class="example"><a id="demonstrate_the_use_of_setjmp_open_paren"/><div class="example-title">Example 6-5. Demonstrate the use of <span class="emphasis"><em>setjmp()</em></span> and
                                <span class="emphasis"><em>longjmp()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>proc/longjmp.c</code></strong>
#include &lt;setjmp.h&gt;
#include "tlpi_hdr.h"

static jmp_buf env;

static void
f2(void)
{
    longjmp(env, 2);
}

static void
f1(int argc)
{
    if (argc == 1)
        longjmp(env, 1);
    f2();
}

int
main(int argc, char *argv[])
{
    switch (setjmp(env)) {
    case 0:     /* This is the return after the initial setjmp() */
        printf("Calling f1() after initial setjmp()\n");
        f1(argc);               /* Never returns... */
        break;                  /* ... but this is good form */

    case 1:
        printf("We jumped back from f1()\n");
        break;

    case 2:
        printf("We jumped back from f2()\n");
        break;
    }

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>proc/longjmp.c</code></strong></pre></div></div></div><div class="sect3" title="Restrictions on the use of setjmp()"><div class="titlepage"><div><div><h4 class="title" id="restrictions_on_the_use_of_setjmp_open_p">Restrictions on the use of <span class="emphasis"><em>setjmp()</em></span></h4></div></div></div><p>SUSv3 and C99 specify that a call to <span class="emphasis"><em>setjmp()</em></span> may
                        appear only in the following contexts:<a id="IDX-CHP-6-0987" class="indexterm"/><a id="IDX-CHP-6-0988" class="indexterm"/><a id="IDX-CHP-6-0989" class="indexterm"/><a id="IDX-CHP-6-0990" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>as the entire controlling expression of a selection or iteration
                                statement (<code class="literal">if</code>, <code class="literal">switch</code>, <code class="literal">while</code>, and so on);</p></li><li class="listitem"><p>as the operand of a unary <code class="literal">!</code>
                                    (<span class="emphasis"><em>not</em></span>) operator, where the resulting
                                expression is the entire controlling expression of a selection or
                                iteration statement;</p></li><li class="listitem"><p>as part of a comparison operation (<code class="literal">==</code>, <code class="literal">!=</code>, <code class="literal">&lt;</code>, and so on), where the other
                                operand is an integer constant expression and the resulting
                                expression is the entire controlling expression of a selection or
                                iteration statement; or</p></li><li class="listitem"><p>as a free-standing function call that is not embedded inside some
                                larger expression.</p></li></ul></div><p>Note that the C assignment statement doesn’t figure in the list above. A
                        statement of the following form is not standards-conformant:</p><a id="I_programlisting6_d1e16025"/><pre class="programlisting">s = setjmp(env);                    /* WRONG! */</pre><p>These restrictions are specified because an implementation of
                            <span class="emphasis"><em>setjmp()</em></span> as a conventional function can’t be
                        guaranteed to have enough information to be able to save the values of all
                        registers and temporary stack locations used in an enclosing expression so
                        that they could then be correctly restored after a
                            <span class="emphasis"><em>longjmp()</em></span>. Thus, it is permitted to call
                            <span class="emphasis"><em>setjmp()</em></span> only inside expressions simple enough not
                        to require temporary storage.</p></div><div class="sect3" title="Abusing longjmp()"><div class="titlepage"><div><div><h4 class="title" id="abusing_long_jmp_open_parenthesis_close">Abusing <span class="emphasis"><em>longjmp()</em></span></h4></div></div></div><p>If the <span class="emphasis"><em>env</em></span> buffer is declared global to all functions
                        (which is typical), then it is possible to execute the following sequence of
                            steps:<a id="IDX-CHP-6-0991" class="indexterm"/><a id="IDX-CHP-6-0992" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Call a function <span class="emphasis"><em>x()</em></span> that uses
                                    <span class="emphasis"><em>setjmp()</em></span> to establish a jump target in the
                                global variable <span class="emphasis"><em>env</em></span>.</p></li><li class="listitem"><p>Return from function <span class="emphasis"><em>x()</em></span>.</p></li><li class="listitem"><p>Call a function <span class="emphasis"><em>y()</em></span> that does a
                                    <span class="emphasis"><em>longjmp()</em></span> using
                                <span class="emphasis"><em>env</em></span>.</p></li></ol></div><p>This is a serious error. We can’t do a <span class="emphasis"><em>longjmp()</em></span> into
                        a function that has already returned. Considering what
                            <span class="emphasis"><em>longjmp()</em></span> tries to do to the stack—it attempts to
                        unwind the stack back to a frame that no longer exists—leads us to realize
                        that chaos will result. If we are lucky, our program will simply crash.
                        However, depending on the state of the stack, other possibilities include
                        infinite call-return loops and the program behaving as though it really did
                        return from a function that was not currently executing. (In a multithreaded
                        program, a similar abuse is to call <span class="emphasis"><em>longjmp()</em></span> in a
                        different thread from that in which <span class="emphasis"><em>setjmp()</em></span> was
                        called.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 says that if <span class="emphasis"><em>longjmp()</em></span> is called from
                            within a nested signal handler (i.e., a handler that was invoked while
                            the handler for another signal was executing), then the program behavior
                            is undefined.</p></div></div><div class="sect3" title="Problems with optimizing compilers"><div class="titlepage"><div><div><h4 class="title" id="problems_with_optimizing_compilers">Problems with optimizing compilers</h4></div></div></div><p>Optimizing compilers may rearrange the order of instructions in a program
                        and store certain variables in CPU registers, rather than RAM. Such
                        optimizations generally rely on the run-time flow of control reflecting the
                        lexical structure of the program. Since jump operations performed via
                            <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>longjmp()</em></span> are
                        established and executed at run time, and are not reflected in the lexical
                        structure of the program, a compiler optimizer is unable to take them into
                        account when performing its task. Furthermore, the semantics of some ABI
                        implementations require <span class="emphasis"><em>longjmp()</em></span> to restore copies of
                        the CPU registers saved by the earlier <span class="emphasis"><em>setjmp()</em></span> call.
                        This means that optimized variables may end up with incorrect values as a
                        consequence of a <span class="emphasis"><em>longjmp()</em></span> operation. We can see an
                        example of this by examining the behavior of the program in <a class="xref" href="ch06.html#a_demonstration_of_the_interaction_of_co" title="Example 6-6. A demonstration of the interaction of compiler optimization and longjmp()">Example 6-6</a>.<a id="IDX-CHP-6-0993" class="indexterm"/><a id="IDX-CHP-6-0994" class="indexterm"/><a id="IDX-CHP-6-0995" class="indexterm"/></p><div class="example"><a id="a_demonstration_of_the_interaction_of_co"/><div class="example-title">Example 6-6. A demonstration of the interaction of compiler optimization and
                                <span class="emphasis"><em>longjmp()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>proc/setjmp_vars.c</code></strong>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;setjmp.h&gt;

static jmp_buf env;

static void
doJump(int nvar, int rvar, int vvar)
{
    printf("Inside doJump(): nvar=%d rvar=%d vvar=%d\n", nvar, rvar, vvar);
    longjmp(env, 1);
}

int
main(int argc, char *argv[])
{
    int nvar;
    register int rvar;          /* Allocated in register if possible */
    volatile int vvar;          /* See text */

    nvar = 111;
    rvar = 222;
    vvar = 333;

    if (setjmp(env) == 0) {     /* Code executed after setjmp() */
        nvar = 777;
        rvar = 888;
        vvar = 999;
        doJump(nvar, rvar, vvar);

    } else {                    /* Code executed after longjmp() */

        printf("After longjmp(): nvar=%d rvar=%d vvar=%d\n", nvar, rvar, vvar);
    }

    exit(EXIT_SUCCESS);
}

      <strong class="userinput"><code>proc/setjmp_vars.c</code></strong></pre></div></div><p>When we compile the program in <a class="xref" href="ch06.html#a_demonstration_of_the_interaction_of_co" title="Example 6-6. A demonstration of the interaction of compiler optimization and longjmp()">Example 6-6</a> normally, we see
                        the expected output:</p><a id="I_programlisting6_d1e16166"/><pre class="programlisting">$ <strong class="userinput"><code>cc -o setjmp_vars setjmp_vars.c</code></strong>

$ <strong class="userinput"><code>./setjmp_vars</code></strong>

Inside doJump(): nvar=777 rvar=888 vvar=999
After longjmp(): nvar=777 rvar=888 vvar=999</pre><p>However, when we compile with optimization, we get the following
                        unexpected results:</p><a id="I_programlisting6_d1e16176"/><pre class="programlisting">$ <strong class="userinput"><code>cc -O -o setjmp_vars setjmp_vars.c</code></strong>

$ <strong class="userinput"><code>./setjmp_vars</code></strong>

Inside doJump(): nvar=777 rvar=888 vvar=999
After longjmp(): nvar=111 rvar=222 vvar=999</pre><p>Here, we see that after the <span class="emphasis"><em>longjmp()</em></span>,
                            <span class="emphasis"><em>nvar</em></span> and <span class="emphasis"><em>rvar</em></span> have been reset
                        to their values at the time of the <span class="emphasis"><em>setjmp()</em></span> call. This
                        has occurred because the code reorganization performed by the optimizer has
                        been confused as a consequence of the <span class="emphasis"><em>longjmp()</em></span>. Any
                        local variables that are candidates for optimization may be subject to this
                        sort of problem; this generally means pointer variables and variables of any
                        of the simple types <span class="emphasis"><em>char</em></span>, <span class="emphasis"><em>int</em></span>,
                            <span class="emphasis"><em>float</em></span>, and <span class="emphasis"><em>long</em></span>.</p><p>We can prevent such code reorganization by declaring variables as <code class="literal">volatile</code>, which tells the optimizer not to
                        optimize them. In the preceding program output, we see that the variable
                            <span class="emphasis"><em>vvar</em></span>, which was declared <code class="literal">volatile</code>, was correctly handled, even when we compiled with
                        optimization.</p><p>Since different compilers do different types of optimizations, portable
                        programs should employ the <code class="literal">volatile</code>
                        keyword with all of the local variables of the aforementioned types in the
                        function that calls <span class="emphasis"><em>setjmp()</em></span>.</p><p>If we specify the <span class="emphasis"><em>-Wextra</em></span> (<span class="emphasis"><em>extra
                            warnings</em></span>) option to the GNU C compiler, it produces the
                        following helpful warning for the <code class="literal">setjmp_vars.c</code> program:</p><a id="I_programlisting6_d1e16245"/><pre class="programlisting">$ <strong class="userinput"><code>cc -Wall -Wextra -O -o setjmp_vars setjmp_vars.c</code></strong>

setjmp_vars.c: In function `main':
setjmp_vars.c:17: warning: variable `nvar' might be clobbered by `longjmp' or `vfork'
setjmp_vars.c:18: warning: variable `rvar' might be clobbered by `longjmp' or `vfork'</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>It is instructive to look at the assembler output produced when
                            compiling the <code class="literal">setjmp_vars.c</code> program
                            both with and without optimization. The <span class="emphasis"><em>cc -S</em></span>
                            command produces a file with the extension <span class="emphasis"><em>.s</em></span>
                            containing the generated assembler code for a program.</p></div></div><div class="sect3" title="Avoid setjmp() and long jmp() where possible"><div class="titlepage"><div><div><h4 class="title" id="avoid_setjmp_open_parenthesis_close_pare">Avoid <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>long jmp()</em></span>
                        where possible</h4></div></div></div><p>If <code class="literal">goto</code> statements are capable of
                        rendering a program difficult to read, then nonlocal gotos can make things
                        an order of magnitude worse, since they can transfer control between any two
                        functions in a program. For this reason, <span class="emphasis"><em>setjmp()</em></span> and
                            <span class="emphasis"><em>longjmp()</em></span> should be used sparingly. It is often
                        worth the extra work in design and coding to come up with a program that
                        avoids their use, because the program will be more readable and possibly
                        more portable. Having said that, we revisit variants of these functions
                            (<span class="emphasis"><em>sigsetjmp()</em></span> and <span class="emphasis"><em>siglongjmp()</em></span>,
                        described in <a class="xref" href="ch21.html#performing_a_nonlocal_goto_from_a_signal" title="Performing a Nonlocal Goto from a Signal Handler">Performing a Nonlocal Goto from a Signal Handler</a>)
                        when we discuss signals, since they are occasionally useful when writing
                        signal handlers.<a id="IDX-CHP-6-0996" class="indexterm"/></p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id5">Summary</h2></div></div></div><p>Each process has a unique process ID and maintains a record of its parent’s
                process ID.</p><p>The virtual memory of a process is logically divided into a number of segments:
                text, (initialized and uninitialized) data, stack, and heap.</p><p>The stack consists of a series of frames, with a new frame being added as a
                function is invoked and removed when the function returns. Each frame contains the
                local variables, function arguments, and call linkage information for a single
                function invocation.</p><p>The command-line arguments supplied when a program is invoked are made available
                via the <span class="emphasis"><em>argc</em></span> and <span class="emphasis"><em>argv</em></span> arguments to
                    <span class="emphasis"><em>main()</em></span>. By convention, <span class="emphasis"><em>argv[0]</em></span>
                contains the name used to invoke the program.</p><p>Each process receives a copy of its parent’s environment list, a set of name-value
                pairs. The global variable <span class="emphasis"><em>environ</em></span> and various library
                functions allow a process to access and modify the variables in its environment
                list.</p><p>The <span class="emphasis"><em>setjmp()</em></span> and <span class="emphasis"><em>longjmp()</em></span> functions
                provide a way to perform a nonlocal goto from one function to another (unwinding the
                stack). In order to avoid problems with compiler optimization, we may need to
                declare variables with the <code class="literal">volatile</code> modifier when
                making use of these functions. Nonlocal gotos can render a program difficult to read
                and maintain, and should be avoided whenever possible.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id3"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id4">Further information</h4></div></div></div><p>[Tanenbaum, 2007] and [Vahalia, 1996] describe virtual memory management
                        in detail. The Linux kernel memory management algorithms and code are
                        described in detail in [Gorman, 2004].<a id="IDX-CHP-6-0997" class="indexterm"/><a id="IDX-CHP-6-0998" class="indexterm"/><a id="IDX-CHP-6-0999" class="indexterm"/></p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id3">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Compile the program in <a class="xref" href="ch06.html#locations_of_program_variables_in_proces" title="Example 6-1. Locations of program variables in process memory segments">Example 6-1</a> (<code class="literal">mem_segments.c</code>), and list its size using
                            <span class="emphasis"><em>ls -l</em></span>. Although the program contains an array
                            (<span class="emphasis"><em>mbuf</em></span>) that is around 10 MB in size, the executable
                        file is much smaller than this. Why is this?</p></li><li class="listitem"><p>Write a program to see what happens if we try to
                            <span class="emphasis"><em>longjmp()</em></span> into a function that has already
                        returned.</p></li><li class="listitem"><p>Implement <span class="emphasis"><em>setenv()</em></span> and
                            <span class="emphasis"><em>unsetenv()</em></span> using <span class="emphasis"><em>getenv()</em></span>,
                            <span class="emphasis"><em>putenv()</em></span>, and, where necessary, code that directly
                        modifies <span class="emphasis"><em>environ</em></span>. Your version of
                            <span class="emphasis"><em>unsetenv()</em></span> should check to see whether there are
                        multiple definitions of an environment variable, and remove them all (which
                        is what the <span class="emphasis"><em>glibc</em></span> version of
                            <span class="emphasis"><em>unsetenv()</em></span> does).</p></li></ol></div></div></section></body></html>
