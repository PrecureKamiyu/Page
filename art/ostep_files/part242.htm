<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>22.10 Other VM Policies</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part241.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part243.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">22.10 Other VM Policies</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Page replacement is not the only policy the VM subsystem employs (though it may be the most important). For example, the OS also has to decide <i>when </i>to bring a page into memory. This policy, sometimes called the <b>page selection </b>policy (as it was called by Denning [D70]), presents the OS with some different options.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">For most pages, the OS simply uses <b>demand paging</b>, which means the OS brings the page into memory when it is accessed, “on demand” as it were. Of course, the OS could guess that a page is about to be used, and thus bring it in ahead of time; this behavior is known as <b>prefetching </b>and should only be done when there is reasonable chance of success. For example, some systems will assume that if a code page <span class="s43">P </span>is brought into memory, that code page <span class="s43">P </span><span class="s44">+1 </span>will likely soon be accessed and thus should be brought into memory too.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Another policy determines how the OS writes pages out to disk. Of course, they could simply be written out one at a time; however, many systems instead collect a number of pending writes together in memory and write them to disk in one (more efficient) write. This behavior is usually called <b>clustering </b>or simply <b>grouping </b>of writes, and is effective because of the nature of disk drives, which perform a single large write more efficiently than many small ones.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part241.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part243.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
