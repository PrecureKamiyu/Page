<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Homework (Measurement)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part62.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part64.htm">下一个 &gt;</a></p><h4 style="padding-top: 2pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">Homework (Measurement)</h4><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 75pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A<span class="s7">SIDE</span>: <b>M</b><span class="s45">EASUREMENT </span><b>H</b><span class="s45">OMEWORKS</span></p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Measurement homeworks are small exercises where you write code to run on a real machine, in order to measure some aspect of OS or hardware performance. The idea behind such homeworks is to give you a little bit of hands-on experience with a real operating system.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 6pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this homework, you’ll measure the costs of a system call and context switch. Measuring the cost of a system call is relatively easy. For example, you could repeatedly call a simple system call (e.g., performing a 0-byte read), and time how long it takes; dividing the time by the number of iterations gives you an estimate of the cost of a system call.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: left;">One thing you’ll have to take into account is the precision and accu- racy of your timer. A typical timer that you can use is <span class="s41">gettimeofday()</span>; read the man page for details. What you’ll see there is that <span class="s41">gettimeofday() </span>returns the time in microseconds since 1970; however, this does not mean that the timer is precise to the microsecond. Measure back-to-back calls</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: justify;">to <span class="s41">gettimeofday() </span>to learn something about how precise the timer re- ally is; this will tell you how many iterations of your null system-call test you’ll have to run in order to get a good measurement result. If <span class="s41">gettimeofday() </span>is not precise enough for you, you might look into using the <span class="s41">rdtsc </span>instruction available on x86 machines.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Measuring the cost of a context switch is a little trickier. The lmbench benchmark does so by running two processes on a single CPU, and set- ting up two U<span class="s7">NIX </span>pipes between them; a pipe is just one of many ways processes in a U<span class="s7">NIX </span>system can communicate with one another. The first process then issues a write to the first pipe, and waits for a read on the second; upon seeing the first process waiting for something to read from the second pipe, the OS puts the first process in the blocked state, and switches to the other process, which reads from the first pipe and then writes to the second. When the second process tries to read from the first pipe again, it blocks, and thus the back-and-forth cycle of communication continues. By measuring the cost of communicating like this repeatedly, lmbench can make a good estimate of the cost of a context switch. You can try to re-create something similar here, using pipes, or perhaps some other communication mechanism such as U<span class="s7">NIX </span>sockets.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_040.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One difficulty in measuring context-switch cost arises in systems with more than one CPU; what you need to do on such a system is ensure that your context-switching processes are located on the same processor. For- tunately, most operating systems have calls to bind a process to a partic- ular processor; on Linux, for example, the <span class="s41">sched setaffinity() </span>call is what you’re looking for. By ensuring both processes are on the same processor, you are making sure to measure the cost of the OS stopping one process and restoring another on the same CPU.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="430" height="57" alt="image" src="Image_041.png"/></span></p><p class="s50" style="text-indent: 0pt;line-height: 20pt;text-align: left;">7</p><p style="text-indent: 0pt;text-align: left;"/><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part62.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part64.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
