<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>27.6 Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part276.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part278.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">27.6 Summary</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We have introduced the basics of the pthread library, including thread creation, building mutual exclusion via locks, and signaling and waiting via condition variables. You don’t need much else to write robust and efficient multi-threaded code, except patience and a great deal of care!</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We now end the chapter with a set of tips that might be useful to you when you write multi-threaded code (see the aside on the following page for details). There are other aspects of the API that are interesting; if you want more information, type <span class="s41">man -k pthread </span>on a Linux system to see over one hundred APIs that make up the entire interface. However, the basics discussed herein should enable you to build sophisticated (and hopefully, correct and performant) multi-threaded programs. The hard part with threads is not the APIs, but rather the tricky logic of how you build concurrent programs. Read on to learn more.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="408" height="573" alt="image" src="Image_360.png"/></span></p><p style="padding-top: 2pt;padding-left: 142pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A<span class="s7">SIDE</span>: <b>T</b><span class="s45">HREAD </span><b>API G</b><span class="s45">UIDELINES</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">There are a number of small but important things to remember when you use the POSIX thread library (or really, any thread library) to build a multi-threaded program. They are:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Keep it simple. </span><span class="p">Above all else, any code to lock or signal between threads should be as simple as possible. Tricky thread interactions lead to bugs.</span></p><p class="s4" style="padding-top: 6pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Minimize thread interactions. </span><span class="p">Try to keep the number of ways in which threads interact to a minimum. Each interaction should be carefully thought out and constructed with tried and true ap- proaches (many of which we will learn about in the coming chap- ters).</span></p><p class="s4" style="padding-top: 6pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Initialize locks and condition variables. </span><span class="p">Failure to do so will lead to code that sometimes works and sometimes fails in very strange ways.</span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><b>Check your return codes. </b>Of course, in any C and U<span class="s7">NIX </span>program- ming you do, you should be checking each and every return code, and it’s true here as well. Failure to do so will lead to bizarre and hard to understand behavior, making you likely to (a) scream, (b) pull some of your hair out, or (c) both.</p><p class="s4" style="padding-top: 6pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Be careful with how you pass arguments to, and return values from, threads. </span><span class="p">In particular, any time you are passing a reference to a variable allocated on the stack, you are probably doing something wrong.</span></p><p style="padding-top: 6pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span><b>Each thread has its own stack. </b>As related to the point above, please remember that each thread has its own stack. Thus, if you have a locally-allocated variable inside of some function a thread is exe- cuting, it is essentially <i>private </i>to that thread; no other thread can (easily) access it. To share data between threads, the values must be in the <b>heap </b>or otherwise some locale that is globally accessible.</p><p class="s4" style="padding-top: 6pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Always use condition variables to signal between threads. </span><span class="p">While it is often tempting to use a simple flag, don’t do it.</span></p><p class="s4" style="padding-top: 6pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Use the manual pages. </span><span class="p">On Linux, in particular, the pthread man pages are highly informative and discuss much of the nuances pre- sented here, often in even more detail. Read them carefully!</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part276.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part278.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
