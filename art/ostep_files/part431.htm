<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>39.15 Making and Mounting a File System</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part430.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part432.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">39.15 Making and Mounting a File System</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We’ve now toured the basic interfaces to access files, directories, and certain types of special types of links. But there is one more topic we should discuss: how to assemble a full directory tree from many under- lying file systems. This task is accomplished via first making file systems, and then mounting them to make their contents accessible.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To make a file system, most file systems provide a tool, usually re- ferred to as <span class="s41">mkfs </span>(pronounced “make fs”), that performs exactly this task. The idea is as follows: give the tool, as input, a device (such as a disk partition, e.g., <span class="s41">/dev/sda1</span>) a file system type (e.g., ext3), and it simply writes an empty file system, starting with a root directory, onto that disk partition. And mkfs said, let there be a file system!</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">However, once such a file system is created, it needs to be made ac- cessible within the uniform file-system tree. This task is achieved via the <span class="s41">mount </span>program (which makes the underlying system call <span class="s41">mount() </span>to do the real work). What mount does, quite simply is take an existing direc- tory as a target <b>mount point </b>and essentially paste a new file system onto the directory tree at that point.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">An example here might be useful. Imagine we have an unmounted ext3 file system, stored in device partition <span class="s41">/dev/sda1</span>, that has the fol- lowing contents: a root directory which contains two sub-directories, <span class="s41">a </span>and <span class="s41">b</span>, each of which in turn holds a single file named <span class="s41">foo</span>. Let’s say we wish to mount this file system at the mount point <span class="s41">/home/users</span>. We would type something like this:</p><p class="s38" style="padding-top: 6pt;padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">prompt&gt; mount -t ext3 /dev/sda1 /home/users</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">If successful, the mount would thus make this new file system avail- able. However, note how the new file system is now accessed. To look at the contents of the root directory, we would use <span class="s41">ls </span>like this:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; ls /home/users/ a b</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">As you can see, the pathname <span class="s41">/home/users/ </span>now refers to the root of the newly-mounted directory. Similarly, we could access files <span class="s41">a </span>and <span class="s41">b </span>with the pathnames <span class="s41">/home/users/a </span>and <span class="s41">/home/users/b</span>. Finally, the files named <span class="s41">foo </span>could be accessed via <span class="s41">/home/users/a/foo </span>and</p><p class="s41" style="padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: justify;">/home/users/b/foo<span class="p">. And thus the beauty of mount: instead of having a number of separate file systems, mount unifies all file systems into one tree, making naming uniform and convenient.</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To see what is mounted on your system, and at which points, simply run the <span class="s41">mount </span>program. You’ll see something like this:</p><p class="s38" style="padding-top: 6pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">/dev/sda1 on / type ext3 (rw) proc on /proc type proc (rw) sysfs on /sys type sysfs (rw)</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">/dev/sda5 on /tmp type ext3 (rw)</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">/dev/sda7 on /var/vice/cache type ext3 (rw) tmpfs on /dev/shm type tmpfs (rw)</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">AFS on /afs type afs (rw)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">This crazy mix shows that a whole number of different file systems, including ext3 (a standard disk-based file system), the proc file system (a file system for accessing information about current processes), tmpfs (a file system just for temporary files), and AFS (a distributed file system) are all glued together onto this one machine’s file-system tree.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part430.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part432.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
