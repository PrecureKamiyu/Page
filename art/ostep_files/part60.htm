<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>6.4 Worried About Concurrency?</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part59.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part61.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">6.4 Worried About Concurrency?</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Some of you, as attentive and thoughtful readers, may be now think- ing: “Hmm... what happens when, during a system call, a timer interrupt occurs?” or “What happens when you’re handling one interrupt and an- other one happens? Doesn’t that get hard to handle in the kernel?” Good questions – we really have some hope for you yet!</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The answer is yes, the OS does indeed need to be concerned as to what happens if, during interrupt or trap handling, another interrupt occurs. This, in fact, is the exact topic of the entire second piece of this book, on <b>concurrency</b>; we’ll defer a detailed discussion until then.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 56pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>H<span class="s45">OW </span>L<span class="s45">ONG </span>C<span class="s45">ONTEXT </span>S<span class="s45">WITCHES </span>T<span class="s45">AKE</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">A natural question you might have is: how long does something like a context switch take? Or even a system call? For those of you that are cu- rious, there is a tool called <b>lmbench </b>[MS96] that measures exactly those things, as well as a few other performance measures that might be rele- vant.</p><p style="padding-top: 2pt;padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Results have improved quite a bit over time, roughly tracking processor performance. For example, in 1996 running Linux 1.3.37 on a 200-MHz P6 CPU, system calls took roughly 4 microseconds, and a context switch roughly 6 microseconds [MS96]. Modern systems perform almost an or- der of magnitude better, with sub-microsecond results on systems with 2- or 3-GHz processors.</p><p style="padding-top: 2pt;padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">It should be noted that not all operating-system actions track CPU per- formance. As Ousterhout observed, many OS operations are memory intensive, and memory bandwidth has not improved as dramatically as processor speed over time [O90]. Thus, depending on your workload, buying the latest and greatest processor may not speed up your OS as much as you might hope.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 4pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To whet your appetite, we’ll just sketch some basics of how the OS handles these tricky situations. One simple thing an OS might do is <b>dis- able interrupts </b>during interrupt processing; doing so ensures that when one interrupt is being handled, no other one will be delivered to the CPU. Of course, the OS has to be careful in doing so; disabling interrupts for too long could lead to lost interrupts, which is (in technical terms) bad.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Operating systems also have developed a number of sophisticated <b>locking </b>schemes to protect concurrent access to internal data structures. This enables multiple activities to be on-going within the kernel at the same time, particularly useful on multiprocessors. As we’ll see in the next piece of this book on concurrency, though, such locking can be com- plicated and lead to a variety of interesting and hard-to-find bugs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part59.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part61.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
