<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.12 Summary: So Much Spinning</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part290.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part292.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">28.12 Summary: So Much Spinning</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Our simple hardware-based locks are simple (only a few lines of code) and they work (you could even prove that if you’d like to, by writing some code), which are two excellent properties of any system or code. However, in some cases, these solutions can be quite inefficient. Imagine you are running two threads on a single processor. Now imagine that one thread (thread 0) is in a critical section and thus has a lock held, and unfortunately gets interrupted. The second thread (thread 1) now tries to acquire the lock, but finds that it is held. Thus, it begins to spin. And spin. Then it spins some more. And finally, a timer interrupt goes off, thread 0 is run again, which releases the lock, and finally (the next time it runs, say), thread 1 won’t have to spin so much and will be able to acquire the lock. Thus, any time a thread gets caught spinning in a situation like this, it wastes an entire time slice doing nothing but checking a value that isn’t going to change! The problem gets worse with <span class="s43">N </span>threads contending for a lock; <span class="s43">N </span><span class="s4">− </span><span class="s44">1 </span>time slices may be wasted in a similar manner, simply spinning and waiting for a single thread to release the lock. And thus, our next problem:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 75pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>A<span class="s7">VOID </span>S<span class="s7">PINNING</span></p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: left;">How can we develop a lock that doesn’t needlessly waste time spin- ning on the CPU?</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Hardware support alone cannot solve the problem. We’ll need OS sup- port too! Let’s now figure out just how that might work.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part290.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part292.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
