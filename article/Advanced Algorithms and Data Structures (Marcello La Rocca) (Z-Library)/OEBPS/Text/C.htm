<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>appendix C</title>
    
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <div class="tocheadb">
    <h1 class="tochead" id="heading_id_2"><a id="pgfId-998402"></a><a id="pgfId-998517"></a>appendix C. Core data structures</h1>
  </div>

  <p class="body"><a id="pgfId-998530"></a>You can’t <a id="marker-1001525"></a><a id="marker-1001529"></a>build a house from the roof down. Likewise, you can’t build knowledge of advanced data structures if you don’t master the basics first.</p>

  <p class="body"><a id="pgfId-998548"></a>In this appendix, we provide an overview of core data structures and present some of the most widely used algorithms.</p>

  <p class="body"><a id="pgfId-998563"></a>It starts with a refresher of the most basic data structures: <i class="calibre17">arrays</i><a id="marker-1001533"></a>, <i class="calibre17">linked lists</i><a id="marker-1001537"></a>, <i class="calibre17">trees</i><a id="marker-1001541"></a>, and <i class="calibre17">hash tables</i><a id="marker-1001545"></a>. We do expect readers to already be familiar with them; after all, these structures are the building blocks of the most advanced ones. But we’ll provide a quick overview, just for your convenience.</p>

  <p class="body"><a id="pgfId-998593"></a>In the last section, we briefly compare these data structures. For each of them, we will look at key features (like if they support ordering, and if they are <i class="calibre17">static</i><a id="marker-1001549"></a> or <i class="calibre17">dynamic</i><a id="marker-1001553"></a>) and sum them up in a table. This will help us decide, for each problem we might run into, which one of them would be more appropriate to support us in solving the problem.</p>

  <h2 class="fm-head" id="heading_id_3"><a id="pgfId-998640"></a>C.1 Core data structures</h2>

  <p class="body"><a id="pgfId-998657"></a>Data structures (<i class="calibre17">DSs</i><a id="marker-1001557"></a>) are one of the foundations of programming and have been progressively introduced since the very dawn of computer science.</p>

  <p class="body"><a id="pgfId-998669"></a>In this section, we are going to explore the most basic ways to organize data items in memory so that those items can later be retrieved according to specific criteria. The nature of those criteria, together with the way storage is used and the performance of the basic operations (adding, removing, and searching elements) are what determine the characteristics of a data structure.</p>

  <p class="body"><a id="pgfId-998678"></a>These core DSs are the building blocks for the implementations of countless advanced DSs.</p>

  <h2 class="fm-head" id="heading_id_4"><a id="pgfId-998687"></a>C.2 Array</h2>

  <p class="body"><a id="pgfId-998699"></a>This <a id="marker-1001561"></a><a id="marker-1001565"></a><a id="marker-1001569"></a>is one of the simplest and yet most used data structures. It’s provided natively by most programming languages: an <i class="calibre17">array</i><a id="marker-1001573"></a> is a collection of homogeneous data. At a low level it is, roughly, a chunk of memory where elements are stored contiguously. Many programming languages only provide <i class="calibre17">static arrays</i><a id="marker-1001577"></a>. Their sizes can’t change and the number of elements they store needs to be decided when they are created (or at least at initialization). <i class="calibre17">Dynamic arrays</i><a id="marker-1001581"></a>, however, can grow when new elements are added and shrink when elements are removed. Figure C.1 provides an example of how this works. It’s not too hard to find dynamic arrays in mainstream languages: <i class="calibre17">JavaScript</i> arrays are intrinsically dynamic.</p>

  <p class="fm-callout"><a id="pgfId-998742"></a><span class="fm-callout-head">Note</span> It can be proven that it’s possible to implement dynamic arrays in such a way that, on aggregate,<a href="#pgfId-1002604"><sup class="footnotenumber1">1</sup></a> insertion and removal are as fast as for static arrays.</p>

  <p class="fm-callout"><a id="pgfId-1009673"></a> </p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F1.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1009681"></a>Figure C.1 An example of insertion into static (top) and dynamic arrays (bottom). Notice how the size of the static array in the upper half is constant (it always has three elements), while the dynamic array in the other half starts with size 2, its size is only increased (doubled, actually) when an element is added to a full array. In this example, the static array could not have any other element inserted unless we override another one.</p>

  <p class="body"><a id="pgfId-998785"></a>Elements in arrays must all have the same type and require the same space to be stored.<a href="#pgfId-1002619"><sup class="footnotenumber">2</sup></a> When this specification is met, it makes it easier to move from one element to the next one by just adding to the former’s memory address the size of array’s elements.</p>

  <p class="fm-callout"><a id="pgfId-998806"></a><span class="fm-callout-head">Note</span> Because they are allocated in a single block of memory, arrays are more likely to show the so-called locality of reference. When traversing an array, for example, data in the same page of memory is likely to be accessed in a short window of time. This can lead to several optimizations (see the original article<a href="#pgfId-1002633"><sup class="footnotenumber1">3</sup></a> about the principle of locality).</p>

  <p class="body"><a id="pgfId-998830"></a>The key advantage of arrays is that they have constant time access for all elements. It would be more accurate to say that every position in an array can be accessed in constant time. It’s possible to retrieve or store the first element, or the last, or any intermediate element as long as its position is known. See figure C.2 as a reference.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F2.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1009723"></a>Figure C.2 Retrieving the third element of an array. If the array is stored in a variable named <code class="fm-code-in-text">A</code>, then <code class="fm-code-in-text">A[2]</code> refers to the third element of the array. This is because on computers, both memory addresses and the indices of array elements start from 0.</p>

  <p class="body"><a id="pgfId-998878"></a>While random access is one of the strengths of arrays, other operations are slower for them. As mentioned, you can’t resize an array by just adding or removing an element at its tail. Every time such an operation is needed, you have to reallocate the array, unless you are using a dynamic array. In that case, you have to initially allocate a larger chunk of memory, keep track of the number of elements, and amortize the overhead for resizing on a larger number of operations.</p>

  <p class="body"><a id="pgfId-998897"></a>As we’ll see in the next section, lists can be optimal for insertions and deletions while they are slower for random <a id="marker-1001585"></a><a id="marker-1001589"></a><a id="marker-1001593"></a>access.</p>

  <h2 class="fm-head" id="heading_id_5"><a id="pgfId-998912"></a>C.3 Linked List</h2>

  <p class="body"><a id="pgfId-998924"></a>A <a id="marker-1001597"></a><a id="marker-1001601"></a><a id="marker-1001605"></a><i class="calibre17">linked list</i> stores a sequence of items by wrapping each item in an object, called a node.</p>

  <p class="body"><a id="pgfId-998940"></a>As shown in figure C.3, each node holds a value and either one or two links (references) to other nodes.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F3.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1009768"></a>Figure C.3 The graphic represen-tation of a linked list. Here each element holds a pointer (aka reference or link) to the next node in the list. The reference to the first node is held by a special pointer, the head of the list. To go through the whole list, we need to follow the head pointer, and then traverse the list node by node.</p>

  <p class="body"><a id="pgfId-998973"></a>A value can be a simple type, like a number, or a complex type, such as a string or an object. The order of the elements is determined exclusively by the list’s links. Nodes don’t need to be allocated contiguously and therefore lists are dynamic by nature. So, they can grow or shrink as needed.</p>

  <p class="body"><a id="pgfId-998989"></a>More formally, a list can be defined recursively (see figure C.4). It can be either</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999004"></a>An empty list</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999016"></a>A node containing a value and a reference to a linked list</p>

      <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F4.png"/></p>

      <p class="fm-figure-caption"><a id="pgfId-1009826"></a>Figure C.4 Inductive definition of a list. The middle column uses a formal notation for the list, while the right column shows the graphical representation of the same list. In the formal representation, the recursive nature is more explicit, because it is indeed a recursive notation. The empty list is assumed as a primitive, a building block, and each non-empty list is recursively defined as its first element followed by its tail, a shorter, possibly empty list of the remaining elements.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999053"></a>Figure C.5 exemplifies another key feature of lists that can be either</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999064"></a><i class="calibre15">Singly linked</i><a class="calibre14" id="marker-1001609"></a>—Every node has only a link (aka pointer or reference) to the next element.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999079"></a><i class="calibre15">Doubly linked</i><a class="calibre14" id="marker-1001613"></a>—Two links per node are stored: a link to the next element and one to the previous element.</p>

      <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F5.png"/></p>

      <p class="fm-figure-caption"><a id="pgfId-1009880"></a>Figure C.5 Singly linked (left) versus doubly linked lists (right).</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999120"></a>As mentioned before, the choice between singly and doubly linked is a trade-off. The former requires less space per node, and the latter allows for faster algorithms to delete an element, but needs a small overhead to keep the pointers updated.</p>

  <p class="body"><a id="pgfId-999135"></a>In order to keep track of a linked list, the head of the list must be stored in a variable. When adding or removing elements from the list, we need to take extra care to update that reference to the head of the list as well: if we don’t perform the update, it might end up pointing to an internal node, or even worse, to an invalid location.</p>

  <p class="body"><a id="pgfId-999151"></a>Insertion in lists can happen</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999160"></a><i class="calibre15">At the beginning</i>—That’s the easiest place to add a node in constant time. Figure C.6 shows, in fact, that we only need to update the head reference with a new node and update the links for this new node and the old head (unless the list was empty).</p>

      <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F6.png"/></p>

      <p class="fm-figure-caption"><a id="pgfId-1009926"></a>Figure C.6 Insertion at the beginning of a linked list. (A) The original list. (B) Create a new node, whose next pointer is set to the previous head. (C) Correct the head pointer. (D) Final result.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999196"></a><i class="calibre15">At the end</i>—This is not a very practical solution, because we would need to traverse the whole list to find the last node; check figure C.7 to see why. We could think about keeping an extra pointer for the tail of the list, but this would cause an overhead because every method that changes the list would need to check if that reference needs to be updated.</p>

      <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F7.png"/></p>

      <p class="fm-figure-caption"><a id="pgfId-1009972"></a>Figure C.7 Insertion at the end of a linked list. (A) The original list. (B) Walk the linked list until the last element: let’s call it <code class="fm-code-in-text">P</code>. (C) Create a new node and update the next pointer for <code class="fm-code-in-text">P</code>. (D) Final result.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999247"></a><i class="calibre15">In any other position</i>—This is useful when keeping the list ordered. However, it’s also expensive, requiring linear time in the worst case, as shown in figure C.8.</p>

      <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F8.png"/></p>

      <p class="fm-figure-caption"><a id="pgfId-1010044"></a>Figure C.8 Insertion in a linked list in any position. In this example, we show insertion on a sorted linked list (but sorting is not a requirement). (A) The original list. (B) Walk the linked list until we find the predecessor of the position where we want to insert the new element (being a singly linked list, we need to maintain a pointer to the predecessor during this search). Let’s denote this predecessor with <code class="fm-code-in-text">P</code>. (C) Create a new node <code class="fm-code-in-text">N</code>, and update the next pointer for <code class="fm-code-in-text">P</code>. At the same time, set <code class="fm-code-in-text">N.next</code> to <code class="fm-code-in-text">P.next</code>. (D) Final result.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999302"></a>Similarly, we can double down on the same reasoning for node removal:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999311"></a><i class="calibre15">From the beginning</i>—It can be done in constant time by updating the head reference to the old head’s successor (after checking that the list isn’t empty). And we should make sure that the removed node is deallocated or made available for garbage collection.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999329"></a><i class="calibre15">From the end</i>—We need to find the second-to-last node and update its pointer to the next node. For a doubly linked list, we just get to the end of the list and then take its predecessor. For singly linked lists, we need to keep a reference both to the current node and to its predecessor while we traverse the list. This is a linear-time operation.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999351"></a><i class="calibre15">From any other position</i>—Same considerations as for insertions, plus the concern about keeping a reference to the second-to-last element in the list.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999369"></a>Linked lists are recursive data structures. This stems out of their recursive definition, and it means that problems on lists can be reasoned about by induction. You can try to provide a solution for the base case (the empty list) as well as a way to combine some actions on the head of the list with solutions for its tail (which is a smaller list). For instance, if you have to develop an algorithm to search the max of a list of numbers, you <a id="marker-1008363"></a><a id="marker-1008364"></a><a id="marker-1008365"></a>can do the following:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999382"></a>If the list is empty, return <code class="fm-code-in-text">null</code>.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999396"></a>If the list has at least one element, take the list’s head (call it <code class="fm-code-in-text">x</code>) and apply the algorithm to the list with the remaining <code class="fm-code-in-text">N - 1</code> elements obtaining a value <code class="fm-code-in-text">y</code>. Then the result is</p>

      <ul class="calibre20">
        <li class="fm-list-bullet1">
          <p class="list"><a class="calibre14" id="pgfId-999416"></a><code class="fm-code-in-text">x</code> if <code class="fm-code-in-text">y</code> is <code class="fm-code-in-text">null</code> or <code class="fm-code-in-text">x &gt;= y</code></p>
        </li>

        <li class="fm-list-bullet1">
          <p class="list"><a class="calibre14" id="pgfId-999435"></a><code class="fm-code-in-text">y</code> otherwise.</p>
        </li>
      </ul>
    </li>
  </ul>

  <h2 class="fm-head" id="heading_id_6"><a id="pgfId-999449"></a>C.4 Tree</h2>

  <p class="body"><a id="pgfId-999461"></a><i class="calibre17">Trees</i><a id="marker-1001629"></a> <a id="marker-1001633"></a><a id="marker-1001637"></a>are another widely used abstract data type that provides a hierarchical structure, like lists, but in a branched shape. They can indeed be seen as a generalization of <i class="calibre17">linked lists</i><a id="marker-1001641"></a>: each node has still a single predecessor, called its <i class="calibre17">parent</i><a id="marker-1001645"></a>, but can have more than a single successor, here denoted as its <i class="calibre17">children</i><a id="marker-1001649"></a>. Each tree node’s <i class="calibre17">child</i><a id="marker-1001653"></a> is itself a subtree (either empty or including a root and its subtrees).</p>

  <p class="body"><a id="pgfId-999494"></a>A generic tree is illustrated in figure C.9, but a tree can also be formally defined as either</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999509"></a>An empty tree.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999521"></a>A node with one or more references to its children, and (optionally) a reference to its parent</p>

      <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F9.png"/></p>

      <p class="fm-figure-caption"><a id="pgfId-1010090"></a>Figure C.9 An example of a tree. The top-to-bottom arrows represent the links between a node and its children; these arrows are always directed from parent to children. Every node has one and only one parent. Nodes that share the same parent are called siblings<a id="marker-1010091"></a>. There is no explicit link between siblings, but a node’s siblings can only be reached through their common parent. Nodes with no children are called leaves<a id="marker-1010092"></a>.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999567"></a>Each tree node, like <i class="calibre17">list</i>’s nodes<a id="marker-1001665"></a>, contains a value. Moreover, a node holds a list of references to other nodes, its children<a id="marker-1001669"></a>. There is a constraint: in a tree, each node is the child of just a single other node, except for the root, which has no <i class="calibre17">parent</i><a id="marker-1001673"></a> (so no node in a <i class="calibre17">tree</i><a id="marker-1001677"></a> points to its <i class="calibre17">root</i><a id="marker-1001681"></a>). Therefore, we’ll need to keep a reference (using a variable) to the root of the tree. This is the same as a singly linked list where the head of the list is not linked by other nodes. Moreover, trees define a “vertical” hierarchy, a parent-children relation, while there can be no relation between sibling nodes or between nodes in different subtrees.</p>

  <p class="body"><a id="pgfId-999600"></a>Before moving on, let’s review the terminology used when dealing with trees:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999611"></a>If a node <code class="fm-code-in-text">x</code> has two children <code class="fm-code-in-text">y</code> and <code class="fm-code-in-text">z</code>, <code class="fm-code-in-text">x</code> is the parent of these nodes. So, the following is true: <code class="fm-code-in-text">parent(y) == parent(z) == x</code>. In figure C.9, the node labeled <code class="fm-code-in-text">1</code> is the parent of the nodes labeled <code class="fm-code-in-text">4</code>, <code class="fm-code-in-text">5</code>, and <code class="fm-code-in-text">2</code>.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999643"></a>Being <code class="fm-code-in-text">x</code>, <code class="fm-code-in-text">y,</code> and <code class="fm-code-in-text">z</code> as defined here, <code class="fm-code-in-text">y</code> and <code class="fm-code-in-text">z</code> are called <i class="calibre15">siblings</i><a class="calibre14" id="marker-1001685"></a>.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999673"></a>The <i class="calibre15">root</i><a class="calibre14" id="marker-1001689"></a> of a tree is the one and only node in a tree that has no parent.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999690"></a>An <i class="calibre15">ancestor</i><a class="calibre14" id="marker-1001693"></a> of a node <code class="fm-code-in-text">x</code> is any node in the path from the tree’s root to <code class="fm-code-in-text">x</code>. In other words, either <code class="fm-code-in-text">parent(x)</code>, <code class="fm-code-in-text">parent(parent(x)),</code> and so on. In figure C.9, <code class="fm-code-in-text">2</code> is an ancestor of <code class="fm-code-in-text">7</code>, <code class="fm-code-in-text">3</code>, <code class="fm-code-in-text">0,</code> and <code class="fm-code-in-text">9</code>.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999731"></a>A <i class="calibre15">leaf</i><a class="calibre14" id="marker-1001697"></a> is any node that has no children. Another way to express this is that for a leaf, all the node’s children are empty subtrees.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999754"></a>A fundamental characteristic of a tree is its <i class="calibre15">height</i><a class="calibre14" id="marker-1001701"></a>, defined as the length of the longest path from the root to a leaf. The height of the tree in figure C.9 is <code class="fm-code-in-text">3</code> because the longest path is <code class="fm-code-in-text">1-&gt;2-&gt;3-&gt;0</code> (or equivalently <code class="fm-code-in-text">1-&gt;2-&gt;3-&gt;9</code>), and it traverses three parent-child links.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999780"></a>In the next section, we will focus on introducing binary search trees.</p>

  <h3 class="fm-head2" id="heading_id_7"><a id="pgfId-999789"></a>C.4.1 Binary search trees</h3>

  <p class="body"><a id="pgfId-999805"></a>A <a id="marker-1001705"></a><a id="marker-1001709"></a><i class="calibre17">binary tree</i><a id="marker-1001713"></a> is a tree where the number of children for any node is <i class="calibre17">at most</i> 2, meaning that each node can have either 0, 1, or 2 children.</p>

  <p class="body"><a id="pgfId-999824"></a>A <i class="calibre17">binary search tree</i><a id="marker-1001717"></a> (<i class="calibre17">BST</i>) is a binary tree where each node has a key associated with it, and satisfies two conditions: if <code class="fm-code-in-text">key(x)</code> is the key associated with a node <code class="fm-code-in-text">x</code>, then</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999846"></a><code class="fm-code-in-text">key(x) &gt; key(y)</code> for every node <code class="fm-code-in-text">y</code> in the left subtree of <code class="fm-code-in-text">x</code>.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999863"></a><code class="fm-code-in-text">key(x) &lt; key(z)</code> for every node <code class="fm-code-in-text">z</code> in the right subtree of <code class="fm-code-in-text">x</code>.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999880"></a>A node’s key can also be its value, but in general, BST’s nodes can store a key and a value, or any additional data, independently.</p>

  <p class="body"><a id="pgfId-999897"></a>Let’s continue with a few more definitions:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999908"></a>A <i class="calibre15">balanced tree</i><a class="calibre14" id="marker-1001721"></a> is a tree where for each node, the height of its left and right subtrees differs at most by 1, <i class="calibre15">and</i> both its left and right subtrees are balanced.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999925"></a>A tree is a <i class="calibre15">complete tree</i><a class="calibre14" id="marker-1001725"></a> if it has height <code class="fm-code-in-text">H</code> and every leaf node is either at level <code class="fm-code-in-text">H</code> or <code class="fm-code-in-text">H-1</code>.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-999946"></a>A <i class="calibre15">perfectly balanced tree</i><a class="calibre14" id="marker-1001729"></a> is a <i class="calibre15">balanced tree</i> in which, for each internal node, the heights of its left and right subtrees are the same.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999965"></a>A <i class="calibre15">perfectly balanced</i> tree is also <i class="calibre15">complete</i><a class="calibre14" id="marker-1001733"></a><i class="calibre15">.</i></p>
    </li>
  </ul>

  <p class="fm-callout"><a id="pgfId-999983"></a><span class="fm-callout-head">Definitions</span> There are two definitions for tree balancedness<a id="marker-1001737"></a>: height-balancedness<a id="marker-1001741"></a>, which is the one used in the definitions provided, and weight-balancedness<a id="marker-1001745"></a>. They are independent characteristics of a tree, as neither of them implies the other. Both could lead to similar results, but the former is normally used, and we’ll just refer to it in the rest of this book when we talk about balanced trees.</p>

  <p class="body"><a id="pgfId-1000010"></a>Binary search trees are recursive structures. Each BST, in fact, can be either</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1000021"></a>An empty tree</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1000033"></a>A node with a key and a left and right subtree</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1000045"></a>This recursive nature allows for intuitive recursive algorithms for all the basic operations on BSTs.</p>

  <p class="body"><a id="pgfId-1000056"></a>Binary search trees offer a compromise between the flexibility and performance of insertions in a linked list and the efficiency of search in an ordered array. All the basic operations (<code class="fm-code-in-text">insert</code><a id="marker-1008660"></a>, <code class="fm-code-in-text">delete</code><a id="marker-1008661"></a>, <code class="fm-code-in-text">search</code><a id="marker-1008662"></a>, <code class="fm-code-in-text">minimum</code><a id="marker-1008663"></a> and <code class="fm-code-in-text">maximum</code><a id="marker-1008664"></a>, <code class="fm-code-in-text">successor</code><a id="marker-1008665"></a> and <code class="fm-code-in-text">predecessor</code><a id="marker-1008666"></a>) require examining a number of nodes proportional to the height of the tree.</p>

  <p class="body"><a id="pgfId-1000086"></a>Therefore, the shorter we manage to keep the height of a tree, the better performance on those operations will be.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title"><a class="calibre14" id="pgfId-1010132"></a>What’s the smallest possible height of a tree?</p>

    <p class="fm-sidebar-text"><a id="pgfId-1010133"></a>For a binary tree with <code class="fm-code-in-text2">n</code> nodes, <code class="fm-code-in-text2">log(n)</code> is the shortest possible height.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1010134"></a>Let’s consider a binary tree. There can be only one root, obviously. It can have at most 2 children, so there can be at most 2 nodes with height 1. Each of them can have 2 children, so there can be at most 4=2<sup class="superscript2">2</sup> nodes with height 2. How many nodes with height 3 can a BST have? As you probably guessed, it’s 2<code class="fm-code-in-text2"><sup class="footnotenumber2">3</sup></code>=8. Going down the tree, at each level, we increase the height by one and double the number of nodes that the current level can hold.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1010135"></a>So, at height <code class="fm-code-in-text2">h</code>, we have <code class="fm-code-in-text2">2<sup class="superscript">h</sup></code> nodes. But we also know that the total number of nodes for a complete tree with height <code class="fm-code-in-text2">h</code> is <code class="fm-code-in-text2">2<sup class="superscript">0</sup> + 2<sup class="superscript">1</sup>+ 2<sup class="superscript">2</sup> + 2<sup class="superscript">3</sup> +... + 2<sup class="superscript">h</sup> = 2<sup class="superscript">h+1</sup> – 1</code>.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1010136"></a>To keep the height as small as possible, it is easy to see that we need to fill all the levels (except, possibly, the last one), because otherwise we could just move the nodes in the last level up the tree until we have no vacancies in the upper levels.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1010137"></a>Therefore, if we have <code class="fm-code-in-text2">n</code> nodes, <code class="fm-code-in-text2">2<sup class="superscript">h+1</sup> – 1</code> <span class="cambria">≤</span> <code class="fm-code-in-text2">n</code>, and taking the log of both sides, <code class="fm-code-in-text2">h</code> <span class="cambria">≥</span> <code class="fm-code-in-text2">log(n+1) – 1.</code></p>
  </div>

  <p class="body"><a id="pgfId-1000223"></a>BSTs are not balanced by nature: on the contrary, for the same set of elements, their shape and height can vary greatly depending on the sequence of insertions for those elements (see figure C.10).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F10.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1010166"></a>Figure C.10 All possible layouts for BSTs of size 3. The layout depends on the order in which elements are inserted. Notice how two sequences produce identical layouts for the insertion sequences <code class="fm-code-in-text">[2, 1, 3]</code> and <code class="fm-code-in-text">[2, 3, 1]</code>.</p>

  <p class="body"><a id="pgfId-1000263"></a>On average, after a high number of insertions, the probability of having a skewed tree is pretty low. It is worth mentioning, however, that the simplest algorithm for deleting a node tends to produce skewed trees. Many workarounds have been proposed for this problem but, as of today, there is no proof that they always produce a better result than the naïve version.</p>

  <p class="body"><a id="pgfId-1000274"></a>The silver lining is that there are several solutions that allows us to keep BST<a id="marker-1001777"></a>s balanced without degrading performance for insert or delete. <a id="marker-1001781"></a><a id="marker-1001785"></a>For <a id="marker-1001789"></a><a id="marker-1001793"></a>instance</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1000293"></a><a class="calibre14" id="id_Hlk56856355"></a>2-3 search trees<a class="calibre14" id="marker-1001797"></a></p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1000307"></a>red-black trees<a class="calibre14" id="marker-1001801"></a></p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1000321"></a>B-trees<a class="calibre14" id="marker-1001805"></a></p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1000335"></a>AVL trees<a class="calibre14" id="marker-1001809"></a></p>
    </li>
  </ul>

  <h2 class="fm-head" id="heading_id_8"><a id="pgfId-1000349"></a>C.5 Hash table</h2>

  <p class="body"><a id="pgfId-1000363"></a><i class="calibre17">Hashing</i><a id="marker-1001813"></a> <a id="marker-1001817"></a><a id="marker-1001821"></a><a id="marker-1001825"></a>is probably the most common way to represent symbol tables. If we need to associate each one of a set of <i class="calibre17">keys</i> to a <i class="calibre17">value</i>, then we are going to face a few problems.</p>

  <h3 class="fm-head2" id="heading_id_9"><a id="pgfId-1000386"></a>C.5.1 Storing key-value pairs</h3>

  <p class="body"><a id="pgfId-1000398"></a>We <a id="marker-1001829"></a><a id="marker-1001833"></a>assume keys and values can be picked from different domains. Then, we need to decide if duplicate keys are allowed. For the sake of simplicity, we will consider only sets of unique keys: it is always possible to make a static group of keys unique.</p>

  <p class="body"><a id="pgfId-1000410"></a>The easiest case is when keys are non-negative integers. In theory, you can use an array to store the value associated with key <code class="fm-code-in-text">k</code> in the <code class="fm-code-in-text">k</code>-th element of the array. This, however, is only possible when the possible keys are limited in range. If, for example, any 32-bit positive integer was allowed, we would need an array with more than 3 billion elements—possibly larger than even the most modern machine’s RAM. It gets even worse if for the possible values we consider “longs,” aka 8-byte integers. We’d be talking about 18 billion of billions of elements. No, it’s not a typo: we are talking about billions of billions.</p>

  <p class="body"><a id="pgfId-1000459"></a>The worst part is that by using arrays, even if we know that we’ll store only a few thousands integer keys at a time, we’ll still need an array with 2<code class="fm-code-in-text"><sup class="footnotenumber4">32</sup></code> elements if any integer value is allowed for a key.</p>

  <p class="body"><a id="pgfId-1008826"></a>While there is little we can do to improve when we do have to store many elements, when we know that we might store only a handful of elements (say, a few hundreds or thousands), it’s a whole different story. Even if we can still choose these elements from a large set (for example all the integers that can be represented with 32 bits, for a total of around 4 billion elements), but we’ll only store a handful of them at the same time, then we can do better.</p>

  <p class="body"><a id="pgfId-1000504"></a>And that’s precisely where <i class="calibre17">hashing</i><a id="marker-1001837"></a> comes to the <a id="marker-1001841"></a><a id="marker-1001845"></a>rescue.</p>

  <h3 class="fm-head2" id="heading_id_10"><a id="pgfId-1000523"></a>C.5.2 Hashing</h3>

  <p class="body"><a id="pgfId-1000535"></a>Hashing<a id="marker-1001849"></a> <a id="marker-1001853"></a><a id="marker-1001857"></a>provides a compromise between key-indexed arrays and unsorted arrays in conjunction with sequential search. The former solution offers constant time search, but needs space proportional to the set of possible keys. The latter requires linear time for search, but space proportional to the number of actual keys.</p>

  <p class="body"><a id="pgfId-1000549"></a>Using hash tables, we fix the size of the array to, say, <code class="fm-code-in-text">M</code> elements. As we’ll see, we might store more than <code class="fm-code-in-text">M</code> elements, though, depending on how we solve <i class="calibre17">collisions</i><a id="marker-1001861"></a>. Then, we transform each key into an index between <code class="fm-code-in-text">0</code> and <code class="fm-code-in-text">M - 1</code>, using a hash function<a id="marker-1001865"></a>.</p>

  <p class="body"><a id="pgfId-1000576"></a>It’s worth noting that introducing such a transformation relaxes the constraint about having only non-negative integers as keys. We can “serialize” any object into a string and transform any string into an integer modulo <code class="fm-code-in-text">M</code> as part of hashing. In the rest of the discussion, we’ll assume keys are integers for the sake of brevity.</p>

  <p class="body"><a id="pgfId-1000603"></a>The exact hash function we need to use depends on the type of the keys, and it’s correlated to the size of the array. The most notable examples include</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1000614"></a><i class="calibre15">The division method</i><a class="calibre14" id="marker-1001869"></a>—Given an integer key k, we define its hash <code class="fm-code-in-text">h(k)</code> as</p>

      <p class="fm-equation"><i class="calibre17">h</i>(<i class="calibre17">k</i>) = <i class="calibre17">k%M</i></p>

      <p class="body"><a id="pgfId-1000645"></a>where % represents the modulo operator.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1000656"></a>For this method, <code class="fm-code-in-text">M</code>, the size of the table, should be a prime number that is not too close to a power of 2.</p>

  <p class="body"><a id="pgfId-1000668"></a>For instance, if <code class="fm-code-in-text">M=13</code>, we would have <code class="fm-code-in-text">h(0)=0, h(1)=1, h(2)=2,... h(13)=0, h(14)=1</code> and so on.</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1000682"></a><i class="calibre15">The multiplication metho</i>d<a class="calibre14" id="marker-1001873"></a>:</p>

      <p class="fm-equation"><i class="calibre17">h</i>(<i class="calibre17">k</i>) = <span class="cambria">⎣ </span><i class="calibre17">M</i> <span class="cambria">⋅</span> (<i class="calibre17">k</i> <span class="cambria">⋅</span> <i class="calibre17">A</i>%1) <span class="cambria">⎦</span></p>

      <p class="body"><a id="pgfId-1000703"></a>where <code class="fm-code-in-text">0 &lt; A &lt; 1</code> is a <i class="calibre17">real</i> constant, and <code class="fm-code-in-text">(k*A % 1)</code> is the fractional part of <code class="fm-code-in-text">k*A</code>. In this case, <code class="fm-code-in-text">M</code> is usually chosen as a power of 2, but <code class="fm-code-in-text">A</code> has to be chosen carefully, depending on <code class="fm-code-in-text">M</code>.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1000728"></a>For instance, say <code class="fm-code-in-text">M=16</code> and <code class="fm-code-in-text">A=0.25</code>; then</p>
  <pre class="programlisting">k = 0 =&gt; h(k) = 0
<code class="fm-code-in-text2">k = 1 =&gt; k * A = 0.25, k*A%1 = 0.25, h(k) = 4</code>
<code class="fm-code-in-text2">k = 2 =&gt; k * A = 0.5, k*A%1 = 0.5, h(k) = 8</code>
<code class="fm-code-in-text2">k = 3 =&gt; k * A = 0.75, k*A%1 = 0.75, h(k) = 12</code>
<code class="fm-code-in-text2">k = 4 =&gt; k * A = 1, k*A%1 = 0, h(k) = 0</code>
<code class="fm-code-in-text2">k = 5 =&gt; k * A = 1.25, k*A%1 = 0.25, h(k) = 4</code>
... </pre>

  <p class="body"><a id="pgfId-1000801"></a>and so on.</p>

  <p class="body"><a id="pgfId-1000811"></a>As you can see, 0.25 was not a great choice for <code class="fm-code-in-text">A</code>, because <code class="fm-code-in-text">h(k)</code> will only assume five different values. To this extent, however, it was a great choice to illustrate both the method itself and why you need to be careful choosing its parameters.</p>

  <p class="body"><a id="pgfId-1000828"></a>There are also more advanced methods to improve the quality of the hash function so that it gets closer and closer to uniform <a id="marker-1001877"></a><a id="marker-1001881"></a>distribution.</p>

  <h3 class="fm-head2" id="heading_id_11"><a id="pgfId-1000840"></a>C.5.3 Conflicts resolution in hashing</h3>

  <p class="body"><a id="pgfId-1000856"></a>No <a id="marker-1001885"></a><a id="marker-1001889"></a>matter how good or how uniform a hash function we can create, the number of keys, <code class="fm-code-in-text">m</code>, can grow until it becomes larger than the size of the table, <code class="fm-code-in-text">n</code>. At that point, the pigeonhole principle<a id="marker-1001893"></a> kicks in to rain on our parade.</p>

  <p class="fm-callout"><a id="pgfId-1000884"></a><span class="fm-callout-head">Definition</span> The pigeonhole principle<a id="marker-1001897"></a> states that if the number of possible key values to store is larger than the available slots, at some point, we are bound to have two different keys mapped to the same slot. What happens if we try to add both keys to the table? In that case, we have a conflict. We therefore need a way to be able to resolve the conflict and make sure that it is possible to distinguish between the two different keys and find both of them in a search.</p>

  <p class="body"><a id="pgfId-1000910"></a>There are two main ways to solve conflicts due to different keys mapping to the same slot:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1000919"></a><i class="calibre15">Chaining</i><a class="calibre14" id="marker-1001901"></a>—Each element in the array stores a link to another data structure, holding all the keys mapped to that element (see figure C.11). The secondary data structure can be a linked list (usually), a tree, or even another hash table (as in <i class="calibre15">perfect hashing</i><a class="calibre14" id="marker-1001905"></a>, a technique that allows the best possible hashing performance on a <i class="calibre15">static</i> set of keys, known in advance). In this case, there is no limit to the number of elements that can be stored in the hash table, but performance degrades as we add more and more elements, because at least some lists get longer and longer and require more steps to be traversed in order to find an element.</p>
    </li>
  </ul>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F11.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1010212"></a>Figure C.11 Example of a hash table using chaining and a linked list for conflict resolution</p>

  <ul class="calibre19">
    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1000967"></a><i class="calibre15">Open addressing</i><a class="calibre14" id="marker-1001909"></a>—We store elements directly in the array, and on conflicts we generate (deterministically) another hash value for the next position to try. Figure C.12 shows an example of a hash table using open addressing for conflict resolution.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1000986"></a>Hash functions for open addressing look like</p>

      <p class="fm-equation"><i class="calibre17">h</i>(<i class="calibre17">k, i</i>) = (<i class="calibre17">h'</i>(<i class="calibre17">k</i>) + <i class="calibre17">f</i> (<i class="calibre17">i, k</i>))%<i class="calibre17">M</i></p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1001008"></a>where <code class="fm-code-in-text">i</code> counts the number of positions already examined, and <code class="fm-code-in-text">f</code><a id="marker-1001913"></a> is a function of the number of attempts, and possibly of the key as well. Open addressing allows us to save memory, because there are no secondary data structures, but has some problems that make it rarely the best choice. First and foremost, deleting elements becomes too complicated, and because the size of the hash table is limited and decided on creation, this means that these tables will fill up quickly and need to be reallocated. Even worse, elements tend to group in clusters and, when the table gets populated, many attempts are needed to find a free slot—basically there is a high probability that a linear number of attempts will already be needed when the table is nearly <a id="marker-1001917"></a><a id="marker-1001921"></a>half-full.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/appC_F12.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1010282"></a>Figure C.12 A hash table using open addressing for conflict resolution. The assignment of the elements depends on the order of insertion. Assume that <code class="fm-code-in-text">f(i) = i</code> and that we have the same collisions as in figure C.11. (A) We can infer that 9 must have been inserted before 2 (otherwise, since we assume 9 and 2 would be mapped in the same spot, as in figure C.11, 2 would be stored in <code class="fm-code-in-text">A<sub class="subscript1">3</sub></code>). Also, 4 must have been added before 2, because when the algorithm finds out that <code class="fm-code-in-text">A<sub class="subscript1">3</sub></code> is not empty, <code class="fm-code-in-text">A<sub class="subscript1">4</sub></code> would be tried next (because <code class="fm-code-in-text">f(i) = i</code>, we do a linear scan of the positions following a collision). (B) We try to add 7, assuming <code class="fm-code-in-text">h(7) = 3</code>. Because of open addressing and the definition of function <code class="fm-code-in-text">f</code><a id="marker-1010283"></a>, we try the elements in positions 3, 4, and 5, which are all already used. Then we finally try <code class="fm-code-in-text">A<sub class="subscript1">6</sub></code>, which is free, and we add the new key there.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title"><a class="calibre14" id="pgfId-1010256"></a>Issues with scaling hash tables</p>

    <p class="fm-sidebar-text"><a id="pgfId-1010257"></a>Even with chaining hashing, the number of slots in the table is usually static, as changing the size of the table would change the hash function and therefore the target slot for potentially all elements already stored. This, in turn, would force us to delete every single element from the old table and then insert it into the new one. It’s worth noting that this kind of situation often arises with distributed caches (such as Cassandra or Memcached) when a new node needs to be added, and—unless proper workarounds have been put in place in a website’s architecture—this can cause bottlenecks or even crash a whole site.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1010259"></a>In chapter 7, we describe consistent hashing<a id="marker-1010258"></a>, a way to mitigate this problem.</p>
  </div>

  <h3 class="fm-head2" id="heading_id_12"><a id="pgfId-1001182"></a>C.5.4 Performance</h3>

  <p class="body"><a id="pgfId-1001194"></a>As <a id="marker-1001933"></a><a id="marker-1001937"></a>mentioned, chaining is usually the method of choice to resolve collisions, because it gives several advantages in terms of running time and memory allocation. For a hash table using chaining and linked lists, where the table has size <code class="fm-code-in-text">m</code> and contains <code class="fm-code-in-text">n</code> elements, all operations require on average <code class="fm-code-in-text">O(n/m)</code> time.</p>

  <p class="fm-callout"><a id="pgfId-1001225"></a><span class="fm-callout-head">Note</span> While most of the time it is fine to consider hash table operations to be <code class="fm-code-in-text2">O(1)</code>, you should keep in mind that the worst-case time is <code class="fm-code-in-text2">O(n)</code>. This happens if all elements are mapped to the same bucket (that is, the same chain) within the table. In such cases, the time needed to delete or search an element is <code class="fm-code-in-text2">O(n)</code>. This is, however, a very unlikely event, at least when the hash functions used are properly designed.</p>

  <p class="body"><a id="pgfId-1001261"></a>The good news is that if the set of possible keys is static and known in advance, then it is possible to use <i class="calibre17">perfect hashing</i><a id="marker-1001941"></a> and have a worst case <code class="fm-code-in-text">O(1)</code> time for <a id="marker-1001945"></a><a id="marker-1001949"></a>all <a id="marker-1001953"></a><a id="marker-1001957"></a><a id="marker-1001961"></a>operations.</p>

  <h2 class="fm-head" id="heading_id_13"><a id="pgfId-1001284"></a>C.6 Comparative analysis of core data structures</h2>

  <p class="body"><a id="pgfId-1001305"></a>Now <a id="marker-1001965"></a><a id="marker-1001969"></a>that we have described all the core data structures, we’ll try to sum up their characteristics by listing their properties and performance in table 2.1.</p>

  <p class="body"><a id="pgfId-1001323"></a>The properties we will include are</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1001332"></a><i class="calibre15">Order</i><a class="calibre14" id="marker-1001973"></a>—Whether a deterministic order for the elements can be maintained. It could be a natural order for the elements, or the insertion order.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1001347"></a><i class="calibre15">Unique</i><a class="calibre14" id="marker-1001977"></a>—If duplicate elements/keys are forbidden.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1001362"></a><i class="calibre15">Associative</i><a class="calibre14" id="marker-1001981"></a>—If elements can be indexed by a key.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1001378"></a><i class="calibre15">Dynamic</i><a class="calibre14" id="marker-1001985"></a>—Whether the container can resize on insertion/removal, or its max size needs to be decided in advance.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1001393"></a><i class="calibre15">Locality</i><a class="calibre14" id="marker-1001989"></a>—Locality of reference. If elements are all stored in a single, uninterrupted block of memory.</p>
    </li>
  </ul>

  <p class="fm-table-caption"><a id="pgfId-1006775"></a>Table C.1 Comparative analysis of core data structures</p>

  <table class="contenttable">
    <tr class="calibre8">
      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1006787"></a>Structure</p>
      </th>

      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1006789"></a>Order</p>
      </th>

      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1006791"></a>Unique</p>
      </th>

      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1006793"></a>Associative</p>
      </th>

      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1006795"></a>Dynamic</p>
      </th>

      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1006797"></a>Locality</p>
      </th>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006799"></a>Array<a id="marker-1006870"></a><a id="marker-1006871"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006801"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006803"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006805"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006807"></a>no <a href="#pgfId-1006902"><sup class="footnotenumber1">4</sup></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006809"></a>yes</p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006811"></a>Singly-linked list<a id="marker-1006872"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006813"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006815"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006817"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006819"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006821"></a>no</p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006823"></a>Doubly-linked list<a id="marker-1006873"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006825"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006827"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006829"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006831"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006833"></a>no</p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006835"></a>Balanced tree<a id="marker-1006874"></a><a id="marker-1006875"></a> (for example, BST<a id="marker-1006876"></a>)</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006837"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006839"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006841"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006843"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006845"></a>no</p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006847"></a>Heap<a id="marker-1006877"></a> (see chapter 2)</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006849"></a>no <a href="#pgfId-1006944"><sup class="footnotenumber1">5</sup></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006851"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006853"></a>key-priority</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006855"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006857"></a>yes</p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006859"></a>Hash table<a id="marker-1006878"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006861"></a>no</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006863"></a>yes</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006865"></a>key-value</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006867"></a>yes <a href="#pgfId-1006923"><sup class="footnotenumber1">6</sup></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1006869"></a>no</p>
      </td>
    </tr>
  </table>

  <p class="body"><a id="pgfId-1002530"></a>As part of the comparison, we also have to take into account their relative performance. But what does performance really mean for a whole data structure, if we have only discussed the running time for their individual methods?</p>

  <p class="body"><a id="pgfId-1002539"></a>Usually the performance for a data structure, and even more for its implementation, is a trade-off between the individual performances of its methods. This is valid for all data structures: there is no ideal data structure that has optimal performance for all the operations it provides. For instance, arrays are faster for random, position-based access. But they are slow when their shape needs to be changed and very slow<a href="#pgfId-1002652"><sup class="footnotenumber">7</sup></a> when you need to look up an element by value. Lists allow for fast insertion of new elements, but lookup and access by position are slow. Hash tables have fast key-based lookup, but finding the successor of an element, or maximum and minimum, are very slow.</p>

  <p class="body"><a id="pgfId-1002556"></a>In practice, choosing the best data structure should be based on a careful analysis of your problem and the performance of the data structure, but it’s more important to avoid using a bad data structure (which could cause a bottleneck) than to find the single best option available, just to gain a small savings on the average (and easier to <a id="marker-1002587"></a><a id="marker-1002591"></a>implement) <a id="marker-1002595"></a><a id="marker-1002599"></a>choice.</p>
  <hr class="calibre22"/>

  <p class="fm-footnote"><sup class="footnotenumber">1.</sup> <a id="pgfId-1002604"></a>In big-O analysis, aggregate running time refers to the expected performance over a big enough number of operations. For instance, if we toss a (fair) coin once, we don’t know if it’s going to be heads or tails. If we toss it twice, it’s possible that we get tails once and heads once, but it’s far from being certain. If we repeat the experiment a million times, and the coin is fair and we don’t do any tricks with it, then we will get heads and tails (very) close to 50% of the times. Likewise, for some algorithms, a single operation can take longer than expected, but if we run it on a high volume of data, the average running time will be predictable.</p>

  <p class="fm-footnote"><sup class="footnotenumber">2.</sup> <a id="pgfId-1002619"></a>At least in theory, low-level implementation may vary between different programming languages.</p>

  <p class="fm-footnote"><sup class="footnotenumber">3.</sup> <a id="pgfId-1002633"></a>Peter J. Denning, Stuart C. Schwartz, “Properties of the Working-Set Model,” Communications of the ACM, Volume 15, Issue 3 (March 1972), pages 191-198.</p>

  <p class="fm-footnote"><sup class="footnotenumber">4.</sup> <a id="pgfId-1006902"></a>Arrays are natively static in most languages, but dynamic arrays can be built from static ones with little performance overhead.</p>

  <p class="fm-footnote"><sup class="footnotenumber">5.</sup> <a id="pgfId-1006944"></a>Heaps only define a partial order between their keys. They allow sorting keys based on their priority, but they don’t keep any info on the order of insertion.</p>

  <p class="fm-footnote"><sup class="footnotenumber">6.</sup> <a id="pgfId-1006923"></a>Hash tables are dynamic in size when conflict resolution is resolved with chaining.</p>

  <p class="fm-footnote"><sup class="footnotenumber">7.</sup> <a id="pgfId-1002652"></a>Unsorted arrays are terribly slow for search and direct access. Sorted arrays can implement both in O(log(n)).</p>
</body>
</html>
