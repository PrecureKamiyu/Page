<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos701833" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_56"><span class="bold">11. Timers and Time Management</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos702005"> </div>
<p class="calibre_2">The passing of time is important to the kernel. A large number of kernel functions are time-driven, as opposed to event-driven.<sup class="calibre8"><a id="filepos702188" href="#filepos702718">1</a></sup> Some of these functions are periodic, such as balancing the scheduler runqueues or refreshing the screen. They occur on a fixed schedule, such as 100 times per second. The kernel schedules other functions, such as delayed disk I/O, at a relative time in the future. For example, the kernel might schedule work for 500 milliseconds from now. Finally, the kernel must also manage the system uptime and the current date and time.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos702718" href="#filepos702188">1</a></sup>
<em class="calibre4">More accurately, time-driven events are also event-driven—the event being the passing of time. In this chapter, however, we single out time-driven events because of their frequency in and importance to the kernel.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">Note the differences between relative and absolute time. Scheduling an event for 5 seconds in the future requires no concept of the <em class="calibre4">absolute</em> time—only the <em class="calibre4">relative</em> time (for example, 5 seconds from now). Conversely, managing the current time of day requires the kernel to understand not just the passing of time but also some absolute measurement of it. Both of these concepts are crucial to the management of time.</p><div class="calibre_3"> </div>
<p class="calibre_2">Moreover, the implementation differs between how events that occur periodically and events the kernel schedules for a fixed point in the future are handled. Events that occur periodically—say, every 10 milliseconds—are driven by the <em class="calibre4">system timer</em>. The system timer is a programmable piece of hardware that issues an interrupt at a fixed frequency. The interrupt handler for this timer—called the <em class="calibre4">timer interrupt</em>—updates the system time and performs periodic work. The system timer and its timer interrupt are central to Linux and a large focus of this chapter.</p><div class="calibre_3"> </div>
<p class="calibre_2">The other focus of this chapter is <em class="calibre4">dynamic timers</em>, the facility used to schedule events that run once after a specified time has elapsed. For example, the floppy device driver uses a timer to shut off the floppy drive motor after a specified period of inactivity. The kernel can create and destroy timers dynamically. This chapter covers the kernel implementation of dynamic timers, and the interface available for their use in your code.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos704689"> </div>
<h3 class="calibre_21"><span class="bold">Kernel Notion of Time</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos704813"> </div>
<p class="calibre_2">Certainly, the concept of <em class="calibre4">time</em> to a computer is a bit obscure. Indeed, the kernel must work with the system’s hardware to comprehend and manage time. The hardware provides a system timer that the kernel uses to gauge the passing of time. This system timer works off of an electronic time source, such as a digital clock or the frequency of the processor. The system timer goes off (often called <em class="calibre4">hitting</em> or <em class="calibre4">popping</em>) at a preprogrammed frequency, called the <em class="calibre4">tick rate</em>. When the system timer goes off, it issues an interrupt that the kernel handles via a special interrupt handler.</p><div class="calibre_3"> </div>
<p class="calibre_2">Because the kernel knows the preprogrammed tick rate, it knows the time between any two successive timer interrupts. This period is called a <em class="calibre4">tick</em> and is equal to <code class="calibre6"><span class="calibre7">1/(tick rate)</span></code> seconds. This is how the kernel keeps track of both wall time and system uptime. Wall time—the actual time of day—is important to user-space applications. The kernel keeps track of it simply because the kernel controls the timer interrupt. A family of system calls provides the date and time of day to user-space. The system uptime—the relative time since the system booted—is useful to both kernel-space and user-space. A lot of code must be aware of the <em class="calibre4">passing</em> of time. The difference between two uptime readings—now and then—is a simple measure of this relativity.</p><div class="calibre_3"> </div>
<p class="calibre_2">The timer interrupt is important to the management of the operating system. A large number of kernel functions live and die by the passing of time. Some of the work executed periodically by the timer interrupt includes</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Updating the system uptime</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Updating the time of day</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• On an SMP system, ensuring that the scheduler runqueues are balanced and, if not, balancing them (as discussed in <a href="index_split_013.html#filepos223287">Chapter 4</a>, “Process Scheduling”)</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Running any dynamic timers that have expired</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Updating resource usage and processor time statistics</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Some of this work occurs on <em class="calibre4">every</em> timer interrupt—that is, the work is carried out with the frequency of the tick rate. Other functions execute periodically but only every <em class="calibre4">n</em> timer interrupts. That is, these functions occur at some fraction of the tick rate. The section “<a href="#filepos738659">The Timer Interrupt Handler</a>” looks at the timer interrupt handler.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos707901"> </div>
<h3 class="calibre_21"><span class="bold">The Tick Rate: HZ</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The frequency of the system timer (the tick rate) is programmed on system boot based on a static preprocessor define, <code class="calibre6"><span class="calibre7">HZ</span></code>. The value of <code class="calibre6"><span class="calibre7">HZ</span></code> differs for each supported architecture. On some supported architectures, it even differs between machine types.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel defines the value in <code class="calibre6"><span class="calibre7">&lt;asm/param.h&gt;</span></code>. The tick rate has a frequency of <code class="calibre6"><span class="calibre7">HZ</span></code> hertz and a period of <code class="calibre6"><span class="calibre7">1/HZ</span></code> seconds. For example, by default the x86 architecture defines HZ to be 100. Therefore, the timer interrupt on i386 has a frequency of 100HZ and occurs 100 times per second (every one-hundredth of a second, which is every <a id="filepos708834"></a>10 milliseconds). Other common values for HZ are 250 and 1000, corresponding to periods of 4ms and 1ms, respectively. <a href="#filepos709123">Table 11.1</a> is a complete listing of the supported architectures and their defined tick rates.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos709123"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 11.1. Frequency of the Timer Interrupt</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00141.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">When writing kernel code, never assume that <code class="calibre6"><span class="calibre7">HZ</span></code> has any given value. This is not a common mistake these days because so many architectures have varying tick rates. In the past, however, Alpha was the only architecture with a tick rate not equal to 100Hz, and it was common to see code incorrectly hard-code the value <code class="calibre6"><span class="calibre7">100</span></code> when the <code class="calibre6"><span class="calibre7">HZ</span></code> value should have been used. Examples of using <code class="calibre6"><span class="calibre7">HZ</span></code> in kernel code are shown later.</p><div class="calibre_3"> </div>
<p class="calibre_2">The frequency of the timer interrupt is important. As you already saw, the timer interrupt performs a lot of work. Indeed, the kernel’s entire notion of time derives from the periodicity of the system timer. Picking the right value, like a successful relationship, is all about compromise.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos710367"> </div>
<h4 class="calibre_27"><span class="calibre3">The Ideal <code class="calibre6"><span class="calibre7">HZ</span></code> Value</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Starting with the initial version of Linux, the i386 architecture has had a timer interrupt frequency of 100 Hz. During the 2.5 development series, however, the frequency was raised to 1000 Hz and was (as such things are) controversial. Although the frequency is again 100 Hz, it is now a configuration option, allowing users to compile a kernel with a custom <code class="calibre6"><span class="calibre7">HZ</span></code> value. Because so much of the system is dependent on the timer interrupt, changing its frequency has a reasonable impact on the system. Of course, there are pros and cons to larger versus smaller <code class="calibre6"><span class="calibre7">HZ</span></code> values.</p><div class="calibre_3"> </div>
<p class="calibre_2">Increasing the tick rate means the timer interrupt runs more frequently. Consequently, the work it performs occurs more often. This has the following benefits:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The timer interrupt has a higher resolution and, consequently, all timed events have a higher resolution.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The accuracy of timed events improves.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The resolution increases by the same factor as the tick rate increases. For example, the granularity of timers with <code class="calibre6"><span class="calibre7">HZ=100</span></code> is 10 milliseconds. In other words, all periodic events occur along the timer interrupt’s 10 millisecond period and no finer <em class="calibre4">precision</em><sup class="calibre8"><a id="filepos712049" href="#filepos712522">2</a></sup> is guaranteed. With <code class="calibre6"><span class="calibre7">HZ=1000</span></code>, however, resolution is 1 millisecond—10 times finer. Although kernel code can create timers with 1-millisecond resolution, there is no guarantee the precision afforded with <code class="calibre6"><span class="calibre7">HZ=100</span></code> is sufficient to execute the timer on anything better than 10-millisecond intervals.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos712522" href="#filepos712049">2</a></sup>
<em class="calibre4">We use precision here in the computer sense, not the scientific. Precision in science is a statistical measurement of repeatability. In computers, precision is the number of significant figures used to represent a value.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">Likewise, accuracy improves in the same manner. Assuming the kernel starts timers at random times, the average timer is off by half the period of the timer interrupt because timers might expire at any time, but are executed only on occurrences of the timer interrupt. For example, with <code class="calibre6"><span class="calibre7">HZ=100</span></code>, the average event occurs +/– 5 milliseconds off from the desired time. Thus, error is 5 milliseconds on average. With <code class="calibre6"><span class="calibre7">HZ=1000</span></code>, the average error drops to 0.5 milliseconds—a tenfold improvement.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos713474"> </div>
<h4 class="calibre_27"><span class="calibre3">Advantages with a Larger <code class="calibre6"><span class="calibre7">HZ</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">This higher resolution and greater accuracy provides multiple advantages:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Kernel timers execute with finer resolution and increased accuracy. (This provides a large number of improvements, one of which is the following.)</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <a id="filepos714016"></a>System calls such as <code class="calibre6"><span class="calibre7">poll()</span></code> and <code class="calibre6"><span class="calibre7">select()</span></code> that optionally employ a timeout value execute with improved precision.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Measurements, such as resource usage or the system uptime, are recorded with a finer resolution.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Process preemption occurs more accurately.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Some of the most readily noticeable performance benefits come from the improved precision of <code class="calibre6"><span class="calibre7">poll()</span></code> and <code class="calibre6"><span class="calibre7">select()</span></code> timeouts. The improvement might be quite large; an application that makes heavy use of these system calls might waste a great deal of time waiting for the timer interrupt, when, in fact, the timeout has actually expired. Remember, the average error (that is, potentially wasted time) is half the period of the timer interrupt.</p><div class="calibre_3"> </div>
<p class="calibre_2">Another benefit of a higher tick rate is the greater accuracy in process preemption, which results in decreased scheduling latency. Recall from <a href="index_split_013.html#filepos223287">Chapter 4</a> that the timer interrupt is responsible for decrementing the running process’s timeslice count. When the count reaches zero, <code class="calibre6"><span class="calibre7">need_resched</span></code> is set and the kernel runs the scheduler as soon as possible. Now assume a given process is running and has 2 milliseconds of its timeslice remaining. In 2 milliseconds, the scheduler <em class="calibre4">should</em> preempt the running process and begin executing a new process. Unfortunately, this event does not occur until the next timer interrupt, which might not be in 2 milliseconds. At worst the next timer interrupt might be <code class="calibre6"><span class="calibre7">1/HZ</span></code> of a second away! With <code class="calibre6"><span class="calibre7">HZ=100</span></code>, a process can get nearly 10 extra milliseconds to run. Of course, this all balances out and fairness is preserved, because all tasks receive the same imprecision in scheduling—but that is not the issue. The problem stems from the latency created by the delayed preemption. If the to-be-scheduled task had something time-sensitive to do, such as refill an audio buffer, the delay might not be acceptable. Increasing the tick rate to 1000Hz lowers the worst-case scheduling overrun to just 1 millisecond, and the average-case overrun to just 0.5 milliseconds.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos716629"> </div>
<h4 class="calibre_27"><span class="calibre3">Disadvantages with a Larger <code class="calibre6"><span class="calibre7">HZ</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Now, there must be <em class="calibre4">some</em> downside to increasing the tick rate, or it would have been 1000Hz (or even higher) to start. Indeed, there is one large issue: A higher tick rate implies more frequent timer interrupts, which implies higher overhead, because the processor must spend more time executing the timer interrupt handler. The higher the tick rate, the more time the processor spends executing the timer interrupt. This adds up to not just less processor time available for other work, but also a more frequent thrashing of the processor’s cache and increase in power consumption. The issue of the overhead’s impact is debatable. A move from <code class="calibre6"><span class="calibre7">HZ=100</span></code> to <code class="calibre6"><span class="calibre7">HZ=1000</span></code> clearly brings with it ten times greater overhead. However, how substantial is the overhead to begin with? The final agreement is that, at least on modern systems, <code class="calibre6"><span class="calibre7">HZ=1000</span></code> does not create unacceptable overhead and the <a id="filepos717801"></a>move to a 1000Hz timer has not hurt performance too much. Nevertheless, it is possible in 2.6 to compile the kernel with a different value for <code class="calibre6"><span class="calibre7">HZ</span></code>.<sup class="calibre8"><a id="filepos717987" href="#filepos718090">3</a></sup></p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos718090" href="#filepos717987">3</a></sup>
<em class="calibre4">Because of architectural and NTP-related issues, however, not just any value is acceptable for</em>
<code class="calibre6"><span class="calibre7">HZ</span></code>. <em class="calibre4">On x86, 100, 500, and 1000 all work fine.</em></p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">A Tickless OS</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">You might wonder whether an operating system even needs a fixed timer interrupt. Although that has been the norm for 40 years, with nearly all general-purpose operating systems employing a timer interrupt similar to the system described in this chapter, the Linux kernel supports an option known as a <em class="calibre4">tickless operation</em>. When a kernel is built with the <code class="calibre6"><span class="calibre7">CONFIG_HZ</span></code> configuration option set, the system dynamically schedules the timer interrupt in accordance with pending timers. Instead of firing the timer interrupt every, say, 1ms, the interrupt is dynamically scheduled and rescheduled as needed. If the next timer is set to go off in 3ms, the timer interrupt fires in 3ms. After that, if there is no work for 50ms, the kernel reschedules the interrupt to go off in 50ms.</p><div class="calibre_3"> </div>
<p class="calibre_2">The reduction in overhead is welcome, but the real gain is in power savings, particular on an idle system. On a standard tick-based system, the kernel needs to service timer interrupts, even during idle periods. With a tickless system, moments of idleness are not interrupted by unnecessary time interrupts, reducing system power consumption. Whether the idle period is 200 milliseconds or 200 seconds, over time the gains add up to tangible power savings.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos720043"> </div>
<h3 class="calibre_21"><span class="bold">Jiffies</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The global variable <code class="calibre6"><span class="calibre7">jiffies</span></code> holds the number of ticks that have occurred since the system booted. On boot, the kernel initializes the variable to zero, and it is incremented by one during each timer interrupt. Thus, because there are <code class="calibre6"><span class="calibre7">HZ</span></code> timer interrupts in a second, there are <code class="calibre6"><span class="calibre7">HZ</span></code> jiffies in a second. The system uptime is therefore <code class="calibre6"><span class="calibre7">jiffies/HZ</span></code> seconds. What actually happens is slightly more complicated: The kernel initializes <code class="calibre6"><span class="calibre7">jiffies</span></code> to a special initial value, causing the variable to overflow more often, catching bugs. When the actual value of <code class="calibre6"><span class="calibre7">jiffies</span></code> is sought, this “offset” is first subtracted.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">The Etymology of the Jiffy</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">The origin of the term <em class="calibre4">jiffy</em> is unknown. Phrases such as <em class="calibre4">in a jiffy</em> are thought to originate from 18th-century England. In lay terms, <em class="calibre4">jiffy</em> refers to an indeterminate but brief period of time.</p><div class="calibre_3"> </div>
<p class="calibre_2">In scientific applications, <em class="calibre4">jiffy</em> represents various intervals of time, most commonly 10ms. In physics, a jiffy is sometimes used to refer to the time it takes for light to travel some specific distance (usually a foot or a centimeter or across a nucleon).</p><div class="calibre_3"> </div>
<p class="calibre_2">In computer engineering, a jiffy is often the time between two successive clock cycles. In electrical engineering, a jiffy is the time to complete one AC (alternating current) cycle. In the United States, this is 1/60 of a second.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos722140"></a>In operating systems, especially Unix, a jiffy is the time between two successive clock ticks. Historically, this has been 10ms. As we have seen in this chapter, however, a jiffy in Linux can have various values.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">jiffies</span></code> variable is declared in <code class="calibre6"><span class="calibre7">&lt;linux/jiffies.h&gt;</span></code> as</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">extern unsigned long volatile jiffies;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">In the next section, we look at its actual definition, which is a bit peculiar. For now, let’s look at some sample kernel code. The following expression converts from seconds to a unit of <code class="calibre6"><span class="calibre7">jiffies</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">(seconds * HZ)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Likewise, this expression converts from <code class="calibre6"><span class="calibre7">jiffies</span></code> to seconds:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">(jiffies / HZ)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The former, converting from seconds to ticks, is more common. For example, code often needs to set a value for some time in the future, for example:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00142.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Converting from ticks to seconds is typically reserved for communicating with user-space, as the kernel itself rarely cares about any sort of absolute time.</p><div class="calibre_3"> </div>
<p class="calibre_2">Note that the <code class="calibre6"><span class="calibre7">jiffies</span></code> variable is prototyped as <code class="calibre6"><span class="calibre7">unsigned long</span></code> and that storing it in anything else is incorrect.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos724171"> </div>
<h4 class="calibre_27"><span class="calibre3">Internal Representation of Jiffies</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">jiffies</span></code> variable has always been an <code class="calibre6"><span class="calibre7">unsigned long</span></code>, and therefore 32 bits in size on 32-bit architectures and 64-bits on 64-bit architectures. With a tick rate of 100, a 32-bit <code class="calibre6"><span class="calibre7">jiffies</span></code> variable would overflow in about 497 days. With <code class="calibre6"><span class="calibre7">HZ</span></code> increased to 1000, however, that overflow now occurs in just 49.7 days! If <code class="calibre6"><span class="calibre7">jiffies</span></code> were stored in a 64-bit variable on all architectures, then for any reasonable <code class="calibre6"><span class="calibre7">HZ</span></code> value the <code class="calibre6"><span class="calibre7">jiffies</span></code> variable would never overflow in anyone’s lifetime.</p><div class="calibre_3"> </div>
<p class="calibre_2">For performance and historical reasons—mainly compatibility with existing kernel code—the kernel developers wanted to keep <code class="calibre6"><span class="calibre7">jiffies</span></code> an <code class="calibre6"><span class="calibre7">unsigned long</span></code>. Some smart thinking and a little linker magic saved that day.</p><div class="calibre_3"> </div>
<p class="calibre_2">As you previously saw, <code class="calibre6"><span class="calibre7">jiffies</span></code> is defined as an <code class="calibre6"><span class="calibre7">unsigned long</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">extern unsigned long volatile jiffies;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">A second variable is also defined in <code class="calibre6"><span class="calibre7">&lt;linux/jiffies.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">extern u64 jiffies_64;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos726021"></a>The <code class="calibre6"><span class="calibre7">ld(1)</span></code> script used to link the main kernel image <code class="calibre6"><span class="calibre7">(arch/x86/kernel/vmlinux.lds.S</span></code> on x86) then <em class="calibre4">overlays</em> the <code class="calibre6"><span class="calibre7">jiffies</span></code> variable over the start of the <code class="calibre6"><span class="calibre7">jiffies_64</span></code> variable:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">jiffies = jiffies_64;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Thus, <code class="calibre6"><span class="calibre7">jiffies</span></code> is the lower 32 bits of the full 64-bit <code class="calibre6"><span class="calibre7">jiffies_64</span></code> variable. Code can continue to access the <code class="calibre6"><span class="calibre7">jiffies</span></code> variable exactly as before. Because most code uses <code class="calibre6"><span class="calibre7">jiffies</span></code> simply to measure elapses in time, most code cares about only the lower 32 bits. The time management code uses the entire 64 bits, however, and thus prevents overflow of the full 64-bit value. <a href="#filepos727223">Figure 11.1</a> shows the layout of <code class="calibre6"><span class="calibre7">jiffies</span></code> and <code class="calibre6"><span class="calibre7">jiffies_64</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos727223"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 11.1. Layout of <code class="calibre6"><span class="calibre15">jiffies</span></code> and <code class="calibre6"><span class="calibre15">jiffies_64</span></code>.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00143.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Code that accesses <code class="calibre6"><span class="calibre7">jiffies</span></code> simply reads the lower 32 bits of <code class="calibre6"><span class="calibre7">jiffies_64</span></code>. The function <code class="calibre6"><span class="calibre7">get_jiffies_64()</span></code> can be used to read the full 64-bit value.<sup class="calibre8"><a id="filepos727844" href="#filepos728105">4</a></sup> Such a need is rare; consequently, most code simply continues to read the lower 32 bits directly via the <code class="calibre6"><span class="calibre7">jiffies</span></code> variable.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos728105" href="#filepos727844">4</a></sup>
<em class="calibre4">A special function is needed because 32-bit architectures cannot atomically access both 32-bit words in a 64-bit value. The special function locks the jiffies count via the</em>
<code class="calibre6"><span class="calibre7">xtime_lock</span></code>
<em class="calibre4">lock before reading.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">On 64-bit architectures, <code class="calibre6"><span class="calibre7">jiffies_64</span></code> and <code class="calibre6"><span class="calibre7">jiffies</span></code> refer to the same thing. Code can either read <code class="calibre6"><span class="calibre7">jiffies</span></code> or call <code class="calibre6"><span class="calibre7">get_jiffies_64()</span></code> as both actions have the same effect.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos728820"> </div>
<h4 class="calibre_27"><span class="calibre3">Jiffies Wraparound</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">jiffies</span></code> variable, like any C integer, experiences <em class="calibre4">overflow</em> when its value is increased beyond its maximum storage limit. For a 32-bit unsigned integer, the maximum value is <code class="calibre6"><span class="calibre7">2<sup class="calibre17">32</sup> – 1</span></code>. Thus, a possible 4294967295 timer ticks can occur before the tick count overflows. When the tick count is equal to this maximum and it is incremented, it wraps around to zero.</p><div class="calibre_3"> </div>
<p class="calibre_2">Look at an example of a wraparound:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00144.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The intention of this code snippet is to set a timeout for some time in the future—for one half second from now, in this example. The code then proceeds to perform some work, presumably poking hardware and waiting for a response. When done, if the whole ordeal took longer than the timeout, the code handles the error as appropriate.</p><div class="calibre_3"> </div>
<p class="calibre_2">Multiple potential overflow issues are here, but let’s study one of them: Consider what happens if <code class="calibre6"><span class="calibre7">jiffies</span></code> wrapped back to zero after setting <code class="calibre6"><span class="calibre7">timeout</span></code>. Then the first conditional would fail because the <code class="calibre6"><span class="calibre7">jiffies</span></code> value would be smaller than <code class="calibre6"><span class="calibre7">timeout</span></code> despite logically being larger. Conceptually, the <code class="calibre6"><span class="calibre7">jiffies</span></code> value should be a large number—larger than <code class="calibre6"><span class="calibre7">timeout</span></code>. Because it overflowed its maximum value, however, it is now a small value—perhaps only a handful of ticks over zero. Because of the wraparound, the results of the <code class="calibre6"><span class="calibre7">if</span></code> statement are switched. Whoops!</p><div class="calibre_3"> </div>
<p class="calibre_2">Thankfully, the kernel provides four macros for comparing tick counts that correctly handle wraparound in the tick count. They are in <code class="calibre6"><span class="calibre7">&lt;linux/jiffies.h&gt;</span></code>. Listed here are simplified versions of the macros:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00145.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">unknown</span></code> parameter is typically <code class="calibre6"><span class="calibre7">jiffies</span></code> and the <code class="calibre6"><span class="calibre7">known</span></code> parameter is the value against which you want to compare.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">time_after(unknown, known)</span></code> macro returns true if time <code class="calibre6"><span class="calibre7">unknown</span></code> is after time <code class="calibre6"><span class="calibre7">known</span></code>; otherwise, it returns false. The <code class="calibre6"><span class="calibre7">time_before(unknown, known)</span></code> macro returns true if time <code class="calibre6"><span class="calibre7">unknown</span></code> is before time <code class="calibre6"><span class="calibre7">known</span></code>; otherwise, it returns false. The final two macros perform identically to the first two, except they also return true if the parameters are equal.</p><div class="calibre_3"> </div>
<p class="calibre_2">The timer-wraparound-safe version of the previous example would look like this:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00146.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos732360"></a>If you are curious as to why these macros prevent errors because of wraparound, try various values for the two parameters. Then assume one parameter wrapped to zero and see what happens.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos732597"> </div>
<h4 class="calibre_27"><span class="calibre3">User-Space and <code class="calibre6"><span class="calibre7">HZ</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">In kernels earlier than 2.6, changing the value of <code class="calibre6"><span class="calibre7">HZ</span></code> resulted in user-space anomalies. This happened because values were exported to user-space in units of ticks-per-second. As these interfaces became permanent, applications grew to rely on a specific value of <code class="calibre6"><span class="calibre7">HZ</span></code>. Consequently, changing <code class="calibre6"><span class="calibre7">HZ</span></code> would scale various exported values by some constant—without user-space knowing! Uptime would read 20 hours when it was in fact two!</p><div class="calibre_3"> </div>
<p class="calibre_2">To prevent such problems, the kernel needs to scale all exported <code class="calibre6"><span class="calibre7">jiffies</span></code> values. It does this by defining <code class="calibre6"><span class="calibre7">USER_HZ</span></code>, which is the <code class="calibre6"><span class="calibre7">HZ</span></code> value that user-space expects. On x86, because <code class="calibre6"><span class="calibre7">HZ</span></code> was historically 100, <code class="calibre6"><span class="calibre7">USER_HZ</span></code> is <code class="calibre6"><span class="calibre7">100</span></code>. The function <code class="calibre6"><span class="calibre7">jiffies_to_clock_t()</span></code>, defined in <code class="calibre6"><span class="calibre7">kernel/time.c</span></code>, is then used to scale a tick count in terms of <code class="calibre6"><span class="calibre7">HZ</span></code> to a tick count in terms of <code class="calibre6"><span class="calibre7">USER_HZ</span></code>. The expression used depends on whether <code class="calibre6"><span class="calibre7">USER_HZ</span></code> and <code class="calibre6"><span class="calibre7">HZ</span></code> are integer multiples of themselves and whether <code class="calibre6"><span class="calibre7">USER_HZ</span></code> is less than or equal to <code class="calibre6"><span class="calibre7">HZ</span></code>. If both those conditions are true, and for most systems they usually are, the expression is rather simple:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">return x / (HZ / USER_HZ);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">A more complicated algorithm is used if the values are not integer multiples.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, the function <code class="calibre6"><span class="calibre7">jiffies_64_to_clock_t()</span></code> is provided to convert a 64-bit <code class="calibre6"><span class="calibre7">jiffies</span></code> value from <code class="calibre6"><span class="calibre7">HZ</span></code> to <code class="calibre6"><span class="calibre7">USER_HZ</span></code> units.</p><div class="calibre_3"> </div>
<p class="calibre_2">These functions are used anywhere a value in ticks-per-seconds needs to be exported to user-space. Following is an example:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00147.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">User-space expects the previous value as if <code class="calibre6"><span class="calibre7">HZ=USER_HZ</span></code>. If they are not equivalent, the macro scales as needed and everyone is happy. Of course, this example is silly: It would make more sense to print the message in seconds, not ticks. For example:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">printk("That took %lu seconds\n", total_time / HZ);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos735806"> </div>
<h3 class="calibre_21"><span class="bold">Hardware Clocks and Timers</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Architectures provide two hardware devices to help with time keeping: the system timer, which we have been discussing, and the real-time clock. The actual behavior and implementation of these devices varies between different machines, but the general purpose and design is about the same for each.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos736283"> </div>
<h4 class="calibre_27"><span class="calibre3">Real-Time Clock</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos736400"> </div>
<p class="calibre_2">The real-time clock (RTC) provides a nonvolatile device for storing the system time. The RTC continues to keep track of time even when the system is off by way of a small battery typically included on the system board. On the PC architecture, the RTC and the CMOS are integrated, and a single battery keeps the RTC running and the BIOS settings preserved.</p><div class="calibre_3"> </div>
<p class="calibre_2">On boot, the kernel reads the RTC and uses it to initialize the wall time, which is stored in the <code class="calibre6"><span class="calibre7">xtime</span></code> variable. The kernel does not typically read the value again; however, some supported architectures, such as x86, periodically save the current wall time back to the RTC. Nonetheless, the real time clock’s primary importance is only during boot, when the <code class="calibre6"><span class="calibre7">xtime</span></code> variable is initialized.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos737373"> </div>
<h4 class="calibre_27"><span class="calibre3">System Timer</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The system timer serves a much more important (and frequent) role in the kernel’s timekeeping. The idea behind the system timer, regardless of architecture, is the same—to provide a mechanism for driving an interrupt at a periodic rate. Some architectures implement this via an electronic clock that oscillates at a programmable frequency. Other systems provide a decrementer: A counter is set to some initial value and decrements at a fixed rate until the counter reaches zero. When the counter reaches zero, an interrupt is triggered. In any case, the effect is the same.</p><div class="calibre_3"> </div>
<p class="calibre_2">On x86, the primary system timer is the programmable interrupt timer (PIT). The PIT exists on all PC machines and has been driving interrupts since the days of DOS. The kernel programs the PIT on boot to drive the system timer interrupt (interrupt zero) at <code class="calibre6"><span class="calibre7">HZ</span></code> frequency. It is a simple device with limited functionality, but it gets the job done. Other x86 time sources include the local APIC timer and the processor’s time stamp counter (TSC).</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos738659"> </div>
<h3 class="calibre_21"><span class="bold">The Timer Interrupt Handler</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Now that we have an understanding of <code class="calibre6"><span class="calibre7">HZ</span></code>, <code class="calibre6"><span class="calibre7">jiffies</span></code>, and what the system timer’s role is, let’s look at the actual implementation of the timer interrupt handler. The timer interrupt is broken into two pieces: an architecture-dependent and an architecture-independent routine.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos739194"></a>The architecture-dependent routine is registered as the interrupt handler for the system timer and, thus, runs when the timer interrupt hits. Its exact job depends on the given architecture, of course, but most handlers perform at least the following work:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Obtain the <code class="calibre6"><span class="calibre7">xtime_lock</span></code> lock, which protects access to <code class="calibre6"><span class="calibre7">jiffies_64</span></code> and the wall time value, <code class="calibre6"><span class="calibre7">xtime</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Acknowledge or reset the system timer as required.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Periodically save the updated wall time to the real time clock.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Call the architecture-independent timer routine, <code class="calibre6"><span class="calibre7">tick_periodic()</span></code>.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The architecture-independent routine, <code class="calibre6"><span class="calibre7">tick_periodic()</span></code>, performs much more work:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Increment the <code class="calibre6"><span class="calibre7">jiffies_64</span></code> count by one. (This is safe, even on 32-bit architectures, because the <code class="calibre6"><span class="calibre7">xtime_lock</span></code> lock was previously obtained.)</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Update resource usages, such as consumed system and user time, for the currently running process.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Run any dynamic timers that have expired (discussed in the following section).</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Execute <code class="calibre6"><span class="calibre7">scheduler_tick()</span></code>, as discussed in <a href="index_split_013.html#filepos223287">Chapter 4</a>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Update the wall time, which is stored in <code class="calibre6"><span class="calibre7">xtime</span></code>.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Calculate the infamous load average.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The routine is simple because other functions handle most of the work:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00148.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Most of the important work is enabled in <code class="calibre6"><span class="calibre7">do_timer()</span></code> and <code class="calibre6"><span class="calibre7">update_process_times()</span></code>. The former is responsible for actually performing the increment to <code class="calibre6"><span class="calibre7">jiffies_64</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00149.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The function <code class="calibre6"><span class="calibre7">update_wall_time()</span></code>, as its name suggests, updates the wall time in accordance with the elapsed ticks, whereas <code class="calibre6"><span class="calibre7">calc_global_load()</span></code> updates the system’s load average statistics.</p><div class="calibre_3"> </div>
<p class="calibre_2">When <code class="calibre6"><span class="calibre7">do_timer()</span></code> ultimately returns, <code class="calibre6"><span class="calibre7">update_process_times()</span></code> is invoked to update various statistics that a tick has elapsed, noting via <code class="calibre6"><span class="calibre7">user_tick</span></code> whether it occurred in user-space or kernel-space:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00150.jpg" class="calibre2"/><a id="filepos742830"></a></p><div class="calibre_7"> </div>
<p class="calibre_2">Recall from <code class="calibre6"><span class="calibre7">tick_periodic()</span></code> that the value of <code class="calibre6"><span class="calibre7">user_tick</span></code> is set by looking at the system’s registers:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">update_process_times(user_mode(get_irq_regs()));</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">account_process_tick()</span></code> function does the actual updating of the process’s times:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00151.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">You might realize that this approach implies that the kernel credits a process for running the <em class="calibre4">entire</em> previous tick in whatever mode the processor was in when the timer interrupt occurred. In reality, the process might have entered and exited kernel mode many times during the last tick. In fact, the process might not even have been the only process running in the last tick! This granular process accounting is classic Unix, and without much more complex accounting, this is the best the kernel can provide. It is also another reason for a higher frequency tick rate.</p><div class="calibre_3"> </div>
<p class="calibre_2">Next, the <code class="calibre6"><span class="calibre7">run_local_timers()</span></code> function marks a softirq (see <a href="index_split_017.html#filepos487358">Chapter 8</a>, “Bottom Halves and Deferring Work”) to handle the execution of any expired timers. Timers are covered in a following section, “<a href="#filepos750353">Timers</a>.”</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, the <code class="calibre6"><span class="calibre7">scheduler_tick()</span></code> function decrements the currently running process’s timeslice and sets <code class="calibre6"><span class="calibre7">need_resched</span></code> if needed. On SMP machines, it also balances the per-processor runqueues as needed. This is discussed in <a href="index_split_013.html#filepos223287">Chapter 4</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos744940"></a>The <code class="calibre6"><span class="calibre7">tick_periodic()</span></code> function returns to the original architecture-dependent interrupt handler, which performs any needed cleanup, releases the <code class="calibre6"><span class="calibre7">xtime_lock</span></code> lock, and finally returns.</p><div class="calibre_3"> </div>
<p class="calibre_2">All this occurs every <code class="calibre6"><span class="calibre7">1/HZ</span></code> of a second. That is potentially <em class="calibre4">100</em> or <em class="calibre4">1,000</em> times per second on an x86 machine!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos745453"> </div>
<h3 class="calibre_21"><span class="bold">The Time of Day</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The current time of day (the wall time) is defined in <code class="calibre6"><span class="calibre7">kernel/time/timekeeping.c</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct timespec xtime;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">timespec</span></code> data structure is defined in <code class="calibre6"><span class="calibre7">&lt;linux/time.h&gt;</span></code> as:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00152.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">xtime.tv_sec</span></code> value stores the number of seconds that have elapsed since January 1, 1970 (UTC). This date is called the <em class="calibre4">epoch</em>. Most Unix systems base their notion of the current wall time as relative to this epoch. The <code class="calibre6"><span class="calibre7">xtime.v_nsec</span></code> value stores the number of nanoseconds that have elapsed in the last second.</p><div class="calibre_3"> </div>
<p class="calibre_2">Reading or writing the <code class="calibre6"><span class="calibre7">xtime</span></code> variable requires the <code class="calibre6"><span class="calibre7">xtime_lock</span></code> lock, which is <em class="calibre4">not</em> a normal spinlock but a <em class="calibre4">seqlock</em>. <a href="index_split_019.html#filepos613760">Chapter 10</a>, “Kernel Synchronization Methods,” discusses seqlocks.</p><div class="calibre_3"> </div>
<p class="calibre_2">To update <code class="calibre6"><span class="calibre7">xtime</span></code>, a write seqlock is required:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">write_seqlock(&amp;xtime_lock);<br class="calibre1"/><br class="calibre1"/>/* update xtime ... */<br class="calibre1"/><br class="calibre1"/>write_sequnlock(&amp;xtime_lock);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Reading <code class="calibre6"><span class="calibre7">xtime</span></code> requires the use of the <code class="calibre6"><span class="calibre7">read_seqbegin()</span></code> and <code class="calibre6"><span class="calibre7">read_seqretry()</span></code> functions:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00153.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos747603"></a>This loop repeats until the reader is assured that it read the data without an intervening write. If the timer interrupt occurred and updated <code class="calibre6"><span class="calibre7">xtime</span></code> during the loop, the returned sequence number is invalid and the loop repeats.</p><div class="calibre_3"> </div>
<p class="calibre_2">The primary user-space interface for retrieving the wall time is <code class="calibre6"><span class="calibre7">gettimeofday()</span></code>, which is implemented as <code class="calibre6"><span class="calibre7">sys_gettimeofday()</span></code> in <code class="calibre6"><span class="calibre7">kernel/time.c</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00154.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">If the user provided a non-<code class="calibre6"><span class="calibre7">NULL tv</span></code> value, the architecture-dependent <code class="calibre6"><span class="calibre7">do_gettimeofday()</span></code> is called. This function primarily performs the <code class="calibre6"><span class="calibre7">xtime</span></code> read loop previously discussed. Likewise, if <code class="calibre6"><span class="calibre7">tz</span></code> is non-<code class="calibre6"><span class="calibre7">NULL</span></code>, the system time zone (stored in <code class="calibre6"><span class="calibre7">sys_tz</span></code>) is returned to the user. If there were errors copying the wall time or time zone back to user-space, the function returns <code class="calibre6"><span class="calibre7">-EFAULT</span></code>. Otherwise, it returns zero for success.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel also implements the <code class="calibre6"><span class="calibre7">time()</span></code><sup class="calibre8"><a id="filepos749085" href="#filepos749450">5</a></sup> system call, but <code class="calibre6"><span class="calibre7">gettimeofday()</span></code> largely supersedes it. The C library also provides other wall time–related library calls, such as <code class="calibre6"><span class="calibre7">ftime()</span></code> and <code class="calibre6"><span class="calibre7">ctime()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos749450" href="#filepos749085">5</a></sup>
<em class="calibre4">Some architectures, however, do not implement</em>
<code class="calibre6"><span class="calibre7">sys_time()</span></code>
<em class="calibre4">and instead specify that it is emulated in the C library through the use of</em>
<code class="calibre6"><span class="calibre7">gettimeofday()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">settimeofday()</span></code> system call sets the wall time to the specified value. It requires the <code class="calibre6"><span class="calibre7">CAP_SYS_TIME</span></code> capability.</p><div class="calibre_3"> </div>
<p class="calibre_2">Other than updating <code class="calibre6"><span class="calibre7">xtime</span></code>, the kernel does not make nearly as frequent use of the current wall time as user-space does. One notable exception is in the filesystem code, which stores various timestamps (accessed, modified, and so on) in inodes.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos750353"> </div>
<h3 class="calibre_21"><span class="bold">Timers</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos750462"> </div>
<p class="calibre_2"><em class="calibre4">Timers</em>—sometimes called <em class="calibre4">dynamic timers</em> or <em class="calibre4">kernel timers</em>—are essential for managing the flow of time in kernel code. Kernel code often needs to delay execution of some function until a later time. In previous chapters, we looked at using the bottom-half mechanisms, which are great for deferring work until later. Unfortunately, the definition of <em class="calibre4">later</em> is intentionally quite vague. The purpose of bottom halves is not so much to <em class="calibre4">delay work</em>, but simply to <em class="calibre4">not do the work now</em>. What we need is a tool for delaying work a specified amount of time—certainly no less, and with hope, not much longer. The solution is kernel timers.</p><div class="calibre_3"> </div>
<p class="calibre_2">A timer is easy to use. You perform some initial setup, specify an expiration time, specify a function to execute upon said expiration, and activate the timer. The given function runs after the timer expires. Timers are <em class="calibre4">not</em> cyclic. The timer is destroyed after it expires. This is one reason for the <em class="calibre4">dynamic</em> nomenclature: Timers are constantly created and destroyed, and there is no limit on the number of timers. Timers are popular throughout the entire kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos751792"> </div>
<h4 class="calibre_27"><span class="calibre3">Using Timers</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Timers are represented by <code class="calibre6"><span class="calibre7">struct timer_list</span></code>, which is defined in <code class="calibre6"><span class="calibre7">&lt;linux/timer.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00155.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Fortunately, the usage of timers requires little understanding of this data structure. Toying with it is discouraged to keep code forward compatible with changes. The kernel provides a family of timer-related interfaces to make timer management easy. Everything is declared in <code class="calibre6"><span class="calibre7">&lt;linux/timer.h&gt;</span></code>. Most of the actual implementation is in <code class="calibre6"><span class="calibre7">kernel/timer.c</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The first step in creating a timer is defining it:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct timer_list my_timer;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Next, the timer’s internal values must be initialized. This is done via a helper function and must be done prior to calling <em class="calibre4">any</em> timer management functions on the timer:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">init_timer(&amp;my_timer);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Now you fill out the remaining values as required:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00156.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos753461"></a>The <code class="calibre6"><span class="calibre7">my_timer.expires</span></code> value specifies the timeout value in absolute ticks. When the current <code class="calibre6"><span class="calibre7">jiffies</span></code> count is equal to or greater than <code class="calibre6"><span class="calibre7">my_timer.expires</span></code>, the handler function <code class="calibre6"><span class="calibre7">my_timer.function</span></code> is run with the lone argument of <code class="calibre6"><span class="calibre7">my_timer.data</span></code>. As you can see from the <code class="calibre6"><span class="calibre7">timer_list</span></code> definition, the function must match this prototype:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void my_timer_function(unsigned long data);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">data</span></code> parameter enables you to register multiple timers with the same handler, and differentiate between them via the argument. If you do not need the argument, you can simply pass zero (or any other value).</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, you activate the timer:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">add_timer(&amp;my_timer);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">And, voila, the timer is off and running! Note the significance of the <code class="calibre6"><span class="calibre7">expired</span></code> value. The kernel runs the timer handler when the current tick count is <em class="calibre4">equal to or greater than</em> the specified expiration. Although the kernel guarantees to run no timer handler <em class="calibre4">prior</em> to the timer’s expiration, there may be a delay in running the timer. Typically, timers are run fairly close to their expiration; however, they might be delayed until the first timer tick after their expiration. Consequently, timers cannot be used to implement any sort of hard real-time processing.</p><div class="calibre_3"> </div>
<p class="calibre_2">Sometimes you might need to modify the expiration of an already active timer. The kernel implements a function, <code class="calibre6"><span class="calibre7">mod_timer()</span></code>, which changes the expiration of a given timer:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">mod_timer(&amp;my_timer, jiffies + new_delay);  /* new expiration */</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">mod_timer()</span></code> function can operate on timers that are initialized but not active, too. If the timer is inactive, <code class="calibre6"><span class="calibre7">mod_timer()</span></code> activates it. The function returns zero if the timer were inactive and one if the timer were active. In either case, upon return from <code class="calibre6"><span class="calibre7">mod_timer()</span></code>, the timer is activated and set to the new expiration.</p><div class="calibre_3"> </div>
<p class="calibre_2">If you need to deactivate a timer prior to its expiration, use the <code class="calibre6"><span class="calibre7">del_timer()</span></code> function:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">del_timer(&amp;my_timer);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The function works on both active and inactive timers. If the timer is already inactive, the function returns zero; otherwise, the function returns one. Note that you do <em class="calibre4">not</em> need to call this for timers that have expired because they are automatically deactivated.</p><div class="calibre_3"> </div>
<p class="calibre_2">A potential race condition that must be guarded against exists when deleting timers. When <code class="calibre6"><span class="calibre7">del_timer()</span></code> returns, it guarantees only that the timer is no longer active (that is, that it will not be executed in the future). On a multiprocessing machine, however, the timer handler might already be executing on another processor. To deactivate the timer and wait until a potentially executing handler for the timer exits, use <code class="calibre6"><span class="calibre7">del_timer_sync()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">del_timer_sync(&amp;my_timer);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Unlike <code class="calibre6"><span class="calibre7">del_timer()</span></code>, <code class="calibre6"><span class="calibre7">del_timer_sync()</span></code> cannot be used from interrupt context.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos757807"> </div>
<h4 class="calibre_27"><span class="calibre3">Timer Race Conditions</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos757930"> </div>
<p class="calibre_2">Because timers run asynchronously with respect to the currently executing code, several potential race conditions exist. First, never do the following as a substitute for a mere <code class="calibre6"><span class="calibre7">mod_timer()</span></code>, because this is unsafe on multiprocessing machines:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">del_timer(my_timer)<br class="calibre1"/>my_timer-&gt;expires = jiffies + new_delay;<br class="calibre1"/>add_timer(my_timer);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Second, in almost all cases, you should use <code class="calibre6"><span class="calibre7">del_timer_sync()</span></code> over <code class="calibre6"><span class="calibre7">del_timer()</span></code>. Otherwise, you cannot assume the timer is not currently running, and that is why you made the call in the first place! Imagine if, after deleting the timer, the code went on to free or otherwise manipulate resources used by the timer handler. Therefore, the synchronous version is preferred.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, you must make sure to protect any shared data used in the timer handler function. The kernel runs the function asynchronously with respect to other code. Data with a timer should be protected as discussed in <a href="index_split_017.html#filepos487358">Chapters 8</a> and <a href="index_split_018.html#filepos575425">9</a>, “An Introduction to Kernel Synchronization.”</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos759391"> </div>
<h4 class="calibre_27"><span class="calibre3">Timer Implementation</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The kernel executes timers in bottom-half context, as softirqs, after the timer interrupt completes. The timer interrupt handler runs <code class="calibre6"><span class="calibre7">update_process_times()</span></code>, which calls <code class="calibre6"><span class="calibre7">run_local_timers()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00157.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">TIMER_SOFTIRQ</span></code> softirq is handled by <code class="calibre6"><span class="calibre7">run_timer_softirq()</span></code>. This function runs all the expired timers (if any) on the current processor.</p><div class="calibre_3"> </div>
<p class="calibre_2">Timers are stored in a linked list. However, it would be unwieldy for the kernel to either constantly traverse the entire list looking for expired timers, or keep the list sorted by expiration value; the insertion and deletion of timers would then become expensive. Instead, the kernel partitions timers into five groups based on their expiration value. Timers move down through the groups as their expiration time draws closer. The partitioning ensures that, in most executions of the timer softirq, the kernel has to do little work to find the expired timers. Consequently, the timer management code is efficient.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos760835"> </div>
<h3 class="calibre_21"><span class="bold">Delaying Execution</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos760956"> </div>
<p class="calibre_2">Often, kernel code (especially drivers) needs a way to delay execution for some time without using timers or a bottom-half mechanism. This is usually to enable hardware time to complete a given task. The time is typically quite short. For example, the specifications for a network card might list the time to change Ethernet modes as two microseconds. After setting the desired speed, the driver should wait at least the two microseconds before continuing.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel provides a number of solutions, depending on the semantics of the delay. The solutions have different characteristics. Some hog the processor while delaying—effectively preventing—the accomplishment of any real work. Other solutions do not hog the processor but offer no guarantee that your code will resume in exactly the required time.<sup class="calibre8"><a id="filepos761879" href="#filepos761982">6</a></sup></p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos761982" href="#filepos761879">6</a></sup>
<em class="calibre4">Actually, no approach guarantees that the delay will be for</em> exactly <em class="calibre4">the time requested. Some come extremely close, however, and they all promise to wait</em> at least <em class="calibre4">as long as needed. Some just wait longer.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos762315"> </div>
<h4 class="calibre_27"><span class="calibre3">Busy Looping</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The simplest solution to implement (although rarely the optimal solution) is <em class="calibre4">busy waiting</em> or <em class="calibre4">busy looping</em>. This technique works only when the time you want to delay is some integer multiple of the tick rate or precision is not important.</p><div class="calibre_3"> </div>
<p class="calibre_2">The idea is simple: Spin in a loop until the desired number of clock ticks pass. For example</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00158.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The loop continues until <code class="calibre6"><span class="calibre7">jiffies</span></code> is larger than <code class="calibre6"><span class="calibre7">delay</span></code>, which occurs only after 10 clock ticks have passed. On x86 with <code class="calibre6"><span class="calibre7">HZ</span></code> equal to 1,000, this results in a wait of 10 milliseconds. Similarly</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00159.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This spins until <code class="calibre6"><span class="calibre7">2*HZ</span></code> clock ticks has passed, which is always two seconds regardless of the clock rate.</p><div class="calibre_3"> </div>
<p class="calibre_2">This approach is not nice to the rest of the system. While your code waits, the processor is tied up spinning in a silly loop—no useful work is accomplished! You rarely want to take this brain-dead approach, and it is shown here because it is a clear and simple method for delaying execution. You might also encounter it in someone else’s not-so-pretty code.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos764010"></a>A better solution would be to reschedule your process to allow the processor to accomplish other work while your code waits:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">unsigned long delay = jiffies + 5*HZ;<br class="calibre1"/><br class="calibre1"/>while (time_before(jiffies, delay))<br class="calibre1"/>        cond_resched();</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The call to <code class="calibre6"><span class="calibre7">cond_resched()</span></code> schedules a new process, but only if <code class="calibre6"><span class="calibre7">need_resched</span></code> is set. In other words, this solution conditionally invokes the scheduler only if there is some more important task to run. Note that because this approach invokes the scheduler, you cannot make use of it from an interrupt handler—only from process context. All these approaches are best used from process context, because interrupt handlers should execute as quickly as possible. (And busy looping does not help accomplish that goal!) Furthermore, delaying execution in any manner, if at all possible, should not occur while a lock is held or interrupts are disabled.</p><div class="calibre_3"> </div>
<p class="calibre_2">C aficionados might wonder what guarantee is given that the previous loops even work. The C compiler is usually free to perform a given load only once. Normally, no assurance is given that the <code class="calibre6"><span class="calibre7">jiffies</span></code> variable in the loop’s conditional statement is even reloaded on each loop iteration. The kernel requires, however, that <code class="calibre6"><span class="calibre7">jiffies</span></code> be reread on each iteration, as the value is incremented elsewhere: in the timer interrupt. Indeed, this is why the variable is marked <code class="calibre6"><span class="calibre7">volatile</span></code> in <code class="calibre6"><span class="calibre7">&lt;linux/jiffies.h&gt;</span></code>. The <code class="calibre6"><span class="calibre7">volatile</span></code> keyword instructs the compiler to reload the variable on each access from main memory and never alias the variable’s value in a register, guaranteeing that the previous loop completes as expected.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos766159"> </div>
<h4 class="calibre_27"><span class="calibre3">Small Delays</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Sometimes, kernel code (again, usually drivers) requires short (smaller than a clock tick) and rather precise delays. This is often to synchronize with hardware, which again usually lists some minimum time for an activity to complete—often less than a millisecond. It would be impossible to use <code class="calibre6"><span class="calibre7">jiffies</span></code>-based delays, as in the previous examples, for such a short wait. With a timer interrupt of 100Hz, the clock tick is a rather large 10 milliseconds! Even with a 1,000Hz timer interrupt, the clock tick is still one millisecond. Another solution is clearly necessary for smaller, more precise delays.</p><div class="calibre_3"> </div>
<p class="calibre_2">Thankfully, the kernel provides three functions for microsecond, nanosecond, and millisecond delays, defined in <code class="calibre6"><span class="calibre7">&lt;linux/delay.h&gt;</span></code> and <code class="calibre6"><span class="calibre7">&lt;asm/delay.h&gt;</span></code>, which do not use <code class="calibre6"><span class="calibre7">jiffies</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void udelay(unsigned long usecs)<br class="calibre1"/>void ndelay(unsigned long nsecs)<br class="calibre1"/>void mdelay(unsigned long msecs)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The former function delays execution by busy looping for the specified number of <em class="calibre4">microseconds</em>. The latter function delays execution for the specified number of <em class="calibre4">milliseconds</em>. <a id="filepos767707"></a>Recall one second equals 1,000 milliseconds, which equals 1,000,000 microseconds. Usage is trivial:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">udelay(150);        /* delay for 150 μs */</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">udelay()</span></code> function is implemented as a loop that knows how many iterations can be executed in a given period of time. The <code class="calibre6"><span class="calibre7">mdelay()</span></code> function is then implemented in terms of <code class="calibre6"><span class="calibre7">udelay()</span></code>. Because the kernel knows how many loops the processor can complete in a second (see the sidebar on BogoMIPS), the <code class="calibre6"><span class="calibre7">udelay()</span></code> function simply scales that value to the correct number of loop iterations for the given delay.</p><div class="calibre_3"> </div>
<div border="1" class="calibre_26"><blockquote class="calibre10"><div class="calibre11">
<p class="calibre_2"></p><div class="calibre_3"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">My BogoMIPS Are Bigger Than Yours!</span></span></p><div class="calibre_24"> </div>
<p class="calibre_2">The BogoMIPS value has always been a source of confusion and humor. In reality, the BogoMIPS calculation has little to do with the performance of your computer and is primarily used only for the <code class="calibre6"><span class="calibre7">udelay()</span></code> and <code class="calibre6"><span class="calibre7">mdelay()</span></code> functions. Its name is a contraction of <em class="calibre4">bogus</em> (that is, fake) and <em class="calibre4">MIPS</em> (million of instructions per second). Everyone is familiar with a boot message similar to the following (this is on a 2.4GHz 7300-series Intel Xeon):</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">Detected 2400.131 MHz processor.<br class="calibre1"/>Calibrating delay loop... 4799.56 BogoMIPS</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The BogoMIPS value is the number of busy loop iterations the processor can perform in a given period. In effect, BogoMIPS are a measurement of how fast a processor can do nothing! This value is stored in the <code class="calibre6"><span class="calibre7">loops_per_jiffy</span></code> variable and is readable from <code class="calibre6"><span class="calibre7">/proc/cpuinfo</span></code>. The delay loop functions use the <code class="calibre6"><span class="calibre7">loops_per_jiffy</span></code> value to figure out (fairly precisely) how many busy loop iterations they need to execute to provide the requisite delay.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel computes <code class="calibre6"><span class="calibre7">loops_per_jiffy</span></code> on boot via <code class="calibre6"><span class="calibre7">calibrate_delay()</span></code> in <code class="calibre6"><span class="calibre7">init/main.c</span></code>.</p><div class="calibre_3"> </div>
</div></blockquote></div><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">udelay()</span></code> function should be called only for small delays because larger delays on fast machines might result in overflow. As a rule, do not use <code class="calibre6"><span class="calibre7">udelay()</span></code> for delays more than one millisecond in duration. For longer durations, <code class="calibre6"><span class="calibre7">mdelay()</span></code> works fine. Like the other busy waiting solutions for delaying execution, neither of these functions (especially <code class="calibre6"><span class="calibre7">mdelay()</span></code>, because it is used for such long delays) should be used unless absolutely needed. Remember that it is rude to busy loop with locks held or interrupts disabled because system response and performance will be adversely affected. If you require precise delays, however, these calls are your best bet. Typical uses of these busy waiting functions delay for a small amount of time, usually in the microsecond range.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos771497"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">schedule_timeout()</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">A more optimal method of delaying execution is to use <code class="calibre6"><span class="calibre7">schedule_timeout()</span></code>. This call puts your task to sleep until at least the specified time has elapsed. There is no guarantee that the sleep duration will be <em class="calibre4">exactly</em> the specified time—only that the duration is at least as long as specified. When the specified time has elapsed, the kernel wakes the task up and places it back on the runqueue. Usage is easy:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">/* set task's state to interruptible sleep */<br class="calibre1"/>set_current_state(TASK_INTERRUPTIBLE);<br class="calibre1"/><br class="calibre1"/>/* take a nap and wake up in "s" seconds */<br class="calibre1"/>schedule_timeout(s * HZ);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The lone parameter is the desired relative timeout, in jiffies. This example puts the task in interruptible sleep for <code class="calibre6"><span class="calibre7">s</span></code> seconds. Because the task is marked <code class="calibre6"><span class="calibre7">TASK_INTERRUPTIBLE</span></code>, it wakes up prematurely if it receives a signal. If the code does not want to process signals, you can use <code class="calibre6"><span class="calibre7">TASK_UNINTERRUPTIBLE</span></code> instead. The task must be in one of these two states before <code class="calibre6"><span class="calibre7">schedule_timeout()</span></code> is called or else the task will not go to sleep.</p><div class="calibre_3"> </div>
<p class="calibre_2">Note that because <code class="calibre6"><span class="calibre7">schedule_timeout()</span></code> invokes the scheduler, code that calls it must be capable of sleeping. See <a href="index_split_017.html#filepos487358">Chapters 8</a> and <a href="index_split_018.html#filepos575425">9</a> for discussions on atomicity and sleeping. In short, you must be in process context and must not hold a lock.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos773436"> </div>
<h5 class="calibre_29"><span class="calibre3"><code class="calibre6"><span class="calibre11">schedule_timeout()</span></code> Implementation</span></h5><div class="calibre_24"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">schedule_timeout()</span></code> function is fairly straightforward. Indeed, it is a simple application of kernel timers, so let’s take a look at it:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00160.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_31"><img alt="image" src="images/00161.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos774013"></a>The function creates a timer with the original name <code class="calibre6"><span class="calibre7">timer</span></code> and sets it to expire in <code class="calibre6"><span class="calibre7">timeout</span></code> clock ticks in the future. It sets the timer to execute the <code class="calibre6"><span class="calibre7">process_timeout()</span></code> function when the timer expires. It then enables the timer and calls <code class="calibre6"><span class="calibre7">schedule()</span></code>. Because the task is supposedly marked <code class="calibre6"><span class="calibre7">TASK_INTERRUPTIBLE</span></code> or <code class="calibre6"><span class="calibre7">TASK_UNINTERRUPTIBLE</span></code>, the scheduler does <em class="calibre4">not</em> run the task, but instead picks a new one.</p><div class="calibre_3"> </div>
<p class="calibre_2">When the timer expires, it runs <code class="calibre6"><span class="calibre7">process_timeout()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void process_timeout(unsigned long data)<br class="calibre1"/>{<br class="calibre1"/>        wake_up_process((task_t *) data);<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function puts the task in the <code class="calibre6"><span class="calibre7">TASK_RUNNING</span></code> state and places it back on the runqueue.</p><div class="calibre_3"> </div>
<p class="calibre_2">When the task reschedules, it returns to where it left off in <code class="calibre6"><span class="calibre7">schedule_timeout()</span></code> (right after the call to <code class="calibre6"><span class="calibre7">schedule()</span></code>). In case the task was awakened prematurely (if a signal was received), the timer is destroyed. The function then returns the time slept.</p><div class="calibre_3"> </div>
<p class="calibre_2">The code in the <code class="calibre6"><span class="calibre7">switch()</span></code> statement is for special cases and is not part of the general usage of the function. The <code class="calibre6"><span class="calibre7">MAX_SCHEDULE_TIMEOUT</span></code> check enables a task to sleep indefinitely. In that case, no timer is set (because there is no bound on the sleep duration), and the scheduler is immediately invoked. If you do this, you must have another method of waking your task up!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos776098"> </div>
<h5 class="calibre_29"><span class="calibre3">Sleeping on a Wait Queue, with a Timeout</span></h5><div class="calibre_24"> </div>
<p class="calibre_2"><a href="index_split_013.html#filepos223287">Chapter 4</a> looked at how process context code in the kernel can place itself on a wait queue to wait for a specific event and then invoke the scheduler to select a new task. Elsewhere, when the event finally occurs, <code class="calibre6"><span class="calibre7">wake_up()</span></code> is called, and the tasks sleeping on the wait queue are awakened and can continue running.</p><div class="calibre_3"> </div>
<p class="calibre_2">Sometimes it is desirable to wait for a specific event <em class="calibre4">or</em> wait for a specified time to elapse—whichever comes first. In those cases, code might simply call <code class="calibre6"><span class="calibre7">schedule_timeout()</span></code> instead of <code class="calibre6"><span class="calibre7">schedule()</span></code> after placing itself on a wait queue. The task wakes up when the desired event occurs or the specified time elapses. The code needs to check <em class="calibre4">why</em> it woke up—it might be because of the event occurring, the time elapsing, or a received signal—and continue as appropriate.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos777290"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">In this chapter, we looked at the kernel’s concept of time and how both wall time and uptime are managed. We contrasted relative time with absolute time and absolute events with periodic events. We then covered time concepts such as the timer interrupt, timer ticks, <code class="calibre6"><span class="calibre7">HZ</span></code>, and <code class="calibre6"><span class="calibre7">jiffies</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">We looked at the implementation of timers and how you can use them in your own kernel code. We finished the chapter with an overview of other methods developers can use to pass time.</p><div class="calibre_3"> </div>
<p class="calibre_2">Much of the kernel code that you write will require some understanding of time and its passing. With high probability—especially if you hack on drivers—you will need to deal with kernel timers. Reading this chapter is good for more than just passing the time.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_57"></div>
</body></html>
