<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 4. File I/O: The Universal I/O Model</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch03.html" title="Chapter 3. System Programming Concepts"/><link rel="next" href="ch05.html" title="Chapter 5. File I/O: Further Details"/></head><body><section class="chapter" title="Chapter 4. File I/O: The Universal I/O Model" epub:type="chapter" id="file_i_solidus_o_colon_the_universal_i_s"><div class="titlepage"><div><div><h2 class="title">Chapter 4. File I/O: The Universal I/O Model</h2></div></div></div><p>We now start to look in earnest at the system call API. Files are a good place to
            start, since they are central to the UNIX philosophy. The focus of this chapter is the
            system calls used for performing file input and output.</p><p>We introduce the concept of a file descriptor, and then look at the system calls that
            constitute the so-called universal I/O model. These are the system calls that open and
            close a file, and read and write data.<a id="IDX-CHP-4-0553" class="indexterm"/></p><p>We focus on I/O on disk files. However, much of the material covered here is relevant
            for later chapters, since the same system calls are used for performing I/O on all types
            of files, such as pipes and terminals.</p><p><a class="xref" href="ch05.html" title="Chapter 5. File I/O: Further Details">Chapter 5</a> extends the discussion in
            this chapter with further details on file I/O. One other aspect of file I/O, buffering,
            is complex enough to deserve its own chapter. <a class="xref" href="ch13.html" title="Chapter 13. File I/O Buffering">Chapter 13</a> covers I/O buffering in the kernel and in the <span class="emphasis"><em>stdio</em></span>
            library.</p><div class="sect1" title="Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="overview">Overview</h2></div></div></div><p>All system calls for performing I/O refer to open files using a <span class="emphasis"><em>file
                    descriptor</em></span>, a (usually small) nonnegative integer. File descriptors
                are used to refer to all types of open files, including pipes, FIFOs, sockets,
                terminals, devices, and regular files. Each process has its own set of file
                    descriptors.<a id="IDX-CHP-4-0554" class="indexterm"/><a id="IDX-CHP-4-0555" class="indexterm"/><a id="IDX-CHP-4-0556" class="indexterm"/><a id="IDX-CHP-4-0557" class="indexterm"/><a id="IDX-CHP-4-0558" class="indexterm"/><a id="IDX-CHP-4-0559" class="indexterm"/><a id="IDX-CHP-4-0560" class="indexterm"/><a id="IDX-CHP-4-0561" class="indexterm"/></p><p>By convention, most programs expect to be able to use the three standard file
                descriptors listed in <a class="xref" href="ch04.html#standard_file_descriptors" title="Table 4-1. Standard file descriptors">Table 4-1</a>. These three
                descriptors are opened on the program’s behalf by the shell, before the program is
                started. Or, more precisely, the program inherits copies of the shell’s file
                descriptors, and the shell normally operates with these three file descriptors
                always open. (In an interactive shell, these three file descriptors normally refer
                to the terminal under which the shell is running.) If I/O redirections are specified
                on a command line, then the shell ensures that the file descriptors are suitably
                modified before starting the program.</p><div class="table"><a id="standard_file_descriptors"/><div class="table-title">Table 4-1. Standard file descriptors</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>File descriptor</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Purpose</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>POSIX name</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p><span class="emphasis"><em>stdio</em></span> stream</p>
                            </td></tr></thead><tbody><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>0</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>standard input</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">STDIN_FILENO</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>stdin</em></span>
                                </p>
                            </td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>1</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>standard output</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">STDOUT_FILENO</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>stdout</em></span>
                                </p>
                            </td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>2</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>standard error</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">STDERR_FILENO</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>
                                    <span class="emphasis"><em>stderr</em></span>
                                </p>
                            </td></tr></tbody></table></div></div><p>When referring to these file descriptors in a program, we can use either the
                numbers (0, 1, or 2) or, preferably, the POSIX standard names defined in <code class="literal">&lt;unistd.h&gt;</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although the variables <span class="emphasis"><em>stdin</em></span>,
                    <span class="emphasis"><em>stdout</em></span>, and <span class="emphasis"><em>stderr</em></span> initially refer to
                    the process’s standard input, output, and error, they can be changed to refer to
                    any file by using the <span class="emphasis"><em>freopen()</em></span> library function. As part
                    of its operation, <span class="emphasis"><em>freopen()</em></span> may change the file descriptor
                    underlying the reopened stream. In other words, after an
                        <span class="emphasis"><em>freopen()</em></span> on <span class="emphasis"><em>stdout</em></span>, for example,
                    it is no longer safe to assume that the underlying file descriptor is still
                    1.</p></div><p>The following are the four key system calls for performing file I/O (programming
                languages and software packages typically employ these calls only indirectly, via
                I/O libraries):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>fd = open (pathname, flags, mode)</em></span> opens the file
                        identified by <span class="emphasis"><em>pathname</em></span>, returning a file descriptor
                        used to refer to the open file in subsequent calls. If the file doesn’t
                        exist, <span class="emphasis"><em>open()</em></span> may create it, depending on the settings
                        of the <span class="emphasis"><em>flags</em></span> bit-mask argument. The
                            <span class="emphasis"><em>flags</em></span> argument also specifies whether the file is
                        to be opened for reading, writing, or both. The <span class="emphasis"><em>mode</em></span>
                        argument specifies the permissions to be placed on the file if it is created
                        by this call. If the <span class="emphasis"><em>open()</em></span> call is not being used to
                        create a file, this argument is ignored and can be omitted.<a id="IDX-CHP-4-0562" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>numread = read (fd, buffer, count)</em></span> reads at most
                            <span class="emphasis"><em>count</em></span> bytes from the open file referred to by
                            <span class="emphasis"><em>fd</em></span> and stores them in <span class="emphasis"><em>buffer</em></span>.
                        The <span class="emphasis"><em>read()</em></span> call returns the number of bytes actually
                        read. If no further bytes could be read (i.e., end-of-file was encountered),
                            <span class="emphasis"><em>read()</em></span> returns 0.<a id="IDX-CHP-4-0563" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>numwritten = write (fd, buffer, count)</em></span> writes up to
                            <span class="emphasis"><em>count</em></span> bytes from <span class="emphasis"><em>buffer</em></span> to the
                        open file referred to by <span class="emphasis"><em>fd</em></span>. The
                            <span class="emphasis"><em>write()</em></span> call returns the number of bytes actually
                        written, which may be less than <span class="emphasis"><em>count</em></span>.<a id="IDX-CHP-4-0564" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>status = close (fd)</em></span> is called after all I/O has been
                        completed, in order to release the file descriptor <span class="emphasis"><em>fd</em></span>
                        and its associated kernel resources.</p></li></ul></div><p>Before we launch into the details of these system calls, we provide a short
                demonstration of their use in <a class="xref" href="ch04.html#using_i_solidus_o_system_calls" title="Example 4-1. Using I/O system calls">Example 4-1</a>. This
                program is a simple version of the <span class="emphasis"><em>cp(1)</em></span> command. It copies the
                contents of the existing file named in its first command-line argument to the new
                file named in its second command-line argument.</p><p>We can use the program in <a class="xref" href="ch04.html#using_i_solidus_o_system_calls" title="Example 4-1. Using I/O system calls">Example 4-1</a> as
                follows:</p><a id="I_programlisting4_d1e7980"/><pre class="programlisting"><strong class="userinput"><code>$ ./copy oldfile newfile</code></strong></pre><div class="example"><a id="using_i_solidus_o_system_calls"/><div class="example-title">Example 4-1. Using I/O system calls</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>fileio/copy.c</code></strong>
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include "tlpi_hdr.h"

#ifndef BUF_SIZE        /* Allow "cc -D" to override definition */
#define BUF_SIZE 1024
#endif

int
main(int argc, char *argv[])
{
    int inputFd, outputFd, openFlags;
    mode_t filePerms;
    ssize_t numRead;
    char buf[BUF_SIZE];

    if (argc != 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s old-file new-file\n", argv[0]);

    /* Open input and output files */

    inputFd = open(argv[1], O_RDONLY);
    if (inputFd == -1)
        errExit("opening file %s", argv[1]);

    openFlags = O_CREAT | O_WRONLY | O_TRUNC;
    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |
                S_IROTH | S_IWOTH;      /* rw-rw-rw- */
    outputFd = open(argv[2], openFlags, filePerms);
    if (outputFd == -1)
        errExit("opening file %s", argv[2]);

    /* Transfer data until we encounter end of input or an error */

    while ((numRead = read(inputFd, buf, BUF_SIZE)) &gt; 0)
        if (write(outputFd, buf, numRead) != numRead)
            fatal("couldn't write whole buffer");
    if (numRead == -1)
        errExit("read");

    if (close(inputFd) == -1)
        errExit("close input");
    if (close(outputFd) == -1)
        errExit("close output");

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>fileio/copy.c</code></strong></pre></div></div></div><div class="sect1" title="Universality of I/O"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="universality_of_i_solidus_o">Universality of I/O</h2></div></div></div><p>One of the distinguishing features of the UNIX I/O model is the concept of
                    <span class="emphasis"><em>universality of I/O</em></span>. This means that the same four system
                    calls—<span class="emphasis"><em>open()</em></span>, <span class="emphasis"><em>read()</em></span>,
                    <span class="emphasis"><em>write()</em></span>, and <span class="emphasis"><em>close()</em></span>—are used to
                perform I/O on all types of files, including devices such as terminals.
                Consequently, if we write a program using only these system calls, that program will
                work on any type of file. For example, the following are all valid uses of the
                program in <a class="xref" href="ch04.html#using_i_solidus_o_system_calls" title="Example 4-1. Using I/O system calls">Example 4-1</a>:<a id="IDX-CHP-4-0565" class="indexterm"/><a id="IDX-CHP-4-0566" class="indexterm"/></p><a id="I_programlisting4_d1e8023"/><pre class="programlisting"><strong class="userinput"><code>$ ./copy test test.old</code></strong>           <em class="lineannotation"><span class="lineannotation">Copy a regular file</span></em>
<strong class="userinput"><code>$ ./copy a.txt /dev/tty</code></strong>          <em class="lineannotation"><span class="lineannotation">Copy a regular file to this terminal</span></em>
<strong class="userinput"><code>$ ./copy /dev/tty b.txt</code></strong>          <em class="lineannotation"><span class="lineannotation">Copy input from this terminal to a regular file</span></em>
<strong class="userinput"><code>$ ./copy /dev/pts/16 /dev/tty</code></strong>    <em class="lineannotation"><span class="lineannotation">Copy input from another terminal</span></em></pre><p>Universality of I/O is achieved by ensuring that each file system and device
                driver implements the same set of I/O system calls. Because details specific to the
                file system or device are handled within the kernel, we can generally ignore
                device-specific factors when writing application programs. When access to specific
                features of a file system or device is required, a program can use the catchall
                    <span class="emphasis"><em>ioctl()</em></span> system call (<a class="xref" href="ch04.html#operations_outside_the_universal_i_solid" title="Operations Outside the Universal I/O Model: ioctl()">Operations Outside the Universal I/O Model: <span class="emphasis"><em>ioctl()</em></span></a>), which provides an
                interface to features that fall outside the universal I/O model.<a id="IDX-CHP-4-0567" class="indexterm"/></p></div><div class="sect1" title="Opening a File: open()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="opening_a_file_colon_open_open_parenthes">Opening a File: <span class="emphasis"><em>open()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>open()</em></span> system call either opens an existing file or
                creates and opens a new file.<a id="IDX-CHP-4-0568" class="indexterm"/><a id="IDX-CHP-4-0569" class="indexterm"/><a id="IDX-CHP-4-0570" class="indexterm"/><a id="IDX-CHP-4-0571" class="indexterm"/></p><a id="I_programlisting4_d1e8087"/><pre class="programlisting">#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int <strong class="userinput"><code>open</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>, int <span class="emphasis"><em>flags</em></span>, ... /* mode_t <span class="emphasis"><em>mode</em></span> */);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns file descriptor on success, or -1 on error</p></div><p>The file to be opened is identified by the <span class="emphasis"><em>pathname</em></span> argument.
                If <span class="emphasis"><em>pathname</em></span> is a symbolic link, it is dereferenced. On success,
                    <span class="emphasis"><em>open()</em></span> returns a file descriptor that is used to refer to
                the file in subsequent system calls. If an error occurs, <span class="emphasis"><em>open()</em></span>
                returns -1 and <span class="emphasis"><em>errno</em></span> is set accordingly.</p><p>The <span class="emphasis"><em>flags</em></span> argument is a bit mask that specifies the
                    <span class="emphasis"><em>access mode</em></span> for the file, using one of the constants shown
                in <a class="xref" href="ch04.html#file_access_modes" title="Table 4-2. File access modes">Table 4-2</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Early UNIX implementations used the numbers 0, 1, and 2 instead of the names
                    shown in <a class="xref" href="ch04.html#file_access_modes" title="Table 4-2. File access modes">Table 4-2</a>. Most modern UNIX implementations
                    define these constants to have those values. Thus, we can see that <code class="literal">O_RDWR</code> is not equivalent to <code class="literal">O_RDONLY | O_WRONLY</code>; the latter combination is a
                    logical error.</p></div><p>When <span class="emphasis"><em>open()</em></span> is used to create a new file, the
                    <span class="emphasis"><em>mode</em></span> bit-mask argument specifies the permissions to be
                placed on the file. (The <span class="emphasis"><em>mode_t</em></span> data type used to type
                    <span class="emphasis"><em>mode</em></span> is an integer type specified in SUSv3.) If the
                    <span class="emphasis"><em>open()</em></span> call doesn’t specify <code class="literal">O_CREAT</code>, <span class="emphasis"><em>mode</em></span> can be omitted.<a id="IDX-CHP-4-0572" class="indexterm"/></p><div class="table"><a id="file_access_modes"/><div class="table-title">Table 4-2. File access modes</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Access mode</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p>Description</p>
                            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">O_RDONLY</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Open the file for reading only</p>
                            </td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">O_WRONLY</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>Open the file for writing only</p>
                            </td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">O_RDWR</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>Open the file for both reading and writing</p>
                            </td></tr></tbody></table></div></div><p>We describe file permissions in detail in Section 15.4. Later, we’ll see that the
                permissions actually placed on a new file depend not just on the
                    <span class="emphasis"><em>mode</em></span> argument, but also on the process umask (<a class="xref" href="ch15.html#the_process_file_mode_creation_mask_colo" title="The Process File Mode Creation Mask: umask()">The Process File Mode Creation Mask: <span class="emphasis"><em>umask()</em></span></a>) and the (optionally
                present) default access control list (<a class="xref" href="ch17.html#default_acls_and_file_creation" title="Default ACLs and File Creation">Default ACLs and File Creation</a>) of the parent directory. In the meantime, we’ll just note that the
                    <span class="emphasis"><em>mode</em></span> argument can be specified as a number (typically in
                octal) or, preferably, by ORing (<code class="literal">|</code>) together zero
                or more of the bit-mask constants listed in <a class="xref" href="ch15.html#constants_for_file_permission_bits" title="Table 15-4. Constants for file permission bits">Table 15-4</a>, in <a class="xref" href="ch15.html#file_permissions" title="File Permissions">File Permissions</a>.</p><p><a class="xref" href="ch04.html#examples_of_the_use_of_open_open_parenth" title="Example 4-2. Examples of the use of open()">Example 4-2</a> shows examples of the
                use of <span class="emphasis"><em>open()</em></span>, some of which employ additional
                    <span class="emphasis"><em>flags</em></span> bits that we describe shortly.</p><div class="example"><a id="examples_of_the_use_of_open_open_parenth"/><div class="example-title">Example 4-2. Examples of the use of <span class="emphasis"><em>open()</em></span></div><div class="example-contents"><pre class="programlisting">/* Open existing file for reading */

    fd = open("startup", O_RDONLY);
    if (fd == -1)
        errExit("open");

    /* Open new or existing file for reading and writing, truncating to zero
       bytes; file permissions read+write for owner, nothing for all others */

    fd = open("myfile", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    if (fd == -1)
        errExit("open");

    /* Open new or existing file for writing; writes should always
       append to end of file */

    fd = open("w.log", O_WRONLY | O_CREAT | O_TRUNC | O_APPEND,
                       S_IRUSR | S_IWUSR);
    if (fd == -1)
        errExit("open");</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="file_descriptor_number_returned_by"/></div></div></div><div class="sect3" title="File descriptor number returned by open()"><div class="titlepage"><div><div><h4 class="title" id="file_descriptor_number_returned_by-id1">File descriptor number returned by <span class="emphasis"><em>open()</em></span></h4></div></div></div><p>SUSv3 specifies that if <span class="emphasis"><em>open()</em></span> succeeds, it is
                        guaranteed to use the lowest-numbered unused file descriptor for the
                        process. We can use this feature to ensure that a file is opened using a
                        particular file descriptor. For example, the following sequence ensures that
                        a file is opened using standard input (file descriptor 0).<a id="IDX-CHP-4-0573" class="indexterm"/><a id="IDX-CHP-4-0574" class="indexterm"/><a id="IDX-CHP-4-0575" class="indexterm"/><a id="IDX-CHP-4-0576" class="indexterm"/><a id="IDX-CHP-4-0577" class="indexterm"/></p><a id="I_programlisting4_d1e8287"/><pre class="programlisting">if (close(STDIN_FILENO) == -1)      /* Close file descriptor 0 */
    errExit("close");

fd = open(pathname, O_RDONLY);
if (fd == -1)
    errExit("open");</pre><p>Since file descriptor 0 is unused, <span class="emphasis"><em>open()</em></span> is
                        guaranteed to open the file using that descriptor. In <a class="xref" href="ch05.html#duplicating_file_descriptors" title="Duplicating File Descriptors">Duplicating File Descriptors</a>, we look at the use of
                            <span class="emphasis"><em>dup2()</em></span> and <span class="emphasis"><em>fcntl()</em></span> to achieve
                        a similar result, but with more flexible control over the file descriptor
                        used. In that section, we also show an example of why it can be useful to
                        control the file descriptor on which a file is opened.</p></div></div><div class="sect2" title="The open() flags Argument"><div class="titlepage"><div><div><h3 class="title" id="the_open_open_parenthesis_close_parenthe">The <span class="emphasis"><em>open() flags</em></span> Argument</h3></div></div></div><p>In some of the example <span class="emphasis"><em>open()</em></span> calls shown in <a class="xref" href="ch04.html#examples_of_the_use_of_open_open_parenth" title="Example 4-2. Examples of the use of open()">Example 4-2</a>, we included other bits
                        (<code class="literal">O_CREAT</code>, <code class="literal">O_TRUNC</code>, and <code class="literal">O_APPEND</code>) in
                        <span class="emphasis"><em>flags</em></span> in addition to the file access mode. We now
                    consider the <span class="emphasis"><em>flags</em></span> argument in more detail. <a class="xref" href="ch04.html#values_for_the_flags_argument_of_open_op" title="Table 4-3. Values for the flags argument of open()">Table 4-3</a> summarizes the full set
                    of constants that can be bit-wise ORed (<code class="literal">|</code>) in
                        <span class="emphasis"><em>flags</em></span>. The final column indicates which of these
                    constants are standardized in SUSv3 or SUSv4.<a id="IDX-CHP-4-0578" class="indexterm"/><a id="IDX-CHP-4-0579" class="indexterm"/><a id="IDX-CHP-4-0580" class="indexterm"/><a id="IDX-CHP-4-0581" class="indexterm"/><a id="IDX-CHP-4-0582" class="indexterm"/><a id="IDX-CHP-4-0583" class="indexterm"/><a id="IDX-CHP-4-0584" class="indexterm"/><a id="IDX-CHP-4-0585" class="indexterm"/><a id="IDX-CHP-4-0586" class="indexterm"/><a id="IDX-CHP-4-0587" class="indexterm"/><a id="IDX-CHP-4-0588" class="indexterm"/><a id="IDX-CHP-4-0589" class="indexterm"/><a id="IDX-CHP-4-0590" class="indexterm"/><a id="IDX-CHP-4-0591" class="indexterm"/><a id="IDX-CHP-4-0592" class="indexterm"/><a id="IDX-CHP-4-0593" class="indexterm"/><a id="IDX-CHP-4-0594" class="indexterm"/><a id="IDX-CHP-4-0595" class="indexterm"/><a id="IDX-CHP-4-0596" class="indexterm"/><a id="IDX-CHP-4-0597" class="indexterm"/><a id="IDX-CHP-4-0598" class="indexterm"/><a id="IDX-CHP-4-0599" class="indexterm"/><a id="IDX-CHP-4-0600" class="indexterm"/><a id="IDX-CHP-4-0601" class="indexterm"/><a id="IDX-CHP-4-0602" class="indexterm"/><a id="IDX-CHP-4-0603" class="indexterm"/><a id="IDX-CHP-4-0604" class="indexterm"/><a id="IDX-CHP-4-0605" class="indexterm"/><a id="IDX-CHP-4-0606" class="indexterm"/><a id="IDX-CHP-4-0607" class="indexterm"/><a id="IDX-CHP-4-0608" class="indexterm"/><a id="IDX-CHP-4-0609" class="indexterm"/><a id="IDX-CHP-4-0610" class="indexterm"/><a id="IDX-CHP-4-0611" class="indexterm"/><a id="IDX-CHP-4-0612" class="indexterm"/><a id="IDX-CHP-4-0613" class="indexterm"/><a id="IDX-CHP-4-0614" class="indexterm"/><a id="IDX-CHP-4-0615" class="indexterm"/><a id="IDX-CHP-4-0616" class="indexterm"/><a id="IDX-CHP-4-0617" class="indexterm"/><a id="IDX-CHP-4-0618" class="indexterm"/><a id="IDX-CHP-4-0619" class="indexterm"/><a id="IDX-CHP-4-0620" class="indexterm"/></p><div class="table"><a id="values_for_the_flags_argument_of_open_op"/><div class="table-title">Table 4-3. Values for the <span class="emphasis"><em>flags</em></span> argument of
                            <span class="emphasis"><em>open()</em></span></div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Flag</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Purpose</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                    <p>SUS?</p>
                                </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_RDONLY</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Open for reading only</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_WRONLY</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Open for writing only</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_RDWR</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Open for reading and writing</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_CLOEXEC</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Set the close-on-exec flag (since Linux 2.6.23)<a id="IDX-CHP-4-0621" class="indexterm"/></p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v4</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_CREAT</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Create file if it doesn’t already exist</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_DIRECT</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>File I/O bypasses buffer cache</p>
                                </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_DIRECTORY</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Fail if <span class="emphasis"><em>pathname</em></span> is not a
                                        directory</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v4</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_EXCL</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>With <span class="emphasis"><em>O_CREAT</em></span>: create file
                                        exclusively</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_LARGEFILE</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Used on 32-bit systems to open large files</p>
                                </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_NOATIME</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Don’t update file last access time on
                                            <span class="emphasis"><em>read()</em></span> (since Linux
                                            2.6.8)<a id="IDX-CHP-4-0622" class="indexterm"/></p>
                                </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_NOCTTY</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Don’t let <span class="emphasis"><em>pathname</em></span> become the
                                        controlling terminal</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_NOFOLLOW</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Don’t dereference symbolic links</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v4</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_TRUNC</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Truncate existing file to zero length</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_APPEND</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Writes are always appended to end of file</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_ASYNC</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Generate a signal when I/O is possible</p>
                                </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_DSYNC</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Provide synchronized I/O data integrity (since Linux
                                        2.6.33)</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_NONBLOCK</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Open in nonblocking mode</p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>v3</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">O_SYNC</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>Make file writes synchronous</p>
                                </td><td style="text-align: left; vertical-align: top; ">
                                    <p>v3</p>
                                </td></tr></tbody></table></div></div><p>The constants in <a class="xref" href="ch04.html#values_for_the_flags_argument_of_open_op" title="Table 4-3. Values for the flags argument of open()">Table 4-3</a>
                    are divided into the following groups:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>File access mode flags</em></span>: These are the <code class="literal">O_RDONLY</code>, <code class="literal">O_WRONLY</code>, and <code class="literal">O_RDWR</code>
                            flags described earlier. Only one of these values should be specified in
                                <span class="emphasis"><em>flags</em></span>. The access mode can be retrieved using
                            the <span class="emphasis"><em>fcntl()</em></span>
                            <code class="literal">F_GETFL</code> operation (<a class="xref" href="ch05.html#open_file_status_flags" title="Open File Status Flags">Open File Status Flags</a>).</p></li><li class="listitem"><p><span class="emphasis"><em>File creation flags</em></span>: These are the flags shown in
                            the second part of <a class="xref" href="ch04.html#values_for_the_flags_argument_of_open_op" title="Table 4-3. Values for the flags argument of open()">Table 4-3</a>. They control
                            various aspects of the behavior of the <span class="emphasis"><em>open()</em></span> call,
                            as well as options for subsequent I/O operations. These flags can’t be
                            retrieved or changed.</p></li><li class="listitem"><p><span class="emphasis"><em>Open file status flags</em></span>: These are the remaining
                            flags in <a class="xref" href="ch04.html#values_for_the_flags_argument_of_open_op" title="Table 4-3. Values for the flags argument of open()">Table 4-3</a>.
                            They can be retrieved and modified using the
                                <span class="emphasis"><em>fcntl()</em></span>
                            <code class="literal">F_GETFL</code> and <code class="literal">F_SETFL</code> operations (<a class="xref" href="ch05.html#open_file_status_flags" title="Open File Status Flags">Open File Status Flags</a>). These flags are sometimes
                            simply called the <span class="emphasis"><em>file status flags</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since kernel 2.6.22, the Linux-specific files in the directory
                                    <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/fdinfo</code> can be read to obtain
                                information about the file descriptors of any process on the system.
                                There is one file in this directory for each of the process’s open
                                file descriptors, with a name that matches the number of the
                                descriptor. The <span class="emphasis"><em>pos</em></span> field in this file shows
                                the current file offset (<a class="xref" href="ch04.html#changing_the_file_offset_colon_lseek_ope" title="Changing the File Offset: lseek()">Changing the File Offset: <span class="emphasis"><em>lseek()</em></span></a>). The
                                    <span class="emphasis"><em>flags</em></span> field is an octal number that shows
                                the file access mode flags and open file status flags. (To decode
                                this number, we need to look at the numeric values of these flags in
                                the C library header files.)<a id="IDX-CHP-4-0623" class="indexterm"/><a id="IDX-CHP-4-0624" class="indexterm"/></p></div></li></ul></div><p>Details for the <span class="emphasis"><em>flags</em></span> constants are as follows:</p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">O_APPEND</code>
                        </span></dt><dd><p>Writes are always appended to the end of the file. We discuss the
                                significance of this flag in Section 5.1.</p></dd><dt><span class="term">
                            <code class="literal">O_ASYNC</code>
                        </span></dt><dd><p>Generate a signal when I/O becomes possible on the file descriptor
                                returned by <span class="emphasis"><em>open()</em></span>. This feature, termed
                                    <span class="emphasis"><em>signal-driven I/O</em></span>, is available only for
                                certain file types, such as terminals, FIFOs, and sockets. (The
                                    <code class="literal">O_ASYNC</code> flag is not specified
                                in SUSv3; however, it, or the older synonym, <code class="literal">FASYNC</code>, is found on most UNIX
                                implementations.) On Linux, specifying the <code class="literal">O_ASYNC</code> flag when calling <span class="emphasis"><em>open()</em></span>
                                has no effect. To enable signal-driven I/O, we must instead set this
                                flag using the <span class="emphasis"><em>fcntl()</em></span>
                                <code class="literal">F_SETFL</code> operation (<a class="xref" href="ch05.html#open_file_status_flags" title="Open File Status Flags">Open File Status Flags</a>). (Several other UNIX
                                implementations behave similarly.) Refer to <a class="xref" href="ch63.html#signal-driven_i_solidus_o" title="Signal-Driven I/O">Signal-Driven I/O</a> for more information about
                                the <code class="literal">O_ASYNC</code> flag.<a id="IDX-CHP-4-0625" class="indexterm"/><a id="IDX-CHP-4-0626" class="indexterm"/></p></dd><dt><span class="term"><code class="literal">O_CLOEXEC</code> (since Linux
                            2.6.23)</span></dt><dd><p>Enable the close-on-exec flag (<code class="literal">FD_CLOEXEC</code>) for the new file descriptor. We describe
                                the <code class="literal">FD_CLOEXEC</code> flag in Section
                                27.4. Using the <code class="literal">O_CLOEXEC</code> flag
                                allows a program to avoid additional <span class="emphasis"><em>fcntl()</em></span>
                                <code class="literal">F_GETFD</code> and <code class="literal">F_SETFD</code> operations to set the
                                close-on-exec flag. It is also necessary in multithreaded programs
                                to avoid the race conditions that could occur using the latter
                                technique. These races can occur when one thread opens a file
                                descriptor and then tries to mark it close-on-exec at the same time
                                as another thread does a <span class="emphasis"><em>fork()</em></span> and then an
                                    <span class="emphasis"><em>exec()</em></span> of an arbitrary program. (Suppose
                                that the second thread manages to both <span class="emphasis"><em>fork()</em></span>
                                and <span class="emphasis"><em>exec()</em></span> between the time the first thread
                                opens the file descriptor and uses <span class="emphasis"><em>fcntl()</em></span> to
                                set the close-on-exec flag.) Such races could result in open file
                                descriptors being unintentionally passed to unsafe programs. (We say
                                more about race conditions in Section 5.1.)</p></dd><dt><span class="term">
                            <code class="literal">O_CREAT</code>
                        </span></dt><dd><p>If the file doesn’t already exist, it is created as a new, empty
                                file. This flag is effective even if the file is being opened only
                                for reading. If we specify <code class="literal">O_CREAT</code>, then we must supply a
                                    <span class="emphasis"><em>mode</em></span> argument in the
                                    <span class="emphasis"><em>open()</em></span> call; otherwise, the permissions of
                                the new file will be set to some random value from the stack.</p></dd><dt><span class="term">
                            <code class="literal">O_DIRECT</code>
                        </span></dt><dd><p>Allow file I/O to bypass the buffer cache. This feature is
                                described in Section 13.6. The <code class="literal">_GNU_SOURCE</code> feature test macro must be defined in
                                order to make this constant definition available from <code class="literal">&lt;fcntl.h&gt;</code>.</p></dd><dt><span class="term">
                            <code class="literal">O_DIRECTORY</code>
                        </span></dt><dd><p>Return an error (<span class="emphasis"><em>errno</em></span> equals <code class="literal">ENOTDIR</code>) if
                                    <span class="emphasis"><em>pathname</em></span> is not a directory. This flag is
                                an extension designed specifically for implementing
                                    <span class="emphasis"><em>opendir()</em></span> (<a class="xref" href="ch18.html#reading_directories_colon_opendir_open_p" title="Reading Directories: opendir() and readdir()">Reading Directories: <span class="emphasis"><em>opendir()</em></span> and
                    <span class="emphasis"><em>readdir()</em></span></a>). The
                                    <code class="literal">_GNU_SOURCE</code> feature test
                                macro must be defined in order to make this constant definition
                                available from <code class="literal">&lt;fcntl.h&gt;</code>.</p></dd><dt><span class="term"><code class="literal">O_DSYNC</code> (since Linux 2.6.33)</span></dt><dd><p>Perform file writes according to the requirements of synchronized
                                I/O data integrity completion. See the discussion of kernel I/O
                                buffering in Section 13.3.</p></dd><dt><span class="term">
                            <code class="literal">O_EXCL</code>
                        </span></dt><dd><p>This flag is used in conjunction with <code class="literal">O_CREAT</code> to indicate that if the file already exists,
                                it should not be opened; instead, <span class="emphasis"><em>open()</em></span> should
                                fail, with <span class="emphasis"><em>errno</em></span> set to <code class="literal">EEXIST</code>. In other words, this flag
                                allows the caller to ensure that it is the process creating the
                                file. The check for existence and the creation of the file are
                                performed <span class="emphasis"><em>atomically</em></span>. We discuss the concept of
                                atomicity in Section 5.1. When both <code class="literal">O_CREAT</code> and <code class="literal">O_EXCL</code>
                                are specified in <span class="emphasis"><em>flags</em></span>,
                                    <span class="emphasis"><em>open()</em></span> fails (with the error <code class="literal">EEXIST</code>) if
                                    <span class="emphasis"><em>pathname</em></span> is a symbolic link. SUSv3 requires
                                this behavior so that a privileged application can create a file in
                                a known location without there being a possibility that a symbolic
                                link would cause the file to be created in a different location
                                (e.g., a system directory), which would have security
                                    implications.<a id="IDX-CHP-4-0627" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">O_LARGEFILE</code>
                        </span></dt><dd><p>Open the file with large file support. This flag is used on 32-bit
                                systems in order to work with large files. Although it is not
                                specified in SUSv3, the <code class="literal">O_LARGEFILE</code> flag is found on several other UNIX
                                implementations. On 64-bit Linux implementations such as Alpha and
                                IA-64, this flag has no effect. See <a class="xref" href="ch05.html#i_solidus_o_on_large_files" title="I/O on Large Files">I/O on Large Files</a> for more
                                    information.<a id="IDX-CHP-4-0628" class="indexterm"/></p></dd><dt><span class="term"><code class="literal">O_NOATIME</code> (since Linux
                            2.6.8)</span></dt><dd><p>Don’t update the file last access time (the
                                    <span class="emphasis"><em>st_atime</em></span> field described in <a class="xref" href="ch15.html#retrieving_file_information_colon_stat_o" title="Retrieving File Information: stat()">Retrieving File Information: <span class="emphasis"><em>stat()</em></span></a>) when
                                reading from this file. To use this flag, the effective user ID of
                                the calling process must match the owner of the file, or the process
                                must be privileged (<code class="literal">CAP_FOWNER</code>);
                                otherwise, <span class="emphasis"><em>open()</em></span> fails with the error <code class="literal">EPERM</code>. (In reality, for an
                                unprivileged process, it is the process’s file-system user ID,
                                rather than its effective user ID, that must match the user ID of
                                the file when opening a file with the <code class="literal">O_NOATIME</code> flag, as described in Section 9.5.) This
                                flag is a nonstandard Linux extension. To expose its definition from
                                    <code class="literal">&lt;fcntl.h&gt;</code>, we
                                must define the <code class="literal">_GNU_SOURCE</code>
                                feature test macro. The <code class="literal">O_NOATIME</code>
                                flag is intended for use by indexing and backup programs. Its use
                                can significantly reduce the amount of disk activity, because
                                repeated disk seeks back and forth across the disk are not required
                                to read the contents of a file and to update the last access time in
                                the file’s i-node (<a class="xref" href="ch14.html#i-nodes" title="I-nodes">I-nodes</a>). Functionality similar
                                to <code class="literal">O_NOATIME</code> is available using
                                the <code class="literal">MS_NOATIME</code>
                                <span class="emphasis"><em>mount()</em></span> flag (<a class="xref" href="ch14.html#mounting_a_file_system_colon_mount_open" title="Mounting a File System: mount()">Mounting a File System: <span class="emphasis"><em>mount()</em></span></a>) and the
                                    <code class="literal">FS_NOATIME_FL</code> flag (<a class="xref" href="ch15.html#i-node_flags_open_parenthesis_ext2_exten" title="I-node Flags (ext2 Extended File Attributes)">I-node Flags (<span class="emphasis"><em>ext2</em></span> Extended File Attributes)</a>).<a id="IDX-CHP-4-0629" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">O_NOCTTY</code>
                        </span></dt><dd><p>If the file being opened is a terminal device, prevent it from
                                becoming the controlling terminal. Controlling terminals are
                                discussed in Section 34.4. If the file being opened is not a
                                terminal, this flag has no effect.<a id="IDX-CHP-4-0630" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">O_NOFOLLOW</code>
                        </span></dt><dd><p>Normally, <span class="emphasis"><em>open()</em></span> dereferences
                                    <span class="emphasis"><em>pathname</em></span> if it is a symbolic link. However,
                                if the <code class="literal">O_NOFOLLOW</code> flag is
                                specified, then <span class="emphasis"><em>open()</em></span> fails (with
                                    <span class="emphasis"><em>errno</em></span> set to <code class="literal">ELOOP</code>) if <span class="emphasis"><em>pathname</em></span> is a symbolic
                                link. This flag is useful, especially in privileged programs, for
                                ensuring that <span class="emphasis"><em>open()</em></span> doesn’t dereference a
                                symbolic link. To expose the definition of this flag from <code class="literal">&lt;fcntl.h&gt;</code>, we must
                                define the <code class="literal">_GNU_SOURCE</code> feature
                                test macro.<a id="IDX-CHP-4-0631" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">O_NONBLOCK</code>
                        </span></dt><dd><p>Open the file in nonblocking mode. See Section 5.9.<a id="IDX-CHP-4-0632" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">O_SYNC</code>
                        </span></dt><dd><p>Open the file for synchronous I/O. See the discussion of kernel
                                I/O buffering in Section 13.3.</p></dd><dt><span class="term">
                            <code class="literal">O_TRUNC</code>
                        </span></dt><dd><p>If the file already exists and is a regular file, then truncate it
                                to zero length, destroying any existing data. On Linux, truncation
                                occurs whether the file is being opened for reading or writing (in
                                both cases, we must have write permission on the file). SUSv3 leaves
                                the combination of <code class="literal">O_RDONLY</code> and
                                    <code class="literal">O_TRUNC</code> unspecified, but most
                                other UNIX implementations behave in the same way as Linux.</p></dd></dl></div></div><div class="sect2" title="Errors from open()"><div class="titlepage"><div><div><h3 class="title" id="errors_from_open_open_parenthesis_close">Errors from <span class="emphasis"><em>open()</em></span></h3></div></div></div><p>If an error occurs while trying to open the file, <span class="emphasis"><em>open()</em></span>
                    returns -1, and <span class="emphasis"><em>errno</em></span> identifies the cause of the error.
                    The following are some possible errors that can occur (in addition to those
                    already noted when describing the <span class="emphasis"><em>flags</em></span> argument
                        above):<a id="IDX-CHP-4-0633" class="indexterm"/><a id="IDX-CHP-4-0634" class="indexterm"/><a id="IDX-CHP-4-0635" class="indexterm"/><a id="IDX-CHP-4-0636" class="indexterm"/><a id="IDX-CHP-4-0637" class="indexterm"/><a id="IDX-CHP-4-0638" class="indexterm"/><a id="IDX-CHP-4-0639" class="indexterm"/><a id="IDX-CHP-4-0640" class="indexterm"/><a id="IDX-CHP-4-0641" class="indexterm"/><a id="IDX-CHP-4-0642" class="indexterm"/><a id="IDX-CHP-4-0643" class="indexterm"/><a id="IDX-CHP-4-0644" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                            <code class="literal">EACCES</code>
                        </span></dt><dd><p>The file permissions don’t allow the calling process to open the
                                file in the mode specified by <span class="emphasis"><em>flags</em></span>.
                                Alternatively, because of directory permissions, the file could not
                                be accessed, or the file did not exist and could not be
                                created.</p></dd><dt><span class="term">
                            <code class="literal">EISDIR</code>
                        </span></dt><dd><p>The specified file is a directory, and the caller attempted to
                                open it for writing. This isn’t allowed. (On the other hand, there
                                are occasions when it can be useful to open a directory for reading.
                                We consider an example in <a class="xref" href="ch18.html#operating_relative_to_a_directory_file_d" title="Operating Relative to a Directory File Descriptor">Operating Relative to a Directory File Descriptor</a>.)</p></dd><dt><span class="term">
                            <code class="literal">EMFILE</code>
                        </span></dt><dd><p>The process resource limit on the number of open file descriptors
                                has been reached (<code class="literal">RLIMIT_NOFILE</code>,
                                described in <a class="xref" href="ch36.html#details_of_specific_resource_limits" title="Details of Specific Resource Limits">Details of Specific Resource Limits</a>).</p></dd><dt><span class="term">
                            <code class="literal">ENFILE</code>
                        </span></dt><dd><p>The system-wide limit on the number of open files has been
                                reached.</p></dd><dt><span class="term">
                            <code class="literal">ENOENT</code>
                        </span></dt><dd><p>The specified file doesn’t exist, and <code class="literal">O_CREAT</code> was not specified, or <code class="literal">O_CREAT</code> was specified, and one of the
                                directories in <span class="emphasis"><em>pathname</em></span> doesn’t exist or is a
                                symbolic link pointing to a nonexistent pathname (a dangling
                                link).</p></dd><dt><span class="term">
                            <code class="literal">EROFS</code>
                        </span></dt><dd><p>The specified file is on a read-only file system and the caller
                                tried to open it for writing.</p></dd><dt><span class="term">
                            <code class="literal">ETXTBSY</code>
                        </span></dt><dd><p>The specified file is an executable file (a program) that is
                                currently executing. It is not permitted to modify (i.e., open for
                                writing) the executable file associated with a running program. (We
                                must first terminate the program in order to be able to modify the
                                executable file.)</p></dd></dl></div><p>When we later describe other system calls or library functions, we generally
                    won’t list the range of possible errors that may occur in the above fashion.
                    (Such a list can be found in the corresponding manual page for each system call
                    or library function.) We do so here for two reasons. One of these is that
                        <span class="emphasis"><em>open()</em></span> is the first system call that we describe in
                    detail, and the above list illustrates that a system call or library function
                    may fail for any of a number of reasons. Second, the specific reasons why
                        <span class="emphasis"><em>open()</em></span> may fail make an interesting list in themselves,
                    illustrating a number of factors and checks that come into play when a file is
                    accessed. (The above list is incomplete: see the <span class="emphasis"><em>open(2)</em></span>
                    manual page for more reasons why <span class="emphasis"><em>open()</em></span> may fail.)</p></div><div class="sect2" title="The creat() System Call"><div class="titlepage"><div><div><h3 class="title" id="the_creat_open_parenthesis_close_parenth">The <span class="emphasis"><em>creat()</em></span> System Call</h3></div></div></div><p>In early UNIX implementations, <span class="emphasis"><em>open()</em></span> had only two
                    arguments and could not be used to create a new file. Instead, the
                        <span class="emphasis"><em>creat()</em></span> system call was used to create and open a new
                        file.<a id="IDX-CHP-4-0646" class="indexterm"/><a id="IDX-CHP-4-0647" class="indexterm"/><a id="IDX-CHP-4-0648" class="indexterm"/><a id="IDX-CHP-4-0649" class="indexterm"/><a id="IDX-CHP-4-0650" class="indexterm"/><a id="IDX-CHP-4-0651" class="indexterm"/><a id="IDX-CHP-4-0652" class="indexterm"/><a id="IDX-CHP-4-0653" class="indexterm"/><a id="IDX-CHP-4-0654" class="indexterm"/><a id="IDX-CHP-4-0645" class="indexterm"/></p><a id="I_programlisting4_d1e9476"/><pre class="programlisting">#include &lt;fcntl.h&gt;

int <strong class="userinput"><code>creat</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>, mode_t <span class="emphasis"><em>mode</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns file descriptor, or -1 on error</p></div><p>The <span class="emphasis"><em>creat()</em></span> system call creates and opens a new file with
                    the given <span class="emphasis"><em>pathname</em></span>, or if the file already exists, opens
                    the file and truncates it to zero length. As its function result,
                        <span class="emphasis"><em>creat()</em></span> returns a file descriptor that can be used in
                    subsequent system calls. Calling <span class="emphasis"><em>creat()</em></span> is equivalent to
                    the following <span class="emphasis"><em>open()</em></span> call:</p><a id="I_programlisting4_d1e9507"/><pre class="programlisting">fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</pre><p>Because the <span class="emphasis"><em>open() flags</em></span> argument provides greater
                    control over how the file is opened (e.g., we can specify <code class="literal">O_RDWR</code> instead of <code class="literal">O_WRONLY</code>), <span class="emphasis"><em>creat()</em></span> is now obsolete, although
                    it may still be seen in older programs.</p></div></div><div class="sect1" title="Reading from a File: read()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="reading_from_a_file_colon_read_open_pare">Reading from a File: <span class="emphasis"><em>read()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>read()</em></span> system call reads data from the open file referred
                to by the descriptor <span class="emphasis"><em>fd</em></span>.<a id="IDX-CHP-4-0656" class="indexterm"/><a id="IDX-CHP-4-0657" class="indexterm"/><a id="IDX-CHP-4-0655" class="indexterm"/></p><a id="I_programlisting4_d1e9552"/><pre class="programlisting">#include &lt;unistd.h&gt;

ssize_t <strong class="userinput"><code>read</code></strong>(int <span class="emphasis"><em>fd</em></span>, void *<span class="emphasis"><em>buffer</em></span>, size_t <span class="emphasis"><em>count</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of bytes read, 0 on EOF, or -1 on error</p></div><p>The <span class="emphasis"><em>count</em></span> argument specifies the maximum number of bytes to
                read. (The <span class="emphasis"><em>size_t</em></span> data type is an unsigned integer type.) The
                    <span class="emphasis"><em>buffer</em></span> argument supplies the address of the memory buffer
                into which the input data is to be placed. This buffer must be at least
                    <span class="emphasis"><em>count</em></span> bytes long.<a id="IDX-CHP-4-0658" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>System calls don’t allocate memory for buffers that are used to return
                    information to the caller. Instead, we must pass a pointer to a previously
                    allocated memory buffer of the correct size. This contrasts with several library
                    functions that <span class="emphasis"><em>do</em></span> allocate memory buffers in order to
                    return information to the caller.</p></div><p>A successful call to <span class="emphasis"><em>read()</em></span> returns the number of bytes
                actually read, or 0 if end-of-file is encountered. On error, the usual -1 is
                returned. The <span class="emphasis"><em>ssize_t</em></span> data type is a signed integer type used
                to hold a byte count or a -1 error indication.<a id="IDX-CHP-4-0659" class="indexterm"/></p><p>A call to <span class="emphasis"><em>read()</em></span> may read less than the requested number of
                bytes. For a regular file, the probable reason for this is that we were close to the
                end of the file.</p><p>When <span class="emphasis"><em>read()</em></span> is applied to other types of files—such as pipes,
                FIFOs, sockets, or terminals—there are also various circumstances where it may read
                fewer bytes than requested. For example, by default, a <span class="emphasis"><em>read()</em></span>
                from a terminal reads characters only up to the next newline (<code class="literal">\n</code>) character. We consider these cases when we cover
                other file types in subsequent chapters.</p><p>Using <span class="emphasis"><em>read()</em></span> to input a series of characters from, say, a
                terminal, we might expect the following code to work:</p><a id="I_programlisting4_d1e9628"/><pre class="programlisting">#define MAX_READ 20
char buffer[MAX_READ];

if (read(STDIN_FILENO, buffer, MAX_READ) == -1)
    errExit("read");
printf("The input data was: %s\n", buffer);</pre><p>The output from this piece of code is likely to be strange, since it will probably
                include characters in addition to the string actually entered. This is because
                    <span class="emphasis"><em>read()</em></span> doesn’t place a terminating null byte at the end of
                the string that <span class="emphasis"><em>printf()</em></span> is being asked to print. A moment’s
                reflection leads us to realize that this must be so, since
                    <span class="emphasis"><em>read()</em></span> can be used to read any sequence of bytes from a
                file. In some cases, this input might be text, but in other cases, the input might
                be binary integers or C structures in binary form. There is no way for
                    <span class="emphasis"><em>read()</em></span> to tell the difference, and so it can’t attend to
                the C convention of null terminating character strings. If a terminating null byte
                is required at the end of the input buffer, we must put it there explicitly:</p><a id="I_programlisting4_d1e9645"/><pre class="programlisting">char buffer[MAX_READ + 1];
ssize_t numRead;

numRead = read(STDIN_FILENO, buffer, MAX_READ);
if (numRead == -1)
    errExit("read");

buffer[numRead] = '\0';
printf("The input data was: %s\n", buffer);</pre><p>Because the terminating null byte requires a byte of memory, the size of
                    <span class="emphasis"><em>buffer</em></span> must be at least one greater than the largest string
                we expect to read.</p></div><div class="sect1" title="Writing to a File: write()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="writing_to_a_file_colon_write_open_paren">Writing to a File: <span class="emphasis"><em>write()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>write()</em></span> system call writes data to an open
                    file.<a id="IDX-CHP-4-0661" class="indexterm"/><a id="IDX-CHP-4-0662" class="indexterm"/><a id="IDX-CHP-4-0663" class="indexterm"/><a id="IDX-CHP-4-0664" class="indexterm"/><a id="IDX-CHP-4-0665" class="indexterm"/><a id="IDX-CHP-4-0660" class="indexterm"/></p><a id="I_programlisting4_d1e9693"/><pre class="programlisting">#include &lt;unistd.h&gt;

ssize_t <strong class="userinput"><code>write</code></strong>(int fd, void *<span class="emphasis"><em>buffer</em></span>, size_t <span class="emphasis"><em>count</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns number of bytes written, or -1 on error</p></div><p>The arguments to <span class="emphasis"><em>write()</em></span> are similar to those for
                    <span class="emphasis"><em>read()</em></span>: <span class="emphasis"><em>buffer</em></span> is the address of the
                data to be written; <span class="emphasis"><em>count</em></span> is the number of bytes to write from
                    <span class="emphasis"><em>buffer</em></span>; and <span class="emphasis"><em>fd</em></span> is a file descriptor
                referring to the file to which data is to be written.</p><p>On success, <span class="emphasis"><em>write()</em></span> returns the number of bytes actually
                written; this may be less than <span class="emphasis"><em>count</em></span>. For a disk file, possible
                reasons for such a <span class="emphasis"><em>partial write</em></span> are that the disk was filled
                or that the process resource limit on file sizes was reached. (The relevant limit is
                    <code class="literal">RLIMIT_FSIZE</code>, described in Section
                    36.3.)<a id="IDX-CHP-4-0666" class="indexterm"/></p><p>When performing I/O on a disk file, a successful return from
                    <span class="emphasis"><em>write()</em></span> doesn’t guarantee that the data has been
                transferred to disk, because the kernel performs buffering of disk I/O in order to
                reduce disk activity and expedite <span class="emphasis"><em>write()</em></span> calls. We consider
                the details in <a class="xref" href="ch13.html" title="Chapter 13. File I/O Buffering">Chapter 13</a>.</p></div><div class="sect1" title="Closing a File: close()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="closing_a_file_colon_close_open_parenthe">Closing a File: <span class="emphasis"><em>close()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>close()</em></span> system call closes an open file descriptor,
                freeing it for subsequent reuse by the process. When a process terminates, all of
                its open file descriptors are automatically closed.<a id="IDX-CHP-4-0667" class="indexterm"/></p><a id="I_programlisting4_d1e9769"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>close</code></strong>(int <span class="emphasis"><em>fd</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>It is usually good practice to close unneeded file descriptors explicitly, since
                this makes our code more readable and reliable in the face of subsequent
                modifications. Furthermore, file descriptors are a consumable resource, so failure
                to close a file descriptor could result in a process running out of descriptors.
                This is a particularly important issue when writing long-lived programs that deal
                with multiple files, such as shells or network servers.</p><p>Just like every other system call, a call to <span class="emphasis"><em>close()</em></span> should
                be bracketed with error-checking code, such as the following:</p><a id="I_programlisting4_d1e9787"/><pre class="programlisting">if (close(fd) == -1)
    errExit("close");</pre><p>This catches errors such as attempting to close an unopened file descriptor or
                close the same file descriptor twice, and catches error conditions that a specific
                file system may diagnose during a close operation.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>NFS (Network File System) provides an example of an error that is specific to
                    a file system. If an NFS commit failure occurs, meaning that the data did not
                    reach the remote disk, then this error is propagated to the application as a
                    failure in the <span class="emphasis"><em>close()</em></span> call.</p></div></div><div class="sect1" title="Changing the File Offset: lseek()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="changing_the_file_offset_colon_lseek_ope">Changing the File Offset: <span class="emphasis"><em>lseek()</em></span></h2></div></div></div><p>For each open file, the kernel records a <span class="emphasis"><em>file offset</em></span>,
                sometimes also called the <span class="emphasis"><em>read-write offset</em></span> or
                    <span class="emphasis"><em>pointer</em></span>. This is the location in the file at which the next
                    <span class="emphasis"><em>read()</em></span> or <span class="emphasis"><em>write()</em></span> will commence. The
                file offset is expressed as an ordinal byte position relative to the start of the
                file. The first byte of the file is at offset 0.<a id="IDX-CHP-4-0669" class="indexterm"/><a id="IDX-CHP-4-0670" class="indexterm"/><a id="IDX-CHP-4-0671" class="indexterm"/><a id="IDX-CHP-4-0672" class="indexterm"/><a id="IDX-CHP-4-0673" class="indexterm"/><a id="IDX-CHP-4-0674" class="indexterm"/><a id="IDX-CHP-4-0675" class="indexterm"/><a id="IDX-CHP-4-0676" class="indexterm"/><a id="IDX-CHP-4-0677" class="indexterm"/><a id="IDX-CHP-4-0678" class="indexterm"/><a id="IDX-CHP-4-0679" class="indexterm"/><a id="IDX-CHP-4-0680" class="indexterm"/><a id="IDX-CHP-4-0681" class="indexterm"/><a id="IDX-CHP-4-0668" class="indexterm"/><a id="IDX-CHP-4-0682" class="indexterm"/></p><p>The file offset is set to point to the start of the file when the file is opened
                and is automatically adjusted by each subsequent call to <span class="emphasis"><em>read()</em></span>
                or <span class="emphasis"><em>write()</em></span> so that it points to the next byte of the file after
                the byte(s) just read or written. Thus, successive <span class="emphasis"><em>read()</em></span> and
                    <span class="emphasis"><em>write()</em></span> calls progress sequentially through a file.</p><p>The <span class="emphasis"><em>lseek()</em></span> system call adjusts the file offset of the open
                file referred to by the file descriptor <span class="emphasis"><em>fd</em></span>, according to the
                values specified in <span class="emphasis"><em>offset</em></span> and
                <span class="emphasis"><em>whence</em></span>.</p><a id="I_programlisting4_d1e9927"/><pre class="programlisting">#include &lt;unistd.h&gt;

off_t <strong class="userinput"><code>lseek</code></strong>(int <span class="emphasis"><em>fd</em></span>, off_t <span class="emphasis"><em>offset</em></span>, int <span class="emphasis"><em>whence</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns new file offset if successful, or -1 on error</p></div><p>The <span class="emphasis"><em>offset</em></span> argument specifies a value in bytes. (The
                    <span class="emphasis"><em>off_t</em></span> data type is a signed integer type specified by
                SUSv3.) The <span class="emphasis"><em>whence</em></span> argument indicates the base point from which
                    <span class="emphasis"><em>offset</em></span> is to be interpreted, and is one of the following
                    values:<a id="IDX-CHP-4-0683" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">SEEK_SET</code>
                    </span></dt><dd><p>The file offset is set <span class="emphasis"><em>offset</em></span> bytes from the
                            beginning of the file.</p></dd><dt><span class="term">
                        <code class="literal">SEEK_CUR</code>
                    </span></dt><dd><p>The file offset is adjusted by <span class="emphasis"><em>offset</em></span> bytes
                            relative to the current file offset.</p></dd><dt><span class="term">
                        <code class="literal">SEEK_END</code>
                    </span></dt><dd><p>The file offset is set to the size of the file plus
                                <span class="emphasis"><em>offset</em></span>. In other words,
                                <span class="emphasis"><em>offset</em></span> is interpreted with respect to the next
                            byte after the last byte of the file.</p></dd></dl></div><p><a class="xref" href="ch04.html#interpreting_the_whence_argument_of_lsee" title="Figure 4-1. Interpreting the whence argument of lseek()">Figure 4-1</a> shows how the
                    <span class="emphasis"><em>whence</em></span> argument is interpreted.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In earlier UNIX implementations, the integers 0, 1, and 2 were used, rather
                    than the <code class="literal">SEEK_*</code> constants shown in the main
                    text. Older versions of BSD used different names for these values: <code class="literal">L_SET</code>, <code class="literal">L_INCR</code>,
                    and <code class="literal">L_XTND</code>.</p></div><div class="figure"><a id="interpreting_the_whence_argument_of_lsee"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e10026"/><img src="figs/web/04-1_FILEIO-A-lseek-scale90.png.jpg" alt="Interpreting the whence argument of lseek()"/></div></div><div class="figure-title">Figure 4-1. Interpreting the <span class="emphasis"><em>whence</em></span> argument of
                        <span class="emphasis"><em>lseek()</em></span></div></div><p>If <span class="emphasis"><em>whence</em></span> is <code class="literal">SEEK_CUR</code> or
                    <code class="literal">SEEK_END</code>, <span class="emphasis"><em>offset</em></span> may be
                negative or positive; for <code class="literal">SEEK_SET</code>,
                    <span class="emphasis"><em>offset</em></span> must be nonnegative.</p><p>The return value from a successful <span class="emphasis"><em>lseek()</em></span> is the new file
                offset. The following call retrieves the current location of the file offset without
                changing it:</p><a id="I_programlisting4_d1e10058"/><pre class="programlisting">curr = lseek(fd, 0, SEEK_CUR);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Some UNIX implementations (but not Linux) have the nonstandard
                        <span class="emphasis"><em>tell(fd)</em></span> function, which serves the same purpose as the
                    above <span class="emphasis"><em>lseek()</em></span> call.</p></div><p>Here are some other examples of <span class="emphasis"><em>lseek()</em></span> calls, along with
                comments indicating where the file offset is moved to:</p><a id="I_programlisting4_d1e10074"/><pre class="programlisting">lseek(fd, 0, SEEK_SET);         /* Start of file */
lseek(fd, 0, SEEK_END);         /* Next byte after the end of the file */
lseek(fd, -1, SEEK_END);        /* Last byte of file */
lseek(fd, -10, SEEK_CUR);       /* Ten bytes prior to current location */
lseek(fd, 10000, SEEK_END);     /* 10001 bytes past last byte of file */</pre><p>Calling <span class="emphasis"><em>lseek()</em></span> simply adjusts the kernel’s record of the
                file offset associated with a file descriptor. It does not cause any physical device
                access.</p><p>We describe some further details of the relationship between file offsets, file
                descriptors, and open files in Section 5.4.</p><p>We can’t apply <span class="emphasis"><em>lseek()</em></span> to all types of files. Applying
                    <span class="emphasis"><em>lseek()</em></span> to a pipe, FIFO, socket, or terminal is not
                permitted; <span class="emphasis"><em>lseek()</em></span> fails, with <span class="emphasis"><em>errno</em></span> set
                to <code class="literal">ESPIPE</code>. On the other hand, it is possible to
                apply <span class="emphasis"><em>lseek()</em></span> to devices where it is sensible to do so. For
                example, it is possible to seek to a specified location on a disk or tape
                device.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>l</em></span> in the name <span class="emphasis"><em>lseek()</em></span> derives
                    from the fact that the <span class="emphasis"><em>offset</em></span> argument and the return value
                    were both originally typed as <span class="emphasis"><em>long</em></span>. Early UNIX
                    implementations provided a <span class="emphasis"><em>seek()</em></span> system call, which typed
                    these values as <span class="emphasis"><em>int</em></span>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="file_holes"/></div></div></div><div class="sect3" title="File holes"><div class="titlepage"><div><div><h4 class="title" id="file_holes-id1">File holes</h4></div></div></div><p>What happens if a program seeks past the end of a file, and then performs
                        I/O? A call to <span class="emphasis"><em>read()</em></span> will return 0, indicating
                        end-of-file. Somewhat surprisingly, it is possible to write bytes at an
                        arbitrary point past the end of the file.<a id="IDX-CHP-4-0684" class="indexterm"/><a id="IDX-CHP-4-0685" class="indexterm"/><a id="IDX-CHP-4-0686" class="indexterm"/><a id="IDX-CHP-4-0687" class="indexterm"/></p><p>The space in between the previous end of the file and the newly written
                        bytes is referred to as a <span class="emphasis"><em>file hole</em></span>. From a programming
                        point of view, the bytes in a hole exist, and reading from the hole returns
                        a buffer of bytes containing 0 (null bytes).<a id="IDX-CHP-4-0688" class="indexterm"/></p><p>File holes don’t, however, take up any disk space. The file system doesn’t
                        allocate any disk blocks for a hole until, at some later point, data is
                        written into it. The main advantage of file holes is that a sparsely
                        populated file consumes less disk space than would otherwise be required if
                        the null bytes actually needed to be allocated in disk blocks. Core dump
                        files (<a class="xref" href="ch22.html#core_dump_files" title="Core Dump Files">Core Dump Files</a>) are common examples of files that
                        contain large holes.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The statement that file holes don’t consume disk space needs to be
                            qualified slightly. On most file systems, file space is allocated in
                            units of blocks (<a class="xref" href="ch14.html#file_systems-id1" title="File Systems">File Systems</a>). The size of a
                            block depends on the file system, but is typically something like 1024,
                            2048, or 4096 bytes. If the edge of a hole falls within a block, rather
                            than on a block boundary, then a complete block is allocated to store
                            the data in the other part of the block, and the part corresponding to
                            the hole is filled with null bytes.</p></div><p>Most native UNIX file systems support the concept of file holes, but many
                        nonnative file systems (e.g., Microsoft’s VFAT) do not. On a file system
                        that doesn’t support holes, explicit null bytes are written to the
                        file.</p><p>The existence of holes means that a file’s nominal size may be larger than
                        the amount of disk storage it utilizes (in some cases, considerably larger).
                        Writing bytes into the middle of the file hole will decrease the amount of
                        free disk space as the kernel allocates blocks to fill the hole, even though
                        the file’s size doesn’t change. Such a scenario is uncommon, but
                        nevertheless one to be aware of.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 specifies a function, <span class="emphasis"><em>posix_fallocate(fd, offset,
                                len)</em></span>, that ensures that space is allocated on disk for
                            the byte range specified by <span class="emphasis"><em>offset</em></span> and
                                <span class="emphasis"><em>len</em></span> for the disk file referred to by the
                            descriptor <span class="emphasis"><em>fd</em></span>. This allows an application to be
                            sure that a later <span class="emphasis"><em>write()</em></span> to the file won’t fail
                            because disk space is exhausted (which could otherwise occur if a hole
                            in the file was filled in, or some other application consumed space on
                            the disk). Historically, the <span class="emphasis"><em>glibc</em></span> implementation
                            of this function achieved the desired result by writing a 0 byte into
                            each block in the specified range. Since version 2.6.23, Linux provides
                            an <span class="emphasis"><em>fallocate()</em></span> system call, which provides a more
                            efficient way of ensuring that the necessary space is allocated, and the
                                <span class="emphasis"><em>glibc posix_fallocate()</em></span> implementation makes
                            use of this system call when it is available.<a id="IDX-CHP-4-0689" class="indexterm"/></p></div><p><a class="xref" href="ch14.html#i-nodes" title="I-nodes">I-nodes</a> describes how holes are represented in a file,
                        and <a class="xref" href="ch15.html#retrieving_file_information_colon_stat_o" title="Retrieving File Information: stat()">Retrieving File Information: <span class="emphasis"><em>stat()</em></span></a> describes the
                            <span class="emphasis"><em>stat()</em></span> system call, which can tell us the current
                        size of a file, as well as the number of blocks actually allocated to the
                        file.</p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program">Example program</h4></div></div></div><p><a class="xref" href="ch04.html#demonstration_of_read_open_parenthesis_c" title="Example 4-3. Demonstration of read(), write(), and lseek()">Example 4-3</a> demonstrates
                        the use of <span class="emphasis"><em>lseek()</em></span> in conjunction with
                            <span class="emphasis"><em>read()</em></span> and <span class="emphasis"><em>write()</em></span>. The first
                        command-line argument to this program is the name of a file to be opened.
                        The remaining arguments specify I/O operations to be performed on the file.
                        Each of these operations consists of a letter followed by an associated
                        value (with no separating space):<a id="IDX-CHP-4-0690" class="indexterm"/><a id="IDX-CHP-4-0691" class="indexterm"/><a id="IDX-CHP-4-0692" class="indexterm"/><a id="IDX-CHP-4-0693" class="indexterm"/><a id="IDX-CHP-4-0694" class="indexterm"/><a id="IDX-CHP-4-0695" class="indexterm"/><a id="IDX-CHP-4-0696" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">s</code><span class="emphasis"><em>offset</em></span>:
                                Seek to byte <span class="emphasis"><em>offset</em></span> from the start of the
                                file.</p></li><li class="listitem"><p><code class="literal">r</code><span class="emphasis"><em>length</em></span>:
                                Read <span class="emphasis"><em>length</em></span> bytes from the file, starting at
                                the current file offset, and display them in text form.</p></li><li class="listitem"><p><code class="literal">R</code><span class="emphasis"><em>length</em></span>:
                                Read <span class="emphasis"><em>length</em></span> bytes from the file, starting at
                                the current file offset, and display them in hexadecimal.</p></li><li class="listitem"><p><code class="literal">w</code><span class="emphasis"><em>str</em></span>:
                                Write the string of characters specified in <span class="emphasis"><em>str</em></span>
                                at the current file offset.</p></li></ul></div><div class="example"><a id="demonstration_of_read_open_parenthesis_c"/><div class="example-title">Example 4-3. Demonstration of <span class="emphasis"><em>read()</em></span>,
                                <span class="emphasis"><em>write()</em></span>, and
                            <span class="emphasis"><em>lseek()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>fileio/seek_io.c</code></strong>
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;ctype.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    size_t len;
    off_t offset;
    int fd, ap, j;
    char *buf;
    ssize_t numRead, numWritten;

    if (argc &lt; 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s file {r&lt;length&gt;|R&lt;length&gt;|w&lt;string&gt;|s&lt;offset&gt;}...\n",
                 argv[0]);

    fd = open(argv[1], O_RDWR | O_CREAT,
                S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |
                S_IROTH | S_IWOTH);                     /* rw-rw-rw- */
    if (fd == -1)
        errExit("open");

    for (ap = 2; ap &lt; argc; ap++) {
        switch (argv[ap][0]) {
        case 'r':   /* Display bytes at current offset, as text */
        case 'R':   /* Display bytes at current offset, in hex */
            len = getLong(&amp;argv[ap][1], GN_ANY_BASE, argv[ap]);

            buf = malloc(len);
            if (buf == NULL)
                errExit("malloc");

            numRead = read(fd, buf, len);
            if (numRead == -1)
                errExit("read");

            if (numRead == 0) {
                printf("%s: end-of-file\n", argv[ap]);
            } else {
                printf("%s: ", argv[ap]);
                for (j = 0; j &lt; numRead; j++) {
                    if (argv[ap][0] == 'r')
                        printf("%c", isprint((unsigned char) buf[j]) ?
                                                buf[j] : '?');
                    else
                        printf("%02x ", (unsigned int) buf[j]);
                }
                printf("\n");
            }

            free(buf);
            break;

        case 'w':   /* Write string at current offset */
            numWritten = write(fd, &amp;argv[ap][1], strlen(&amp;argv[ap][1]));
            if (numWritten == -1)
                errExit("write");
            printf("%s: wrote %ld bytes\n", argv[ap], (long) numWritten);
            break;

        case 's':   /* Change file offset */
            offset = getLong(&amp;argv[ap][1], GN_ANY_BASE, argv[ap]);
            if (lseek(fd, offset, SEEK_SET) == -1)
                errExit("lseek");
            printf("%s: seek succeeded\n", argv[ap]);
            break;

        default:
            cmdLineErr("Argument must start with [rRws]: %s\n", argv[ap]);
        }
    }

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>fileio/seek_io.c</code></strong></pre></div></div><p>The following shell session log demonstrates the use of the program in
                            <a class="xref" href="ch04.html#demonstration_of_read_open_parenthesis_c" title="Example 4-3. Demonstration of read(), write(), and lseek()">Example 4-3</a>, showing what
                        happens when we attempt to read bytes from a file hole:</p><a id="I_programlisting4_d1e10340"/><pre class="programlisting">$ <strong class="userinput"><code>touch tfile</code></strong>                       <em class="lineannotation"><span class="lineannotation">Create new, empty file</span></em>
$ <strong class="userinput"><code>./seek_io tfile s100000</code></strong> <strong class="userinput"><code><em class="replaceable"><code>wabc</code></em></code></strong>      <em class="lineannotation"><span class="lineannotation">Seek to offset 100,000, write “abc”</span></em>
s100000: seek succeeded
wabc: wrote 3 bytes
$ <strong class="userinput"><code>ls -l tfile</code></strong>                       <em class="lineannotation"><span class="lineannotation">Check size of file</span></em>
-rw-r--r--    1 mtk    users   100003 Feb 10 10:35 tfile
$ <strong class="userinput"><code>./seek_io tfile s10000 R5</code></strong>         <em class="lineannotation"><span class="lineannotation">Seek to offset 10,000, read 5 bytes from hole</span></em>
s10000: seek succeeded
R5: 00 00 00 00 00                  <em class="lineannotation"><span class="lineannotation">Bytes in the hole contain 0</span></em></pre></div></div></div><div class="sect1" title="Operations Outside the Universal I/O Model: ioctl()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="operations_outside_the_universal_i_solid">Operations Outside the Universal I/O Model: <span class="emphasis"><em>ioctl()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>ioctl()</em></span> system call is a general-purpose mechanism for
                performing file and device operations that fall outside the universal I/O model
                described earlier in this chapter.<a id="IDX-CHP-4-0698" class="indexterm"/><a id="IDX-CHP-4-0699" class="indexterm"/><a id="IDX-CHP-4-0700" class="indexterm"/><a id="IDX-CHP-4-0697" class="indexterm"/></p><a id="I_programlisting4_d1e10400"/><pre class="programlisting">#include &lt;sys/ioctl.h&gt;

int <strong class="userinput"><code>ioctl</code></strong>(int <span class="emphasis"><em>fd</em></span>, int <span class="emphasis"><em>request</em></span>, ... /* <span class="emphasis"><em>argp</em></span> */);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Value returned on success depends on <span class="emphasis"><em>request</em></span>, or -1 on
                    error</p></div><p>The <span class="emphasis"><em>fd</em></span> argument is an open file descriptor for the device or
                file upon which the control operation specified by <span class="emphasis"><em>request</em></span> is
                to be performed. Device-specific header files define constants that can be passed in
                the <span class="emphasis"><em>request</em></span> argument.</p><p>As indicated by the standard C ellipsis (<code class="literal">...</code>)
                notation, the third argument to <span class="emphasis"><em>ioctl()</em></span>, which we label
                    <span class="emphasis"><em>argp</em></span>, can be of any type. The value of the
                    <span class="emphasis"><em>request</em></span> argument enables <span class="emphasis"><em>ioctl()</em></span> to
                determine what type of value to expect in <span class="emphasis"><em>argp</em></span>. Typically,
                    <span class="emphasis"><em>argp</em></span> is a pointer to either an integer or a structure; in
                some cases, it is unused.</p><p>We’ll see a number of uses for <span class="emphasis"><em>ioctl()</em></span> in later chapters
                (see, for example, <a class="xref" href="ch15.html#i-node_flags_open_parenthesis_ext2_exten" title="I-node Flags (ext2 Extended File Attributes)">I-node Flags (<span class="emphasis"><em>ext2</em></span> Extended File Attributes)</a>).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The only specification that SUSv3 makes for <span class="emphasis"><em>ioctl()</em></span> is
                    for operations to control STREAMS devices. (The STREAMS facility is a System V
                    feature that is not supported by the mainline Linux kernel, although a few
                    add-on implementations have been developed.) None of the other
                        <span class="emphasis"><em>ioctl()</em></span> operations described in this book is specified
                    in SUSv3. However, the <span class="emphasis"><em>ioctl()</em></span> call has been part of the
                    UNIX system since early versions, and consequently several of the
                        <span class="emphasis"><em>ioctl()</em></span> operations that we describe are provided on
                    many other UNIX implementations. As we describe each
                        <span class="emphasis"><em>ioctl()</em></span> operation, we note portability issues.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id3">Summary</h2></div></div></div><p>In order to perform I/O on a regular file, we must first obtain a file descriptor
                using <span class="emphasis"><em>open()</em></span>. I/O is then performed using
                    <span class="emphasis"><em>read()</em></span> and <span class="emphasis"><em>write()</em></span>. After performing
                all I/O, we should free the file descriptor and its associated resources using
                    <span class="emphasis"><em>close()</em></span>. These system calls can be used to perform I/O on
                all types of files.</p><p>The fact that all file types and device drivers implement the same I/O interface
                allows for universality of I/O, meaning that a program can typically be used with
                any type of file without requiring code that is specific to the file type.</p><p>For each open file, the kernel maintains a file offset, which determines the
                location at which the next read or write will occur. The file offset is implicitly
                updated by reads and writes. Using <span class="emphasis"><em>lseek()</em></span>, we can explicitly
                reposition the file offset to any location within the file or past the end of the
                file. Writing data at a position beyond the previous end of the file creates a hole
                in the file. Reads from a file hole return bytes containing zeros.</p><p>The <span class="emphasis"><em>ioctl()</em></span> system call is a catchall for device and file
                operations that don’t fit into the standard file I/O model.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id1">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <span class="emphasis"><em>tee</em></span> command reads its standard input until
                        end-of-file, writing a copy of the input to standard output and to the file
                        named in its command-line argument. (We show an example of the use of this
                        command when we discuss FIFOs in Section 44.7.) Implement
                            <span class="emphasis"><em>tee</em></span> using I/O system calls. By default,
                            <span class="emphasis"><em>tee</em></span> overwrites any existing file with the given
                        name. Implement the -<span class="emphasis"><em>a</em></span> command-line option
                            (<span class="emphasis"><em>tee -a file</em></span>), which causes
                            <span class="emphasis"><em>tee</em></span> to append text to the end of a file if it
                        already exists. (Refer to <a class="xref" href="apb.html" title="Appendix B. Parsing Command-Line Options">Appendix B</a> for
                        a description of the <span class="emphasis"><em>getopt()</em></span> function, which can be
                        used to parse command-line options.)<a id="IDX-CHP-4-0701" class="indexterm"/></p></li><li class="listitem"><p>Write a program like <span class="emphasis"><em>cp</em></span> that, when used to copy a
                        regular file that contains holes (sequences of null bytes), also creates
                        corresponding holes in the target file.</p></li></ol></div></div></section></body></html>
