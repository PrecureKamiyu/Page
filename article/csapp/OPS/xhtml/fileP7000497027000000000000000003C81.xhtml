<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>4.2 Logic Design and the Hardware Control Language HCL</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000003C81" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000041E65" data-uri="chapter04.xhtml#P7000497027000000000000000041E65" epub:type="title"><span class="pcalibre label pcalibre1">4.2 </span>Logic Design and the Hardware Control Language HCL</h1></header>
<p id="P7000497027000000000000000041E66" data-uri="chapter04.xhtml#P7000497027000000000000000041E66" class="pcalibre1 pcalibre calibre2">In hardware design, electronic circuits are used to compute functions on bits and to store bits in different kinds of memory elements. Most contemporary circuit technology represents different bit values as high or low voltages on signal wires. In current technology, logic value 1 is represented by a high voltage of around 1.0 volt, while logic value 0 is represented by a low voltage of around 0.0 volts. Three major components are required to implement a digital system: <i class="calibre5 pcalibre pcalibre1">combinational logic</i> to compute functions on the bits, <i class="calibre5 pcalibre pcalibre1">memory elements</i> to store bits, and <i class="calibre5 pcalibre pcalibre1">clock signals</i> to regulate the updating of the memory elements.</p>
<p id="P7000497027000000000000000041E67" data-uri="chapter04.xhtml#P7000497027000000000000000041E67" class="pcalibre1 pcalibre calibre2">In this section, we provide a brief description of these different components. We also introduce HCL (for "hardware control language"), the language that we use to describe the control logic of the different processor designs. We only describe HCL informally here. A complete reference for HCL can be found in Web Aside <span class="smallcaps pcalibre pcalibre1">arch:hcl </span>on page 472.</p>

<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000003C85" data-uri="chapter04.xhtml#P7000497027000000000000000003C85"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000041E68" data-uri="chapter04.xhtml#P7000497027000000000000000041E68" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003C87" title="373" data-uri="chapter04.xhtml#P7000497027000000000000000003C87" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Modern logic design</h1></header>
<p id="P7000497027000000000000000041E69" data-uri="chapter04.xhtml#P7000497027000000000000000041E69" class="calibre13 pcalibre pcalibre1">At one time, hardware designers created circuit designs by drawing schematic diagrams of logic circuits (first with paper and pencil, and later with computer graphics terminals). Nowadays, most designs are expressed in a <i class="calibre5 pcalibre pcalibre1">hardware description language</i> (HDL), a textual notation that looks similar to a programming language but that is used to describe hardware structures rather than program behaviors. The most commonly used languages are Verilog, having a syntax similar to C, and VHDL, having a syntax similar to the Ada programming language. These languages were originally designed for creating simulation models of digital circuits. In the mid-1980s, researchers developed <i class="calibre5 pcalibre pcalibre1">logic synthesis</i> programs that could generate efficient circuit designs from HDL descriptions. There are now a number of commercial synthesis programs, and this has become the dominant technique for generating digital circuits. This shift from hand-designed circuits to synthesized ones can be likened to the shift from writing programs in assembly code to writing them in a high-level language and having a compiler generate the machine code.</p>
<p id="P7000497027000000000000000041E6A" data-uri="chapter04.xhtml#P7000497027000000000000000041E6A" class="pcalibre calibre3 pcalibre1">Our HCL language expresses only the control portions of a hardware design, with only a limited set of operations and with no modularity. As we will see, however, the control logic is the most difficult part of designing a microprocessor. We have developed tools that can directly translate HCL into Verilog, and by combining this code with Verilog code for the basic hardware units, we can generate HDL descriptions from which actual working microprocessors can be synthesized. By carefully separating out, designing, and testing the control logic, we can create a working microprocessor with reasonable effort. Web Aside <span class="smallcaps pcalibre pcalibre1">arch:vlog </span>on page 467 describes how we can generate Verilog versions of a Y86-64 processor.</p>
</aside>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003C8A" data-uri="chapter04.xhtml#P7000497027000000000000000003C8A">
<img alt="A diagram illustrates three logic gate types." id="P7000497027000000000000000041E6B" data-uri="P700049702700000000000000000B6CD" src="../images/p373-1.png" class="calibre107 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000041E6C" data-uri="chapter04.xhtml#P7000497027000000000000000041E6C" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041E6D" data-uri="chapter04.xhtml#P7000497027000000000000000041E6D" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">4.9 </span>Logic gate types.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041E6E" data-uri="chapter04.xhtml#P7000497027000000000000000041E6E"><p id="P7000497027000000000000000041E6F" data-uri="chapter04.xhtml#P7000497027000000000000000041E6F" class="pcalibre1 pcalibre calibre2">Each gate generates output equal to some Boolean function of its inputs.</p><p id="P7000497027000000000000000041E70" data-uri="chapter04.xhtml#P7000497027000000000000000041E70" class="pcalibre calibre3 pcalibre1">
</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000022150" data-uri="chapter04.xhtml#P7000497027000000000000000022150">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000041E71" data-uri="chapter04.xhtml#P7000497027000000000000000041E71" class="pcalibre1 pcalibre calibre2">The three logic gate types are summarized below.</p>
<ul id="P7000497027000000000000000041E72" data-uri="chapter04.xhtml#P7000497027000000000000000041E72" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000041E73" data-uri="chapter04.xhtml#P7000497027000000000000000041E73" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041E74" data-uri="chapter04.xhtml#P7000497027000000000000000041E74" class="pcalibre calibre3 pcalibre1">AND: round bullet shape with a and b on the left and out on the right, depicting out = a &amp;&amp; b</p></li>
<li id="P7000497027000000000000000041E75" data-uri="chapter04.xhtml#P7000497027000000000000000041E75" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041E76" data-uri="chapter04.xhtml#P7000497027000000000000000041E76" class="pcalibre calibre3 pcalibre1">OR: pointing bullet shape with and b on the left and out on the right, depicting out = a | | b</p></li>
<li id="P7000497027000000000000000041E77" data-uri="chapter04.xhtml#P7000497027000000000000000041E77" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041E78" data-uri="chapter04.xhtml#P7000497027000000000000000041E78" class="pcalibre calibre3 pcalibre1">NOT: triangle with a on the left and out on the right, depicting out = !a</p></li>
</ul>
</details>
</figcaption>
</figure>

<section id="P7000497027000000000000000003C90" data-uri="chapter04.xhtml#P7000497027000000000000000003C90" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000041E79" data-uri="chapter04.xhtml#P7000497027000000000000000041E79" epub:type="title"><span class="pcalibre label pcalibre1">4.2.1 </span>Logic Gates</h1></header>
<p id="P7000497027000000000000000041E7A" data-uri="chapter04.xhtml#P7000497027000000000000000041E7A" class="pcalibre1 pcalibre calibre2">Logic gates are the basic computing elements for digital circuits. They generate an output equal to some Boolean function of the bit values at their inputs. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003C8A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.9</span></a> shows the standard symbols used for Boolean functions <span class="smallcaps pcalibre pcalibre1">and, or</span>, and <span class="smallcaps pcalibre pcalibre1">not. </span>HCL expressions are shown below the gates for the operators in C (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000002AD_split_001.xhtml#P70004970270000000000000000006AF"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">2.1.8</span></a>): <code id="P7000497027000000000000000041E7B" data-uri="chapter04.xhtml#P7000497027000000000000000041E7B" class="pcalibre1 calibre8 pcalibre">&amp;&amp;</code> for <span class="smallcaps pcalibre pcalibre1">and</span>, || for <span class="smallcaps pcalibre pcalibre1">or</span>, and ! for <span class="smallcaps pcalibre pcalibre1">not. </span>We use these instead of the bit-level C operators <code id="P7000497027000000000000000041E7C" data-uri="chapter04.xhtml#P7000497027000000000000000041E7C" class="pcalibre1 calibre8 pcalibre">&amp;</code>, |, and ~, because logic gates operate on single-bit quantities, not entire words. Although the figure illustrates only two-input versions of the <span class="smallcaps pcalibre pcalibre1">and </span>and <span class="smallcaps pcalibre pcalibre1">or </span>gates, it is common to see these being used as <var class="calibre5 pcalibre pcalibre1">n</var>-way operations for <var class="calibre5 pcalibre pcalibre1">n</var> &gt; 2. We still write these in HCL using binary operators, though, so the operation of a three-input <span class="smallcaps pcalibre pcalibre1">and </span>gate with inputs a, b, and c is described with the HCL expression a <code id="P7000497027000000000000000041E7D" data-uri="chapter04.xhtml#P7000497027000000000000000041E7D" class="pcalibre1 calibre8 pcalibre">&amp;&amp;</code> b <code id="P7000497027000000000000000041E7E" data-uri="chapter04.xhtml#P7000497027000000000000000041E7E" class="pcalibre1 calibre8 pcalibre">&amp;&amp;</code> c.</p>
<p id="P7000497027000000000000000041E7F" data-uri="chapter04.xhtml#P7000497027000000000000000041E7F" class="pcalibre1 pcalibre calibre2">Logic gates are always active. If some input to a gate changes, then within some small amount of time, the output will change accordingly.</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003C98" data-uri="chapter04.xhtml#P7000497027000000000000000003C98">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003C99" title="374" data-uri="chapter04.xhtml#P7000497027000000000000000003C99" epub:type="pagebreak"></span><img alt="A diagram illustrates a combination circuit." id="P7000497027000000000000000041E80" data-uri="P700049702700000000000000000B6CE" src="../images/p374-1.png" class="pcalibre calibre108 pcalibre1"/>
<figcaption id="P7000497027000000000000000041E81" data-uri="chapter04.xhtml#P7000497027000000000000000041E81" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041E82" data-uri="chapter04.xhtml#P7000497027000000000000000041E82" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">4.10 </span>Combinational circuit to test for bit equality.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041E83" data-uri="chapter04.xhtml#P7000497027000000000000000041E83"><p id="P7000497027000000000000000041E84" data-uri="chapter04.xhtml#P7000497027000000000000000041E84" class="pcalibre1 pcalibre calibre2">The output will equal 1 when both inputs are 0 or both are 1.</p><p id="P7000497027000000000000000041E85" data-uri="chapter04.xhtml#P7000497027000000000000000041E85" class="pcalibre calibre3 pcalibre1">
</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000022165" data-uri="chapter04.xhtml#P7000497027000000000000000022165">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000041E86" data-uri="chapter04.xhtml#P7000497027000000000000000041E86" class="pcalibre calibre3 pcalibre1">A circuit has a and b on the left and eq on the right, with bit equal in between containing a circuit of logic gates. The bit equal has two AND gates leading to an OR gate, which leads to eq. A and B are each connected to the top AND gate and separate NOT gates, which are each connected to the bottom AND gate.</p>
</details>
</figcaption>
</figure>
</section>
<section id="P7000497027000000000000000003C9F" data-uri="chapter04.xhtml#P7000497027000000000000000003C9F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000041E87" data-uri="chapter04.xhtml#P7000497027000000000000000041E87" epub:type="title"><span class="pcalibre label pcalibre1">4.2.2 </span>Combinational Circuits and HCL Boolean Expressions</h1></header>
<p id="P7000497027000000000000000041E88" data-uri="chapter04.xhtml#P7000497027000000000000000041E88" class="pcalibre1 pcalibre calibre2">By assembling a number of logic gates into a network, we can construct computational blocks known as <i class="calibre5 pcalibre pcalibre1">combinational circuits.</i> Several restrictions are placed on how the networks are constructed:</p>
<ul id="P7000497027000000000000000041E89" data-uri="chapter04.xhtml#P7000497027000000000000000041E89" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000041E8A" data-uri="chapter04.xhtml#P7000497027000000000000000041E8A" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041E8B" data-uri="chapter04.xhtml#P7000497027000000000000000041E8B" class="pcalibre calibre3 pcalibre1">Every logic gate input must be connected to exactly one of the following: (1) one of the system inputs (known as a <i class="calibre5 pcalibre pcalibre1">primary input</i>), (2) the output connection of some memory element, or (3) the output of some logic gate.</p></li>
<li id="P7000497027000000000000000041E8C" data-uri="chapter04.xhtml#P7000497027000000000000000041E8C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041E8D" data-uri="chapter04.xhtml#P7000497027000000000000000041E8D" class="pcalibre calibre3 pcalibre1">The outputs of two or more logic gates cannot be connected together. Otherwise, the two could try to drive the wire toward different voltages, possibly causing an invalid voltage or a circuit malfunction.</p></li>
<li id="P7000497027000000000000000041E8E" data-uri="chapter04.xhtml#P7000497027000000000000000041E8E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041E8F" data-uri="chapter04.xhtml#P7000497027000000000000000041E8F" class="pcalibre calibre3 pcalibre1">The network must be <i class="calibre5 pcalibre pcalibre1">acyclic.</i> That is, there cannot be a path through a series of gates that forms a loop in the network. Such loops can cause ambiguity in the function computed by the network.</p></li>
</ul>
<p id="P7000497027000000000000000041E90" data-uri="chapter04.xhtml#P7000497027000000000000000041E90" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003C98"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.10</span></a> shows an example of a simple combinational circuit that we will find useful. It has two inputs, a and b. It generates a single output eq, such that the output will equal 1 if either a and b are both 1 (detected by the upper <span class="smallcaps pcalibre pcalibre1">and </span>gate) or are both 0 (detected by the lower <span class="smallcaps pcalibre pcalibre1">and </span>gate). We write the function of this network in HCL as</p>
<pre id="P7000497027000000000000000041E91" data-uri="chapter04.xhtml#P7000497027000000000000000041E91" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041E92" data-uri="chapter04.xhtml#P7000497027000000000000000041E92" class="calibre10 pcalibre pcalibre1">bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</code></pre>
<p id="P7000497027000000000000000041E93" data-uri="chapter04.xhtml#P7000497027000000000000000041E93" class="pcalibre1 pcalibre calibre2">This code simply defines the bit-level (denoted by data type <code id="P7000497027000000000000000041E94" data-uri="chapter04.xhtml#P7000497027000000000000000041E94" class="pcalibre1 calibre8 pcalibre">bool</code>) signal eq as a function of inputs a and b. As this example shows, HCL uses C-style syntax, with `=' associating a signal name with an expression. Unlike C, however, we do not view this as performing a computation and assigning the result to some memory location. Instead, it is simply a way to give a name to an expression.</p>
<section id="P7000497027000000000000000003CAE" data-uri="chapter04.xhtml#P7000497027000000000000000003CAE" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041E95" data-uri="chapter04.xhtml#P7000497027000000000000000041E95" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">4.9 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<p id="P7000497027000000000000000041E96" data-uri="chapter04.xhtml#P7000497027000000000000000041E96" class="pcalibre1 pcalibre calibre2">Write an HCL expression for a signal <code id="P7000497027000000000000000041E97" data-uri="chapter04.xhtml#P7000497027000000000000000041E97" class="pcalibre1 calibre8 pcalibre">xor</code>, equal to the <span class="smallcaps pcalibre pcalibre1">exclusive-or </span>of inputs a and b. What is the relation between the signals <code id="P7000497027000000000000000041E98" data-uri="chapter04.xhtml#P7000497027000000000000000041E98" class="pcalibre1 calibre8 pcalibre">xor</code> and eq defined above?</p>
</section>
<p id="P7000497027000000000000000041E99" data-uri="chapter04.xhtml#P7000497027000000000000000041E99" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CB4"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.11</span></a> shows another example of a simple but useful combinational circuit known as a <i class="calibre5 pcalibre pcalibre1">multiplexor</i> (commonly referred to as a "MUX"). A multiplexor</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003CB4" data-uri="chapter04.xhtml#P7000497027000000000000000003CB4">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003CB5" title="375" data-uri="chapter04.xhtml#P7000497027000000000000000003CB5" epub:type="pagebreak"></span><img alt="A diagram illustrates a multiplexor circuit." id="P7000497027000000000000000041E9A" data-uri="P700049702700000000000000000B6CF" src="../images/p375-1.png" class="pcalibre1 pcalibre calibre109"/>
<figcaption id="P7000497027000000000000000041E9B" data-uri="chapter04.xhtml#P7000497027000000000000000041E9B" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041E9C" data-uri="chapter04.xhtml#P7000497027000000000000000041E9C" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">4.11 </span>Single-bit multiplexor circuit.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041E9D" data-uri="chapter04.xhtml#P7000497027000000000000000041E9D"><p id="P7000497027000000000000000041E9E" data-uri="chapter04.xhtml#P7000497027000000000000000041E9E" class="pcalibre calibre3 pcalibre1">The output will equal input a if the control signal s is 1 and will equal input b when s is 0.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P700049702700000000000000002217F" data-uri="chapter04.xhtml#P700049702700000000000000002217F">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000041E9F" data-uri="chapter04.xhtml#P7000497027000000000000000041E9F" class="pcalibre calibre3 pcalibre1">A circuit has a, b, and s on the left and out on the right, with bit MUX in between containing a circuit of logic gates. The bit MUX has two AND gates leading to an OR gate, which leads to out. S is connected to the bottom AND gate and a NOT gate connected to the top AND gate. A is connected to the bottom AND gate and B connected to the top AND gate.</p>
</details>
</figcaption>
</figure>

<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041EA0" data-uri="chapter04.xhtml#P7000497027000000000000000041EA0">selects a value from among a set of different data signals, depending on the value of a control input signal. In this single-bit multiplexor, the two data signals are the input bits a and b, while the control signal is the input bit s. The output will equal a when s is 1, and it will equal b when s is 0. In this circuit, we can see that the two <span class="smallcaps pcalibre pcalibre1">and </span>gates determine whether to pass their respective data inputs to the <span class="smallcaps pcalibre pcalibre1">or </span>gate. The upper <span class="smallcaps pcalibre pcalibre1">and </span>gate passes signal b when s is 0 (since the other input to the gate is !s), while the lower <span class="smallcaps pcalibre pcalibre1">and </span>gate passes signal a when s is 1. Again, we can write an HCL expression for the output signal, using the same operations as are present in the combinational circuit:</p>
<pre id="P7000497027000000000000000041EA1" data-uri="chapter04.xhtml#P7000497027000000000000000041EA1" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041EA2" data-uri="chapter04.xhtml#P7000497027000000000000000041EA2" class="calibre10 pcalibre pcalibre1">bool out = (s &amp;&amp; a) || (!s &amp;&amp; b);</code></pre>
<p id="P7000497027000000000000000041EA3" data-uri="chapter04.xhtml#P7000497027000000000000000041EA3" class="pcalibre1 pcalibre calibre2">Our HCL expressions demonstrate a clear parallel between combinational logic circuits and logical expressions in C. They both use Boolean operations to compute functions over their inputs. Several differences between these two ways of expressing computation are worth noting:</p>
<ul id="P7000497027000000000000000041EA4" data-uri="chapter04.xhtml#P7000497027000000000000000041EA4" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000041EA5" data-uri="chapter04.xhtml#P7000497027000000000000000041EA5" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EA6" data-uri="chapter04.xhtml#P7000497027000000000000000041EA6" class="pcalibre calibre3 pcalibre1">Since a combinational circuit consists of a series of logic gates, it has the property that the outputs continually respond to changes in the inputs. If some input to the circuit changes, then after some delay, the outputs will change accordingly. By contrast, a C expression is only evaluated when it is encountered during the execution of a program.</p></li>
<li id="P7000497027000000000000000041EA7" data-uri="chapter04.xhtml#P7000497027000000000000000041EA7" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EA8" data-uri="chapter04.xhtml#P7000497027000000000000000041EA8" class="pcalibre calibre3 pcalibre1">Logical expressions in C allow arguments to be arbitrary integers, interpreting 0 as <span class="smallcaps pcalibre pcalibre1">false </span>and anything else as <span class="smallcaps pcalibre pcalibre1">true. </span>In contrast, our logic gates only operate over the bit values 0 and 1.</p></li>
<li id="P7000497027000000000000000041EA9" data-uri="chapter04.xhtml#P7000497027000000000000000041EA9" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EAA" data-uri="chapter04.xhtml#P7000497027000000000000000041EAA" class="pcalibre calibre3 pcalibre1">Logical expressions in C have the property that they might only be partially evaluated. If the outcome of an <span class="smallcaps pcalibre pcalibre1">and </span>or <span class="smallcaps pcalibre pcalibre1">or </span>operation can be determined by just evaluating the first argument, then the second argument will not be evaluated. For example, with the C expression</p></li>
</ul>
<pre id="P7000497027000000000000000041EAB" data-uri="chapter04.xhtml#P7000497027000000000000000041EAB" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041EAC" data-uri="chapter04.xhtml#P7000497027000000000000000041EAC" class="calibre10 pcalibre pcalibre1">(a &amp;&amp; !a) &amp;&amp; func(b, c)</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041EAD" data-uri="chapter04.xhtml#P7000497027000000000000000041EAD">the function <code id="P7000497027000000000000000041EAE" data-uri="chapter04.xhtml#P7000497027000000000000000041EAE" class="pcalibre1 calibre8 pcalibre">func</code> will not be called, because the expression (<code id="P7000497027000000000000000041EAF" data-uri="chapter04.xhtml#P7000497027000000000000000041EAF" class="pcalibre1 calibre8 pcalibre">a &amp;&amp; !a</code>) evaluates to 0. In contrast, combinational logic does not have any partial evaluation rules. The gates simply respond to changing inputs.</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003CCB" data-uri="chapter04.xhtml#P7000497027000000000000000003CCB">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003CCC" title="376" data-uri="chapter04.xhtml#P7000497027000000000000000003CCC" epub:type="pagebreak"></span><img alt="Diagrams illustrate bit-level implementation and word-level abstraction for equality test circuit." id="P7000497027000000000000000041EB0" data-uri="P700049702700000000000000000B6D1" src="../images/p376-1.png" class="calibre110 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000041EB1" data-uri="chapter04.xhtml#P7000497027000000000000000041EB1" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041EB2" data-uri="chapter04.xhtml#P7000497027000000000000000041EB2" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">4.12 </span>Word-level equality test circuit.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041EB3" data-uri="chapter04.xhtml#P7000497027000000000000000041EB3"><p id="P7000497027000000000000000041EB4" data-uri="chapter04.xhtml#P7000497027000000000000000041EB4" class="pcalibre1 pcalibre calibre2">The output will equal 1 when each bit from word A equals its counterpart from word B. Word-level equality is one of the operations in HCL.</p><p id="P7000497027000000000000000041EB5" data-uri="chapter04.xhtml#P7000497027000000000000000041EB5" class="pcalibre calibre3 pcalibre1">
</p></div>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000022196" data-uri="chapter04.xhtml#P7000497027000000000000000022196">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000041EB6" data-uri="chapter04.xhtml#P7000497027000000000000000041EB6" class="pcalibre1 pcalibre calibre2">Two diagrams are summarized below.</p>
<ul id="P7000497027000000000000000041EB7" data-uri="chapter04.xhtml#P7000497027000000000000000041EB7" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000041EB8" data-uri="chapter04.xhtml#P7000497027000000000000000041EB8" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EB9" data-uri="chapter04.xhtml#P7000497027000000000000000041EB9" class="pcalibre calibre3 pcalibre1">Bit-level implementation: four bit equal diagrams led to an AND gate and Eq:</p>
<ul id="P7000497027000000000000000041EBA" data-uri="chapter04.xhtml#P7000497027000000000000000041EBA" class="pcalibre calibre39 pcalibre1">
<li id="P7000497027000000000000000041EBB" data-uri="chapter04.xhtml#P7000497027000000000000000041EBB" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EBC" data-uri="chapter04.xhtml#P7000497027000000000000000041EBC" class="pcalibre calibre3 pcalibre1">a<sub class="pcalibre1 calibre47 pcalibre">63</sub> and b<sub class="pcalibre1 calibre47 pcalibre">63</sub> lead to eq<sub class="pcalibre1 calibre47 pcalibre">63</sub></p></li>
<li id="P7000497027000000000000000041EBD" data-uri="chapter04.xhtml#P7000497027000000000000000041EBD" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EBE" data-uri="chapter04.xhtml#P7000497027000000000000000041EBE" class="pcalibre calibre3 pcalibre1">a<sub class="pcalibre1 calibre47 pcalibre">62</sub> and b<sub class="pcalibre1 calibre47 pcalibre">62</sub> lead to eq<sub class="pcalibre1 calibre47 pcalibre">62</sub></p></li>
<li id="P7000497027000000000000000041EBF" data-uri="chapter04.xhtml#P7000497027000000000000000041EBF" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EC0" data-uri="chapter04.xhtml#P7000497027000000000000000041EC0" class="pcalibre calibre3 pcalibre1">a<sub class="pcalibre1 calibre47 pcalibre">1</sub> and b<sub class="pcalibre1 calibre47 pcalibre">1</sub> lead to eq<sub class="pcalibre1 calibre47 pcalibre">1</sub></p></li>
<li id="P7000497027000000000000000041EC1" data-uri="chapter04.xhtml#P7000497027000000000000000041EC1" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EC2" data-uri="chapter04.xhtml#P7000497027000000000000000041EC2" class="pcalibre calibre3 pcalibre1">a<sub class="pcalibre1 calibre47 pcalibre">0</sub> and b<sub class="pcalibre1 calibre47 pcalibre">0</sub> lead to eq<sub class="pcalibre1 calibre47 pcalibre">0</sub></p></li>
</ul></li>
<li id="P7000497027000000000000000041EC3" data-uri="chapter04.xhtml#P7000497027000000000000000041EC3" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EC4" data-uri="chapter04.xhtml#P7000497027000000000000000041EC4" class="pcalibre calibre3 pcalibre1">Word-level implemention: B and A lead to = which leads to A == B.</p></li>
</ul>
</details>
</figcaption>
</figure>
</section>

<section id="P7000497027000000000000000003CD2" data-uri="chapter04.xhtml#P7000497027000000000000000003CD2" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000041EC5" data-uri="chapter04.xhtml#P7000497027000000000000000041EC5" epub:type="title"><span class="pcalibre label pcalibre1">4.2.3 </span>Word-Level Combinational Circuits and HCL Integer Expressions</h1></header>
<p id="P7000497027000000000000000041EC6" data-uri="chapter04.xhtml#P7000497027000000000000000041EC6" class="pcalibre1 pcalibre calibre2">By assembling large networks of logic gates, we can construct combinational circuits that compute much more complex functions. Typically, we design circuits that operate on data <i class="calibre5 pcalibre pcalibre1">words.</i> These are groups of bit-level signals that represent an integer or some control pattern. For example, our processor designs will contain numerous words, with word sizes ranging between 4 and 64 bits, representing integers, addresses, instruction codes, and register identifiers.</p>
<p id="P7000497027000000000000000041EC7" data-uri="chapter04.xhtml#P7000497027000000000000000041EC7" class="pcalibre1 pcalibre calibre2">Combinational circuits that perform word-level computations are constructed using logic gates to compute the individual bits of the output word, based on the individual bits of the input words. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CCB"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.12</span></a> shows a combinational circuit that tests whether two 64-bit words A and B are equal. That is, the output will equal 1 if and only if each bit of A equals the corresponding bit of B. This circuit is implemented using 64 of the single-bit equality circuits shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003C98"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.10</span></a>. The outputs of these single-bit circuits are combined with an <span class="smallcaps pcalibre pcalibre1">and </span>gate to form the circuit output.</p>
<p id="P7000497027000000000000000041EC8" data-uri="chapter04.xhtml#P7000497027000000000000000041EC8" class="pcalibre1 pcalibre calibre2">In HCL, we will declare any word-level signal as an <code id="P7000497027000000000000000041EC9" data-uri="chapter04.xhtml#P7000497027000000000000000041EC9" class="pcalibre1 calibre8 pcalibre">int</code>, without specifying the word size. This is done for simplicity. In a full-featured hardware description language, every word can be declared to have a specific number of bits. HCL allows words to be compared for equality, and so the functionality of the circuit shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CCB"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.12</span></a> can be expressed at the word level as</p>
<p id="P7000497027000000000000000041ECA" data-uri="chapter04.xhtml#P7000497027000000000000000041ECA" class="pcalibre1 pcalibre calibre2"><code id="P7000497027000000000000000041ECB" data-uri="chapter04.xhtml#P7000497027000000000000000041ECB" class="pcalibre1 calibre8 pcalibre">bool Eq = (A == B);</code></p>
<p id="P7000497027000000000000000041ECC" data-uri="chapter04.xhtml#P7000497027000000000000000041ECC" class="pcalibre1 pcalibre calibre2">where arguments A and B are of type int. Note that we use the same syntax conventions as in C, where `=' denotes assignment and `==' denotes the equality operator.</p>

<p id="P7000497027000000000000000041ECD" data-uri="chapter04.xhtml#P7000497027000000000000000041ECD" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003CDC" title="377" data-uri="chapter04.xhtml#P7000497027000000000000000003CDC" epub:type="pagebreak"></span>As is shown on the right side of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CCB"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.12</span></a>, we will draw word-level circuits using medium-thickness lines to represent the set of wires carrying the individual bits of the word, and we will show a single-bit signal as a dashed line.</p>
<section id="P7000497027000000000000000003CDD" data-uri="chapter04.xhtml#P7000497027000000000000000003CDD" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041ECE" data-uri="chapter04.xhtml#P7000497027000000000000000041ECE" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">4.10 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<p id="P7000497027000000000000000041ECF" data-uri="chapter04.xhtml#P7000497027000000000000000041ECF" class="pcalibre1 pcalibre calibre2">Suppose you want to implement a word-level equality circuit using the <span class="smallcaps pcalibre pcalibre1">exclusive-or </span>circuits from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CAE"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">4.9</span></a> rather than from bit-level equality circuits. Design such a circuit for a 64-bit word consisting of 64 bit-level <span class="smallcaps pcalibre pcalibre1">exclusive-or </span>circuits and two additional logic gates.</p>
</section>
<p id="P7000497027000000000000000041ED0" data-uri="chapter04.xhtml#P7000497027000000000000000041ED0" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CE1"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.13</span></a> shows the circuit for a word-level multiplexor. This circuit generates a 64-bit word Out equal to one of the two input words, A or B, depending on the control input bit s. The circuit consists of 64 identical subcircuits, each having a structure similar to the bit-level multiplexor from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CB4"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.11</span></a>. Rather than replicating the bit-level multiplexor 64 times, the word-level version reduces the number of inverters by generating !s once and reusing it at each bit position.</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003CE1" data-uri="chapter04.xhtml#P7000497027000000000000000003CE1">
<img alt="Diagrams illustrate bit-level implementation and word-level abstraction for multiplexor circuit." id="P7000497027000000000000000041ED1" data-uri="P700049702700000000000000000B6D2" src="../images/p377-1.png" class="calibre111 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000041ED2" data-uri="chapter04.xhtml#P7000497027000000000000000041ED2" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041ED3" data-uri="chapter04.xhtml#P7000497027000000000000000041ED3" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">4.13 </span>Word-level multiplexor circuit.</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041ED4" data-uri="chapter04.xhtml#P7000497027000000000000000041ED4"><p id="P7000497027000000000000000041ED5" data-uri="chapter04.xhtml#P7000497027000000000000000041ED5" class="pcalibre1 pcalibre calibre2"> The output will equal input word A when the control signal s is 1, and it will equal B otherwise. Multiplexors are described in HCL using case expressions.</p><p id="P7000497027000000000000000041ED6" data-uri="chapter04.xhtml#P7000497027000000000000000041ED6" class="pcalibre calibre3 pcalibre1">
</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000221B7" data-uri="chapter04.xhtml#P70004970270000000000000000221B7">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000041ED7" data-uri="chapter04.xhtml#P7000497027000000000000000041ED7" class="pcalibre1 pcalibre calibre2">Two diagrams are summarized below.</p>
<ul id="P7000497027000000000000000041ED8" data-uri="chapter04.xhtml#P7000497027000000000000000041ED8" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000041ED9" data-uri="chapter04.xhtml#P7000497027000000000000000041ED9" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EDA" data-uri="chapter04.xhtml#P7000497027000000000000000041EDA" class="pcalibre calibre3 pcalibre1">Bit-level implementation: s leads to a series of AND gates as well as a NOT gate leading to the AND gates. Pairs of AND gates leads to OR gates leading to an OUT:</p>
<ul id="P7000497027000000000000000041EDB" data-uri="chapter04.xhtml#P7000497027000000000000000041EDB" class="pcalibre calibre39 pcalibre1">
<li id="P7000497027000000000000000041EDC" data-uri="chapter04.xhtml#P7000497027000000000000000041EDC" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EDD" data-uri="chapter04.xhtml#P7000497027000000000000000041EDD" class="pcalibre calibre3 pcalibre1">Leading to out<sub class="pcalibre1 calibre47 pcalibre">63</sub>, b<sub class="pcalibre1 calibre47 pcalibre">63</sub> and a<sub class="pcalibre1 calibre47 pcalibre">63</sub> lead to separate AND gates</p></li>
<li id="P7000497027000000000000000041EDE" data-uri="chapter04.xhtml#P7000497027000000000000000041EDE" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EDF" data-uri="chapter04.xhtml#P7000497027000000000000000041EDF" class="pcalibre calibre3 pcalibre1">Leading to out<sub class="pcalibre1 calibre47 pcalibre">62</sub>, b<sub class="pcalibre1 calibre47 pcalibre">62</sub> and a<sub class="pcalibre1 calibre47 pcalibre">62</sub> lead to separate AND gates</p></li>
<li id="P7000497027000000000000000041EE0" data-uri="chapter04.xhtml#P7000497027000000000000000041EE0" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EE1" data-uri="chapter04.xhtml#P7000497027000000000000000041EE1" class="pcalibre calibre3 pcalibre1">Leading to out<sub class="pcalibre1 calibre47 pcalibre">0</sub>, b<sub class="pcalibre1 calibre47 pcalibre">0</sub> and a<sub class="pcalibre1 calibre47 pcalibre">0</sub> lead to separate AND gates</p></li>
</ul></li>
<li id="P7000497027000000000000000041EE2" data-uri="chapter04.xhtml#P7000497027000000000000000041EE2" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EE3" data-uri="chapter04.xhtml#P7000497027000000000000000041EE3" class="pcalibre calibre3 pcalibre1">Word-level abstraction: S, B, and A lead to MUX, which leads to Out, showing:</p>
<ul id="P7000497027000000000000000041EE4" data-uri="chapter04.xhtml#P7000497027000000000000000041EE4" class="pcalibre calibre39 pcalibre1">
<li id="P7000497027000000000000000041EE5" data-uri="chapter04.xhtml#P7000497027000000000000000041EE5" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EE6" data-uri="chapter04.xhtml#P7000497027000000000000000041EE6" class="pcalibre calibre3 pcalibre1">Int Out = [</p>
<ul id="P7000497027000000000000000041EE7" data-uri="chapter04.xhtml#P7000497027000000000000000041EE7" class="calibre112 pcalibre pcalibre1">
<li id="P7000497027000000000000000041EE8" data-uri="chapter04.xhtml#P7000497027000000000000000041EE8" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EE9" data-uri="chapter04.xhtml#P7000497027000000000000000041EE9" class="pcalibre calibre3 pcalibre1">S : A;</p></li>
<li id="P7000497027000000000000000041EEA" data-uri="chapter04.xhtml#P7000497027000000000000000041EEA" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EEB" data-uri="chapter04.xhtml#P7000497027000000000000000041EEB" class="pcalibre calibre3 pcalibre1">L: B;</p></li>
</ul></li>
<li id="P7000497027000000000000000041EEC" data-uri="chapter04.xhtml#P7000497027000000000000000041EEC" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041EED" data-uri="chapter04.xhtml#P7000497027000000000000000041EED" class="pcalibre calibre3 pcalibre1">] ;</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>

<p id="P7000497027000000000000000041EEE" data-uri="chapter04.xhtml#P7000497027000000000000000041EEE" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003CE8" title="378" data-uri="chapter04.xhtml#P7000497027000000000000000003CE8" epub:type="pagebreak"></span>We will use many forms of multiplexors in our processor designs. They allow us to select a word from a number of sources depending on some control condition. Multiplexing functions are described in HCL using <i class="calibre5 pcalibre pcalibre1">case expressions.</i> A case expression has the following general form:</p>
<pre id="P7000497027000000000000000041EEF" data-uri="chapter04.xhtml#P7000497027000000000000000041EEF" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041EF0" data-uri="chapter04.xhtml#P7000497027000000000000000041EF0" class="calibre10 pcalibre pcalibre1">[
<i class="calibre5 pcalibre pcalibre1">select<sub class="calibre85 pcalibre pcalibre1">1</sub> : expr<sub class="calibre85 pcalibre pcalibre1">1</sub>;</i>
<i class="calibre5 pcalibre pcalibre1">select<sub class="calibre85 pcalibre pcalibre1">2</sub></i> : <i class="calibre5 pcalibre pcalibre1">sxpr<sub class="calibre85 pcalibre pcalibre1">2</sub>;</i>
⋮
<i class="calibre5 pcalibre pcalibre1">select<sub class="calibre85 pcalibre pcalibre1">k</sub> : expr<sub class="calibre85 pcalibre pcalibre1">k</sub>;</i>
]
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041EF1" data-uri="chapter04.xhtml#P7000497027000000000000000041EF1">The expression contains a series of cases, where each case <var class="calibre5 pcalibre pcalibre1">i</var> consists of a Boolean expression <i class="calibre5 pcalibre pcalibre1">select<sub class="pcalibre1 calibre47 pcalibre">i</sub></i>, indicating when this case should be selected, and an integer expression <i class="calibre5 pcalibre pcalibre1">expr<sub class="pcalibre1 calibre47 pcalibre">i</sub></i>, indicating the resulting value.</p>
<p id="P7000497027000000000000000041EF2" data-uri="chapter04.xhtml#P7000497027000000000000000041EF2" class="pcalibre1 pcalibre calibre2">Unlike the switch statement of C, we do not require the different selection expressions to be mutually exclusive. Logically, the selection expressions are evaluated in sequence, and the case for the first one yielding 1 is selected. For example, the word-level multiplexor of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CE1"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.13</span></a> can be described in HCL as</p>
<pre id="P7000497027000000000000000041EF3" data-uri="chapter04.xhtml#P7000497027000000000000000041EF3" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041EF4" data-uri="chapter04.xhtml#P7000497027000000000000000041EF4" class="calibre10 pcalibre pcalibre1">word Out = [
	s: A;
	1: B;
];
</code></pre>
<p id="P7000497027000000000000000041EF5" data-uri="chapter04.xhtml#P7000497027000000000000000041EF5" class="pcalibre1 pcalibre calibre2">In this code, the second selection expression is simply 1, indicating that this case should be selected if no prior one has been. This is the way to specify a default case in HCL. Nearly all case expressions end in this manner.</p>
<p id="P7000497027000000000000000041EF6" data-uri="chapter04.xhtml#P7000497027000000000000000041EF6" class="pcalibre1 pcalibre calibre2">Allowing nonexclusive selection expressions makes the HCL code more readable. An actual hardware multiplexor must have mutually exclusive signals controlling which input word should be passed to the output, such as the signals s and !s in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CE1"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.13</span></a>. To translate an HCL case expression into hardware, a logic synthesis program would need to analyze the set of selection expressions and resolve any possible conflicts by making sure that only the first matching case would be selected.</p>
<p id="P7000497027000000000000000041EF7" data-uri="chapter04.xhtml#P7000497027000000000000000041EF7" class="pcalibre1 pcalibre calibre2">The selection expressions can be arbitrary Boolean expressions, and there can be an arbitrary number of cases. This allows case expressions to describe blocks where there are many choices of input signals with complex selection criteria. For example, consider the diagram of a 4-way multiplexor shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CF4"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.14</span></a>. This circuit selects from among the four input words A, B, C, and D based on the control signals s1 and s0, treating the controls as a 2-bit binary number. We can express this in HCL using Boolean expressions to describe the different combinations of control bit patterns:</p>
<pre id="P7000497027000000000000000041EF8" data-uri="chapter04.xhtml#P7000497027000000000000000041EF8" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041EF9" data-uri="chapter04.xhtml#P7000497027000000000000000041EF9" class="calibre10 pcalibre pcalibre1">word Out4 = [
	!s1 &amp;&amp; !s0 : A; # 00
</code></pre>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003CF4" data-uri="chapter04.xhtml#P7000497027000000000000000003CF4">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003CF5" title="379" data-uri="chapter04.xhtml#P7000497027000000000000000003CF5" epub:type="pagebreak"></span><img alt="A diagram of a four-way multiplexor shows s1, s0, D, C, B, and A leading to MUX4, which leads to Out4." id="P7000497027000000000000000041EFA" data-uri="P700049702700000000000000000B6D3" src="../images/p379-1.png" class="calibre113 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000041EFB" data-uri="chapter04.xhtml#P7000497027000000000000000041EFB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041EFC" data-uri="chapter04.xhtml#P7000497027000000000000000041EFC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">4.14 </span>Four-way multiplexor.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000041EFD" data-uri="chapter04.xhtml#P7000497027000000000000000041EFD"><p id="P7000497027000000000000000041EFE" data-uri="chapter04.xhtml#P7000497027000000000000000041EFE" class="pcalibre1 pcalibre calibre2"> The different combinations of control signals s1 and s0 determine which data input is transmitted to the output.</p><p id="P7000497027000000000000000041EFF" data-uri="chapter04.xhtml#P7000497027000000000000000041EFF" class="pcalibre calibre3 pcalibre1">
</p></div>
</figcaption>
</figure>
<pre id="P7000497027000000000000000041F00" data-uri="chapter04.xhtml#P7000497027000000000000000041F00" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041F01" data-uri="chapter04.xhtml#P7000497027000000000000000041F01" class="calibre10 pcalibre pcalibre1">	!s1 : B; # 01
	!s0 : C; # 10
	1 : D; # 11
];
</code></pre>
<p id="P7000497027000000000000000041F02" data-uri="chapter04.xhtml#P7000497027000000000000000041F02" class="pcalibre1 pcalibre calibre2">The comments on the right (any text starting with # and running for the rest of the line is a comment) show which combination of s1 and s0 will cause the case to be selected. Observe that the selection expressions can sometimes be simplified, since only the first matching case is selected. For example, the second expression can be written <code id="P7000497027000000000000000041F03" data-uri="chapter04.xhtml#P7000497027000000000000000041F03" class="pcalibre1 calibre8 pcalibre">!s1</code>, rather than the more complete <code id="P7000497027000000000000000041F04" data-uri="chapter04.xhtml#P7000497027000000000000000041F04" class="pcalibre1 calibre8 pcalibre">!s1 &amp;&amp; s0</code>, since the only other possibility having <code id="P7000497027000000000000000041F05" data-uri="chapter04.xhtml#P7000497027000000000000000041F05" class="pcalibre1 calibre8 pcalibre">s1</code> equal to 0 was given as the first selection expression. Similarly, the third expression can be written as <code id="P7000497027000000000000000041F06" data-uri="chapter04.xhtml#P7000497027000000000000000041F06" class="pcalibre1 calibre8 pcalibre">!s0</code>, while the fourth can simply be written as 1.</p>
<p id="P7000497027000000000000000041F07" data-uri="chapter04.xhtml#P7000497027000000000000000041F07" class="pcalibre1 pcalibre calibre2">As a final example, suppose we want to design a logic circuit that finds the minimum value among a set of words A, B, and C, diagrammed as follows:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003D03" data-uri="chapter04.xhtml#P7000497027000000000000000003D03">
<img alt="A diagram shows C, B, and A leading to MIN3, leading to Min3." id="P7000497027000000000000000041F08" data-uri="P700049702700000000000000000B6D4" src="../images/p379-2.png" class="pcalibre1 calibre114 pcalibre"/>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041F09" data-uri="chapter04.xhtml#P7000497027000000000000000041F09">We can express this using an HCL case expression as</p>
<pre id="P7000497027000000000000000041F0A" data-uri="chapter04.xhtml#P7000497027000000000000000041F0A" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041F0B" data-uri="chapter04.xhtml#P7000497027000000000000000041F0B" class="calibre10 pcalibre pcalibre1">word Min3 = [
	A &lt;= B &amp;&amp; A &lt;= C : A;
	B &lt;= A &amp;&amp; B &lt;= C : B;
	1 : C;
];
</code></pre>

<section id="P7000497027000000000000000003D08" data-uri="chapter04.xhtml#P7000497027000000000000000003D08" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041F0C" data-uri="chapter04.xhtml#P7000497027000000000000000041F0C" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">4.11 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000041F0D" data-uri="chapter04.xhtml#P7000497027000000000000000041F0D">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000041F0E" data-uri="chapter04.xhtml#P7000497027000000000000000041F0E">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041F0F" data-uri="chapter04.xhtml#P7000497027000000000000000041F0F"><p id="P7000497027000000000000000041F10" data-uri="chapter04.xhtml#P7000497027000000000000000041F10" class="pcalibre calibre3 pcalibre1">The HCL code given for computing the minimum of three words contains four comparison expressions of the form <var class="calibre5 pcalibre pcalibre1">X</var> &lt;= <i class="calibre5 pcalibre pcalibre1">Y.</i> Rewrite the code to compute the same result, but using only three comparisons.</p></div>
</li>
</ol>
</section>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003D0E" data-uri="chapter04.xhtml#P7000497027000000000000000003D0E">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003D0F" title="380" data-uri="chapter04.xhtml#P7000497027000000000000000003D0F" epub:type="pagebreak"></span><img alt="A diagram shows four ALU circuits." id="P7000497027000000000000000041F11" data-uri="P700049702700000000000000000B6D5" src="../images/p380-1.png" class="calibre115 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000041F12" data-uri="chapter04.xhtml#P7000497027000000000000000041F12" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041F13" data-uri="chapter04.xhtml#P7000497027000000000000000041F13" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">4.15 </span>Arithmetic/logic unit (ALU).</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041F14" data-uri="chapter04.xhtml#P7000497027000000000000000041F14"><p id="P7000497027000000000000000041F15" data-uri="chapter04.xhtml#P7000497027000000000000000041F15" class="pcalibre1 pcalibre calibre2"> Depending on the setting of the function input, the circuit will perform one of four different arithmetic and logical operations.</p><p id="P7000497027000000000000000041F16" data-uri="chapter04.xhtml#P7000497027000000000000000041F16" class="pcalibre calibre3 pcalibre1">
</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000221F6" data-uri="chapter04.xhtml#P70004970270000000000000000221F6">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000041F17" data-uri="chapter04.xhtml#P7000497027000000000000000041F17" class="pcalibre1 pcalibre calibre2">The four ALU circuits are summarized below.</p>
<ul id="P7000497027000000000000000041F18" data-uri="chapter04.xhtml#P7000497027000000000000000041F18" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000041F19" data-uri="chapter04.xhtml#P7000497027000000000000000041F19" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041F1A" data-uri="chapter04.xhtml#P7000497027000000000000000041F1A" class="pcalibre calibre3 pcalibre1">Input 0: Y and X lead to A and B, respectively, in ALU, with output X + Y</p></li>
<li id="P7000497027000000000000000041F1B" data-uri="chapter04.xhtml#P7000497027000000000000000041F1B" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041F1C" data-uri="chapter04.xhtml#P7000497027000000000000000041F1C" class="pcalibre calibre3 pcalibre1">Input 1: Y and X lead to A and B, respectively, in ALU, with output X minus Y</p></li>
<li id="P7000497027000000000000000041F1D" data-uri="chapter04.xhtml#P7000497027000000000000000041F1D" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041F1E" data-uri="chapter04.xhtml#P7000497027000000000000000041F1E" class="pcalibre calibre3 pcalibre1">Input 2: Y and X lead to A and B, respectively, in ALU, with output X &amp; Y</p></li>
<li id="P7000497027000000000000000041F1F" data-uri="chapter04.xhtml#P7000497027000000000000000041F1F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041F20" data-uri="chapter04.xhtml#P7000497027000000000000000041F20" class="pcalibre calibre3 pcalibre1">Input 3: Y and X lead to A and B, respectively, in ALU, with output X ^ Y</p></li>
</ul>
</details>
</figcaption>
</figure>
<section id="P7000497027000000000000000003D15" data-uri="chapter04.xhtml#P7000497027000000000000000003D15" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041F21" data-uri="chapter04.xhtml#P7000497027000000000000000041F21" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">4.12 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP70004970270000000000000000046A4.xhtml#P70004970270000000000000000046F2">484</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000041F22" data-uri="chapter04.xhtml#P7000497027000000000000000041F22">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000041F23" data-uri="chapter04.xhtml#P7000497027000000000000000041F23">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041F24" data-uri="chapter04.xhtml#P7000497027000000000000000041F24"><p id="P7000497027000000000000000041F25" data-uri="chapter04.xhtml#P7000497027000000000000000041F25" class="pcalibre calibre3 pcalibre1">Write HCL code describing a circuit that for word inputs A, B, and C selects the <i class="calibre5 pcalibre pcalibre1">median</i> of the three values. That is, the output equals the word lying between the minimum and maximum of the three inputs.</p></div>
</li>
</ol>
</section>
<p id="P7000497027000000000000000041F26" data-uri="chapter04.xhtml#P7000497027000000000000000041F26" class="pcalibre1 pcalibre calibre2">Combinational logic circuits can be designed to perform many different types of operations on word-level data. The detailed design of these is beyond the scope of our presentation. One important combinational circuit, known as an <i class="calibre5 pcalibre pcalibre1">arithmetic/logic unit</i> (ALU), is diagrammed at an abstract level in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003D0E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.15</span></a>. In our version, the circuit has three inputs: two data inputs labeled A and B and a control input. Depending on the setting of the control input, the circuit will perform different arithmetic or logical operations on the data inputs. Observe that the four operations diagrammed for this ALU correspond to the four different integer operations supported by the Y86-64 instruction set, and the control values match the function codes for these instructions (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000003AB0.xhtml#P7000497027000000000000000003B10"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.3</span></a>). Note also the ordering of operands for subtraction, where the A input is subtracted from the B input. This ordering is chosen in anticipation of the ordering of arguments in the <code id="P7000497027000000000000000041F27" data-uri="chapter04.xhtml#P7000497027000000000000000041F27" class="pcalibre1 calibre8 pcalibre">subq</code> instruction.</p>
</section>

<section id="P7000497027000000000000000003D1D" data-uri="chapter04.xhtml#P7000497027000000000000000003D1D" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000041F28" data-uri="chapter04.xhtml#P7000497027000000000000000041F28" epub:type="title"><span class="pcalibre label pcalibre1">4.2.4 </span>Set Membership</h1></header>
<p id="P7000497027000000000000000041F29" data-uri="chapter04.xhtml#P7000497027000000000000000041F29" class="pcalibre1 pcalibre calibre2">In our processor designs, we will find many examples where we want to compare one signal against a number of possible matching signals, such as to test whether the code for some instruction being processed matches some category of instruction codes. As a simple example, suppose we want to generate the signals s1 and s0 for the 4-way multiplexor of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003CF4"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.14</span></a> by selecting the high- and low-order bits from a 2-bit signal code, as follows:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003D20" data-uri="chapter04.xhtml#P7000497027000000000000000003D20">
<img alt="A diagram shows code leading to Control, leading to s1 and s0, which lead to MUX4. D, C, B, and A also lead to MUX4, which leads to Out4." id="P7000497027000000000000000041F2A" data-uri="P700049702700000000000000000B6D6" src="../images/p380-2.png" class="pcalibre1 pcalibre calibre116"/>
</figure>

<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041F2B" data-uri="chapter04.xhtml#P7000497027000000000000000041F2B"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003D23" title="381" data-uri="chapter04.xhtml#P7000497027000000000000000003D23" epub:type="pagebreak"></span>In this circuit, the 2-bit signal code would then control the selection among the four data words A, B, C, and D. We can express the generation of signals s1 and s0 using equality tests based on the possible values of code:</p>
<pre id="P7000497027000000000000000041F2C" data-uri="chapter04.xhtml#P7000497027000000000000000041F2C" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041F2D" data-uri="chapter04.xhtml#P7000497027000000000000000041F2D" class="calibre10 pcalibre pcalibre1">bool s1 = code == 2 || code == 3;</code>
<code id="P7000497027000000000000000041F2E" data-uri="chapter04.xhtml#P7000497027000000000000000041F2E" class="calibre10 pcalibre pcalibre1">bool s0 = code == 1 || code == 3;</code></pre>
<p id="P7000497027000000000000000041F2F" data-uri="chapter04.xhtml#P7000497027000000000000000041F2F" class="pcalibre1 pcalibre calibre2">A more concise expression can be written that expresses the property that s1 is 1 when code is in the set {2, 3}, and s0 is 1 when code is in the set {1, 3}:</p>
<pre id="P7000497027000000000000000041F30" data-uri="chapter04.xhtml#P7000497027000000000000000041F30" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041F31" data-uri="chapter04.xhtml#P7000497027000000000000000041F31" class="calibre10 pcalibre pcalibre1">bool s1 = code in { 2, 3 };</code>
<code id="P7000497027000000000000000041F32" data-uri="chapter04.xhtml#P7000497027000000000000000041F32" class="calibre10 pcalibre pcalibre1">bool s0 = code in { 1, 3 };</code></pre>
<p id="P7000497027000000000000000041F33" data-uri="chapter04.xhtml#P7000497027000000000000000041F33" class="pcalibre1 pcalibre calibre2">The general form of a set membership test is</p>
<pre id="P7000497027000000000000000041F34" data-uri="chapter04.xhtml#P7000497027000000000000000041F34" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041F35" data-uri="chapter04.xhtml#P7000497027000000000000000041F35" class="calibre10 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">iexpr</i> in <i class="calibre5 pcalibre pcalibre1">{.iexpr<sub class="calibre85 pcalibre pcalibre1">1</sub>, iexpr<sub class="calibre85 pcalibre pcalibre1">2</sub>, ···, iexpr<sub class="calibre85 pcalibre pcalibre1">k</sub>}</i></code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041F36" data-uri="chapter04.xhtml#P7000497027000000000000000041F36">where the value being tested <i class="calibre5 pcalibre pcalibre1">(iexpr)</i> and the candidate matches (<i class="calibre5 pcalibre pcalibre1">iexpr</i><sub class="pcalibre1 calibre47 pcalibre">1</sub> through <i class="calibre5 pcalibre pcalibre1">iexpr<sub class="pcalibre1 calibre47 pcalibre">k</sub></i>) are all integer expressions.</p>
</section>
<section id="P7000497027000000000000000003D2F" data-uri="chapter04.xhtml#P7000497027000000000000000003D2F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000041F37" data-uri="chapter04.xhtml#P7000497027000000000000000041F37" epub:type="title"><span class="pcalibre label pcalibre1">4.2.5 </span>Memory and Clocking</h1></header>
<p id="P7000497027000000000000000041F38" data-uri="chapter04.xhtml#P7000497027000000000000000041F38" class="pcalibre1 pcalibre calibre2">Combinational circuits, by their very nature, do not store any information. Instead, they simply react to the signals at their inputs, generating outputs equal to some function of the inputs. To create <i class="calibre5 pcalibre pcalibre1">sequential circuits</i>—that is, systems that have state and perform computations on that state—we must introduce devices that store information represented as bits. Our storage devices are all controlled by a single <i class="calibre5 pcalibre pcalibre1">clock</i>, a periodic signal that determines when new values are to be loaded into the devices. We consider two classes of memory devices:</p>

<blockquote id="P7000497027000000000000000041F39" data-uri="chapter04.xhtml#P7000497027000000000000000041F39" class="pcalibre7 pcalibre8 calibre52"><p id="P7000497027000000000000000041F3A" data-uri="chapter04.xhtml#P7000497027000000000000000041F3A" class="pcalibre1 pcalibre calibre2"><i class="calibre5 pcalibre pcalibre1">Clocked registers</i> (or simply <i class="calibre5 pcalibre pcalibre1">registers)</i> store individual bits or words. The clock signal controls the loading of the register with the value at its input.</p>
<p id="P7000497027000000000000000041F3B" data-uri="chapter04.xhtml#P7000497027000000000000000041F3B" class="pcalibre calibre3 pcalibre1"><i class="calibre5 pcalibre pcalibre1">Random access memories</i> (or simply <i class="calibre5 pcalibre pcalibre1">memories</i>) store multiple words, using an address to select which word should be read or written. Examples of random access memories include (1) the virtual memory system of a processor, where a combination of hardware and operating system software make it appear to a processor that it can access any word within a large address space; and (2) the register file, where register identifiers serve as the addresses. In a Y86-64 processor, the register file holds the 15 program registers (<code id="P7000497027000000000000000041F3C" data-uri="chapter04.xhtml#P7000497027000000000000000041F3C" class="calibre10 pcalibre pcalibre1">%rax</code> through <code id="P7000497027000000000000000041F3D" data-uri="chapter04.xhtml#P7000497027000000000000000041F3D" class="calibre10 pcalibre pcalibre1">%r14</code>).</p>
</blockquote>
<p id="P7000497027000000000000000041F3E" data-uri="chapter04.xhtml#P7000497027000000000000000041F3E" class="pcalibre1 pcalibre calibre2">As we can see, the word "register" means two slightly different things when speaking of hardware versus machine-language programming. In hardware, a register is directly connected to the rest of the circuit by its input and output wires. In machine-level programming, the registers represent a small collection of addressable words in the CPU, where the addresses consist of register IDs. These words are generally stored in the register file, although we will see that the hardware can sometimes pass a word directly from one instruction to another to</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003D38" data-uri="chapter04.xhtml#P7000497027000000000000000003D38">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003D39" title="382" data-uri="chapter04.xhtml#P7000497027000000000000000003D39" epub:type="pagebreak"></span><img alt="A diagram of the register operation shows a flow from state = x, with input y and output x, leading to rising clock leading to state = y, with output y." id="P7000497027000000000000000041F3F" data-uri="P700049702700000000000000000B6D7" src="../images/p382-1.png" class="pcalibre calibre117 pcalibre1"/>
<figcaption id="P7000497027000000000000000041F40" data-uri="chapter04.xhtml#P7000497027000000000000000041F40" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000041F41" data-uri="chapter04.xhtml#P7000497027000000000000000041F41" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">4.16 </span>Register operation.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000041F42" data-uri="chapter04.xhtml#P7000497027000000000000000041F42"><p id="P7000497027000000000000000041F43" data-uri="chapter04.xhtml#P7000497027000000000000000041F43" class="pcalibre1 pcalibre calibre2"> The register outputs remain held at the current register state until the clock signal rises. When the clock rises, the values at the register inputs are captured to become the new register state.</p><p id="P7000497027000000000000000041F44" data-uri="chapter04.xhtml#P7000497027000000000000000041F44" class="pcalibre calibre3 pcalibre1">
</p></div>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041F45" data-uri="chapter04.xhtml#P7000497027000000000000000041F45">avoid the delay of first writing and then reading the register file. When necessary to avoid ambiguity, we will call the two classes of registers "hardware registers" and "program registers," respectively.</p>
<p id="P7000497027000000000000000041F46" data-uri="chapter04.xhtml#P7000497027000000000000000041F46" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000003D38"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.16</span></a> gives a more detailed view of a hardware register and how it operates. For most of the time, the register remains in a fixed state (shown as x), generating an output equal to its current state. Signals propagate through the combinational logic preceding the register, creating a new value for the register input (shown as y), but the register output remains fixed as long as the clock is low. As the clock rises, the input signals are loaded into the register as its next state (y), and this becomes the new register output until the next rising clock edge. A key point is that the registers serve as barriers between the combinational logic in different parts of the circuit. Values only propagate from a register input to its output once every clock cycle at the rising clock edge. Our Y86-64 processors will use clocked registers to hold the program counter (PC), the condition codes (CC), and the program status (Stat).</p>
<p id="P7000497027000000000000000041F47" data-uri="chapter04.xhtml#P7000497027000000000000000041F47" class="pcalibre1 pcalibre calibre2">The following diagram shows a typical register file:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003D42" data-uri="chapter04.xhtml#P7000497027000000000000000003D42">
<img alt="A diagram of a register file, with clock input, has two read ports: A with input srcA and output valA and B with input srcB and output valB, and a write port with inputs dstW and valW." id="P7000497027000000000000000041F48" data-uri="P700049702700000000000000000B6D8" src="../images/p382-2.png" class="calibre118 pcalibre pcalibre1"/>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041F49" data-uri="chapter04.xhtml#P7000497027000000000000000041F49">This register file has two <i class="calibre5 pcalibre pcalibre1">read ports</i>, named A and B, and one <i class="calibre5 pcalibre pcalibre1">write port</i>, named W. Such a <i class="calibre5 pcalibre pcalibre1">multiported</i> random access memory allows multiple read and write operations to take place simultaneously. In the register file diagrammed, the circuit can read the values of two program registers and update the state of a third. Each port has an address input, indicating which program register should be selected, and a data output or input giving a value for that program register. The addresses are register identifiers, using the encoding shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000003AB0.xhtml#P7000497027000000000000000003B18"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">4.4</span></a>. The two read ports have address inputs srcA and srcB (short for "source A" and "source B") and data <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003D45" title="383" data-uri="chapter04.xhtml#P7000497027000000000000000003D45" epub:type="pagebreak"></span>outputs valA and valB (short for "value A" and "value B"). The write port has address input dstW (short for "destination W") and data input valW (short for "value W").</p>
<p id="P7000497027000000000000000041F4A" data-uri="chapter04.xhtml#P7000497027000000000000000041F4A" class="pcalibre1 pcalibre calibre2">The register file is not a combinational circuit, since it has internal storage. In our implementation, however, data can be read from the register file as if it were a block of combinational logic having addresses as inputs and the data as outputs. When either srcA or srcB is set to some register ID, then, after some delay, the value stored in the corresponding program register will appear on either valA or valB. For example, setting srcA to 3 will cause the value of program register <code id="P7000497027000000000000000041F4B" data-uri="chapter04.xhtml#P7000497027000000000000000041F4B" class="pcalibre1 calibre8 pcalibre">%rbx</code> to be read, and this value will appear on output valA.</p>
<p id="P7000497027000000000000000041F4C" data-uri="chapter04.xhtml#P7000497027000000000000000041F4C" class="pcalibre1 pcalibre calibre2">The writing of words to the register file is controlled by the clock signal in a manner similar to the loading of values into a clocked register. Every time the clock rises, the value on input valW is written to the program register indicated by the register ID on input dstW. When dstW is set to the special ID value <code id="P7000497027000000000000000041F4D" data-uri="chapter04.xhtml#P7000497027000000000000000041F4D" class="pcalibre1 calibre8 pcalibre">0xF</code>, no program register is written. Since the register file can be both read and written, a natural question to ask is, "What happens if the circuit attempts to read and write the same register simultaneously?" The answer is straightforward: if the same register ID is used for both a read port and the write port, then, as the clock rises, there will be a transition on the read port's data output from the old value to the new. When we incorporate the register file into our processor design, we will make sure that we take this property into consideration.</p>
<p id="P7000497027000000000000000041F4E" data-uri="chapter04.xhtml#P7000497027000000000000000041F4E" class="pcalibre1 pcalibre calibre2">Our processor has a random access memory for storing program data, as illustrated below:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000003D4B" data-uri="chapter04.xhtml#P7000497027000000000000000003D4B">
<img alt="A diagram of data memory shows inputs from clock, read, write, address, and data in and outputs as error and data out." id="P7000497027000000000000000041F4F" data-uri="P700049702700000000000000000B6D9" src="../images/p383-1.png" class="calibre119 pcalibre pcalibre1"/>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041F50" data-uri="chapter04.xhtml#P7000497027000000000000000041F50">This memory has a single address input, a data input for writing, and a data output for reading. Like the register file, reading from our memory operates in a manner similar to combinational logic: If we provide an address on the address input and set the write control signal to 0, then after some delay, the value stored at that address will appear on data out. The error signal will be set to 1 if the address is out of range, and to 0 otherwise. Writing to the memory is controlled by the clock: We set address to the desired address, data in to the desired value, and write to 1. When we then operate the clock, the specified location in the memory will be updated, as long as the address is valid. As with the read operation, the error signal will be set to 1 if the address is invalid. This signal is generated by combinational logic, since the required bounds checking is purely a function of the address input and does not involve saving any state.</p>

<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000003D4E" data-uri="chapter04.xhtml#P7000497027000000000000000003D4E"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000041F51" data-uri="chapter04.xhtml#P7000497027000000000000000041F51" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000003D50" title="384" data-uri="chapter04.xhtml#P7000497027000000000000000003D50" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Real-life memory design</h1></header>
<p id="P7000497027000000000000000041F52" data-uri="chapter04.xhtml#P7000497027000000000000000041F52" class="calibre13 pcalibre pcalibre1">The memory system in a full-scale microprocessor is far more complex than the simple one we assume in our design. It consists of several forms of hardware memories, including several random access memories, plus nonvolatile memory or magnetic disk, as well as a variety of hardware and software mechanisms for managing these devices. The design and characteristics of the memory system are described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000005190.xhtml#P7000497027000000000000000005190"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">6</span></a>.</p>
<p id="P7000497027000000000000000041F53" data-uri="chapter04.xhtml#P7000497027000000000000000041F53" class="pcalibre calibre3 pcalibre1">Nonetheless, our simple memory design can be used for smaller systems, and it provides us with an abstraction of the interface between the processor and memory for more complex systems.</p>
</aside>
<p id="P7000497027000000000000000041F54" data-uri="chapter04.xhtml#P7000497027000000000000000041F54" class="pcalibre1 pcalibre calibre2">Our processor includes an additional read-only memory for reading instructions. In most actual systems, these memories are merged into a single memory with two ports: one for reading instructions, and the other for reading or writing data.</p>
</section>
</section></body></html>
