<?xml version="1.0" encoding="utf-8"?><html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/"><head>
<meta name="dcterms.conformsTo" content="PXE Basic 1.0"></meta>
<meta name="generator" content="PXE Tools version 1.39.109"></meta>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.109, partial=false-->
<title>6.2 Error-Detection and -Correction Techniques</title><link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/sepia.css"></link><link rel="alternate stylesheet" type="text/css" title="night" href="../css/night.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/main.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/print.css"></link>
<script src="js/format_lg_obj.js"></script>
</head><body epub:type="bodymatter">
<section id="P70010119520000000000000000023E8" class="level1"><header><h1 class="title" id="P700101195200000000000000000AF37" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF37" epub:type="title"><span class="number">6.2</span> Error-Detection and -Correction Techniques</h1></header>
<p id="P700101195200000000000000000AF38" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF38">In the previous section, we noted that <span class="keyword" id="P70010119520000000000000000023EB" data-uri="M06_KURO4140_07_SE_C06.xhtml#P70010119520000000000000000023EB"><b>bit-level error detection and correction</b></span>—detecting and correcting the corruption of bits in a link-layer frame sent from one node to another physically connected neighboring node—are two services often ­provided by the link layer. We saw in <a class="xref" href="fileP70010119520000000000000000010EC.xhtml#P70010119520000000000000000010EC" data-foobar="7"><span class="label">Chapter</span> <span class="number">3</span></a> that error-detection and -correction services are also often offered at the transport layer as well. In this section, we’ll <span class="pagebreak" title="445" id="P70010119520000000000000000023EC" data-uri="M06_KURO4140_07_SE_C06.xhtml#P70010119520000000000000000023EC" epub:type="pagebreak" role="doc-pagebreak"></span>examine a few of the simplest techniques that can be used to detect and, in some cases, correct such bit errors. A full treatment of the theory and implementation of this topic is itself the topic of many textbooks (for example, <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BFB" data-foobar="7">[Schwartz 1980]</a> or <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003837" data-foobar="7">[Bertsekas 1991]</a>), and our treatment here is necessarily brief. Our goal here is to develop an intuitive feel for the capabilities that error-detection and -correction techniques provide and to see how a few simple techniques work and are used in practice in the link layer.</p>
<p id="P700101195200000000000000000AF39" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF39"><a class="xref" href="#P70010119520000000000000000023F0" data-foobar="1"><span class="label">Figure</span> <span class="number">6.3</span></a> illustrates the setting for our study. At the sending node, data, <i>D</i>, to be protected against bit errors is augmented with error-detection and -correction bits (<i>EDC</i>). Typically, the data to be protected includes not only the datagram passed down from the network layer for transmission across the link, but also link-level addressing information, sequence numbers, and other fields in the link frame header. Both <i>D</i> and <i>EDC</i> are sent to the receiving node in a link-level frame. At the receiving node, a sequence of bits, <i>D</i>′ and <i>EDC</i>′ is received. Note that <i>D</i>′ and <i>EDC</i>′ may differ from the original <i>D</i> and <i>EDC</i> as a result of in-transit bit flips.</p>
<p id="P700101195200000000000000000AF3A" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF3A">The receiver’s challenge is to determine whether or not <i>D</i>′ is the same as the original <i>D</i>, given that it has only received <i>D</i>′ and <i>EDC</i>′. The exact wording of the receiver’s decision in <a class="xref" href="#P70010119520000000000000000023F0" data-foobar="1"><span class="label">Figure</span> <span class="number">6.3</span></a> (we ask whether an error is detected, not whether an error has occurred!) is important. Error-detection and -correction techniques allow the receiver to sometimes, <i>but not always</i>, detect that bit errors have occurred. Even with the use of error-detection bits there still may be <span class="keyword" id="P70010119520000000000000000023EF" data-uri="M06_KURO4140_07_SE_C06.xhtml#P70010119520000000000000000023EF"><b>undetected bit errors</b></span>; that is, the receiver may be unaware that the received information contains bit errors. As a</p>
<figure id="P70010119520000000000000000023F0" class="figure" data-uri="M06_KURO4140_07_SE_C06.xhtml#P70010119520000000000000000023F0">
<img alt="Illustration of an error-detection and -correction scenario." height="422" width="670" aria-describedby="P70010119520000000000000000023F4" id="P700101195200000000000000000AF3B" data-uri="P70010119520000000000000000055C6" src="../images/4055106003.png"></img>
<figcaption id="P700101195200000000000000000AF3C" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF3C"><header><h1 class="title" id="P700101195200000000000000000AF3D" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF3D" epub:type="title"><span class="label">Figure </span> <span class="number">6.3</span> Error-detection and -correction scenario</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000023F4" data-uri="M06_KURO4140_07_SE_C06.xhtml#P70010119520000000000000000023F4" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055106003.xhtml#la_4055106003"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000AF40" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF40"><span class="pagebreak" title="446" id="P70010119520000000000000000023F8" data-uri="M06_KURO4140_07_SE_C06.xhtml#P70010119520000000000000000023F8" epub:type="pagebreak" role="doc-pagebreak"></span>consequence, the receiver might deliver a corrupted datagram to the network layer, or be unaware that the contents of a field in the frame’s header has been corrupted. We thus want to choose an error-detection scheme that keeps the probability of such occurrences small. Generally, more sophisticated error-detection and-correction techniques (that is, those that have a smaller probability of allowing undetected bit errors) incur a larger overhead—more computation is needed to compute and transmit a larger number of error-detection and -correction bits.</p>
<p id="P700101195200000000000000000AF41" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF41">Let’s now examine three techniques for detecting errors in the transmitted data—parity checks (to illustrate the basic ideas behind error detection and correction), checksumming methods (which are more typically used in the transport layer), and cyclic redundancy checks (which are more typically used in the link layer in an adapter).</p>
<section id="P70010119520000000000000000023FA" data-uri="M06_KURO4140_07_SE_C06.xhtml#P70010119520000000000000000023FA" class="level2"><header><h1 class="title" id="P700101195200000000000000000AF42" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF42" epub:type="title"><span class="number">6.2.1</span> Parity Checks</h1></header>
<p id="P700101195200000000000000000AF43" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF43">Perhaps the simplest form of error detection is the use of a single <span class="keyword" id="P70010119520000000000000000023FD" data-uri="M06_KURO4140_07_SE_C06.xhtml#P70010119520000000000000000023FD"><b>parity bit</b></span>. Suppose that the information to be sent, <i>D</i> in <a class="xref" href="#P7001011952000000000000000002400" data-foobar="1"><span class="label">Figure</span> <span class="number">6.4</span></a>, has <i>d</i> bits. In an even parity scheme, the sender simply includes one additional bit and chooses its value such that the total number of 1s in the <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="44" altimg-height="13" altimg="../images/ch06math01.png"><m:mrow><m:mi>d</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> bits (the original information plus a parity bit) is even. For odd parity schemes, the parity bit value is chosen such that there is an odd number of 1s. <a class="xref" href="#P7001011952000000000000000002400" data-foobar="1"><span class="label">Figure</span> <span class="number">6.4</span></a> illustrates an even parity scheme, with the single parity bit being stored in a separate field.</p>
<p id="P700101195200000000000000000AF44" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF44">Receiver operation is also simple with a single parity bit. The receiver need only count the number of 1s in the received <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="44" altimg-height="13" altimg="../images/ch06math02.png"><m:mrow><m:mi>d</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> bits. If an odd number of 1-valued bits are found with an even parity scheme, the receiver knows that at least one bit error has occurred. More precisely, it knows that some <i>odd</i> number of bit errors have occurred.</p>
<p id="P700101195200000000000000000AF45" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF45">But what happens if an even number of bit errors occur? You should convince yourself that this would result in an undetected error. If the probability of bit errors is small and errors can be assumed to occur independently from one bit to the next, the probability of multiple bit errors in a packet would be extremely small. In this case, a single parity bit might suffice. However, measurements have shown that, rather than occurring independently, errors are often clustered together in “bursts.” Under burst error conditions, the probability of undetected errors in a frame protected by single-bit parity can approach 50 percent <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C1E" data-foobar="7">[Spragins 1991]</a>. Clearly, a more robust error-detection scheme is needed (and, fortunately, is used in practice!). But before examining error-detection schemes that are used in practice, let’s consider a simple</p>
<figure id="P7001011952000000000000000002400" class="figure" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002400">
<img alt="Illustration of one-bit even." height="106" width="302" aria-describedby="P7001011952000000000000000002404" id="P700101195200000000000000000AF46" data-uri="P70010119520000000000000000055C7" src="../images/4055106004.png"></img>
<figcaption id="P700101195200000000000000000AF47" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF47"><header><h1 class="title" id="P700101195200000000000000000AF48" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF48" epub:type="title"><span class="label">Figure </span> <span class="number">6.4</span> One-bit even parity</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000002404" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002404" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055106004.xhtml#la_4055106004"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000AF4D" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF4D"><span class="pagebreak" title="447" id="P700101195200000000000000000240A" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000240A" epub:type="pagebreak" role="doc-pagebreak"></span>generalization of one-bit parity that will provide us with insight into error-correction techniques.</p>
<p id="P700101195200000000000000000AF4E" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF4E"><a class="xref" href="#P700101195200000000000000000240E" data-foobar="1"><span class="label">Figure</span> <span class="number">6.5</span></a> shows a two-dimensional generalization of the single-bit parity scheme. Here, the <i>d</i> bits in <i>D</i> are divided into <i>i</i> rows and <i>j</i> columns. A parity value is computed for each row and for each column. The resulting <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="74" altimg-height="17" altimg="../images/ch06math03.png"><m:mrow><m:mi>i</m:mi><m:mo>+</m:mo><m:mi>j</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> parity bits comprise the link-layer frame’s error-detection bits.</p>
<p id="P700101195200000000000000000AF4F" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF4F">Suppose now that a single bit error occurs in the original <i>d</i> bits of information. With this <span class="keyword" id="P700101195200000000000000000240D" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000240D"><b>two-dimensional parity</b></span> scheme, the parity of both the column and the row containing the flipped bit will be in error. The receiver can thus not only <i>detect</i> the fact that a single bit error has occurred, but can use the column and row indices of the column and row with parity errors to actually identify the bit that was corrupted and <i>correct</i> that error! <a class="xref" href="#P700101195200000000000000000240E" data-foobar="1"><span class="label">Figure</span> <span class="number">6.5</span></a> shows an example in which the 1-valued bit in position (2,2) is corrupted and switched to a 0—an error that is both detectable and correctable at the receiver. Although our discussion has focused on the original <i>d</i> bits of information, a single error in the parity bits themselves is also detectable and correctable. Two-dimensional parity can also detect (but not correct!) any combination of two errors in a packet. Other properties of the two-dimensional parity scheme are explored in the problems at the end of the chapter.</p>
<figure id="P700101195200000000000000000240E" class="figure" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000240E">
<img alt="Illustration of two-dimensional even parity." height="529" width="418" aria-describedby="P7001011952000000000000000002412" id="P700101195200000000000000000AF50" data-uri="P70010119520000000000000000055C8" src="../images/4055106005.png"></img>
<figcaption id="P700101195200000000000000000AF51" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF51"><header><h1 class="title" id="P700101195200000000000000000AF52" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF52" epub:type="title"><span class="label">Figure </span> <span class="number">6.5</span> Two-dimensional even parity</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000002412" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002412" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055106005.xhtml#la_4055106005"><span class="label">Description</span></a></div>
<p id="P700101195200000000000000000AF6E" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF6E"><span class="pagebreak" title="448" id="P700101195200000000000000000242F" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000242F" epub:type="pagebreak" role="doc-pagebreak"></span>The ability of the receiver to both detect and correct errors is known as <span class="keyword" id="P7001011952000000000000000002430" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002430"><b>forward error correction (FEC)</b></span>. These techniques are commonly used in audio storage and playback devices such as audio CDs. In a network setting, FEC techniques can be used by themselves, or in conjunction with link-layer ARQ techniques similar to those we examined in <a class="xref" href="fileP70010119520000000000000000010EC.xhtml#P70010119520000000000000000010EC" data-foobar="7"><span class="label">Chapter</span> <span class="number">3</span></a>. FEC techniques are valuable because they can decrease the number of sender retransmissions required. Perhaps more important, they allow for immediate correction of errors at the receiver. This avoids having to wait for the round-trip propagation delay needed for the sender to receive a NAK packet and for the retransmitted packet to propagate back to the receiver—a potentially important advantage for real-time network applications <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BDE" data-foobar="7">[Rubenstein 1998]</a> or links (such as deep-space links) with long propagation delays. Research examining the use of FEC in error-control protocols includes <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003839" data-foobar="7">[Biersack 1992</a>; <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003A7F" data-foobar="7">Nonnenmacher 1998</a>; <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003856" data-foobar="7">Byers 1998</a>; <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C09" data-foobar="7">Shacham 1990]</a>.</p>
</section>
<section id="P7001011952000000000000000002431" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002431" class="level2"><header><h1 class="title" id="P700101195200000000000000000AF6F" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF6F" epub:type="title"><span class="number">6.2.2</span> Checksumming Methods</h1></header>
<p id="P700101195200000000000000000AF70" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF70">In checksumming techniques, the <i>d</i> bits of data in <a class="xref" href="#P7001011952000000000000000002400" data-foobar="1"><span class="label">Figure</span> <span class="number">6.4</span></a> are treated as a sequence of <i>k</i>-bit integers. One simple checksumming method is to simply sum these <i>k</i>-bit integers and use the resulting sum as the error-detection bits. The <span class="keyword" id="P7001011952000000000000000002434" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002434"><b>Internet checksum</b></span> is based on this approach—bytes of data are treated as 16-bit integers and summed. The 1s complement of this sum then forms the Internet checksum that is carried in the segment header. As discussed in <a class="xref" href="fileP70010119520000000000000000011C0.xhtml#P70010119520000000000000000011C0" data-foobar="7"><span class="label">Section</span> <span class="number">3.3</span></a>, the  receiver checks the checksum by taking the 1s complement of the sum of the received data (including the checksum) and checking whether the result is all 1 bits. If any of the bits are 0, an error is indicated. RFC 1071 discusses the Internet checksum algorithm and its implementation in detail. In the TCP and UDP protocols, the Internet checksum is computed over all fields (header and data fields included). In IP the checksum is computed over the IP header (since the UDP or TCP segment has its own checksum). In other protocols, for example, XTP <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C31" data-foobar="7">[Strayer 1992]</a>, one checksum is computed over the header and another checksum is computed over the entire packet.</p>
<p id="P700101195200000000000000000AF71" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF71">Checksumming methods require relatively little packet overhead. For example, the checksums in TCP and UDP use only 16 bits. However, they provide relatively weak protection against errors as compared with cyclic redundancy check, which is discussed below and which is often used in the link layer. A natural question at this point is, Why is checksumming used at the transport layer and cyclic redundancy check used at the link layer? Recall that the transport layer is typically implemented in software in a host as part of the host’s operating system. Because transport-layer error detection is implemented in software, it is important to have a simple and fast error-detection scheme such as checksumming. On the other hand, error detection at the link layer is implemented in dedicated hardware in adapters, which can rapidly perform the more complex CRC operations. Feldmeier <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P70010119520000000000000000038F8" data-foobar="7">[Feldmeier 1995]</a> presents fast software implementation techniques for not only weighted checksum codes, but CRC (see below) and other codes as well.</p>
</section>
<section id="P7001011952000000000000000002436" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002436" class="level2"><header><h1 class="title" id="P700101195200000000000000000AF72" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF72" epub:type="title"><span class="pagebreak" title="449" id="P7001011952000000000000000002438" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002438" epub:type="pagebreak" role="doc-pagebreak"></span><span class="number">6.2.3</span> Cyclic Redundancy Check (CRC)</h1></header>
<p id="P700101195200000000000000000AF73" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF73">An error-detection technique used widely in today’s computer networks is based on <span class="keyword" id="P700101195200000000000000000243A" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000243A"><b>cyclic redundancy check (CRC) codes</b></span>. CRC codes are also known as <span class="keyword" id="P700101195200000000000000000243B" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000243B"><b>polynomial codes</b></span>, since it is possible to view the bit string to be sent as a polynomial whose coefficients are the 0 and 1 values in the bit string, with operations on the bit string interpreted as polynomial arithmetic.</p>
<p id="P700101195200000000000000000AF74" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF74">CRC codes operate as follows. Consider the <i>d</i>-bit piece of data, <i>D</i>, that the sending node wants to send to the receiving node. The sender and receiver must first agree on an <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="45" altimg-height="13" altimg="../images/ch06math04.png"><m:mrow><m:mi>r</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> bit pattern, known as a <span class="keyword" id="P700101195200000000000000000243D" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000243D"><b>generator</b></span>, which we will denote as <i>G</i>. We will require that the most significant (leftmost) bit of <i>G</i> be a 1. The key idea behind CRC codes is shown in <a class="xref" href="#P7001011952000000000000000002445" data-foobar="1"><span class="label">Figure</span> <span class="number">6.6</span></a>. For a given piece of data, <i>D</i>, the sender will choose <i>r</i> additional bits, <i>R</i>, and append them to <i>D</i> such that the resulting <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="45" altimg-height="13" altimg="../images/ch06math05.png"><m:mrow><m:mi>d</m:mi><m:mo>+</m:mo><m:mi>r</m:mi></m:mrow></m:math></span> bit pattern (interpreted as a binary number) is exactly divisible by <i>G</i> (i.e., has no remainder) using modulo-2 arithmetic. The process of error checking with CRCs is thus simple: The receiver divides the <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="47" altimg-height="13" altimg="../images/ch06math06.png"><m:mrow><m:mi>d</m:mi><m:mo>+</m:mo><m:mi>r</m:mi></m:mrow></m:math></span> received bits by <i>G</i>. If the remainder is nonzero, the receiver knows that an error has occurred; otherwise the data is accepted as being correct.</p>
<p id="P700101195200000000000000000AF75" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF75">All CRC calculations are done in modulo-2 arithmetic without carries in addition or borrows in subtraction. This means that addition and subtraction are identical, and both are equivalent to the bitwise exclusive-or (XOR) of the operands. Thus, for example,</p>
<pre id="P700101195200000000000000000AF76" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF76"><code id="P700101195200000000000000000AF77" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF77">
1011 XOR 0101 = 1110
1001 XOR 1101 = 0100</code></pre>
<p id="P700101195200000000000000000AF78" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF78">Also, we similarly have</p>
<pre id="P700101195200000000000000000AF79" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF79"><code id="P700101195200000000000000000AF7A" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF7A">
1011 - 0101 = 1110
1001 - 1101 = 0100</code></pre>
<p class="continued" id="P700101195200000000000000000AF7B" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF7B">Multiplication and division are the same as in base-2 arithmetic, except that any required addition or subtraction is done without carries or borrows. As in regular</p>
<figure id="P7001011952000000000000000002445" class="figure" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002445">
<img alt="Illustration of CRC." height="121" width="524" aria-describedby="P7001011952000000000000000002449" id="P700101195200000000000000000AF7C" data-uri="P70010119520000000000000000055C9" src="../images/4055106006.png"></img>
<figcaption id="P700101195200000000000000000AF7D" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF7D"><header><h1 class="title" id="P700101195200000000000000000AF7E" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF7E" epub:type="title"><span class="label">Figure </span> <span class="number">6.6</span> CRC</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000002449" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002449" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055106006.xhtml#la_4055106006"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000AF80" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF80"><span class="pagebreak" title="450" id="P700101195200000000000000000244C" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000244C" epub:type="pagebreak" role="doc-pagebreak"></span>binary arithmetic, multiplication by 2<sup><i>k</i></sup> left shifts a bit pattern by <i>k</i> places. Thus, given <i>D</i> and <i>R</i>, the quantity <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="114" altimg-height="14" altimg="../images/ch06math07.png"><m:mrow><m:mi>D</m:mi><m:mo>⋅</m:mo><m:msup><m:mn>2</m:mn><m:mi>r</m:mi></m:msup><m:mtext>XOR</m:mtext><m:mo> </m:mo><m:mi>R</m:mi></m:mrow></m:math></span> yields the <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="43" altimg-height="13" altimg="../images/ch06math08.png"><m:mrow><m:mi>d</m:mi><m:mo>+</m:mo><m:mi>r</m:mi></m:mrow></m:math></span> bit pattern shown in <a class="xref" href="#P7001011952000000000000000002445" data-foobar="1"><span class="label">Figure</span> <span class="number">6.6</span></a>. We’ll use this algebraic characterization of the <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="43" altimg-height="13" altimg="../images/ch06math09.png"><m:mrow><m:mi>d</m:mi><m:mo>+</m:mo><m:mi>r</m:mi></m:mrow></m:math></span> bit pattern from <a class="xref" href="#P7001011952000000000000000002445" data-foobar="1"><span class="label">Figure</span> <span class="number">6.6</span></a> in our discussion below.</p>
<p id="P700101195200000000000000000AF81" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF81">Let us now turn to the crucial question of how the sender computes <i>R</i>. Recall that we want to find <i>R</i> such that there is an <i>n</i> such that</p>
<div class="informalequation" id="P700101195200000000000000000244E" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000244E"><m:math display="block" alttext="" data-uri="" altimg-width="167" altimg-height="14" altimg="../images/ch06math10.png"><m:mrow><m:mi>D</m:mi><m:mo>⋅</m:mo><m:msup><m:mn>2</m:mn><m:mi>r</m:mi></m:msup><m:mtext>XOR </m:mtext><m:mi>R</m:mi><m:mo>=</m:mo><m:mi>n</m:mi><m:mi>G</m:mi></m:mrow></m:math></div>
<p id="P700101195200000000000000000AF82" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF82">That is, we want to choose <i>R</i> such that <i>G</i> divides into <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="114" altimg-height="14" altimg="../images/ch06math11.png"><m:mrow><m:mi>D</m:mi><m:mo>⋅</m:mo><m:msup><m:mn>2</m:mn><m:mi>r</m:mi></m:msup><m:mtext>XOR </m:mtext><m:mi>R</m:mi></m:mrow></m:math></span> without remainder. If we XOR (that is, add modulo-2, without carry) <i>R</i> to both sides of the above equation, we get</p>
<div class="informalequation" id="P7001011952000000000000000002450" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002450"><m:math display="block" alttext="" data-uri="" altimg-width="167" altimg-height="14" altimg="../images/ch06math12.png"><m:mrow><m:mi>D</m:mi><m:mo>⋅</m:mo><m:msup><m:mn>2</m:mn><m:mi>r</m:mi></m:msup><m:mo>=</m:mo><m:mi>n</m:mi><m:mi>G</m:mi><m:mtext> </m:mtext><m:mtext>XOR </m:mtext><m:mi>R</m:mi></m:mrow></m:math></div>
<p id="P700101195200000000000000000AF83" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF83">This equation tells us that if we divide <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="54" altimg-height="13" altimg="../images/ch06math13.png"><m:mrow><m:mi>D</m:mi><m:mo>⋅</m:mo><m:msup><m:mn>2</m:mn><m:mi>r</m:mi></m:msup></m:mrow></m:math></span> by G, the value of the remainder is precisely <i>R</i>. In other words, we can calculate <i>R</i> as</p>
<div class="informalequation" id="P7001011952000000000000000002452" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002452"><m:math display="block" alttext="" data-uri="" altimg-width="169" altimg-height="41" altimg="../images/ch06math14.png"><m:mrow><m:mi>R</m:mi><m:mo>=</m:mo><m:mtext>remainder</m:mtext><m:mfrac><m:mrow><m:mi>D</m:mi><m:mo>⋅</m:mo><m:msup><m:mn>2</m:mn><m:mi>r</m:mi></m:msup></m:mrow><m:mi>G</m:mi></m:mfrac></m:mrow></m:math></div>
<p id="P700101195200000000000000000AF84" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF84"><a class="xref" href="#P7001011952000000000000000002454" data-foobar="1"><span class="label">Figure</span> <span class="number">6.7</span></a> illustrates this calculation for the case of <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="165" altimg-height="16" altimg="../images/ch06math15.png"><m:mrow><m:mi>D</m:mi><m:mo>=</m:mo><m:mn>101110</m:mn><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi>d</m:mi><m:mo>=</m:mo><m:mn>6</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="87" altimg-height="16" altimg="../images/ch06math16.png"><m:mrow><m:mi>G</m:mi><m:mo>=</m:mo><m:mn>1001</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> and <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="47" altimg-height="13" altimg="../images/ch06math17.png"><m:mrow><m:mi>r</m:mi><m:mo>=</m:mo><m:mn>3</m:mn></m:mrow></m:math></span>. The 9 bits transmitted in this case are 101 110  011. You should check these calculations for yourself and also check that indeed <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="237" altimg-height="14" altimg="../images/ch06math18.png"><m:mrow><m:mi>D</m:mi><m:mo>⋅</m:mo><m:msup><m:mn>2</m:mn><m:mi>r</m:mi></m:msup><m:mo>=</m:mo><m:mn>101011</m:mn><m:mo>⋅</m:mo><m:mi>G</m:mi><m:mo> </m:mo><m:mtext>XOR</m:mtext><m:mo> </m:mo><m:mi>R</m:mi></m:mrow></m:math></span>.</p>
<figure id="P7001011952000000000000000002454" class="figure" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002454">
<img alt="A sample CRC calculation." height="363" width="270" aria-describedby="P7001011952000000000000000002458" id="P700101195200000000000000000AF85" data-uri="P70010119520000000000000000055CA" src="../images/4055106007.png"></img>
<figcaption id="P700101195200000000000000000AF86" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF86"><header><h1 class="title" id="P700101195200000000000000000AF87" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF87" epub:type="title"><span class="label">Figure </span> <span class="number">6.7</span> A sample CRC calculation</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000002458" data-uri="M06_KURO4140_07_SE_C06.xhtml#P7001011952000000000000000002458" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055106007.xhtml#la_4055106007"><span class="label">Description</span></a></div>
<p id="P700101195200000000000000000AF8A" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF8A"><span class="pagebreak" title="451" id="P700101195200000000000000000245C" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000245C" epub:type="pagebreak" role="doc-pagebreak"></span>International standards have been defined for 8-, 12-, 16-, and 32-bit generators, <i>G</i>. The CRC-32 32-bit standard, which has been adopted in a number of link-level IEEE protocols, uses a generator of</p>
<div class="informalequation" id="P700101195200000000000000000245D" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000245D"><m:math display="block" alttext="" data-uri="" altimg-width="402" altimg-height="17" altimg="../images/ch06math19.png"><m:mrow><m:msub><m:mi>G</m:mi><m:mrow><m:mtext>CRC</m:mtext><m:mo>-</m:mo><m:mn>32</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:mn>100000100110000010001110110110111</m:mn></m:mrow></m:math></div>
<p id="P700101195200000000000000000AF8B" data-uri="M06_KURO4140_07_SE_C06.xhtml#P700101195200000000000000000AF8B">Each of the CRC standards can detect burst errors of fewer than <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="40" altimg-height="13" altimg="../images/ch06math20.png"><m:mrow><m:mi>r</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> bits. (This means that all consecutive bit errors of <i>r</i> bits or fewer will be detected.) Furthermore, under appropriate assumptions, a burst of length greater than <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="40" altimg-height="13" altimg="../images/ch06math21.png"><m:mrow><m:mi>r</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> bits is detected with probability <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="68" altimg-height="14" altimg="../images/ch06math22.png"><m:mrow><m:mn>1</m:mn><m:mo>−</m:mo><m:msup><m:mrow><m:mn>0.5</m:mn></m:mrow><m:mi>r</m:mi></m:msup></m:mrow></m:math></span>. Also, each of the CRC standards can detect any odd number of bit errors. See [Williams 1993] for a discussion of implementing CRC checks. The theory behind CRC codes and even more powerful codes is beyond the scope of this text. The text <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BFB" data-foobar="7">[Schwartz 1980]</a> provides an excellent introduction to this topic.</p>
</section>
</section></body></html>