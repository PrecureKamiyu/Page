<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>12.1 Concurrent Programming with Processes</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000008097" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000046B9E" data-uri="chapter12.xhtml#P7000497027000000000000000046B9E" epub:type="title"><span class="pcalibre label pcalibre1">12.1 </span>Concurrent Programming with Processes</h1></header>
<p id="P7000497027000000000000000046B9F" data-uri="chapter12.xhtml#P7000497027000000000000000046B9F" class="pcalibre1 pcalibre calibre2">The simplest way to build a concurrent program is with processes, using familiar functions such as <code id="P7000497027000000000000000046BA0" data-uri="chapter12.xhtml#P7000497027000000000000000046BA0" class="pcalibre1 calibre8 pcalibre">fork, exec</code>, and <code id="P7000497027000000000000000046BA1" data-uri="chapter12.xhtml#P7000497027000000000000000046BA1" class="pcalibre1 calibre8 pcalibre">waitpid</code>. For example, a natural approach for building a concurrent server is to accept client connection requests in the parent and then create a new child process to service each new client.</p>
<p id="P7000497027000000000000000046BA2" data-uri="chapter12.xhtml#P7000497027000000000000000046BA2" class="pcalibre1 pcalibre calibre2">To see how this might work, suppose we have two clients and a server that is listening for connection requests on a listening descriptor (say, 3). Now suppose that the server accepts a connection request from client 1 and returns a connected descriptor (say, 4), as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000809E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.1</span></a>. After accepting the connection request, the server forks a child, which gets a complete copy of the server's descriptor table. The child closes its copy of listening descriptor 3, and the parent closes its copy of connected descriptor 4, since they are no longer needed. This gives us the situation shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000080A2"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.2</span></a>, where the child process is busy servicing the client.</p>
<p id="P7000497027000000000000000046BA3" data-uri="chapter12.xhtml#P7000497027000000000000000046BA3" class="pcalibre1 pcalibre calibre2">Since the connected descriptors in the parent and child each point to the same file table entry, it is crucial for the parent to close its copy of the connected</p>
<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000809E" data-uri="chapter12.xhtml#P700049702700000000000000000809E">
<img alt="A diagram shows step 1: a connection request from client 1 (which contains clientfd) to listenfd(3) on server (which also has connfd(4)). Client 2 below also contains clientfd." id="P7000497027000000000000000046BA4" data-uri="P700049702700000000000000000B7C8" src="../images/p973-1.png" class="calibre328 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000046BA5" data-uri="chapter12.xhtml#P7000497027000000000000000046BA5" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046BA6" data-uri="chapter12.xhtml#P7000497027000000000000000046BA6" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.1 </span>Step 1: Server accepts connection request from client.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000080A2" data-uri="chapter12.xhtml#P70004970270000000000000000080A2">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000080A3" title="974" data-uri="chapter12.xhtml#P70004970270000000000000000080A3" epub:type="pagebreak"></span>
<img alt="A diagram shows step 2: data transfers between clientfd on client 1 and connfd(4) on Child 1." id="P7000497027000000000000000046BA7" data-uri="P700049702700000000000000000B7C9" src="../images/p974-1.png" class="calibre329 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000046BA8" data-uri="chapter12.xhtml#P7000497027000000000000000046BA8" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046BA9" data-uri="chapter12.xhtml#P7000497027000000000000000046BA9" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.2 </span>Step 2: Server forks a child process to service the client.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000080A7" data-uri="chapter12.xhtml#P70004970270000000000000000080A7">
<img alt="A diagram shows step 3: data.transfers between clientfd on client 1 and connfd(4) on child 1, and connection request from clientfd on client 2 to listenfd(3) on server (also has connfd(5))." id="P7000497027000000000000000046BAA" data-uri="P700049702700000000000000000B7CA" src="../images/p974-2.png" class="calibre329 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000046BAB" data-uri="chapter12.xhtml#P7000497027000000000000000046BAB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046BAC" data-uri="chapter12.xhtml#P7000497027000000000000000046BAC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.3 </span>Step 3: Server accepts another connection request.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046BAD" data-uri="chapter12.xhtml#P7000497027000000000000000046BAD">descriptor. Otherwise, the file table entry for connected descriptor 4 will never be released, and the resulting memory leak will eventually consume the available memory and crash the system.</p>
<p id="P7000497027000000000000000046BAE" data-uri="chapter12.xhtml#P7000497027000000000000000046BAE" class="pcalibre1 pcalibre calibre2">Now suppose that after the parent creates the child for client 1, it accepts a new connection request from client 2 and returns a new connected descriptor (say, 5), as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000080A7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.3</span></a>. The parent then forks another child, which begins servicing its client using connected descriptor 5, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000080B6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.4</span></a>. At this point, the parent is waiting for the next connection request and the two children are servicing their respective clients concurrently.</p>
<section id="P70004970270000000000000000080AD" data-uri="chapter12.xhtml#P70004970270000000000000000080AD" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046BAF" data-uri="chapter12.xhtml#P7000497027000000000000000046BAF" epub:type="title"><span class="pcalibre label pcalibre1">12.1.1 </span>A Concurrent Server Based on Processes</h1></header>
<p id="P7000497027000000000000000046BB0" data-uri="chapter12.xhtml#P7000497027000000000000000046BB0" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000080CF"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.5</span></a> shows the code for a concurrent echo server based on processes. The echo function called in line 29 comes from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007E78"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.22</span></a>. There are several important points to make about this server:</p>
<ul id="P7000497027000000000000000046BB1" data-uri="chapter12.xhtml#P7000497027000000000000000046BB1" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000046BB2" data-uri="chapter12.xhtml#P7000497027000000000000000046BB2" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046BB3" data-uri="chapter12.xhtml#P7000497027000000000000000046BB3" class="pcalibre calibre3 pcalibre1">First, servers typically run for long periods of time, so we must include a SIGCHLD handler that reaps zombie children (lines 4−9). Since SIGCHLD signals are blocked while the SIGCHLD handler is executing, and since Linux signals are not queued, the SIGCHLD handler must be prepared to reap multiple zombie children.</p></li>
<li id="P7000497027000000000000000046BB4" data-uri="chapter12.xhtml#P7000497027000000000000000046BB4" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046BB5" data-uri="chapter12.xhtml#P7000497027000000000000000046BB5" class="pcalibre calibre3 pcalibre1">Second, the parent and the child must close their respective copies of <code id="P7000497027000000000000000046BB6" data-uri="chapter12.xhtml#P7000497027000000000000000046BB6" class="pcalibre1 calibre8 pcalibre">connfd</code> (lines 33 and 30, respectively). As we have mentioned, this is especially important</p>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000080B6" data-uri="chapter12.xhtml#P70004970270000000000000000080B6">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000080B7" title="975" data-uri="chapter12.xhtml#P70004970270000000000000000080B7" epub:type="pagebreak"></span>
<img alt="A diagram shows step 4: data.transfers between clientfd on client 1 and connfd(4) on child 1, and between clientfd on client 2 and connfd(5) on child 2." id="P7000497027000000000000000046BB7" data-uri="P700049702700000000000000000B7CB" src="../images/p975-1.png" class="pcalibre1 calibre330 pcalibre"/>
<figcaption id="P7000497027000000000000000046BB8" data-uri="chapter12.xhtml#P7000497027000000000000000046BB8" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046BB9" data-uri="chapter12.xhtml#P7000497027000000000000000046BB9" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.4 </span>Step 4: Server forks another child to service the new client.</h1></header>
</figcaption>
</figure>
<p class="pcalibre calibre3 pcalibre1" id="P7000497027000000000000000046BBA" data-uri="chapter12.xhtml#P7000497027000000000000000046BBA">for the parent, which must close its copy of the connected descriptor to avoid a memory leak.</p></li>
<li id="P7000497027000000000000000046BBB" data-uri="chapter12.xhtml#P7000497027000000000000000046BBB" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046BBC" data-uri="chapter12.xhtml#P7000497027000000000000000046BBC" class="pcalibre calibre3 pcalibre1">Finally, because of the reference count in the socket's file table entry, the connection to the client will not be terminated until both the parent's and child's copies of <code id="P7000497027000000000000000046BBD" data-uri="chapter12.xhtml#P7000497027000000000000000046BBD" class="pcalibre1 calibre8 pcalibre">connfd</code> are closed.</p></li>
</ul>
</section>
<section id="P70004970270000000000000000080BF" data-uri="chapter12.xhtml#P70004970270000000000000000080BF" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046BBE" data-uri="chapter12.xhtml#P7000497027000000000000000046BBE" epub:type="title"><span class="pcalibre label pcalibre1">12.1.2 </span>Pros and Cons of Processes</h1></header>
<p id="P7000497027000000000000000046BBF" data-uri="chapter12.xhtml#P7000497027000000000000000046BBF" class="pcalibre1 pcalibre calibre2">Processes have a clean model for sharing state information between parents and children: file tables are shared and user address spaces are not. Having separate address spaces for processes is both an advantage and a disadvantage. It is impossible for one process to accidentally overwrite the virtual memory of another process, which eliminates a lot of confusing failures—an obvious advantage.</p>
<p id="P7000497027000000000000000046BC0" data-uri="chapter12.xhtml#P7000497027000000000000000046BC0" class="pcalibre1 pcalibre calibre2">On the other hand, separate address spaces make it more difficult for processes to share state information. To share information, they must use explicit IPC (interprocess communications) mechanisms. (See the Aside on <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="#P70004970270000000000000000080DB">page 977</a>.) Another disadvantage of process-based designs is that they tend to be slower because the overhead for process control and IPC is high.</p>
<section id="P70004970270000000000000000080C3" data-uri="chapter12.xhtml#P70004970270000000000000000080C3" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046BC1" data-uri="chapter12.xhtml#P7000497027000000000000000046BC1" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.1 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000046BC2" data-uri="chapter12.xhtml#P7000497027000000000000000046BC2">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000046BC3" data-uri="chapter12.xhtml#P7000497027000000000000000046BC3">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000046BC4" data-uri="chapter12.xhtml#P7000497027000000000000000046BC4"><p id="P7000497027000000000000000046BC5" data-uri="chapter12.xhtml#P7000497027000000000000000046BC5" class="pcalibre calibre3 pcalibre1">After the parent closes the connected descriptor in line 33 of the concurrent server in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000080CF"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.5</span></a>, the child is still able to communicate with the client using its copy of the descriptor. Why?</p></div></li>
</ol>
</section>
<section id="P70004970270000000000000000080C9" data-uri="chapter12.xhtml#P70004970270000000000000000080C9" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046BC6" data-uri="chapter12.xhtml#P7000497027000000000000000046BC6" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">12.2 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000867A.xhtml#P700049702700000000000000000875C">1036</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000046BC7" data-uri="chapter12.xhtml#P7000497027000000000000000046BC7">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000046BC8" data-uri="chapter12.xhtml#P7000497027000000000000000046BC8">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000046BC9" data-uri="chapter12.xhtml#P7000497027000000000000000046BC9"><p id="P7000497027000000000000000046BCA" data-uri="chapter12.xhtml#P7000497027000000000000000046BCA" class="pcalibre calibre3 pcalibre1">If we were to delete line 30 of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000080CF"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">12.5</span></a>, which closes the connected descriptor, the code would still be correct, in the sense that there would be no memory leak. Why?</p></div></li>
</ol>
</section>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000080CF" data-uri="chapter12.xhtml#P70004970270000000000000000080CF">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000080D0" title="976" data-uri="chapter12.xhtml#P70004970270000000000000000080D0" epub:type="pagebreak"></span>
<p id="P7000497027000000000000000046BCB" data-uri="chapter12.xhtml#P7000497027000000000000000046BCB" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoserverp.c</i></p>
<pre id="P7000497027000000000000000046BCC" data-uri="chapter12.xhtml#P7000497027000000000000000046BCC" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046BCD" data-uri="chapter12.xhtml#P7000497027000000000000000046BCD" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	void echo(int connfd);
3	
4	void sigchld_handler(int sig)
5	{
6		while (waitpid(−1, 0, WNOHANG) &gt; 0)
7			;
8		return;
9	}
10	
11	int main(int argc, char **argv)
12	{
13		int listenfd, connfd;
14		socklen_t clientlen;
15		struct sockaddr_storage clientaddr;
16
17		if (argc != 2) {
18			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
19			exit(0);
20		}
21	
22		Signal(SIGCHLD, sigchld_handler);
23		listenfd = Open_listenfd(argv[1]);
24		while (1) {
25			clientlen = sizeof(struct sockaddr_storage);
26			connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);
27			if (Fork() == 0) {
28				Close(listenfd); /* Child closes its listening socket */
29				echo(connfd);	 /* Child services client */
30				Close(connfd);	 /* Child closes connection with client */
31				exit(0);	 /* Child exits */
32			}
33			Close(connfd); /* Parent closes connected socket (important!) */
34		}
35	}
</code></pre>
<p id="P7000497027000000000000000046BCE" data-uri="chapter12.xhtml#P7000497027000000000000000046BCE" class="pcalibre1 pcalibre calibre2">-------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/conc/echoserverp.c</i></p>
<figcaption id="P7000497027000000000000000046BCF" data-uri="chapter12.xhtml#P7000497027000000000000000046BCF" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046BD0" data-uri="chapter12.xhtml#P7000497027000000000000000046BD0" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">12.5 </span>Concurrent echo server based on processes.</h1></header>
<div class="caption pcalibre pcalibre1" id="P7000497027000000000000000046BD1" data-uri="chapter12.xhtml#P7000497027000000000000000046BD1"><p id="P7000497027000000000000000046BD2" data-uri="chapter12.xhtml#P7000497027000000000000000046BD2" class="pcalibre calibre3 pcalibre1">The parent forks a child to handle each new connection request.</p></div></figcaption>
</figure>
<aside class="sidebar pcalibre5 pcalibre" id="P70004970270000000000000000080D9" data-uri="chapter12.xhtml#P70004970270000000000000000080D9"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000046BD3" data-uri="chapter12.xhtml#P7000497027000000000000000046BD3" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000080DB" title="977" data-uri="chapter12.xhtml#P70004970270000000000000000080DB" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Unix IPC</h1></header>
<p id="P7000497027000000000000000046BD4" data-uri="chapter12.xhtml#P7000497027000000000000000046BD4" class="pcalibre calibre3 pcalibre1">You have already encountered several examples of IPC in this text. The <code id="P7000497027000000000000000046BD5" data-uri="chapter12.xhtml#P7000497027000000000000000046BD5" class="pcalibre1 calibre8 pcalibre">waitpid</code> function and signals from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">8</span></a> are primitive IPC mechanisms that allow processes to send tiny messages to process running on the same host. The sockets interface from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007B7A.xhtml#P7000497027000000000000000007B7A"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">11</span></a> is an important form of IPC that allows processes on different hosts to exchange arbitrary byte streams. However, the term <i class="calibre5 pcalibre pcalibre1">Unix IPC</i> is typically reserved for a hodgepodge of techniques that allow processes to communicate with other processes that are running on the same host. Examples include pipes, FIFOs, System V shared memory, and System V semaphores. These mechanisms are beyond our scope. The book by Kerrisk [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B41E">62</a>] is an excellent reference.</p>
</aside>
</section>
</section></body></html>
