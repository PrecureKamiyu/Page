<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>6.2 Problem #1: Restricted Operations</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part53.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part55.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 44pt;text-indent: 0pt;text-align: left;">6.2 Problem #1: Restricted Operations</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Direct execution has the obvious advantage of being fast; the program runs natively on the hardware CPU and thus executes as quickly as one would expect. But running on the CPU introduces a problem: what if the process wishes to perform some kind of restricted operation, such as issuing an I/O request to a disk, or gaining access to more system resources such as CPU or memory?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>P<span class="s7">ERFORM </span>R<span class="s7">ESTRICTED </span>O<span class="s7">PERATIONS</span></p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: justify;">A process must be able to perform I/O and some other restricted oper- ations, but without giving the process complete control over the system. How can the OS and hardware work together to do so?</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 66pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: U<span class="s7">SE </span>P<span class="s7">ROTECTED </span>C<span class="s7">ONTROL </span>T<span class="s7">RANSFER</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The hardware assists the OS by providing different modes of execution. In <b>user mode</b>, applications do not have full access to hardware resources. In <b>kernel mode</b>, the OS has access to the full resources of the machine. Special instructions to <b>trap </b>into the kernel and <b>return-from-trap </b>back to user-mode programs are also provided, as well instructions that allow the OS to tell the hardware where the <b>trap table </b>resides in memory.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One approach would simply be to let any process do whatever it wants in terms of I/O and other related operations. However, doing so would prevent the construction of many kinds of systems that are desirable. For example, if we wish to build a file system that checks permissions before granting access to a file, we can’t simply let any user process issue I/Os to the disk; if we did, a process could simply read or write the entire disk and thus all protections would be lost.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus, the approach we take is to introduce a new processor mode, known as <b>user mode</b>; code that runs in user mode is restricted in what it can do. For example, when running in user mode, a process can’t issue I/O requests; doing so would result in the processor raising an exception; the OS would then likely kill the process.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In contrast to user mode is <b>kernel mode</b>, which the operating system (or kernel) runs in. In this mode, code that runs can do what it likes, in- cluding privileged operations such as issuing I/O requests and executing all types of restricted instructions.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We are still left with a challenge, however: what should a user pro- cess do when it wishes to perform some kind of privileged operation, such as reading from disk? To enable this, virtually all modern hard- ware provides the ability for user programs to perform a <b>system call</b>. Pioneered on ancient machines such as the Atlas [K+61,L78], system calls allow the kernel to carefully expose certain key pieces of functionality to user programs, such as accessing the file system, creating and destroy- ing processes, communicating with other processes, and allocating more memory. Most operating systems provide a few hundred calls (see the POSIX standard for details [P10]); early Unix systems exposed a more concise subset of around twenty calls.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To execute a system call, a program must execute a special <b>trap </b>instruc- tion. This instruction simultaneously jumps into the kernel and raises the privilege level to kernel mode; once in the kernel, the system can now per- form whatever privileged operations are needed (if allowed), and thus do the required work for the calling process. When finished, the OS calls a special <b>return-from-trap </b>instruction, which, as you might expect, returns into the calling user program while simultaneously reducing the privi- lege level back to user mode.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The hardware needs to be a bit careful when executing a trap, in that it must make sure to save enough of the caller’s register state in order</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 28pt;text-indent: 0pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>W<span class="s45">HY </span>S<span class="s45">YSTEM </span>C<span class="s45">ALLS </span>L<span class="s45">OOK </span>L<span class="s45">IKE </span>P<span class="s45">ROCEDURE </span>C<span class="s45">ALLS</span></p><p style="padding-top: 3pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">You may wonder why a call to a system call, such as <span class="s41">open() </span>or <span class="s41">read()</span>, looks exactly like a typical procedure call in C; that is, if it looks just like a procedure call, how does the system know it’s a system call, and do all the right stuff? The simple reason: it <i>is </i>a procedure call, but hidden in- side that procedure call is the famous trap instruction. More specifically, when you call <span class="s41">open() </span>(for example), you are executing a procedure call into the C library. Therein, whether for <span class="s41">open() </span>or any of the other sys- tem calls provided, the library uses an agreed-upon calling convention with the kernel to put the arguments to open in well-known locations (e.g., on the stack, or in specific registers), puts the system-call number into a well-known location as well (again, onto the stack or a register), and then executes the aforementioned trap instruction. The code in the library after the trap unpacks return values and returns control to the program that issued the system call. Thus, the parts of the C library that make system calls are hand-coded in assembly, as they need to carefully follow convention in order to process arguments and return values cor- rectly, as well as execute the hardware-specific trap instruction. And now you know why you personally don’t have to write assembly code to trap into an OS; somebody has already written that assembly for you.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">to be able to return correctly when the OS issues the return-from-trap instruction. On x86, for example, the processor will push the program counter, flags, and a few other registers onto a per-process <b>kernel stack</b>; the return-from-trap will pop these values off the stack and resume exe- cution of the user-mode program (see the Intel systems manuals [I11] for details). Other hardware systems use different conventions, but the basic concepts are similar across platforms.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">There is one important detail left out of this discussion: how does the trap know which code to run inside the OS? Clearly, the calling process can’t specify an address to jump to (as you would when making a pro- cedure call); doing so would allow programs to jump anywhere into the kernel which clearly is a bad idea (imagine jumping into code to access a file, but just after a permission check; in fact, it is likely such ability would enable a wily programmer to get the kernel to run arbitrary code sequences [S07]). Thus the kernel must carefully control what code exe- cutes upon a trap.</p><p style="padding-left: 68pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The kernel does so by setting up a <b>trap table </b>at boot time. When the machine boots up, it does so in privileged (kernel) mode, and thus is free to configure machine hardware as need be. One of the first things the OS thus does is to tell the hardware what code to run when certain exceptional events occur. For example, what code should run when a hard-disk interrupt takes place, when a keyboard interrupt occurs, or when program makes a system call? The OS informs the hardware of the locations of these <b>trap handlers</b>, usually with some kind of special</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-top: 3pt;padding-left: 53pt;text-indent: 0pt;line-height: 8pt;text-align: left;">OS @ boot          Hardware</p><p style="text-indent: 0pt;text-align: left;"><span><img width="367" height="1" alt="image" src="Image_034.png"/></span></p><p class="s36" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">(kernel mode) initialize trap table</p><p class="s12" style="padding-left: 162pt;text-indent: -4pt;line-height: 91%;text-align: left;">remember address of... syscall handler</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-left: 53pt;text-indent: 0pt;line-height: 8pt;text-align: left;">OS @ run           Hardware           Program</p><p class="s36" style="padding-left: 53pt;text-indent: 0pt;line-height: 8pt;text-align: left;">(kernel mode)                        (user mode)</p><p style="padding-left: 47pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="361" height="0" alt="image" src="Image_035.png"/></span></p><p class="s12" style="padding-left: 53pt;text-indent: 0pt;line-height: 92%;text-align: left;">Create entry for process list Allocate memory for program Load program into memory Setup user stack with argv Fill kernel stack with reg/PC <b>return-from-trap</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 53pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Handle trap</p><p class="s12" style="padding-left: 57pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Do work of syscall</p><p class="s36" style="padding-left: 53pt;text-indent: 0pt;line-height: 8pt;text-align: left;">return-from-trap</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-top: 5pt;padding-left: 53pt;text-indent: 0pt;line-height: 92%;text-align: left;">Free memory of process Remove from process list</p><p class="s12" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">restore regs from kernel stack</p><p class="s12" style="padding-left: 24pt;text-indent: 0pt;line-height: 91%;text-align: left;">move to user mode jump to main</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-top: 5pt;padding-left: 24pt;text-indent: 0pt;line-height: 92%;text-align: left;">save regs to kernel stack move to kernel mode jump to trap handler</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 24pt;text-indent: 0pt;line-height: 91%;text-align: left;">restore regs from kernel stack move to user mode</p><p class="s12" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">jump to PC after trap</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-top: 4pt;padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Run main()</p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">...</p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Call system call</p><p class="s36" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">trap <span class="s12">into OS</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">...</p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">return from main</p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><b>trap </b>(via <span class="s38">exit()</span>)</p><p style="padding-top: 6pt;padding-left: 89pt;text-indent: 0pt;text-align: justify;">Table 6.2: <b>Limited Direction Execution Protocol</b></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">instruction. Once the hardware is informed, it remembers the location of these handlers until the machine is next rebooted, and thus the hardware knows what to do (i.e., what code to jump to) when system calls and other exceptional events take place.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One last aside: being able to execute the instruction to tell the hard- ware where the trap tables are is a very powerful capability. Thus, as you might have guessed, it is also a <b>privileged </b>operation. If you try to exe- cute this instruction in user mode, the hardware won’t let you, and you can probably guess what will happen (hint: adios, offending program). Point to ponder: what horrible things could you do to a system if you could install your own trap table? Could you take over the machine?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The timeline (with time increasing downward, in Table <span style=" color: #00AEEF;">6.2</span>) summa- rizes the protocol. We assume each process has a kernel stack where reg- isters (including general purpose registers and the program counter) are saved to and restored from (by the hardware) when transitioning into and out of the kernel.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">There are two phases in the LDE protocol. In the first (at boot time), the kernel initializes the trap table, and the CPU remembers its location for subsequent use. The kernel does so via a privileged instruction (all privileged instructions are highlighted in bold).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In the second (when running a process), the kernel sets up a few things (e.g., allocating a node on the process list, allocating memory) before us- ing a return-from-trap instruction to start the execution of the process; this switches the CPU to user mode and begins running the process. When the process wishes to issue a system call, it traps back into the OS, which handles it and once again returns control via a return-from-trap to the process. The process then completes its work, and returns from <span class="s41">main()</span>; this usually will return into some stub code which will properly exit the program (say, by calling the <span class="s41">exit() </span>system call, which traps into the OS). At this point, the OS cleans up and we are done.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part53.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part55.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
