<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Crash Scenarios</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part463.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part465.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Crash Scenarios</p><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">To understand the problem better, let’s look at some example crash sce- narios. Imagine only a single write succeeds; there are thus three possible outcomes, which we list here:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-top: 4pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Just the data block (Db) is written to disk. </span><span class="p">In this case, the data is on disk, but there is no inode that points to it and no bitmap that even says the block is allocated. Thus, it is as if the write never occurred. This case is not a problem at all, from the perspective of</span></p><p style="padding-left: 91pt;text-indent: 0pt;text-align: justify;">file-system crash consistency<span class="s35">1</span>.</p><p class="s27" style="padding-top: 7pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>Just the updated inode (I[v2]) is written to disk. <span class="p">In this case, the inode points to the disk address (5) where Db was about to be writ- ten, but Db has not yet been written there. Thus, if we trust that pointer, we will read </span>garbage <span class="p">data from the disk (the old contents of disk address 5).</span></p><p style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Further, we have a new problem, which we call a <b>file-system incon- sistency</b>. The on-disk bitmap is telling us that data block 5 has not been allocated, but the inode is saying that it has. This disagree- ment in the file system data structures is an inconsistency in the data structures of the file system; to use the file system, we must somehow resolve this problem (more on that below).</p><p class="s27" style="padding-top: 7pt;padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>Just the updated bitmap (B[v2]) is written to disk. <span class="p">In this case, the bitmap indicates that block 5 is allocated, but there is no inode that points to it. Thus the file system is inconsistent again; if left unre- solved, this write would result in a </span>space leak<span class="p">, as block 5 would never be used by the file system.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: left;">There are also three more crash scenarios in this attempt to write three blocks to disk. In these cases, two writes succeed and the last one fails:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">The inode (I[v2]) and bitmap (B[v2]) are written to disk, but not data (Db). </span><span class="p">In this case, the file system metadata is completely con- sistent: the inode has a pointer to block 5, the bitmap indicates that 5 is in use, and thus everything looks OK from the perspective of the file system’s metadata. But there is one problem: 5 has garbage in it again.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">The inode (I[v2]) and the data block (Db) are written, but not the bitmap (B[v2]). </span><span class="p">In this case, we have the inode pointing to the cor- rect data on disk, but again have an inconsistency between the in- ode and the old version of the bitmap (B1). Thus, we once again need to resolve the problem before using the file system.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 91pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">The bitmap (B[v2]) and data block (Db) are written, but not the inode (I[v2]). </span><span class="p">In this case, we again have an inconsistency between the inode and the data bitmap. However, even though the block was written and the bitmap indicates its usage, we have no idea which file it belongs to, as no inode points to the file.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_614.png"/></span></p><p class="s11" style="padding-top: 1pt;padding-left: 32pt;text-indent: 0pt;text-align: center;">1<span class="s12">However, it might be a problem for the user, who just lost some data!</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part463.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part465.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
