<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>26.4 The Wish For Atomicity</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part264.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part266.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">26.4 The Wish For Atomicity</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One way to solve this problem would be to have more powerful in- structions that, in a single step, did exactly whatever we needed done and thus removed the possibility of an untimely interrupt. For example, what if we had a super instruction that looked like this?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 45pt;text-indent: 0pt;text-align: left;">memory-add 0x8049a1c, $0x1</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Assume this instruction adds a value to a memory location, and the hardware guarantees that it executes <b>atomically</b>; when the instruction executed, it would perform the update as desired. It could not be inter- rupted mid-instruction, because that is precisely the guarantee we receive from the hardware: when an interrupt occurs, either the instruction has not run at all, or it has run to completion; there is no in-between state. Hardware can be a beautiful thing, no?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Atomically, in this context, means “as a unit”, which sometimes we take as “all or none.” What we’d like is to execute the three instruction sequence atomically:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 45pt;text-indent: 0pt;text-align: left;">mov 0x8049a1c, %eax add $0x1, %eax</p><p class="s38" style="padding-left: 45pt;text-indent: 0pt;text-align: left;">mov %eax, 0x8049a1c</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As we said, if we had a single instruction to do this, we could just issue that instruction and be done. But in the general case, we won’t have such an instruction. Imagine we were building a concurrent B-tree, and wished to update it; would we really want the hardware to support an “atomic update of B-tree” instruction? Probably not, at least in a sane instruction set.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus, what we will instead do is ask the hardware for a few useful instructions upon which we can build a general set of what we call <b>syn- chronization primitives</b>. By using these hardware synchronization prim- itives, in combination with some help from the operating system, we will be able to build multi-threaded code that accesses critical sections in a</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 74pt;text-indent: 5pt;line-height: 89%;text-align: left;">A<span class="s7">SIDE</span>: <b>K</b><span class="s45">EY </span><b>C</b><span class="s45">ONCURRENCY </span><b>T</b><span class="s45">ERMS </span>C<span class="s7">RITICAL </span>S<span class="s7">ECTION</span>, R<span class="s7">ACE </span>C<span class="s7">ONDITION</span>, I<span class="s7">NDETERMINATE</span>, M<span class="s7">UTUAL </span>E<span class="s7">XCLUSION</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">These four terms are so central to concurrent code that we thought it worth while to call them out explicitly. See some of Dijkstra’s early work [D65,D68] for more details.</p><p style="padding-top: 6pt;padding-left: 31pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>A <b>critical section </b>is a piece of code that accesses a <i>shared </i>resource, usually a variable or data structure.</p><p style="padding-top: 6pt;padding-left: 31pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>A <b>race condition </b>arises if multiple threads of execution enter the critical section at roughly the same time; both attempt to update the shared data structure, leading to a surprising (and perhaps un- desirable) outcome.</p><p style="padding-top: 6pt;padding-left: 31pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>An <b>indeterminate </b>program consists of one or more race conditions; the output of the program varies from run to run, depending on which threads ran when. The outcome is thus not <b>deterministic</b>, something we usually expect from computer systems.</p><p style="padding-top: 6pt;padding-left: 31pt;text-indent: -9pt;line-height: 89%;text-align: justify;"><span class="s4">• </span>To avoid these problems, threads should use some kind of <b>mutual exclusion </b>primitives; doing so guarantees that only a single thread ever enters a critical section, thus avoiding races, and resulting in deterministic program outputs.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">synchronized and controlled manner, and thus reliably produces the cor- rect result despite the challenging nature of concurrent execution. Pretty awesome, right?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This is the problem we will study in this section of the book. It is a wonderful and hard problem, and should make your mind hurt (a bit). If it doesn’t, then you don’t understand! Keep working until your head hurts; you then know you’re headed in the right direction. At that point, take a break; we don’t want your head hurting too much.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>:</p><p style="padding-left: 24pt;text-indent: 0pt;line-height: 10pt;text-align: center;">H<span class="s7">OW </span>T<span class="s7">O </span>P<span class="s7">ROVIDE </span>S<span class="s7">UPPORT </span>F<span class="s7">OR </span>S<span class="s7">YNCHRONIZATION</span></p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: justify;">What support do we need from the hardware in order to build use- ful synchronization primitives? What support do we need from the OS? How can we build these primitives correctly and efficiently? How can programs use them to get the desired results?</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part264.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part266.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
