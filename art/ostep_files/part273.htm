<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>27.2 Thread Completion</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part272.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part274.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">27.2 Thread Completion</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_327.png"/></span></p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The example above shows how to create a thread. However, what happens if you want to wait for a thread to complete? You need to do something special in order to wait for completion; in particular, you must call the routine <span class="s41">pthread join()</span>.</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">int pthread_join(pthread_t thread, void <span class="s39">**</span>value_ptr);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#include &lt;pthread.h&gt;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">2</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;text-align: left;"><span class="s37">3  </span>typedef struct <span class="s75">&nbsp;</span>myarg_t {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4    <span class="s38">int a;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5    <span class="s38">int b;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6  <span class="s38">} myarg_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">7</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">8  </span>void <span class="s39">*</span>mythread(void <span class="s39">*</span>arg) {</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">9    </span>myarg_t <span class="s39">*</span>m = (myarg_t <span class="s39">*</span>) arg;</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">10    <span class="s38">printf(&quot;%d %d\n&quot;, m-&gt;a, m-&gt;b);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11    <span class="s38">return NULL;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">13</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14  <span class="s38">int</span></p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">15  </span>main(int argc, char <span class="s39">*</span>argv[]) {</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">16    <span class="s38">pthread_t p;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">17    <span class="s38">int rc;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">18</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19    <span class="s38">myarg_t args;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">20    <span class="s38">args.a = 10;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">21    <span class="s38">args.b = 20;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">22    <span class="s38">rc = pthread_create(&amp;p, NULL, mythread, &amp;args);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">23    <span class="s38">...</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">24  <span class="s38">}</span></p><p style="padding-left: 123pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 27.1: <b>Creating a Thread</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_328.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">This routine takes only two arguments. The first is of type <span class="s41">pthread t</span>, and is used to specify which thread to wait for. This value is exactly what you passed into the thread library during creation; if you held onto it, you can now use it to wait for the thread to stop running.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_329.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The second argument is a pointer to the return value you expect to get back. Because the routine can return anything, it is defined to return a pointer to void; because the <span class="s41">pthread join() </span>routine <i>changes </i>the value of the passed in argument, you need to pass in a pointer to that value, not just the value itself.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_330.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_331.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let’s look at another example (Figure <span style=" color: #00AEEF;">27.2</span>). In the code, a single thread is again created, and passed a couple of arguments via the <span class="s41">myarg t </span>struc- ture. To return values, the <span class="s41">myret t </span>type is used. Once the thread is finished running, the main thread, which has been waiting inside of the</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_332.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_333.png"/></span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 88%;text-align: justify;"><span class="s41">pthread join() </span>routine<span class="s35">1</span>, then returns, and we can access the values returned from the thread, namely whatever is in <span class="s41">myret t</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_334.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A few things to note about this example. First, often times we don’t have to do all of this painful packing and unpacking of arguments. For example, if we just create a thread with no arguments, we can pass <span class="s41">NULL </span>in as an argument when the thread is created. Similarly, we can pass <span class="s41">NULL </span>into <span class="s41">pthread join() </span>if we don’t care about the return value.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Second, if we are just passing in a single value (e.g., an int), we don’t have to package it up as an argument. Figure <span style=" color: #00AEEF;">27.3 </span>shows an example. In</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_335.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_336.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_337.png"/></span></p><p class="s11" style="padding-top: 2pt;padding-left: 41pt;text-indent: 13pt;line-height: 92%;text-align: justify;">1<span class="s12">Note we use wrapper functions here; specifically, we call Malloc(), Pthread join(), and Pthread create(), which just call their similarly-named lower-case versions and make sure the routines did not return anything unexpected.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#include &lt;stdio.h&gt;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2  <span class="s38">#include &lt;pthread.h&gt;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">#include &lt;assert.h&gt;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38">#include &lt;stdlib.h&gt;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">5</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">6  </span>typedef struct <span class="s75">&nbsp;</span>myarg_t {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7    <span class="s38">int a;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8    <span class="s38">int b;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9  <span class="s38">} myarg_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">10</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;text-align: left;"><span class="s37">11  </span>typedef struct <span class="s75">&nbsp;</span>myret_t {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">12    <span class="s38">int x;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">13    <span class="s38">int y;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">14  <span class="s38">} myret_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">15</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">16  </span>void <span class="s39">*</span>mythread(void <span class="s39">*</span>arg) {</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 85%;text-align: left;"><span class="s37">17    </span>myarg_t <span class="s39">*</span>m = (myarg_t <span class="s39">*</span>) arg;</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">18    <span class="s38">printf(&quot;%d %d\n&quot;, m-&gt;a, m-&gt;b);</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">19    </span>myret_t <span class="s39">*</span>r = Malloc(sizeof(myret_t));</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">20    <span class="s38">r-&gt;x = 1;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">21    <span class="s38">r-&gt;y = 2;</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">22    </span>return (void <span class="s39">*</span>) r;</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">23  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">24</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">25  <span class="s38">int</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">26  </span>main(int argc, char <span class="s39">*</span>argv[]) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">27    <span class="s38">int rc;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">28    <span class="s38">pthread_t p;</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;text-align: left;"><span class="s37">29    </span>myret_t <span class="s39">*</span>m;</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">30</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">31    <span class="s38">myarg_t args;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">32    <span class="s38">args.a = 10;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">33    <span class="s38">args.b = 20;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">34    <span class="s38">Pthread_create(&amp;p, NULL, mythread, &amp;args);</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">35    </span>Pthread_join(p, (void <span class="s39">**</span>) &amp;m);</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">36    <span class="s38">printf(&quot;returned %d %d\n&quot;, m-&gt;x, m-&gt;y);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">37    <span class="s38">return 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">38  <span class="s38">}</span></p><p style="padding-left: 124pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 27.2: <b>Waiting for Thread Completion</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">this case, life is a bit simpler, as we don’t have to package arguments and return values inside of structures.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Third, we should note that one has to be extremely careful with how values are returned from a thread. In particular, never return a pointer which refers to something allocated on the thread’s call stack. If you do, what do you think will happen? (think about it!) Here is an example of a dangerous piece of code, modified from the example in Figure <span style=" color: #00AEEF;">27.2</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">1  </span>void <span class="s39">*</span>mythread(void <span class="s39">*</span>arg) {</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">2    </span>myarg_t <span class="s39">*</span>m = (myarg_t <span class="s39">*</span>) arg;</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">3    <span class="s38">printf(&quot;%d %d\n&quot;, m-&gt;a, m-&gt;b);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4     <span class="s38">myret_t r; // ALLOCATED ON STACK: BAD!</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5    <span class="s38">r.x = 1;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6    <span class="s38">r.y = 2;</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">7    </span>return (void <span class="s39">*</span>) &amp;r;</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">8  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 57pt;text-indent: -16pt;line-height: 94%;text-align: left;">void <span class="s39">*</span>mythread(void <span class="s39">*</span>arg) { int m = (int) arg; printf(&quot;%d\n&quot;, m);</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;line-height: 8pt;text-align: left;">return (void <span class="s39">*</span>) (arg + 1);</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;line-height: 8pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 57pt;text-indent: -16pt;line-height: 89%;text-align: left;">int main(int argc, char <span class="s39">*</span>argv[]) { pthread_t p;</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">int rc, m;</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;line-height: 90%;text-align: left;">Pthread_create(&amp;p, NULL, mythread, (void <span class="s39">*</span>) 100); Pthread_join(p, (void <span class="s39">**</span>) &amp;m);</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;line-height: 7pt;text-align: left;">printf(&quot;returned %d\n&quot;, m);</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">return 0;</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 5pt;padding-left: 81pt;text-indent: 0pt;text-align: left;">Figure 27.3: <b>Simpler Argument Passing to a Thread</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In this case, the variable <span class="s41">r </span>is allocated on the stack of <span class="s41">mythread</span>. How- ever, when it returns, the value is automatically deallocated (that’s why the stack is so easy to use, after all!), and thus, passing back a pointer to a now deallocated variable will lead to all sorts of bad results. Certainly, when you print out the values you think you returned, you’ll probably</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">(but not necessarily!) be surprised. Try it and find out for yourself<span class="s35">2</span>!</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_338.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_339.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Finally, you might notice that the use of <span class="s41">pthread create() </span>to create a thread, followed by an immediate call to <span class="s41">pthread join()</span>, is a pretty strange way to create a thread. In fact, there is an easier way to accom- plish this exact task; it’s called a <b>procedure call</b>. Clearly, we’ll usually be creating more than just one thread and waiting for it to complete, other- wise there is not much purpose to using threads at all.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We should note that not all code that is multi-threaded uses the join routine. For example, a multi-threaded web server might create a number of worker threads, and then use the main thread to accept requests and pass them to the workers, indefinitely. Such long-lived programs thus may not need to join. However, a parallel program that creates threads to execute a particular task (in parallel) will likely use join to make sure all such work completes before exiting or moving onto the next stage of computation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part272.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part274.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
