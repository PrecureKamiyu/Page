<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 32. Threads: Thread Cancellation</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch31.html" title="Chapter 31. Threads: Thread Safety and Per-Thread Storage"/><link rel="next" href="ch33.html" title="Chapter 33. Threads: Further Details"/></head><body><section class="chapter" title="Chapter 32. Threads: Thread Cancellation" epub:type="chapter" id="threads_colon_thread_cancellation"><div class="titlepage"><div><div><h2 class="title">Chapter 32. Threads: Thread Cancellation</h2></div></div></div><p>Typically, multiple threads execute in parallel, with each thread performing its task
            until it decides to terminate by calling <span class="emphasis"><em>pthread_exit()</em></span> or
            returning from the thread’s start function.</p><p>Sometimes, it can be useful to <span class="emphasis"><em>cancel</em></span> a thread; that is, to send
            it a request asking it to terminate now. This could be useful, for example, if a group
            of threads is performing a calculation, and one thread detects an error condition that
            requires the other threads to terminate. Alternatively, a GUI-driven application may
            provide a cancel button to allow the user to terminate a task that is being performed by
            a thread in the background; in this case, the main thread (controlling the GUI) needs to
            tell the background thread to terminate.</p><p>In this chapter, we describe the POSIX threads cancellation mechanism.</p><div class="sect1" title="Canceling a Thread"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="canceling_a_thread">Canceling a Thread</h2></div></div></div><p>The <span class="emphasis"><em>pthread_cancel()</em></span> function sends a cancellation request to
                the specified <span class="emphasis"><em>thread</em></span>.<a id="IDX-CHP-32-4706" class="indexterm"/><a id="IDX-CHP-32-4707" class="indexterm"/><a id="IDX-CHP-32-4708" class="indexterm"/><a id="IDX-CHP-32-4709" class="indexterm"/><a id="IDX-CHP-32-4710" class="indexterm"/></p><a id="I_programlisting32_d1e89554"/><pre class="programlisting">#include &lt;pthread.h&gt;

int <strong class="userinput"><code>pthread_cancel</code></strong> (pthread_t <span class="emphasis"><em>thread</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><p>Having made the cancellation request, <span class="emphasis"><em>pthread_cancel()</em></span>
                returns immediately; that is, it doesn’t wait for the target thread to
                terminate.</p><p>Precisely what happens to the target thread, and when it happens, depends on that
                thread’s cancellation state and type, as described in the next section.</p></div><div class="sect1" title="Cancellation State and Type"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="cancellation_state_and_type">Cancellation State and Type</h2></div></div></div><p>The <span class="emphasis"><em>pthread_setcancelstate()</em></span> and
                    <span class="emphasis"><em>pthread_setcanceltype()</em></span> functions set flags that allow a
                thread to control how it responds to a cancellation request.<a id="IDX-CHP-32-4711" class="indexterm"/><a id="IDX-CHP-32-4712" class="indexterm"/><a id="IDX-CHP-32-4713" class="indexterm"/><a id="IDX-CHP-32-4714" class="indexterm"/><a id="IDX-CHP-32-4715" class="indexterm"/><a id="IDX-CHP-32-4716" class="indexterm"/><a id="IDX-CHP-32-4717" class="indexterm"/><a id="IDX-CHP-32-4718" class="indexterm"/></p><a id="I_programlisting32_d1e89626"/><pre class="programlisting">#include &lt;pthread.h&gt;

int <strong class="userinput"><code>pthread_setcancelstate</code></strong>(int <span class="emphasis"><em>state</em></span>, int *<span class="emphasis"><em>oldstate</em></span>);
int <strong class="userinput"><code>pthread_setcanceltype</code></strong>(int <span class="emphasis"><em>type</em></span>, int *<span class="emphasis"><em>oldtype</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or a positive error number on error</p></div><p>The <span class="emphasis"><em>pthread_setcancelstate()</em></span> function sets the calling
                thread’s cancelability state to the value given in <span class="emphasis"><em>state</em></span>. This
                argument has one of the following values:<a id="IDX-CHP-32-4719" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">PTHREAD_CANCEL_DISABLE</code>
                    </span></dt><dd><p>The thread is not cancelable. If a cancellation request is received,
                            it remains pending until cancelability is enabled.</p></dd><dt><span class="term">
                        <code class="literal">PTHREAD_CANCEL_ENABLE</code>
                    </span></dt><dd><p>The thread is cancelable. This is the default cancelability state in
                            newly created threads.</p></dd></dl></div><p>The thread’s previous cancelability state is returned in the location pointed to
                by <span class="emphasis"><em>oldstate</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If we are not interested in the previous cancelability state, Linux allows
                        <span class="emphasis"><em>oldstate</em></span> to be specified as <code class="literal">NULL</code>. This is the case on many other implementations as well;
                    however, SUSv3 doesn’t specify this feature, so portable applications can’t rely
                    on it. We should always specify a non-<code class="literal">NULL</code>
                    value for <span class="emphasis"><em>oldstate</em></span>.</p></div><p>Temporarily disabling cancellation (<code class="literal">PTHREAD_CANCEL_DISABLE</code>) is useful if a thread is executing a section
                of code where <span class="emphasis"><em>all</em></span> of the steps must be completed.</p><p>If a thread is cancelable (<code class="literal">PTHREAD_CANCEL_ENABLE</code>), then the treatment of a cancellation request
                is determined by the thread’s cancelability type, which is specified by the
                    <span class="emphasis"><em>type</em></span> argument in a call to
                    <span class="emphasis"><em>pthread_setcanceltype()</em></span>. This argument has one of the
                following values:<a id="IDX-CHP-32-4720" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">PTHREAD_CANCEL_ASYNCHRONOUS</code>
                    </span></dt><dd><p>The thread may be canceled at any time (perhaps, but not necessarily,
                            immediately). Asynchronous cancelability is rarely useful, and we defer
                            discussion of it until Section 32.6.</p></dd><dt><span class="term">
                        <code class="literal">PTHREAD_CANCEL_DEFERRED</code>
                    </span></dt><dd><p>The cancellation remains pending until a cancellation point (see the
                            next section) is reached. This is the default cancelability type in
                            newly created threads. We say more about deferred cancelability in the
                            following sections.</p></dd></dl></div><p>The thread’s previous cancelability type is returned in the location pointed to by
                    <span class="emphasis"><em>oldtype</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>As with the <span class="emphasis"><em>pthread_setcancelstate() oldstate</em></span> argument,
                    many implementations, including Linux, allow <span class="emphasis"><em>oldtype</em></span> to be
                    specified as <code class="literal">NULL</code> if we are not interested in
                    the previous cancelability type. Again, SUSv3 doesn’t specify this feature, and
                    portable applications can’t rely on it We should always specify a non-<code class="literal">NULL</code> value for
                    <span class="emphasis"><em>oldtype</em></span>.</p></div><p>When a thread calls <span class="emphasis"><em>fork()</em></span>, the child inherits the calling
                thread’s cancelability type and state. When a thread calls
                    <span class="emphasis"><em>exec()</em></span>, the cancelability type and state of the main thread
                of the new program are reset to <code class="literal">PTHREAD_CANCEL_ENABLE</code> and <code class="literal">PTHREAD_CANCEL_DEFERRED</code>, respectively.</p></div><div class="sect1" title="Cancellation Points"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="cancellation_points">Cancellation Points</h2></div></div></div><p>When cancelability is enabled and deferred, a cancellation request is acted upon
                only when a thread next reaches a <span class="emphasis"><em>cancellation point</em></span>. A
                cancellation point is a call to one of a set of functions defined by the
                    implementation.<a id="IDX-CHP-32-4721" class="indexterm"/><a id="IDX-CHP-32-4722" class="indexterm"/><a id="IDX-CHP-32-4723" class="indexterm"/><a id="IDX-CHP-32-4724" class="indexterm"/><a id="IDX-CHP-32-4725" class="indexterm"/><a id="IDX-CHP-32-4726" class="indexterm"/><a id="IDX-CHP-32-4727" class="indexterm"/></p><p>SUSv3 specifies that the functions shown in <a class="xref" href="ch32.html#functions_required_to_be_cancellation_po" title="Table 32-1. Functions required to be cancellation points by SUSv3">Table 32-1</a>
                <span class="emphasis"><em>must</em></span> be cancellation points if they are provided by an
                implementation. Most of these are functions that are capable of blocking the thread
                for an indefinite period of time.</p><div class="table"><a id="functions_required_to_be_cancellation_po"/><div class="table-title">Table 32-1. Functions required to be cancellation points by SUSv3</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>accept()</em></span>
                                    <a id="IDX-CHP-32-4728" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>aio_suspend()</em></span>
                                    <a id="IDX-CHP-32-4729" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>clock_nanosleep()</em></span>
                                    <a id="IDX-CHP-32-4730" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>close()</em></span>
                                </p>
                                <p>
                                    <span class="emphasis"><em>connect()</em></span>
                                    <a id="IDX-CHP-32-4731" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>creat()</em></span>
                                    <a id="IDX-CHP-32-4732" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>fcntl(F_SETLKW)</em></span>
                                </p>
                                <p>
                                    <span class="emphasis"><em>fsync()</em></span>
                                    <a id="IDX-CHP-32-4733" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>fdatasync()</em></span>
                                    <a id="IDX-CHP-32-4734" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>getmsg()</em></span>
                                    <a id="IDX-CHP-32-4735" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>getpmsg()</em></span>
                                    <a id="IDX-CHP-32-4736" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>lockf(F_LOCK)</em></span>
                                </p>
                                <p>
                                    <span class="emphasis"><em>mq_receive()</em></span>
                                    <a id="IDX-CHP-32-4737" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>mq_send()</em></span>
                                    <a id="IDX-CHP-32-4738" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>mq_timedreceive()</em></span>
                                    <a id="IDX-CHP-32-4739" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>mq_timedsend()</em></span>
                                    <a id="IDX-CHP-32-4740" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>msgrcv()</em></span>
                                    <a id="IDX-CHP-32-4741" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>msgsnd()</em></span>
                                    <a id="IDX-CHP-32-4742" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>msync()</em></span>
                                    <a id="IDX-CHP-32-4743" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>nanosleep()</em></span>
                                    <a id="IDX-CHP-32-4744" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>open()</em></span>
                                    <a id="IDX-CHP-32-4745" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>pause()</em></span>
                                    <a id="IDX-CHP-32-4746" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>poll()</em></span>
                                    <a id="IDX-CHP-32-4747" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>pread()</em></span>
                                    <a id="IDX-CHP-32-4748" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>pselect()</em></span>
                                    <a id="IDX-CHP-32-4749" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>pthread_cond_timedwait()</em></span>
                                    <a id="IDX-CHP-32-4750" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>pthread_cond_wait()</em></span>
                                    <a id="IDX-CHP-32-4751" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>pthread_join()</em></span>
                                    <a id="IDX-CHP-32-4752" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>pthread_testcancel()</em></span>
                                    <a id="IDX-CHP-32-4753" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>putmsg()</em></span>
                                    <a id="IDX-CHP-32-4754" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>putpmsg()</em></span>
                                    <a id="IDX-CHP-32-4755" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>pwrite()</em></span>
                                    <a id="IDX-CHP-32-4756" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>read()</em></span>
                                    <a id="IDX-CHP-32-4757" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>readv()</em></span>
                                    <a id="IDX-CHP-32-4758" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>recv()</em></span>
                                    <a id="IDX-CHP-32-4759" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>recvfrom()</em></span>
                                    <a id="IDX-CHP-32-4760" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>recvmsg()</em></span>
                                    <a id="IDX-CHP-32-4761" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>select()</em></span>
                                    <a id="IDX-CHP-32-4762" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>
                                    <span class="emphasis"><em>sem_timedwait()</em></span>
                                    <a id="IDX-CHP-32-4763" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sem_wait()</em></span>
                                    <a id="IDX-CHP-32-4764" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>send()</em></span>
                                    <a id="IDX-CHP-32-4765" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sendmsg()</em></span>
                                    <a id="IDX-CHP-32-4766" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sendto()</em></span>
                                    <a id="IDX-CHP-32-4767" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sigpause()</em></span>
                                    <a id="IDX-CHP-32-4768" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sigsuspend()</em></span>
                                    <a id="IDX-CHP-32-4769" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sigtimedwait()</em></span>
                                    <a id="IDX-CHP-32-4770" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sigwait()</em></span>
                                    <a id="IDX-CHP-32-4771" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sigwaitinfo()</em></span>
                                    <a id="IDX-CHP-32-4772" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>sleep()</em></span>
                                    <a id="IDX-CHP-32-4773" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>system()</em></span>
                                    <a id="IDX-CHP-32-4774" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>tcdrain()</em></span>
                                    <a id="IDX-CHP-32-4775" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>usleep()</em></span>
                                    <a id="IDX-CHP-32-4776" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>wait()</em></span>
                                    <a id="IDX-CHP-32-4777" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>waitid()</em></span>
                                    <a id="IDX-CHP-32-4778" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>waitpid()</em></span>
                                    <a id="IDX-CHP-32-4779" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>write()</em></span>
                                    <a id="IDX-CHP-32-4780" class="indexterm"/>
                                </p>
                                <p>
                                    <span class="emphasis"><em>writev()</em></span>
                                    <a id="IDX-CHP-32-4781" class="indexterm"/>
                                </p>
                            </td></tr></tbody></table></div></div><p>In addition to the functions in <a class="xref" href="ch32.html#functions_required_to_be_cancellation_po" title="Table 32-1. Functions required to be cancellation points by SUSv3">Table 32-1</a>, SUSv3 specifies a larger
                group of functions that an implementation <span class="emphasis"><em>may</em></span> define as
                cancellation points. These include the <span class="emphasis"><em>stdio</em></span> functions, the
                    <span class="emphasis"><em>dlopen</em></span> API, the <span class="emphasis"><em>syslog</em></span> API,
                    <span class="emphasis"><em>nftw()</em></span>, <span class="emphasis"><em>popen()</em></span>,
                    <span class="emphasis"><em>semop()</em></span>, <span class="emphasis"><em>unlink()</em></span>, and various
                functions that retrieve information from system files such as the
                    <span class="emphasis"><em>utmp</em></span> file. A portable program must correctly handle the
                possibility that a thread may be canceled when calling these functions.</p><p>SUSv3 specifies that aside from the two lists of functions that must and may be
                cancellation points, none of the other functions in the standard may act as
                cancellation points (i.e., a portable program doesn’t need to handle the possibility
                that calling these other functions could precipitate thread cancellation).</p><p>SUSv4 adds <span class="emphasis"><em>openat()</em></span> to the list of functions that must be
                cancellation points, and removes <span class="emphasis"><em>sigpause()</em></span> (it moves to the
                list of functions that <span class="emphasis"><em>may</em></span> be cancellation points) and
                    <span class="emphasis"><em>usleep()</em></span> (which is dropped from the standard).<a id="IDX-CHP-32-4782" class="indexterm"/><a id="IDX-CHP-32-4783" class="indexterm"/><a id="IDX-CHP-32-4784" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>An implementation is free to mark additional functions that are not specified
                    in the standard as cancellation points. Any function that might block (perhaps
                    because it might access a file) is a likely candidate to be a cancellation
                    point. Within <span class="emphasis"><em>glibc</em></span>, many nonstandard functions are marked
                    as cancellation points for this reason.</p></div><p>Upon receiving a cancellation request, a thread whose cancelability is enabled and
                deferred terminates when it next reaches a cancellation point. If the thread was not
                detached, then some other thread in the process must join with it, in order to
                prevent it from becoming a zombie thread. When a canceled thread is joined, the
                value returned in the second argument to <span class="emphasis"><em>pthread_join()</em></span> is a
                special thread return value: <code class="literal">PTHREAD_CANCELED</code>.<a id="IDX-CHP-32-4785" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_program-id43"/></div></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id44">Example program</h4></div></div></div><p><a class="xref" href="ch32.html#canceling_a_thread_with_pthread_undersco" title="Example 32-1. Canceling a thread with pthread_cancel()">Example 32-1</a> shows a simple
                        example of the use of <span class="emphasis"><em>pthread_cancel()</em></span>. The main
                        program creates a thread that executes an infinite loop, sleeping for a
                        second and printing the value of a loop counter. (This thread will terminate
                        only if it is sent a cancellation request or if the process exits.)
                        Meanwhile, the main program sleeps for 3 seconds, and then sends a
                        cancellation request to the thread that it created. When we run this
                        program, we see the following:<a id="IDX-CHP-32-4786" class="indexterm"/><a id="IDX-CHP-32-4787" class="indexterm"/></p><a id="I_programlisting32_d1e90386"/><pre class="programlisting">$ <strong class="userinput"><code>./t_pthread_cancel</code></strong>
New thread started
Loop 1
Loop 2
Loop 3
Thread was canceled</pre><div class="example"><a id="canceling_a_thread_with_pthread_undersco"/><div class="example-title">Example 32-1. Canceling a thread with <span class="emphasis"><em>pthread_cancel()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>threads/thread_cancel.c</code></strong>
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"

static void *
threadFunc(void *arg)
{
    int j;
    printf("New thread started\n");     /* May be a cancellation point */
    for (j = 1; ; j++) {
        printf("Loop %d\n", j);         /* May be a cancellation point */
        sleep(1);                       /* A cancellation point */
    }

    /* NOTREACHED */
    return NULL;
}

int
main(int argc, char *argv[])
{
    pthread_t thr;
    int s;
    void *res;

    s = pthread_create(&amp;thr, NULL, threadFunc, NULL);
    if (s != 0)
        errExitEN(s, "pthread_create");

    sleep(3);                           /* Allow new thread to run a while */

    s = pthread_cancel(thr);
    if (s != 0)
        errExitEN(s, "pthread_cancel");

    s = pthread_join(thr, &amp;res);
    if (s != 0)
        errExitEN(s, "pthread_join");

    if (res == PTHREAD_CANCELED)
        printf("Thread was canceled\n");
    else
        printf("Thread was not canceled (should not happen!)\n");

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>threads/thread_cancel.c</code></strong></pre></div></div></div></div></div><div class="sect1" title="Testing for Thread Cancellation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="testing_for_thread_cancellation">Testing for Thread Cancellation</h2></div></div></div><p>In <a class="xref" href="ch32.html#canceling_a_thread_with_pthread_undersco" title="Example 32-1. Canceling a thread with pthread_cancel()">Example 32-1</a>, the thread created
                by <span class="emphasis"><em>main()</em></span> accepted the cancellation request because it executed
                a function that was a cancellation point (<span class="emphasis"><em>sleep()</em></span> is a
                cancellation point; <span class="emphasis"><em>printf()</em></span> may be one). However, suppose a
                thread executes a loop that contains no cancellation points (e.g., a compute-bound
                loop). In this case, the thread would never honor the cancellation
                    request.<a id="IDX-CHP-32-4788" class="indexterm"/><a id="IDX-CHP-32-4789" class="indexterm"/><a id="IDX-CHP-32-4790" class="indexterm"/><a id="IDX-CHP-32-4791" class="indexterm"/><a id="IDX-CHP-32-4792" class="indexterm"/></p><p>The purpose of <span class="emphasis"><em>pthread_testcancel()</em></span> is simply to be a
                cancellation point. If a cancellation is pending when this function is called, then
                the calling thread is terminated.<a id="IDX-CHP-32-4793" class="indexterm"/></p><a id="I_programlisting32_d1e90462"/><pre class="programlisting">#include &lt;pthread.h&gt;

void <strong class="userinput"><code>pthread_testcancel</code></strong>(void);</pre><p>A thread that is executing code that does not otherwise include cancellation
                points can periodically call <span class="emphasis"><em>pthread_testcancel()</em></span> to ensure
                that it responds in a timely fashion to a cancellation request sent by another
                thread.</p></div><div class="sect1" title="Cleanup Handlers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="cleanup_handlers">Cleanup Handlers</h2></div></div></div><p>If a thread with a pending cancellation were simply terminated when it reached a
                cancellation point, then shared variables and Pthreads objects (e.g., mutexes) might
                be left in an inconsistent state, perhaps causing the remaining threads in the
                process to produce incorrect results, deadlock, or crash. To get around this
                problem, a thread can establish one or more <span class="emphasis"><em>cleanup
                handlers</em></span>—functions that are automatically executed if the thread is
                canceled. A cleanup handler can perform tasks such as modifying the values of global
                variables and unlocking mutexes before the thread is terminated.<a id="IDX-CHP-32-4794" class="indexterm"/><a id="IDX-CHP-32-4795" class="indexterm"/><a id="IDX-CHP-32-4796" class="indexterm"/><a id="IDX-CHP-32-4797" class="indexterm"/><a id="IDX-CHP-32-4798" class="indexterm"/></p><p>Each thread can have a stack of cleanup handlers. When a thread is canceled, the
                cleanup handlers are executed working down from the top of the stack; that is, the
                most recently established handler is called first, then the next most recently
                established, and so on. When all of the cleanup handlers have been executed, the
                thread terminates.</p><p>The <span class="emphasis"><em>pthread_cleanup_push()</em></span> and
                    <span class="emphasis"><em>pthread_cleanup_pop()</em></span> functions respectively add and remove
                handlers on the calling thread’s stack of cleanup handlers.<a id="IDX-CHP-32-4799" class="indexterm"/><a id="IDX-CHP-32-4800" class="indexterm"/></p><a id="I_programlisting32_d1e90527"/><pre class="programlisting">#include &lt;pthread.h&gt;

void <strong class="userinput"><code>pthread_cleanup_push</code></strong>(void (*<span class="emphasis"><em>routine</em></span>)(void*), void *<span class="emphasis"><em>arg</em></span>);
void <strong class="userinput"><code>pthread_cleanup_pop</code></strong>(int <span class="emphasis"><em>execute</em></span>);</pre><p>The <span class="emphasis"><em>pthread_cleanup_push()</em></span> function adds the function whose
                address is specified in <span class="emphasis"><em>routine</em></span> to the top of the calling
                thread’s stack of cleanup handlers. The <span class="emphasis"><em>routine</em></span> argument is a
                pointer to a function that has the following form:</p><a id="I_programlisting32_d1e90555"/><pre class="programlisting">void
routine(void *arg)
{
    /* Code to perform cleanup */
}</pre><p>The <span class="emphasis"><em>arg</em></span> value given to
                    <span class="emphasis"><em>pthread_cleanup_push()</em></span> is passed as the argument of the
                cleanup handler when it is invoked. This argument is typed as <span class="emphasis"><em>void
                    *</em></span>, but, using judicious casting, other data types can be passed in
                this argument.</p><p>Typically, a cleanup action is needed only if a thread is canceled during the
                execution of a particular section of code. If the thread reaches the end of that
                section without being canceled, then the cleanup action is no longer required. Thus,
                each call to <span class="emphasis"><em>pthread_cleanup_push()</em></span> has an accompanying call to
                    <span class="emphasis"><em>pthread_cleanup_pop()</em></span>. This function removes the topmost
                function from the stack of cleanup handlers. If the <span class="emphasis"><em>execute</em></span>
                argument is nonzero, the handler is also executed. This is convenient if we want to
                perform the cleanup action even if the thread was not canceled.</p><p>Although we have described <span class="emphasis"><em>pthread_cleanup_push()</em></span> and
                    <span class="emphasis"><em>pthread_cleanup_pop()</em></span> as functions, SUSv3 permits them to
                be implemented as macros that expand to statement sequences that include an opening
                    (<code class="literal">{</code>) and closing (<code class="literal">}</code>) brace, respectively. Not all UNIX implementations do things this
                way, but Linux and many others do. This means that each use of
                    <span class="emphasis"><em>pthread_cleanup_push()</em></span> must be paired with exactly one
                corresponding <span class="emphasis"><em>pthread_cleanup_pop()</em></span> in the same lexical block.
                (On implementations that do things this way, variables declared between the
                    <span class="emphasis"><em>pthread_cleanup_push()</em></span> and
                    <span class="emphasis"><em>pthread_cleanup_pop()</em></span> will be limited to that lexical
                scope.) For example, it is not correct to write code such as the following:</p><a id="I_programlisting32_d1e90606"/><pre class="programlisting">pthread_cleanup_push(func, arg);
...
if (cond) {
    pthread_cleanup_pop(0);
}</pre><p>As a coding convenience, any cleanup handlers that have not been popped are also
                executed automatically if a thread terminates by calling
                    <span class="emphasis"><em>pthread_exit()</em></span> (but not if it does a simple <code class="literal">return</code>).</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_program-id45"/></div></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id46">Example program</h4></div></div></div><p>The program in <a class="xref" href="ch32.html#using_cleanup_handlers" title="Example 32-2. Using cleanup handlers">Example 32-2</a> provides a simple
                        example of the use of a cleanup handler. The main program creates a thread
                            <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90626"/><img src="figs/web/U008.png" alt=""/></span> whose first actions are to allocate a block of memory
                            <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90632"/><img src="figs/web/U003.png" alt=""/></span> whose location is stored in <span class="emphasis"><em>buf</em></span>,
                        and then lock the mutex <span class="emphasis"><em>mtx</em></span>
                        <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90645"/><img src="figs/web/U004.png" alt=""/></span>. Since the thread may be canceled, it uses
                            <span class="emphasis"><em>pthread_cleanup_push()</em></span>
                        <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90654"/><img src="figs/web/U005.png" alt=""/></span> to install a cleanup handler that is called with the
                        address stored in <span class="emphasis"><em>buf</em></span>. If it is invoked, the cleanup
                        handler deallocates the freed memory <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90663"/><img src="figs/web/U001.png" alt=""/></span> and unlocks the mutex <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90669"/><img src="figs/web/U002.png" alt=""/></span>.<a id="IDX-CHP-32-4801" class="indexterm"/><a id="IDX-CHP-32-4802" class="indexterm"/><a id="IDX-CHP-32-4803" class="indexterm"/></p><p>The thread then enters a loop waiting for the condition variable
                            <span class="emphasis"><em>cond</em></span> to be signaled <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90699"/><img src="figs/web/U006.png" alt=""/></span>. This loop will terminate in one of two ways, depending
                        on whether the program is supplied with a command-line argument:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If no command-line argument is supplied, the thread is canceled by
                                    <span class="emphasis"><em>main()</em></span>
                                <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90712"/><img src="figs/web/U009.png" alt=""/></span>. In this case, cancellation will occur at the
                                call to <span class="emphasis"><em>pthread_cond_wait()</em></span>
                                <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90721"/><img src="figs/web/U006.png" alt=""/></span>, which is one of the cancellation points shown
                                in <a class="xref" href="ch32.html#functions_required_to_be_cancellation_po" title="Table 32-1. Functions required to be cancellation points by SUSv3">Table 32-1</a>. As
                                part of cancellation, the cleanup handler established using
                                    <span class="emphasis"><em>pthread_cleanup_push()</em></span> is invoked
                                automatically.</p></li><li class="listitem"><p>If a command-line argument is supplied, the condition variable is
                                signaled <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90736"/><img src="figs/web/U010.png" alt=""/></span> after the associated global variable,
                                    <span class="emphasis"><em>glob</em></span>, is first set to a nonzero value. In
                                this case, the thread falls through to execute
                                    <span class="emphasis"><em>pthread_cleanup_pop()</em></span>
                                <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90748"/><img src="figs/web/U007.png" alt=""/></span>, which, given a nonzero argument, also causes
                                the cleanup handler to be invoked.</p></li></ul></div><p>The main program joins with the terminated thread <span class="inlinemediaobject"><a id="I_inlinemediaobject32_d1e90756"/><img src="figs/web/U011.png" alt=""/></span>, and reports whether the thread was canceled or
                        terminated normally.</p><div class="example"><a id="using_cleanup_handlers"/><div class="example-title">Example 32-2. Using cleanup handlers</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>threads/thread_cleanup.c</code></strong>
    #include &lt;pthread.h&gt;
    #include "tlpi_hdr.h"

    static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    static int glob = 0;                    /* Predicate variable */

    static void     /* Free memory pointed to by 'arg' and unlock mutex */
    cleanupHandler(void *arg)
    {
        int s;

        printf("cleanup: freeing block at %p\n", arg);
<img src="figs/web/U001.png" alt=""/>    free(arg);

        printf("cleanup: unlocking mutex\n");
<img src="figs/web/U002.png" alt=""/>    s = pthread_mutex_unlock(&amp;mtx);
        if (s != 0)
            errExitEN(s, "pthread_mutex_unlock");
    }

    static void *
    threadFunc(void *arg)
    {
        int s;
        void *buf = NULL;                   /* Buffer allocated by thread */

<img src="figs/web/U003.png" alt=""/>    buf = malloc(0x10000);              /* Not a cancellation point */
        printf("thread:  allocated memory at %p\n", buf);

<img src="figs/web/U004.png" alt=""/>    s = pthread_mutex_lock(&amp;mtx);       /* Not a cancellation point */
        if (s != 0)
            errExitEN(s, "pthread_mutex_lock");

<img src="figs/web/U005.png" alt=""/>    pthread_cleanup_push(cleanupHandler, buf);

        while (glob == 0) {
<img src="figs/web/U006.png" alt=""/>        s = pthread_cond_wait(&amp;cond, &amp;mtx);    /* A cancellation point */
            if (s != 0)
                errExitEN(s, "pthread_cond_wait");
        }

        printf("thread:  condition wait loop completed\n");
<img src="figs/web/U007.png" alt=""/>    pthread_cleanup_pop(1);             /* Executes cleanup handler */
        return NULL;
    }

    int
    main(int argc, char *argv[])
    {
        pthread_t thr;
        void *res;
        int s;

    <img src="figs/web/U008.png" alt=""/>    s = pthread_create(&amp;thr, NULL, threadFunc, NULL);
        if (s != 0)
            errExitEN(s, "pthread_create");

        sleep(2);                   /* Give thread a chance to get started */

        if (argc == 1) {            /* Cancel thread */
            printf("main:    about to cancel thread\n");
<img src="figs/web/U009.png" alt=""/>        s = pthread_cancel(thr);
            if (s != 0)
                errExitEN(s, "pthread_cancel");

        } else {                    /* Signal condition variable */
            printf("main:    about to signal condition variable\n");
            glob = 1;
<img src="figs/web/U010.png" alt=""/>        s = pthread_cond_signal(&amp;cond);
            if (s != 0)
                errExitEN(s, "pthread_cond_signal");
        }

<img src="figs/web/U011.png" alt=""/>    s = pthread_join(thr, &amp;res);
        if (s != 0)
            errExitEN(s, "pthread_join");
        if (res == PTHREAD_CANCELED)
            printf("main:    thread was canceled\n");
        else
            printf("main:    thread terminated normally\n");

        exit(EXIT_SUCCESS);
    }
          <strong class="userinput"><code>threads/thread_cleanup.c</code></strong></pre></div></div><p>If we invoke the program in <a class="xref" href="ch32.html#using_cleanup_handlers" title="Example 32-2. Using cleanup handlers">Example 32-2</a>
                        without any command-line arguments, then <span class="emphasis"><em>main()</em></span> calls
                            <span class="emphasis"><em>pthread_cancel()</em></span>, the cleanup handler is invoked
                        automatically, and we see the following:</p><a id="I_programlisting32_d1e90849"/><pre class="programlisting">$ .<strong class="userinput"><code>/thread_cleanup</code></strong>
thread:  allocated memory at 0x804b050
main:    about to cancel thread
cleanup: freeing block at 0x804b050
cleanup: unlocking mutex
main:    thread was canceled</pre><p>If we invoke the program with a command-line argument, then
                            <span class="emphasis"><em>main()</em></span> sets <span class="emphasis"><em>glob</em></span> to 1 and
                        signals the condition variable, the cleanup handler is invoked by
                            <span class="emphasis"><em>pthread_cleanup_pop()</em></span>, and we see the
                        following:</p><a id="I_programlisting32_d1e90865"/><pre class="programlisting">$ <strong class="userinput"><code>./thread_cleanup s</code></strong>
thread:  allocated memory at 0x804b050
main:    about to signal condition variable
thread:  condition wait loop completed
cleanup: freeing block at 0x804b050
cleanup: unlocking mutex
main:    thread terminated normally</pre></div></div></div><div class="sect1" title="Asynchronous Cancelability"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="asynchronous_cancelability">Asynchronous Cancelability</h2></div></div></div><p>When a thread is made asynchronously cancelable (cancelability type <code class="literal">PTHREAD_CANCEL_ASYNCHRONOUS</code>), it may be canceled at
                any time (i.e., at any machine-language instruction); delivery of a cancellation is
                not held off until the thread next reaches a cancellation point.</p><p>The problem with asynchronous cancellation is that, although cleanup handlers are
                still invoked, the handlers have no way of determining the state of a thread. In the
                program in <a class="xref" href="ch32.html#using_cleanup_handlers" title="Example 32-2. Using cleanup handlers">Example 32-2</a>, which employs the deferred
                cancelability type, the thread can be canceled only when it executes the call to
                    <span class="emphasis"><em>pthread_cond_wait()</em></span>, which is the only cancellation point.
                By this time, we know that <span class="emphasis"><em>buf</em></span> has been initialized to point to
                a block of allocated memory and that the mutex <span class="emphasis"><em>mtx</em></span> has been
                locked. However, with asynchronous cancelability, the thread could be canceled at
                any point; for example, before the <span class="emphasis"><em>malloc()</em></span> call, between the
                    <span class="emphasis"><em>malloc()</em></span> call and locking the mutex, or after locking the
                mutex. The cleanup handler has no way of knowing where cancellation has occurred, or
                precisely which cleanup steps are required. Furthermore, the thread might even be
                canceled <span class="emphasis"><em>during</em></span> the <span class="emphasis"><em>malloc()</em></span> call, after
                which chaos is likely to result (<a class="xref" href="ch07.html#implementation_of_malloc_open_parenthesi" title="Implementation of malloc() and free()">Implementation of <span class="emphasis"><em>malloc()</em></span> and
                        <span class="emphasis"><em>free()</em></span></a>).<a id="IDX-CHP-32-4804" class="indexterm"/></p><p>As a general principle, an asynchronously cancelable thread can’t allocate any
                resources or acquire any mutexes, semaphores, or locks. This precludes the use of a
                wide range of library functions, including most of the Pthreads functions. (SUSv3
                makes exceptions for <span class="emphasis"><em>pthread_cancel()</em></span>,
                    <span class="emphasis"><em>pthread_setcancelstate()</em></span>, and
                    <span class="emphasis"><em>pthread_setcanceltype()</em></span>, which are explicitly required to
                be <span class="emphasis"><em>async-cancel-safe</em></span>; that is, an implementation must make them
                safe to call from a thread that is asynchronously cancelable.) In other words, there
                are few circumstances where asynchronous cancellation is useful. One such
                circumstance is canceling a thread that is in a compute-bound loop.<a id="IDX-CHP-32-4805" class="indexterm"/><a id="IDX-CHP-32-4806" class="indexterm"/><a id="IDX-CHP-32-4807" class="indexterm"/></p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id31">Summary</h2></div></div></div><p>The <span class="emphasis"><em>pthread_cancel()</em></span> function allows one thread to send
                another thread a cancellation request, which is a request that the target thread
                should terminate.<a id="IDX-CHP-32-4808" class="indexterm"/><a id="IDX-CHP-32-4809" class="indexterm"/></p><p>How the target thread reacts to this request is determined by its cancelability
                state and type. If the cancelability state is currently set to disabled, the request
                will remain pending until the cancelability state is set to enabled. If
                cancelability is enabled, the cancelability type determines when the target thread
                reacts to the request. If the type is deferred, the cancellation occurs when the
                thread next calls one of a number of functions specified as cancellation points by
                SUSv3. If the type is asynchronous, cancellation may occur at any time (this is
                rarely useful).</p><p>A thread can establish a stack of cleanup handlers, which are programmer-defined
                functions that are invoked automatically to perform cleanups (e.g., restoring the
                states of shared variables, or unlocking mutexes) if the thread is canceled.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id41"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id42">Further information</h4></div></div></div><p>Refer to the sources of further information listed in <a class="xref" href="ch29.html#summary-id28" title="Summary">Summary</a>.</p></div></div></div></section></body></html>
