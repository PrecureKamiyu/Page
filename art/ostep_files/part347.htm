<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Mutual Exclusion</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part346.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part348.htm">下一个 &gt;</a></p><p class="s27" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Mutual Exclusion</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The final prevention technique would be to avoid the need for mutual exclusion at all. In general, we know this is difficult, because the code we wish to run does indeed have critical sections. So what can we do?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Herlihy had the idea that one could design various data structures to be <b>wait-free </b>[H91]. The idea here is simple: using powerful hardware in- structions, you can build data structures in a manner that does not require explicit locking.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As a simple example, let us assume we have a compare-and-swap in- struction, which as you may recall is an atomic instruction provided by the hardware that does the following:</p><p class="s38" style="padding-top: 7pt;padding-left: 26pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>int CompareAndSwap(int <span class="s39">*</span>address, int expected, int new) {</p><table style="border-collapse:collapse;margin-left:24.06pt" cellspacing="0"><tr style="height:9pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;text-align: center;">2</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:118pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 73%;text-align: left;">if (<span class="s136">*</span>address == expected) {</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">3</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:118pt"><p class="s136" style="padding-left: 10pt;text-indent: 0pt;line-height: 71%;text-align: left;">*<span class="s42">address = new;</span></p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">4</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:118pt"><p class="s42" style="padding-left: 10pt;text-indent: 0pt;line-height: 6pt;text-align: left;">return 1; // success</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;text-align: center;">5</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:118pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">}</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;text-align: center;">6</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:118pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">return 0; // failure</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">7</p></td><td style="width:12pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 6pt;text-align: left;">}</p></td><td style="width:118pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Imagine we now wanted to atomically increment a value by a certain amount. We could do it as follows:</p><p class="s38" style="padding-top: 7pt;padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">1  </span>void AtomicIncrement(int <span class="s39">*</span>value, int amount) {</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">2   <span class="s38">do {</span></p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">3    </span>int old = <span class="s39">*</span>value;</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">4   <span class="s38">} while (CompareAndSwap(value, old, old + amount) == 0);</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Instead of acquiring a lock, doing the update, and then releasing it, we have instead built an approach that repeatedly tries to update the value to the new amount and uses the compare-and-swap to do so. In this manner, no lock is acquired, and no deadlock can arise (though livelock is still a possibility).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let us consider a slightly more complex example: list insertion. Here is code that inserts at the head of a list:</p><p class="s37" style="padding-top: 7pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">void insert(int value) {</span></p><table style="border-collapse:collapse;margin-left:24.0602pt" cellspacing="0"><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;text-align: center;">2</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:152pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">node_t <span class="s136">*</span>n = malloc(sizeof(node_t));</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">3</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:152pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">assert(n != NULL);</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">4</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:152pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">n-&gt;value = value;</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">5</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:152pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">n-&gt;next = head;</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">6</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:152pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">head  = n;</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 5pt;text-align: center;">7</p></td><td style="width:12pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 6pt;text-align: left;">}</p></td><td style="width:152pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This code performs a simple insertion, but if called by multiple threads at the “same time”, has a race condition (see if you can figure out why). Of course, we could solve this by surrounding this code with a lock acquire and release:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">void insert(int value) {</span></p><table style="border-collapse:collapse;margin-left:52.0199pt" cellspacing="0"><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;text-align: center;">2</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">node_t <span class="s136">*</span>n = malloc(sizeof(node_t));</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">3</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">assert(n != NULL);</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">4</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">n-&gt;value = value;</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">5</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">lock(listlock); // begin critical section</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">6</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">n-&gt;next = head;</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">7</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">head  = n;</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">8</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">unlock(listlock); // end of critical section</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 5pt;text-align: center;">9</p></td><td style="width:12pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 6pt;text-align: left;">}</p></td><td style="width:189pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this solution, we are using locks in the traditional manner<span class="s35">1</span>. Instead, let us try to perform this insertion in a wait-free manner simply using the compare-and-swap instruction. Here is one possible approach:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">void insert(int value) {</span></p><table style="border-collapse:collapse;margin-left:52.02pt" cellspacing="0"><tr style="height:9pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;text-align: center;">2</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">node_t <span class="s136">*</span>n = malloc(sizeof(node_t));</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">3</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">assert(n != NULL);</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">4</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">n-&gt;value = value;</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">5</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">do {</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">6</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 10pt;text-indent: 0pt;line-height: 7pt;text-align: left;">n-&gt;next = head;</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">7</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:189pt"><p class="s42" style="padding-left: 2pt;text-indent: 0pt;line-height: 7pt;text-align: left;">} while (CompareAndSwap(&amp;head, n-&gt;next, n));</p></td></tr><tr style="height:8pt"><td style="width:11pt"><p class="s135" style="padding-top: 1pt;padding-right: 3pt;text-indent: 0pt;line-height: 5pt;text-align: center;">8</p></td><td style="width:12pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 6pt;text-align: left;">}</p></td><td style="width:189pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The code here updates the next pointer to point to the current head, and then tries to swap the newly-created node into position as the new head of the list. However, this will fail if some other thread successfully swapped in a new head in the meanwhile, causing this thread to retry again with the new head.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Of course, building a useful list requires more than just a list insert, and not surprisingly building a list that you can insert into, delete from, and perform lookups on in a wait-free manner is non-trivial. Read the rich literature on wait-free synchronization if you find this interesting.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part346.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part348.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
