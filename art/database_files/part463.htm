<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>block 0 genesis block</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part462.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part464.htm">下一个 &gt;</a></p><p class="s462" style="padding-top: 4pt;padding-left: 125pt;text-indent: 0pt;line-height: 108%;text-align: left;">block 0 genesis block</p><p class="s462" style="padding-top: 4pt;padding-left: 48pt;text-indent: 0pt;text-align: center;">block 1                block <span class="s543">n</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 220pt;text-indent: 0pt;text-align: left;">Figure 26.1 <span class="s74">Blockchain data structure.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">This hash-validated pointer format in a blockchain makes tampering with a blockchain hard. To make tampering virtually impossible, it is necessary to ensure that any tampering with the blockchain is easily detected and that the correct version of the blockchain is easily determined. To achieve this, the hash function must have certain mathematical properties that we shall discuss shortly. Further, the chain itself must be replicated and distributed among many independent nodes so that no single node or small group of nodes can tamper with the blockchain. Since the blockchain is repli- cated across multiple nodes, a distributed consensus algorithm needs to be used to maintain agreement regarding the correct current state of the blockchain. In this way, even if some nodes try to tamper with the blockchain contents, as long as a majority are honest, making decisions based on a majority vote can ensure the integrity of the blockchain.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The above approach works if the set of nodes that participates in the blockchain is controlled in some fashion that makes it diﬃcult for an adversary to control a major- ity of the nodes. However, such control goes against the goal of not have any central control, and is viewed as unacceptable in public blockchains such as Bitcoin, which are based on public blockchains in which the number of participating nodes may change continuously. Any computer may download the blockchain and attempt to add blocks (the code for implementing blockchains is available in open source). As a result, a majority-based approach can be overwhelmed by an adversary who sets up a large num- ber of low-cost computers as nodes. Such an attack is called a <span class="s63">Sybil attack</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The way in which consensus is achieved among independent nodes varies among blockchains. The variations address trade-oﬀs between performance (latency and throughput) and robustness to adversarial attacks on the consensus mechanism, in- cluding Sybil attacks. When we addressed distributed consensus in Chapter 23, we assumed that a single organization controlled the entire distributed system, and so the consensus algorithm had to tolerate only possible failures of nodes or the network that were fail-stop, where participants do not behave in an adversarial manner.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In a typical blockchain application, the chain is shared among multiple indepen- dent organizations. In the extreme case, for example Bitcoin, anyone can set up a node and participate, possibly for nefarious purposes. This implies that the types of failure that may occur are not just cases where a device or system stops working, but also cases</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">where a system remains operational but behaves in an adversarial manner. In most en- terprise settings, the blockchain is <span class="s63">permissioned</span>, providing some control over the set of participants, but still without direct controls to prevent malicious behavior.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A node participating in a blockchain fully needs to participate in the consensus mechanism and maintain its own replica of the blockchain. Such a node is called a <span class="s63">full node</span>. In some applications, there is a need for low-cost nodes that submit updates to the blockchain, but do not have the storage or computational power to participate in the consensus process. Such a node is called a <span class="s63">light node</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We discuss blockchain consensus algorithms in detail in Section 26.4. Blockchain consensus algorithms can be placed into one of several broad categories:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>Proof of work: <span class="p">Proof of work, which is described in detail in Section 26.4.1, pro- vides a solution to Sybil attacks by making it very expensive for an attacker to control a majority of the nodes. Speciﬁcally, the nodes agree that the next block on the blockchain will be added by the ﬁrst node to solve a certain hard mathemat- ical problem. This is referred to as </span>mining <span class="p">a block. Proof-of-work algorithms are robust to adversarial behavior as long as the adversary does not control more than half the computing power in the entire network. To ensure this requirement, the problems are made intentionally hard, and require a lot of computational eﬀort. Thus, robustness comes at the price of a huge amount of otherwise useless com- putation along with the price of electricity needed to carry out the computation.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Proof of stake: </span><span class="p">Proof of stake, which is described in Section 26.4.2, provides an- other solution to Sybil attacks. Here, the nodes agree to select the next node to add a block to the blockchain based on an amount of the blockchain’s currency owned or held in reserve by a node.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Byzantine consensus: </span><span class="p">Byzantine consensus does not solve the problem of Sybil at- tacks, but can be used in non-public blockchains, where entry of nodes to the sys- tem can be controlled. While some nodes may behave maliciously, it is assumed that a substantial majority are honest. In Byzantine consensus, described in Sec- tion 26.4.3, the next node to add a block to the blockchain is decided by an algo- rithm from the class of algorithms referred to as Byzantine-consensus algorithms. Like the basic consensus algorithms we described earlier in Section 23.8, these algorithms achieve agreement by message passing, but unlike those algorithms, these algorithms can tolerate some number of nodes being malicious by either dis- rupting consensus or trying to cause an incorrect consensus to be reached. This approach requires signiﬁcantly more messages to be exchanged than in the case of the basic consensus algorithms of Section 26.4.3, but this is a worthwhile trade-oﬀ for the ability for a system to work correctly in the presence of a certain number of malicious nodes.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s46">Other approaches: </span><span class="p">There are several other less widely used consensus mechanisms, some of which are variants of the preceding mechanisms. These include proof of</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;">activity, proof of burn, proof of capacity, and proof of elapsed time. See the Further Reading section at the end of the chapter for details.</p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Another way to damage a blockchain besides attempting to alter blocks is to add a new block to a block other than the most recent one. This is called a <span class="s63">fork</span>. Forking may occur due to malicious activity, but there are two sources of nonmalicious forks:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span>Two distinct nodes may add a new block after the most recent block, but they do it so close together in time that both are added successfully, thus creating a forked chain. These accidental forks are resolved by a protocol rule that nodes always attempt to add blocks to the end of the longest chain. This probabilistically limits these accidental forks to a short length. The blocks on the shorter forks are said to be <i>orphaned</i>, and the contents of those blocks will get inserted on the real chain later if those contents are not already there.</p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span class="p">A majority of blockchain users may agree to fork the blockchain in order to change some aspect of the blockchain protocol or data structure. This is a rare event and one that, when it has occurred in major blockchains, has caused major controversy. Such a fork is said to be a </span>soft fork <span class="p">if prior blocks are not invalidated by the fork. That is, the old version of the blockchain software will recognize blocks from the new version as valid. This permits a gradual transition from the old version of the blockchain software to the new version. In a </span>hard fork<span class="p">, the old version of the blockchain software will deem blocks from the new version to be invalid. After a hard fork, if the old version of the blockchain software remains in use, it will lead to a separate blockchain with diﬀerent contents.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 122pt;text-indent: 0pt;text-align: center;">Because of the possibility of orphaned blocks, it may be necessary to wait for several additional blocks to be added before it is safe to assume s block will not be orphaned.</p><p style="padding-left: 84pt;text-indent: 0pt;text-align: center;">Note 26.1 on page 1258 presents a few examples of notable blockchain forks.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">So far, we have not said much about the actual data in the blocks. The contents of blocks vary by application domain. In a cryptocurrency application, the most com- mon data found in blocks are basic currency-transfer transactions. Since any node can add a block, there needs to be a way to ensure that transactions entered are in fact genuine. This is achieved via a technique called a <span class="s63">digital signature </span>that allows a user to “sign” a transaction and allows every node to verify that signature. This prevents fake transactions from being added to the chain and prevents participants in the transaction from subsequently denying their involvement in the transaction. This latter property is referred to as <span class="s63">irrefutability</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Transactions are broadcast to all nodes participating in the blockchain; when a node adds a block to the chain, the block contains all transactions received by the node that have not already been added to the chain.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The users who submit transactions may be known to the blockchain administrator in a permissioned blockchain, but in a public blockchain like Bitcoin, there is no direct</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="493" height="438" alt="image" src="Image_3465.png"/></span></p><p class="s73" style="padding-left: 59pt;text-indent: 0pt;text-align: center;">Note 26.1 <span class="s146">Blockchain Fork Examples</span></p><p style="padding-top: 2pt;padding-left: 53pt;text-indent: 0pt;text-align: center;">There have been several notable forks of major blockchains. We list a few here.</p><p class="s39" style="padding-top: 9pt;padding-left: 117pt;text-indent: -16pt;text-align: justify;">• <span class="s46">Hard fork: Bitcoin/Bitcoin Cash: </span><span class="p">Bitcoin’s built-in block-size limit was an ac- knowledged problem in the Bitcoin community but agreeing on a solution proved controversial. A hard fork in August 2017 created a new cryptocur- rency, Bitcoin Cash, with a larger block-size limit. Holders of Bitcoin at the time of the fork received an equal amount of Bitcoin Cash, and thus could spend both.</span></p><p style="padding-top: 3pt;padding-left: 117pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Soft fork: Bitcoin SegWit: </b>SegWit (short for segregated witness) moves certain transaction-signature data (referred to as <i>witness </i>data) outside the block. This allows more transactions per block while retaining the existing block size limit. The relocated witness data are needed only for transaction validation. SegWit was introduced in August 2017 via a soft fork. This was a soft fork because the old blocks were recognized as valid and nodes not yet upgraded were able to retain a high degree of compatibility.</p><p class="s39" style="padding-top: 3pt;padding-left: 117pt;text-indent: -16pt;text-align: justify;">• <span class="s46">Hard fork: Ethereum/Ethereum Classic: </span><span class="p">This fork arose from the failure of a crowd-funded venture-capital operation running as a smart contract in the Ethereum blockchain. Its code contained a design ﬂaw that enabled a hack in 2016 that stole ether valued in the tens of millions of U.S. dollars. A controver- sial hard fork refunded the stolen funds, but opponents of the fork, believing in the inviolabilty of blockchain immutability, retained the original blockchain and created Ethereum Classic.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">connection between a user <span class="s44">ID </span>and any real-world entity. This anonymity property is a key feature of Bitcoin, but its value is diminished because of the possibility to tie a user <span class="s44">ID </span>to some oﬀ-chain activity, thereby de-anonymizing the user. De-anonymization can occur if the user enters into a transaction with a user whose user <span class="s44">ID </span>has already been de-anonymized. De-anonymization can occur also via data mining on the blockchain data and correlating on-chain activity by a speciﬁc user <span class="s44">ID </span>with the “real-world” activity of a speciﬁc individual.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Finally, a feature of blockchains is the ability to store executable code, referred to as a <span class="s63">smart contract</span>. A smart contract can implement complex transactions, take action at some point in the future based on speciﬁed conditions, and, more generally, encode a complex agreement among a set of users. Blockchains diﬀer not only in the language used for smart contracts but also in the power of the language used. Many are Turing complete, but some (notably, Bitcoin) have more limited power. We discuss smart contracts, including how and when their code is executed, in Section 26.6.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 137pt;text-indent: 0pt;text-align: justify;"><a name="bookmark563">We summarize this discussion by listing a set of properties of blockchains:</a><span class="s76">2</span><a name="bookmark593">&zwnj;</a></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Decentralization: </span><span class="p">In a public blockchain, control of the blockchain is by majority consensus with no central controlling authority. In a permissioned blockchain, the degree of central control is limited, typically only to access authorization and identity management. All other actions happen in a decentralized manner.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Tamper Resistance: </span><span class="p">Without gaining control over a majority of the blockchain net- work, it is infeasible to change the contents of blocks.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s63">Irrefutability: </span><span class="p">Activity by a user on a blockchain is signed cryptographically by the user. These signatures can be validated easily by anyone and thus prove that the user indeed is responsible for the transaction.</span></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Anonymity: </span>Users of a blockchain have user <span class="s44">ID</span>s that are not tied directly to any personally identifying information, though anonymity may be compromised indi- rectly. Permissioned blockchains may oﬀer only limited anonymity or none at all.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part462.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part464.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
