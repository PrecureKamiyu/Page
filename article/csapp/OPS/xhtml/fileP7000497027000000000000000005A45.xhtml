<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>6.6 Putting It Together: The Impact of Caches on Program Performance</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000005A45" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P700049702700000000000000004419E" data-uri="chapter06.xhtml#P700049702700000000000000004419E" epub:type="title"><span class="pcalibre label pcalibre1">6.6 </span>Putting It Together: The Impact of Caches on Program Performance</h1></header>
<p id="P700049702700000000000000004419F" data-uri="chapter06.xhtml#P700049702700000000000000004419F" class="pcalibre1 pcalibre calibre2">This section wraps up our discussion of the memory hierarchy by studying the impact that caches have on the performance of programs running on real machines.</p>
<section id="P7000497027000000000000000005A48" data-uri="chapter06.xhtml#P7000497027000000000000000005A48" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000441A0" data-uri="chapter06.xhtml#P70004970270000000000000000441A0" epub:type="title"><span class="pcalibre label pcalibre1">6.6.1 </span>The Memory Mountain</h1></header>
<p id="P70004970270000000000000000441A1" data-uri="chapter06.xhtml#P70004970270000000000000000441A1" class="pcalibre1 pcalibre calibre2">The rate that a program reads data from the memory system is called the <i class="calibre5 pcalibre pcalibre1">read throughput</i>, or sometimes the <i class="calibre5 pcalibre pcalibre1">read bandwidth</i>. If a program reads <var class="calibre5 pcalibre pcalibre1">n</var> bytes over a period of <var class="calibre5 pcalibre pcalibre1">s</var> seconds, then the read throughput over that period is <i class="calibre5 pcalibre pcalibre1">n/s</i>, typically expressed in units of megabytes per second (MB/s).</p>
<p id="P70004970270000000000000000441A2" data-uri="chapter06.xhtml#P70004970270000000000000000441A2" class="pcalibre1 pcalibre calibre2">If we were to write a program that issued a sequence of read requests from a tight program loop, then the measured read throughput would give us some insight into the performance of the memory system for that particular sequence of reads. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005A68"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.40</span></a> shows a pair of functions that measure the read throughput for a particular read sequence.</p>
<p id="P70004970270000000000000000441A3" data-uri="chapter06.xhtml#P70004970270000000000000000441A3" class="pcalibre1 pcalibre calibre2">The <code id="P70004970270000000000000000441A4" data-uri="chapter06.xhtml#P70004970270000000000000000441A4" class="pcalibre1 calibre8 pcalibre">test</code> function generates the read sequence by scanning the first <code id="P70004970270000000000000000441A5" data-uri="chapter06.xhtml#P70004970270000000000000000441A5" class="pcalibre1 calibre8 pcalibre">elems</code> elements of an array with a stride of <code id="P70004970270000000000000000441A6" data-uri="chapter06.xhtml#P70004970270000000000000000441A6" class="pcalibre1 calibre8 pcalibre">stride</code>. To increase the available parallelism in the inner loop, it uses 4 Ã— 4 unrolling (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004D16.xhtml#P7000497027000000000000000004D16"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">5.9</span></a>). The <code id="P70004970270000000000000000441A7" data-uri="chapter06.xhtml#P70004970270000000000000000441A7" class="pcalibre1 calibre8 pcalibre">run</code> function is a wrapper that calls the <code id="P70004970270000000000000000441A8" data-uri="chapter06.xhtml#P70004970270000000000000000441A8" class="pcalibre1 calibre8 pcalibre">test</code> function and returns the measured read throughput. The call to the <code id="P70004970270000000000000000441A9" data-uri="chapter06.xhtml#P70004970270000000000000000441A9" class="pcalibre1 calibre8 pcalibre">test</code> function in line 37 warms the cache. The <code id="P70004970270000000000000000441AA" data-uri="chapter06.xhtml#P70004970270000000000000000441AA" class="pcalibre1 calibre8 pcalibre">fcyc2</code> function in line 38 calls the <code id="P70004970270000000000000000441AB" data-uri="chapter06.xhtml#P70004970270000000000000000441AB" class="pcalibre1 calibre8 pcalibre">test</code> function with arguments <code id="P70004970270000000000000000441AC" data-uri="chapter06.xhtml#P70004970270000000000000000441AC" class="pcalibre1 calibre8 pcalibre">elems</code> and estimates the running time of the <code id="P70004970270000000000000000441AD" data-uri="chapter06.xhtml#P70004970270000000000000000441AD" class="pcalibre1 calibre8 pcalibre">test</code> function in CPU cycles. Notice that the <code id="P70004970270000000000000000441AE" data-uri="chapter06.xhtml#P70004970270000000000000000441AE" class="pcalibre1 calibre8 pcalibre">size</code> argument to the <code id="P70004970270000000000000000441AF" data-uri="chapter06.xhtml#P70004970270000000000000000441AF" class="pcalibre1 calibre8 pcalibre">run</code> function is in units of bytes, while the corresponding <code id="P70004970270000000000000000441B0" data-uri="chapter06.xhtml#P70004970270000000000000000441B0" class="pcalibre1 calibre8 pcalibre">elems</code> argument to the <code id="P70004970270000000000000000441B1" data-uri="chapter06.xhtml#P70004970270000000000000000441B1" class="pcalibre1 calibre8 pcalibre">test</code> function is in units of array elements. Also, notice that line 39 computes MB/s as 10<sup class="calibre51 pcalibre pcalibre1">6</sup> bytes/s, as opposed to 2<sup class="calibre51 pcalibre pcalibre1">20</sup> bytes/s.</p>
<p id="P70004970270000000000000000441B2" data-uri="chapter06.xhtml#P70004970270000000000000000441B2" class="pcalibre1 pcalibre calibre2">The <code id="P70004970270000000000000000441B3" data-uri="chapter06.xhtml#P70004970270000000000000000441B3" class="pcalibre1 calibre8 pcalibre">size</code> and <code id="P70004970270000000000000000441B4" data-uri="chapter06.xhtml#P70004970270000000000000000441B4" class="pcalibre1 calibre8 pcalibre">stride</code> arguments to the <code id="P70004970270000000000000000441B5" data-uri="chapter06.xhtml#P70004970270000000000000000441B5" class="pcalibre1 calibre8 pcalibre">run</code> function allow us to control the degree of temporal and spatial locality in the resulting read sequence. Smaller values of <code id="P70004970270000000000000000441B6" data-uri="chapter06.xhtml#P70004970270000000000000000441B6" class="pcalibre1 calibre8 pcalibre">size</code> result in a smaller working set size, and thus better temporal locality. Smaller values of <code id="P70004970270000000000000000441B7" data-uri="chapter06.xhtml#P70004970270000000000000000441B7" class="pcalibre1 calibre8 pcalibre">stride</code> result in better spatial locality. If we call the <code id="P70004970270000000000000000441B8" data-uri="chapter06.xhtml#P70004970270000000000000000441B8" class="pcalibre1 calibre8 pcalibre">run</code> function repeatedly with different values of <code id="P70004970270000000000000000441B9" data-uri="chapter06.xhtml#P70004970270000000000000000441B9" class="pcalibre1 calibre8 pcalibre">size</code> and <code id="P70004970270000000000000000441BA" data-uri="chapter06.xhtml#P70004970270000000000000000441BA" class="pcalibre1 calibre8 pcalibre">stride</code>, then we can recover a fascinating two-dimensional function of read throughput versus temporal and spatial locality. This function is called a <i class="calibre5 pcalibre pcalibre1">memory mountain</i> [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B484">112</a>].</p>
<p id="P70004970270000000000000000441BB" data-uri="chapter06.xhtml#P70004970270000000000000000441BB" class="pcalibre1 pcalibre calibre2">Every computer has a unique memory mountain that characterizes the capabilities of its memory system. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005A75"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.41</span></a> shows the memory mountain for an Intel Core i7 Haswell system. In this example, the <code id="P70004970270000000000000000441BC" data-uri="chapter06.xhtml#P70004970270000000000000000441BC" class="pcalibre1 calibre8 pcalibre">size</code> varies from 16 KB to 128 MB, and the <code id="P70004970270000000000000000441BD" data-uri="chapter06.xhtml#P70004970270000000000000000441BD" class="pcalibre1 calibre8 pcalibre">stride</code> varies from 1 to 12 elements, where each element is an 8-byte <code id="P70004970270000000000000000441BE" data-uri="chapter06.xhtml#P70004970270000000000000000441BE" class="pcalibre1 calibre8 pcalibre">long int.</code></p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000005A68" data-uri="chapter06.xhtml#P7000497027000000000000000005A68">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005A69" title="640" data-uri="chapter06.xhtml#P7000497027000000000000000005A69" epub:type="pagebreak"></span>
<p id="P70004970270000000000000000441BF" data-uri="chapter06.xhtml#P70004970270000000000000000441BF" class="pcalibre1 pcalibre calibre2">-------------------------------------------------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/mountain/mountain.c</i></p>
<pre id="P70004970270000000000000000441C0" data-uri="chapter06.xhtml#P70004970270000000000000000441C0" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000441C1" data-uri="chapter06.xhtml#P70004970270000000000000000441C1" class="calibre10 pcalibre pcalibre1">
1 long data[MAXELEMS];	/* The global array we'll be traversing */
2
3	/* test - Iterate over first "elems" elements of array "data" with
4		* stride of "stride", using 4 x 4 loop unrolling.
5	*/
6	int test(int elems, int stride)
7	{
8		long i, sx2 = stride*2, sx3 = stride*3, sx4 = stride*4;
9		long acc0 = 0, acc1 = 0, acc2 = 0, acc3 = 0;
10		long length = elems;
11		long limit = length - sx4;
12
13		/* Combine 4 elements at a time */
14		for (i = 0; i &lt; limit; i += sx4) {
15			acc0 = acc0 + data[i];
16			acc1 = acc1 + data[i+stride];
17			acc2 = acc2 + data[i+sx2];
18			acc3 = acc3 + data[i+sx3];
19		}
20
21		/* Finish any remaining elements */
22		for (; i &lt; length; i++) {
23			acc0 = acc0 + data[i];
24		}
25		return ((acc0 + acc1) + (acc2 + acc3));
26	}
27
28	/* run - Run test(elems, stride) and return read throughput (MB/s).
29	*	"size" is in bytes, "stride" is in array elements, and Mhz is
30	*	CPU clock frequency in Mhz.
31	*/
32	double run(int size, int stride, double Mhz)
33	{
34		double cycles;
35		int elems = size / sizeof(double);
36
37	test(elems, stride);	/* Warm up the cache */
38	cycles = fcyc2(test, elems, stride, 0);	/* Call test(elems,stride) */
39	return (size / stride) / (cycles / Mhz);	/* Convert cycles to MB/s */
40	}
</code></pre>
<p id="P70004970270000000000000000441C2" data-uri="chapter06.xhtml#P70004970270000000000000000441C2" class="pcalibre1 pcalibre calibre2">-------------------------------------------------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/mountain/mountain.c</i></p>
<figcaption id="P70004970270000000000000000441C3" data-uri="chapter06.xhtml#P70004970270000000000000000441C3" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000441C4" data-uri="chapter06.xhtml#P70004970270000000000000000441C4" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">6.40 </span>Functions that measure and compute read throughput.</h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000441C5" data-uri="chapter06.xhtml#P70004970270000000000000000441C5"><p id="P70004970270000000000000000441C6" data-uri="chapter06.xhtml#P70004970270000000000000000441C6" class="pcalibre calibre3 pcalibre1">We can generate a memory mountain for a particular computer by calling the <code id="P70004970270000000000000000441C7" data-uri="chapter06.xhtml#P70004970270000000000000000441C7" class="pcalibre1 calibre8 pcalibre">run</code> function with different values of <code id="P70004970270000000000000000441C8" data-uri="chapter06.xhtml#P70004970270000000000000000441C8" class="pcalibre1 calibre8 pcalibre">size</code> (which corresponds to temporal locality) and <code id="P70004970270000000000000000441C9" data-uri="chapter06.xhtml#P70004970270000000000000000441C9" class="pcalibre1 calibre8 pcalibre">stride</code> (which corresponds to spatial locality).</p></div></figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000005A75" data-uri="chapter06.xhtml#P7000497027000000000000000005A75">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005A76" title="641" data-uri="chapter06.xhtml#P7000497027000000000000000005A76" epub:type="pagebreak"></span>
<img alt="A graph illustrates a memory mountains." id="P70004970270000000000000000441CA" data-uri="P700049702700000000000000000B74A" src="../images/p641-1.png" class="pcalibre1 calibre222 pcalibre"/>
<figcaption id="P70004970270000000000000000441CB" data-uri="chapter06.xhtml#P70004970270000000000000000441CB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000441CC" data-uri="chapter06.xhtml#P70004970270000000000000000441CC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">6.41 </span>A memory mountain.</h1></header>
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000441CD" data-uri="chapter06.xhtml#P70004970270000000000000000441CD"><p id="P70004970270000000000000000441CE" data-uri="chapter06.xhtml#P70004970270000000000000000441CE" class="pcalibre calibre3 pcalibre1">Shows read throughput as a function of temporal and spatial locality.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000244D3" data-uri="chapter06.xhtml#P70004970270000000000000000244D3">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000441CF" data-uri="chapter06.xhtml#P70004970270000000000000000441CF" class="pcalibre calibre3 pcalibre1">A graph has three axes: Read throughput (MB/s) as the height, Stride (x8 bytes) as the width, and Size (bytes) as the depth. The data is shown for Core I7 Haswell with 2.1 GHz, 32 KB L1 d-cache, 256 KB L2 cache, 8 MB L3 cache, and 64 B block size. The slopes of spatial locality have read throughput decreasing with stride and increasing with size. The ridge of temporal locality are numbered L1, L2, L3, and Mem with read throughput decreasing as size decreases from around size 32 K to around 32 M, from about stride s5 to s11.</p>
</details>
</figcaption>
</figure>
<p id="P70004970270000000000000000441D0" data-uri="chapter06.xhtml#P70004970270000000000000000441D0" class="pcalibre1 pcalibre calibre2">The geography of the Core i7 mountain reveals a rich structure. Perpendicular to the <code id="P70004970270000000000000000441D1" data-uri="chapter06.xhtml#P70004970270000000000000000441D1" class="pcalibre1 calibre8 pcalibre">size</code> axis are four <i class="calibre5 pcalibre pcalibre1">ridges</i> that correspond to the regions of temporal locality where the working set fits entirely in the L1 cache, L2 cache, L3 cache, and main memory, respectively. Notice that there is more than an order of magnitude difference between the highest peak of the L1 ridge, where the CPU reads at a rate of over 14 GB/s, and the lowest point of the main memory ridge, where the CPU reads at a rate of 900 MB/s.</p>
<p id="P70004970270000000000000000441D2" data-uri="chapter06.xhtml#P70004970270000000000000000441D2" class="pcalibre1 pcalibre calibre2">On each of the L2, L3, and main memory ridges, there is a slope of spatial locality that falls downhill as the stride increases and spatial locality decreases. Notice that even when the working set is too large to fit in any of the caches, the highest point on the main memory ridge is a factor of 8 higher than its lowest point. So even when a program has poor temporal locality, spatial locality can still come to the rescue and make a significant difference.</p>
<p id="P70004970270000000000000000441D3" data-uri="chapter06.xhtml#P70004970270000000000000000441D3" class="pcalibre1 pcalibre calibre2">There is a particularly interesting flat ridge line that extends perpendicular to the stride axis for a stride of 1, where the read throughput is a relatively flat 12 GB/s, even though the working set exceeds the capacities of L1 and L2. This is apparently due to a hardware <i class="calibre5 pcalibre pcalibre1">prefetching</i> mechanism in the Core i7 memory system that automatically identifies sequential stride-1 reference patterns and attempts to fetch those blocks into the cache before they are accessed. While the</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000005A80" data-uri="chapter06.xhtml#P7000497027000000000000000005A80">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005A81" title="642" data-uri="chapter06.xhtml#P7000497027000000000000000005A81" epub:type="pagebreak"></span>
<img alt="A graph of read throughput versus working set size is divided into four regions." id="P70004970270000000000000000441D4" data-uri="P700049702700000000000000000B74B" src="../images/p641-2.png" class="calibre223 pcalibre pcalibre1"/>
<figcaption id="P70004970270000000000000000441D5" data-uri="chapter06.xhtml#P70004970270000000000000000441D5" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000441D6" data-uri="chapter06.xhtml#P70004970270000000000000000441D6" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">6.42 </span>Ridges of temporal locality in the memory mountain.</h1></header>
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000441D7" data-uri="chapter06.xhtml#P70004970270000000000000000441D7"><p id="P70004970270000000000000000441D8" data-uri="chapter06.xhtml#P70004970270000000000000000441D8" class="pcalibre calibre3 pcalibre1">The graph shows a slice through <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005A75"><span class="pcalibre label pcalibre1">Figure </span><span class="number pcalibre pcalibre1">6.41</span></a> with <code id="P70004970270000000000000000441D9" data-uri="chapter06.xhtml#P70004970270000000000000000441D9" class="pcalibre1 calibre8 pcalibre">stride</code> = 8.</p></div>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000244DF" data-uri="chapter06.xhtml#P70004970270000000000000000244DF">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000441DA" data-uri="chapter06.xhtml#P70004970270000000000000000441DA" class="pcalibre1 pcalibre calibre2">A graph of read throughput (MB/s) versus working set size (bytes) divided into four regions, as summarized below.</p>
<ul id="P70004970270000000000000000441DB" data-uri="chapter06.xhtml#P70004970270000000000000000441DB" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000441DC" data-uri="chapter06.xhtml#P70004970270000000000000000441DC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000441DD" data-uri="chapter06.xhtml#P70004970270000000000000000441DD" class="pcalibre calibre3 pcalibre1">Main memory region: read throughput increases from around 1,2000 MB/s at 128 M to around 1,500 MB/s at 16 M.</p></li>
<li id="P70004970270000000000000000441DE" data-uri="chapter06.xhtml#P70004970270000000000000000441DE" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000441DF" data-uri="chapter06.xhtml#P70004970270000000000000000441DF" class="pcalibre calibre3 pcalibre1">L3 cache region: read throughput increases from around 1,500 MB/s at 8 M to around 2,500 at 512 K.</p></li>
<li id="P70004970270000000000000000441E0" data-uri="chapter06.xhtml#P70004970270000000000000000441E0" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000441E1" data-uri="chapter06.xhtml#P70004970270000000000000000441E1" class="pcalibre calibre3 pcalibre1">L2 cache region: read throughput increases from nearly 4,000 MB/s at 256 K to nearly 5,000 MB/s at 64 K.</p></li>
<li id="P70004970270000000000000000441E2" data-uri="chapter06.xhtml#P70004970270000000000000000441E2" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000441E3" data-uri="chapter06.xhtml#P70004970270000000000000000441E3" class="pcalibre calibre3 pcalibre1">L1 cache region: read throughput decreases from around 12,500 MB/s at 32 K to nearly 11,000 MB/s at 16 K.</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000441E4" data-uri="chapter06.xhtml#P70004970270000000000000000441E4">details of the particular prefetching algorithm are not documented, it is clear from the memory mountain that the algorithm works best for small stridesâ€”yet another reason to favor sequential stride-1 accesses in your code.</p>
<p id="P70004970270000000000000000441E5" data-uri="chapter06.xhtml#P70004970270000000000000000441E5" class="pcalibre1 pcalibre calibre2">If we take a slice through the mountain, holding the stride constant as in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005A80"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.42</span></a>, we can see the impact of cache size and temporal locality on performance. For sizes up to 32 KB, the working set fits entirely in the L1 d-cache, and thus reads are served from L1 at throughput of about 12 GB/s. For sizes up to 256 KB, the working set fits entirely in the unified L2 cache, and for sizes up to 8 MB, the working set fits entirely in the unified L3 cache. Larger working set sizes are served primarily from main memory.</p>
<p id="P70004970270000000000000000441E6" data-uri="chapter06.xhtml#P70004970270000000000000000441E6" class="pcalibre1 pcalibre calibre2">The dips in read throughputs at the leftmost edges of the L2 and L3 cache regionsâ€”where the working set sizes of 256 KB and 8 MB are equal to their respective cache sizesâ€”are interesting. It is not entirely clear why these dips occur. The only way to be sure is to perform a detailed cache simulation, but it is likely that the drops are caused by conflicts with other code and data lines.</p>
<p id="P70004970270000000000000000441E7" data-uri="chapter06.xhtml#P70004970270000000000000000441E7" class="pcalibre1 pcalibre calibre2">Slicing through the memory mountain in the opposite direction, holding the working set size constant, gives us some insight into the impact of spatial locality on the read throughput. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005A8D"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.43</span></a> shows the slice for a fixed working set size of 4 MB. This slice cuts along the L3 ridge in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005A75"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.41</span></a>, where the working set fits entirely in the L3 cache but is too large for the L2 cache.</p>
<p id="P70004970270000000000000000441E8" data-uri="chapter06.xhtml#P70004970270000000000000000441E8" class="pcalibre1 pcalibre calibre2">Notice how the read throughput decreases steadily as the stride increases from one to eight words. In this region of the mountain, a read miss in L2 causes a block to be transferred from L3 to L2. This is followed by some number of hits</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000005A8D" data-uri="chapter06.xhtml#P7000497027000000000000000005A8D">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005A8E" title="643" data-uri="chapter06.xhtml#P7000497027000000000000000005A8E" epub:type="pagebreak"></span>
<img alt="A graph shows read throughput decreasing with stride, from about 11,500 MB/s at s1 to near 2,000 by s8, with one access per cache line from s8 to s11." id="P70004970270000000000000000441E9" data-uri="P700049702700000000000000000B74C" src="../images/p643-1.png" class="calibre224 pcalibre pcalibre1"/>
<figcaption id="P70004970270000000000000000441EA" data-uri="chapter06.xhtml#P70004970270000000000000000441EA" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000441EB" data-uri="chapter06.xhtml#P70004970270000000000000000441EB" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">6.43 </span>A slope of spatial locality.</h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000441EC" data-uri="chapter06.xhtml#P70004970270000000000000000441EC"><p id="P70004970270000000000000000441ED" data-uri="chapter06.xhtml#P70004970270000000000000000441ED" class="pcalibre calibre3 pcalibre1">The graph shows a slice through <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005A75"><span class="pcalibre label pcalibre1">Figure </span><span class="number pcalibre pcalibre1">6.41</span></a> with <code id="P70004970270000000000000000441EE" data-uri="chapter06.xhtml#P70004970270000000000000000441EE" class="pcalibre1 calibre8 pcalibre">size</code> = 4 MB.</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000441EF" data-uri="chapter06.xhtml#P70004970270000000000000000441EF">on the block in L2, depending on the stride. As the stride increases, the ratio of L2 misses to L2 hits increases. Since misses are served more slowly than hits, the read throughput decreases. Once the stride reaches eight 8-byte words, which on this system equals the block size of 64 bytes, every read request misses in L2 and must be served from L3. Thus, the read throughput for strides of at least eight is a constant rate determined by the rate that cache blocks can be transferred from L3 into L2.</p>
<p id="P70004970270000000000000000441F0" data-uri="chapter06.xhtml#P70004970270000000000000000441F0" class="pcalibre1 pcalibre calibre2">To summarize our discussion of the memory mountain, the performance of the memory system is not characterized by a single number. Instead, it is a mountain of temporal and spatial locality whose elevations can vary by over an order of magnitude. Wise programmers try to structure their programs so that they run in the peaks instead of the valleys. The aim is to exploit temporal locality so that heavily used words are fetched from the L1 cache, and to exploit spatial locality so that as many words as possible are accessed from a single L1 cache line.</p>
<section id="P7000497027000000000000000005A97" data-uri="chapter06.xhtml#P7000497027000000000000000005A97" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000441F1" data-uri="chapter06.xhtml#P70004970270000000000000000441F1" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">6.21 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000005E52.xhtml#P7000497027000000000000000005F85">666</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P70004970270000000000000000441F2" data-uri="chapter06.xhtml#P70004970270000000000000000441F2">
<li class="general-problem pcalibre pcalibre1" id="P70004970270000000000000000441F3" data-uri="chapter06.xhtml#P70004970270000000000000000441F3">
<div class="edition pcalibre pcalibre1" id="P70004970270000000000000000441F4" data-uri="chapter06.xhtml#P70004970270000000000000000441F4"><p id="P70004970270000000000000000441F5" data-uri="chapter06.xhtml#P70004970270000000000000000441F5" class="pcalibre calibre3 pcalibre1">Use the memory mountain in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005A75"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.41</span></a> to estimate the time, in CPU cycles, to read an 8-byte word from the L1 d-cache.</p></div></li>
</ol>
</section>
</section>
<section id="P7000497027000000000000000005A9D" data-uri="chapter06.xhtml#P7000497027000000000000000005A9D" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000441F6" data-uri="chapter06.xhtml#P70004970270000000000000000441F6" epub:type="title"><span class="pcalibre label pcalibre1">6.6.2 </span>Rearranging Loops to Increase Spatial Locality</h1></header>
<p id="P70004970270000000000000000441F7" data-uri="chapter06.xhtml#P70004970270000000000000000441F7" class="pcalibre1 pcalibre calibre2">Consider the problem of multiplying a pair of <var class="calibre5 pcalibre pcalibre1">n</var> Ã— <var class="calibre5 pcalibre pcalibre1">n</var> matrices: <var class="calibre5 pcalibre pcalibre1">C</var> = <i class="calibre5 pcalibre pcalibre1">AB</i>. For example, if <var class="calibre5 pcalibre pcalibre1">n</var> = 2, then</p>
<div class="informalequation pcalibre pcalibre1" id="P70004970270000000000000000441F8" data-uri="chapter06.xhtml#P70004970270000000000000000441F8">
<m:math display="block" alttext="" data-uri="" altimg-width="243" altimg-height="37" altimg="../images/ch06-09.png"><m:mrow><m:mrow><m:mo>[</m:mo> <m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow> <m:mo>]</m:mo></m:mrow><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo> <m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>a</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow> <m:mo>]</m:mo></m:mrow><m:mtext>â€‰</m:mtext><m:mrow><m:mo>[</m:mo> <m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd><m:mtd><m:mrow><m:msub><m:mi>b</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow> <m:mo>]</m:mo></m:mrow></m:mrow></m:math>
</div>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000441F9" data-uri="chapter06.xhtml#P70004970270000000000000000441F9"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005AA2" title="644" data-uri="chapter06.xhtml#P7000497027000000000000000005AA2" epub:type="pagebreak"></span>where</p>
<div class="informalequation pcalibre pcalibre1" id="P70004970270000000000000000441FA" data-uri="chapter06.xhtml#P70004970270000000000000000441FA">
<m:math display="block" alttext="" data-uri="" altimg-width="131" altimg-height="91" altimg="../images/ch06-10.png"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>11</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:msub><m:mi>c</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>21</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>12</m:mn></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mi>a</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub><m:msub><m:mi>b</m:mi><m:mrow><m:mn>22</m:mn></m:mrow></m:msub></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000441FB" data-uri="chapter06.xhtml#P70004970270000000000000000441FB">A matrix multiply function is usually implemented using three nested loops, which are identified by their indices <i class="calibre5 pcalibre pcalibre1">i, j</i>, and <i class="calibre5 pcalibre pcalibre1">k.</i> If we permute the loops and make some other minor code changes, we can create the six functionally equivalent versions of matrix multiply shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AB5"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.44</span></a>. Each version is uniquely identified by the ordering of its loops.</p>
<p id="P70004970270000000000000000441FC" data-uri="chapter06.xhtml#P70004970270000000000000000441FC" class="pcalibre1 pcalibre calibre2">At a high level, the six versions are quite similar. If addition is associative, then each version computes an identical result.<a class="noteref pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" id="r__P7000497027000000000000000005FAE" epub:type="noteref" href="#P7000497027000000000000000005FAE">1</a> Each version performs <var class="calibre5 pcalibre pcalibre1">O</var>(<var class="calibre5 pcalibre pcalibre1">n</var><sup class="calibre51 pcalibre pcalibre1">3</sup>) total operations and an identical number of adds and multiplies. Each of the <var class="calibre5 pcalibre pcalibre1">n</var><sup class="calibre51 pcalibre pcalibre1">2</sup> elements of <var class="calibre5 pcalibre pcalibre1">A</var> and <var class="calibre5 pcalibre pcalibre1">B</var> is read <var class="calibre5 pcalibre pcalibre1">n</var> times. Each of the <var class="calibre5 pcalibre pcalibre1">n</var><sup class="calibre51 pcalibre pcalibre1">2</sup> elements of <var class="calibre5 pcalibre pcalibre1">C</var> is computed by summing <var class="calibre5 pcalibre pcalibre1">n</var> values. However, if we analyze the behavior of the innermost loop iterations, we find that there are differences in the number of accesses and the locality. For the purposes of this analysis, we make the following assumptions:</p><aside class="footnote pcalibre5 pcalibre" id="P7000497027000000000000000005FAE" data-uri="chapter06.xhtml#P7000497027000000000000000005FAE" epub:type="footnote"><p class="pcalibre calibre3 pcalibre1"><span class="pcalibre1 number2 pcalibre"><a href="#r__P7000497027000000000000000005FAE" class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1">1. </a></span>As we learned in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000000279.xhtml#P7000497027000000000000000000279"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre1 number2 pcalibre">2</span></a>, floating-point addition is commutative, but in general not associative. In practice, if the matrices do not mix extremely large values with extremely small ones, as often is true when the matrices store physical properties, then the assumption of associativity is reasonable.</p></aside>
<ul id="P70004970270000000000000000441FD" data-uri="chapter06.xhtml#P70004970270000000000000000441FD" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000441FE" data-uri="chapter06.xhtml#P70004970270000000000000000441FE" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000441FF" data-uri="chapter06.xhtml#P70004970270000000000000000441FF" class="pcalibre calibre3 pcalibre1">Each array is an <var class="calibre5 pcalibre pcalibre1">n</var> Ã— <var class="calibre5 pcalibre pcalibre1">n</var> array of <code id="P7000497027000000000000000044200" data-uri="chapter06.xhtml#P7000497027000000000000000044200" class="pcalibre1 calibre8 pcalibre">double</code>, with <code id="P7000497027000000000000000044201" data-uri="chapter06.xhtml#P7000497027000000000000000044201" class="pcalibre1 calibre8 pcalibre">sizeof(<code id="P7000497027000000000000000044202" data-uri="chapter06.xhtml#P7000497027000000000000000044202" class="calibre10 pcalibre pcalibre1">double</code>) = 8</code>.</p></li>
<li id="P7000497027000000000000000044203" data-uri="chapter06.xhtml#P7000497027000000000000000044203" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044204" data-uri="chapter06.xhtml#P7000497027000000000000000044204" class="pcalibre calibre3 pcalibre1">There is a single cache with a 32-byte block size (<var class="calibre5 pcalibre pcalibre1">B</var> = 32).</p></li>
<li id="P7000497027000000000000000044205" data-uri="chapter06.xhtml#P7000497027000000000000000044205" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044206" data-uri="chapter06.xhtml#P7000497027000000000000000044206" class="pcalibre calibre3 pcalibre1">The array size <var class="calibre5 pcalibre pcalibre1">n</var> is so large that a single matrix row does not fit in the L1 cache.</p></li>
<li id="P7000497027000000000000000044207" data-uri="chapter06.xhtml#P7000497027000000000000000044207" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044208" data-uri="chapter06.xhtml#P7000497027000000000000000044208" class="pcalibre calibre3 pcalibre1">The compiler stores local variables in registers, and thus references to local variables inside loops do not require any load or store instructions.</p></li>
</ul>
<p id="P7000497027000000000000000044209" data-uri="chapter06.xhtml#P7000497027000000000000000044209" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AD9"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.45</span></a> summarizes the results of our inner-loop analysis. Notice that the six versions pair up into three equivalence classes, which we denote by the pair of matrices that are accessed in the inner loop. For example, versions <i class="calibre5 pcalibre pcalibre1">ijk</i> and <i class="calibre5 pcalibre pcalibre1">jik</i> are members of class <i class="calibre5 pcalibre pcalibre1">AB</i> because they reference arrays <var class="calibre5 pcalibre pcalibre1">A</var> and <var class="calibre5 pcalibre pcalibre1">B</var> (but not <var class="calibre5 pcalibre pcalibre1">C</var>) in their innermost loop. For each class, we have counted the number of loads (reads) and stores (writes) in each inner-loop iteration, the number of references to <i class="calibre5 pcalibre pcalibre1">A, B</i>, and <var class="calibre5 pcalibre pcalibre1">C</var> that will miss in the cache in each loop iteration, and the total number of cache misses per iteration.</p>
<p id="P700049702700000000000000004420A" data-uri="chapter06.xhtml#P700049702700000000000000004420A" class="pcalibre1 pcalibre calibre2">The inner loops of the class <i class="calibre5 pcalibre pcalibre1">AB</i> routines (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AB5"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.44(a)</span></a> and <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AB5"><span class="pcalibre label pcalibre1">(b)</span></a>) scan a row of array <var class="calibre5 pcalibre pcalibre1">A</var> with a stride of 1. Since each cache block holds four 8-byte words, the miss rate for <var class="calibre5 pcalibre pcalibre1">A</var> is 0.25 misses per iteration. On the other hand, the inner loop scans a column of <var class="calibre5 pcalibre pcalibre1">B</var> with a stride of <i class="calibre5 pcalibre pcalibre1">n.</i> Since <var class="calibre5 pcalibre pcalibre1">n</var> is large, each access of array <var class="calibre5 pcalibre pcalibre1">B</var> results in a miss, for a total of 1.25 misses per iteration.</p>
<p id="P700049702700000000000000004420B" data-uri="chapter06.xhtml#P700049702700000000000000004420B" class="pcalibre1 pcalibre calibre2">The inner loops in the class <i class="calibre5 pcalibre pcalibre1">AC</i> routines (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AB5"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.44(c)</span></a> and <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AB5"><span class="pcalibre label pcalibre1">(d)</span></a>) have some problems. Each iteration performs two loads and a store (as opposed to the</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000005AB5" data-uri="chapter06.xhtml#P7000497027000000000000000005AB5">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005AB6" title="645" data-uri="chapter06.xhtml#P7000497027000000000000000005AB6" epub:type="pagebreak"></span>
<p id="P700049702700000000000000004420C" data-uri="chapter06.xhtml#P700049702700000000000000004420C" class="pcalibre1 pcalibre calibre2">(a) Version <i class="calibre5 pcalibre pcalibre1">i j k</i></p>
<p id="P700049702700000000000000004420D" data-uri="chapter06.xhtml#P700049702700000000000000004420D" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P700049702700000000000000004420E" data-uri="chapter06.xhtml#P700049702700000000000000004420E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004420F" data-uri="chapter06.xhtml#P700049702700000000000000004420F" class="calibre10 pcalibre pcalibre1">
1	for (i = 0; i &lt; n; i++)
2	for (j = 0; j &lt; n; j++) {
3	sum = 0.0;
4	for (k = 0; k &lt; n; k++)
5	sum += A[i][k]*B[k][j];
6	C[i][j] += sum;
7	}
</code></pre>
<p id="P7000497027000000000000000044210" data-uri="chapter06.xhtml#P7000497027000000000000000044210" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P7000497027000000000000000044211" data-uri="chapter06.xhtml#P7000497027000000000000000044211" class="pcalibre1 pcalibre calibre2">(b) Version <i class="calibre5 pcalibre pcalibre1">jik</i></p>
<p id="P7000497027000000000000000044212" data-uri="chapter06.xhtml#P7000497027000000000000000044212" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P7000497027000000000000000044213" data-uri="chapter06.xhtml#P7000497027000000000000000044213" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044214" data-uri="chapter06.xhtml#P7000497027000000000000000044214" class="calibre10 pcalibre pcalibre1">
1	for (j = 0; j &lt; n; j++)
2	for (i = 0; i &lt; n; i++) {
3	sum = 0.0;
4	for (k = 0; k &lt; n; k++)
5	sum += A[i][k]*B[k][j];
6	C[i][j] += sum;
7	}
</code></pre>
<p id="P7000497027000000000000000044215" data-uri="chapter06.xhtml#P7000497027000000000000000044215" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P7000497027000000000000000044216" data-uri="chapter06.xhtml#P7000497027000000000000000044216" class="pcalibre1 pcalibre calibre2">(c) Version <i class="calibre5 pcalibre pcalibre1">jki</i></p>
<p id="P7000497027000000000000000044217" data-uri="chapter06.xhtml#P7000497027000000000000000044217" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P7000497027000000000000000044218" data-uri="chapter06.xhtml#P7000497027000000000000000044218" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044219" data-uri="chapter06.xhtml#P7000497027000000000000000044219" class="calibre10 pcalibre pcalibre1">
1	for (j = 0; j &lt; n; j++)
2	for (k = 0; k &lt; n; k++) {
3	r = B[k][j];
4	for (i = 0; i &lt; n; i++)
5	C[i][j] += A[i][k]*r;
6	}
</code></pre>
<p id="P700049702700000000000000004421A" data-uri="chapter06.xhtml#P700049702700000000000000004421A" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P700049702700000000000000004421B" data-uri="chapter06.xhtml#P700049702700000000000000004421B" class="pcalibre1 pcalibre calibre2">(d) Version <i class="calibre5 pcalibre pcalibre1">kji</i></p>
<p id="P700049702700000000000000004421C" data-uri="chapter06.xhtml#P700049702700000000000000004421C" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P700049702700000000000000004421D" data-uri="chapter06.xhtml#P700049702700000000000000004421D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004421E" data-uri="chapter06.xhtml#P700049702700000000000000004421E" class="calibre10 pcalibre pcalibre1">
1	for (k = 0; k &lt; n; k++)
2	for (j = 0; j &lt; n; j++) {
3	r = B[k][j];
4	for (i = 0; i &lt; n; i++)
5	C[i][j] += A[i][k]*r;
6	}
</code></pre>
<p id="P700049702700000000000000004421F" data-uri="chapter06.xhtml#P700049702700000000000000004421F" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P7000497027000000000000000044220" data-uri="chapter06.xhtml#P7000497027000000000000000044220" class="pcalibre1 pcalibre calibre2">(e) Version <i class="calibre5 pcalibre pcalibre1">kij</i></p>
<p id="P7000497027000000000000000044221" data-uri="chapter06.xhtml#P7000497027000000000000000044221" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P7000497027000000000000000044222" data-uri="chapter06.xhtml#P7000497027000000000000000044222" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044223" data-uri="chapter06.xhtml#P7000497027000000000000000044223" class="calibre10 pcalibre pcalibre1">
1	for (k = 0; k &lt; n; k++)
2	for (i = 0; i &lt; n; i++) {
3	r = A[i][k];
4	for (j = 0; j &lt; n; j++)
5	C[i][j] += r*B[k][j];
6	}
</code></pre>
<p id="P7000497027000000000000000044224" data-uri="chapter06.xhtml#P7000497027000000000000000044224" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<p id="P7000497027000000000000000044225" data-uri="chapter06.xhtml#P7000497027000000000000000044225" class="pcalibre1 pcalibre calibre2">(f) Version <i class="calibre5 pcalibre pcalibre1">ikj</i></p>
<p id="P7000497027000000000000000044226" data-uri="chapter06.xhtml#P7000497027000000000000000044226" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<pre id="P7000497027000000000000000044227" data-uri="chapter06.xhtml#P7000497027000000000000000044227" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044228" data-uri="chapter06.xhtml#P7000497027000000000000000044228" class="calibre10 pcalibre pcalibre1">
1	for (i = 0; i &lt; n; i++)
2	for (k = 0; k &lt; n; k++) {
3	r = A[i][k];
4	for (j = 0; j &lt; n; j++)
5	C[i][j] += r*B[k][j];
6	}
</code></pre>
<p id="P7000497027000000000000000044229" data-uri="chapter06.xhtml#P7000497027000000000000000044229" class="pcalibre1 pcalibre calibre2">--------------------------------- <i class="calibre5 pcalibre pcalibre1">code/mem/matmult/mm.c</i></p>
<figcaption id="P700049702700000000000000004422A" data-uri="chapter06.xhtml#P700049702700000000000000004422A" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004422B" data-uri="chapter06.xhtml#P700049702700000000000000004422B" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">6.44 </span>Six versions of matrix multiply.</h1></header>
<div class="caption pcalibre pcalibre1" id="P700049702700000000000000004422C" data-uri="chapter06.xhtml#P700049702700000000000000004422C"><p id="P700049702700000000000000004422D" data-uri="chapter06.xhtml#P700049702700000000000000004422D" class="pcalibre calibre3 pcalibre1">Each version is uniquely identified by the ordering of its loops.</p></div></figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000005AD9" data-uri="chapter06.xhtml#P7000497027000000000000000005AD9">
<table id="P700049702700000000000000004422E" data-uri="chapter06.xhtml#P700049702700000000000000004422E" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th rowspan="2" id="P700049702700000000000000004422F" data-uri="chapter06.xhtml#P700049702700000000000000004422F" class="calibre18 pcalibre pcalibre1">Matrix multiply version (class)</th>
<th colspan="6" id="P7000497027000000000000000044230" data-uri="chapter06.xhtml#P7000497027000000000000000044230" class="calibre18 pcalibre pcalibre1">Per iteration</th>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000044231" data-uri="chapter06.xhtml#P7000497027000000000000000044231" class="calibre18 pcalibre pcalibre1">Loads</th>
<th id="P7000497027000000000000000044232" data-uri="chapter06.xhtml#P7000497027000000000000000044232" class="calibre18 pcalibre pcalibre1">Stores</th>
<th id="P7000497027000000000000000044233" data-uri="chapter06.xhtml#P7000497027000000000000000044233" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">A</var> misses</th>
<th id="P7000497027000000000000000044234" data-uri="chapter06.xhtml#P7000497027000000000000000044234" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">B</var> misses</th>
<th id="P7000497027000000000000000044235" data-uri="chapter06.xhtml#P7000497027000000000000000044235" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">C</var> misses</th>
<th id="P7000497027000000000000000044236" data-uri="chapter06.xhtml#P7000497027000000000000000044236" class="calibre18 pcalibre pcalibre1">Total misses</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000044237" data-uri="chapter06.xhtml#P7000497027000000000000000044237" class="calibre20 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">ijk</i> &amp; <i class="calibre5 pcalibre pcalibre1">jik</i> (<i class="calibre5 pcalibre pcalibre1">AB</i>)</td>
<td id="P7000497027000000000000000044238" data-uri="chapter06.xhtml#P7000497027000000000000000044238" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P7000497027000000000000000044239" data-uri="chapter06.xhtml#P7000497027000000000000000044239" class="calibre20 pcalibre pcalibre1">0</td>
<td id="P700049702700000000000000004423A" data-uri="chapter06.xhtml#P700049702700000000000000004423A" class="calibre20 pcalibre pcalibre1">0.25</td>
<td id="P700049702700000000000000004423B" data-uri="chapter06.xhtml#P700049702700000000000000004423B" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P700049702700000000000000004423C" data-uri="chapter06.xhtml#P700049702700000000000000004423C" class="calibre20 pcalibre pcalibre1">0.00</td>
<td id="P700049702700000000000000004423D" data-uri="chapter06.xhtml#P700049702700000000000000004423D" class="calibre20 pcalibre pcalibre1">1.25</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004423E" data-uri="chapter06.xhtml#P700049702700000000000000004423E" class="calibre20 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">jki</i> &amp; <i class="calibre5 pcalibre pcalibre1">kji</i> (<i class="calibre5 pcalibre pcalibre1">AC</i>)</td>
<td id="P700049702700000000000000004423F" data-uri="chapter06.xhtml#P700049702700000000000000004423F" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P7000497027000000000000000044240" data-uri="chapter06.xhtml#P7000497027000000000000000044240" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000044241" data-uri="chapter06.xhtml#P7000497027000000000000000044241" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000044242" data-uri="chapter06.xhtml#P7000497027000000000000000044242" class="calibre20 pcalibre pcalibre1">0.00</td>
<td id="P7000497027000000000000000044243" data-uri="chapter06.xhtml#P7000497027000000000000000044243" class="calibre20 pcalibre pcalibre1">1.00</td>
<td id="P7000497027000000000000000044244" data-uri="chapter06.xhtml#P7000497027000000000000000044244" class="calibre20 pcalibre pcalibre1">2.00</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000044245" data-uri="chapter06.xhtml#P7000497027000000000000000044245" class="calibre20 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">kij</i> &amp; <i class="calibre5 pcalibre pcalibre1">ikj</i> (<i class="calibre5 pcalibre pcalibre1">BC</i>)</td>
<td id="P7000497027000000000000000044246" data-uri="chapter06.xhtml#P7000497027000000000000000044246" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P7000497027000000000000000044247" data-uri="chapter06.xhtml#P7000497027000000000000000044247" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P7000497027000000000000000044248" data-uri="chapter06.xhtml#P7000497027000000000000000044248" class="calibre20 pcalibre pcalibre1">0.00</td>
<td id="P7000497027000000000000000044249" data-uri="chapter06.xhtml#P7000497027000000000000000044249" class="calibre20 pcalibre pcalibre1">0.25</td>
<td id="P700049702700000000000000004424A" data-uri="chapter06.xhtml#P700049702700000000000000004424A" class="calibre20 pcalibre pcalibre1">0.25</td>
<td id="P700049702700000000000000004424B" data-uri="chapter06.xhtml#P700049702700000000000000004424B" class="calibre20 pcalibre pcalibre1">0.50</td>
</tr>
</tbody>
</table>
<figcaption id="P700049702700000000000000004424C" data-uri="chapter06.xhtml#P700049702700000000000000004424C" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004424D" data-uri="chapter06.xhtml#P700049702700000000000000004424D" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">6.45 </span>Analysis of matrix multiply inner loops.</h1></header>
<div class="caption pcalibre pcalibre1" id="P700049702700000000000000004424E" data-uri="chapter06.xhtml#P700049702700000000000000004424E"><p id="P700049702700000000000000004424F" data-uri="chapter06.xhtml#P700049702700000000000000004424F" class="pcalibre calibre3 pcalibre1">The six versions partition into three equivalence classes, denoted by the pair of arrays that are accessed in the inner loop.</p></div></figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000005AFC" data-uri="chapter06.xhtml#P7000497027000000000000000005AFC">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005AFD" title="646" data-uri="chapter06.xhtml#P7000497027000000000000000005AFD" epub:type="pagebreak"></span>
<img alt="A graph of Core I7 matrix multiply performance shows cycles per inner-loop iteration versus array size (n)." id="P7000497027000000000000000044250" data-uri="P700049702700000000000000000B74D" src="../images/p646-1.png" class="calibre225 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000044251" data-uri="chapter06.xhtml#P7000497027000000000000000044251" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000044252" data-uri="chapter06.xhtml#P7000497027000000000000000044252" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">6.46 </span>Core i7 matrix multiply performance.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000024559" data-uri="chapter06.xhtml#P7000497027000000000000000024559">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000044253" data-uri="chapter06.xhtml#P7000497027000000000000000044253" class="pcalibre1 pcalibre calibre2">A graph has six lines plotted with cycles per inner-loop iteration over array size (n), as summarized below.</p>
<ul id="P7000497027000000000000000044254" data-uri="chapter06.xhtml#P7000497027000000000000000044254" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000044255" data-uri="chapter06.xhtml#P7000497027000000000000000044255" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044256" data-uri="chapter06.xhtml#P7000497027000000000000000044256" class="pcalibre calibre3 pcalibre1">Lines jki and kji increase from around 5 cycles from size 50 to size 200 to around 70 cycles by size 700.</p></li>
<li id="P7000497027000000000000000044257" data-uri="chapter06.xhtml#P7000497027000000000000000044257" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044258" data-uri="chapter06.xhtml#P7000497027000000000000000044258" class="pcalibre calibre3 pcalibre1">Lines ijk and jik increase from between 4 and 5 cycles from size 50 to size 400 to around 25 cycles by size 700.</p></li>
<li id="P7000497027000000000000000044259" data-uri="chapter06.xhtml#P7000497027000000000000000044259" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004425A" data-uri="chapter06.xhtml#P700049702700000000000000004425A" class="pcalibre calibre3 pcalibre1">Lines kij and ikj remain around 2 cycles from size 50 to size 700.</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004425B" data-uri="chapter06.xhtml#P700049702700000000000000004425B">class <i class="calibre5 pcalibre pcalibre1">AB</i> routines, which perform two loads and no stores). Second, the inner loop scans the columns of <var class="calibre5 pcalibre pcalibre1">A</var> and <var class="calibre5 pcalibre pcalibre1">C</var> with a stride of <var class="calibre5 pcalibre pcalibre1">n</var>. The result is a miss on each load, for a total of two misses per iteration. Notice that interchanging the loops has decreased the amount of spatial locality compared to the class <i class="calibre5 pcalibre pcalibre1">AB</i> routines.</p>
<p id="P700049702700000000000000004425C" data-uri="chapter06.xhtml#P700049702700000000000000004425C" class="pcalibre1 pcalibre calibre2">The <i class="calibre5 pcalibre pcalibre1">BC</i> routines (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AB5"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.44(e)</span></a> and <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AB5"><span class="pcalibre label pcalibre1">(f)</span></a>) present an interesting trade-off: With two loads and a store, they require one more memory operation than the <i class="calibre5 pcalibre pcalibre1">AB</i> routines. On the other hand, since the inner loop scans both <var class="calibre5 pcalibre pcalibre1">B</var> and <var class="calibre5 pcalibre pcalibre1">C</var> row-wise with a stride-1 access pattern, the miss rate on each array is only 0.25 misses per iteration, for a total of 0.50 misses per iteration.</p>
<p id="P700049702700000000000000004425D" data-uri="chapter06.xhtml#P700049702700000000000000004425D" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005AFC"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">6.46</span></a> summarizes the performance of different versions of matrix multiply on a Core i7 system. The graph plots the measured number of CPU cycles per inner-loop iteration as a function of array size (<var class="calibre5 pcalibre pcalibre1">n</var>).</p>
<p id="P700049702700000000000000004425E" data-uri="chapter06.xhtml#P700049702700000000000000004425E" class="pcalibre1 pcalibre calibre2">There are a number of interesting points to notice about this graph:</p>
<ul id="P700049702700000000000000004425F" data-uri="chapter06.xhtml#P700049702700000000000000004425F" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000044260" data-uri="chapter06.xhtml#P7000497027000000000000000044260" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044261" data-uri="chapter06.xhtml#P7000497027000000000000000044261" class="pcalibre calibre3 pcalibre1">For large values of <var class="calibre5 pcalibre pcalibre1">n</var>, the fastest version runs almost 40 times faster than the slowest version, even though each performs the same number of floating-point arithmetic operations.</p></li>
<li id="P7000497027000000000000000044262" data-uri="chapter06.xhtml#P7000497027000000000000000044262" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044263" data-uri="chapter06.xhtml#P7000497027000000000000000044263" class="pcalibre calibre3 pcalibre1">Pairs of versions with the same number of memory references and misses per iteration have almost identical measured performance.</p></li>
<li id="P7000497027000000000000000044264" data-uri="chapter06.xhtml#P7000497027000000000000000044264" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044265" data-uri="chapter06.xhtml#P7000497027000000000000000044265" class="pcalibre calibre3 pcalibre1">The two versions with the worst memory behavior, in terms of the number of accesses and misses per iteration, run significantly slower than the other four versions, which have fewer misses or fewer accesses, or both.</p></li>
<li id="P7000497027000000000000000044266" data-uri="chapter06.xhtml#P7000497027000000000000000044266" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044267" data-uri="chapter06.xhtml#P7000497027000000000000000044267" class="pcalibre calibre3 pcalibre1">Miss rate, in this case, is a better predictor of performance than the total number of memory accesses. For example, the class <i class="calibre5 pcalibre pcalibre1">BC</i> routines, with 0.5 misses per iteration, perform much better than the class <i class="calibre5 pcalibre pcalibre1">AB</i> routines, with 1.25 misses per iteration, even though the class <i class="calibre5 pcalibre pcalibre1">BC</i> routines perform more</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000005B0E" data-uri="chapter06.xhtml#P7000497027000000000000000005B0E"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000044268" data-uri="chapter06.xhtml#P7000497027000000000000000044268" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000005B10" title="647" data-uri="chapter06.xhtml#P7000497027000000000000000005B10" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Web Aside MEM:BLOCKING </span>Using blocking to increase temporal locality</h1></header>
<p id="P7000497027000000000000000044269" data-uri="chapter06.xhtml#P7000497027000000000000000044269" class="pcalibre calibre3 pcalibre1">There is an interesting technique called <i class="calibre5 pcalibre pcalibre1">blocking</i> that can improve the temporal locality of inner loops. The general idea of blocking is to organize the data structures in a program into large chunks called <i class="calibre5 pcalibre pcalibre1">blocks.</i> (In this context, "block" refers to an application-level chunk of data, <i class="calibre5 pcalibre pcalibre1">not</i> to a cache block.) The program is structured so that it loads a chunk into the L1 cache, does all the reads and writes that it needs to on that chunk, then discards the chunk, loads in the next chunk, and so on.</p>
<p id="P700049702700000000000000004426A" data-uri="chapter06.xhtml#P700049702700000000000000004426A" class="pcalibre1 calibre32 pcalibre">Unlike the simple loop transformations for improving spatial locality, blocking makes the code harder to read and understand. For this reason, it is best suited for optimizing compilers or frequently executed library routines. Blocking does not improve the performance of matrix multiply on the Core i7, because of its sophisticated prefetching hardware. Still, the technique is interesting to study and understand because it is a general concept that can produce big performance gains on systems that don't prefetch.</p>
</aside>
<p class="pcalibre calibre3 pcalibre1" id="P700049702700000000000000004426B" data-uri="chapter06.xhtml#P700049702700000000000000004426B">memory references in the inner loop (two loads and one store) than the class <i class="calibre5 pcalibre pcalibre1">AB</i> routines (two loads).</p></li>
<li id="P700049702700000000000000004426C" data-uri="chapter06.xhtml#P700049702700000000000000004426C" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004426D" data-uri="chapter06.xhtml#P700049702700000000000000004426D" class="pcalibre calibre3 pcalibre1">For large values of <var class="calibre5 pcalibre pcalibre1">n</var>, the performance of the fastest pair of versions (<i class="calibre5 pcalibre pcalibre1">kij</i> and <i class="calibre5 pcalibre pcalibre1">ikj</i>) is constant. Even though the array is much larger than any of the SRAM cache memories, the prefetching hardware is smart enough to recognize the stride-1 access pattern, and fast enough to keep up with memory accesses in the tight inner loop. This is a stunning accomplishment by the Intel engineers who designed this memory system, providing even more incentive for programmers to develop programs with good spatial locality.</p></li>
</ul>
</section>
<section id="P7000497027000000000000000005B16" data-uri="chapter06.xhtml#P7000497027000000000000000005B16" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004426E" data-uri="chapter06.xhtml#P700049702700000000000000004426E" epub:type="title"><span class="pcalibre label pcalibre1">6.6.3 </span>Exploiting Locality in Your Programs</h1></header>
<p id="P700049702700000000000000004426F" data-uri="chapter06.xhtml#P700049702700000000000000004426F" class="pcalibre1 pcalibre calibre2">As we have seen, the memory system is organized as a hierarchy of storage devices, with smaller, faster devices toward the top and larger, slower devices toward the bottom. Because of this hierarchy, the effective rate that a program can access memory locations is not characterized by a single number. Rather, it is a wildly varying function of program locality (what we have dubbed the memory mountain) that can vary by orders of magnitude. Programs with good locality access most of their data from fast cache memories. Programs with poor locality access most of their data from the relatively slow DRAM main memory.</p>
<p id="P7000497027000000000000000044270" data-uri="chapter06.xhtml#P7000497027000000000000000044270" class="pcalibre1 pcalibre calibre2">Programmers who understand the nature of the memory hierarchy can exploit this understanding to write more efficient programs, regardless of the specific memory system organization. In particular, we recommend the following techniques:</p>
<ul id="P7000497027000000000000000044271" data-uri="chapter06.xhtml#P7000497027000000000000000044271" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000044272" data-uri="chapter06.xhtml#P7000497027000000000000000044272" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044273" data-uri="chapter06.xhtml#P7000497027000000000000000044273" class="pcalibre calibre3 pcalibre1">Focus your attention on the inner loops, where the bulk of the computations and memory accesses occur.</p></li>
<li id="P7000497027000000000000000044274" data-uri="chapter06.xhtml#P7000497027000000000000000044274" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044275" data-uri="chapter06.xhtml#P7000497027000000000000000044275" class="pcalibre calibre3 pcalibre1">Try to maximize the spatial locality in your programs by reading data objects sequentially, with stride 1, in the order they are stored in memory.</p></li>
<li id="P7000497027000000000000000044276" data-uri="chapter06.xhtml#P7000497027000000000000000044276" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044277" data-uri="chapter06.xhtml#P7000497027000000000000000044277" class="pcalibre calibre3 pcalibre1">Try to maximize the temporal locality in your programs by using a data object as often as possible once it has been read from memory.</p></li>
</ul>
</section>
</section></body></html>
