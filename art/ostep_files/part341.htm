<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Why Do Deadlocks Occur?</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part340.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part342.htm">下一个 &gt;</a></p><p class="s32" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;text-align: justify;">Why Do Deadlocks Occur?</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">As you may be thinking, simple deadlocks such as the one above seem readily avoidable. For example, if Thread 1 and 2 both made sure to grab locks in the same order, the deadlock would never arise. So why do dead- locks happen?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="59" alt="image" src="Image_489.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Thread 1</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="39" height="39" alt="image" src="Image_490.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">Lock L1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Wanted by</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Wanted by</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 4pt;padding-bottom: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Holds</p><p style="padding-left: 198pt;text-indent: 0pt;line-height: 4pt;text-align: left;"><span><img width="52" height="5" alt="image" src="Image_491.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s152" style="padding-left: 167pt;text-indent: 0pt;text-align: left;"><span><img width="5" height="53" alt="image" src="Image_492.png"/></span>	<span><img width="5" height="53" alt="image" src="Image_493.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 188pt;text-indent: 0pt;line-height: 4pt;text-align: left;"><span><img width="52" height="5" alt="image" src="Image_494.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="59" alt="image" src="Image_495.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 7pt;text-indent: 0pt;text-align: left;">Thread 2</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="39" height="39" alt="image" src="Image_496.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s47" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">Lock L2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-top: 2pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Holds</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 118pt;text-indent: 0pt;text-align: left;">Figure 32.1: <b>The Deadlock Dependency Graph</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One reason is that in large code bases, complex dependencies arise between components. Take the operating system, for example. The vir- tual memory system might need to access the file system in order to page in a block from disk; the file system might subsequently require a page of memory to read the block into and thus contact the virtual memory system. Thus, the design of locking strategies in large systems must be carefully done to avoid deadlock in the case of circular dependencies that may occur naturally in the code.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Another reason is due to the nature of <b>encapsulation</b>. As software de- velopers, we are taught to hide details of implementations and thus make software easier to build in a modular way. Unfortunately, such modular- ity does not mesh well with locking. As Jula et al. point out [J+08], some seemingly innocuous interfaces almost invite you to deadlock. For exam- ple, take the Java Vector class and the method <span class="s41">AddAll()</span>. This routine would be called as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">Vector v1, v2; v1.AddAll(v2);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Internally, because the method needs to be multi-thread safe, locks for both the vector being added to (v1) and the parameter (v2) need to be acquired. The routine acquires said locks in some arbitrary order (say v1 then v2) in order to add the contents of v2 to v1. If some other thread calls <span class="s41">v2.AddAll(v1) </span>at nearly the same time, we have the potential for deadlock, all in a way that is quite hidden from the calling application.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part340.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part342.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
