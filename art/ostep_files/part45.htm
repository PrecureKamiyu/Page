<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>5.2  Adding wait() System Call</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part44.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part46.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 16pt;text-indent: 0pt;text-align: left;">5.2  Adding <span class="s51">wait() </span>System Call</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">So far, we haven’t done much: just created a child that prints out a message and exits. Sometimes, as it turns out, it is quite useful for a parent to wait for a child process to finish what it has been doing. This task is accomplished with the <span class="s41">wait() </span>system call (or its more complete sibling <span class="s41">waitpid()</span>); see Figure <span style=" color: #00AEEF;">5.2 </span>for details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">In this example (<span class="s41">p2.c</span>), the parent process calls <span class="s41">wait() </span>to delay its execution until the child finishes executing. When the child is done, <span class="s41">wait() </span>returns to the parent.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">Adding a <span class="s41">wait() </span>call to the code above makes the output determin- istic. Can you see why? Go ahead, think about it.</p><p class="s6" style="padding-top: 2pt;padding-left: 80pt;text-indent: 0pt;text-align: justify;">(waiting for you to think<span class="s53">  </span>and done)</p><p style="padding-top: 2pt;padding-left: 80pt;text-indent: 0pt;text-align: justify;">Now that you have thought a bit, here is the output:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; ./p2</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">hello world (pid:29266) hello, I am child (pid:29267)</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">hello, I am parent of 29267 (wc:29267) (pid:29266) prompt&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 91%;text-align: justify;">With this code, we now know that the child will always print first. Why do we know that? Well, it might simply run first, as before, and thus print before the parent. However, if the parent does happen to run first, it will immediately call <span class="s41">wait()</span>; this system call won’t return until the child has run and exited<span class="s35">2</span>. Thus, even when the parent runs first, it politely waits for the child to finish running, then <span class="s41">wait() </span>returns, and then the parent prints its message.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part44.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part46.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
