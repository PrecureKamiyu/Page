<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 103" epub:type="pagebreak" id="page_103" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 5: The relative power of primitive synchronization operations</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">In this chapter, we consider various synchronization primitives that a multiprocessor system might provide, and evaluate their relative power. In particular, we compare synchronization primitives by their ability to solve consensus, an elementary synchronization problem. The consensus number of a synchronization primitive is the maximum number of threads for which consensus can be achieved using that primitive. We show that different synchronization primitives have different consensus numbers. Read–write registers have consensus number 1: we cannot achieve consensus for even two threads using only read–write registers. Many common synchronization primitives, including queues, stacks, and some read–modify–write operations such as test-and-set have consensus number 2. An operation that can write <i>n</i> registers atomically has consensus number <i>n</i>. Finally, the compare-and-swap operation has an infinite consensus number.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">synchronization power; consensus number; synchronization primitives; compare-and-swap (CAS); compare-and-set; read-modify-write operations</p></section></header><p class="textfl" id="p0010">Imagine you are in charge of designing a new multiprocessor. What kinds of atomic instructions should you include? The literature includes a bewildering array of different choices: <img alt="Image" height="9" src="images/B9780124159501000148/fx001.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000148/fx002.jpg" width="32"/>(), <img alt="Image" height="11" src="images/B9780124159501000148/fx003.jpg" width="99"/>(), <img alt="Image" height="11" src="images/B9780124159501000148/fx004.jpg" width="106"/>(), <img alt="Image" height="9" src="images/B9780124159501000148/fx005.jpg" width="25"/>(), <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/>, and many, many others. Supporting them all would be complicated and inefficient, but supporting the wrong ones could make it difficult or even impossible to solve important synchronization problems.</p><p class="text" id="p0015">Our goal is to identify a set of primitive synchronization operations powerful enough to solve synchronization problems likely to arise in practice. (We might also support other, nonessential synchronization operations, for convenience.) To this end, we need some way to evaluate the <i>power</i> of various synchronization primitives: what synchronization problems they can solve, and how efficiently they can solve them.</p><p class="text" id="p0020">A concurrent object implementation is <i>wait-free</i> if each method call finishes in a finite number of steps. A method is <i>lock-free</i> if it guarantees that infinitely often, <i>some</i> method call finishes in a finite number of steps. We have already seen wait-free (and therefore also lock-free) register implementations in Chapter <a href="B9780124159501000136.xhtml">4</a>. One way to evaluate the power of synchronization instructions is to see how well they support implementations of shared objects such as queues, stacks, trees, and so on. As we explain in Section <a href="B9780124159501000136.xhtml">4.1</a>, we evaluate solutions that are wait-free or lock-free, that is, that guarantee progress without relying on the underlying platform.<sup><a epub:type="noteref" href="#fn001" id="cf0010" role="doc-noteref">1</a></sup></p><p class="text" id="p0025">Not all synchronization instructions are created equal. If one thinks of primitive synchronization instructions as objects whose exported methods are the instructions themselves (these objects are often called <i>synchronization primitives</i>), one can show that there is an infinite hierarchy of synchronization primitives, such that no primitive at one level can be used for a wait-free or lock-free implementation of any primitives at higher levels. The basic idea is simple: Each class in the hierarchy has an associated <i>consensus number</i>, which is the maximum number of threads for which objects of the class can solve an elementary synchronization problem called <i>consensus</i>. In a system of <i>n</i> or more concurrent threads, it is impossible to implement a wait-free or lock-free object with consensus number <i>n</i> from objects with a lower consensus number.</p><section><h2 class="h1hd" id="s0010"><a id="st0020"/>5.1 Consensus numbers</h2><p class="textfl" id="p0030"><span aria-label="Page 104" epub:type="pagebreak" id="page_104" role="doc-pagebreak"/><i>Consensus</i> is an innocuous-looking, somewhat abstract problem that has enormous consequences for everything from algorithm design to hardware architecture. A <i>consensus object</i> provides a single method <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>(), as shown in <a href="#f0010" id="cf0015">Fig. 5.1</a>. Each thread calls the <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method with its input <i>v at most once</i>. The object's <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method returns a value meeting the following conditions:</p><div><ul><li class="bulllist" id="u0010">•  <i>consistent</i>: all threads decide the same value,</li><li class="bulllist" id="u0015">•  <i>valid</i>: the common decision value is some thread's input.</li></ul></div><p class="textfl"> In other words, a concurrent consensus object is linearizable to a sequential consensus object in which the thread whose value was chosen completes its <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() first. To simplify the presentation, we focus on <i>binary consensus</i>, in which all inputs are either 0 or 1 but our claims apply to consensus in general.</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="43" src="images/B9780124159501000148/gr001.jpg" width="204"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.1</span> Consensus object interface.</div></figcaption></figure></div><p class="text" id="p0045">We are interested in wait-free solutions to the consensus problem, that is, wait-free concurrent implementations of consensus objects. The reader will notice that since the <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method of a given consensus object is executed only once by each thread, and there are a finite number of threads, a lock-free implementation would also be wait-free and vice versa. Henceforth, we mention only wait-free implementations, and for historical reasons, call any class that implements <i>consensus</i> in a wait-free manner a <i>consensus protocol</i>.</p><p class="text" id="p0050">We want to understand whether a particular class of objects is powerful enough to solve the consensus problem.<sup><a epub:type="noteref" href="#fn002" id="cf0020" role="doc-noteref">2</a></sup> How can we make this notion more precise? If we think of such objects as supported by a lower level of the system, perhaps the operating system or even the hardware, then we care about the properties of the class, not about the number of objects. (If the system can provide one object of this class, it can probably provide more.) Second, it is reasonable to suppose that any modern system can provide a generous amount of read–write memory for bookkeeping. These two observations suggest the following definitions.</p><p class="text" id="p0055"/><div class="boxg1" id="enun0010"><p class="b1num">Definition 5.1.1 </p><div><p class="b1textfl" id="p0060">A class <i>C solves n</i>-thread consensus if there exists a consensus protocol for <i>n</i> threads using any number of objects of class <i>C</i> and any number of atomic registers.</p></div></div><p class="textfl"/><p class="text" id="p0065"><span aria-label="Page 105" epub:type="pagebreak" id="page_105" role="doc-pagebreak"/></p><div class="boxg1" id="enun0015"><p class="b1num">Definition 5.1.2 </p><div><p class="b1textfl" id="p0070">The <i>consensus number</i> of a class <i>C</i> is the largest <i>n</i> for which that class solves <i>n</i>-thread consensus. If no largest <i>n</i> exists, we say the consensus number of the class is <i>infinite</i>.</p></div></div><p class="textfl"/><p class="text" id="p0075"/><div class="boxg1" id="enun0020"><p class="b1num">Corollary 5.1.3 </p><div><p class="b1textfl" id="p0080">Suppose one can implement an object of class <i>C</i> from one or more objects of class <i>D</i>, together with some number of atomic registers. If class <i>C</i> solves <i>n</i>-consensus, then so does class <i>D</i>.</p></div></div><p class="textfl"/><section><h3 class="h2hd" id="s0015"><a id="st0025"/>5.1.1 States and valence</h3><p class="textfl" id="p0085">A good place to start is to think about the simplest interesting case: binary consensus (i.e., inputs 0 or 1) for two threads (call them <i>A</i> and <i>B</i>). Each thread makes moves until it decides on a value. Here, a <i>move</i> is a method call to a shared object. A <i>protocol state</i> consists of the states of the threads and the shared objects. An <i>initial state</i> is a protocol state before any thread has moved, and a <i>final state</i> is a protocol state after all threads have finished. The <i>decision value</i> of any final state is the value decided by all threads in that state.</p><p class="text" id="p0090">A wait-free protocol's set of possible states forms a tree, where each node represents a possible protocol state and each edge represents a possible move by some thread. <a href="#f0015" id="cf0025">Fig. 5.2</a> shows the tree for a two-thread protocol in which each thread moves twice. An edge for <i>A</i> from node <i>s</i> to node <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> means that if <i>A</i> moves in protocol state <i>s</i>, then the new protocol state is <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span>. We refer to <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> as a <i>successor state</i> to <i>s</i>. Because the protocol is wait-free, every (simple) path starting from the root is finite (i.e., eventually ends at a leaf node). Leaf nodes represent final protocol states, and are labeled with their decision values, either 0 or 1.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="302" src="images/B9780124159501000148/gr002.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.2</span> An execution tree for two threads <i>A</i> and <i>B</i>. The dark shaded nodes denote bivalent states, and the lighter ones denote univalent states.</div></figcaption></figure></div><p class="text" id="p0095">A protocol state is <i>bivalent</i> if the decision value is not yet fixed: There is some execution starting from that state in which the threads decide 0, and one in which they decide 1. By contrast, a protocol state is <i>univalent</i> if the outcome is fixed: Every execution starting from that state decides the same value. A protocol state is 1<i>-valent</i> if it is univalent, and the decision value will be 1, and similarly for 0<i>-valent</i>. As illustrated in <a href="#f0015" id="cf0030">Fig. 5.2</a>, a bivalent state is a node whose descendants in the tree include both leaves labeled with 0 and leaves labeled with 1, while a univalent state is a node whose descendants include only leaves labeled with a single decision value.</p><p class="text" id="p0100">Our next lemma says that an initial bivalent state exists. This observation means that the outcome of the protocol cannot be fixed in advance, but must depend on how <img alt="Image" height="9" src="images/B9780124159501000148/fx008.jpg" width="31"/> and <img alt="Image" height="9" src="images/B9780124159501000148/fx009.jpg" width="39"/> are interleaved.</p><p class="text" id="p0105"/><div class="boxg1" id="enun0025"><p class="b1num">Lemma 5.1.4 </p><div><p class="b1textfl" id="p0110">Every two-thread consensus protocol has a bivalent initial state.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0030"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0115">Consider the initial state where <i>A</i> has input 0 and <i>B</i> has input 1. If <i>A</i> finishes the protocol before <i>B</i> takes a step, then <i>A</i> must decide 0, because it must decide some thread's input, and 0 is the only input it has seen (it cannot decide 1 because it has no way of distinguishing this state from the one in which <i>B</i> has input 0). Symmetrically, if <i>B</i> finishes the protocol before <i>A</i> takes a step, then <i>B</i> must decide 1. It follows that the initial state where <i>A</i> has input 0 and <i>B</i> has input 1 is bivalent.  □</p></div></div><p class="textfl"/><p class="text" id="p0120"><span aria-label="Page 106" epub:type="pagebreak" id="page_106" role="doc-pagebreak"/></p><div class="boxg1" id="enun0035"><p class="b1num">Lemma 5.1.5 </p><div><p class="b1textfl" id="p0125">Every <i>n</i>-thread consensus protocol has a bivalent initial state.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0040"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0130">Left as an exercise. □</p></div></div><p class="textfl"/><p class="text" id="p0135">A protocol state is <i>critical</i> if:</p><div><ul><li class="bulllist" id="u0020">•  it is bivalent, and</li><li class="bulllist" id="u0025">•  if any thread moves, the protocol state becomes univalent.</li></ul></div><p class="textfl"/><p class="text" id="p0150"/><div class="boxg1" id="enun0045"><p class="b1num">Lemma 5.1.6 </p><div><p class="b1textfl" id="p0155">Every wait-free consensus protocol has a critical state.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0050"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0160">By <a href="#enun0035" id="cf0035">Lemma 5.1.5</a>, the protocol has a bivalent initial state. Start the protocol in this state. As long as some thread can move without making the protocol state univalent, let that thread move. The protocol cannot run forever because it is wait-free. Therefore, the protocol eventually enters a state where no such move is possible, which is, by definition, a critical state. □</p></div></div><p class="textfl"/><p class="text" id="p0165">Everything we have proved so far applies to any consensus protocol, no matter what class(es) of shared objects it uses. Now we consider specific classes of objects.<span aria-label="Page 107" epub:type="pagebreak" id="page_107" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>5.2 Atomic registers</h2><p class="textfl" id="p0170">The obvious place to begin is to ask whether we can solve consensus using atomic registers. Surprisingly, perhaps, the answer is <i>no</i>. We show that there is no binary consensus protocol for two threads. We leave it as an exercise to show that if two threads cannot reach consensus on two values, then <i>n</i> threads cannot reach consensus on <i>k</i> values, for <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo>⩾</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si2.png" style="vertical-align:middle" width="38"/></span> and <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo>⩾</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si3.png" style="vertical-align:middle" width="38"/></span>.</p><p class="text" id="p0175">Often, when we argue about whether or not there exists a protocol that solves a particular problem, we construct a scenario of the form: “If we had such a protocol, it would behave like this under these circumstances.” One particularly useful scenario is to have one thread, say, <i>A</i>, run completely by itself until it finishes the protocol. This particular scenario is common enough that we give it its own name: <i>A</i> runs <i>solo</i>.</p><p class="text" id="p0180"/><div class="boxg1" id="enun0055"><p class="b1num">Theorem 5.2.1 </p><div><p class="b1textfl" id="p0185">Atomic registers have consensus number 1.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0060"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0190">Suppose there exists a binary consensus protocol for two threads <i>A</i> and <i>B</i>. We reason about the properties of such a protocol and derive a contradiction.</p><p class="b1text" id="p0195">By <a href="#enun0045" id="cf0040">Lemma 5.1.6</a>, we can run the protocol until it reaches a critical state <i>s</i>. Suppose <i>A</i>'s next move carries the protocol to a 0-valent state, and <i>B</i>'s next move carries the protocol to a 1-valent state. (If not, then swap thread names.) What methods could <i>A</i> and <i>B</i> be about to call? We now consider an exhaustive list of the possibilities: one of them reads from a register, they both write to separate registers, or they both write to the same register.</p><p class="b1text" id="p0200">Suppose <i>A</i> is about to read a given register (<i>B</i> may be about to either read or write the same register or a different register), as depicted in <a href="#f0020" id="cf0045">Fig. 5.3</a>. Consider two possible execution scenarios. In the first scenario, <i>B</i> moves first, driving the protocol to a 1-valent state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span>, and then <i>B</i> runs solo and eventually decides 1. In the second execution scenario, <i>A</i> moves first, driving the protocol to a 0-valent state, <span aria-label="Page 108" epub:type="pagebreak" id="page_108" role="doc-pagebreak"/>and then <i>B</i> takes a step to reach state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span>. <i>B</i> then runs solo starting in <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> and eventually decides 0. The problem is that the states <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> are indistinguishable to <i>B</i> (the read <i>A</i> performed could only change its thread-local state, which is not visible to <i>B</i>), which means that <i>B</i> must decide the same value in both scenarios, a contradiction.</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="249" src="images/B9780124159501000148/gr003.jpg" width="288"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.3</span> Case: <i>A</i> reads first. In the first execution scenario, <i>B</i> moves first, driving the protocol to a 1-valent state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">s</mml:mtext></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si4.png" style="vertical-align:middle" width="13"/></span>, and then <i>B</i> runs solo and eventually decides 1. In the second execution scenario, <i>A</i> moves first, driving the protocol to a 0-valent state, and then <i>B</i> takes a step to reach state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">s</mml:mtext></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si5.png" style="vertical-align:middle" width="16"/></span>. <i>B</i> then runs solo starting in <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">s</mml:mtext></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si5.png" style="vertical-align:middle" width="16"/></span> and eventually decides 0.</div></figcaption></figure></div><p class="b1text" id="p0205">Suppose, instead of this scenario, both threads are about to write to different registers, as depicted in <a href="#f0025" id="cf0050">Fig. 5.4</a>. <i>A</i> is about to write to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si7.png" style="vertical-align:middle" width="15"/></span> and <i>B</i> to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si8.png" style="vertical-align:middle" width="14"/></span>. Consider two possible execution scenarios. In the first, <i>A</i> writes to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si7.png" style="vertical-align:middle" width="15"/></span> and then <i>B</i> writes to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si8.png" style="vertical-align:middle" width="14"/></span>; the resulting protocol state is 0-valent because <i>A</i> went first. In the second, <i>B</i> writes to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si8.png" style="vertical-align:middle" width="14"/></span> and then <i>A</i> writes to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si7.png" style="vertical-align:middle" width="15"/></span>; the resulting protocol state is 1-valent because <i>B</i> went first.</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="258" src="images/B9780124159501000148/gr004.jpg" width="313"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.4</span> Case: <i>A</i> and <i>B</i> write to different registers.</div></figcaption></figure></div><p class="b1text" id="p0210">The problem is that both scenarios lead to the same protocol state. Neither <i>A</i> nor <i>B</i> can tell which move was first. The resulting state is therefore both 0-valent and 1-valent, a contradiction.</p><p class="b1text" id="p0215">Finally, suppose both threads write to the same register <i>r</i>, as depicted in <a href="#f0030" id="cf0055">Fig. 5.5</a>. Again, consider two possible execution scenarios. In one scenario <i>A</i> writes first, and then <i>B</i> writes; the resulting protocol state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> is 0-valent, and <i>B</i> then runs solo and decides 0. In the other scenario, <i>B</i> writes first, the resulting protocol state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> is 1-valent, and <i>B</i> then runs solo and decides 1. The problem is that <i>B</i> cannot tell the difference between <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> (because in both <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span>, <i>B</i> overwrote the register <i>r</i> and obliterated any trace of <i>A</i>'s write) so <i>B</i> must decide the same value starting from either state, a contradiction. □</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="253" src="images/B9780124159501000148/gr005.jpg" width="289"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.5</span> Case: <i>A</i> and <i>B</i> write to the same register.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0220"/><div class="boxg1" id="enun0065"><p class="b1num">Corollary 5.2.2 </p><div><p class="b1textfl" id="p0225">It is impossible to construct a wait-free implementation of any object with consensus number greater than 1 using atomic registers.</p></div></div><p class="textfl"/><p class="text" id="p0230">This corollary is one of the most striking impossibility results in computer science. It explains why, if we want to implement lock-free <span aria-label="Page 109" epub:type="pagebreak" id="page_109" role="doc-pagebreak"/>concurrent data structures on modern multiprocessors, our hardware must provide primitive synchronization operations other than loads and stores (i.e., reads and writes).</p></section><section><h2 class="h1hd" id="s0025"><a id="st0035"/>5.3 Consensus protocols</h2><p class="textfl" id="p0235">We now consider a variety of interesting object classes, asking how well each can solve the consensus problem. These protocols have a generic form, shown in <a href="#f0035" id="cf0060">Fig. 5.6</a>. The object has an array of atomic registers in which each <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method proposes its input value and then goes on to execute a sequence of steps in order to decide on one of the proposed values. We devise different implementations of the <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method using various synchronization objects.<span aria-label="Page 110" epub:type="pagebreak" id="page_110" role="doc-pagebreak"/></p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="142" src="images/B9780124159501000148/gr006.jpg" width="482"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.6</span> The generic consensus protocol.</div></figcaption></figure></div></section><section><h2 class="h1hd" id="s0030"><a id="st0040"/>5.4 FIFO queues</h2><p class="textfl" id="p0240">In Chapter <a href="B9780124159501000124.xhtml">3</a>, we saw a wait-free FIFO queue implementation using only atomic registers, subject to the limitation that only one thread could enqueue to the queue, and only one thread could dequeue from the queue. It is natural to ask whether one can provide a wait-free implementation of a FIFO queue that supports multiple enqueuers and dequeuers. For now, let us focus on a more specific problem: Can we provide a wait-free implementation of a two-dequeuer FIFO queue using atomic registers?</p><p class="text" id="p0245"/><div class="boxg1" id="enun0070"><p class="b1num">Lemma 5.4.1 </p><div><p class="b1textfl" id="p0250">The two-dequeuer FIFO queue class has consensus number at least 2.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0075"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0255"><a href="#f0040" id="cf0065">Fig. 5.7</a> shows a two-thread consensus protocol using a single FIFO queue. Here, the queue stores integers. The queue is initialized by enqueuing the value <img alt="Image" height="9" src="images/B9780124159501000148/fx010.jpg" width="19"/> followed by the value <img alt="Image" height="9" src="images/B9780124159501000148/fx011.jpg" width="25"/>. As in all the consensus protocols considered here, <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() first calls <img alt="Image" height="9" src="images/B9780124159501000148/fx012.jpg" width="45"/>(<i>v</i>), which stores <i>v</i> in <img alt="Image" height="11" src="images/B9780124159501000148/fx013.jpg" width="52"/>[], a shared array of proposed input values. It then proceeds to dequeue the next item from the queue. If that item is the value <img alt="Image" height="9" src="images/B9780124159501000148/fx010.jpg" width="19"/>, then the calling thread was first, and it decides on its own value. If that item is the value <img alt="Image" height="9" src="images/B9780124159501000148/fx011.jpg" width="25"/>, then the other thread was first, so the calling thread returns the other thread's input, as declared in the <img alt="Image" height="11" src="images/B9780124159501000148/fx013.jpg" width="52"/>[] array.</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="339" src="images/B9780124159501000148/gr007.jpg" width="389"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.7</span> Two-thread consensus using a FIFO queue.</div></figcaption></figure></div><p class="b1text" id="p0260">The protocol is wait-free, since it contains no loops. If each thread returns its own input, then they must both have dequeued <img alt="Image" height="9" src="images/B9780124159501000148/fx010.jpg" width="19"/>, violating the <span aria-label="Page 111" epub:type="pagebreak" id="page_111" role="doc-pagebreak"/>FIFO queue specification. If each returns the other's input, then they must both have dequeued <img alt="Image" height="9" src="images/B9780124159501000148/fx011.jpg" width="25"/>, also violating the queue specification.</p><p class="b1text" id="p0265">The validity condition follows from the observation that the thread that dequeued <img alt="Image" height="9" src="images/B9780124159501000148/fx010.jpg" width="19"/> stored its input in the <img alt="Image" height="11" src="images/B9780124159501000148/fx013.jpg" width="52"/>[] array before any value was dequeued. □</p></div></div><p class="textfl"/><p class="text" id="p0270">Trivial variations of this program yield protocols for stacks, priority queues, lists, sets, or any object with methods that return different results if applied in different orders.</p><p class="text" id="p0275"/><div class="boxg1" id="enun0080"><p class="b1num">Corollary 5.4.2 </p><div><p class="b1textfl" id="p0280">It is impossible to construct a wait-free implementation of a queue, stack, priority queue, list, or set from a set of atomic registers.</p></div></div><p class="textfl"/><p class="text" id="p0285">Although FIFO queues solve two-thread consensus, they do not solve three-thread consensus. </p><div class="boxg1" id="enun0085"><p class="b1num">Theorem 5.4.3 </p><div><p class="b1textfl" id="p0290">FIFO queues have consensus number 2.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0090"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0295">By contradiction, assume we have a consensus protocol for a thread <i>A</i>, <i>B</i>, and <i>C</i>. By <a href="#enun0045" id="cf0070">Lemma 5.1.6</a>, the protocol has a critical state <i>s</i>. Without loss of generality, we can assume that <i>A</i>'s next move takes the protocol to a 0-valent state, and <i>B</i>'s next move takes the protocol to a 1-valent state. The rest, as before, is a case analysis.</p><p class="b1text" id="p0300">We know that <i>A</i> and <i>B</i>'s pending moves cannot commute. Thus, they are both about to call methods of the same object. We also know that <i>A</i> and <i>B</i> cannot be about to read or write shared registers by the proof of <a href="#enun0055" id="cf0075">Theorem 5.2.1</a>. It follows that they are about to call methods of a single queue object.</p><p class="b1text" id="p0305">First, suppose <i>A</i> and <i>B</i> both call <img alt="Image" height="11" src="images/B9780124159501000148/fx014.jpg" width="19"/>(), as depicted in <a href="#f0045" id="cf0080">Fig. 5.8</a>. Let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> be the protocol state if <i>A</i> dequeues and then <i>B</i> dequeues, and <span aria-label="Page 112" epub:type="pagebreak" id="page_112" role="doc-pagebreak"/>let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> be the state if the dequeues occur in the opposite order. Since <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> is 0-valent, if <i>C</i> runs uninterrupted from <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span>, then it decides 0. Since <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> is 1-valent, if <i>C</i> runs uninterrupted from <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span>, then it decides 1. But <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> are indistinguishable to <i>C</i> (the same two items were removed from the queue), so <i>C</i> must decide the same value in both states, a contradiction.</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="267" src="images/B9780124159501000148/gr008.jpg" width="221"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.8</span> Case: <i>A</i> and <i>B</i> both call <img alt="Image" height="11" src="images/B9780124159501000148/fx014.jpg" width="19"/>().</div></figcaption></figure></div><p class="b1text" id="p0310">Second, suppose <i>A</i> calls <img alt="Image" height="9" src="images/B9780124159501000148/fx015.jpg" width="19"/>(<i>a</i>) and <i>B</i> calls <img alt="Image" height="11" src="images/B9780124159501000148/fx014.jpg" width="19"/>(). If the queue is nonempty, the contradiction is immediate because the two methods commute (each operates on a different end of the queue): <i>C</i> cannot observe the order in which they occurred. If the queue is empty, then the 1-valent state reached if <i>B</i> executes a dequeue on the empty queue and then <i>A</i> enqueues is indistinguishable to <i>C</i> from the 0-valent state reached if <i>A</i> alone enqueues. Note that it does not matter what a <img alt="Image" height="11" src="images/B9780124159501000148/fx014.jpg" width="19"/>() on an empty queue does, that is, aborts or waits, since this does not affect the state visible to <i>C</i>.</p><p class="b1text" id="p0315">Finally, suppose <i>A</i> calls <img alt="Image" height="9" src="images/B9780124159501000148/fx015.jpg" width="19"/>(<i>a</i>) and <i>B</i> calls <img alt="Image" height="9" src="images/B9780124159501000148/fx015.jpg" width="19"/>(<i>b</i>), as depicted in <a href="#f0050" id="cf0085">Fig. 5.9</a>. Let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> be the state at the end of the following execution:</p><div><ol><li class="b1numlist" id="o0010">1.  Let <i>A</i> and <i>B</i> enqueue items <i>a</i> and <i>b</i> in that order. <span aria-label="Page 113" epub:type="pagebreak" id="page_113" role="doc-pagebreak"/></li><li class="b1numlist" id="o0015">2.  Run <i>A</i> until it dequeues <i>a</i>. (Since the only way to observe the queue's state is via the <img alt="Image" height="11" src="images/B9780124159501000148/fx014.jpg" width="19"/>() method, <i>A</i> cannot decide before it observes one of <i>a</i> or <i>b</i>.)</li><li class="b1numlist" id="o0020">3.  Before <i>A</i> takes any further steps, run <i>B</i> until it dequeues <i>b</i>.</li></ol></div><p class="b1textfl"/><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="399" src="images/B9780124159501000148/gr009.jpg" width="275"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.9</span> Case: <i>A</i> calls <img alt="Image" height="9" src="images/B9780124159501000148/fx015.jpg" width="19"/>(<i>a</i>) and <i>B</i> calls <img alt="Image" height="9" src="images/B9780124159501000148/fx015.jpg" width="19"/>(<i>b</i>). Note that a new item is enqueued by <i>A</i> after <i>A</i> and <i>B</i> enqueued their respective items and before it dequeued (and <i>B</i> could have also enqueued items before dequeuing), but that this item is the same in both of the execution scenarios.</div></figcaption></figure></div><p class="b1text" id="p0335">Let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> be the state after the following alternative execution:</p><div><ol><li class="b1numlist" id="o0025">1.  Let <i>B</i> and <i>A</i> enqueue items <i>b</i> and <i>a</i> in that order.</li><li class="b1numlist" id="o0030">2.  Run <i>A</i> until it dequeues <i>b</i>.</li><li class="b1numlist" id="o0035">3.  Before <i>A</i> takes any further steps, run <i>B</i> until it dequeues <i>a</i>.</li></ol></div><p class="b1textfl"> Clearly, <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> is 0-valent and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> is 1-valent. Both of <i>A</i>'s executions are identical until <i>A</i> dequeues <i>a</i> or <i>b</i>. Since <i>A</i> is halted before it can modify any other objects, <i>B</i>'s executions are also identical until it dequeues <i>a</i> or <i>b</i>. By a now familiar argument, a contradiction arises because <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> are indistinguishable to <i>C</i>. □</p></div></div><p class="textfl"/><p class="text" id="p0355">Variations of this argument can be applied to show that many similar data types, such as sets, stacks, double-ended queues, and priority queues, all have consensus number exactly 2.</p></section><section><h2 class="h1hd" id="s0035"><a id="st0045"/>5.5 Multiple assignment objects</h2><p class="textfl" id="p0360">In the <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si9.png" style="vertical-align:middle" width="41"/></span><i>-assignment</i> problem for <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo>⩾</mml:mo><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si10.png" style="vertical-align:middle" width="69"/></span> (sometimes called <i>multiple assignment</i>), we are given an object with <i>n</i> fields (sometimes an <i>n</i>-element array). The <img alt="Image" height="11" src="images/B9780124159501000148/fx016.jpg" width="38"/>() method takes as arguments <i>m</i> values <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si11.png" style="vertical-align:middle" width="16"/></span> and <i>m</i> indices <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si12.png" style="vertical-align:middle" width="108"/></span> for <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si13.png" style="vertical-align:middle" width="108"/></span>. It atomically assigns <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si11.png" style="vertical-align:middle" width="16"/></span> to array element <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si14.png" style="vertical-align:middle" width="13"/></span>. The <img alt="Image" height="9" src="images/B9780124159501000148/fx001.jpg" width="25"/>() method takes an index argument <i>i</i>, and returns the <i>i</i>th array element.</p><p class="text" id="p0365"><a href="#f0055" id="cf0090">Fig. 5.10</a> shows a lock-based implementation of a <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si15.png" style="vertical-align:middle" width="36"/></span>-assignment object. Here, threads can assign atomically to any two out of three array entries.</p><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="224" src="images/B9780124159501000148/gr010.jpg" width="424"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.10</span> A lock-based implementation of a (2,3)-assignment object.</div></figcaption></figure></div><p class="text" id="p0370">Multiple assignment is the dual of the <i>atomic snapshot</i> (Section <a href="B9780124159501000136.xhtml">4.3</a>), where we assign to one field and read multiple fields atomically. Because snapshots can be implemented from read–write registers, <a href="#enun0055" id="cf0095">Theorem 5.2.1</a> implies snapshot objects have consensus number 1. However, the same is not true for multiple assignment objects.</p><p class="text" id="p0375"/><div class="boxg1" id="enun0095"><p class="b1num">Theorem 5.5.1 </p><div><p class="b1textfl" id="p0380">There is no wait-free implementation of an <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si9.png" style="vertical-align:middle" width="41"/></span>-assignment object by atomic registers for any <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si16.png" style="vertical-align:middle" width="69"/></span>.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0100"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0385">It is enough to show that we can solve 2-consensus given two threads and a <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si15.png" style="vertical-align:middle" width="36"/></span>-assignment object. (<a href="#enun0290" id="cf0100">Exercise 5.26</a> asks you to justify this claim.) As usual, the <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method must figure out which thread went first. All array entries are initialized with <i>null</i> values. <a href="#f0060" id="cf0105">Fig. 5.11</a> shows the protocol. Thread <i>A</i>, with ID 0, writes (atomically) to fields 0 and 1, while thread <i>B</i>, with ID 1, writes (atomically) to fields 1 and 2. Then they try to determine who went first. From <i>A</i>'s point of view, there are three cases, as shown in <a href="#f0065" id="cf0110">Fig. 5.12</a>:</p><div><ul><li class="b1bulllist" id="u0030">•  If <i>A</i>'s assignment was ordered first, and <i>B</i>'s assignment has not (yet) happened, then fields 0 and 1 have <i>A</i>'s value, and field 2 is <i>null</i>. <i>A</i> decides its own input. <span aria-label="Page 114" epub:type="pagebreak" id="page_114" role="doc-pagebreak"/><span aria-label="Page 115" epub:type="pagebreak" id="page_115" role="doc-pagebreak"/></li><li class="b1bulllist" id="u0035">•  If <i>A</i>'s assignment was ordered first, and <i>B</i>'s second, then field 0 has <i>A</i>'s value, and fields 1 and 2 have <i>B</i>'s. <i>A</i> decides its own input.</li><li class="b1bulllist" id="u0040">•  If <i>B</i>'s assignment was ordered first, and <i>A</i>'s second, then fields 0 and 1 have <i>A</i>'s value, and 2 has <i>B</i>'s. <i>A</i> decides <i>B</i>'s input.</li></ul></div><p class="b1textfl"> A similar analysis holds for <i>B</i>. □</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="257" src="images/B9780124159501000148/gr011.jpg" width="389"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.11</span> Two-thread consensus using (2,3)-multiple assignment.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="72" src="images/B9780124159501000148/gr012.jpg" width="287"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.12</span> Consensus using multiple assignment: possible views.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0405"/><div class="boxg1" id="enun0105"><p class="b1num">Theorem 5.5.2 </p><div><p class="b1textfl" id="p0410"><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="22" src="images/B9780124159501000148/si17.png" style="vertical-align:middle" width="70"/></span>-assignment for <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si18.png" style="vertical-align:middle" width="38"/></span> has consensus number at least <i>n</i>.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0110"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0415">We design a consensus protocol for <i>n</i> threads with IDs <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si19.png" style="vertical-align:middle" width="80"/></span> that uses an <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="22" src="images/B9780124159501000148/si17.png" style="vertical-align:middle" width="70"/></span>-assignment object. For convenience, we name the object fields as follows. There are <i>n</i> fields <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si20.png" style="vertical-align:middle" width="78"/></span> where thread <i>i</i> writes to register <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si21.png" style="vertical-align:middle" width="12"/></span>, and <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si22.png" style="vertical-align:middle" width="75"/></span> fields <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si23.png" style="vertical-align:middle" width="18"/></span>, for <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si24.png" style="vertical-align:middle" width="35"/></span>, where threads <i>i</i> and <i>j</i> both write to field <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si23.png" style="vertical-align:middle" width="18"/></span>. All fields are initialized to <i>null</i>. Each thread <i>i</i> atomically assigns its input value to <i>n</i> fields: its single-writer field <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si21.png" style="vertical-align:middle" width="12"/></span> and its <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si25.png" style="vertical-align:middle" width="37"/></span> multi-writer fields <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si23.png" style="vertical-align:middle" width="18"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si26.png" style="vertical-align:middle" width="19"/></span>. The protocol decides the first value to be assigned.</p><p class="b1text" id="p0420">After assigning to its fields, a thread determines the relative ordering of the assignments for every two threads <i>i</i> and <i>j</i> as follows:</p><div><ul><li class="b1bulllist" id="u0045">•  Read <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si23.png" style="vertical-align:middle" width="18"/></span> or <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si26.png" style="vertical-align:middle" width="19"/></span>. If the value is <i>null</i>, then neither assignment has occurred.</li><li class="b1bulllist" id="u0050">•  Otherwise, read <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si21.png" style="vertical-align:middle" width="12"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si27.png" style="vertical-align:middle" width="14"/></span>. If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si21.png" style="vertical-align:middle" width="12"/></span>'s value is <i>null</i>, then <i>j</i> precedes <i>i</i>, and similarly for <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si27.png" style="vertical-align:middle" width="14"/></span>.</li><li class="b1bulllist" id="u0055">•  If neither <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si21.png" style="vertical-align:middle" width="12"/></span> nor <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si27.png" style="vertical-align:middle" width="14"/></span> is <i>null</i>, reread <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si23.png" style="vertical-align:middle" width="18"/></span>. If its value is equal to the value read from <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si21.png" style="vertical-align:middle" width="12"/></span>, then <i>j</i> precedes <i>i</i>, else vice versa.</li></ul></div><p class="b1textfl"/><p class="b1text" id="p0440">Repeating this procedure, a thread can determine which value was written by the earliest assignment. Two example orderings appear in <a href="#f0070" id="cf0115">Fig. 5.13</a>.  □</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="181" src="images/B9780124159501000148/gr013.jpg" width="288"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.13</span> Two possible cases of (4,10)-assignment solving consensus for four threads. In Case 1, only threads <i>B</i> and <i>D</i> show up. <i>B</i> is the first to assign and wins the consensus. In Case 2, there are three threads, <i>A</i>, <i>B</i>, and <i>D</i>, and as before, <i>B</i> wins by assigning first and <i>D</i> assigns last. The order among the threads can be determined by looking at the pairwise order among any two. Because the assignments are atomic, these individual orders are always consistent and define the total order among the calls.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0445"><span aria-label="Page 116" epub:type="pagebreak" id="page_116" role="doc-pagebreak"/>Note that <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="22" src="images/B9780124159501000148/si17.png" style="vertical-align:middle" width="70"/></span>-assignment solves consensus for <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si18.png" style="vertical-align:middle" width="38"/></span> threads, while its dual structures, atomic snapshots, have consensus number 1. Although these two problems may appear similar, we have just shown that writing atomically to multiple memory locations requires more computational power than reading atomically.</p></section><section><h2 class="h1hd" id="s0040"><a id="st0050"/>5.6 Read–modify–write operations</h2><p class="textfl" id="p0450">Many, if not all, synchronization operations commonly provided by multiprocessors in hardware can be expressed as <i>read–modify–write</i> (RMW) operations, or, as they are called in their object form, <i>read–modify–write registers</i>. Consider an RMW register that encapsulates integer values, and let <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">F</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si28.png" style="vertical-align:middle" width="16"/></span> be a set of functions from integers to integers.<sup><a epub:type="noteref" href="#fn003" id="cf0120" role="doc-noteref">3</a></sup> (Sometimes <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">F</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si28.png" style="vertical-align:middle" width="16"/></span> is a singleton set.)</p><p class="text" id="p0455">A method is an RMW for the function set <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">F</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si28.png" style="vertical-align:middle" width="16"/></span> if it atomically replaces the current register value <i>v</i> with <span class="hiddenClass"><mml:math><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si29.png" style="vertical-align:middle" width="33"/></span>, for some <span class="hiddenClass"><mml:math><mml:mi>f</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">F</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si30.png" style="vertical-align:middle" width="44"/></span>, and returns the original value <i>v</i>. We (mostly) follow the Java convention that an RMW method that applies the function <span class="sans-serif">mumble</span> is called <span class="sans-serif">getAndMumble()</span>.</p><p class="text" id="p0460">For example, the <span class="sans-serif">java.util.concurrent.atomic</span> package provides <img alt="Image" height="11" src="images/B9780124159501000148/fx017.jpg" width="87"/>, a class with a rich set of RMW methods.</p><div><ul><li class="bulllist" id="u0060">•  The <img alt="Image" height="11" src="images/B9780124159501000148/fx018.jpg" width="59"/>(<i>v</i>) method atomically replaces the register's current value with <i>v</i> and returns the prior value. This method (also called <img alt="Image" height="9" src="images/B9780124159501000148/fx005.jpg" width="25"/>()) is an RMW method for the set of constant functions of the type <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>v</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si31.png" style="vertical-align:middle" width="66"/></span>.</li><li class="bulllist" id="u0065">•  The <img alt="Image" height="11" src="images/B9780124159501000148/fx003.jpg" width="99"/>() method atomically adds 1 to the register's current value and returns the prior value. This method (also called <i>fetch-and-increment</i>) is an RMW method for the function <span class="hiddenClass"><mml:math><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si32.png" style="vertical-align:middle" width="88"/></span>.</li><li class="bulllist" id="u0070">•  The <img alt="Image" height="11" src="images/B9780124159501000148/fx019.jpg" width="59"/>(<i>k</i>) method atomically adds <i>k</i> to the register's current value and returns the prior value. This method (also called <i>fetch-and-add</i>) is an RMW method for the set of functions <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si33.png" style="vertical-align:middle" width="93"/></span>.</li><li class="bulllist" id="u0075">•  The <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> method takes two values, an <i>expected</i> value <i>e</i> and an <i>update</i> value <i>u</i>. If the register value is equal to <i>e</i>, it is atomically replaced with <i>u</i>; otherwise it is unchanged. Either way, the method returns a Boolean value indicating whether the value was changed. Informally, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si34.png" style="vertical-align:middle" width="76"/></span> if <span class="hiddenClass"><mml:math><mml:mi>x</mml:mi><mml:mo>≠</mml:mo><mml:mi>e</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si35.png" style="vertical-align:middle" width="38"/></span> and <i>u</i> otherwise. (Strictly speaking, <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> is not an RMW method for <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si36.png" style="vertical-align:middle" width="27"/></span>, because an RMW method would return the register's prior value instead of a Boolean value, but this distinction is a technicality.)</li><li class="bulllist" id="u0080">•  The <img alt="Image" height="11" src="images/B9780124159501000148/fx020.jpg" width="19"/>() method returns the register's value. This method is an RMW method for the identity function <span class="hiddenClass"><mml:math><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>v</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si37.png" style="vertical-align:middle" width="61"/></span>.</li></ul></div><p class="textfl"> The RMW methods are interesting precisely because they are potential hardware primitives, engraved not in stone, but in silicon. Here, we define RMW <span aria-label="Page 117" epub:type="pagebreak" id="page_117" role="doc-pagebreak"/>registers and their methods in terms of <img alt="Image" height="11" src="images/B9780124159501000148/fx021.jpg" width="79"/> Java methods, but, pragmatically, they correspond (exactly or nearly) to many real or proposed hardware synchronization primitives.</p><p class="text" id="p0490">A set of functions is <i>nontrivial</i> if it includes at least one function that is not the identity function. An RMW method is <i>nontrivial</i> if its set of functions is nontrivial, and a RMW register is <i>nontrivial</i> if it has a nontrivial RMW method.</p><p class="text" id="p0495"/><div class="boxg1" id="enun0115"><p class="b1num">Theorem 5.6.1 </p><div><p class="b1textfl" id="p0500">Any nontrivial RMW register has consensus number at least 2.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0120"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0505"><a href="#f0075" id="cf0125">Fig. 5.14</a> shows a two-thread consensus protocol. Since there exists <i>f</i> in <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">F</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si28.png" style="vertical-align:middle" width="16"/></span> that is not the identity, there exists a value <i>v</i> such that <span class="hiddenClass"><mml:math><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mi>v</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si38.png" style="vertical-align:middle" width="61"/></span>. In the <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method, as usual, the <img alt="Image" height="9" src="images/B9780124159501000148/fx012.jpg" width="45"/>(<i>v</i>) method writes the thread's input <i>v</i> to the <img alt="Image" height="11" src="images/B9780124159501000148/fx013.jpg" width="52"/>[] array. Then each thread applies the RMW method to a shared register. If a thread's call returns <i>v</i>, it is linearized first, and it decides its own value. Otherwise, it is linearized second, and it decides the other thread's proposed value. □</p><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="208" src="images/B9780124159501000148/gr014.jpg" width="338"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.14</span> Two-thread consensus using RMW.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0510"/><div class="boxg1" id="enun0125"><p class="b1num">Corollary 5.6.2 </p><div><p class="b1textfl" id="p0515">It is impossible to construct a wait-free implementation of any nontrivial RMW method from atomic registers for two or more threads.</p></div></div><p class="textfl"/></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>5.7 Common2 RMW operations</h2><p class="textfl" id="p0520">We now identify a class of RMW registers, called <i>Common2</i>, that correspond to many of the common synchronization primitives provided by processors in the late 20th century. Although <i>Common2</i> registers, like all nontrivial RMW registers, are more powerful than atomic registers, we show that they have consensus number exactly 2, implying that they have limited synchronization power. Fortunately, these synchronization primitives have by-and-large fallen from favor in contemporary processor architectures.</p><p class="text" id="p0525"><span aria-label="Page 118" epub:type="pagebreak" id="page_118" role="doc-pagebreak"/></p><div class="boxg1" id="enun0130"><p class="b1num">Definition 5.7.1 </p><div><p class="b1textfl" id="p0530">A nontrivial set of functions <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">F</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si28.png" style="vertical-align:middle" width="16"/></span> belongs to <i>Common2</i> if for all values <i>v</i> and all <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si39.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si40.png" style="vertical-align:middle" width="17"/></span> in <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">F</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si28.png" style="vertical-align:middle" width="16"/></span>, either:</p><div><ul><li class="b1bulllist" id="u0085">•  <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si39.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si40.png" style="vertical-align:middle" width="17"/></span> <i>commute</i>: <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si41.png" style="vertical-align:middle" width="144"/></span>, or</li><li class="b1bulllist" id="u0090">•  one function <i>overwrites</i> the other: <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si42.png" style="vertical-align:middle" width="117"/></span> or <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si43.png" style="vertical-align:middle" width="119"/></span>.</li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0545"/><div class="boxg1" id="enun0135"><p class="b1num">Definition 5.7.2 </p><div><p class="b1textfl" id="p0550">An RMW register belongs to <i>Common2</i> if its set of functions <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">F</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si28.png" style="vertical-align:middle" width="16"/></span> belongs to <i>Common2</i>.</p></div></div><p class="textfl"/><p class="text" id="p0555">Many RMW registers in the literature belong to <i>Common2</i>. For example, the <img alt="Image" height="11" src="images/B9780124159501000148/fx018.jpg" width="59"/>() method uses a constant function, which overwrites any prior value. The <img alt="Image" height="11" src="images/B9780124159501000148/fx003.jpg" width="99"/>() and <img alt="Image" height="11" src="images/B9780124159501000148/fx019.jpg" width="59"/>() methods use functions that commute with one another.</p><p class="text" id="p0560">Very informally, here is why RMW registers in <i>Common2</i> cannot solve three-thread consensus: The first thread (the <i>winner</i>) can always tell it was first, and each of the second and third threads (the <i>losers</i>) can tell that it was not. However, because the functions defining the state following operations in <i>Common2</i> commute or overwrite, a loser cannot tell which of the others was the winner (i.e., went first), and because the protocol is wait-free, it cannot wait to find out. Let us make this argument more precise.</p><p class="text" id="p0565"/><div class="boxg1" id="enun0140"><p class="b1num">Theorem 5.7.3 </p><div><p class="b1textfl" id="p0570">Any RMW register in <i>Common2</i> has consensus number (exactly) 2.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0145"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0575"><a href="#enun0115" id="cf0130">Theorem 5.6.1</a> states that any such register has consensus number at least 2. We show that no <i>Common2</i> register solves consensus for three threads.</p><p class="b1text" id="p0580">Assume by contradiction that a three-thread protocol exists using only <i>Common2</i> registers and read–write registers. Suppose threads <i>A</i>, <i>B</i>, and <i>C</i> reach consensus through <i>Common2</i> registers. By <a href="#enun0045" id="cf0135">Lemma 5.1.6</a>, any such protocol has a critical state <i>s</i> in which the protocol is bivalent, but any method call by any thread will cause the protocol to enter a univalent state.</p><p class="b1text" id="p0585">We now do a case analysis, examining each possible method call. The kind of reasoning used in the proof of <a href="#enun0055" id="cf0140">Theorem 5.2.1</a> shows that the pending methods cannot be reads or writes, nor can the threads be about to call methods of different objects. It follows that the threads are about to call RMW methods of a single register <i>r</i>.</p><p class="b1text" id="p0590">Suppose <i>A</i> is about to call a method for function <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si44.png" style="vertical-align:middle" width="19"/></span>, sending the protocol to a 0-valent state, and <i>B</i> is about to call a method for <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si45.png" style="vertical-align:middle" width="19"/></span>, sending the protocol to a 1-valent state. There are two possible cases:</p><div><ol><li class="b1numlist" id="o0040">1.  As depicted in <a href="#f0080" id="cf0145">Fig. 5.15</a>, one function overwrites the other: <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si46.png" style="vertical-align:middle" width="128"/></span>. Let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> be the state that results if <i>A</i> applies <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si44.png" style="vertical-align:middle" width="19"/></span> and then <i>B</i> applies <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si45.png" style="vertical-align:middle" width="19"/></span>. Because <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> is 0-valent, <i>C</i> will decide 0 if it runs alone from <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> until it finishes the protocol. Let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> be the state that results if <i>B</i> alone calls <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si45.png" style="vertical-align:middle" width="19"/></span>. Because <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> is 1-valent, <i>C</i> will decide 1 if it runs alone from <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> until it finishes the protocol. The problem is that the two possible register states <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si47.png" style="vertical-align:middle" width="70"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si48.png" style="vertical-align:middle" width="40"/></span> are the same, so <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> differ only in the internal states of <i>A</i> and <i>B</i>. If we now let thread <i>C</i> execute, since <i>C</i> completes the protocol without communicating with <i>A</i> or <i>B</i>, these two states look identical to <i>C</i>, so it cannot decide different values from the two states.</li></ol><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" height="279" src="images/B9780124159501000148/gr015.jpg" width="312"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.15</span> Case: two functions that overwrite.</div></figcaption></figure></div><ol><li class="b1numlist"/><li class="b1numlist" id="o0045">2.  <span aria-label="Page 119" epub:type="pagebreak" id="page_119" role="doc-pagebreak"/>The functions commute: <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si49.png" style="vertical-align:middle" width="158"/></span>. Let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> be the state that results if <i>A</i> applies <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si44.png" style="vertical-align:middle" width="19"/></span> and then <i>B</i> applies <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si45.png" style="vertical-align:middle" width="19"/></span>. Because <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> is 0-valent, <i>C</i> will decide 0 if it runs alone from <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> until it finishes the protocol. Let <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> be the state that results if <i>A</i> and <i>B</i> perform their calls in reverse order. Because <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> is 1-valent, <i>C</i> will decide 1 if it runs alone from <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> until it finishes the protocol. The problem is that the two possible register states <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si50.png" style="vertical-align:middle" width="70"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si47.png" style="vertical-align:middle" width="70"/></span> are the same, so <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si1.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si6.png" style="vertical-align:middle" width="17"/></span> differ only in the internal states of <i>A</i> and <i>B</i>. Now let thread <i>C</i> execute. Since <i>C</i> completes the protocol without communicating with <i>A</i> or <i>B</i>, these two states look identical to <i>C</i>, so it cannot decide different values from the two states.  □</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>5.8 The <span class="inlinecode">compareAndSet</span> operation</h2><p class="textfl" id="p0605">We now consider the <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> operation (also called <i>compare-and-swap</i>), a synchronization operation supported by several contemporary architectures (e.g., <span class="sans-serif">CMPXCHG</span> on the Intel Pentium). It takes two arguments: an <i>expected</i> value and an <i>update</i> value. If the current register value is equal to the expected value, then it is replaced by the update value; otherwise the value is left unchanged. The method call returns a Boolean indicating whether the value changed.</p><p class="text" id="p0610"/><div class="boxg1" id="enun0150"><p class="b1num">Theorem 5.8.1 </p><div><p class="b1textfl" id="p0615">A register providing <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> and <img alt="Image" height="11" src="images/B9780124159501000148/fx020.jpg" width="19"/>() methods has an infinite consensus number.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0155"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0620"><a href="#f0085" id="cf0150">Fig. 5.16</a> shows a consensus protocol for <i>n</i> threads using the <img alt="Image" height="11" src="images/B9780124159501000148/fx017.jpg" width="87"/> class's <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> method. The threads share an <img alt="Image" height="11" src="images/B9780124159501000148/fx017.jpg" width="87"/> object, initialized to a constant <img alt="Image" height="9" src="images/B9780124159501000148/fx022.jpg" width="31"/>, distinct from any thread index. Each thread calls <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> with <img alt="Image" height="9" src="images/B9780124159501000148/fx022.jpg" width="31"/> as the expected value, and its own index as the new value. If thread <i>A</i>'s call returns <i>true</i>, then that method call was first in the linearization order, so <i>A</i> decides its own value. Otherwise, <i>A</i> reads the current <img alt="Image" height="11" src="images/B9780124159501000148/fx017.jpg" width="87"/> value, and takes that thread's input from the <img alt="Image" height="11" src="images/B9780124159501000148/fx013.jpg" width="52"/>[] array. □</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="191" src="images/B9780124159501000148/gr016.jpg" width="339"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.16</span> Consensus using <img alt="Image" height="12" src="images/B9780124159501000148/fx023.jpg" width="97"/>.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0625"><span aria-label="Page 120" epub:type="pagebreak" id="page_120" role="doc-pagebreak"/>We remark that the <img alt="Image" height="11" src="images/B9780124159501000148/fx020.jpg" width="19"/>() method provided by <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> register in <a href="#f0085" id="cf0155">Fig. 5.16</a> is only a convenience, and not necessary for the protocol.</p><p class="text" id="p0630"/><div class="boxg1" id="enun0160"><p class="b1num">Corollary 5.8.2 </p><div><p class="b1textfl" id="p0635">A register providing only <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> has an infinite consensus number.</p></div></div><p class="textfl"/><p class="text" id="p0640">As we will see in Chapter <a href="B978012415950100015X.xhtml">6</a>, machines that provide primitive operations like <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/><sup><a epub:type="noteref" href="#fn004" id="cf0160" role="doc-noteref">4</a></sup> are asynchronous computation's equivalents of the Turing machines of sequential computation: Any concurrent object that can be implemented in a wait-free manner on such machines. Thus, in the words of Maurice Sendak, <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> is the “king of all wild things.”</p></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>5.9 Chapter notes</h2><p class="textfl" id="p0645">Michael Fischer, Nancy Lynch, and Michael Paterson <a epub:type="noteref" href="#br0230" id="cf0165" role="doc-noteref">[46]</a> were the first to prove that consensus is impossible in a message-passing system where a single thread can halt. Their seminal paper introduced the “bivalence” style of impossibility argument now widely used in distributed computing. M. Loui and H. Abu-Amara <a epub:type="noteref" href="#br0580" id="cf0170" role="doc-noteref">[116]</a> and Herlihy <a epub:type="noteref" href="#br0345" id="cf0175" role="doc-noteref">[69]</a> were the first to extend this result to shared memory.</p><p class="text" id="p0650"><span aria-label="Page 121" epub:type="pagebreak" id="page_121" role="doc-pagebreak"/>Clyde Kruskal, Larry Rudolph, and Marc Snir <a epub:type="noteref" href="#br0480" id="cf0180" role="doc-noteref">[96]</a> coined the term read–modify–write operation as part of the NYU Ultracomputer project.</p><p class="text" id="p0655">Maurice Herlihy <a epub:type="noteref" href="#br0345" id="cf0185" role="doc-noteref">[69]</a> introduced the notion of a consensus number as a measure of computational power, and was the first to prove most of the impossibility and universality results presented in this and the next chapter.</p><p class="text" id="p0660">The class <i>Common2</i>, which includes several common primitive synchronization operations, was defined by Yehuda Afek, Eytan Weisberger, and Hanan Weisman <a epub:type="noteref" href="#br0025" id="cf0190" role="doc-noteref">[5]</a>. The “sticky-bit” object used in the exercises is due to Serge Plotkin <a epub:type="noteref" href="#br0700" id="cf0195" role="doc-noteref">[140]</a>.</p><p class="text" id="p0665">The <i>n</i>-bounded <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> object with arbitrary consensus number <i>n</i> in <a href="#enun0280" id="cf0200">Exercise 5.24</a> is based on a construction by Prasad Jayanti and Sam Toueg <a epub:type="noteref" href="#br0450" id="cf0205" role="doc-noteref">[90]</a>. In the hierarchy used here, we say that <i>X</i> solves consensus if one can construct a wait-free consensus protocol from any number of instances of <i>X</i> and any amount of read–write memory. Prasad Jayanti <a epub:type="noteref" href="#br0440" id="cf0210" role="doc-noteref">[88]</a> observed that one could also define resource-bounded hierarchies where one is restricted to using only a fixed number of instances of <i>X</i>, or a fixed amount of memory. The unbounded hierarchy used here seems to be the most natural one, since any other hierarchy is a coarsening of the unbounded one.</p><p class="text" id="p0670">Jayanti also raised the question whether the hierarchy is <i>robust</i>, that is, whether an object <i>X</i> at level <i>m</i> can be “boosted” to a higher consensus level by combining it with another object <i>Y</i> at the same or a lower level. Wai-Kau Lo and Vassos Hadzilacos <a epub:type="noteref" href="#br0570" id="cf0215" role="doc-noteref">[114]</a> and Eric Schenk <a epub:type="noteref" href="#br0795" id="cf0220" role="doc-noteref">[159]</a> showed that the consensus hierarchy is not robust: Certain objects can be boosted. Informally, their constructions went like this: Let <i>X</i> be an object with the following curious properties. <i>X</i> solves <i>n</i>-thread consensus but “refuses” to reveal the results unless the caller can prove he or she can solve an intermediate task weaker than <i>n</i>-thread consensus, but stronger than any task solvable by atomic read–write registers. If <i>Y</i> is an object that can be used to solve the intermediate task, <i>Y</i> can boost <i>X</i> by convincing <i>X</i> to reveal the outcome of an <i>n</i>-thread consensus. The objects used in these proofs are nondeterministic.</p><p class="text" id="p0675">The Maurice Sendak quote is from <i>Where the Wild Things Are</i> <a epub:type="noteref" href="#br0775" id="cf0225" role="doc-noteref">[155]</a>.</p></section><section><h2 class="h1hd" id="s0060"><a id="st0070"/>5.10 Exercises</h2><p class="textfl" id="p0680"/><div class="boxg1" id="enun0165"><p class="b1num">Exercise 5.1 </p><div><p class="b1textfl" id="p0685">Prove <a href="#enun0035" id="cf0230">Lemma 5.1.5</a>, that is, that every <i>n</i>-thread consensus protocol has a bivalent initial state.</p></div></div><p class="textfl"/><p class="text" id="p0690"/><div class="boxg1" id="enun0170"><p class="b1num">Exercise 5.2 </p><div><p class="b1textfl" id="p0695">Prove that in a critical state, one successor state must be 0-valent, and the other 1-valent.</p></div></div><p class="textfl"/><p class="text" id="p0700"/><div class="boxg1" id="enun0175"><p class="b1num">Exercise 5.3 </p><div><p class="b1textfl" id="p0705">Show that if binary consensus using atomic registers is impossible for two threads, then it is also impossible for <i>n</i> threads, where <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si51.png" style="vertical-align:middle" width="39"/></span>. (Hint: Argue by <i>reduction</i>: If we have a protocol to solve binary consensus for <i>n</i> threads, then we can transform it into a two-thread protocol.)</p></div></div><p class="textfl"/><p class="text" id="p0710"/><div class="boxg1" id="enun0180"><p class="b1num">Exercise 5.4 </p><div><p class="b1textfl" id="p0715">Show that if binary consensus using atomic registers is impossible for <i>n</i> threads, then so is consensus over <i>k</i> values, where <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si52.png" style="vertical-align:middle" width="38"/></span>.</p></div></div><p class="textfl"/><p class="text" id="p0720"><span aria-label="Page 122" epub:type="pagebreak" id="page_122" role="doc-pagebreak"/></p><div class="boxg1" id="enun0185"><p class="b1num">Exercise 5.5 </p><div><p class="b1textfl" id="p0725">Show that with sufficiently many <i>n</i>-thread binary consensus objects and atomic registers, one can implement <i>n</i>-thread consensus over <i>n</i> values.</p></div></div><p class="textfl"/><p class="text" id="p0730"/><div class="boxg1" id="enun0190"><p class="b1num">Exercise 5.6 </p><div><p class="b1textfl" id="p0735">Consider the algorithm in <a href="#f0090" id="cf0235">Fig. 5.17</a> for two-thread binary consensus.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="339" src="images/B9780124159501000148/gr017.jpg" width="493"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.17</span> Proposed consensus code for thread <i>i</i> ∈ {0,1}.</div></figcaption></figure></div><p class="b1text" id="p0740"/><div><ul><li class="b1bulllist" id="u0095">•  Show that the algorithm is consistent and valid (that is, an output value must be an input of one of the threads, and the output values cannot differ).</li><li class="b1bulllist" id="u0100">•  Since the algorithm is consistent and valid and only uses read–write registers, it cannot be wait-free. Give an execution history that is a counterexample to wait-freedom.</li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0755"/><div class="boxg1" id="enun0195"><p class="b1num">Exercise 5.7 </p><div><p class="b1textfl" id="p0760">The <img alt="Image" height="9" src="images/B9780124159501000148/fx024.jpg" width="32"/> class provides two methods: <img alt="Image" height="11" src="images/B9780124159501000148/fx025.jpg" width="25"/>(<i>x</i>) pushes a value onto the top of the stack, and <img alt="Image" height="9" src="images/B9780124159501000148/fx026.jpg" width="18"/>() removes and returns the most recently pushed value. Prove that the <img alt="Image" height="9" src="images/B9780124159501000148/fx024.jpg" width="32"/> class has consensus number <i>exactly</i> 2.</p></div></div><p class="textfl"/><p class="text" id="p0765"/><div class="boxg1" id="enun0200"><p class="b1num">Exercise 5.8 </p><div><p class="b1textfl" id="p0770">Suppose we augment the FIFO <img alt="Image" height="11" src="images/B9780124159501000148/fx027.jpg" width="32"/> class with a <img alt="Image" height="11" src="images/B9780124159501000148/fx028.jpg" width="25"/>() method that returns but does not remove the first element in the queue. Show that the augmented queue has infinite consensus number.</p></div></div><p class="textfl"/><p class="text" id="p0775"/><div class="boxg1" id="enun0205"><p class="b1num">Exercise 5.9 </p><div><p class="b1textfl" id="p0780">Consider three threads, <i>A</i>, <i>B</i>, and <i>C</i>, each of which has an MRSW register, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si53.png" style="vertical-align:middle" width="23"/></span>, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si54.png" style="vertical-align:middle" width="23"/></span>, and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si55.png" style="vertical-align:middle" width="23"/></span>, that it alone can write and the others can read. Each pair also shares a <img alt="Image" height="11" src="images/B9780124159501000148/fx029.jpg" width="72"/> register that provides <span aria-label="Page 123" epub:type="pagebreak" id="page_123" role="doc-pagebreak"/>a <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> method: <i>A</i> and <i>B</i> share <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si56.png" style="vertical-align:middle" width="31"/></span>, <i>B</i> and <i>C</i> share <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si57.png" style="vertical-align:middle" width="31"/></span>, and <i>A</i> and <i>C</i> share <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si58.png" style="vertical-align:middle" width="31"/></span>. Only the threads that share a register can call that register's <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> method or read its value.</p><p class="b1text" id="p0785">Either give a three-thread consensus protocol and explain why it works, or sketch an impossibility proof.</p></div></div><p class="textfl"/><p class="text" id="p0790"/><div class="boxg1" id="enun0210"><p class="b1num">Exercise 5.10 </p><div><p class="b1textfl" id="p0795">Consider the situation described in <a href="#enun0205" id="cf0240">Exercise 5.9</a> except that <i>A</i>, <i>B</i>, and <i>C</i> can apply a <i>double</i> <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> to both registers at once.</p></div></div><p class="textfl"/><p class="text" id="p0800"/><div class="boxg1" id="enun0215"><p class="b1num">Exercise 5.11 </p><div><p class="b1textfl" id="p0805">In the consensus protocol shown in <a href="#f0040" id="cf0245">Fig. 5.7</a>, what would happen if we announced the thread's value after dequeuing from the queue?</p></div></div><p class="textfl"/><p class="text" id="p0810"/><div class="boxg1" id="enun0220"><p class="b1num">Exercise 5.12 </p><div><p class="b1textfl" id="p0815">Objects of the <img alt="Image" height="11" src="images/B9780124159501000148/fx030.jpg" width="59"/> class have three possible states, <span class="hiddenClass"><mml:math><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si59.png" style="vertical-align:middle" width="44"/></span>, initially ⊥. A call to <img alt="Image" height="9" src="images/B9780124159501000148/fx002.jpg" width="32"/>(<i>v</i>), where <i>v</i> is 0 or 1, has the following effects:</p><div><ul><li class="b1bulllist" id="u0105">•  If the object's state is ⊥, then it becomes <i>v</i>.</li><li class="b1bulllist" id="u0110">•  If the object's state is 0 or 1, then it is unchanged.</li></ul></div><p class="b1textfl"/><p class="b1text" id="p0830">A call to <img alt="Image" height="9" src="images/B9780124159501000148/fx001.jpg" width="25"/>() returns the object's current state.</p><div><ol><li class="b1numlist" id="o0050">1.  Show that such an object can solve wait-free <i>binary</i> consensus (that is, all inputs are 0 or 1) for any number of threads.</li><li class="b1numlist" id="o0055">2.  Show that an array of <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si60.png" style="vertical-align:middle" width="44"/></span> <img alt="Image" height="11" src="images/B9780124159501000148/fx030.jpg" width="59"/> objects with atomic registers can solve wait-free consensus for any number of threads when there are <i>m</i> possible inputs. (Hint: Give each thread one atomic multi-reader single-writer register.)</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0845"/><div class="boxg1" id="enun0225"><p class="b1num">Exercise 5.13 </p><div><p class="b1textfl" id="p0850">The <img alt="Image" height="11" src="images/B9780124159501000148/fx031.jpg" width="52"/> class, like the <img alt="Image" height="9" src="images/B9780124159501000148/fx032.jpg" width="59"/> class, provides a <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method whose call returns a value that was the input of some thread's <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() call. However, unlike the <img alt="Image" height="9" src="images/B9780124159501000148/fx032.jpg" width="59"/> class, the values returned by <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() calls are not required to agree. Instead, these calls may return no more than <i>k</i> distinct values. (When <i>k</i> is 1, <img alt="Image" height="11" src="images/B9780124159501000148/fx031.jpg" width="52"/> is the same as consensus.)</p><p class="b1text" id="p0855">What is the consensus number of the <img alt="Image" height="11" src="images/B9780124159501000148/fx031.jpg" width="52"/> class when <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000148/si61.png" style="vertical-align:middle" width="37"/></span>?</p></div></div><p class="textfl"/><p class="text" id="p0860"/><div class="boxg1" id="enun0230"><p class="b1num">Exercise 5.14 </p><div><p class="b1textfl" id="p0865">The two-thread <i>approximate agreement</i> class for a given <span class="hiddenClass"><mml:math><mml:mi>ϵ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si62.png" style="vertical-align:middle" width="37"/></span> is defined as follows: Threads <i>A</i> and <i>B</i> each call <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si63.png" style="vertical-align:middle" width="28"/></span> and <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si64.png" style="vertical-align:middle" width="27"/></span> methods, where <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000148/si65.png" style="vertical-align:middle" width="17"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000148/si66.png" style="vertical-align:middle" width="17"/></span> are real numbers. These method calls respectively return values <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si67.png" style="vertical-align:middle" width="16"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si68.png" style="vertical-align:middle" width="16"/></span> such that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si67.png" style="vertical-align:middle" width="16"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000148/si68.png" style="vertical-align:middle" width="16"/></span> both lie in the closed interval <span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="normal">min</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal">max</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si69.png" style="vertical-align:middle" width="171"/></span>, and <span class="hiddenClass"><mml:math><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>⩽</mml:mo><mml:mi>ϵ</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si70.png" style="vertical-align:middle" width="85"/></span>. Note that this object is nondeterministic.</p><p class="b1text" id="p0870">What is the consensus number of the <i>approximate agreement</i> object?</p></div></div><p class="textfl"/><p class="text" id="p0875"/><div class="boxg1" id="enun0235"><p class="b1num">Exercise 5.15 </p><div><p class="b1textfl" id="p0880">An <img alt="Image" height="9" src="images/B9780124159501000148/fx033.jpg" width="32"/> object represents two locations for values that can be read individually and be modified by <img alt="Image" height="9" src="images/B9780124159501000148/fx034.jpg" width="31"/>(). If both locations have the corresponding expected values <i>e</i>0 and <i>e</i>1, then a call to <img alt="Image" height="9" src="images/B9780124159501000148/fx034.jpg" width="31"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si71.png" style="vertical-align:middle" width="67"/></span> will write <i>v</i> to <i>exactly one</i> of the two locations, chosen nondeterministically.</p><p class="b1text" id="p0885">What is the consensus number of the <img alt="Image" height="9" src="images/B9780124159501000148/fx034.jpg" width="31"/>() object? Prove your claim.</p></div></div><p class="textfl"/><p class="text" id="p0890"/><div class="boxg1" id="enun0240"><p class="b1num">Exercise 5.16 </p><div><p class="b1textfl" id="p0895">Consider a distributed system where threads communicate by message passing. A <i>type A</i> broadcast guarantees:</p><div><ol><li class="b1numlist" id="o0060">1.  every nonfaulty thread eventually gets each message, <span aria-label="Page 124" epub:type="pagebreak" id="page_124" role="doc-pagebreak"/></li><li class="b1numlist" id="o0065">2.  if <i>P</i> broadcasts <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si72.png" style="vertical-align:middle" width="22"/></span> and then <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si73.png" style="vertical-align:middle" width="23"/></span>, then every thread receives <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si72.png" style="vertical-align:middle" width="22"/></span> before <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si73.png" style="vertical-align:middle" width="23"/></span>, but</li><li class="b1numlist" id="o0070">3.  messages broadcast by different threads may be received in different orders at different threads.</li></ol></div><p class="b1textfl"> A <i>type B</i> broadcast guarantees:</p><div><ol><li class="b1numlist" id="o0075">1.  every nonfaulty thread eventually gets each message,</li><li class="b1numlist" id="o0080">2.  if <i>P</i> broadcasts <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si72.png" style="vertical-align:middle" width="22"/></span> and <i>Q</i> broadcasts <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si73.png" style="vertical-align:middle" width="23"/></span>, then every thread receives <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si72.png" style="vertical-align:middle" width="22"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si73.png" style="vertical-align:middle" width="23"/></span> in the same order.</li></ol></div><p class="b1textfl"/><p class="b1text" id="p0925">For each kind of broadcast,</p><div><ul><li class="b1bulllist" id="u0115">•  give a consensus protocol if possible;</li><li class="b1bulllist" id="u0120">•  otherwise, sketch an impossibility proof.</li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0940"/><div class="boxg1" id="enun0245"><p class="b1num">Exercise 5.17 </p><div><p class="b1textfl" id="p0945">Consider the following two-thread <img alt="Image" height="11" src="images/B9780124159501000148/fx035.jpg" width="92"/> problem.</p><p class="b1text" id="p0950">Two threads, <i>A</i> and <i>B</i>, are each given a binary input. If both have input <i>v</i>, then both must decide <i>v</i>. If they have mixed inputs, then either they must agree, or <i>B</i> may decide 0 and <i>A</i> may decide 1 (but not vice versa).</p><p class="b1text" id="p0955">Here are three possible exercises (only one of which works):</p><div><ol><li class="b1numlist" id="o0085">1.  Give a two-thread consensus protocol using <img alt="Image" height="11" src="images/B9780124159501000148/fx035.jpg" width="92"/> showing it has consensus number (at least) 2.</li><li class="b1numlist" id="o0090">2.  Give a critical-state proof that this object's consensus number is 1.</li><li class="b1numlist" id="o0095">3.  Give a read–write implementation of <img alt="Image" height="11" src="images/B9780124159501000148/fx035.jpg" width="92"/>, thereby showing it has consensus number 1.</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0975"/><div class="boxg1" id="enun0250"><p class="b1num">Exercise 5.18 </p><div><p class="b1textfl" id="p0980">Explain why the critical-state proof of the impossibility of consensus fails if the shared object is, in fact, a <img alt="Image" height="9" src="images/B9780124159501000148/fx032.jpg" width="59"/> object.</p></div></div><p class="textfl"/><p class="text" id="p0985"/><div class="boxg1" id="enun0255"><p class="b1num">Exercise 5.19 </p><div><p class="b1textfl" id="p0990">A <i>team consensus</i> object provides the same <img alt="Image" height="9" src="images/B9780124159501000148/fx007.jpg" width="39"/>() method as consensus. A team consensus object solves consensus as long as at most <i>two</i> distinct values are ever proposed. (If more than two are proposed, any result is allowed.)</p><p class="b1text" id="p0995">Show how to solve <i>n</i>-thread consensus, with up to <i>n</i> distinct input values, from a supply of team consensus objects.</p></div></div><p class="textfl"/><p class="text" id="p1000"/><div class="boxg1" id="enun0260"><p class="b1num">Exercise 5.20 </p><div><p class="b1textfl" id="p1005">A <i>trinary</i> register holds values <span class="hiddenClass"><mml:math><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si59.png" style="vertical-align:middle" width="44"/></span>, and provides <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> and <img alt="Image" height="11" src="images/B9780124159501000148/fx020.jpg" width="19"/>() methods with the usual meaning. Each such register is initially ⊥. Give a protocol that uses one such register to solve <i>n</i>-thread consensus if the inputs of the threads are <i>binary</i>, that is, either 0 or 1.</p><p class="b1text" id="p1010">Can you use multiple such registers (perhaps with atomic read–write registers) to solve <i>n</i>-thread consensus even if the threads' inputs are in the range <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>…</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si74.png" style="vertical-align:middle" width="77"/></span> for <span class="hiddenClass"><mml:math><mml:mi>K</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000148/si75.png" style="vertical-align:middle" width="42"/></span>? (You may assume an input fits in an atomic register.) <i>Important:</i> Remember that a consensus protocol must be wait-free.</p><div><ul><li class="b1bulllist" id="u0125">•  Devise a solution that uses at most <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si76.png" style="vertical-align:middle" width="35"/></span> trinary registers.</li><li class="b1bulllist" id="u0130">•  Devise a solution that uses <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si77.png" style="vertical-align:middle" width="40"/></span> trinary registers.</li></ul></div><p class="b1textfl"> Feel free to use all the atomic registers you want (they are cheap).</p></div></div><p class="textfl"/><p class="text" id="p1025"><span aria-label="Page 125" epub:type="pagebreak" id="page_125" role="doc-pagebreak"/></p><div class="boxg1" id="enun0265"><p class="b1num">Exercise 5.21 </p><div><p class="b1textfl" id="p1030">Earlier we defined lock-freedom. Prove that there is no lock-free implementation of consensus using read–write registers for two or more threads.</p></div></div><p class="textfl"/><p class="text" id="p1035"/><div class="boxg1" id="enun0270"><p class="b1num">Exercise 5.22 </p><div><p class="b1textfl" id="p1040"><a href="#f0095" id="cf0250">Fig. 5.18</a> shows a FIFO queue implemented with <img alt="Image" height="9" src="images/B9780124159501000148/fx001.jpg" width="25"/>(), <img alt="Image" height="9" src="images/B9780124159501000148/fx002.jpg" width="32"/>(), <img alt="Image" height="11" src="images/B9780124159501000148/fx018.jpg" width="59"/>() (that is, swap), and <img alt="Image" height="11" src="images/B9780124159501000148/fx003.jpg" width="99"/>() methods. You may assume this queue is linearizable, and wait-free as long as <img alt="Image" height="11" src="images/B9780124159501000148/fx014.jpg" width="19"/>() is never applied to an empty queue. Consider the following sequence of statements:</p><div><ul><li class="b1bulllist" id="u0135">•  Both <img alt="Image" height="11" src="images/B9780124159501000148/fx018.jpg" width="59"/>() and <img alt="Image" height="11" src="images/B9780124159501000148/fx003.jpg" width="99"/>() methods have consensus number 2.</li><li class="b1bulllist" id="u0140">•  We can add a <img alt="Image" height="11" src="images/B9780124159501000148/fx028.jpg" width="25"/>() simply by taking a snapshot of the queue (using the methods studied earlier) and returning the item at the head of the queue.</li><li class="b1bulllist" id="u0145">•  Using the protocol devised for <a href="#enun0200" id="cf0255">Exercise 5.8</a>, we can use the resulting queue to solve <i>n</i>-consensus for any <i>n</i>.</li></ul></div><p class="b1textfl"> We have just constructed an <i>n</i>-thread consensus protocol using only objects with consensus number 2.</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="290" src="images/B9780124159501000148/gr018.jpg" width="424"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.18</span> Queue implementation.</div></figcaption></figure></div><p class="b1text" id="p1060">Identify the faulty step in this chain of reasoning, and explain what went wrong.</p></div></div><p class="textfl"/><p class="text" id="p1065"/><div class="boxg1" id="enun0275"><p class="b1num">Exercise 5.23 </p><div><p class="b1textfl" id="p1070">Recall that in our definition of <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/>, we noted that strictly speaking, <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> is not an RMW method for <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000148/si36.png" style="vertical-align:middle" width="27"/></span>, because an RMW method would return the register's prior value instead of a Boolean value. Use an object that supports <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> and <img alt="Image" height="11" src="images/B9780124159501000148/fx020.jpg" width="19"/>() to provide a new object with a linearizable <span class="sans-serif">NewCompareAndSet()</span> method that returns the register's current value instead of a Boolean.</p></div></div><p class="textfl"/><p class="text" id="p1075"><span aria-label="Page 126" epub:type="pagebreak" id="page_126" role="doc-pagebreak"/></p><div class="boxg1" id="enun0280"><p class="b1num">Exercise 5.24 </p><div><p class="b1textfl" id="p1080">Define an <i>n-bounded</i> <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> object as follows: It provides a <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> method that takes two values, an <i>expected</i> value <i>e</i> and an <i>update</i> value <i>u</i>. For the first <i>n</i> times <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> is called, it behaves like a conventional <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> register: If the object value is equal to <i>e</i>, it is atomically replaced with <i>u</i>, and the method call returns <i>true</i>. If the object value <i>v</i> is not equal to <i>e</i>, then it is left unchanged, and the method call returns <i>false</i>, along with the value <i>v</i>. After <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> has been called <i>n</i> times, however, the object enters a faulty state, and all subsequent method calls return ⊥.</p><p class="b1text" id="p1085">Show that an <i>n</i>-bounded <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> object for <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo>⩾</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000148/si2.png" style="vertical-align:middle" width="38"/></span> has consensus number exactly <i>n</i>.</p></div></div><p class="textfl"/><p class="text" id="p1090"/><div class="boxg1" id="enun0285"><p class="b1num">Exercise 5.25 </p><div><p class="b1textfl" id="p1095">Provide a wait-free implementation of a two-thread <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si15.png" style="vertical-align:middle" width="36"/></span>-assignment object from three <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> objects (that is, objects supporting the operations <img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> and <img alt="Image" height="11" src="images/B9780124159501000148/fx020.jpg" width="19"/>()).</p></div></div><p class="textfl"/><p class="text" id="p1100"/><div class="boxg1" id="enun0290"><p class="b1num">Exercise 5.26 </p><div><p class="b1textfl" id="p1105">In the proof of <a href="#enun0095" id="cf0260">Theorem 5.5.1</a>, we claimed that it is enough to show that we can solve 2-consensus given two threads and a <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000148/si15.png" style="vertical-align:middle" width="36"/></span>-assignment object. Justify this claim.</p></div></div><p class="textfl"/><p class="text" id="p1110"/><div class="boxg1" id="enun0295"><p class="b1num">Exercise 5.27 </p><div><p class="b1textfl" id="p1115">We can treat the scheduler as an <i>adversary</i> who uses the knowledge of our protocols and input values to frustrate our attempts at reaching consensus. One way to outwit an adversary is through randomization. Assume that there are two threads that want to reach consensus, each of which can flip an unbiased coin, and that the adversary cannot control future coin flips but can observe the result of each coin flip and each value read or written. The adversary scheduler can stop a thread before or after a coin flip or a read or write to a shared register. A <i>randomized consensus protocol</i> terminates with probability arbitrarily close to 1 (given sufficiently long time) against an adversary scheduler.</p><p class="b1text" id="p1120"><a href="#f0100" id="cf0265">Fig. 5.19</a> shows a plausible-looking randomized binary consensus protocol. Give an example showing that this protocol is incorrect.</p><div><ul><li class="b1bulllist" id="u0150">•  Does the algorithm satisfy the safety properties of consensus (i.e., validity and consistency)? That is, is it true that each thread can only output a value that is the input of one of the two threads, and also that the outputs cannot be different?</li><li class="b1bulllist" id="u0155">•  Does it terminate with a probability arbitrarily close to 1?</li></ul></div><p class="b1textfl"/><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="290" src="images/B9780124159501000148/gr019.jpg" width="259"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 5.19</span> Is this a randomized consensus protocol?</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p1135"/><div class="boxg1" id="enun0300"><p class="b1num">Exercise 5.28 </p><div><p class="b1textfl" id="p1140">One can implement a consensus object using read–write registers by implementing a deadlock- or starvation-free mutual exclusion lock. However, this implementation provides only dependent progress, and the operating system must make sure that threads do not get stuck in the critical section so that the computation as a whole progresses.</p><div><ul><li class="b1bulllist" id="u0160">•  Is the same true for obstruction-freedom, the nonblocking dependent progress condition? Show an obstruction-free implementation of a consensus object using only atomic registers.</li><li class="b1bulllist" id="u0165">•  What is the role of the operating system in the obstruction-free solution to consensus? Explain where the critical state-based proof of <span aria-label="Page 127" epub:type="pagebreak" id="page_127" role="doc-pagebreak"/>the impossibility of consensus breaks down if we repeatedly allow an oracle to halt threads so as to allow others to make progress.</li></ul></div><p class="b1textfl"> (Hint: Think of how you could restrict the set of allowed executions.)</p></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0530"><h2 class="reftitle" id="st0075">Bibliography</h2><p class="reflist" epub:type="biblioentry footnote" id="br0025" role="doc-biblioentry">[5] Yehuda Afek, Eytan Weisberger, Hanan Weisman,  A completeness theorem for a class of synchronization objects,   <i>PODC '93: Proceedings of the Twelfth Annual ACM Symposium on Principles of Distributed Computing</i>.  New York, NY, USA: ACM Press; 1993:159–170.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0230" role="doc-biblioentry">[46] Michael J. Fischer, Nancy A. Lynch, Michael S. Paterson,  Impossibility of distributed consensus with one faulty process,   <cite><i>Journal of the ACM</i></cite> 1985;32(2):374–382.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0345" role="doc-biblioentry">[69] Maurice Herlihy,  Wait-free synchronization,   <cite><i>ACM Transactions on Programming Languages and Systems</i></cite> 1991;13(1):124–149.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0440" role="doc-biblioentry">[88] Prasad Jayanti,  Robust wait-free hierarchies,   <cite><i>Journal of the ACM</i></cite> 1997;44(4):592–614.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0450" role="doc-biblioentry">[90] Prasad Jayanti, Sam Toueg,  Some results on the impossibility, universality, and decidability of consensus,   <i>WDAG '92: Proceedings of the 6th International Workshop on Distributed Algorithms</i>.  London, UK: Springer-Verlag; 1992:69–84.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0480" role="doc-biblioentry">[96] Clyde P. Kruskal, Larry Rudolph, Marc Snir,  Efficient synchronization of multiprocessors with shared memory,   <cite><i>ACM Transactions on Programming Languages and Systems</i></cite> 1988;10(4):579–601.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0570" role="doc-biblioentry">[114] Wai-Kau Lo, Vassos Hadzilacos,  All of us are smarter than any of us: wait-free hierarchies are not robust,   <i>STOC '97: Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing</i>.  New York, NY, USA: ACM Press; 1997:579–588.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0580" role="doc-biblioentry">[116] M. Loui, H. Abu-Amara,  Memory requirements for agreement among unreliable asynchronous processes,   F.P. Preparata, ed.  <i>Advances in Computing Research, vol. 4</i>.  Greenwich, CT: JAI Press; 1987:163–183.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0700" role="doc-biblioentry">[140] S.A. Plotkin,  Sticky bits and universality of consensus,   <i>PODC '89: Proceedings of the Eighth Annual ACM Symposium on Principles of Distributed Computing</i>.  New York, NY, USA: ACM Press; 1989:159–175.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0775" role="doc-biblioentry">[155] Maurice Sendak,  <i>Where the Wild Things Are</i>.  HarperCollins; 1988 0060254920.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0795" role="doc-biblioentry">[159] Eric Shenk,  The consensus hierarchy is not robust,   <i>PODC '97: Proceedings of the Sixteenth Annual ACM Symposium on Principles of Distributed Computing</i>.  New York, NY, USA: ACM Press; 1997:279.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0010" role="doc-noteref">1 </a></sup> <a id="np0010"/>“It makes no sense to evaluate solutions that only meet dependent progress conditions such as obstruction-freedom or deadlock-freedom because the real power of such solutions is masked by the contribution of the operating system they depend on.”</p><p class="ftnote1" epub:type="footnote" id="fn002" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0020" role="doc-noteref">2 </a></sup> <a id="np0015"/>“We restrict ourselves to object classes with deterministic sequential specifications (i.e., ones in which each sequential method call has a single outcome). We avoid nondeterministic objects since their structure is significantly more complex. See the discussion in the notes at the end of this chapter.”</p><p class="ftnote1" epub:type="footnote" id="fn003" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0120" role="doc-noteref">3 </a></sup> <a id="np0020"/>“For simplicity, we consider only registers that hold integer values, but they could equally well hold other values (e.g., references to other objects).”</p><p class="ftnote1" epub:type="footnote" id="fn004" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0160" role="doc-noteref">4 </a></sup> <a id="np0025"/>“Some architectures provide a pair of operations similar to <img alt="Image" height="11" src="images/B9780124159501000148/fx020.jpg" width="19"/>()/<img alt="Image" height="12" src="images/B9780124159501000148/fx006.jpg" width="97"/> called <i>load-linked/store-conditional</i>. In general, the <i>load-linked</i> method marks a location as loaded, and the <i>store-conditional</i> method fails if another thread modified that location since it was loaded. See Appendix <a href="B978012415950100032X.xhtml">B</a>.”</p></div></section></footer></section></body></html>