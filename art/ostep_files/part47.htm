<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>5.4 Why? Motivating the API</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part46.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part48.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 16pt;text-indent: 0pt;text-align: left;">5.4 Why? Motivating the API</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Of course, one big question you might have: why would we build such an odd interface to what should be the simple act of creating a new process? Well, as it turns out, the separation of <span class="s41">fork() </span>and <span class="s41">exec() </span>is essential in building a U<span class="s7">NIX </span>shell, because it lets the shell run code <i>after </i>the call to <span class="s41">fork() </span>but before the call to <span class="s41">exec()</span>; this code can alter the environment of the about-to-be-run program, and thus enables a variety of interesting features to be readily built.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 66pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: G<span class="s7">ETTING </span>I<span class="s7">T </span>R<span class="s7">IGHT </span>(L<span class="s7">AMPSON</span>’<span class="s7">S </span>L<span class="s7">AW</span>)</p><p style="padding-left: 8pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As Lampson states in his well-regarded “Hints for Computer Systems Design” [L83], “<b>Get it right</b>. Neither abstraction nor simplicity is a substi- tute for getting it right.” Sometimes, you just have to do the right thing, and when you do, it is way better than the alternatives. There are lots of ways to design APIs for process creation; however, the combination of <span class="s41">fork() </span>and <span class="s41">exec() </span>are simple and immensely powerful. Here, the U<span class="s7">NIX </span>designers simply got it right. And because Lampson so often “got it right”, we name the law in his honor.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">The shell is just a user program<span class="s35">4</span>. It shows you a <b>prompt </b>and then waits for you to type something into it. You then type a command (i.e., the name of an executable program, plus any arguments) into it; in most cases, the shell then figures out where in the file system the executable resides, calls <span class="s41">fork() </span>to create a new child process to run the command, calls some variant of <span class="s41">exec() </span>to run the command, and then waits for the command to complete by calling <span class="s41">wait()</span>. When the child completes, the shell returns from <span class="s41">wait() </span>and prints out a prompt again, ready for your next command.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">The separation of <span class="s41">fork() </span>and <span class="s41">exec() </span>allows the shell to do a whole bunch of useful things rather easily. For example:</p><p class="s38" style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; wc p3.c &gt; newfile.txt</p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">In the example above, the output of the program <span class="s41">wc </span>is <b>redirected </b>into the output file <span class="s41">newfile.txt </span>(the greater-than sign is how said redirec- tion is indicated). The way the shell accomplishes this task is quite sim- ple: when the child is created, before calling <span class="s41">exec()</span>, the shell closes <b>standard output </b>and opens the file <span class="s41">newfile.txt</span>. By doing so, any out- put from the soon-to-be-running program <span class="s41">wc </span>are sent to the file instead of the screen.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_030.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Figure <span style=" color: #00AEEF;">5.4 </span>shows a program that does exactly this. The reason this redi- rection works is due to an assumption about how the operating system manages file descriptors. Specifically, U<span class="s7">NIX </span>systems start looking for free file descriptors at zero. In this case, STDOUT FILENO will be the first available one and thus get assigned when <span class="s41">open() </span>is called. Subsequent writes by the child process to the standard output file descriptor, for ex- ample by routines such as <span class="s41">printf()</span>, will then be routed transparently to the newly-opened file instead of the screen.</p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Here is the output of running the <span class="s41">p4.c </span>program:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; ./p4</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; cat p4.output</p><p class="s38" style="padding-left: 94pt;text-indent: 0pt;text-align: left;">32  109  846 p4.c</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_031.png"/></span></p><p class="s12" style="padding-top: 2pt;padding-left: 68pt;text-indent: 13pt;line-height: 91%;text-align: justify;"><span class="s11">4</span>And there are lots of shells; <span class="s38">tcsh</span>, <span class="s38">bash</span>, and <span class="s38">zsh </span>to name a few. You should pick one, read its man pages, and learn more about it; all U<span class="s18">NIX </span>experts do.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">1  <span class="s38">#include &lt;stdio.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">2  <span class="s38">#include &lt;stdlib.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">3  <span class="s38">#include &lt;unistd.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">4  <span class="s38">#include &lt;string.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">5  <span class="s38">#include &lt;fcntl.h&gt;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6  <span class="s38">#include &lt;sys/wait.h&gt;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">7</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">8  <span class="s38">int</span></p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">9  </span>main(int argc, char <span class="s39">*</span>argv[])</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 7pt;text-align: left;">10  <span class="s38">{</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">11    <span class="s38">int rc = fork();</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">12     <span class="s38">if (rc &lt; 0) {    // fork failed; exit</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">13       <span class="s38">fprintf(stderr, &quot;fork failed\n&quot;);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">14       <span class="s38">exit(1);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">15     <span class="s38">} else if (rc == 0) { // child: redirect standard output to a file</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">16       <span class="s38">close(STDOUT_FILENO);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">17       <span class="s38">open(&quot;./p4.output&quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span></p><p class="s37" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">18</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">19       <span class="s38">// now exec &quot;wc&quot;...</span></p><p class="s38" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">20       </span>char <span class="s39">*</span>myargs[3];</p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;line-height: 8pt;text-align: left;">21       <span class="s38">myargs[0] = strdup(&quot;wc&quot;);  // program: &quot;wc&quot; (word count)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">22       <span class="s38">myargs[1] = strdup(&quot;p4.c&quot;); // argument: file to count</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">23        <span class="s38">myargs[2] = NULL;     // marks end of array</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">24       <span class="s38">execvp(myargs[0], myargs); // runs word count</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">25     <span class="s38">} else {      // parent goes down this path (main)</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">26       <span class="s38">int wc = wait(NULL);</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">27    <span class="s38">}</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">28    <span class="s38">return 0;</span></p><p class="s37" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">29  <span class="s38">}</span></p><p style="padding-left: 76pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 5.4: <span class="s52">p4.c</span><b>: All Of The Above With Redirection</b></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">You’ll notice (at least) two interesting tidbits about this output. First, when <span class="s41">p4 </span>is run, it looks as if nothing has happened; the shell just prints the command prompt and is immediately ready for your next command. However, that is not the case; the program <span class="s41">p4 </span>did indeed call <span class="s41">fork() </span>to create a new child, and then run the <span class="s41">wc </span>program via a call to <span class="s41">execvp()</span>. You don’t see any output printed to the screen because it has been redi- rected to the file <span class="s41">p4.output</span>. Second, you can see that when we <span class="s41">cat </span>the output file, all the expected output from running <span class="s41">wc </span>is found. Cool, right? U<span class="s7">NIX </span>pipes are implemented in a similar way, but with the <span class="s41">pipe() </span>system call. In this case, the output of one process is connected to an in- kernel <b>pipe </b>(i.e., queue), and the input of another process is connected to that same pipe; thus, the output of one process seamlessly is used as input to the next, and long and useful chains of commands can be strung together. As a simple example, consider the looking for a word in a file, and then counting how many times said word occurs; with pipes and the utilities <span class="s41">grep </span>and <span class="s41">wc</span>, it is easy – just type <span class="s41">grep foo file | wc -l</span></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">into the command prompt and marvel at the result.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Finally, while we just have sketched out the process API at a high level, there is a lot more detail about these calls out there to be learned and digested; we’ll learn more, for example, about file descriptors when we talk about file systems in the third part of the book. For now, suffice it to say that the <span class="s41">fork()/exec() </span>combination is a powerful way to create and manipulate processes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 70pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>RTFM – R<span class="s45">EAD </span>T<span class="s45">HE </span>M<span class="s45">AN </span>P<span class="s45">AGES</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Many times in this book, when referring to a particular system call or library call, we’ll tell you to read the <b>manual pages</b>, or <b>man pages </b>for short. Man pages are the original form of documentation that exist on U<span class="s7">NIX </span>systems; realize that they were created before the thing called <b>the web </b>existed.</p><p style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Spending some time reading man pages is a key step in the growth of a systems programmer; there are tons of useful tidbits hidden in those pages. Some particularly useful pages to read are the man pages for whichever shell you are using (e.g., <b>tcsh</b>, or <b>bash</b>), and certainly for any system calls your program makes (in order to see what return values and error conditions exist).</p><p style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Finally, reading the man pages can save you some embarrassment. When you ask colleagues about some intricacy of <span class="s41">fork()</span>, they may simply reply: “RTFM.” This is your colleagues’ way of gently urging you to Read The Man pages. The F in RTFM just adds a little color to the phrase...</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part46.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part48.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
