<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.10  Recovery in Main-Memory Databases</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part355.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part357.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">19.10  <span style=" color: #00AEEF;">Recovery in Main-Memory Databases</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Main-memory databases support fast querying and updates, since main memory sup- ports very fast random access. However, the contents of main memory are lost on system failure, as well as on system shutdown. Thus, data must be additionally stored on persistent or stable storage to allow recovery of data when the system comes back up.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Traditional recovery algorithms can be used with main-memory databases. Log records for updates have to be output to stable storage. On recovery, the database has to be reloaded from disk and log records applied to restore the database state. Data blocks that have been modiﬁed by committed transactions still have to be written to disk, and checkpoints have to be performed, so that the amount of log that has to be replayed at recovery time is reduced.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">However, some optimizations are possible with main-memory databases.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">With main-memory databases, indices can be rebuilt very quickly after the under- lying relation is brought into memory and recovery has been performed on the relation. Thus, many systems do not perform any redo logging actions for index updates. Undo logging to support transaction abort is still required, but such undo</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-left: 43pt;text-indent: 0pt;text-align: center;"><a name="bookmark405">Note 19.2 </a><span class="s146">NON-VOLATILE RAM</span><a name="bookmark445">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 9pt;text-indent: 0pt;text-align: justify;">Some newly launched non-volatile storage systems support direct access to indi- vidual words, instead of requiring that an entire page must be read or written. Such non-volatile <span class="s44">RAM </span>systems, also called <span class="s63">storage class memory </span>(<span class="s64">SCM</span>), support very fast random access, with latency and bandwidth comparable to <span class="s44">RAM </span>access. The contents of such non-volatile <span class="s44">RAM </span>survive power failures, like ﬂash, but oﬀer direct access, like <span class="s44">RAM</span>. In terms of capacity and cost per megabyte, current generation non-volatile storage lies between <span class="s44">RAM </span>and ﬂash storage.</p><p style="padding-left: 9pt;text-indent: 17pt;text-align: justify;">Recovery techniques have been specialized to deal with <span class="s44">NVRAM </span>storage. In particular, redo logging can be avoided, although undo logging may be used to deal with transaction aborts. Issues such as atomic updates to <span class="s44">NVRAM </span>have to be taken into consideration when designing such recovery techniques.</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">log records can be kept in memory, and they need not be written to the log on stable storage.</p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Several main-memory databases reduce logging overhead by performing only redo logging. Checkpoints are taken periodically, either ensuring that uncommitted data are not written to disk or avoiding in-place updates of records by creating multiple versions of records. Recovery consists of reloading the checkpoint and then performing redo operations. (Record versions created by uncommitted trans- actions must be garbage collected eventually.)</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Fast recovery is crucial for main-memory databases, since the entire database has to be loaded and recovery actions performed before any transaction processing can be done.</span></p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">Several main-memory databases therefore perform recovery in parallel using multiple cores, to minimize recovery time. To do so, data and log records may be partitioned, with log records of a partition aﬀecting only data in the corresponding data partition. Each core is then responsible for performing recovery operations for a particular partition, and it can perform recovery operations in parallel with other cores.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part355.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part357.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
