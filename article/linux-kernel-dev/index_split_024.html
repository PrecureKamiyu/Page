<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1011741" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_68"><span class="bold">15. The Process Address Space</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1011912"> </div>
<p class="calibre_2"><a href="index_split_021.html#filepos778361">Chapter 12</a>, “Memory Management,” looked at how the kernel manages physical memory. In addition to managing its own memory, the kernel also has to manage the memory of user-space processes. This memory is called the <em class="calibre4">process address space</em>, which is the representation of memory given to each user-space process on the system. Linux is a virtual memory operating system, and thus the resource of memory is virtualized among the processes on the system. An individual process’s view of memory is as if it alone has full access to the system’s physical memory. More important, the address space of even a single process can be much larger than physical memory. This chapter discusses how the kernel manages the process address space.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1012802"> </div>
<h3 class="calibre_21"><span class="bold">Address Spaces</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The process address space consists of the virtual memory addressable by a process and the addresses within the virtual memory that the process is allowed to use. Each process is given a <em class="calibre4">flat</em> 32- or 64-bit address space, with the size depending on the architecture. The term <em class="calibre4">flat</em> denotes that the address space exists in a single range. (For example, a 32-bit address space extends from the address 0 to 4294967295.) Some operating systems provide a <em class="calibre4">segmented address space</em>, with addresses existing not in a single linear range, but instead in multiple segments. Modern virtual memory operating systems generally have a flat memory model and not a segmented one. Normally, this flat address space is unique to each process. A memory address in one process’s address space is completely unrelated to that same memory address in another process’s address space. Both processes can have different data at the same address in their respective address spaces. Alternatively, processes can elect to share their address space with other processes. We know these processes as <em class="calibre4">threads</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">A memory address is a given value within the address space, such as <code class="calibre6"><span class="calibre7">4021f000</span></code>. This particular value identifies a specific byte in a process’s 32-bit address space. Although a process can address up to 4GB of memory (with a 32-bit address space), it doesn’t have permission to access all of it. The interesting part of the address space is the intervals of memory addresses, such as <code class="calibre6"><span class="calibre7">08048000-0804c000</span></code>, that the process has permission to access. <a id="filepos1014619"></a>These intervals of legal addresses are called <em class="calibre4">memory areas</em>. The process, through the kernel, can dynamically add and remove memory areas to its address space.</p><div class="calibre_3"> </div>
<p class="calibre_2">The process can access a memory address only in a valid memory area. Memory areas have associated permissions, such as readable, writable, and executable, that the associated process must respect. If a process accesses a memory address not in a valid memory area, or if it accesses a valid area in an invalid manner, the kernel kills the process with the dreaded “Segmentation Fault” message.</p><div class="calibre_3"> </div>
<p class="calibre_2">Memory areas can contain all sorts of goodies, such as</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A memory map of the executable file’s code, called the <em class="calibre4">text section.</em></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A memory map of the executable file’s initialized global variables, called the <em class="calibre4">data section.</em></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A memory map of the zero page (a page consisting of all zeros, used for purposes such as this) containing uninitialized global variables, called the <em class="calibre4">bss section</em>.<sup class="calibre8"><a id="filepos1015956" href="#filepos1016072">1</a></sup></p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1016072" href="#filepos1015956">1</a></sup>
<em class="calibre4">The term “BSS” is historical. It stands for</em> block started by symbol. <em class="calibre4">Uninitialized variables are not stored in the executable object because they do not have any associated value. But the C standard decrees that uninitialized global variables are assigned certain default values (basically, all zeros), so the kernel loads the variables (without value) from the executable into memory and maps the zero page over the area, thereby giving the variables the value zero, without having to waste space in the object file with explicit initializations.</em></p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A memory map of the zero page used for the process’s user-space stack. (Do not confuse this with the process’s kernel stack, which is separate and maintained and used by the kernel.)</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• An additional text, data, and bss section for each shared library, such as the C library and dynamic linker, loaded into the process’s address space.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Any memory mapped files.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Any shared memory segments.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Any anonymous memory mappings, such as those associated with <code class="calibre6"><span class="calibre7">malloc().</span></code><sup class="calibre8"><a id="filepos1017628" href="#filepos1017744">2</a></sup></p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1017744" href="#filepos1017628">2</a></sup>
<em class="calibre4">Newer versions of glibc implement</em>
<code class="calibre6"><span class="calibre7">malloc()</span></code>
<em class="calibre4">via</em>
<code class="calibre6"><span class="calibre7">mmap()</span></code>, <em class="calibre4">in addition to</em>
<code class="calibre6"><span class="calibre7">brk()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">All valid addresses in the process address space exist in exactly one area; memory areas do not overlap. As you can see, there is a separate memory area for each different chunk of memory in a running process: the stack, object code, global variables, mapped file, and so on.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1018381"> </div>
<h3 class="calibre_21"><span class="bold">The Memory Descriptor</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The kernel represents a process’s address space with a data structure called the <em class="calibre4">memory descriptor</em>. This structure contains all the information related to the process address space. The memory descriptor is represented by <code class="calibre6"><span class="calibre7">struct mm_struct</span></code> and defined in <code id="filepos1018809" class="calibre6"><span class="calibre7">&lt;linux/mm_types.h&gt;</span></code>. Let’s look at the memory descriptor, with comments added describing each field:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00212.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">mm_users</span></code> field is the number of processes using this address space. For example, if two threads share this address space, <code class="calibre6"><span class="calibre7">mm_users</span></code> is equal to two. The <code class="calibre6"><span class="calibre7">mm_count</span></code> field is the primary reference count for the <code class="calibre6"><span class="calibre7">mm_struct</span></code>. All <code class="calibre6"><span class="calibre7">mm_users</span></code> equate to one increment of <code class="calibre6"><span class="calibre7">mm_count</span></code>. Thus, in the previous example, <code class="calibre6"><span class="calibre7">mm_count</span></code> is only one. If nine threads shared an address space, <code class="calibre6"><span class="calibre7">mm_users</span></code> would be nine, but again <code class="calibre6"><span class="calibre7">mm_count</span></code> would be only one. Only when <code class="calibre6"><span class="calibre7">mm_users</span></code> reaches zero (when all threads using an address space exit) is <code class="calibre6"><span class="calibre7">mm_count</span></code> decremented. When <code class="calibre6"><span class="calibre7">mm_count</span></code> finally reaches zero, there are no remaining references to <a id="filepos1020118"></a>this <code class="calibre6"><span class="calibre7">mm_struct</span></code>, and it is freed. When the kernel operates on an address space and needs to bump its associated reference count, the kernel increments <code class="calibre6"><span class="calibre7">mm_count</span></code>. Having two counters enables the kernel to differentiate between the main usage counter (<code class="calibre6"><span class="calibre7">mm_count</span></code>) and the number of processes using the address space (<code class="calibre6"><span class="calibre7">mm_users</span></code>).</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">mmap</span></code> and <code class="calibre6"><span class="calibre7">mm_rb</span></code> fields are different data structures that contain the same thing: all the memory areas in this address space. The former stores them in a linked list, whereas the latter stores them in a red-black tree. A red-black tree is a type of binary tree; like all binary trees, searching for a given element is an <code class="calibre6"><span class="calibre7">O(log n)</span></code> operation. For further discussion on red-black trees, see “<a href="#filepos1038462">Lists and Trees of Memory Areas</a>,” later in this chapter.</p><div class="calibre_3"> </div>
<p class="calibre_2">Although the kernel would normally avoid the extra baggage of using two data structures to organize the same data, the redundancy comes in handy here. The <code class="calibre6"><span class="calibre7">mmap</span></code> data structure, as a linked list, allows for simple and efficient traversing of all elements. On the other hand, the <code class="calibre6"><span class="calibre7">mm_rb</span></code> data structure, as a red-black tree, is more suitable to searching for a given element. Memory areas are discussed in more detail later in this chapter. The kernel isn’t duplicating the <code class="calibre6"><span class="calibre7">mm_struct</span></code> structures; just the containing objects. Overlaying a linked list onto a tree, and using both to access the same set of data, is sometimes called a <em class="calibre4">threaded tree</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">All of the <code class="calibre6"><span class="calibre7">mm_struct</span></code> structures are strung together in a doubly linked list via the <code class="calibre6"><span class="calibre7">mmlist</span></code> field. The initial element in the list is the <code class="calibre6"><span class="calibre7">init_mm</span></code> memory descriptor, which describes the address space of the init process. The list is protected from concurrent access via the <code class="calibre6"><span class="calibre7">mmlist_lock</span></code>, which is defined in <code class="calibre6"><span class="calibre7">kernel/fork.c</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1022630"> </div>
<h4 class="calibre_27"><span class="calibre3">Allocating a Memory Descriptor</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The memory descriptor associated with a given task is stored in the <code class="calibre6"><span class="calibre7">mm</span></code> field of the task’s process descriptor. (The process descriptor is represented by the <code class="calibre6"><span class="calibre7">task_struct</span></code> structure, defined in <code class="calibre6"><span class="calibre7">&lt;linux/sched.h&gt;</span></code>.) Thus, <code class="calibre6"><span class="calibre7">current-&gt;mm</span></code> is the current process’s memory descriptor. The <code class="calibre6"><span class="calibre7">copy_mm()</span></code> function copies a parent’s memory descriptor to its child during <code class="calibre6"><span class="calibre7">fork()</span></code>. The <code class="calibre6"><span class="calibre7">mm_struct</span></code> structure is allocated from the <code class="calibre6"><span class="calibre7">mm_cachep</span></code> slab cache via the <code class="calibre6"><span class="calibre7">allocate_mm()</span></code> macro in <code class="calibre6"><span class="calibre7">kernel/fork.c</span></code>. Normally, each process receives a unique <code class="calibre6"><span class="calibre7">mm_struct</span></code> and thus a unique process address space.</p><div class="calibre_3"> </div>
<p class="calibre_2">Processes may elect to share their address spaces with their children by means of the <code class="calibre6"><span class="calibre7">CLONE_VM</span></code> flag to <code class="calibre6"><span class="calibre7">clone()</span></code>. The process is then called a <em class="calibre4">thread</em>. Recall from <a href="index_split_012.html#filepos167044">Chapter 3</a>, “Process Management,” that this is essentially the <em class="calibre4">only</em> difference between normal processes and so-called threads in Linux; the Linux kernel does not otherwise differentiate between them. Threads are regular processes to the kernel that merely share certain resources.</p><div class="calibre_3"> </div>
<p class="calibre_2">In the case that <code class="calibre6"><span class="calibre7">CLONE_VM</span></code> is specified, <code class="calibre6"><span class="calibre7">allocate_mm()</span></code> is <em class="calibre4">not</em> called, and the process’s <code class="calibre6"><span class="calibre7">mm</span></code> field is set to point to the memory descriptor of its parent via this logic in <code class="calibre6"><span class="calibre7">copy_mm()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00213.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1024878"> </div>
<h4 class="calibre_27"><span class="calibre3">Destroying a Memory Descriptor</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When the process associated with a specific address space exits, the <code class="calibre6"><span class="calibre7">exit_mm()</span></code>, defined in <code class="calibre6"><span class="calibre7">kernel/exit.c</span></code>, function is invoked. This function performs some housekeeping and updates some statistics. It then calls <code class="calibre6"><span class="calibre7">mmput()</span></code>, which decrements the memory descriptor’s <code class="calibre6"><span class="calibre7">mm_users</span></code> user counter. If the user count reaches zero, <code class="calibre6"><span class="calibre7">mmdrop()</span></code> is called to decrement the <code class="calibre6"><span class="calibre7">mm_count</span></code> usage counter. If <em class="calibre4">that</em> counter is finally zero, the <code class="calibre6"><span class="calibre7">free_mm()</span></code> macro is invoked to return the <code class="calibre6"><span class="calibre7">mm_struct</span></code> to the <code class="calibre6"><span class="calibre7">mm_cachep</span></code> slab cache via <code class="calibre6"><span class="calibre7">kmem_cache_free()</span></code>, because the memory descriptor does not have any users.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1025995"> </div>
<h4 class="calibre_27"><span class="calibre3">The <code class="calibre6"><span class="calibre7">mm_struct</span></code> and Kernel Threads</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Kernel threads do not have a process address space and therefore do not have an associated memory descriptor. Thus, the <code class="calibre6"><span class="calibre7">mm</span></code> field of a kernel thread’s process descriptor is <code class="calibre6"><span class="calibre7">NULL</span></code>. This is the <em class="calibre4">definition</em> of a kernel thread—processes that have no user context.</p><div class="calibre_3"> </div>
<p class="calibre_2">This lack of an address space is fine because kernel threads do not ever access any user-space memory. (Whose would they access?) Because kernel threads do not have any pages in user-space, they do not deserve their own memory descriptor and page tables. (Page tables are discussed later in the chapter.) Despite this, kernel threads need some of the data, such as the page tables, even to access kernel memory. To provide kernel threads the needed data, without wasting memory on a memory descriptor and page tables, or wasting processor cycles to switch to a new address space whenever a kernel thread begins running, kernel threads use the memory descriptor of whatever task ran previously.</p><div class="calibre_3"> </div>
<p class="calibre_2">Whenever a process is scheduled, the process address space referenced by the process’s <code class="calibre6"><span class="calibre7">mm</span></code> field is loaded. The <code class="calibre6"><span class="calibre7">active_mm</span></code> field in the process descriptor is then updated to refer to the new address space. Kernel threads do not have an address space and <code class="calibre6"><span class="calibre7">mm</span></code> is <code class="calibre6"><span class="calibre7">NULL</span></code>. Therefore, when a kernel thread is scheduled, the kernel notices that <code class="calibre6"><span class="calibre7">mm</span></code> is <code class="calibre6"><span class="calibre7">NULL</span></code> and keeps the previous process’s address space loaded. The kernel then updates the <code class="calibre6"><span class="calibre7">active_mm</span></code> field of the kernel thread’s process descriptor to refer to the previous process’s memory descriptor. The kernel thread can then use the previous process’s page tables as needed. Because kernel threads do not access user-space memory, they make use of only the information in the address space pertaining to kernel memory, which is the same for all processes.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1028429"> </div>
<h3 class="calibre_21"><span class="bold">Virtual Memory Areas</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The memory area structure, <code class="calibre6"><span class="calibre7">vm_area_struct</span></code>, represents memory areas. It is defined in <code class="calibre6"><span class="calibre7">&lt;linux/mm_types.h&gt;</span></code>. In the Linux kernel, memory areas are often called <em class="calibre4">virtual memory areas</em> (abbreviated <em class="calibre4">VMAs</em>).</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structure describes a single memory area over a contiguous interval in a given address space. The kernel treats each memory area as a unique memory object. Each memory area possesses certain properties, such as permissions and a set of associated operations. In this manner, each VMA structure can represent different types of memory areas—for example, memory-mapped files or the process’s user-space stack. This is similar to the object-oriented approach taken by the VFS layer (see <a href="index_split_022.html#filepos870716">Chapter 13</a>). Here’s the structure, with comments added describing each field:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00214.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Recall that each memory descriptor is associated with a unique interval in the process’s address space. The <code class="calibre6"><span class="calibre7">vm_start</span></code> field is the initial (lowest) address in the interval, and the <code class="calibre6"><span class="calibre7">vm_end</span></code> field is the first byte after the final (highest) address in the interval. That is, <code class="calibre6"><span class="calibre7">vm_start</span></code> is the inclusive start, and <code class="calibre6"><span class="calibre7">vm_end</span></code> is the exclusive end of the memory interval. Thus, <code class="calibre6"><span class="calibre7">vm_end – vm_start</span></code> is the length in bytes of the memory area, which exists over the interval <code class="calibre6"><span class="calibre7">[vm_start, vm_end)</span></code>. Intervals in different memory areas in the same address space cannot overlap.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">vm_mm</span></code> field points to this VMA’s associated <code class="calibre6"><span class="calibre7">mm_struct</span></code>. Note that each VMA is unique to the <code class="calibre6"><span class="calibre7">mm_struct</span></code> with which it is associated. Therefore, even if two separate processes map the same file into their respective address spaces, each has a unique <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> to identify its unique memory area. Conversely, two threads that share an address space also share all the <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structures therein.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1031158"> </div>
<h4 class="calibre_27"><span class="calibre3">VMA Flags</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1031269"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">vm_flags</span></code> field contains bit flags, defined in <code class="calibre6"><span class="calibre7">&lt;linux/mm.h&gt;</span></code>, that specify the behavior of and provide information about the pages contained in the memory area. Unlike permissions associated with a specific physical page, the VMA flags specify behavior for which the kernel is responsible, not the hardware. Furthermore, <code class="calibre6"><span class="calibre7">vm_flags</span></code> contains information that relates to each page in the memory area, or the memory area as a whole, and not specific individual pages. <a href="#filepos1032065">Table 15.1</a> is a listing of the possible <code class="calibre6"><span class="calibre7">vm_flags</span></code> values.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1032065"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 15.1. <code class="calibre6"><span class="calibre15">vm_flags</span></code></span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00215.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos1032370"></a>Let’s look at some of the more important and interesting flags in depth. The <code class="calibre6"><span class="calibre7">VM_READ</span></code>, <code class="calibre6"><span class="calibre7">VM_WRITE</span></code>, and <code class="calibre6"><span class="calibre7">VM_EXEC</span></code> flags specify the usual read, write, and execute permissions for the pages <em class="calibre4">in this particular memory area</em>. They are combined as needed to form the appropriate access permissions that a process accessing this VMA must respect. For example, the object code for a process might be mapped with <code class="calibre6"><span class="calibre7">VM_READ</span></code> and <code class="calibre6"><span class="calibre7">VM_EXEC</span></code> but not <code class="calibre6"><span class="calibre7">VM_WRITE</span></code>. On the other hand, the data section from an executable object would be mapped <code class="calibre6"><span class="calibre7">VM_READ</span></code> and <code class="calibre6"><span class="calibre7">VM_WRITE</span></code>, but <code class="calibre6"><span class="calibre7">VM_EXEC</span></code> would make little sense. Meanwhile, a read-only memory mapped data file would be mapped with only the <code class="calibre6"><span class="calibre7">VM_READ</span></code> flag.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">VM_SHARED</span></code> flag specifies whether the memory area contains a mapping that is shared among multiple processes. If the flag is set, it is intuitively called a <em class="calibre4">shared mapping</em>. If the flag is not set, only a single process can view this particular mapping, and it is called a <em class="calibre4">private mapping</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">VM_IO</span></code> flag specifies that this memory area is a mapping of a device’s I/O space. This field is typically set by device drivers when <code class="calibre6"><span class="calibre7">mmap()</span></code> is called on their I/O space. It specifies, among other things, that the memory area must not be included in any process’s core dump. The <code class="calibre6"><span class="calibre7">VM_RESERVED</span></code> flag specifies that the memory region must not be swapped out. It is also used by device driver mappings.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">VM_SEQ_READ</span></code> flag provides a hint to the kernel that the application is performing sequential (that is, linear and contiguous) reads in this mapping. The kernel can then opt to increase the read-ahead performed on the backing file. The <code class="calibre6"><span class="calibre7">VM_RAND_READ</span></code> flag specifies the exact opposite: that the application is performing relatively random (that is, not sequential) reads in this mapping. The kernel can then opt to decrease or altogether disable read-ahead on the backing file. These flags are set via the <code class="calibre6"><span class="calibre7">madvise()</span></code> system call with the <code class="calibre6"><span class="calibre7">MADV_SEQUENTIAL</span></code> and <code class="calibre6"><span class="calibre7">MADV_RANDOM</span></code> flags, respectively. Read-ahead is the act of reading sequentially ahead of requested data, in hopes that the additional data will be needed soon. Such behavior is beneficial if applications are reading data sequentially. If data access patterns are random, however, read-ahead is not effective.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1035501"> </div>
<h4 class="calibre_27"><span class="calibre3">VMA Operations</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">vm_ops</span></code> field in the <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structure points to the table of operations associated with a given memory area, which the kernel can invoke to manipulate the VMA. The <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> acts as a generic object for representing any type of memory area, and the operations table describes the specific methods that can operate on this particular instance of the object.</p><div class="calibre_3"> </div>
<p class="calibre_2">The operations table is represented by struct <code class="calibre6"><span class="calibre7">vm_operations_struct</span></code> and is defined in <code class="calibre6"><span class="calibre7">&lt;linux/mm.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00216.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<blockquote class="calibre_33"><p class="calibre_32"><a id="filepos1036480"></a>Here’s a description for each individual method:</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void open(struct vm_area_struct *area)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">This function is invoked when the given memory area is added to an address space.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">void close(struct vm_area_struct *area)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">This function is invoked when the given memory area is removed from an address space.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int fault(struct vm_area_sruct *area, struct vm_fault *vmf)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">This function is invoked by the page fault handler when a page that is not present in physical memory is accessed.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int page_mkwrite(struct vm_area_sruct *area, struct vm_fault *vmf)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">This function is invoked by the page fault handler when a page that was read-only is being made writable.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• <code class="calibre6"><span class="calibre7">int access(struct vm_area_struct *vma, unsigned long address, void<br class="calibre1"/>*buf, int len, int write)</span></code></p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre_33"><p class="calibre_32">This function is invoked by <code class="calibre6"><span class="calibre7">access_process_vm()</span></code> when <code class="calibre6"><span class="calibre7">get_user_pages()</span></code> fails.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1038462"> </div>
<h4 class="calibre_27"><span class="calibre3">Lists and Trees of Memory Areas</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">As discussed, memory areas are accessed via both the <code class="calibre6"><span class="calibre7">mmap</span></code> and the <code class="calibre6"><span class="calibre7">mm_rb</span></code> fields of the memory descriptor. These two data structures independently point to all the memory area objects associated with the memory descriptor. In fact, they both contain pointers to the same <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structures, merely represented in different ways.</p><div class="calibre_3"> </div>
<p class="calibre_2">The first field, <code class="calibre6"><span class="calibre7">mmap</span></code>, links together all the memory area objects in a singly linked list. Each <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structure is linked into the list via its <code class="calibre6"><span class="calibre7">vm_next</span></code> field. The areas are sorted by ascending address. The first memory area is the <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structure to which <code class="calibre6"><span class="calibre7">mmap</span></code> points. The last structure points to <code class="calibre6"><span class="calibre7">NULL</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The second field, <code class="calibre6"><span class="calibre7">mm_rb</span></code>, links together all the memory area objects in a red-black tree. The root of the red-black tree is <code class="calibre6"><span class="calibre7">mm_rb</span></code>, and each <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structure in this address space is linked to the tree via its <code class="calibre6"><span class="calibre7">vm_rb</span></code> field.</p><div class="calibre_3"> </div>
<p class="calibre_2">A <em class="calibre4">red-black tree</em> is a type of balanced binary tree. Each element in a red-black tree is called a <em class="calibre4">node</em>. The initial node is called the <em class="calibre4">root</em> of the tree. Most nodes have two children: a left child and a right child. Some nodes have only one child, and the final nodes, called <em class="calibre4">leaves</em>, have no children. For any node, the elements to the left are smaller in value, whereas the elements to the right are larger in value. Furthermore, each node is assigned a color (red or black, hence the name of this tree) according to two rules: The children of a red node are black, and every path through the tree from a node to a leaf must contain the same number of black nodes. The root node is always red. Searching of, insertion to, and deletion from the tree is an <code class="calibre6"><span class="calibre7">O(log(n))</span></code> operation.</p><div class="calibre_3"> </div>
<p class="calibre_2">The linked list is used when every node needs to be traversed. The red-black tree is used when locating a specific memory area in the address space. In this manner, the kernel <a id="filepos1041157"></a>uses the redundant data structures to provide optimal performance regardless of the operation performed on the memory areas.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1041332"> </div>
<h4 class="calibre_27"><span class="calibre3">Memory Areas in Real Life</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Let’s look at a particular process’s address space and the memory areas inside. This task uses the useful <code class="calibre6"><span class="calibre7">/proc</span></code> filesystem and the <code class="calibre6"><span class="calibre7">pmap</span></code>(1) utility. The example is a simple user-space program, which does absolutely nothing of value, except act as an example:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int main(int argc, char *argv[])<br class="calibre1"/>{<br class="calibre1"/>        return 0;<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Take note of a few of the memory areas in this process’s address space. First, you know there is the text section, data section, and bss. Assuming this process is dynamically linked with the C library, these three memory areas also exist for <code class="calibre6"><span class="calibre7">libc.so</span></code> and again for <code class="calibre6"><span class="calibre7">ld.so</span></code>. Finally, there is also the process’s stack.</p><div class="calibre_3"> </div>
<p class="calibre_2">The output from <code class="calibre6"><span class="calibre7">/proc/&lt;pid&gt;/maps</span></code> lists the memory areas in this process’s address space:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00217.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The data is in the form</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">start-end permission   offset   major:minor   inode   file</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">pmap</span></code>(1) utility<sup class="calibre8"><a id="filepos1043133" href="#filepos1043292">3</a></sup> formats this information in a bit more readable manner:</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos1043292" href="#filepos1043133">3</a></sup>
<em class="calibre4">The</em>
<code class="calibre6"><span class="calibre7">pmap</span></code><em class="calibre4">(1) utility displays a formatted listing of a process’s memory areas. It is a bit more readable than the <code class="calibre6"><span class="calibre7">/proc</span></code> output, but it is the same information. It is found in newer versions of the procps package.</em></p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00218.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos1043788"></a>The first three rows are the text section, data section, and bss of <code class="calibre6"><span class="calibre7">libc.so</span></code>, the C library. The next two rows are the text and data section of our executable object. The following three rows are the text section, data section, and bss for <code class="calibre6"><span class="calibre7">ld.so</span></code>, the dynamic linker. The last row is the process’s stack.</p><div class="calibre_3"> </div>
<p class="calibre_2">Note how the text sections are all readable and executable, which is what you expect for object code. On the other hand, the data section and bss (which both contain global variables) are marked readable and writable, but not executable. The stack is, naturally, readable, writable, and executable—not of much use otherwise.</p><div class="calibre_3"> </div>
<p class="calibre_2">The entire address space takes up about 1340KB, but only 40KB are writable and private. If a memory region is shared or nonwritable, the kernel keeps only one copy of the backing file in memory. This might seem like common sense for shared mappings, but the nonwritable case can come as a bit of a surprise. If you consider that a nonwritable mapping can never be changed (the mapping is only read from), it is clear that it is safe to load the image only once into memory. Therefore, the C library needs to occupy only 1212KB in physical memory and not 1212KB multiplied by every process using the library. Because this process has access to about 1340KB worth of data and code, yet consumes only about 40KB of physical memory, the space savings from such sharing is substantial.</p><div class="calibre_3"> </div>
<p class="calibre_2">Note the memory areas without a mapped file on device <code class="calibre6"><span class="calibre7">00:00</span></code> and inode zero. This is the zero page, which is a mapping that consists of all zeros. By mapping the zero page over a writable memory area, the area is in effect “initialized” to all zeros. This is important in that it provides a zeroed memory area, which is expected by the bss. Because the mapping is not shared, as soon as the process writes to this data, a copy is made (à la copy-on-write) and the value updated from zero.</p><div class="calibre_3"> </div>
<p class="calibre_2">Each of the memory areas associated with the process corresponds to a <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structure. Because the process was not a thread, it has a unique <code class="calibre6"><span class="calibre7">mm_struct</span></code> structure referenced from its <code class="calibre6"><span class="calibre7">task_struct</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1046377"> </div>
<h3 class="calibre_21"><span class="bold">Manipulating Memory Areas</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The kernel often has to perform operations on a memory area, such as whether a given address exists in a given VMA. These operations are frequent and form the basis of the <code class="calibre6"><span class="calibre7">mmap()</span></code> routine, which is covered in the next section. A handful of helper functions are defined to assist these jobs.</p><div class="calibre_3"> </div>
<p class="calibre_2">These functions are all declared in <code class="calibre6"><span class="calibre7">&lt;linux/mm.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1047021"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">find_vma()</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1047168"> </div>
<p class="calibre_2">The kernel provides a function, <code class="calibre6"><span class="calibre7">find_vma()</span></code>, for searching for the VMA in which a given memory address resides. It is defined in <code class="calibre6"><span class="calibre7">mm/mmap.c</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">struct vm_area_struct * find_vma(struct mm_struct *mm, unsigned long addr);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This function searches the given address space for the first memory area whose <code class="calibre6"><span class="calibre7">vm_end</span></code> field is greater than <code class="calibre6"><span class="calibre7">addr</span></code>. In other words, this function finds the first memory area that contains <code class="calibre6"><span class="calibre7">addr</span></code> or begins at an address greater than <code class="calibre6"><span class="calibre7">addr</span></code>. If no such memory area exists, the function returns <code class="calibre6"><span class="calibre7">NULL</span></code>. Otherwise, a pointer to the <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structure is returned. Note that because the returned VMA may start at an address greater than <code class="calibre6"><span class="calibre7">addr</span></code>, the given address does not necessarily lie <em class="calibre4">inside</em> the returned VMA. The result of the <code class="calibre6"><span class="calibre7">find_vma()</span></code> function is cached in the <code class="calibre6"><span class="calibre7">mmap_cache</span></code> field of the memory descriptor. Because of the probability of an operation on one VMA being followed by more operations on that same VMA, the cached results have a decent hit rate (about 30–40% in practice). Checking the cached result is quick. If the given address is <em class="calibre4">not</em> in the cache, you must search the memory areas associated with this memory descriptor for a match. This is done via the red-black tree:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00219.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos1049112"></a>The initial check of <code class="calibre6"><span class="calibre7">mmap_cache</span></code> tests whether the cached VMA contains the desired address. Note that simply checking whether the VMA’s <code class="calibre6"><span class="calibre7">vm_end</span></code> field is bigger than <code class="calibre6"><span class="calibre7">addr</span></code> would not ensure that this is the first such VMA that is larger than <code class="calibre6"><span class="calibre7">addr</span></code>. Thus, for the cache to be useful here, the given <code class="calibre6"><span class="calibre7">addr</span></code> must lie in the VMA—thankfully, this is just the sort of scenario in which consecutive operations on the same VMA would occur.</p><div class="calibre_3"> </div>
<p class="calibre_2">If the cache does not contain the desired VMA, the function must search the red-black tree. If the current VMA’s <code class="calibre6"><span class="calibre7">vm_end</span></code> is larger than <code class="calibre6"><span class="calibre7">addr</span></code>, the function follows the left child; otherwise, it follows the right child. The function terminates as soon as a VMA is found that contains <code class="calibre6"><span class="calibre7">addr</span></code>. If such a VMA is not found, the function continues traversing the tree and returns the first VMA it found that starts after <code class="calibre6"><span class="calibre7">addr</span></code>. If no VMA is ever found, <code class="calibre6"><span class="calibre7">NULL</span></code> is returned.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1050464"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">find_vma_prev()</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">find_vma_prev()</span></code> function works the same as <code class="calibre6"><span class="calibre7">find_vma()</span></code>, but it also returns the last VMA <em class="calibre4">before</em>
<code class="calibre6"><span class="calibre7">addr</span></code>. The function is also defined in <code class="calibre6"><span class="calibre7">mm/mmap.c</span></code> and declared in <code class="calibre6"><span class="calibre7">&lt;linux/mm.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00220.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">pprev</span></code> argument stores a pointer to the VMA preceding <code class="calibre6"><span class="calibre7">addr</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1051304"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">find_vma_intersection()</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">find_vma_intersection()</span></code> function returns the first VMA that overlaps a given address interval. The function is defined in <code class="calibre6"><span class="calibre7">&lt;linux/mm.h&gt;</span></code> because it is inline:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00221.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The first parameter is the address space to search, <code class="calibre6"><span class="calibre7">start_addr</span></code> is the start of the interval, and <code class="calibre6"><span class="calibre7">end_addr</span></code> is the end of the interval.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1052093"></a>Obviously, if <code class="calibre6"><span class="calibre7">find_vma()</span></code> returns <code class="calibre6"><span class="calibre7">NULL</span></code>, so would <code class="calibre6"><span class="calibre7">find_vma_intersection()</span></code>. If <code class="calibre6"><span class="calibre7">find_vma()</span></code> returns a valid VMA, however, <code class="calibre6"><span class="calibre7">find_vma_intersection()</span></code> returns the same VMA only if it does <em class="calibre4">not</em> start after the end of the given address range. If the returned memory area does start after the end of the given address range, the function returns <code class="calibre6"><span class="calibre7">NULL</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1052700"> </div>
<h3 class="calibre_21"><span class="bold"><code class="calibre18"><span class="calibre15">mmap()</span></code> and <code class="calibre18"><span class="calibre15">do_mmap()</span></code>: Creating an Address Interval</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">do_mmap()</span></code> function is used by the kernel to create a new linear address interval. Saying that this function creates a new VMA is not technically correct, because if the created address interval is adjacent to an existing address interval, and if they share the same permissions, the two intervals are merged into one. If this is not possible, a new VMA is created. In any case, <code class="calibre6"><span class="calibre7">do_mmap()</span></code> is the function used to add an address interval to a process’s address space—whether that means expanding an existing memory area or creating a new one.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">do_mmap()</span></code> function is declared in <code class="calibre6"><span class="calibre7">&lt;linux/mm.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00222.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">This function maps the file specified by <code class="calibre6"><span class="calibre7">file</span></code> at offset <code class="calibre6"><span class="calibre7">offset</span></code> for length <code class="calibre6"><span class="calibre7">len</span></code>. The <code class="calibre6"><span class="calibre7">file</span></code> parameter can be <code class="calibre6"><span class="calibre7">NULL</span></code> and <code class="calibre6"><span class="calibre7">offset</span></code> can be zero, in which case the mapping will not be backed by a file. In that case, this is called an <em class="calibre4">anonymous mapping</em>. If a file and offset are provided, the mapping is called a <em class="calibre4">file-backed mapping</em>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">addr</span></code> function optionally specifies the initial address from which to start the search for a free interval.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">prot</span></code> parameter specifies the access permissions for pages in the memory area. The possible permission flags are defined in <code class="calibre6"><span class="calibre7">&lt;asm/mman.h&gt;</span></code> and are unique to each supported architecture, although in practice each architecture defines the flags listed in <a href="#filepos1055080">Table 15.2</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1055080"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 15.2. Page Protection Flags</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00223.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos1055363"></a>The <code class="calibre6"><span class="calibre7">flags</span></code> parameter specifies flags that correspond to the remaining VMA flags. These flags specify the type and change the behavior of the mapping. They are also defined in <code class="calibre6"><span class="calibre7">&lt;asm/mman.h&gt;</span></code>. See <a href="#filepos1055720">Table 15.3</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1055720"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 15.3. Map Type Flags</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00224.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">If any of the parameters are invalid, <code class="calibre6"><span class="calibre7">do_mmap()</span></code> returns a negative value. Otherwise, a suitable interval in virtual memory is located. If possible, the interval is merged with an adjacent memory area. Otherwise, a new <code class="calibre6"><span class="calibre7">vm_area_struct</span></code> structure is allocated from the <code class="calibre6"><span class="calibre7">vm_area_cachep</span></code> slab cache, and the new memory area is added to the address space’s linked list and red-black tree of memory areas via the <code class="calibre6"><span class="calibre7">vma_link()</span></code> function. Next, the <code class="calibre6"><span class="calibre7">total_vm</span></code> field in the memory descriptor is updated. Finally, the function returns the initial address of the newly created address interval.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">do_mmap()</span></code> functionality is exported to user-space via the <code class="calibre6"><span class="calibre7">mmap()</span></code> system call. The <code class="calibre6"><span class="calibre7">mmap()</span></code> system call is defined as</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">void  * mmap2(void *start,<br class="calibre1"/>              size_t length,<br class="calibre1"/>              int prot,<br class="calibre1"/>              int flags,<br class="calibre1"/>              int fd,<br class="calibre1"/>              off_t pgoff)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This system call is named <code class="calibre6"><span class="calibre7">mmap2()</span></code> because it is the second variant of <code class="calibre6"><span class="calibre7">mmap()</span></code>. The original <code class="calibre6"><span class="calibre7">mmap()</span></code> took an offset in bytes as the last parameter; the current <code class="calibre6"><span class="calibre7">mmap2()</span></code> receives the offset in pages. This enables larger files with larger offsets to be mapped. The original <code id="filepos1058120" class="calibre6"><span class="calibre7">mmap()</span></code>, as specified by POSIX, is available from the C library as <code class="calibre6"><span class="calibre7">mmap()</span></code>, but is no longer implemented in the kernel proper, whereas the new version is available as <code class="calibre6"><span class="calibre7">mmap2()</span></code>. Both library calls use the <code class="calibre6"><span class="calibre7">mmap2()</span></code> system call, with the original <code class="calibre6"><span class="calibre7">mmap()</span></code> converting the offset from bytes to pages.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1058635"> </div>
<h3 class="calibre_21"><span class="bold"><code class="calibre18"><span class="calibre15">munmap()</span></code> and <code class="calibre18"><span class="calibre15">do_munmap()</span></code>: Removing an Address Interval</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">do_munmap()</span></code> function removes an address interval from a specified process address space. The function is declared in <code class="calibre6"><span class="calibre7">&lt;linux/mm.h&gt;</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The first parameter specifies the address space from which the interval starting at address <code class="calibre6"><span class="calibre7">start</span></code> of length <code class="calibre6"><span class="calibre7">len</span></code> bytes is removed. On success, zero is returned. Otherwise, a negative error code is returned.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">munmap()</span></code> system call is exported to user-space as a means to enable processes to remove address intervals from their address space; it is the complement of the <code class="calibre6"><span class="calibre7">mmap()</span></code> system call:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">int munmap(void *start, size_t length)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The system call is defined in <code class="calibre6"><span class="calibre7">mm/mmap.c</span></code> and acts as a simple wrapper to <code class="calibre6"><span class="calibre7">do_munmap()</span></code>:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00225.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1060358"> </div>
<h3 class="calibre_21"><span class="bold">Page Tables</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Although applications operate on virtual memory mapped to physical addresses, processors operate directly on those physical addresses. Consequently, when an application accesses a virtual memory address, it must first be converted to a physical address before the processor can resolve the request. Performing this lookup is done via page tables. Page tables work by splitting the virtual address into chunks. Each chunk is used as an index into a table. The table points to either another table or the associated physical page.</p><div class="calibre_3"> </div>
<p class="calibre_2">In Linux, the page tables consist of three levels. The multiple levels enable a sparsely populated address space, even on 64-bit machines. If the page tables were implemented as <a id="filepos1061229"></a>a single static array, their size on even 32-bit architectures would be enormous. Linux uses three levels of page tables even on architectures that do not support three levels in hardware. (For example, some hardware uses only two levels or implements a hash in hardware.) Using three levels is a sort of “greatest common denominator”—architectures with a less complicated implementation can simplify the kernel page tables as needed with compiler optimizations.</p><div class="calibre_3"> </div>
<p class="calibre_2">The top-level page table is the page global directory (PGD), which consists of an array of <code class="calibre6"><span class="calibre7">pgd_t</span></code> types. On most architectures, the <code class="calibre6"><span class="calibre7">pgd_t</span></code> type is an <code class="calibre6"><span class="calibre7">unsigned long</span></code>. The entries in the PGD point to entries in the second-level directory, the PMD.</p><div class="calibre_3"> </div>
<p class="calibre_2">The second-level page table is the page middle directory (PMD), which is an array of <code class="calibre6"><span class="calibre7">pmd_t</span></code> types. The entries in the PMD point to entries in the PTE.</p><div class="calibre_3"> </div>
<p class="calibre_2">The final level is called simply the page table and consists of page table entries of type <code class="calibre6"><span class="calibre7">pte_t</span></code>. Page table entries point to physical pages.</p><div class="calibre_3"> </div>
<p class="calibre_2">In most architectures, page table lookups are handled (at least to some degree) by hardware. In normal operation, hardware can handle much of the responsibility of using the page tables. The kernel must set things up, however, in such a way that the hardware is happy and can do its thing. <a href="#filepos1063076">Figure 15.1</a> diagrams the flow of a virtual to physical address lookup using page tables.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1063076"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 15.1. Virtual-to-physical address lookup.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00226.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Each process has its own page tables (threads share them, of course). The <code class="calibre6"><span class="calibre7">pgd</span></code> field of the memory descriptor points to the process’s page global directory. Manipulating and traversing page tables requires the <code class="calibre6"><span class="calibre7">page_table_lock</span></code>, which is located inside the associated memory descriptor.</p><div class="calibre_3"> </div>
<p class="calibre_2">Page table data structures are quite architecture-dependent and thus are defined in <code class="calibre6"><span class="calibre7">&lt;asm/page.h&gt;</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">Because nearly every access of a page in virtual memory must be resolved to its corresponding address in physical memory, the performance of the page tables is very critical. Unfortunately, looking up all these addresses in memory can be done only so quickly. To facilitate this, most processors implement a <em class="calibre4">translation lookaside buffer</em>, or simply <em class="calibre4">TLB</em>, <a id="filepos1064344"></a>which acts as a hardware cache of virtual-to-physical mappings. When accessing a virtual address, the processor first checks whether the mapping is cached in the TLB. If there is a hit, the physical address is immediately returned. Otherwise, if there is a miss, the page tables are consulted for the corresponding physical address.</p><div class="calibre_3"> </div>
<p class="calibre_2">Nonetheless, page table management is still a critical—and evolving—part of the kernel. Changes to this area in 2.6 include allocating parts of the page table out of high memory. Future possibilities include shared page tables with copy-on-write semantics. In that scheme, page tables would be shared between parent and child across a <code class="calibre6"><span class="calibre7">fork()</span></code>. When the parent or the child attempted to modify a particular page table entry, a copy would be created, and the two processes would no longer share that entry. Sharing page tables would remove the overhead of copying the page table entries on <code class="calibre6"><span class="calibre7">fork()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1065454"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">In this suspense-laden chapter, we looked at the abstraction of virtual memory provided to each process. We looked at how the kernel represents the process address space (via <code class="calibre6"><span class="calibre7">struct mm_struct</span></code>) and how the kernel represents regions of memory within that space (<code class="calibre6"><span class="calibre7">struct vm_area_struct</span></code>). We covered how the kernel creates (via <code class="calibre6"><span class="calibre7">mmap()</span></code>) and destroys (via <code class="calibre6"><span class="calibre7">munmap()</span></code>) these memory regions. Finally, we covered page tables. Because Linux is a virtual memory–based operating system, these concepts are essential to its operation and process model.</p><div class="calibre_3"> </div>
<p class="calibre_2">The next chapter covers the page cache, a general in-memory data cache used to fulfill all page I/O, and how the kernel performs page-based data writeback.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_69"></div>
</body></html>
