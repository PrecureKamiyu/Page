<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>A Cooperative Approach: Wait For System Calls</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part55.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part57.htm">下一个 &gt;</a></p><p class="s32" style="padding-top: 2pt;padding-left: 68pt;text-indent: 0pt;text-align: justify;">A Cooperative Approach: Wait For System Calls</p><p style="padding-top: 6pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">One approach that some systems have taken in the past (for example, early versions of the Macintosh operating system [M11], or the old Xerox Alto system [A79]) is known as the <b>cooperative </b>approach. In this style, the OS <i>trusts </i>the processes of the system to behave reasonably. Processes that run for too long are assumed to periodically give up the CPU so that the OS can decide to run some other task.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Thus, you might ask, how does a friendly process give up the CPU in this utopian world? Most processes, as it turns out, transfer control of the CPU to the OS quite frequently by making <b>system calls</b>, for example, to open a file and subsequently read it, or to send a message to another machine, or to create a new process. Systems like this often include an</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">IP</span>: D<span class="s7">EALING </span>W<span class="s7">ITH </span>A<span class="s7">PPLICATION </span>M<span class="s7">ISBEHAVIOR</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Operating systems often have to deal with misbehaving processes, those that either through design (maliciousness) or accident (bugs) attempt to do something that they shouldn’t. In modern systems, the way the OS tries to handle such malfeasance is to simply terminate the offender. One strike and you’re out! Perhaps brutal, but what else should the OS do when you try to access memory illegally or execute an illegal instruction?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">explicit <b>yield </b>system call, which does nothing except to transfer control to the OS so it can run other processes.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Applications also transfer control to the OS when they do something illegal. For example, if an application divides by zero, or tries to access memory that it shouldn’t be able to access, it will generate a <b>trap </b>to the OS. The OS will then have control of the CPU again (and likely terminate the offending process).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Thus, in a cooperative scheduling system, the OS regains control of the CPU by waiting for a system call or an illegal operation of some kind to take place. You might also be thinking: isn’t this passive approach less than ideal? What happens, for example, if a process (whether malicious, or just full of bugs) ends up in an infinite loop, and never makes a system call? What can the OS do then?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part55.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part57.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
