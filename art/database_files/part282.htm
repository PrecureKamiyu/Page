<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>15.3  Selection Operation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part281.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part283.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">15.3  <span style=" color: #00AEEF;">Selection Operation</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">In query processing, the <span class="s63">ﬁle scan </span>is the lowest-level operator to access data. File scans are search algorithms that locate and retrieve records that fulﬁll a selection condition. In relational systems, a ﬁle scan allows an entire relation to be read in those cases where the relation is stored in a single, dedicated ﬁle.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">15.3.1 Selections Using File Scans and Indices</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Consider a selection operation on a relation whose tuples are stored together in one ﬁle. The most straightforward way of performing a selection is as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 139pt;text-indent: -16pt;text-align: right;"><span class="s39">• </span><b>A1 </b>(<span class="s63">linear search</span>). In a linear search, the system scans each ﬁle block and tests all records to see whether they satisfy the selection condition. An initial seek is required to access the ﬁrst block of the ﬁle. In case blocks of the ﬁle are not stored contiguously, extra seeks may be required, but we ignore this eﬀect for simplicity. Although it may be slower than other algorithms for implementing selection, the linear-search algorithm can be applied to any ﬁle, regardless of the ordering of the ﬁle, or the availability of indices, or the nature of the selection operation.</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">The other algorithms that we shall study are not applicable in all cases, but when applicable they are generally faster than linear search.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 13pt;text-align: justify;">Cost estimates for linear scan, as well as for other selection algorithms, are shown in Figure 15.3. In the ﬁgure, we use <i>h</i><span class="s97">i </span>to represent the height of the B<span class="s181">+</span>-tree, and assume a random <span class="s44">I/O </span>operation is required for each node in the path from the root to a leaf. Most real-life optimizers assume that the internal nodes of the tree are present in the in-memory buﬀer since they are frequently accessed, and usually less than 1 percent of the nodes of a B<span class="s181">+</span>-tree are nonleaf nodes. The cost formulae can be correspondingly</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">simpliﬁed, charging only one random <span class="s44">I/O </span>cost for a traversal from the root to a leaf, by setting <i>h</i><span class="s97">i </span><span class="s15">= </span>1.</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Index structures are referred to as <span class="s63">access paths</span>, since they provide a path through</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">which data can be located and accessed. In Chapter 14, we pointed out that it is eﬃcient to read the records of a ﬁle in an order corresponding closely to physical order. Recall that a <i>clustering index </i>(also referred to as a <i>primary index</i>) is an index that allows the records of a ﬁle to be read in an order that corresponds to the physical order in the ﬁle. An index that is not a clustering index is called a <i>secondary index </i>or a <i>nonclustering index</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Search algorithms that use an index are referred to as <span class="s63">index scans</span>. We use the selection predicate to guide us in the choice of the index to use in processing the query. Search algorithms that use an index are:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:90.964pt" cellspacing="0"><tr style="height:16pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">Algorithm</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">Cost</p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F" bgcolor="#C6E9FA"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">Reason</p></td></tr><tr style="height:39pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A1</p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Linear Search</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 14pt;text-align: left;">t<span class="s364">S </span><span class="s365">+ </span>b<span class="s364">r </span><span class="s365">∗ </span>t<span class="s364">T</span></p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;padding-right: 3pt;text-indent: 0pt;line-height: 89%;text-align: justify;">One initial seek plus <i>b</i><span class="s364">r </span>block transfers, where <i>b</i><span class="s366">r </span>denotes the number of blocks in the ﬁle.</p></td></tr><tr style="height:52pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A1</p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Linear Search,</p><p class="s72" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">Equality on Key</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Average case</p><p class="s365" style="padding-left: 4pt;text-indent: 0pt;text-align: left;"><span class="s71">t</span><span class="s364">S </span>+<span class="s72">(</span><span class="s71">b</span><span class="s364">r </span>∕<span class="s72">2) </span>∗ <span class="s71">t</span><span class="s364">T</span></p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Since at most one record satisﬁes the con-</p><p class="s72" style="padding-left: 4pt;padding-right: 3pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">dition, scan can be terminated as soon as the required record is found. In the worst case, <i>b</i><span class="s366">r </span>block transfers are still required.</p></td></tr><tr style="height:65pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A2</p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Clustering</p><p class="s72" style="padding-left: 4pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">B<span class="s367">+</span>-tree Index, Equality on Key</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 13pt;text-align: left;">(<i>h</i><span class="s364">i </span><span class="s365">+ </span>1) <span class="s365">∗</span></p><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s72">(</span>t<span class="s364">T </span><span class="s365">+ </span>t<span class="s364">S</span><span class="s72">)</span></p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;padding-right: 3pt;text-indent: 0pt;line-height: 87%;text-align: justify;">(Where <i>h</i><span class="s364">i </span>denotes the height of the in- dex.) Index lookup traverses the height of</p><p class="s72" style="padding-left: 4pt;padding-right: 3pt;text-indent: 0pt;text-align: justify;">the tree plus one <span class="s368">I/O </span>to fetch the record; each of these <span class="s368">I/O </span>operations requires a seek and a block transfer.</p></td></tr><tr style="height:91pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A3</p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Clustering</p><p class="s72" style="padding-left: 4pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">B<span class="s367">+</span>-tree Index, Equality on Non-key</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 13pt;text-align: left;">h<span class="s364">i </span><span class="s365">∗ </span><span class="s72">(</span>t<span class="s364">T </span><span class="s365">+ </span>t<span class="s364">S </span><span class="s72">) </span><span class="s365">+</span></p><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 14pt;text-align: left;">t<span class="s364">S </span><span class="s365">+ </span>b <span class="s365">∗ </span>t<span class="s364">T</span></p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">One seek for each level of the tree, one</p><p class="s72" style="padding-left: 4pt;padding-right: 3pt;text-indent: 0pt;text-align: justify;">seek for the ﬁrst block. Here <i>b </i>is the num- ber of blocks containing records with the speciﬁed search key, all of which are read. These blocks are leaf blocks assumed to be stored sequentially (since it is a clustering index) and don’t require additional seeks.</p></td></tr><tr style="height:39pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A4</p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Secondary</p><p class="s72" style="padding-left: 4pt;padding-right: 5pt;text-indent: 0pt;text-align: left;">B<span class="s367">+</span>-tree Index, Equality on Key</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 12pt;text-align: left;">(<i>h</i><span class="s366">i </span><span class="s365">+ </span>1) <span class="s365">∗</span></p><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s72">(</span>t<span class="s366">T </span><span class="s365">+ </span>t<span class="s366">S</span><span class="s72">)</span></p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">This case is similar to clustering index.</p></td></tr><tr style="height:78pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A4</p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Secondary</p><p class="s72" style="padding-left: 4pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">B<span class="s367">+</span>-tree Index, Equality on Non-key</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s72">(</span>h<span class="s364">i </span><span class="s365">+ </span>n<span class="s72">) </span><span class="s365">∗</span></p><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s72">(</span>t<span class="s364">T </span><span class="s365">+ </span>t<span class="s364">S</span><span class="s72">)</span></p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">(Where <i>n </i>is the number of records</p><p class="s72" style="padding-left: 4pt;padding-right: 3pt;text-indent: 0pt;text-align: justify;">fetched.) Here, cost of index traversal is the same as for A3, but each record may be on a diﬀerent block, requiring a seek per record. Cost is potentially very high if <i>n </i>is large.</p></td></tr><tr style="height:39pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A5</p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Clustering</p><p class="s72" style="padding-left: 4pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">B<span class="s367">+</span>-tree Index, Comparison</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 12pt;text-align: left;">h<span class="s366">i </span><span class="s365">∗ </span><span class="s72">(</span>t<span class="s366">T </span><span class="s365">+ </span>t<span class="s366">S </span><span class="s72">) </span><span class="s365">+</span></p><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 14pt;text-align: left;">t<span class="s366">S </span><span class="s365">+ </span>b <span class="s365">∗ </span>t<span class="s366">T</span></p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Identical to the case of A3, equality on</p><p class="s72" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">non-key.</p></td></tr><tr style="height:39pt"><td style="width:22pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 3pt;padding-right: 3pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A6</p></td><td style="width:81pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Secondary</p><p class="s72" style="padding-left: 4pt;padding-right: 15pt;text-indent: 0pt;text-align: left;">B<span class="s367">+</span>-tree Index, Comparison</p></td><td style="width:74pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span class="s72">(</span>h<span class="s364">i </span><span class="s365">+ </span>n<span class="s72">) </span><span class="s365">∗</span></p><p class="s71" style="padding-left: 4pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s72">(</span>t<span class="s364">T </span><span class="s365">+ </span>t<span class="s364">S</span><span class="s72">)</span></p></td><td style="width:189pt;border-top-style:solid;border-top-width:1pt;border-top-color:#221E1F;border-left-style:solid;border-left-width:1pt;border-left-color:#221E1F;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#221E1F;border-right-style:solid;border-right-width:1pt;border-right-color:#221E1F"><p class="s72" style="padding-left: 4pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Identical to the case of A4, equality on</p><p class="s72" style="padding-left: 4pt;text-indent: 0pt;text-align: left;">non-key.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 15.3 <span class="s74">Cost estimates for selection algorithms.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>A2 <span class="p">(</span>clustering index, equality on key<span class="p">). For an equality comparison on a key at- tribute with a clustering index, we can use the index to retrieve a single record that satisﬁes the corresponding equality condition. Cost estimates are shown in Figure</span></p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">15.3. To model the common situation that the internal nodes of the index are in the in-memory buﬀer, <i>h</i><span class="s97">i </span>can be set to 1.</p><p style="padding-top: 1pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>A3 </b>(<b>clustering index, equality on non-key</b>). We can retrieve multiple records by using a clustering index when the selection condition speciﬁes an equality com- parison on a non-key attribute, <i>A</i>. The only diﬀerence from the previous case is that multiple records may need to be fetched. However, the records must be stored consecutively in the ﬁle since the ﬁle is sorted on the search key. Cost estimates are shown in Figure 15.3.</p><p class="s46" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>A4 <span class="p">(</span>secondary index, equality<span class="p">). Selections specifying an equality condition can use a secondary index. This strategy can retrieve a single record if the equality condition is on a key; multiple records may be retrieved if the indexing ﬁeld is not a key.</span></p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">In the ﬁrst case, only one record is retrieved. The cost in this case is the same as that for a clustering index (case A2).</p><p style="padding-left: 139pt;text-indent: 13pt;text-align: justify;">In the second case, each record may be resident on a diﬀerent block, which may result in one <span class="s44">I/O </span>operation per retrieved record, with each <span class="s44">I/O </span>operation requiring a seek and a block transfer. The worst-case cost in this case is (<i>h</i><span class="s97">i </span><span class="s15">+ </span><i>n</i>) <span class="s15">∗ </span>(<i>t</i><span class="s97">S </span><span class="s15">+ </span><i>t</i><span class="s97">T </span>),</p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">where <i>n </i>is the number of records fetched, if each record is in a diﬀerent disk block,</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">and the block fetches are randomly ordered. The worst-case cost could become even worse than that of linear search if a large number of records are retrieved.</p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">If the in-memory buﬀer is large, the block containing the record may already be in the buﬀer. It is possible to construct an estimate of the <i>average </i>or <i>expected </i>cost of the selection by taking into account the probability of the block containing the record already being in the buﬀer. For large buﬀers, that estimate will be much less than the worst-case estimate.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In certain algorithms, including A2, the use of a B<span class="s181">+</span>-tree ﬁle organization can save one access since records are stored at the leaf level of the tree.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As described in Section 14.4.2, when records are stored in a B<span class="s181">+</span>-tree ﬁle organiza- tion or other ﬁle organizations that may require relocation of records, secondary in- dices usually do not store pointers to the records.<span class="s76">4</span> Instead, secondary indices store the values of the attributes used as the search key in a B<span class="s181">+</span>-tree ﬁle organization. Accessing a record through such a secondary index is then more expensive: First the secondary index is searched to ﬁnd the B<span class="s181">+</span>-tree ﬁle organization search-key values, then the B<span class="s181">+</span>- tree ﬁle organization is looked up to ﬁnd the records. The cost formulae described for secondary indices have to be modiﬁed appropriately if such indices are used.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2762.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">4<span class="s78">Recall that if B</span><span class="s310">+</span><span class="s80">-tree ﬁle organizations are used to store relations, records may be moved between blocks when leaf nodes are split or merged, and when records are redistributed.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">15.3.2 Selections Involving Comparisons</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;line-height: 86%;text-align: left;">Consider a selection of the form <span class="s15">σ</span><i>A</i><span class="s369">≤</span><i>v</i>(<i>r</i>). We can implement the selection either by using linear search or by using indices in one of the following ways:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 107pt;text-indent: -16pt;line-height: 90%;text-align: justify;"><span class="s39">• </span><b>A5 </b>(<b>clustering index, comparison</b>). A clustering ordered index (for example, a clus- tering B<span class="s181">+</span>-tree index) can be used when the selection condition is a comparison. For comparison conditions of the form <i>A </i><span class="s83">&gt; </span><i>v </i>or <i>A </i><span class="s86">≥ </span><i>v</i>, a clustering index on <i>A</i></p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="p">can be used to direct the retrieval of tuples, as follows: For </span>A <span class="s86">≥ </span>v<span class="p">, we look up the</span></p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;line-height: 86%;text-align: left;"><span class="p">value </span>v <span class="p">in the index to ﬁnd the ﬁrst tuple in the ﬁle that has a value of </span>A <span class="s86">≥ </span>v<span class="p">.A ﬁle scan starting from that tuple up to the end of the ﬁle returns all tuples that satisfy</span></p><p class="s13" style="padding-top: 1pt;padding-left: 107pt;text-indent: 0pt;line-height: 70%;text-align: left;"><span class="p">the condition. For </span>A <span class="s83">&gt; </span>v<span class="p">, the ﬁle scan starts with the ﬁrst tuple such that </span>A <span class="s83">&gt; </span>v<span class="p">. The cost estimate for this case is identical to that for case A3.</span></p><p class="s13" style="padding-top: 2pt;padding-left: 107pt;text-indent: 14pt;line-height: 65%;text-align: justify;"><span class="p">For comparisons of the form </span>A <span class="s83">&lt; </span>v <span class="p">or </span>A <span class="s86">≤ </span>v<span class="p">, an index lookup is not required. For </span>A <span class="s83">&lt; </span>v<span class="p">, we use a simple ﬁle scan starting from the beginning of the ﬁle, and continuing up to (but not including) the ﬁrst tuple with attribute </span>A <span class="s15">= </span>v<span class="p">. The case</span></p><p class="s13" style="padding-top: 2pt;padding-left: 107pt;text-indent: 0pt;line-height: 72%;text-align: justify;"><span class="p">of </span>A <span class="s86">≤ </span>v <span class="p">is similar, except that the scan continues up to (but not including) the ﬁrst tuple with attribute </span>A <span class="s83">&gt; </span>v<span class="p">. In either case, the index is not useful.</span></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;line-height: 69%;text-align: justify;"><span class="s39">• </span><b>A6 </b>(<b>secondary index, comparison</b>). We can use a secondary ordered index to guide retrieval for comparison conditions involving <span class="s83">&lt;</span>, <span class="s86">≤</span>, <span class="s86">≥</span>, or <span class="s83">&gt;</span>. The lowest-level index blocks are scanned, either from the smallest value up to <i>v </i>(for <span class="s83">&lt; </span>and <span class="s86">≤</span>), or from</p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 13pt;text-align: justify;"><i>v </i>up to the maximum value (for <span class="s83">&gt; </span>and <span class="s86">≥</span>).</p><p style="padding-left: 123pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">The secondary index provides pointers to the records, but to get the actual</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">records we have to fetch the records by using the pointers. This step may require an <span class="s44">I/O </span>operation for each record fetched, since consecutive records may be on diﬀerent disk blocks; as before, each <span class="s44">I/O </span>operation requires a disk seek and a block transfer. If the number of retrieved records is large, using the secondary index may be even more expensive than using linear search. Therefore, the secondary index should be used only if very few records are selected.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As long as the number of matching tuples is known ahead of time, a query opti- mizer can choose between using a secondary index or using a linear scan based on the cost estimates. However, if the number of matching tuples is not known accurately at compilation time, either choice may lead to bad performance, depending on the actual number of matching tuples.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To deal with the above situation, <span class="s44">P</span>ostgre<span class="s44">SQL </span>uses a hybrid algorithm that it calls a <i>bitmap index scan</i>,<span class="s76">5</span> when a secondary index is available, but the number of matching records is not known precisely. The bitmap index scan algorithm ﬁrst creates a bitmap with as many bits as the number of blocks in the relation, with all bits initialized to 0. The algorithm then uses the secondary index to ﬁnd index entries for matching tuples, but instead of fetching the tuples immediately, it does the following. As each index</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2763.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">5<span class="s78">This algorithm should not be confused with a scan using a bitmap index.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">entry is found, the algorithm gets the block number from the index entry, and sets the corresponding bit in the bitmap to 1.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Once all index entries have been processed, the bitmap is scanned to ﬁnd all blocks whose bit is set to 1. These are exactly the blocks containing matching records. The relation is then scanned linearly, but blocks whose bit is not set to 1 are skipped; only blocks whose bit is set to 1 are fetched, and then a scan within each block is used to retrieve all matching records in the block.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In the worst case, this algorithm is only slightly more expensive than linear scan, but in the best case it is much cheaper than linear scan. Similarly, in the worst case it is only slightly more expensive than using a secondary index scan to directly fetch tuples, but in the best case it is much cheaper than a secondary index scan. Thus, this hybrid algorithm ensures that performance is never much worse than the best plan for that database instance.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A variant of this algorithm collects all the index entries, and sorts them (using sorting algorithms which we study later in this chapter), and then performs a relation scan that skips blocks that do not have any matching entries. Using a bitmap as above can be cheaper than sorting the index entries.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">15.3.3 Implementation of Complex Selections</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">So far, we have considered only simple selection conditions of the form <i>A op B</i>, where <i>op </i>is an equality or comparison operation. We now consider more complex selection predicates.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><b>Conjunction: </b>A <span class="s63">conjunctive selection </span>is a selection of the form:</p><p class="s118" style="padding-top: 12pt;padding-left: 141pt;text-indent: 0pt;text-align: center;"><span class="s117">σ</span><span class="s370">θ</span><span class="s358">1</span>∧ θ<span class="s358">2</span>∧ <span class="s371">⋯</span>∧ θ<span class="s372">n</span><span class="s109"> </span><span class="s122">(</span><span class="s121">r</span><span class="s122">)</span></p><p style="padding-top: 7pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><b>Disjunction: </b>A <span class="s63">disjunctive selection </span>is a selection of the form:</p><p class="s122" style="padding-top: 12pt;padding-left: 141pt;text-indent: 0pt;line-height: 11pt;text-align: center;"><span class="s117">σ</span><span class="s370">θ ∨θ ∨ </span><span class="s371">⋯</span><span class="s118">∨θ </span>(<i>r</i>)</p><p class="s150" style="padding-left: 138pt;text-indent: 0pt;line-height: 6pt;text-align: center;">1  2    <i>n</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;">A disjunctive condition is satisﬁed by the union of all records satisfying the indi- vidual, simple conditions <span class="s15">θ</span><i>i</i>.</p><p style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Negation: </b>The result of a selection <span class="s15">σ</span><span class="s137">¬θ</span>(<i>r</i>) is the set of tuples of <i>r </i>for which the condition <span class="s15">θ </span>evaluates to false. In the absence of nulls, this set is simply the set of tuples in <i>r </i>that are not in <span class="s15">σ</span><span class="s137">θ</span>(<i>r</i>).</p><p style="padding-top: 13pt;padding-left: 119pt;text-indent: 17pt;text-align: left;">We can implement a selection operation involving either a conjunction or a dis- junction of simple conditions by using one of the following algorithms:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>A7 <span class="p">(</span>conjunctive selection using one index<span class="p">). We ﬁrst determine whether an access path is available for an attribute in one of the simple conditions. If one is, one of the</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: 0pt;text-align: justify;">selection algorithms A2 through A6 can retrieve records satisfying that condition. We complete the operation by testing, in the memory buﬀer, whether or not each retrieved record satisﬁes the remaining simple conditions.</p><p class="s106" style="text-indent: 0pt;line-height: 6pt;text-align: left;">i</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 107pt;text-indent: 15pt;text-align: left;">To reduce the cost, we choose a <span class="s15">θ</span><i>i</i><i> </i>and one of algorithms A1 through A6 for which the combination results in the least cost for <span class="s15">σ</span><span class="s137">θ</span><span class="s15"> </span>(<i>r</i>). The cost of algorithm</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">A7 is given by the cost of the chosen algorithm.</p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>A8 </b>(<b>conjunctive selection using composite index</b>). An appropriate <span class="s63">composite index </span>(that is, an index on multiple attributes) may be available for some conjunctive se- lections. If the selection speciﬁes an equality condition on two or more attributes, and a composite index exists on these combined attribute ﬁelds, then the index can be searched directly. The type of index determines which of algorithms A2, A3, or A4 will be used.</p><p class="s46" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>A9 <span class="p">(</span>conjunctive selection by intersection of identiﬁers<span class="p">). Another alternative for im- plementing conjunctive selection operations involves the use of record pointers or record identiﬁers. This algorithm requires indices with record pointers, on the ﬁelds involved in the individual conditions. The algorithm scans each index for pointers to tuples that satisfy an individual condition. The intersection of all the retrieved pointers is the set of pointers to tuples that satisfy the conjunctive condi- tion. The algorithm then uses the pointers to retrieve the actual records. If indices are not available on all the individual conditions, then the algorithm tests the re- trieved records against the remaining conditions.</span></p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">The cost of algorithm A9 is the sum of the costs of the individual index scans, plus the cost of retrieving the records in the intersection of the retrieved lists of pointers. This cost can be reduced by sorting the list of pointers and retrieving records in the sorted order. Thereby, (1) all pointers to records in a block come together, hence all selected records in the block can be retrieved using a single <span class="s44">I/O </span>operation, and (2) blocks are read in sorted order, minimizing disk-arm movement. Section 15.4 describes sorting algorithms.</p><p class="s46" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>A10 <span class="p">(</span>disjunctive selection by union of identiﬁers<span class="p">). If access paths are available on all the conditions of a disjunctive selection, each index is scanned for pointers to tuples that satisfy the individual condition. The union of all the retrieved pointers yields the set of pointers to all tuples that satisfy the disjunctive condition. We then use the pointers to retrieve the actual records.</span></p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">However, if even one of the conditions does not have an access path, we have to perform a linear scan of the relation to ﬁnd tuples that satisfy the condition. Therefore, if there is even one such condition in the disjunct, the most eﬃcient access method is a linear scan, with the disjunctive condition tested on each tuple during the scan.</p><p style="padding-top: 9pt;padding-left: 88pt;text-indent: 17pt;text-align: left;">The implementation of selections with negation conditions is left to you as an exercise (Practice Exercise 15.6).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part281.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part283.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
