<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>Homework Problems </title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000005090" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P700049702700000000000000004383F" data-uri="chapter05.xhtml#P700049702700000000000000004383F" epub:type="title"><span class="pcalibre label pcalibre1">Homework Problems </span></h1></header>
<section id="P7000497027000000000000000005092" data-uri="chapter05.xhtml#P7000497027000000000000000005092" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000043840" data-uri="chapter05.xhtml#P7000497027000000000000000043840" epub:type="title"><span class="pcalibre label pcalibre1">5.13 </span>♦♦</h1></header>
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043841" data-uri="chapter05.xhtml#P7000497027000000000000000043841"><p id="P7000497027000000000000000043842" data-uri="chapter05.xhtml#P7000497027000000000000000043842" class="pcalibre1 pcalibre calibre2">Suppose we wish to write a procedure that computes the inner product of two vectors u and v. An abstract version of the function has a CPE of 14−18 with x86-64 for different types of integer and floating-point data. By doing the same sort of transformations we did to transform the abstract program <code id="P7000497027000000000000000043843" data-uri="chapter05.xhtml#P7000497027000000000000000043843" class="pcalibre1 calibre8 pcalibre">combine1</code> into the more efficient <code id="P7000497027000000000000000043844" data-uri="chapter05.xhtml#P7000497027000000000000000043844" class="pcalibre1 calibre8 pcalibre">combine4</code>, we get the following code:</p></div>
<pre id="P7000497027000000000000000043845" data-uri="chapter05.xhtml#P7000497027000000000000000043845" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043846" data-uri="chapter05.xhtml#P7000497027000000000000000043846" class="calibre10 pcalibre pcalibre1">
1	/* Inner product. Accumulate in temporary */
2	void inner4(vec_ptr u, vec_ptr v, data_t *dest)
3	{
4		long i;
5		long length = vec_length(u);
6		data_t *udata = get_vec_start(u);
7		data_t *vdata = get_vec_start(v);
8		data_t sum = (data_t) 0;
9	
10		for (i = 0; i &lt; length; i++) {
11			sum = sum + udata[i] * vdata[i];
12		}
13		*dest = sum;
14	}
</code></pre>
<p id="P7000497027000000000000000043847" data-uri="chapter05.xhtml#P7000497027000000000000000043847" class="pcalibre1 pcalibre calibre2">Our measurements show that this function has CPEs of 1.50 for integer data and 3.00 for floating-point data. For data type double, the x86-64 assembly code for the inner loop is as follows:</p>
<pre id="P7000497027000000000000000043848" data-uri="chapter05.xhtml#P7000497027000000000000000043848" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043849" data-uri="chapter05.xhtml#P7000497027000000000000000043849" class="calibre10 pcalibre pcalibre1">
	<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000509C" title="571" data-uri="chapter05.xhtml#P700049702700000000000000000509C" epub:type="pagebreak"></span><i class="calibre5 pcalibre pcalibre1">Inner loop of inner4. data_t = double, OP = *</i>
	<i class="calibre5 pcalibre pcalibre1">udata in %rbp, vdata in %rax, sum in %xmm0</i>
	<i class="calibre5 pcalibre pcalibre1">i in %rcx, limit in %rbx</i>
1	.L15:					<b class="calibre4 pcalibre pcalibre1">loop:</b>
2	 vmovsd 0(%rbp,%rcx,8), %xmml		  Get <i class="calibre5 pcalibre pcalibre1">udata[i]</i>
3	 vmulsd (%rax,%rcx,8), %xmml, %xmml	  <i class="calibre5 pcalibre pcalibre1">Multiply by vdata[i]</i>
4	 vaddsd %xmml, %xmm0, %xmm0		  <i class="calibre5 pcalibre pcalibre1">Add to sum</i>
5	 addq $1, 7,rcx				  <i class="calibre5 pcalibre pcalibre1">Increment i</i>
6	 cmpq %rbx, %rcx			  <i class="calibre5 pcalibre pcalibre1">Compare i:limit</i>
7	 jne .L15				  <i class="calibre5 pcalibre pcalibre1">If ! =, goto</i> <b class="calibre4 pcalibre pcalibre1">loop</b>
</code></pre>
<p id="P700049702700000000000000004384A" data-uri="chapter05.xhtml#P700049702700000000000000004384A" class="pcalibre1 pcalibre calibre2">Assume that the functional units have the characteristics listed in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004BAA"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">5.12</span></a>.</p>
<ol class="practicelist1 pcalibre pcalibre1" id="P700049702700000000000000004384B" data-uri="chapter05.xhtml#P700049702700000000000000004384B">
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004384C" data-uri="chapter05.xhtml#P700049702700000000000000004384C">
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000004384D" data-uri="chapter05.xhtml#P700049702700000000000000004384D"><p id="P700049702700000000000000004384E" data-uri="chapter05.xhtml#P700049702700000000000000004384E" class="pcalibre calibre3 pcalibre1">Diagram how this instruction sequence would be decoded into operations and show how the data dependencies between them would create a critical path of operations, in the style of <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C1E"><span class="pcalibre label pcalibre1">Figures </span><span class="pcalibre label pcalibre1">5.13</span></a> and <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004B6C.xhtml#P7000497027000000000000000004C33"><span class="pcalibre label pcalibre1">5.14</span></a>.</p></div></li>
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004384F" data-uri="chapter05.xhtml#P700049702700000000000000004384F">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043850" data-uri="chapter05.xhtml#P7000497027000000000000000043850"><p id="P7000497027000000000000000043851" data-uri="chapter05.xhtml#P7000497027000000000000000043851" class="pcalibre calibre3 pcalibre1">For data type double, what lower bound on the CPE is determined by the critical path?</p></div></li>
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000043852" data-uri="chapter05.xhtml#P7000497027000000000000000043852">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043853" data-uri="chapter05.xhtml#P7000497027000000000000000043853"><p id="P7000497027000000000000000043854" data-uri="chapter05.xhtml#P7000497027000000000000000043854" class="pcalibre calibre3 pcalibre1">Assuming similar instruction sequences for the integer code as well, what lower bound on the CPE is determined by the critical path for integer data?</p></div></li>
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000043855" data-uri="chapter05.xhtml#P7000497027000000000000000043855">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000043856" data-uri="chapter05.xhtml#P7000497027000000000000000043856"><p id="P7000497027000000000000000043857" data-uri="chapter05.xhtml#P7000497027000000000000000043857" class="pcalibre calibre3 pcalibre1">Explain how the floating-point versions can have CPEs of 3.00, even though the multiplication operation requires 5 clock cycles.</p></div></li>
</ol>
</section>
<section id="P70004970270000000000000000050A7" data-uri="chapter05.xhtml#P70004970270000000000000000050A7" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000043858" data-uri="chapter05.xhtml#P7000497027000000000000000043858" epub:type="title"><span class="pcalibre label pcalibre1">5.14 </span>♦</h1></header>
<p id="P7000497027000000000000000043859" data-uri="chapter05.xhtml#P7000497027000000000000000043859" class="pcalibre1 pcalibre calibre2">Write a version of the inner product procedure described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005092"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">5.13</span></a> that uses 6 × 1 loop unrolling. For x86-64, our measurements of the unrolled version give a CPE of 1.07 for integer data but still 3.01 for both floating-point data.</p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P700049702700000000000000004385A" data-uri="chapter05.xhtml#P700049702700000000000000004385A">
<li id="P700049702700000000000000004385B" data-uri="chapter05.xhtml#P700049702700000000000000004385B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004385C" data-uri="chapter05.xhtml#P700049702700000000000000004385C" class="pcalibre calibre3 pcalibre1">Explain why any (scalar) version of an inner product procedure running on an Intel Core i7 Haswell processor cannot achieve a CPE less than 1.00.</p></li>
<li id="P700049702700000000000000004385D" data-uri="chapter05.xhtml#P700049702700000000000000004385D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004385E" data-uri="chapter05.xhtml#P700049702700000000000000004385E" class="pcalibre calibre3 pcalibre1">Explain why the performance for floating-point data did not improve with loop unrolling.</p></li>
</ol>
</section>
<section id="P70004970270000000000000000050AF" data-uri="chapter05.xhtml#P70004970270000000000000000050AF" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004385F" data-uri="chapter05.xhtml#P700049702700000000000000004385F" epub:type="title"><span class="pcalibre label pcalibre1">5.15 </span>♦</h1></header>
<p id="P7000497027000000000000000043860" data-uri="chapter05.xhtml#P7000497027000000000000000043860" class="pcalibre1 pcalibre calibre2">Write a version of the inner product procedure described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005092"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">5.13</span></a> that uses 6 × 6 loop unrolling. Our measurements for this function with x86-64 give a CPE of 1.06 for integer data and 1.01 for floating-point data.</p>
<p id="P7000497027000000000000000043861" data-uri="chapter05.xhtml#P7000497027000000000000000043861" class="pcalibre1 pcalibre calibre2">What factor limits the performance to a CPE of 1.00?</p>
</section>
<section id="P70004970270000000000000000050B3" data-uri="chapter05.xhtml#P70004970270000000000000000050B3" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000043862" data-uri="chapter05.xhtml#P7000497027000000000000000043862" epub:type="title"><span class="pcalibre label pcalibre1">5.16 </span>♦</h1></header>
<p id="P7000497027000000000000000043863" data-uri="chapter05.xhtml#P7000497027000000000000000043863" class="pcalibre1 pcalibre calibre2">Write a version of the inner product procedure described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000005092"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">5.13</span></a> that uses 6 × 1<var class="calibre5 pcalibre pcalibre1">a</var> loop unrolling to enable greater parallelism. Our measurements for this function give a CPE of 1.10 for integer data and 1.05 for floating-point data.</p>
</section>
<section id="P70004970270000000000000000050B6" data-uri="chapter05.xhtml#P70004970270000000000000000050B6" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000043864" data-uri="chapter05.xhtml#P7000497027000000000000000043864" epub:type="title"><span class="pcalibre label pcalibre1">5.17 </span>♦♦</h1></header>
<p id="P7000497027000000000000000043865" data-uri="chapter05.xhtml#P7000497027000000000000000043865" class="pcalibre1 pcalibre calibre2">The library function <code id="P7000497027000000000000000043866" data-uri="chapter05.xhtml#P7000497027000000000000000043866" class="pcalibre1 calibre8 pcalibre">memset</code> has the following prototype:</p>
<pre id="P7000497027000000000000000043867" data-uri="chapter05.xhtml#P7000497027000000000000000043867" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043868" data-uri="chapter05.xhtml#P7000497027000000000000000043868" class="calibre10 pcalibre pcalibre1">void *memset(void *s, int c, size_t n);</code></pre>
<p id="P7000497027000000000000000043869" data-uri="chapter05.xhtml#P7000497027000000000000000043869" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000050BD" title="572" data-uri="chapter05.xhtml#P70004970270000000000000000050BD" epub:type="pagebreak"></span>This function fills <code id="P700049702700000000000000004386A" data-uri="chapter05.xhtml#P700049702700000000000000004386A" class="pcalibre1 calibre8 pcalibre">n</code> bytes of the memory area starting at <code id="P700049702700000000000000004386B" data-uri="chapter05.xhtml#P700049702700000000000000004386B" class="pcalibre1 calibre8 pcalibre">s</code> with copies of the low-order byte of <code id="P700049702700000000000000004386C" data-uri="chapter05.xhtml#P700049702700000000000000004386C" class="pcalibre1 calibre8 pcalibre">c</code>. For example, it can be used to zero out a region of memory by giving argument 0 for <code id="P700049702700000000000000004386D" data-uri="chapter05.xhtml#P700049702700000000000000004386D" class="pcalibre1 calibre8 pcalibre">c</code>, but other values are possible.</p>
<p id="P700049702700000000000000004386E" data-uri="chapter05.xhtml#P700049702700000000000000004386E" class="pcalibre1 pcalibre calibre2">The following is a straightforward implementation of <code id="P700049702700000000000000004386F" data-uri="chapter05.xhtml#P700049702700000000000000004386F" class="pcalibre1 calibre8 pcalibre">memset</code>:</p>
<pre id="P7000497027000000000000000043870" data-uri="chapter05.xhtml#P7000497027000000000000000043870" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000043871" data-uri="chapter05.xhtml#P7000497027000000000000000043871" class="calibre10 pcalibre pcalibre1">
1	/* Basic implementation of memset */
2	void *basic_memset(void *s, int c, size_t n)
3	{
4		size_t cnt = 0;
5		unsigned char *schar = s;
6		while (cnt &lt; n) {
7			*schar++ = (unsigned char) c;
8			cnt++;
9		}
10		return s;
11	}
</code></pre>
<p id="P7000497027000000000000000043872" data-uri="chapter05.xhtml#P7000497027000000000000000043872" class="pcalibre1 pcalibre calibre2">Implement a more efficient version of the function by using a word of data type <code id="P7000497027000000000000000043873" data-uri="chapter05.xhtml#P7000497027000000000000000043873" class="pcalibre1 calibre8 pcalibre">unsigned long</code> to pack eight copies of <code id="P7000497027000000000000000043874" data-uri="chapter05.xhtml#P7000497027000000000000000043874" class="pcalibre1 calibre8 pcalibre">c</code>, and then step through the region using word-level writes. You might find it helpful to do additional loop unrolling as well. On our reference machine, we were able to reduce the CPE from 1.00 for the straightforward implementation to 0.127. That is, the program is able to write 8 bytes every clock cycle.</p>
<p id="P7000497027000000000000000043875" data-uri="chapter05.xhtml#P7000497027000000000000000043875" class="pcalibre1 pcalibre calibre2">Here are some additional guidelines. To ensure portability, let <var class="calibre5 pcalibre pcalibre1">K</var> denote the value of <code id="P7000497027000000000000000043876" data-uri="chapter05.xhtml#P7000497027000000000000000043876" class="pcalibre1 calibre8 pcalibre">sizeof (unsigned long)</code> for the machine on which you run your program.</p>
<ul id="P7000497027000000000000000043877" data-uri="chapter05.xhtml#P7000497027000000000000000043877" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000043878" data-uri="chapter05.xhtml#P7000497027000000000000000043878" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043879" data-uri="chapter05.xhtml#P7000497027000000000000000043879" class="pcalibre calibre3 pcalibre1">You may not call any library functions.</p></li>
<li id="P700049702700000000000000004387A" data-uri="chapter05.xhtml#P700049702700000000000000004387A" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004387B" data-uri="chapter05.xhtml#P700049702700000000000000004387B" class="pcalibre calibre3 pcalibre1">Your code should work for arbitrary values of <code id="P700049702700000000000000004387C" data-uri="chapter05.xhtml#P700049702700000000000000004387C" class="pcalibre1 calibre8 pcalibre">n</code>, including when it is not a multiple of <i class="calibre5 pcalibre pcalibre1">K.</i> You can do this in a manner similar to the way we finish the last few iterations with loop unrolling.</p></li>
<li id="P700049702700000000000000004387D" data-uri="chapter05.xhtml#P700049702700000000000000004387D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004387E" data-uri="chapter05.xhtml#P700049702700000000000000004387E" class="pcalibre calibre3 pcalibre1">You should write your code so that it will compile and run correctly on any machine regardless of the value of <i class="calibre5 pcalibre pcalibre1">K.</i> Make use of the operation <code id="P700049702700000000000000004387F" data-uri="chapter05.xhtml#P700049702700000000000000004387F" class="pcalibre1 calibre8 pcalibre">sizeof</code> to do this.</p></li>
<li id="P7000497027000000000000000043880" data-uri="chapter05.xhtml#P7000497027000000000000000043880" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043881" data-uri="chapter05.xhtml#P7000497027000000000000000043881" class="pcalibre calibre3 pcalibre1">On some machines, unaligned writes can be much slower than aligned ones. (On some non-x86 machines, they can even cause segmentation faults.) Write your code so that it starts with byte-level writes until the destination address is a multiple of <var class="calibre5 pcalibre pcalibre1">K</var>, then do word-level writes, and then (if necessary) finish with byte-level writes.</p></li>
<li id="P7000497027000000000000000043882" data-uri="chapter05.xhtml#P7000497027000000000000000043882" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000043883" data-uri="chapter05.xhtml#P7000497027000000000000000043883" class="pcalibre calibre3 pcalibre1">Beware of the case where <code id="P7000497027000000000000000043884" data-uri="chapter05.xhtml#P7000497027000000000000000043884" class="pcalibre1 calibre8 pcalibre">cnt</code> is small enough that the upper bounds on some of the loops become negative. With expressions involving the <code id="P7000497027000000000000000043885" data-uri="chapter05.xhtml#P7000497027000000000000000043885" class="pcalibre1 calibre8 pcalibre">sizeof</code> operator, the testing may be performed with unsigned arithmetic. (See <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000077D_split_001.xhtml#P7000497027000000000000000000C88"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">2.2.8</span></a> and <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000001498.xhtml#P70004970270000000000000000015A5"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">2.72</span></a>.)</p></li>
</ul>
</section>
<section id="P70004970270000000000000000050DA" data-uri="chapter05.xhtml#P70004970270000000000000000050DA" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000043886" data-uri="chapter05.xhtml#P7000497027000000000000000043886" epub:type="title"><span class="pcalibre label pcalibre1">5.18 </span>♦♦♦</h1></header>
<p id="P7000497027000000000000000043887" data-uri="chapter05.xhtml#P7000497027000000000000000043887" class="pcalibre1 pcalibre calibre2">We considered the task of polynomial evaluation in Practice Problems 5.5 and 5.6, with both a direct evaluation and an evaluation by Horner's method. Try to write <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000050DD" title="573" data-uri="chapter05.xhtml#P70004970270000000000000000050DD" epub:type="pagebreak"></span>faster versions of the function using the optimization techniques we have explored, including loop unrolling, parallel accumulation, and reassociation. You will find many different ways of mixing together Horner's scheme and direct evaluation with these optimization techniques.</p>
<p id="P7000497027000000000000000043888" data-uri="chapter05.xhtml#P7000497027000000000000000043888" class="pcalibre1 pcalibre calibre2">Ideally, you should be able to reach a CPE close to the throughput limit of your machine. Our best version achieves a CPE of 1.07 on our reference machine.</p>
</section>
<section id="P70004970270000000000000000050DF" data-uri="chapter05.xhtml#P70004970270000000000000000050DF" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000043889" data-uri="chapter05.xhtml#P7000497027000000000000000043889" epub:type="title"><span class="pcalibre label pcalibre1">5.19 </span>♦♦♦</h1></header>
<p id="P700049702700000000000000004388A" data-uri="chapter05.xhtml#P700049702700000000000000004388A" class="pcalibre1 pcalibre calibre2">In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000004F49.xhtml#P7000497027000000000000000004FEC"><span class="pcalibre label pcalibre1">Problem </span><span class="pcalibre label pcalibre1">5.12</span></a>, we were able to reduce the CPE for the prefix-sum computation to 3.00, limited by the latency of floating-point addition on this machine. Simple loop unrolling does not improve things.</p>
<p id="P700049702700000000000000004388B" data-uri="chapter05.xhtml#P700049702700000000000000004388B" class="pcalibre1 pcalibre calibre2">Using a combination of loop unrolling and reassociation, write code for a prefix sum that achieves a CPE less than the latency of floating-point addition on your machine. Doing this requires actually increasing the number of additions performed. For example, our version with two-way unrolling requires three additions per iteration, while our version with four-way unrolling requires five. Our best implementation achieves a CPE of 1.67 on our reference machine.</p>
<p id="P700049702700000000000000004388C" data-uri="chapter05.xhtml#P700049702700000000000000004388C" class="pcalibre1 pcalibre calibre2">Determine how the throughput and latency limits of your machine limit the minimum CPE you can achieve for the prefix-sum operation.</p>
</section>
</section></body></html>
