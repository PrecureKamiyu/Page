<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>1.9   History of Database Systems</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part59.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part61.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">1.9   <span style=" color: #00AEEF;">History of Database Systems</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Information processing drives the growth of computers, as it has from the earliest days of commercial computers. In fact, automation of data processing tasks predates com- puters. Punched cards, invented by Herman Hollerith, were used at the very beginning of the twentieth century to record U.S. census data, and mechanical systems were used to process the cards and tabulate results. Punched cards were later widely used as a means of entering data into computers.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">Techniques for data storage and processing have evolved over the years:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s46">1950s and early 1960s</span><span class="p">: Magnetic tapes were developed for data storage. Data- processing tasks such as payroll were automated, with data stored on tapes. Pro- cessing of data consisted of reading data from one or more tapes and writing data to a new tape. Data could also be input from punched card decks and output to printers. For example, salary raises were processed by entering the raises on punched cards and reading the punched card deck in synchronization with a tape containing the master salary details. The records had to be in the same sorted or- der. The salary raises would be added to the salary read from the master tape and written to a new tape; the new tape would become the new master tape.</span></p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">Tapes (and card decks) could be read only sequentially, and data sizes were much larger than main memory; thus, data-processing programs were forced to</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: 0pt;text-align: justify;">process data in a particular order by reading and merging data from tapes and card decks.</p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s46">Late 1960s and early 1970s</span><span class="p">: Widespread use of hard disks in the late 1960s changed the scenario for data processing greatly, since hard disks allowed direct access to data. The position of data on disk was immaterial, since any location on disk could be accessed in just tens of milliseconds. Data were thus freed from the tyranny of sequentiality. With the advent of disks, the network and hierarchical data models were developed, which allowed data structures such as lists and trees to be stored on disk. Programmers could construct and manipulate these data structures.</span></p><p style="padding-left: 107pt;text-indent: 13pt;text-align: justify;">A landmark paper by Edgar Codd in 1970 deﬁned the relational model and non- procedural ways of querying data in the relational model, and relational databases were born. The simplicity of the relational model and the possibility of hiding im- plementation details completely from the programmer were enticing indeed. Codd later won the prestigious Association of Computing Machinery Turing Award for his work.</p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Late 1970s and 1980s</b>: Although academically interesting, the relational model was not used in practice initially because of its perceived performance disadvantages; relational databases could not match the performance of existing network and hierarchical databases. That changed with System R, a groundbreaking project at IBM Research that developed techniques for the construction of an eﬃcient relational database system. The fully functional System R prototype led to <span class="s44">IBM</span>’s ﬁrst relational database product, <span class="s44">SQL/DS</span>. At the same time, the Ingres system was being developed at the University of California at Berkeley. It led to a commercial product of the same name. Also around this time, the ﬁrst version of Oracle was released. Initial commercial relational database systems, such as <span class="s44">IBM DB2</span>, Oracle, Ingres, and <span class="s44">DEC </span>Rdb, played a major role in advancing techniques for eﬃcient processing of declarative queries.</p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">By the early 1980s, relational databases had become competitive with network and hierarchical database systems even in the area of performance. Relational databases were so easy to use that they eventually replaced network and hierar- chical databases. Programmers using those older models were forced to deal with many low-level implementation details, and they had to code their queries in a procedural fashion. Most importantly, they had to keep eﬃciency in mind when designing their programs, which involved a lot of eﬀort. In contrast, in a rela- tional database, almost all these low-level tasks are carried out automatically by the database system, leaving the programmer free to work at a logical level. Since at- taining dominance in the 1980s, the relational model has reigned supreme among data models.</p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">The 1980s also saw much research on parallel and distributed databases, as well as initial work on object-oriented databases.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>1990s</b>: The <span class="s44">SQL </span>language was designed primarily for decision support applica- tions, which are query-intensive, yet the mainstay of databases in the 1980s was transaction-processing applications, which are update-intensive.</p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">In the early 1990s, decision support and querying re-emerged as a major ap- plication area for databases. Tools for analyzing large amounts of data saw a large growth in usage. Many database vendors introduced parallel database products in this period. Database vendors also began to add object-relational support to their databases.</p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">The major event of the 1990s was the explosive growth of the World Wide Web. Databases were deployed much more extensively than ever before. Database systems now had to support very high transaction-processing rates, as well as very high reliability and 24 <span class="s15">× </span>7 availability (availability 24 hours a day, 7 days a week, meaning no downtime for scheduled maintenance activities). Database systems also had to support web interfaces to data.</p><p style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>2000s</b>: The types of data stored in database systems evolved rapidly during this period. Semi-structured data became increasingly important. <span class="s44">XML </span>emerged as a data-exchange standard. <span class="s44">JSON</span>, a more compact data-exchange format well suited for storing objects from JavaScript or other programming languages subsequently grew increasingly important. Increasingly, such data were stored in relational database systems as support for the <span class="s44">XML </span>and <span class="s44">JSON </span>formats was added to the major commercial systems. Spatial data (that is, data that include geographic in- formation) saw widespread use in navigation systems and advanced applications. Database systems added support for such data.</p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">Open-source database systems, notably <span class="s44">P</span>ostgre<span class="s44">SQL </span>and <span class="s44">M</span>y<span class="s44">SQL </span>saw increased use. “Auto-admin” features were added to database systems in order to allow au- tomatic reconﬁguration to adapt to changing workloads. This helped reduce the human workload in administering a database.</p><p style="padding-left: 139pt;text-indent: 14pt;text-align: right;">Social network platforms grew at a rapid pace, creating a need to manage data about connections between people and their posted data, that did not ﬁt well into a tabular row-and-column format. This led to the development of graph databases. In the latter part of the decade, the use of data analytics and <span class="s63">data mining </span>in enterprises became ubiquitous. Database systems were developed speciﬁcally to serve this market. These systems featured physical data organizations suitable for analytic processing, such as “column-stores,” in which tables are stored by column rather than the traditional row-oriented storage of the major commercial database</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: left;">systems.</p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">The huge volumes of data, as well as the fact that much of the data used for analytics was textual or semi-structured, led to the development of programming frameworks, such as <i>map-reduce</i>, to facilitate application programmers’ use of par- allelism in analyzing data. In time, support for these features migrated into tradi- tional database systems. Even in the late 2010s, debate continued in the database</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: 0pt;text-align: justify;">research community over the relative merits of a single database system serving both traditional transaction processing applications and the newer data-analysis applications versus maintaining separate systems for these roles.</p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">The variety of new data-intensive applications and the need for rapid devel- opment, particularly by startup ﬁrms, led to “NoSQL” systems that provide a lightweight form of data management. The name was derived from those systems’ lack of support for the ubiquitous database query language <span class="s44">SQL</span>, though the name is now often viewed as meaning “not only <span class="s44">SQL</span>.” The lack of a high-level query lan- guage based on the relational model gave programmers greater ﬂexibility to work with new types of data. The lack of traditional database systems’ support for strict data consistency provided more ﬂexibility in an application’s use of distributed data stores. The NoSQL model of “eventual consistency” allowed for distributed copies of data to be inconsistent as long they would eventually converge in the absence of further updates.</p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s46">2010s</span><span class="p">: The limitations of NoSQL systems, such as lack of support for consistency, and lack of support for declarative querying, were found acceptable by many ap- plications (e.g., social networks), in return for the beneﬁts they provided such as scalability and availability. However, by the early 2010s it was clear that the lim- itations made life signiﬁcantly more complicated for programmers and database administrators. As a result, these systems evolved to provide features to support stricter notions of consistency, while continuing to support high scalability and availability. Additionally, these systems increasingly support higher levels of ab- straction to avoid the need for programmers to have to reimplement features that are standard in a traditional database system.</span></p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">Enterprises are increasingly outsourcing the storage and management of their data. Rather than maintaining in-house systems and expertise, enterprises may store their data in “cloud” services that host data for various clients in multiple, widely distributed server farms. Data are delivered to users via web-based services. Other enterprises are outsourcing not only the storage of their data but also whole applications. In such cases, termed “software as a service,” the vendor not only stores the data for an enterprise but also runs (and maintains) the application software. These trends result in signiﬁcant savings in costs, but they create new issues not only in responsibility for security breaches, but also in data ownership, particularly in cases where a government requests access to data.</p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">The huge inﬂuence of data and data analytics in daily life has made the man- agement of data a frequent aspect of the news. There is an unresolved tradeoﬀ between an individual’s right of privacy and society’s need to know. Various na- tional governments have put regulations on privacy in place. High-proﬁle security breaches have created a public awareness of the challenges in cybersecurity and the risks of storing data.</p><p class="s66" style="padding-top: 3pt;padding-left: 396pt;text-indent: 0pt;text-align: left;"><a name="bookmark18">1.10 </a><span style=" color: #00AEEF;">Summary</span><span class="s67">  </span><span class="s20">29</span><a name="bookmark30">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part59.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part61.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
