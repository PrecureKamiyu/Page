<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 34. Process Groups, Sessions, and Job Control</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch33.html" title="Chapter 33. Threads: Further Details"/><link rel="next" href="ch35.html" title="Chapter 35. Process Priorities and Scheduling"/></head><body><section class="chapter" title="Chapter 34. Process Groups, Sessions, and Job Control" epub:type="chapter" id="process_groups_comma_sessions_comma_and"><div class="titlepage"><div><div><h2 class="title">Chapter 34. Process Groups, Sessions, and Job Control</h2></div></div></div><p>Process groups and sessions form a two-level hierarchical relationship between
            processes: a process group is a collection of related processes, and a session is a
            collection of related process groups. The meaning of the term
                <span class="emphasis"><em>related</em></span> in each case will become clear in the course of this
                chapter.<a id="IDX-CHP-34-4932" class="indexterm"/></p><p>Process groups and sessions are abstractions defined to support shell job control,
            which allows interactive users to run commands in the foreground or in the background.
            The term <span class="emphasis"><em>job</em></span> is often used synonymously with the term
                <span class="emphasis"><em>process group</em></span>.</p><p>This chapter describes process groups, sessions, and job control.</p><div class="sect1" title="Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="overview-id7">Overview</h2></div></div></div><p>A <span class="emphasis"><em>process group</em></span> is a set of one or more processes sharing the
                same <span class="emphasis"><em>process group identifier</em></span> (PGID). A process group ID is a
                number of the same type (<span class="emphasis"><em>pid_t</em></span>) as a process ID. A process
                group has a <span class="emphasis"><em>process group leader</em></span>, which is the process that
                creates the group and whose process ID becomes the process group ID of the group. A
                new process inherits its parent’s process group ID.<a id="IDX-CHP-34-4933" class="indexterm"/><a id="IDX-CHP-34-4934" class="indexterm"/><a id="IDX-CHP-34-4935" class="indexterm"/><a id="IDX-CHP-34-4936" class="indexterm"/><a id="IDX-CHP-34-4937" class="indexterm"/><a id="IDX-CHP-34-4938" class="indexterm"/><a id="IDX-CHP-34-4939" class="indexterm"/><a id="IDX-CHP-34-4940" class="indexterm"/><a id="IDX-CHP-34-4941" class="indexterm"/><a id="IDX-CHP-34-4942" class="indexterm"/></p><p>A process group has a <span class="emphasis"><em>lifetime</em></span>, which is the period of time
                beginning when the leader creates the group and ending when the last member process
                leaves the group. A process may leave a process group either by terminating or by
                joining another process group. The process group leader need not be the last member
                of a process group.<a id="IDX-CHP-34-4943" class="indexterm"/><a id="IDX-CHP-34-4944" class="indexterm"/></p><p>A <span class="emphasis"><em>session</em></span> is a collection of process groups. A process’s
                session membership is determined by its <span class="emphasis"><em>session identifier</em></span>
                (SID), which, like the process group ID, is a number of type
                    <span class="emphasis"><em>pid_t</em></span>. A <span class="emphasis"><em>session leader</em></span> is the process
                that creates a new session and whose process ID becomes the session ID. A new
                process inherits its parent’s session ID.<a id="IDX-CHP-34-4945" class="indexterm"/><a id="IDX-CHP-34-4946" class="indexterm"/></p><p>All of the processes in a session share a single <span class="emphasis"><em>controlling
                    terminal</em></span>. The controlling terminal is established when the session
                leader first opens a terminal device. A terminal may be the controlling terminal of
                at most one session.<a id="IDX-CHP-34-4947" class="indexterm"/></p><p>At any point in time, one of the process groups in a session is the
                    <span class="emphasis"><em>foreground process group</em></span> for the terminal, and the others
                are <span class="emphasis"><em>background process groups</em></span>. Only processes in the foreground
                process group can read input from the controlling terminal. When the user types one
                of the signal-generating terminal characters on the controlling terminal, a signal
                is sent to all members of the foreground process group. These characters are the
                    <span class="emphasis"><em>interrupt</em></span> character (usually
                <span class="emphasis"><em>Control-C</em></span>), which generates <code class="literal">SIGINT</code>; the <span class="emphasis"><em>quit</em></span> character (usually
                    <span class="emphasis"><em>Control-\</em></span>), which generates <code class="literal">SIGQUIT</code>; and the <span class="emphasis"><em>suspend</em></span> character (usually
                    <span class="emphasis"><em>Control-Z</em></span>), which generates <code class="literal">SIGTSTP</code>.<a id="IDX-CHP-34-4948" class="indexterm"/></p><p>As a consequence of establishing the connection to (i.e., opening) the controlling
                terminal, the session leader becomes the <span class="emphasis"><em>controlling process</em></span>
                for the terminal. The principal significance of being the controlling process is
                that the kernel sends this process a <code class="literal">SIGHUP</code>
                signal if a terminal disconnect occurs.<a id="IDX-CHP-34-4949" class="indexterm"/><a id="IDX-CHP-34-4950" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>By inspecting the Linux-specific <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/stat</code> files, we can determine the process group ID and session ID
                    of any process. We can also determine the device ID of the process’s controlling
                    terminal (expressed as a single decimal integer containing both major and minor
                    IDs) and the process ID of the controlling process for that terminal. See the
                        <span class="emphasis"><em>proc(5)</em></span> manual page for further details.</p></div><p>The main use of sessions and process groups is for shell job control. Looking at a
                specific example from this domain helps clarify these concepts. For an interactive
                login, the controlling terminal is the one on which the user logs in. The login
                shell becomes the session leader and the controlling process for the terminal, and
                is also made the sole member of its own process group. Each command or pipeline of
                commands started from the shell results in the creation of one or more processes,
                and the shell places all of these processes in a new process group. (These processes
                are initially the only members of that process group, although any child processes
                that they create will also be members of the group.) A command or pipeline is
                created as a background process group if it is terminated with an ampersand
                    (<code class="literal">&amp;</code>). Otherwise, it becomes the
                foreground process group. All processes created during the login session are part of
                the same session.<a id="IDX-CHP-34-4951" class="indexterm"/><a id="IDX-CHP-34-4952" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In a windowing environment, the controlling terminal is a pseudoterminal, and
                    there is a separate session for each terminal window, with the window’s startup
                    shell being the session leader and controlling process for the terminal.</p><p>Process groups occasionally find uses in areas other than job control, since
                    they have two useful properties: a parent process can wait on any of its
                    children in a particular process group (<a class="xref" href="ch26.html#the_waitpid_open_parenthesis_close_paren" title="The waitpid() System Call">The <span class="emphasis"><em>waitpid()</em></span> System Call</a>), and a signal can be
                    sent to all of the members of a process group (<a class="xref" href="ch20.html#sending_signals_colon_kill_open_parenthe" title="Sending Signals: kill()">Sending Signals: <span class="emphasis"><em>kill()</em></span></a>).</p></div><p><a class="xref" href="ch34.html#relationships_between_process_groups_com" title="Figure 34-1. Relationships between process groups, sessions, and the controlling terminal">Figure 34-1</a> shows the process group
                and session relationships between the various processes resulting from the execution
                of the following commands:<a id="IDX-CHP-34-4953" class="indexterm"/></p><a id="I_programlisting34_d1e93024"/><pre class="programlisting">$ <strong class="userinput"><code>echo $$</code></strong>                             <em class="lineannotation"><span class="lineannotation">Display the PID of the shell</span></em>
400
$ <strong class="userinput"><code>find / 2&gt; /dev/null | wc -l &amp;</code></strong>       <em class="lineannotation"><span class="lineannotation">Creates 2 processes in background group</span></em>
[1] 659
$ <strong class="userinput"><code>sort &lt; longlist | uniq -c</code></strong>           <em class="lineannotation"><span class="lineannotation">Creates 2 processes in foreground group</span></em></pre><p>At this point, the shell (<span class="emphasis"><em>bash</em></span>), <span class="emphasis"><em>find</em></span>,
                    <span class="emphasis"><em>wc</em></span>, <span class="emphasis"><em>sort</em></span>, and
                    <span class="emphasis"><em>uniq</em></span> are all running.</p><div class="figure"><a id="relationships_between_process_groups_com"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject34_d1e93064"/><img src="figs/web/34-1_PGSJC-overview.png.jpg" alt="Relationships between process groups, sessions, and the controlling terminal"/></div></div><div class="figure-title">Figure 34-1. Relationships between process groups, sessions, and the controlling
                    terminal</div></div></div><div class="sect1" title="Process Groups"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="process_groups">Process Groups</h2></div></div></div><p>Each process has a numeric process group ID that defines the process group to
                which it belongs. A new process inherits its parent’s process group ID. A process
                can obtain its process group ID using <span class="emphasis"><em>getpgrp()</em></span>.<a id="IDX-CHP-34-4954" class="indexterm"/><a id="IDX-CHP-34-4955" class="indexterm"/><a id="IDX-CHP-34-4956" class="indexterm"/><a id="IDX-CHP-34-4957" class="indexterm"/><a id="IDX-CHP-34-4958" class="indexterm"/><a id="IDX-CHP-34-4959" class="indexterm"/><a id="IDX-CHP-34-4960" class="indexterm"/><a id="IDX-CHP-34-4961" class="indexterm"/></p><a id="I_programlisting34_d1e93123"/><pre class="programlisting">#include &lt;unistd.h&gt;

pid_t <strong class="userinput"><code>getpgrp</code></strong>(void)</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Always successfully returns process group ID of calling process</p></div><p>If the value returned by <span class="emphasis"><em>getpgrp()</em></span> matches the caller’s
                process ID, this process is the leader of its process group.<a id="IDX-CHP-34-4962" class="indexterm"/></p><p>The <span class="emphasis"><em>setpgid()</em></span> system call changes the process group of the
                process whose process ID is <span class="emphasis"><em>pid</em></span> to the value specified in
                    <span class="emphasis"><em>pgid</em></span>.<a id="IDX-CHP-34-4963" class="indexterm"/></p><a id="I_programlisting34_d1e93156"/><pre class="programlisting">#include &lt;unistd.h&gt;

int <strong class="userinput"><code>setpgid</code></strong>(pid_t <span class="emphasis"><em>pid</em></span>, pid_t <span class="emphasis"><em>pgid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>If <span class="emphasis"><em>pid</em></span> is specified as 0, the calling process’s process group
                ID is changed. If <span class="emphasis"><em>pgid</em></span> is specified as 0, then the process
                group ID of the process specified by <span class="emphasis"><em>pid</em></span> is made the same as
                its process ID. Thus, the following <span class="emphasis"><em>setpgid()</em></span> calls are
                equivalent:</p><a id="I_programlisting34_d1e93184"/><pre class="programlisting">setpgid(0, 0);
setpgid(getpid(), 0);
setpgid(getpid(), getpid());</pre><p>If the <span class="emphasis"><em>pid</em></span> and <span class="emphasis"><em>pgid</em></span> arguments specify
                the same process (i.e., <span class="emphasis"><em>pgid</em></span> is 0 or matches the process ID of
                the process specified by <span class="emphasis"><em>pid</em></span>), then a new process group is
                created, and the specified process is made the leader of the new group (i.e., the
                process group ID of the process is made the same as its process ID). If the two
                arguments specify different values (i.e., <span class="emphasis"><em>pgid</em></span> is not 0 and
                doesn’t match the process ID of the process specified by <span class="emphasis"><em>pid</em></span>),
                then <span class="emphasis"><em>setpgid()</em></span> is being used to move a process between process
                groups.</p><p>The typical callers of <span class="emphasis"><em>setpgid()</em></span> (and
                    <span class="emphasis"><em>setsid()</em></span>, described in <a class="xref" href="ch34.html#sessions" title="Sessions">Sessions</a>) are
                programs such as the shell and <span class="emphasis"><em>login(1)</em></span>. In <a class="xref" href="ch37.html#creating_a_daemon" title="Creating a Daemon">Creating a Daemon</a>, we’ll see that a program also calls
                    <span class="emphasis"><em>setsid()</em></span> as one of the steps on the way to becoming a
                daemon.</p><p>Several restrictions apply when calling <span class="emphasis"><em>setpgid()</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>pid</em></span> argument may specify only the calling process
                        or one of its children. Violation of this rule results in the error <code class="literal">ESRCH</code>.</p></li><li class="listitem"><p>When moving a process between groups, the calling process and the process
                        specified by <span class="emphasis"><em>pid</em></span> (which may be one and the same), as
                        well as the target process group, must all be part of the same session.
                        Violation of this rule results in the error <code class="literal">EPERM</code>.</p></li><li class="listitem"><p>The <span class="emphasis"><em>pid</em></span> argument may not specify a process that is a
                        session leader. Violation of this rule results in the error <code class="literal">EPERM</code>.</p></li><li class="listitem"><p>A process may not change the process group ID of one of its children after
                        that child has performed an <span class="emphasis"><em>exec()</em></span>. Violation of this
                        rule results in the error <code class="literal">EACCES</code>. The
                        rationale for this constraint is that it could confuse a program if its
                        process group ID were changed after it had commenced.</p></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="using_setpgid_open_parenthesis_close"/></div></div></div><div class="sect3" title="Using setpgid() in a job-control shell"><div class="titlepage"><div><div><h4 class="title" id="using_setpgid_open_parenthesis_close-id1">Using <span class="emphasis"><em>setpgid()</em></span> in a job-control shell</h4></div></div></div><p>The restriction that a process may not change the process group ID of one
                        of its children after that child has performed an
                            <span class="emphasis"><em>exec()</em></span> affects the programming of job-control
                        shells, which have the following requirements:<a id="IDX-CHP-34-4964" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>All of the processes in a job (i.e., a command or a pipeline) must
                                be placed in a single process group. (We can see the desired result
                                by looking at the two process groups created by
                                    <span class="emphasis"><em>bash</em></span> in <a class="xref" href="ch34.html#relationships_between_process_groups_com" title="Figure 34-1. Relationships between process groups, sessions, and the controlling terminal">Figure 34-1</a>.) This step
                                permits the shell to use <span class="emphasis"><em>killpg()</em></span> (or,
                                equivalently, <span class="emphasis"><em>kill()</em></span> with a negative
                                    <span class="emphasis"><em>pid</em></span> argument) to simultaneously send
                                job-control signals to all of the members of the process group.
                                Naturally, this step must be carried out before any job-control
                                signals are sent.</p></li><li class="listitem"><p>Each of the child processes must be transferred to the process
                                group before it execs a program, since the program itself is
                                ignorant of manipulations of the process group ID.</p></li></ul></div><p>For each process in the job, either the parent or the child could use
                            <span class="emphasis"><em>setpgid()</em></span> to change the process group ID of the
                        child. However, because the scheduling of the parent and child is
                        indeterminate after a <span class="emphasis"><em>fork()</em></span> (<a class="xref" href="ch24.html#race_conditions_after_fork_open_parenthe" title="Race Conditions After fork()">Race Conditions After <span class="emphasis"><em>fork()</em></span></a>), we can’t rely on
                        the parent changing the child’s process group ID before the child does an
                            <span class="emphasis"><em>exec()</em></span>; nor can we rely on the child changing its
                        process group ID before the parent tries to send any job-control signals to
                        it. (Dependence on either one of these behaviors would result in a race
                        condition.) Therefore, job-control shells are programmed so that the parent
                        and the child process both call <span class="emphasis"><em>setpgid()</em></span> to change the
                        child’s process group ID to the same value immediately after a
                            <span class="emphasis"><em>fork()</em></span>, and the parent ignores any occurrence of
                        the <code class="literal">EACCES</code> error on the
                            <span class="emphasis"><em>setpgid()</em></span> call. In other words, in a job-control
                        shell, we’ll find code something like that shown in <a class="xref" href="ch34.html#how_a_job-control_shell_sets_the_process" title="Example 34-1. How a job-control shell sets the process group ID of a child process">Example 34-1</a>.</p><div class="example"><a id="how_a_job-control_shell_sets_the_process"/><div class="example-title">Example 34-1. How a job-control shell sets the process group ID of a child
                            process</div><div class="example-contents"><pre class="programlisting">pid_t childPid;
    pid_t pipelinePgid;         /* PGID to which processes in a pipeline
                                    are to be assigned */
    /* Other code */

    childPid = fork();
    switch (childPid) {
    case -1: /* fork() failed */
        /* Handle error */

    case 0: /* Child */
        if (setpgid(0, pipelinePgid) == -1)
            /* Handle error */
        /* Child carries on to exec the required program */

    default: /* Parent (shell) */
        if (setpgid(childPid, pipelinePgid) == -1 &amp;&amp; errno != EACCES)
            /* Handle error */
        /* Parent carries on to do other things */
    }</pre></div></div><p>Things are slightly more complex than shown in <a class="xref" href="ch34.html#how_a_job-control_shell_sets_the_process" title="Example 34-1. How a job-control shell sets the process group ID of a child process">Example 34-1</a>, since, when
                        creating the processes for a pipeline, the parent shell records the process
                        ID of the first process in the pipeline and uses this as the process group
                        ID (<span class="emphasis"><em>pipelinePgid</em></span>) for all of the processes in the
                        group.</p></div><div class="sect3" title="Other (obsolete) interfaces for retrieving and modifying process group IDs"><div class="titlepage"><div><div><h4 class="title" id="other_open_parenthesis_obsolete_close_pa">Other (obsolete) interfaces for retrieving and modifying process group
                        IDs</h4></div></div></div><p>The different suffixes in the names of the <span class="emphasis"><em>getpgrp()</em></span>
                        and <span class="emphasis"><em>setpgid()</em></span> system calls deserve
                            explanation.<a id="IDX-CHP-34-4965" class="indexterm"/><a id="IDX-CHP-34-4966" class="indexterm"/><a id="IDX-CHP-34-4967" class="indexterm"/><a id="IDX-CHP-34-4968" class="indexterm"/></p><p>In the beginning, 4.2BSD provided a <span class="emphasis"><em>getprgp(pid)</em></span>
                        system call that returned the process group ID of the process specified by
                            <span class="emphasis"><em>pid</em></span>. In practice, <span class="emphasis"><em>pid</em></span> was
                        always used to specify the calling process. Consequently, the POSIX
                        committee deemed the call to be more complex than necessary, and instead
                        adopted the System V <span class="emphasis"><em>getpgrp()</em></span> call, which took no
                        arguments and returned the process group ID of the calling process.</p><p>In order to change the process group ID, 4.2BSD provided the call
                            <span class="emphasis"><em>setpgrp(pid, pgid)</em></span>, which operated in a similar
                        manner to <span class="emphasis"><em>setpgid()</em></span>. The principal difference was that
                        the BSD <span class="emphasis"><em>setpgrp()</em></span> could be used to set the process
                        group ID to any value. (We noted earlier that <span class="emphasis"><em>setpgid()</em></span>
                        can’t transfer a process into a process group in a different session.) This
                        resulted in some security issues and was also more flexible than required
                        for implementing job control. Consequently, the POSIX committee settled on a
                        more restrictive function and gave it the name
                            <span class="emphasis"><em>setpgid()</em></span>.<a id="IDX-CHP-34-4969" class="indexterm"/><a id="IDX-CHP-34-4970" class="indexterm"/></p><p>To further complicate matters, SUSv3 specifies
                            <span class="emphasis"><em>getpgid(pid)</em></span>, with the same semantics as the old
                        BSD <span class="emphasis"><em>getpgrp()</em></span>, and also weakly specifies an
                        alternative, System V-derived version of <span class="emphasis"><em>setpgrp()</em></span>,
                        taking no arguments, as being approximately equivalent to
                            <span class="emphasis"><em>setpgid(0, 0)</em></span>.</p><p>Although the <span class="emphasis"><em>setpgid()</em></span> and
                            <span class="emphasis"><em>getpgrp()</em></span> system calls that we described earlier
                        are sufficient for implementing shell job control, Linux, like most other
                        UNIX implementations, also provides <span class="emphasis"><em>getpgid(pid)</em></span> and
                            <span class="emphasis"><em>setpgrp(void)</em></span>. For backward compatibility, many
                        BSD-derived implementations continue to provide <span class="emphasis"><em>setprgp(pid,
                            pgid)</em></span> as a synonym for <span class="emphasis"><em>setpgid(pid,
                            pgid)</em></span>.</p><p>If we explicitly define the <code class="literal">_BSD_SOURCE</code>
                        feature test macro when compiling a program, then <span class="emphasis"><em>glibc</em></span>
                        provides the BSD-derived versions of <span class="emphasis"><em>setpgrp()</em></span> and
                            <span class="emphasis"><em>getpgrp()</em></span>, instead of the default versions.</p></div></div></div><div class="sect1" title="Sessions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sessions">Sessions</h2></div></div></div><p>A <span class="emphasis"><em>session</em></span> is a collection of process groups. The session
                membership of a process is defined by its numeric session ID. A new process inherits
                its parent’s session ID. The <span class="emphasis"><em>getsid()</em></span> system call returns the
                session ID of the process specified by <span class="emphasis"><em>pid</em></span>.<a id="IDX-CHP-34-4971" class="indexterm"/><a id="IDX-CHP-34-4972" class="indexterm"/><a id="IDX-CHP-34-4973" class="indexterm"/><a id="IDX-CHP-34-4974" class="indexterm"/><a id="IDX-CHP-34-4975" class="indexterm"/><a id="IDX-CHP-34-4976" class="indexterm"/><a id="IDX-CHP-34-4977" class="indexterm"/></p><a id="I_programlisting34_d1e93517"/><pre class="programlisting">#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;

pid_t <strong class="userinput"><code>getsid</code></strong>(pid_t <span class="emphasis"><em>pid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns session ID of specified process, or <span class="emphasis"><em>(pid_t)</em></span> -1 on
                    error</p></div><p>If <span class="emphasis"><em>pid</em></span> is specified as 0, <span class="emphasis"><em>getsid()</em></span>
                returns the session ID of the calling process.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On a few UNIX implementations (e.g., HP-UX 11), <span class="emphasis"><em>getsid()</em></span>
                    can be used to retrieve the session ID of a process only if it is in the same
                    session as the calling process. (SUSv3 permits this possibility.) In other
                    words, the call merely serves, by its success or failure (<code class="literal">EPERM</code>), to inform us if the specified process is
                    in the same session as the caller. This restriction doesn’t apply on Linux or on
                    most other implementations.<a id="IDX-CHP-34-4978" class="indexterm"/><a id="IDX-CHP-34-4979" class="indexterm"/></p></div><p>If the calling process is not a process group leader,
                    <span class="emphasis"><em>setsid()</em></span> creates a new session.<a id="IDX-CHP-34-4980" class="indexterm"/><a id="IDX-CHP-34-4981" class="indexterm"/><a id="IDX-CHP-34-4982" class="indexterm"/></p><a id="I_programlisting34_d1e93575"/><pre class="programlisting">#include &lt;unistd.h&gt;

pid_t <strong class="userinput"><code>setsid</code></strong>(void);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns session ID of new session, or <span class="emphasis"><em>(pid_t)</em></span> -1 on
                    error</p></div><p>The <span class="emphasis"><em>setsid()</em></span> system call creates a new session as
                follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The calling process becomes the leader of a new session, ands is made the
                        leader of a new process group within that session. The calling process’s
                        process group ID and session ID are set to the same value as its process
                            ID.<a id="IDX-CHP-34-4983" class="indexterm"/><a id="IDX-CHP-34-4984" class="indexterm"/></p></li><li class="listitem"><p>The calling process has no controlling terminal. Any previously existing
                        connection to a controlling terminal is broken.<a id="IDX-CHP-34-4985" class="indexterm"/></p></li></ul></div><p>If the calling process is a process group leader, <span class="emphasis"><em>setsid()</em></span>
                fails with the error <code class="literal">EPERM</code>. The simplest way of
                ensuring that this doesn’t happen is to perform a <span class="emphasis"><em>fork()</em></span> and
                have the parent exit while the child carries on to call
                    <span class="emphasis"><em>setsid()</em></span>. Since the child inherits its parent’s process
                group ID and receives its own unique process ID, it can’t be a process group
                leader.</p><p>The restriction against a process group leader being able to call
                    <span class="emphasis"><em>setsid()</em></span> is necessary because, without it, the process
                group leader would be able to place itself in another (new) session, while other
                members of the process group remained in the original session. (A new process group
                would not be created, since, by definition, the process group leader’s process group
                ID is already the same as its process ID.) This would violate the strict two-level
                hierarchy of sessions and process groups, whereby all members of a process group
                must be part of the same session.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When a new process is created via <span class="emphasis"><em>fork()</em></span>, the kernel
                    ensures not only that it has a unique process ID, but also that the process ID
                    doesn’t match the process group ID or session ID of any existing process. Thus,
                    even if the leader of a process group or a session has exited, a new process
                    can’t reuse the leader’s process ID and thereby accidentally become the leader
                    of an existing session or process group.</p></div><p><a class="xref" href="ch34.html#creating_a_new_session" title="Example 34-2. Creating a new session">Example 34-2</a> demonstrates the use of
                    <span class="emphasis"><em>setsid()</em></span> to create a new session. To check that it no
                longer has a controlling terminal, this program attempts to open the special file
                    <code class="literal">/dev/tty</code> (described in the next section).
                When we run this program, we see the following:</p><a id="I_programlisting34_d1e93642"/><pre class="programlisting">$ <strong class="userinput"><code>ps -p $$ -o 'pid pgid sid command'</code></strong>            <em class="lineannotation"><span class="lineannotation">$$ is PID of shell</span></em>
  PID  PGID   SID COMMAND
12243 12243 12243 bash                          <em class="lineannotation"><span class="lineannotation">PID, PGID, and SID of shell</span></em>
$ <strong class="userinput"><code>./t_setsid</code></strong>
$ PID=12352, PGID=12352, SID=12352
ERROR [ENXIO Device not configured] open /dev/tty</pre><p>As can be seen from the output, the process successfully places itself in a new
                process group within a new session. Since this session has no controlling terminal,
                the <span class="emphasis"><em>open()</em></span> call fails. (In the penultimate line of program
                output above, we see a shell prompt mixed with the program output, because the shell
                notices that the parent process has exited after the <span class="emphasis"><em>fork()</em></span>
                call, and so prints its next prompt before the child has completed.)<a id="IDX-CHP-34-4986" class="indexterm"/></p><div class="example"><a id="creating_a_new_session"/><div class="example-title">Example 34-2. Creating a new session</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>pgsjc/t_setsid.c</code></strong>
#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    if (fork() != 0)            /* Exit if parent, or on error */
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        errExit("setsid");

    printf("PID=%ld, PGID=%ld, SID=%ld\n", (long) getpid(),
            (long) getpgrp(), (long) getsid(0));

    if (open("/dev/tty", O_RDWR) == -1)
        errExit("open /dev/tty");
    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>pgsjc/t_setsid.c</code></strong></pre></div></div></div><div class="sect1" title="Controlling Terminals and Controlling Processes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="controlling_terminals_and_controlling_pr">Controlling Terminals and Controlling Processes</h2></div></div></div><p>All of the processes in a session may have a (single) controlling terminal. Upon
                creation, a session has no controlling terminal; the controlling terminal is
                established when the session leader first opens a terminal that is not already the
                controlling terminal for a session, unless the <code class="literal">O_NOCTTY</code> flag is specified when calling <span class="emphasis"><em>open()</em></span>.
                A terminal may be the controlling terminal for at most one session.<a id="IDX-CHP-34-4987" class="indexterm"/><a id="IDX-CHP-34-4988" class="indexterm"/><a id="IDX-CHP-34-4989" class="indexterm"/><a id="IDX-CHP-34-4990" class="indexterm"/><a id="IDX-CHP-34-4991" class="indexterm"/><a id="IDX-CHP-34-4992" class="indexterm"/><a id="IDX-CHP-34-4993" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 specifies the function <span class="emphasis"><em>tcgetsid(int fd)</em></span> (prototyped
                    in <code class="literal">&lt;termios.h&gt;</code>), which returns
                    the ID of the session associated with the controlling terminal specified by
                        <span class="emphasis"><em>fd</em></span>. This function is provided in
                        <span class="emphasis"><em>glibc</em></span> (where it is implemented using the
                        <span class="emphasis"><em>ioctl()</em></span>
                    <code class="literal">TIOCGSID</code> operation).</p></div><p>The controlling terminal is inherited by the child of a
                    <span class="emphasis"><em>fork()</em></span> and preserved across an
                <span class="emphasis"><em>exec()</em></span>.</p><p>When a session leader opens a controlling terminal, it simultaneously becomes the
                controlling process for the terminal. If a terminal disconnect subsequently occurs,
                the kernel sends the controlling process a <code class="literal">SIGHUP</code>
                signal to inform it of this event. We go into further detail on this point in <a class="xref" href="ch34.html#sighup_and_termination_of_the_controllin" title="SIGHUP and Termination of the Controlling Process"><code class="literal">SIGHUP</code> and Termination of the Controlling
                    Process</a>.<a id="IDX-CHP-34-4994" class="indexterm"/><a id="IDX-CHP-34-4995" class="indexterm"/></p><p>If a process has a controlling terminal, opening the special file <code class="literal">/dev/tty</code> obtains a file descriptor for that terminal.
                This is useful if standard input and output are redirected, and a program wants to
                ensure that it is communicating with the controlling terminal. For example, the
                    <span class="emphasis"><em>getpass()</em></span> function described in <a class="xref" href="ch08.html#password_encryption_and_user_authenticat" title="Password Encryption and User Authentication">Password Encryption and User Authentication</a> opens <code class="literal">/dev/tty</code> for this purpose. If the process doesn’t have
                a controlling terminal, opening <code class="literal">/dev/tty</code> fails
                with the error <code class="literal">ENXIO</code>.<a id="IDX-CHP-34-4996" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="removing_a_process_number_symble"/></div></div></div><div class="sect3" title="Removing a process’s association with the controlling terminal"><div class="titlepage"><div><div><h4 class="title" id="removing_a_process_number_symble-id1">Removing a process’s association with the controlling terminal</h4></div></div></div><p>The <span class="emphasis"><em>ioctl(fd, TIOCNOTTY)</em></span> operation can be used to
                        remove a process’s association with its controlling terminal, specified via
                        the file descriptor <span class="emphasis"><em>fd</em></span>. After this call, attempts to
                        open <code class="literal">/dev/tty</code> will fail. (Although not
                        specified in SUSv3, the <code class="literal">TIOCNOTTY</code>
                        operation is supported on most UNIX implementations.)<a id="IDX-CHP-34-4997" class="indexterm"/><a id="IDX-CHP-34-4998" class="indexterm"/><a id="IDX-CHP-34-4999" class="indexterm"/><a id="IDX-CHP-34-5000" class="indexterm"/><a id="IDX-CHP-34-5001" class="indexterm"/><a id="IDX-CHP-34-5002" class="indexterm"/><a id="IDX-CHP-34-5003" class="indexterm"/><a id="IDX-CHP-34-5004" class="indexterm"/><a id="IDX-CHP-34-5005" class="indexterm"/></p><p>If the calling process is the controlling process for the terminal, then
                        as for the termination of the controlling process (<a class="xref" href="ch34.html#sighup_and_termination_of_the_controllin" title="SIGHUP and Termination of the Controlling Process"><code class="literal">SIGHUP</code> and Termination of the Controlling
                    Process</a>), the following
                        steps occur:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>All processes in the session lose their association with the
                                controlling terminal.</p></li><li class="listitem"><p>The controlling terminal loses its association with the session,
                                and can therefore be acquired as the controlling process by another
                                session leader.</p></li><li class="listitem"><p>The kernel sends a <code class="literal">SIGHUP</code>
                                signal (and a <code class="literal">SIGCONT</code> signal) to
                                all members of the foreground process group, to inform them of the
                                loss of the controlling terminal.</p></li></ol></div></div><div class="sect3" title="Establishing a controlling terminal on BSD"><div class="titlepage"><div><div><h4 class="title" id="establishing_a_controlling_terminal_on_b">Establishing a controlling terminal on BSD</h4></div></div></div><p>SUSv3 leaves the manner in which a session acquires a controlling terminal
                        unspecified, merely stating that specifying the <code class="literal">O_NOCTTY</code> flag when opening a terminal guarantees that the
                        terminal won’t become a controlling terminal for the session. The Linux
                        semantics that we have described above derive from System V.</p><p>On BSD systems, opening a terminal in the session leader never causes the
                        terminal to become a controlling terminal, regardless of whether the
                            <code class="literal">O_NOCTTY</code> flag is specified. Instead,
                        the session leader uses the <span class="emphasis"><em>ioctl()</em></span>
                        <code class="literal">TIOCSCTTY</code> operation to explicitly
                        establish the terminal referred to by the file descriptor
                            <span class="emphasis"><em>fd</em></span> as the controlling terminal:</p><a id="I_programlisting34_d1e93910"/><pre class="programlisting">if (ioctl(fd, TIOCSCTTY) == -1)
    errExit("ioctl");</pre><p>This operation can be performed only if the session doesn’t already have a
                        controlling terminal.</p><p>The <code class="literal">TIOCSCTTY</code> operation is also
                        available on Linux, but it is not widespread on other (non-BSD)
                        implementations.</p></div><div class="sect3" title="Obtaining a pathname that refers to the controlling terminal: ctermid()"><div class="titlepage"><div><div><h4 class="title" id="obtaining_a_pathname_that_refers_to_the">Obtaining a pathname that refers to the controlling terminal:
                            <span class="emphasis"><em>ctermid()</em></span></h4></div></div></div><p>The <span class="emphasis"><em>ctermid()</em></span> function returns a pathname referring
                        to the controlling terminal.<a id="IDX-CHP-34-5006" class="indexterm"/></p><a id="I_programlisting34_d1e93933"/><pre class="programlisting">#include &lt;stdio.h&gt;            /* Defines L_ctermid constant */

char *<strong class="userinput"><code>ctermid</code></strong>(char *<span class="emphasis"><em>ttyname</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns pointer to string containing pathname of controlling terminal,
                            or <code class="literal">NULL</code> if pathname could not be
                            determined</p></div><p>The <span class="emphasis"><em>ctermid()</em></span> function returns the controlling
                        terminal’s pathname in two different ways: via the function result and via
                        the buffer pointed to by <span class="emphasis"><em>ttyname</em></span>.</p><p>If <span class="emphasis"><em>ttyname</em></span> is not <code class="literal">NULL</code>, then it should be a buffer of at least <code class="literal">L_ctermid</code> bytes, and the pathname is copied
                        into this array. In this case, the function return value is also a pointer
                        to this buffer. If <span class="emphasis"><em>ttyname</em></span> is <code class="literal">NULL</code>, <span class="emphasis"><em>ctermid()</em></span> returns a pointer to a
                        statically allocated buffer containing the pathname. When
                            <span class="emphasis"><em>ttyname</em></span> is <code class="literal">NULL</code>,
                            <span class="emphasis"><em>ctermid()</em></span> is not reentrant.</p><p>On Linux and other UNIX implementations, <span class="emphasis"><em>ctermid()</em></span>
                        typically yields the string <code class="literal">/dev/tty</code>. The
                        purpose of this function is to ease portability to non-UNIX systems.</p></div></div></div><div class="sect1" title="Foreground and Background Process Groups"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="foreground_and_background_process_groups">Foreground and Background Process Groups</h2></div></div></div><p>The controlling terminal maintains the notion of a foreground process group.
                Within a session, only one process group can be in the foreground at a particular
                moment; all of the other process groups in the session are background process
                groups. The foreground process group is the only process group that can freely read
                and write on the controlling terminal. When one of the signal-generating terminal
                characters is typed on the controlling terminal, the terminal driver delivers the
                corresponding signal to the members of the foreground process group. We describe
                further details in Section 34.7.<a id="IDX-CHP-34-5007" class="indexterm"/><a id="IDX-CHP-34-5008" class="indexterm"/><a id="IDX-CHP-34-5009" class="indexterm"/><a id="IDX-CHP-34-5010" class="indexterm"/><a id="IDX-CHP-34-5011" class="indexterm"/><a id="IDX-CHP-34-5012" class="indexterm"/><a id="IDX-CHP-34-5013" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In theory, situations can arise where a session has no foreground process
                    group. This could happen, for example, if all processes in the foreground
                    process group terminate, and no other process notices this fact and moves itself
                    into the foreground. In practice, such situations are rare. Normally, the shell
                    is the process monitoring the status of the foreground process group, and it
                    moves itself back into the foreground when it notices (via
                        <span class="emphasis"><em>wait()</em></span>) that the foreground process group has
                    terminated.</p></div><p>The <span class="emphasis"><em>tcgetpgrp()</em></span> and <span class="emphasis"><em>tcsetpgrp()</em></span>
                functions respectively retrieve and change the process group of a terminal. These
                functions are used primarily by job-control shells.<a id="IDX-CHP-34-5014" class="indexterm"/><a id="IDX-CHP-34-5015" class="indexterm"/></p><a id="I_programlisting34_d1e94055"/><pre class="programlisting">#include &lt;unistd.h&gt;

pid_t <strong class="userinput"><code>tcgetpgrp</code></strong>(int <span class="emphasis"><em>fd</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns process group ID of terminal’s foreground process group, or -1 on
                    error</p></div><a id="I_programlisting34_d1e94066"/><pre class="programlisting">int <strong class="userinput"><code>tcsetpgrp</code></strong>(int <span class="emphasis"><em>fd</em></span>, pid_t <span class="emphasis"><em>pgid</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>tcgetpgrp()</em></span> function returns the process group ID of the
                foreground process group of the terminal referred to by the file descriptor
                    <span class="emphasis"><em>fd</em></span>, which must be the controlling terminal of the calling
                process.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If there is no foreground process group for this terminal,
                        <span class="emphasis"><em>tcgetpgrp()</em></span> returns a value greater than 1 that doesn’t
                    match the ID of any existing process group. (This is the behavior specified by
                    SUSv3.)</p></div><p>The <span class="emphasis"><em>tcsetpgrp()</em></span> function changes the foreground process group
                for a terminal. If the calling process has a controlling terminal, and the file
                descriptor <span class="emphasis"><em>fd</em></span> refers to that terminal, then
                    <span class="emphasis"><em>tcsetpgrp()</em></span> sets the foreground process group of the
                terminal to the value specified in <span class="emphasis"><em>pgid</em></span>, which must match the
                process group ID of one of the processes in the calling process’s session.</p><p>Both <span class="emphasis"><em>tcgetpgrp()</em></span> and <span class="emphasis"><em>tcsetpgrp()</em></span> are
                standardized in SUSv3. On Linux, as on many other UNIX implementations, these
                functions are implemented using two unstandardized <span class="emphasis"><em>ioctl()</em></span>
                operations: <code class="literal">TIOCGPGRP</code> and <code class="literal">TIOCSPGRP</code>.</p></div><div class="sect1" title="The SIGHUP Signal"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_sighup_signal">The <code class="literal">SIGHUP</code> Signal</h2></div></div></div><p>When a controlling process loses its terminal connection, the kernel sends it a
                    <code class="literal">SIGHUP</code> signal to inform it of this fact. (A
                    <code class="literal">SIGCONT</code> signal is also sent, to ensure that
                the process is restarted in case it had been previously stopped by a signal.)
                Typically, this may occur in two circumstances:<a id="IDX-CHP-34-5016" class="indexterm"/><a id="IDX-CHP-34-5017" class="indexterm"/><a id="IDX-CHP-34-5018" class="indexterm"/><a id="IDX-CHP-34-5019" class="indexterm"/><a id="IDX-CHP-34-5020" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When a “disconnect” is detected by the terminal driver, indicating a loss
                        of signal on a modem or terminal line.<a id="IDX-CHP-34-5021" class="indexterm"/></p></li><li class="listitem"><p>When a terminal window is closed on a workstation. This occurs because the
                        last open file descriptor for the master side of the pseudoterminal
                        associated with the terminal window is closed.</p></li></ul></div><p>The default action of <code class="literal">SIGHUP</code> is to terminate a
                process. If the controlling process instead handles or ignores this signal, then
                further attempts to read from the terminal return end-of-file.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 states that if both a terminal disconnect occurs and one of the
                    conditions giving rise to an <code class="literal">EIO</code> error from
                        <span class="emphasis"><em>read()</em></span> exists, then it is unspecified whether
                        <span class="emphasis"><em>read()</em></span> returns end-of-file or fails with the error
                        <code class="literal">EIO</code>. Portable programs must allow for
                    both possibilities. We look at the circumstances in which
                        <span class="emphasis"><em>read()</em></span> may fail with the <code class="literal">EIO</code> error in <a class="xref" href="ch34.html#implementing_job_control" title="Implementing Job Control">Implementing Job Control</a> and <a class="xref" href="ch34.html#orphaned_process_groups_open_parenthesis" title="Orphaned Process Groups (and SIGHUP Revisited)">Orphaned Process Groups (and <code class="literal">SIGHUP</code>
                    Revisited)</a>.<a id="IDX-CHP-34-5022" class="indexterm"/></p></div><p>The delivery of <code class="literal">SIGHUP</code> to the controlling
                process can set off a kind of chain reaction, resulting in the delivery of <code class="literal">SIGHUP</code> to many other processes. This may occur in two
                ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The controlling process is typically a shell. The shell establishes a
                        handler for <code class="literal">SIGHUP</code>, so that, before
                        terminating, it can send a <code class="literal">SIGHUP</code> to each
                        of the jobs that it has created. This signal terminates those jobs by
                        default, but if instead they catch the signal, then they are thus informed
                        of the shell’s demise.</p></li><li class="listitem"><p>Upon termination of the controlling process for a terminal, the kernel
                        disassociates all processes in the session from the controlling terminal,
                        disassociates the controlling terminal from the session (so that it may be
                        acquired as the controlling terminal by another session leader), and informs
                        the members of the foreground process group of the terminal of the loss of
                        their controlling terminal by sending them a <code class="literal">SIGHUP</code> signal.</p></li></ul></div><p>We go into the details of each of these two cases in the next sections.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">SIGHUP</code> signal also finds other uses. In
                        <a class="xref" href="ch34.html#orphaned_process_groups_open_parenthesis" title="Orphaned Process Groups (and SIGHUP Revisited)">Orphaned Process Groups (and <code class="literal">SIGHUP</code>
                    Revisited)</a>, we’ll see that
                        <code class="literal">SIGHUP</code> is generated when a process group
                    becomes orphaned. In addition, manually sending <code class="literal">SIGHUP</code> is conventionally used as a way of triggering a daemon
                    process to reinitialize itself or reread its configuration file. (By definition,
                    a daemon process doesn’t have a controlling terminal, and so can’t otherwise
                    receive <code class="literal">SIGHUP</code> from the kernel.) We describe
                    the use of <code class="literal">SIGHUP</code> with daemon processes in
                    Section 37.4.</p></div><div class="sect2" title="Handling of SIGHUP by the Shell"><div class="titlepage"><div><div><h3 class="title" id="handling_of_sighup_by_the_shell">Handling of <code class="literal">SIGHUP</code> by the Shell</h3></div></div></div><p>In a login session, the shell is normally the controlling process for the
                    terminal. Most shells are programmed so that, when run interactively, they
                    establish a handler for <code class="literal">SIGHUP</code>. This handler
                    terminates the shell, but beforehand sends a <code class="literal">SIGHUP</code> signal to each of the process groups (both foreground and
                    background) created by the shell. (The <code class="literal">SIGHUP</code>
                    signal may be followed by a <code class="literal">SIGCONT</code> signal,
                    depending on the shell and whether or not the job is currently stopped.) How the
                    processes in these groups respond to <code class="literal">SIGHUP</code>
                    is application-dependent; if no special action is taken, they are terminated by
                        default.<a id="IDX-CHP-34-5023" class="indexterm"/><a id="IDX-CHP-34-5024" class="indexterm"/><a id="IDX-CHP-34-5025" class="indexterm"/><a id="IDX-CHP-34-5026" class="indexterm"/><a id="IDX-CHP-34-5027" class="indexterm"/><a id="IDX-CHP-34-5028" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some job-control shells also send <code class="literal">SIGHUP</code> to stopped background jobs if the shell exits normally
                        (e.g., when we explicitly log out or type <span class="emphasis"><em>Control-D</em></span> in
                        a shell window). This is done by both <span class="emphasis"><em>bash</em></span> and the Korn
                        shell (after printing a message on the first logout attempt).</p><p>The <span class="emphasis"><em>nohup(1)</em></span> command can be used to make a command
                        immune to the <code class="literal">SIGHUP</code> signal—that is,
                        start it with the disposition of <code class="literal">SIGHUP</code>
                        set to <code class="literal">SIG_IGN.</code> The
                            <span class="emphasis"><em>bash</em></span> built-in command <span class="emphasis"><em>disown</em></span>
                        serves a similar purpose, removing a job from the shell’s list of jobs, so
                        that the job is not sent <code class="literal">SIGHUP</code> when the
                        shell terminates.</p></div><p>We can use the program in <a class="xref" href="ch34.html#catching_sighup" title="Example 34-3. Catching SIGHUP">Example 34-3</a> to demonstrate
                    that when the shell receives <code class="literal">SIGHUP</code>, it in
                    turn sends <code class="literal">SIGHUP</code> to the jobs it has created.
                    The main task of this program is to create a child process, and then have both
                    the parent and the child pause to catch <code class="literal">SIGHUP</code> and display a message if it is received. If the program is
                    given an optional command-line argument (which may be any string), the child
                    places itself in a different process group (within the same session). This is
                    useful to show that the shell doesn’t send <code class="literal">SIGHUP</code> to a process group that it did not create, even if it is
                    in the same session as the shell. (Since the final <code class="literal">for</code> loop of the program loops forever, this program uses
                        <span class="emphasis"><em>alarm()</em></span> to establish a timer to deliver <code class="literal">SIGALRM</code>. The arrival of an unhandled <code class="literal">SIGALRM</code> signal guarantees process termination, if
                    the process is not otherwise terminated.)</p><div class="example"><a id="catching_sighup"/><div class="example-title">Example 34-3. Catching <code class="literal">SIGHUP</code></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>pgsjc/catch_SIGHUP.c</code></strong>
#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include "tlpi_hdr.h"

static void
handler(int sig)
{
}
int
main(int argc, char *argv[])
{
    pid_t childPid;
    struct sigaction sa;

    setbuf(stdout, NULL);       /* Make stdout unbuffered */

    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = handler;
    if (sigaction(SIGHUP, &amp;sa, NULL) == -1)
        errExit("sigaction");

    childPid = fork();
    if (childPid == -1)
        errExit("fork");

    if (childPid == 0 &amp;&amp; argc &gt; 1)
        if (setpgid(0, 0) == -1)        /* Move to new process group */
            errExit("setpgid");

    printf("PID=%ld; PPID=%ld; PGID=%ld; SID=%ld\n", (long) getpid(),
            (long) getppid(), (long) getpgrp(), (long) getsid(0));

    alarm(60);                 /* An unhandled SIGALRM ensures this process
                                  will die if nothing else terminates it */
    for(;;) {                  /* Wait for signals */
        pause();
        printf("%ld: caught SIGHUP\n", (long) getpid());
    }
}
     <strong class="userinput"><code>pgsjc/catch_SIGHUP.c</code></strong></pre></div></div><p>Suppose that we enter the following commands in a terminal window in order to
                    run two instances of the program in <a class="xref" href="ch34.html#catching_sighup" title="Example 34-3. Catching SIGHUP">Example 34-3</a>, and then
                    we close the terminal window:</p><a id="I_programlisting34_d1e94406"/><pre class="programlisting">$ <strong class="userinput"><code>echo $$</code></strong>                                   <em class="lineannotation"><span class="lineannotation">PID of shell is ID of session</span></em>
5533
$ <strong class="userinput"><code>./catch_SIGHUP &gt; samegroup.log 2&gt;&amp;1 &amp;</code></strong>
$ <strong class="userinput"><code>./catch_SIGHUP x &gt; diffgroup.log 2&gt;&amp;1</code></strong></pre><p>The first command results in the creation of two processes that remain in the
                    process group created by the shell. The second command creates a child that
                    places itself in a separate process group.</p><p>When we look at <code class="literal">samegroup.log</code>, we see that
                    it contains the following output, indicating that both members of this process
                    group were signaled by the shell:</p><a id="I_programlisting34_d1e94426"/><pre class="programlisting">$ <strong class="userinput"><code>cat samegroup.log</code></strong>
PID=5612; PPID=5611; PGID=5611; SID=5533    <em class="lineannotation"><span class="lineannotation">Child</span></em>
PID=5611; PPID=5533; PGID=5611; SID=5533    <em class="lineannotation"><span class="lineannotation">Parent</span></em>
5611: caught SIGHUP
5612: caught SIGHUP</pre><p>When we examine <code class="literal">diffgroup.log</code>, we find the
                    following output, indicating that when the shell received <code class="literal">SIGHUP</code>, it did not send a signal to the process
                    group that it did not create:</p><a id="I_programlisting34_d1e94446"/><pre class="programlisting">$ <strong class="userinput"><code>cat diffgroup.log</code></strong>
PID=5614; PPID=5613; PGID=5614; SID=5533    <em class="lineannotation"><span class="lineannotation">Child</span></em>
PID=5613; PPID=5533; PGID=5613; SID=5533    <em class="lineannotation"><span class="lineannotation">Parent</span></em>
5613: caught SIGHUP                         <em class="lineannotation"><span class="lineannotation">Parent was signaled, but not child</span></em></pre></div><div class="sect2" title="SIGHUP and Termination of the Controlling Process"><div class="titlepage"><div><div><h3 class="title" id="sighup_and_termination_of_the_controllin"><code class="literal">SIGHUP</code> and Termination of the Controlling
                    Process</h3></div></div></div><p>If the <code class="literal">SIGHUP</code> signal that is sent to the
                    controlling process as the result of a terminal disconnect causes the
                    controlling process to terminate, then <code class="literal">SIGHUP</code>
                    is sent to all of the members of the terminal’s foreground process group (refer
                    to <a class="xref" href="ch25.html#details_of_process_termination" title="Details of Process Termination">Details of Process Termination</a>). This behavior is a
                    consequence of the termination of the controlling process, rather than a
                    behavior associated specifically with the <code class="literal">SIGHUP</code> signal. If the controlling process terminates for any
                    reason, then the foreground process group is signaled with <code class="literal">SIGHUP</code>.<a id="IDX-CHP-34-5029" class="indexterm"/><a id="IDX-CHP-34-5030" class="indexterm"/><a id="IDX-CHP-34-5031" class="indexterm"/><a id="IDX-CHP-34-5032" class="indexterm"/><a id="IDX-CHP-34-5033" class="indexterm"/><a id="IDX-CHP-34-5034" class="indexterm"/><a id="IDX-CHP-34-5035" class="indexterm"/><a id="IDX-CHP-34-5036" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, the <code class="literal">SIGHUP</code> signal is followed
                        by a <code class="literal">SIGCONT</code> signal to ensure that the
                        process group is resumed if it had earlier been stopped by a signal.
                        However, SUSv3 doesn’t specify this behavior, and most other UNIX
                        implementations don’t send a <code class="literal">SIGCONT</code> in
                        this circumstance.</p></div><p>We can use the program in <a class="xref" href="ch34.html#catching_sighup_when_a_terminal_disconne" title="Example 34-4. Catching SIGHUP when a terminal disconnect occurs">Example 34-4</a> to demonstrate that
                    termination of the controlling process causes a <code class="literal">SIGHUP</code> signal to be sent to all members of the terminal’s
                    foreground process group. This program creates one child process for each of its
                    command-line arguments <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e94548"/><img src="figs/web/U002.png" alt=""/></span>. If the corresponding command-line argument is the letter
                        <span class="emphasis"><em>d</em></span>, then the child process places itself in its own
                    (different) process group <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e94557"/><img src="figs/web/U003.png" alt=""/></span>; otherwise, the child remains in the same process group as
                    its parent. (We use the letter <span class="emphasis"><em>s</em></span> to specify the latter
                    action, although any letter other than <span class="emphasis"><em>d</em></span> can be used.) Each
                    child then establishes a handler for <code class="literal">SIGHUP</code>
                    <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e94573"/><img src="figs/web/U004.png" alt=""/></span>. To ensure that they terminate if no event occurs that
                    would otherwise terminate them, the parent and the children both call
                        <span class="emphasis"><em>alarm()</em></span> to set a timer that delivers a <code class="literal">SIGALRM</code> signal after 60 seconds <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e94586"/><img src="figs/web/U005.png" alt=""/></span>. Finally, all processes (including the parent) print out
                    their process ID and process group ID <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e94592"/><img src="figs/web/U006.png" alt=""/></span> and then loop waiting for signals to arrive
                        <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e94598"/><img src="figs/web/U007.png" alt=""/></span>. When a signal is delivered, the handler prints the process
                    ID of the process and signal number <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e94604"/><img src="figs/web/U001.png" alt=""/></span>.</p><div class="example"><a id="catching_sighup_when_a_terminal_disconne"/><div class="example-title">Example 34-4. Catching <code class="literal">SIGHUP</code> when a terminal
                        disconnect occurs</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>pgsjc/disc_SIGHUP.c</code></strong>
    #define _GNU_SOURCE     /* Get strsignal() declaration from &lt;string.h&gt; */
    #include &lt;string.h&gt;
    #include &lt;signal.h&gt;
    #include "tlpi_hdr.h"

    static void             /* Handler for SIGHUP */
    handler(int sig)
    {
<img src="figs/web/U001.png" alt=""/>    printf("PID %ld: caught signal %2d (%s)\n", (long) getpid(),
                sig, strsignal(sig));
                            /* UNSAFE (see Section 21.1.2) */
    }
        int
    main(int argc, char *argv[])
    {
        pid_t parentPid, childPid;
        int j;
        struct sigaction sa;

        if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
            usageErr("%s {d|s}... [ &gt; sig.log 2&gt;&amp;1 ]\n", argv[0]);

        setbuf(stdout, NULL);               /* Make stdout unbuffered */

        parentPid = getpid();
        printf("PID of parent process is:       %ld\n", (long) parentPid);
        printf("Foreground process group ID is: %ld\n",
                (long) tcgetpgrp(STDIN_FILENO));
<img src="figs/web/U002.png" alt=""/>    for (j = 1; j &lt; argc; j++) {        /* Create child processes */
            childPid = fork();
            if (childPid == -1)
                errExit("fork");

            if (childPid == 0) {            /* If child... */
<img src="figs/web/U003.png" alt=""/>            if (argv[j][0] == 'd')     /* 'd' --&gt; to different pgrp */
                    if (setpgid(0, 0) == -1)
                        errExit("setpgid");

                sigemptyset(&amp;sa.sa_mask);
                sa.sa_flags = 0;
                sa.sa_handler = handler;
<img src="figs/web/U004.png" alt=""/>            if (sigaction(SIGHUP, &amp;sa, NULL) == -1)
                    errExit("sigaction");
                break;                      /* Child exits loop */
            }
        }

        /* All processes fall through to here */
<img src="figs/web/U005.png" alt=""/>    alarm(60);          /* Ensure each process eventually terminates */

<img src="figs/web/U006.png" alt=""/>    printf("PID=%ld PGID=%ld\n", (long) getpid(), (long) getpgrp());
        for (;;)
<img src="figs/web/U007.png" alt=""/>        pause();        /* Wait for signals */
      }
          <strong class="userinput"><code>pgsjc/disc_SIGHUP.c</code></strong></pre></div></div><p>Suppose that we run the program in <a class="xref" href="ch34.html#catching_sighup_when_a_terminal_disconne" title="Example 34-4. Catching SIGHUP when a terminal disconnect occurs">Example 34-4</a> in a terminal window
                    with the following command:</p><a id="I_programlisting34_d1e94669"/><pre class="programlisting">$ <strong class="userinput"><code>exec ./disc_SIGHUP d s s &gt; sig.log 2&gt;&amp;1</code></strong></pre><p>The <span class="emphasis"><em>exec</em></span> command is a shell built-in command that causes
                    the shell to do an <span class="emphasis"><em>exec()</em></span>, replacing itself with the named
                    program. Since the shell was the controlling process for the terminal, our
                    program is now the controlling process and will receive <code class="literal">SIGHUP</code> when the terminal window is closed. After closing the
                    terminal window, we find the following lines in the file <code class="literal">sig.log</code>:</p><a id="I_programlisting34_d1e94687"/><pre class="programlisting">PID of parent process is:       12733
Foreground process group ID is: 12733
PID=12755 PGID=12755                <em class="lineannotation"><span class="lineannotation">First child is in a different process group</span></em>
PID=12756 PGID=12733                <em class="lineannotation"><span class="lineannotation">Remaining children are in same PG as parent</span></em>
PID=12757 PGID=12733
PID=12733 PGID=12733                <em class="lineannotation"><span class="lineannotation">This is the parent process</span></em>
PID 12756: caught signal  1 (Hangup)
PID 12757: caught signal  1 (Hangup)</pre><p>Closing the terminal window caused <code class="literal">SIGHUP</code>
                    to be sent to the controlling process (the parent), which terminated as a
                    result. We see that the two children that were in the same process group as the
                    parent (i.e., the foreground process group for the terminal) also both received
                        <code class="literal">SIGHUP</code>. However, the child that was in a
                    separate (background) process group did not receive this signal.</p></div></div><div class="sect1" title="Job Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="job_control">Job Control</h2></div></div></div><p>Job control is a feature that first appeared around 1980 in the C shell on BSD.
                Job control permits a shell user to simultaneously execute multiple commands (jobs),
                one in the foreground and the others in the background. Jobs can be stopped and
                resumed, and moved between the foreground and background, as described in the
                following paragraphs.<a id="IDX-CHP-34-5037" class="indexterm"/><a id="IDX-CHP-34-5038" class="indexterm"/><a id="IDX-CHP-34-5039" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In the initial POSIX.1 standard, support for job control was optional. Later
                    UNIX standards made support mandatory.<a id="IDX-CHP-34-5040" class="indexterm"/></p></div><p>In the days of character-based dumb terminals (physical terminal devices that were
                limited to displaying ASCII characters), many shell users knew how to use shell
                job-control commands. With the advent of bit-mapped monitors running the X Window
                System, knowledge of shell job control is less common. However, job control remains
                a useful feature. Using job control to manage multiple simultaneous commands can be
                faster and simpler than switching back and forth between multiple windows. For those
                readers unfamiliar with job control, we begin with a short tutorial on its use. We
                then go on to look at a few details of the implementation of job control and
                consider the implications of job control for application design.</p><div class="sect2" title="Using Job Control Within the Shell"><div class="titlepage"><div><div><h3 class="title" id="using_job_control_within_the_shell">Using Job Control Within the Shell</h3></div></div></div><p>When we enter a command terminated by an ampersand (<code class="literal">&amp;</code>), it is run as a background job, as illustrated by the
                    following examples:<a id="IDX-CHP-34-5041" class="indexterm"/><a id="IDX-CHP-34-5042" class="indexterm"/><a id="IDX-CHP-34-5043" class="indexterm"/><a id="IDX-CHP-34-5044" class="indexterm"/></p><a id="I_programlisting34_d1e94758"/><pre class="programlisting">[1] 18932                           <em class="lineannotation"><span class="lineannotation">Job 1: process running</span></em> <span class="emphasis"><em>grep</em></span> <em class="lineannotation"><span class="lineannotation">has PID 18932</span></em>
$ <strong class="userinput"><code>sleep 60 &amp;</code></strong>
[2] 18934                           <em class="lineannotation"><span class="lineannotation">Job 2: process running</span></em> <span class="emphasis"><em>sleep</em></span> <em class="lineannotation"><span class="lineannotation">has PID 18934</span></em></pre><p>Each job that is placed in the background is assigned a unique job number by
                    the shell. This job number is shown in square brackets after the job is started
                    in the background, and also when the job is manipulated or monitored by various
                    job-control commands. The number following the job number is the process ID of
                    the process created to execute the command, or, in the case of a pipeline, the
                    process ID of the last process in the pipeline. In the commands described in the
                    following paragraphs, jobs can be referred to using the notation
                        <span class="emphasis"><em>%num</em></span>, where <span class="emphasis"><em>num</em></span> is the number
                    assigned to this job by the shell.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In many cases, the <span class="emphasis"><em>%num</em></span> argument can be omitted, in
                        which case the <span class="emphasis"><em>current</em></span> job is used by default. The
                        current job is the last job that was stopped in the foreground (using the
                            <span class="emphasis"><em>suspend</em></span> character described below), or, if there is
                        no such job, then the last job that was started in the background. (There
                        are some variations in the details of how different shells determine which
                        background job is considered the current job.) In addition, the notation %%
                        or %+ refers to the current job, and the notation %- refers to the
                            <span class="emphasis"><em>previous current</em></span> job. The current and previous
                        current jobs are marked by a plus (+) and a minus (-) sign, respectively, in
                        the output produced by the <span class="emphasis"><em>jobs</em></span> command, which we
                        describe next.</p></div><p>The <span class="emphasis"><em>jobs</em></span> shell built-in command lists all background
                    jobs:</p><a id="I_programlisting34_d1e94812"/><pre class="programlisting">$ <strong class="userinput"><code>jobs</code></strong>
[1]- Running        grep -r SIGHUP /usr/src/linux &gt;x &amp;
[2]+ Running        sleep 60 &amp;</pre><p>At this point, the shell is the foreground process for the terminal. Since
                    only a foreground process can read input from the controlling terminal and
                    receive terminal-generated signals, sometimes it is necessary to move a
                    background job into the foreground. This is done using the
                        <span class="emphasis"><em>fg</em></span> shell built-in command:</p><a id="I_programlisting34_d1e94822"/><pre class="programlisting">$ <strong class="userinput"><code>fg %1</code></strong>
grep -r SIGHUP /usr/src/linux &gt;x</pre><p>As demonstrated in this example, the shell redisplays a job’s command line
                    whenever the job is moved between the foreground and the background. Below,
                    we’ll see that the shell also does this whenever the job’s state changes in the
                    background.</p><p>When a job is running in the foreground, we can suspend it using the terminal
                        <span class="emphasis"><em>suspend</em></span> character (normally
                        <span class="emphasis"><em>Control-Z</em></span>), which sends the <code class="literal">SIGTSTP</code> signal to the terminal’s foreground process
                        group:<a id="IDX-CHP-34-5045" class="indexterm"/></p><a id="I_programlisting34_d1e94846"/><pre class="programlisting"><em class="lineannotation"><span class="lineannotation">Type Control-Z</span></em>
[1]+ Stopped        grep -r SIGHUP /usr/src/linux &gt;x</pre><p>After we typed <span class="emphasis"><em>Control-Z</em></span>, the shell displays the command
                    that has been stopped in the background. If desired, we can use the
                        <span class="emphasis"><em>fg</em></span> command to resume the job in the foreground, or use
                    the <span class="emphasis"><em>bg</em></span> command to resume it in the background. In both
                    cases, the shell resumes the stopped job by sending it a <code class="literal">SIGCONT</code> signal.</p><a id="I_programlisting34_d1e94864"/><pre class="programlisting">$ <strong class="userinput"><code>bg %1</code></strong>
[1]+ grep -r SIGHUP /usr/src/linux &gt;x &amp;</pre><p>We can stop a background job by sending it a <code class="literal">SIGSTOP</code> signal:<a id="IDX-CHP-34-5046" class="indexterm"/></p><a id="I_programlisting34_d1e94879"/><pre class="programlisting">$ <strong class="userinput"><code>kill -STOP %1</code></strong>
[1]+ Stopped        grep -r SIGHUP /usr/src/linux &gt;x
$ <strong class="userinput"><code>jobs</code></strong>
[1]+ Stopped        grep -r SIGHUP /usr/src/linux &gt;x
[2]- Running        sleep 60 &amp;
$ <strong class="userinput"><code>bg %1</code></strong>                             <em class="lineannotation"><span class="lineannotation">Restart job in background</span></em>
[1]+ grep -r SIGHUP /usr/src/linux &gt;x &amp;</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The Korn and C shells provide the command <span class="emphasis"><em>stop</em></span> as a
                        shorthand for <span class="emphasis"><em>kill -stop</em></span>.</p></div><p>When a background job eventually completes, the shell prints a message prior
                    to displaying the next shell prompt:</p><a id="I_programlisting34_d1e94904"/><pre class="programlisting"><em class="lineannotation"><span class="lineannotation">Press Enter to see a further shell prompt</span></em>
[1]- Done           grep -r SIGHUP /usr/src/linux &gt;x
[2]+ Done           sleep 60
$</pre><p>Only processes in the foreground job may read from the controlling terminal.
                    This restriction prevents multiple jobs from competing for terminal input. If a
                    background job tries to read from the terminal, it is sent a <code class="literal">SIGTTIN</code> signal. The default action of <code class="literal">SIGTTIN</code> is to stop the job:</p><a id="I_programlisting34_d1e94916"/><pre class="programlisting">$ <strong class="userinput"><code>cat &gt; x.txt &amp;</code></strong>
[1] 18947
$
<em class="lineannotation"><span class="lineannotation">Press Enter once more in order to see</span></em>
 <em class="lineannotation"><span class="lineannotation">job state changes displayed prior to next shell prompt</span></em>
[1]+ Stopped        cat &gt;x.txt
$</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>It may not always be necessary to press the <span class="emphasis"><em>Enter</em></span> key
                        to see the job state changes in the previous example and some of the
                        following examples. Depending on kernel scheduling decisions, the shell may
                        receive notification about changes in the state of the background job before
                        the next shell prompt is displayed.</p></div><p>At this point, we must bring the job into the foreground
                        (<span class="emphasis"><em>fg</em></span>), and provide the required input. If desired, we
                    can then continue execution of the job in the background by first suspending it
                    and then resuming it in the background (<span class="emphasis"><em>bg</em></span>). (Of course, in
                    this particular example, <span class="emphasis"><em>cat</em></span> would immediately be stopped
                    again, since it would once more try to read from the terminal.)</p><p>By default, background jobs are allowed to perform output to the controlling
                    terminal. However, if the <code class="literal">TOSTOP</code> flag
                        (<span class="emphasis"><em>terminal output stop</em></span>, <a class="xref" href="ch62.html#terminal_flags" title="Terminal Flags">Terminal Flags</a>) is set for the terminal, then attempts by background jobs to perform
                    terminal output result in the generation of a <code class="literal">SIGTTOU</code> signal. (We can set the <code class="literal">TOSTOP</code> flag using the <span class="emphasis"><em>stty</em></span> command, which is
                    described in Section 62.3.) Like <code class="literal">SIGTTIN</code>, a
                        <code class="literal">SIGTTOU</code> signal stops the job.</p><a id="I_programlisting34_d1e94971"/><pre class="programlisting">$ <strong class="userinput"><code>stty tostop</code></strong>                       <em class="lineannotation"><span class="lineannotation">Enable</span></em> TOSTOP <em class="lineannotation"><span class="lineannotation">flag for this terminal</span></em>
$ <strong class="userinput"><code>date &amp;</code></strong>
[1] 19023
$
<em class="lineannotation"><span class="lineannotation">Press Enter once more to see job state changes displayed prior to next shell prompt</span></em>
[1]+ Stopped        date</pre><p>We can then see the output of the job by bringing it into the
                    foreground:</p><a id="I_programlisting34_d1e94990"/><pre class="programlisting">$ <strong class="userinput"><code>fg</code></strong>
date
Tue Dec 28 16:20:51 CEST 2010</pre><p>The various states of a job under job control, as well as the shell commands
                    and terminal characters (and the accompanying signals) used to move a job
                    between these states, are summarized in <a class="xref" href="ch34.html#job-control_states" title="Figure 34-2. Job-control states">Figure 34-2</a>.
                    This figure also includes a notional <span class="emphasis"><em>terminated</em></span> state for a
                    job. This state can be reached by sending various signals to the job, including
                        <code class="literal">SIGINT</code> and <code class="literal">SIGQUIT</code>, which can be generated from the keyboard.</p><div class="figure"><a id="job-control_states"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject34_d1e95011"/><img src="figs/web/34-2_PGSJC-job-control.png.jpg" alt="Job-control states"/></div></div><div class="figure-title">Figure 34-2. Job-control states</div></div></div><div class="sect2" title="Implementing Job Control"><div class="titlepage"><div><div><h3 class="title" id="implementing_job_control">Implementing Job Control</h3></div></div></div><p>In this section, we examine various aspects of the implementation of job
                    control, and conclude with an example program that makes the operation of job
                    control more transparent.<a id="IDX-CHP-34-5048" class="indexterm"/><a id="IDX-CHP-34-5049" class="indexterm"/><a id="IDX-CHP-34-5050" class="indexterm"/><a id="IDX-CHP-34-5051" class="indexterm"/><a id="IDX-CHP-34-5052" class="indexterm"/><a id="IDX-CHP-34-5053" class="indexterm"/><a id="IDX-CHP-34-5054" class="indexterm"/><a id="IDX-CHP-34-5055" class="indexterm"/><a id="IDX-CHP-34-5056" class="indexterm"/><a id="IDX-CHP-34-5057" class="indexterm"/><a id="IDX-CHP-34-5058" class="indexterm"/><a id="IDX-CHP-34-5059" class="indexterm"/><a id="IDX-CHP-34-5060" class="indexterm"/><a id="IDX-CHP-34-5061" class="indexterm"/><a id="IDX-CHP-34-5062" class="indexterm"/><a id="IDX-CHP-34-5063" class="indexterm"/><a id="IDX-CHP-34-5047" class="indexterm"/><a id="IDX-CHP-34-5064" class="indexterm"/></p><p>Although optional in the original POSIX.1 standard, later standards, including
                    SUSv3, require that an implementation support job control. This support requires
                    the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The implementation must provide certain job-control signals: <code class="literal">SIGTSTP</code>, <code class="literal">SIGSTOP</code>, <code class="literal">SIGCONT</code>,
                                <code class="literal">SIGTTOU</code>, and <code class="literal">SIGTTIN</code>. In addition, the <code class="literal">SIGCHLD</code> signal (<a class="xref" href="ch26.html#the_sigchld_signal" title="The SIGCHLD Signal">The <code class="literal">SIGCHLD</code> Signal</a>) is also necessary, since it allows
                            the shell (the parent of all jobs) to find out when one of its children
                            terminates or is stopped.<a id="IDX-CHP-34-5065" class="indexterm"/></p></li><li class="listitem"><p>The terminal driver must support generation of the job-control
                            signals, so that when certain characters are typed, or terminal I/O and
                            certain other terminal operations (described below) are performed from a
                            background job, an appropriate signal (as shown in <a class="xref" href="ch34.html#job-control_states" title="Figure 34-2. Job-control states">Figure 34-2</a>) is sent to the relevant process
                            group. In order to be able to carry out these actions, the terminal
                            driver must also record the session ID (controlling process) and
                            foreground process group ID associated with a terminal (<a class="xref" href="ch34.html#relationships_between_process_groups_com" title="Figure 34-1. Relationships between process groups, sessions, and the controlling terminal">Figure 34-1</a>).</p></li><li class="listitem"><p>The shell must support job control (most modern shells do so). This
                            support is provided in the form of the commands described earlier to
                            move a job between the foreground and background and monitor the state
                            of jobs. Certain of these commands send signals to a job (as shown in
                                <a class="xref" href="ch34.html#job-control_states" title="Figure 34-2. Job-control states">Figure 34-2</a>). In addition, when performing
                            operations that move a job between the <span class="emphasis"><em>running in
                                foreground</em></span> and any of the other states, the shell uses
                            calls to <span class="emphasis"><em>tcsetpgrp()</em></span> to adjust the terminal
                            driver’s record of the foreground process group.<a id="IDX-CHP-34-5066" class="indexterm"/></p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>In <a class="xref" href="ch20.html#sending_signals_colon_kill_open_parenthe" title="Sending Signals: kill()">Sending Signals: <span class="emphasis"><em>kill()</em></span></a>, we saw that
                        signals can generally be sent to a process only if the real or effective
                        user ID of the sending process matches the real user ID or saved set-user-ID
                        of the receiving process. However, <code class="literal">SIGCONT</code> is an exception to this rule. The kernel allows a
                        process (e.g., the shell) to send <code class="literal">SIGCONT</code>
                        to any process in the same session, regardless of process credentials. This
                        relaxation of the rules for <code class="literal">SIGCONT</code> is
                        required so that if a user starts a set-user-ID program that changes its
                        credentials (in particular, its real user ID), it is still possible to
                        resume it with <code class="literal">SIGCONT</code> if it is
                            stopped.<a id="IDX-CHP-34-5067" class="indexterm"/></p></div><div class="sect3" title="The SIGTTIN and SIGTTOU signals"><div class="titlepage"><div><div><h4 class="title" id="the_sigttin_and_sigttou_signals">The <code class="literal">SIGTTIN</code> and <code class="literal">SIGTTOU</code> signals</h4></div></div></div><p>SUSv3 specifies (and Linux implements) some special cases that apply with
                        respect to the generation of the <code class="literal">SIGTTIN</code>
                        and <code class="literal">SIGTTOU</code> signals for background
                            jobs:<a id="IDX-CHP-34-5068" class="indexterm"/><a id="IDX-CHP-34-5069" class="indexterm"/><a id="IDX-CHP-34-5070" class="indexterm"/><a id="IDX-CHP-34-5071" class="indexterm"/><a id="IDX-CHP-34-5072" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">SIGTTIN</code> is not sent if the
                                process is currently blocking or ignoring this signal. Instead, a
                                    <span class="emphasis"><em>read()</em></span> from the controlling terminal fails,
                                setting <span class="emphasis"><em>errno</em></span> to <code class="literal">EIO</code>. The rationale for this behavior is that the
                                process would otherwise have no way of knowing that the
                                    <span class="emphasis"><em>read()</em></span> was not permitted.</p></li><li class="listitem"><p>Even if the terminal <code class="literal">TOSTOP</code>
                                flag is set, <code class="literal">SIGTTOU</code> is not sent
                                if the process is currently blocking or ignoring this signal.
                                Instead, a <span class="emphasis"><em>write()</em></span> to the controlling terminal
                                is permitted (i.e., the <code class="literal">TOSTOP</code>
                                flag is ignored).</p></li><li class="listitem"><p>Regardless of the setting of the <code class="literal">TOSTOP</code> flag, certain functions that change terminal
                                driver data structures result in the generation of <code class="literal">SIGTTOU</code> for a background process if it
                                tries to apply them to its controlling terminal. These functions
                                include <span class="emphasis"><em>tcsetpgrp()</em></span>,
                                    <span class="emphasis"><em>tcsetattr()</em></span>,
                                <span class="emphasis"><em>tcflush()</em></span>, <span class="emphasis"><em>tcflow()</em></span>,
                                    <span class="emphasis"><em>tcsendbreak()</em></span>, and
                                    <span class="emphasis"><em>tcdrain()</em></span>. (These functions are described
                                in <a class="xref" href="ch62.html" title="Chapter 62. Terminals">Chapter 62</a>.) If <code class="literal">SIGTTOU</code> is being blocked or ignored, these calls
                                    succeed.<a id="IDX-CHP-34-5073" class="indexterm"/><a id="IDX-CHP-34-5074" class="indexterm"/><a id="IDX-CHP-34-5075" class="indexterm"/><a id="IDX-CHP-34-5076" class="indexterm"/><a id="IDX-CHP-34-5077" class="indexterm"/></p></li></ul></div></div><div class="sect3" title="Example program: demonstrating the operation of job control"><div class="titlepage"><div><div><h4 class="title" id="example_program_colon_demonstrating_the">Example program: demonstrating the operation of job control</h4></div></div></div><p>The program in <a class="xref" href="ch34.html#observing_the_treatment_of_a_process_und" title="Example 34-5. Observing the treatment of a process under job control">Example 34-5</a>
                        allows us to see how the shell organizes the commands in a pipeline into a
                        job (process group). This program also allows us to monitor certain of the
                        signals sent and the changes made to the terminal’s foreground process group
                        setting under job control. The program is designed so that multiple
                        instances can be run in a pipeline, as in the following example:<a id="IDX-CHP-34-5078" class="indexterm"/><a id="IDX-CHP-34-5079" class="indexterm"/><a id="IDX-CHP-34-5080" class="indexterm"/><a id="IDX-CHP-34-5081" class="indexterm"/><a id="IDX-CHP-34-5082" class="indexterm"/><a id="IDX-CHP-34-5083" class="indexterm"/><a id="IDX-CHP-34-5084" class="indexterm"/><a id="IDX-CHP-34-5085" class="indexterm"/><a id="IDX-CHP-34-5086" class="indexterm"/></p><a id="I_programlisting34_d1e95400"/><pre class="programlisting">$ <strong class="userinput"><code>./job_mon | ./job_mon | ./job_mon</code></strong></pre><p>The program in <a class="xref" href="ch34.html#observing_the_treatment_of_a_process_und" title="Example 34-5. Observing the treatment of a process under job control">Example 34-5</a>
                        performs the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On startup, the program installs a single handler for <code class="literal">SIGINT</code>, <code class="literal">SIGTSTP</code>, and <code class="literal">SIGCONT</code>
                                <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95421"/><img src="figs/web/U004.png" alt=""/></span>. The handler carries out the following
                                steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Display the foreground process group for the terminal
                                            <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95431"/><img src="figs/web/U001.png" alt=""/></span>. To avoid multiple identical lines of
                                        output, this is done only by the process group
                                        leader.</p></li><li class="listitem"><p>Display the ID of the process, the process’s position in
                                        the pipeline, and the signal received <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95440"/><img src="figs/web/U002.png" alt=""/></span>.</p></li><li class="listitem"><p>The handler must do some extra work if it catches <code class="literal">SIGTSTP</code>, since, when caught,
                                        this signal doesn’t stop a process. So, to actually stop the
                                        process, the handler raises the <code class="literal">SIGSTOP</code> signal <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95455"/><img src="figs/web/U003.png" alt=""/></span>, which always stops a process. (We
                                        refine this treatment of <code class="literal">SIGTSTP</code> in <a class="xref" href="ch34.html#handling_job-control_signals" title="Handling Job-Control Signals">Handling Job-Control Signals</a>.)</p></li></ul></div></li><li class="listitem"><p>If the program is the initial process in the pipeline, it prints
                                headings for the output produced by all of the processes
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95469"/><img src="figs/web/U006.png" alt=""/></span>. In order to test whether it is the initial (or
                                final) process in the pipeline, the program uses the
                                    <span class="emphasis"><em>isatty()</em></span> function (described in <a class="xref" href="ch62.html#terminal_identification" title="Terminal Identification">Terminal Identification</a>) to check whether its
                                standard input (or output) is a terminal <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95480"/><img src="figs/web/U005.png" alt=""/></span>. If the specified file descriptor refers to a
                                pipe, <span class="emphasis"><em>isatty()</em></span> returns false (0).</p></li><li class="listitem"><p>The program builds a message to be passed to its successor in the
                                pipeline. This message is an integer indicating the position of this
                                process in the pipeline. Thus, for the initial process, the message
                                contains the number 1. If the program is the initial process in the
                                pipeline, the message is initialized to 0. If it is not the initial
                                process in the pipeline, the program first reads this message from
                                its predecessor <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95492"/><img src="figs/web/U007.png" alt=""/></span>. The program increments the message value
                                before proceeding to the next steps <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95498"/><img src="figs/web/U008.png" alt=""/></span>.</p></li><li class="listitem"><p>Regardless of its position in the pipeline, the program displays a
                                line containing its pipeline position, process ID, parent process
                                ID, process group ID, and session ID <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95507"/><img src="figs/web/U009.png" alt=""/></span>.</p></li><li class="listitem"><p>Unless it is the last command in the pipeline, the program writes
                                an integer message for its successor in the pipeline
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95516"/><img src="figs/web/U010.png" alt=""/></span>.</p></li><li class="listitem"><p>Finally, the program loops forever, using
                                    <span class="emphasis"><em>pause()</em></span> to wait for signals
                                    <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e95528"/><img src="figs/web/U011.png" alt=""/></span>.</p></li></ul></div><div class="example"><a id="observing_the_treatment_of_a_process_und"/><div class="example-title">Example 34-5. Observing the treatment of a process under job control</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>pgsjc/job_mon.c</code></strong>
    #define _GNU_SOURCE     /* Get declaration of strsignal() from &lt;string.h&gt; */
    #include &lt;string.h&gt;
    #include &lt;signal.h&gt;
    #include &lt;fcntl.h&gt;
    #include "tlpi_hdr.h"

    static int cmdNum;              /* Our position in pipeline */

    static void                     /* Handler for various signals */
    handler(int sig)
    {
        /* UNSAFE: This handler uses non-async-signal-safe functions
           (fprintf(), strsignal(); see Section 21.1.2) */
    <img src="figs/web/U001.png" alt=""/>    if (getpid() == getpgrp())          /* If process group leader */
          fprintf(stderr, "Terminal FG process group: %ld\n",
                    (long) tcgetpgrp(STDERR_FILENO));
<img src="figs/web/U002.png" alt=""/>    fprintf(stderr, "Process %ld (%d) received signal %d (%s)\n",
                    (long) getpid(), cmdNum, sig, strsignal(sig));

        /* If we catch SIGTSTP, it won't actually stop us. Therefore we
           raise SIGSTOP so we actually get stopped. */

<img src="figs/web/U003.png" alt=""/>    if (sig == SIGTSTP)
            raise(SIGSTOP);
    }

    int
    main(int argc, char *argv[])
    {
        struct sigaction sa;

        sigemptyset(&amp;sa.sa_mask);
        sa.sa_flags = SA_RESTART;
        sa.sa_handler = handler;
<img src="figs/web/U004.png" alt=""/>    if (sigaction(SIGINT, &amp;sa, NULL) == -1)
            errExit("sigaction");
        if (sigaction(SIGTSTP, &amp;sa, NULL) == -1)
            errExit("sigaction");
        if (sigaction(SIGCONT, &amp;sa, NULL) == -1)
            errExit("sigaction");

        /* If stdin is a terminal, this is the first process in pipeline:
           print a heading and initialize message to be sent down pipe */

<img src="figs/web/U005.png" alt=""/>    if (isatty(STDIN_FILENO)) {
            fprintf(stderr, "Terminal FG process group: %ld\n",
                    (long) tcgetpgrp(STDIN_FILENO));
<img src="figs/web/U006.png" alt=""/>        fprintf(stderr, "Command   PID  PPID  PGRP   SID\n");
            cmdNum = 0;

        } else {            /* Not first in pipeline, so read message from pipe */
<img src="figs/web/U007.png" alt=""/>        if (read(STDIN_FILENO, &amp;cmdNum, sizeof(cmdNum)) &lt;= 0)
                fatal("read got EOF or error");
        }

<img src="figs/web/U008.png" alt=""/>    cmdNum++;
<img src="figs/web/U009.png" alt=""/>    fprintf(stderr, "%4d    %5ld %5ld %5ld %5ld\n", cmdNum,
                (long) getpid(), (long) getppid(),
                (long) getpgrp(), (long) getsid(0));

        /* If not the last process, pass a message to the next process */

        if (!isatty(STDOUT_FILENO))   /* If not tty, then should be pipe */0
<img src="figs/web/U010.png" alt=""/>        if (write(STDOUT_FILENO, &amp;cmdNum, sizeof(cmdNum)) == -1)
                errMsg("write");

<img src="figs/web/U011.png" alt=""/>    for(;;)             /* Wait for signals */
            pause();
    }

           <strong class="userinput"><code>pgsjc/job_mon.c</code></strong></pre></div></div><p>The following shell session demonstrates the use of the program in <a class="xref" href="ch34.html#observing_the_treatment_of_a_process_und" title="Example 34-5. Observing the treatment of a process under job control">Example 34-5</a>. We begin by
                        displaying the process ID of the shell (which is the session leader, and the
                        leader of a process group of which it is the sole member), and then create a
                        background job containing two processes:</p><a id="I_programlisting34_d1e95615"/><pre class="programlisting">$ <strong class="userinput"><code>echo $$</code></strong>                       <em class="lineannotation"><span class="lineannotation">Show PID of the shell</span></em>
1204
$ <strong class="userinput"><code>./job_mon | ./job_mon &amp;</code></strong>                   <em class="lineannotation"><span class="lineannotation">Start a job containing 2 processes</span></em>
[1] 1227
Terminal FG process group: 1204
Command   PID  PPID  PGRP   SID
   1     1226  1204  1226  1204
   2     1227  1204  1226  1204</pre><p>From the above output, we can see that the shell remains the foreground
                        process for the terminal. We can also see that the new job is in the same
                        session as the shell and that all of the processes are in the same process
                        group. Looking at the process IDs, we can see that the processes in the job
                        were created in the same order as the commands were given on the command
                        line. (Most shells do things this way, but some shell implementations create
                        the processes in a different order.)</p><p>We continue, creating a second background job consisting of three
                        processes:</p><a id="I_programlisting34_d1e95633"/><pre class="programlisting">$ <strong class="userinput"><code>./job_mon | ./job_mon | ./job_mon &amp;</code></strong>
[2] 1230
Terminal FG process group: 1204
Command   PID  PPID  PGRP   SID
   1     1228  1204  1228  1204
   2     1229  1204  1228  1204
   3     1230  1204  1228  1204</pre><p>We see that the shell is still the foreground process group for the
                        terminal. We also see that the processes for the new job are in the same
                        session as the shell, but are in a different process group from the first
                        job. Now we bring the second job into the foreground and send it a <code class="literal">SIGINT</code> signal:</p><a id="I_programlisting34_d1e95644"/><pre class="programlisting">$ <strong class="userinput"><code>fg</code></strong>
./job_mon | ./job_mon | ./job_mon
<em class="lineannotation"><span class="lineannotation">Type Control-C to generate</span></em> SIGINT <em class="lineannotation"><span class="lineannotation">(signal2)</span></em>
Process 1230 (3) received signal 2 (Interrupt)
Process 1229 (2) received signal 2 (Interrupt)
Terminal FG process group: 1228
Process 1228 (1) received signal 2 (Interrupt)</pre><p>From the above output, we see that the <code class="literal">SIGINT</code> signal was delivered to all of the processes in the
                        foreground process group. We also see that this job is now the foreground
                        process group for the terminal. Next, we send a <code class="literal">SIGTSTP</code> signal to the job:</p><a id="I_programlisting34_d1e95663"/><pre class="programlisting"><em class="lineannotation"><span class="lineannotation">Type Control-Z to generate</span></em> SIGTSTP <em class="lineannotation"><span class="lineannotation">(signal 20 on Linux/x86-32).</span></em>
Process 1230 (3) received signal 20 (Stopped)
Process 1229 (2) received signal 20 (Stopped)
Terminal FG process group: 1228
Process 1228 (1) received signal 20 (Stopped)

[2]+  Stopped       ./job_mon | ./job_mon | ./job_mon</pre><p>Now all members of the process group are stopped. The output indicates
                        that process group 1228 was the foreground job. However, after this job was
                        stopped, the shell became the foreground process group, although we can’t
                        tell this from the output.</p><p>We then proceed by restarting the job using the <span class="emphasis"><em>bg</em></span>
                        command, which delivers a <code class="literal">SIGCONT</code> signal
                        to the processes in the job:</p><a id="I_programlisting34_d1e95680"/><pre class="programlisting">$ <strong class="userinput"><code>bg</code></strong>                                        <em class="lineannotation"><span class="lineannotation">Resume job in background</span></em>
[2]+ ./job_mon | ./job_mon | ./job_mon &amp;
Process 1230 (3) received signal 18 (Continued)
Process 1229 (2) received signal 18 (Continued)
Terminal FG process group: 1204             <em class="lineannotation"><span class="lineannotation">The shell is in the foreground</span></em>
Process 1228 (1) received signal 18 (Continued)
$ <strong class="userinput"><code>kill %1 %2</code></strong>                                <em class="lineannotation"><span class="lineannotation">We’ve finished: clean up</span></em>
[1]-  Terminated    ./job_mon | ./job_mon
[2]+  Terminated    ./job_mon | ./job_mon | ./job_mon</pre></div></div><div class="sect2" title="Handling Job-Control Signals"><div class="titlepage"><div><div><h3 class="title" id="handling_job-control_signals">Handling Job-Control Signals</h3></div></div></div><p>Because the operation of job control is transparent to most applications, they
                    don’t need to take special action for dealing with job-control signals. One
                    exception is programs that perform screen handling, such as
                        <span class="emphasis"><em>vi</em></span> and <span class="emphasis"><em>less</em></span>. Such programs control
                    the precise layout of text on a terminal and change various terminal settings,
                    including settings that allow terminal input to be read a character (rather than
                    a line) at a time. (We describe the various terminal settings in <a class="xref" href="ch62.html" title="Chapter 62. Terminals">Chapter 62</a>.)<a id="IDX-CHP-34-5087" class="indexterm"/><a id="IDX-CHP-34-5088" class="indexterm"/></p><p>Screen-handling programs need to handle the terminal stop signal (<code class="literal">SIGTSTP</code>). The signal handler should reset the
                    terminal into canonical (line-at-a-time) input mode and place the cursor at the
                    bottom-left corner of the terminal. When resumed, the program sets the terminal
                    back into the mode required by the program, checks the terminal window size
                    (which may have been changed by the user in the meantime), and redraws the
                    screen with the desired contents.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When we suspend or exit a terminal-handling program, such as
                            <span class="emphasis"><em>vi</em></span> on an <span class="emphasis"><em>xterm</em></span> or other
                        terminal emulator, we typically see that the terminal is redrawn with the
                        text that was visible before the program was started. The terminal emulator
                        achieves this effect by catching two character sequences that programs
                        employing the <span class="emphasis"><em>terminfo</em></span> or <span class="emphasis"><em>termcap</em></span>
                        packages are required to output when assuming and releasing control of
                        terminal layout. The first of these sequences, called
                            <span class="emphasis"><em>smcup</em></span> (normally <span class="emphasis"><em>Escape</em></span>
                        followed by <code class="literal">[?1049h</code>), causes the terminal
                        emulator to switch to its “alternate” screen. The second sequence, called
                            <span class="emphasis"><em>rmcup</em></span> (normally <span class="emphasis"><em>Escape</em></span>
                        followed by <code class="literal">[?1049l</code>), causes the terminal
                        emulator to revert to its default screen, thus resulting in the reappearance
                        of the original text that was on display before the screen-handling program
                        took control of the terminal.</p></div><p>When handling <code class="literal">SIGTSTP</code>, we should be aware
                    of some subtleties. We have already noted the first of these in <a class="xref" href="ch34.html#implementing_job_control" title="Implementing Job Control">Implementing Job Control</a>: if <code class="literal">SIGTSTP</code> is caught, then it doesn’t perform its default action of
                    stopping a process. We dealt with this issue in <a class="xref" href="ch34.html#observing_the_treatment_of_a_process_und" title="Example 34-5. Observing the treatment of a process under job control">Example 34-5</a> by having the handler
                    for <code class="literal">SIGTSTP</code> raise the <code class="literal">SIGSTOP</code> signal. Since <code class="literal">SIGSTOP</code> can’t be caught, blocked, or ignored, it is guaranteed to
                    immediately stop the process. However, this approach is not quite correct. In
                        <a class="xref" href="ch26.html#the_wait_status_value" title="The Wait Status Value">The Wait Status Value</a>, we saw that a parent process can
                    use the wait status value returned by <span class="emphasis"><em>wait()</em></span> or
                        <span class="emphasis"><em>waitpid()</em></span> to determine which signal caused one of its
                    child to stop. If we raise the <code class="literal">SIGSTOP</code> signal
                    in the handler for <code class="literal">SIGTSTP</code>, it will
                    (misleadingly) appear to the parent that the child was stopped by <code class="literal">SIGSTOP</code>.</p><p>The proper approach in this situation is to have the <code class="literal">SIGTSTP</code> handler raise a further <code class="literal">SIGTSTP</code> signal to stop the process, as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The handler resets the disposition of <code class="literal">SIGTSTP</code> to its default (<code class="literal">SIG_DFL</code>).</p></li><li class="listitem"><p>The handler raises <code class="literal">SIGTSTP</code>.</p></li><li class="listitem"><p>Since <code class="literal">SIGTSTP</code> was blocked on entry
                            to the handler (unless the <code class="literal">SA_NODEFER</code>
                            flag was specified), the handler unblocks this signal. At this point,
                            the pending <code class="literal">SIGTSTP</code> raised in the
                            previous step performs its default action: the process is immediately
                            suspended.</p></li><li class="listitem"><p>At some later time, the process will be resumed upon receipt of
                                <code class="literal">SIGCONT</code>. At this point, execution
                            of the handler continues.</p></li><li class="listitem"><p>Before returning, the handler reblocks the <code class="literal">SIGTSTP</code> signal and reestablishes itself to handle the
                            next occurrence of the <code class="literal">SIGTSTP</code>
                            signal.</p></li></ol></div><p>The step of reblocking the <code class="literal">SIGTSTP</code> signal
                    is needed to prevent the handler from being recursively called if another
                        <code class="literal">SIGTSTP</code> signal was delivered after the
                    handler reestablished itself, but before the handler returned. As noted in <a class="xref" href="ch22.html#implementation_and_portability_of_signal" title="Implementation and Portability of signal()">Implementation and Portability of <span class="emphasis"><em>signal()</em></span></a>, recursive invocations
                    of a signal handler could cause stack overflow if a rapid stream of signals is
                    delivered. Blocking the signal also avoids problems if the signal handler needs
                    to perform some other actions (e.g., saving or restoring values from global
                    variables) after reestablishing the handler but before returning.</p><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id47">Example program</h4></div></div></div><p>The handler in <a class="xref" href="ch34.html#handling_sigtstp" title="Example 34-6. Handling SIGTSTP">Example 34-6</a> implements the steps
                        described above to correctly handle <code class="literal">SIGTSTP</code>. (We show another example of the handling of the
                            <code class="literal">SIGTSTP</code> signal in <a class="xref" href="ch62.html#demonstrating_cbreak_and_raw_modes" title="Example 62-4. Demonstrating cbreak and raw modes">Example 62-4</a>, in <a class="xref" href="ch62.html#terminal_line_speed_open_parenthesis_bit" title="Terminal Line Speed (Bit Rate)">Terminal Line Speed (Bit Rate)</a>.) After
                        establishing the <code class="literal">SIGTSTP</code> handler, the
                            <span class="emphasis"><em>main()</em></span> function of this program sits in a loop
                        waiting for signals. Here is an example of what we see when running this
                            program:<a id="IDX-CHP-34-5089" class="indexterm"/><a id="IDX-CHP-34-5090" class="indexterm"/><a id="IDX-CHP-34-5091" class="indexterm"/></p><a id="I_programlisting34_d1e95905"/><pre class="programlisting">$ <strong class="userinput"><code>./handling_SIGTSTP</code></strong>
<em class="lineannotation"><span class="lineannotation">Type Control-Z, sending</span></em> SIGTSTP
Caught SIGTSTP                 <em class="lineannotation"><span class="lineannotation">This message is printed by</span></em> SIGTSTP <em class="lineannotation"><span class="lineannotation">handler</span></em>

[1]+  Stopped       ./handling_SIGTSTP
$ <strong class="userinput"><code>fg</code></strong>                           <em class="lineannotation"><span class="lineannotation">Sends</span></em> SIGCONT
./handling_SIGTSTP
Exiting SIGTSTP handler        <em class="lineannotation"><span class="lineannotation">Execution of handler continues; handler returns</span></em>
Main                           <em class="lineannotation"><span class="lineannotation">pause() call in main() was interrupted by handler</span></em>
<em class="lineannotation"><span class="lineannotation">Type Control-C to terminate the program</span></em></pre><p>In a screen-handling program such as <span class="emphasis"><em>vi</em></span>, the
                            <span class="emphasis"><em>printf()</em></span> calls inside the signal handler in <a class="xref" href="ch34.html#handling_sigtstp" title="Example 34-6. Handling SIGTSTP">Example 34-6</a> would be replaced by code that caused the
                        program to modify the terminal mode and redraw the terminal display, as
                        outlined above. (Because of the need to avoid calling non-async-signal-safe
                        functions, described in <a class="xref" href="ch21.html#reentrant_and_async-signal-safe_function" title="Reentrant and Async-Signal-Safe Functions">Reentrant and Async-Signal-Safe Functions</a>, the handler should
                        do this by setting a flag to inform the main program to redraw the
                        screen.)</p><p>Note that the <code class="literal">SIGTSTP</code> handler may
                        interrupt certain blocking system calls (as described in <a class="xref" href="ch21.html#interruption_and_restarting_of_system_ca" title="Interruption and Restarting of System Calls">Interruption and Restarting of System Calls</a>). This point is
                        illustrated in the above program output by the fact that, after the
                            <span class="emphasis"><em>pause()</em></span> call is interrupted, the main program
                        prints the message <span class="emphasis"><em>Main</em></span>.</p><div class="example"><a id="handling_sigtstp"/><div class="example-title">Example 34-6. Handling <code class="literal">SIGTSTP</code></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>pgsjc/handling_SIGTSTP.c</code></strong>
#include &lt;signal.h&gt;
#include "tlpi_hdr.h"

static void                             /* Handler for SIGTSTP */
tstpHandler(int sig)
{
    sigset_t tstpMask, prevMask;
    int savedErrno;
    struct sigaction sa;

    savedErrno = errno;                 /* In case we change 'errno' here */

    printf("Caught SIGTSTP\n");         /* UNSAFE (see Section 21.1.2) */

    if (signal(SIGTSTP, SIG_DFL) == SIG_ERR)
        errExit("signal");              /* Set handling to default */

    raise(SIGTSTP);                     /* Generate a further SIGTSTP */

    /* Unblock SIGTSTP; the pending SIGTSTP immediately suspends the program */

    sigemptyset(&amp;tstpMask);
    sigaddset(&amp;tstpMask, SIGTSTP);
    if (sigprocmask(SIG_UNBLOCK, &amp;tstpMask, &amp;prevMask) == -1)
        errExit("sigprocmask");

    /* Execution resumes here after SIGCONT */

    if (sigprocmask(SIG_SETMASK, &amp;prevMask, NULL) == -1)
        errExit("sigprocmask");         /* Reblock SIGTSTP */

    sigemptyset(&amp;sa.sa_mask);           /* Reestablish handler */
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = tstpHandler;
    if (sigaction(SIGTSTP, &amp;sa, NULL) == -1)
        errExit("sigaction");

    printf("Exiting SIGTSTP handler\n");
    errno = savedErrno;
}

int
main(int argc, char *argv[])
{
    struct sigaction sa;
    /* Only establish handler for SIGTSTP if it is not being ignored */

    if (sigaction(SIGTSTP, NULL, &amp;sa) == -1)
        errExit("sigaction");

    if (sa.sa_handler != SIG_IGN) {
        sigemptyset(&amp;sa.sa_mask);
        sa.sa_flags = SA_RESTART;
        sa.sa_handler = tstpHandler;
        if (sigaction(SIGTSTP, &amp;sa, NULL) == -1)
            errExit("sigaction");
    }

    for (;;) {                          /* Wait for signals */
        pause();
        printf("Main\n");
    }
}
      <strong class="userinput"><code>pgsjc/handling_SIGTSTP.c</code></strong></pre></div></div></div><div class="sect3" title="Dealing with ignored job-control and terminal-generated signals"><div class="titlepage"><div><div><h4 class="title" id="dealing_with_ignored_job-control_and_ter">Dealing with ignored job-control and terminal-generated signals</h4></div></div></div><p>The program in <a class="xref" href="ch34.html#handling_sigtstp" title="Example 34-6. Handling SIGTSTP">Example 34-6</a> establishes a signal
                        handler for <code class="literal">SIGTSTP</code> only if that signal
                        is not being ignored. This is an instance of the more general rule that
                        applications should handle job-control and terminal-generated signals only
                        if these signals were not previously being ignored. In the case of
                        job-control signals (<code class="literal">SIGTSTP</code>, <code class="literal">SIGTTIN</code>, and <code class="literal">SIGTTOU</code>), this prevents an application from attempting to
                        handle these signals if it is started from a non-job-control shell (such as
                        the traditional Bourne shell). In a non-job-control shell, the dispositions
                        of these signals are set to <code class="literal">SIG_IGN</code>; only
                        job-control shells set the dispositions of these signals to <code class="literal">SIG_DFL</code>.<a id="IDX-CHP-34-5092" class="indexterm"/><a id="IDX-CHP-34-5093" class="indexterm"/><a id="IDX-CHP-34-5094" class="indexterm"/><a id="IDX-CHP-34-5095" class="indexterm"/><a id="IDX-CHP-34-5096" class="indexterm"/><a id="IDX-CHP-34-5097" class="indexterm"/></p><p>A similar statement also applies to the other signals that can be
                        generated from the terminal: <code class="literal">SIGINT</code>,
                            <code class="literal">SIGQUIT</code>, and <code class="literal">SIGHUP</code>. In the case of <code class="literal">SIGINT</code> and <code class="literal">SIGQUIT</code>, the
                        reason is that when a command is executed in the background under
                        non-job-control shells, the resulting process is not placed in a separate
                        process group. Instead, the process stays in the same group as the shell,
                        and the shell sets the disposition of <code class="literal">SIGINT</code> and <code class="literal">SIGQUIT</code> to be
                        ignored before execing the command. This ensures that the process is not
                        killed if the user types the terminal <span class="emphasis"><em>interrupt</em></span> or
                            <span class="emphasis"><em>quit</em></span> characters (which should affect only the job
                        that is notionally in the foreground). If the process subsequently undoes
                        the shell’s manipulations of the dispositions of these signals, then it once
                        more becomes vulnerable to receiving them.</p><p>The <code class="literal">SIGHUP</code> signal is ignored if a
                        command is executed via <span class="emphasis"><em>nohup(1)</em></span>. This prevents the
                        command from being killed as a consequence of a terminal hangup. Thus, an
                        application should not attempt to change the disposition if it is being
                            ignored.<a id="IDX-CHP-34-5098" class="indexterm"/></p></div></div><div class="sect2" title="Orphaned Process Groups (and SIGHUP Revisited)"><div class="titlepage"><div><div><h3 class="title" id="orphaned_process_groups_open_parenthesis">Orphaned Process Groups (and <code class="literal">SIGHUP</code>
                    Revisited)</h3></div></div></div><p>In <a class="xref" href="ch26.html#orphans_and_zombies" title="Orphans and Zombies">Orphans and Zombies</a>, we saw that an orphaned process is
                    one that has been adopted by <span class="emphasis"><em>init</em></span> (process ID 1) after its
                    parent terminated. Within a program, we can create an orphaned child using the
                    following code:<a id="IDX-CHP-34-5099" class="indexterm"/></p><a id="I_programlisting34_d1e96086"/><pre class="programlisting">if (fork() != 0)                /* Exit if parent (or on error) */
    exit(EXIT_SUCCESS);</pre><p>Suppose that we include this code in a program executed from the shell. <a class="xref" href="ch34.html#steps_in_the_creation_of_an_orphaned_pro" title="Figure 34-3. Steps in the creation of an orphaned process group">Figure 34-3</a> shows the state of
                    processes before and after the parent exits.</p><p>After the parent terminates, the child process in <a class="xref" href="ch34.html#steps_in_the_creation_of_an_orphaned_pro" title="Figure 34-3. Steps in the creation of an orphaned process group">Figure 34-3</a> is not only an orphaned
                    process, it is also part of an <span class="emphasis"><em>orphaned process group</em></span>.
                    SUSv3 defines a process group as orphaned if “the parent of every member is
                    either itself a member of the group or is not a member of the group’s session.”
                    Put another way, a process group is not orphaned if at least one of its members
                    has a parent in the same session but in a different process group. In <a class="xref" href="ch34.html#steps_in_the_creation_of_an_orphaned_pro" title="Figure 34-3. Steps in the creation of an orphaned process group">Figure 34-3</a>, the process group
                    containing the child is orphaned because the child is in a process group on its
                    own and its parent (<span class="emphasis"><em>init</em></span>) is in a different session.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>By definition, a session leader is in an orphaned process group. This
                        follows because <span class="emphasis"><em>setsid()</em></span> creates a new process group in
                        the new session, and the parent of the session leader is in a different
                        session.</p></div><div class="figure"><a id="steps_in_the_creation_of_an_orphaned_pro"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject34_d1e96113"/><img src="figs/web/34-3_PGSJC-orphaned-pgrp.png.jpg" alt="Steps in the creation of an orphaned process group"/></div></div><div class="figure-title">Figure 34-3. Steps in the creation of an orphaned process group</div></div><p>To see why orphaned process groups are important, we need to view things from
                    the perspective of shell job control. Consider the following scenario based on
                        <a class="xref" href="ch34.html#steps_in_the_creation_of_an_orphaned_pro" title="Figure 34-3. Steps in the creation of an orphaned process group">Figure 34-3</a>:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Before the parent process exits, the child was stopped (perhaps
                            because the parent sent it a stop signal).</p></li><li class="listitem"><p>When the parent process exits, the shell removes the parent’s process
                            group from its list of jobs. The child is adopted by
                                <span class="emphasis"><em>init</em></span> and becomes a background process for the
                            terminal. The process group containing the child is orphaned.</p></li><li class="listitem"><p>At this point, there is no process that monitors the state of the
                            stopped child via <span class="emphasis"><em>wait()</em></span>.</p></li></ol></div><p>Since the shell did not create the child process, it is not aware of the
                    child’s existence or that the child is part of the same process group as the
                    deceased parent. Furthermore, the <span class="emphasis"><em>init</em></span> process checks only
                    for a terminated child, and then reaps the resulting zombie process.
                    Consequently, the stopped child might languish forever, since no other process
                    knows to send it a <code class="literal">SIGCONT</code> signal in order to
                    cause it to resume execution.<a id="IDX-CHP-34-5100" class="indexterm"/></p><p>Even if a stopped process in an orphaned process group has a still-living
                    parent in a different session, that parent is not guaranteed to be able to send
                        <code class="literal">SIGCONT</code> to the stopped child. A process
                    may send <code class="literal">SIGCONT</code> to any other process in the
                    same session, but if the child is in a different session, the normal rules for
                    sending signals apply (<a class="xref" href="ch20.html#sending_signals_colon_kill_open_parenthe" title="Sending Signals: kill()">Sending Signals: <span class="emphasis"><em>kill()</em></span></a>), so the parent may not be able to send a signal to the child if the child is
                    a privileged process that has changed its credentials.</p><p>To prevent scenarios such as the one described above, SUSv3 specifies that if
                    a process group becomes orphaned and has any stopped members, then all members
                    of the group are sent a <code class="literal">SIGHUP</code> signal, to
                    inform them that they have become disconnected from their session, followed by a
                        <code class="literal">SIGCONT</code> signal, to ensure that they
                    resume execution. If the orphaned process group doesn’t have any stopped
                    members, no signals are sent.</p><p>A process group may become orphaned either because the last parent in a
                    different process group in the same session terminated or because of the
                    termination of the last process within the group that had a parent in another
                    group. (The latter case is the one illustrated in <a class="xref" href="ch34.html#steps_in_the_creation_of_an_orphaned_pro" title="Figure 34-3. Steps in the creation of an orphaned process group">Figure 34-3</a>.) In either case, the
                    treatment of a newly orphaned process group containing stopped children is the
                    same.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Sending <code class="literal">SIGHUP</code> and <code class="literal">SIGCONT</code> to a newly orphaned process group that
                        contains stopped members is done in order to eliminate a specific loophole
                        in the job-control framework. There is nothing to prevent the members of an
                        already-orphaned process group from later being stopped if another process
                        (with suitable privileges) sends them a stop signal. In this case, the
                        processes will remain stopped until some process (again with suitable
                        privileges) sends them a <code class="literal">SIGCONT</code>
                        signal.</p><p>When called by a member of an orphaned process group, the
                            <span class="emphasis"><em>tcsetpgrp()</em></span> function (<a class="xref" href="ch34.html#foreground_and_background_process_groups" title="Foreground and Background Process Groups">Foreground and Background Process Groups</a>) fails with the
                        error <code class="literal">ENOTTY</code>, and calls to the
                            <span class="emphasis"><em>tcsetattr()</em></span>, <span class="emphasis"><em>tcflush()</em></span>,
                            <span class="emphasis"><em>tcflow()</em></span>, <span class="emphasis"><em>tcsendbreak()</em></span>, and
                            <span class="emphasis"><em>tcdrain()</em></span> functions (all described in <a class="xref" href="ch62.html" title="Chapter 62. Terminals">Chapter 62</a>) fail with the error <code class="literal">EIO</code>.<a id="IDX-CHP-34-5101" class="indexterm"/><a id="IDX-CHP-34-5102" class="indexterm"/><a id="IDX-CHP-34-5103" class="indexterm"/><a id="IDX-CHP-34-5104" class="indexterm"/><a id="IDX-CHP-34-5105" class="indexterm"/><a id="IDX-CHP-34-5106" class="indexterm"/></p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id48">Example program</h4></div></div></div><p>The program in <a class="xref" href="ch34.html#sighup_and_orphaned_process_groups" title="Example 34-7. SIGHUP and orphaned process groups">Example 34-7</a>
                        demonstrates the treatment of orphaned processes that we have just
                        described. After establishing handlers for <code class="literal">SIGHUP</code> and <code class="literal">SIGCONT</code>
                        <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e96255"/><img src="figs/web/U002.png" alt=""/></span>, this program creates one child process for each
                        command-line argument <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e96261"/><img src="figs/web/U003.png" alt=""/></span>. Each child then stops itself (by raising <code class="literal">SIGSTOP</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e96271"/><img src="figs/web/U004.png" alt=""/></span>, or waits for signals (using
                            <span class="emphasis"><em>pause()</em></span>) <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e96280"/><img src="figs/web/U005.png" alt=""/></span>. The choice of action by the child is determined by
                        whether or not the corresponding command-line argument starts with the
                        letter <span class="emphasis"><em>s</em></span> (for <span class="emphasis"><em>stop</em></span>). (We use a
                        command-line argument starting with the letter <span class="emphasis"><em>p</em></span> to
                        specify the converse action of calling <span class="emphasis"><em>pause()</em></span>,
                        although any character other than the letter <span class="emphasis"><em>s</em></span> can be
                            used.)<a id="IDX-CHP-34-5107" class="indexterm"/><a id="IDX-CHP-34-5108" class="indexterm"/><a id="IDX-CHP-34-5109" class="indexterm"/><a id="IDX-CHP-34-5110" class="indexterm"/><a id="IDX-CHP-34-5111" class="indexterm"/><a id="IDX-CHP-34-5112" class="indexterm"/><a id="IDX-CHP-34-5113" class="indexterm"/></p><p>After creating all of the children, the parent sleeps for a few seconds to
                        allow the children time to get set up <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e96349"/><img src="figs/web/U006.png" alt=""/></span>. (As noted in <a class="xref" href="ch24.html#creating_a_new_process_colon_fork_open_p" title="Creating a New Process: fork()">Creating a New Process: <span class="emphasis"><em>fork()</em></span></a>, using
                            <span class="emphasis"><em>sleep()</em></span> in this way is an imperfect, but sometimes
                        viable method of accomplishing this result.) The parent then exits
                            <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e96360"/><img src="figs/web/U007.png" alt=""/></span>, at which point the process group containing the
                        children becomes orphaned. If any of the children receives a signal as a
                        consequence of the process group becoming orphaned, the signal handler is
                        invoked, and it displays the child’s process ID and the signal number
                            <span class="inlinemediaobject"><a id="I_inlinemediaobject34_d1e96366"/><img src="figs/web/U001.png" alt=""/></span>.</p><div class="example"><a id="sighup_and_orphaned_process_groups"/><div class="example-title">Example 34-7. <code class="literal">SIGHUP</code> and orphaned process
                            groups</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>pgsjc/orphaned_pgrp_SIGHUP.c</code></strong>
    #define _GNU_SOURCE     /* Get declaration of strsignal() from &lt;string.h&gt; */
    #include &lt;string.h&gt;
    #include &lt;signal.h&gt;
    #include "tlpi_hdr.h"

    static void             /* Signal handler */
    handler(int sig)
    {
<img src="figs/web/U001.png" alt=""/>    printf("PID=%ld: caught signal %d (%s)\n", (long) getpid(),
                sig, strsignal(sig));     /* UNSAFE (see Section 21.1.2) */
    }

    int
    main(int argc, char *argv[])
    {
        int j;
        struct sigaction sa;

        if (argc &lt; 2 || strcmp(argv[1], "--help") == 0)
            usageErr("%s {s|p} ...\n", argv[0]);

        setbuf(stdout, NULL);               /* Make stdout unbuffered */

        sigemptyset(&amp;sa.sa_mask);
        sa.sa_flags = 0;
        sa.sa_handler = handler;
<img src="figs/web/U002.png" alt=""/>    if (sigaction(SIGHUP, &amp;sa, NULL) == -1)
            errExit("sigaction");
        if (sigaction(SIGCONT, &amp;sa, NULL) == -1)
            errExit("sigaction");

        printf("parent: PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\n",
                (long) getpid(), (long) getppid(),
                (long) getpgrp(), (long) getsid(0));

        /* Create one child for each command-line argument */

<img src="figs/web/U003.png" alt=""/>    for (j = 1; j &lt; argc; j++) {
            switch (fork()) {
            case -1:
                errExit("fork");

            case 0:         /* Child */
                printf("child:  PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\n",
                        (long) getpid(), (long) getppid(),
                        (long) getpgrp(), (long) getsid(0));

                if (argv[j][0] == 's') {    /* Stop via signal */
                    printf("PID=%ld stopping\n", (long) getpid());
    <img src="figs/web/U004.png" alt=""/>                raise(SIGSTOP);
                } else {                    /* Wait for signal */
                    alarm(60);              /* So we die if not SIGHUPed */
                    printf("PID=%ld pausing\n", (long) getpid());
<img src="figs/web/U005.png" alt=""/>                pause();
                }

                _exit(EXIT_SUCCESS);

            default:        /* Parent carries on round loop */
                break;
            }
        }

        /* Parent falls through to here after creating all children */

<img src="figs/web/U006.png" alt=""/>    sleep(3);                           /* Give children a chance to start */
        printf("parent exiting\n");
<img src="figs/web/U007.png" alt=""/>    exit(EXIT_SUCCESS);                 /* And orphan them and their group */
    }

         <strong class="userinput"><code>pgsjc/orphaned_pgrp_SIGHUP.c</code></strong></pre></div></div><p>The following shell session log shows the results of two different runs of
                        the program in <a class="xref" href="ch34.html#sighup_and_orphaned_process_groups" title="Example 34-7. SIGHUP and orphaned process groups">Example 34-7</a>:</p><a id="I_programlisting34_d1e96430"/><pre class="programlisting">$ <strong class="userinput"><code>echo $$</code></strong>                     <em class="lineannotation"><span class="lineannotation">Display PID of shell, which is also the session ID</span></em>
4785
$ <strong class="userinput"><code>./orphaned_pgrp_SIGHUP s p</code></strong>
parent: PID=4827, PPID=4785, PGID=4827, SID=4785
child:  PID=4828, PPID=4827, PGID=4827, SID=4785
PID=4828 stopping
child:  PID=4829, PPID=4827, PGID=4827, SID=4785
PID=4829 pausing
parent exiting
$ PID=4828: caught signal 18 (Continued)
PID=4828: caught signal 1 (Hangup)
PID=4829: caught signal 18 (Continued)
PID=4829: caught signal 1 (Hangup)
<em class="lineannotation"><span class="lineannotation">Press Enter to get another shell prompt</span></em>
$ <strong class="userinput"><code>./orphaned_pgrp_SIGHUP p p</code></strong>
parent: PID=4830, PPID=4785, PGID=4830, SID=4785
child:  PID=4831, PPID=4830, PGID=4830, SID=4785
PID=4831 pausing
child:  PID=4832, PPID=4830, PGID=4830, SID=4785
PID=4832 pausing
parent exiting</pre><p>The first run creates two children in the to-be-orphaned process group:
                        one stops itself and the other pauses. (In this run, the shell prompt
                        appears in the middle of the children’s output because the shell notices
                        that the parent has already exited.) As can be seen, both children receive
                            <code class="literal">SIGCONT</code> and <code class="literal">SIGHUP</code> after the parent exits. In the second run, two
                        children are created, neither stops itself, and consequently no signals are
                        sent when the parent exits.</p></div><div class="sect3" title="Orphaned process groups and the SIGTSTP, SIGTTIN, and SIGTTOU signals"><div class="titlepage"><div><div><h4 class="title" id="orphaned_process_groups_and_the_sigtstp">Orphaned process groups and the <code class="literal">SIGTSTP</code>, <code class="literal">SIGTTIN</code>, and
                            <code class="literal">SIGTTOU</code> signals</h4></div></div></div><p>Orphaned process groups also affect the semantics for delivery of the
                            <code class="literal">SIGTSTP</code>, <code class="literal">SIGTTIN</code>, and <code class="literal">SIGTTOU</code>
                        signals.</p><p>In <a class="xref" href="ch34.html#using_job_control_within_the_shell" title="Using Job Control Within the Shell">Using Job Control Within the Shell</a>, we saw that
                            <code class="literal">SIGTTIN</code> is sent to a background
                        process if it tries to <span class="emphasis"><em>read()</em></span> from the controlling
                        terminal, and <code class="literal">SIGTTOU</code> is sent to a
                        background process that tries to <span class="emphasis"><em>write()</em></span> to the
                        controlling terminal if the terminal’s <code class="literal">TOSTOP</code> flag is set. However, it makes no sense to send these
                        signals to an orphaned process group since, once stopped, it will never be
                        resumed again. For this reason, instead of sending <code class="literal">SIGTTIN</code> or <code class="literal">SIGTTOU</code>, the
                        kernel causes <span class="emphasis"><em>read()</em></span> or <span class="emphasis"><em>write()</em></span> to
                        fail with the error <code class="literal">EIO</code>.</p><p>For similar reasons, if delivery of <code class="literal">SIGTSTP</code>, <code class="literal">SIGTTIN</code>, or
                            <code class="literal">SIGTTOU</code> would stop a member of an
                        orphaned process group, then the signal is silently discarded. (If the
                        signal is being handled, then it is delivered to the process.) This behavior
                        occurs no matter how the signal is sent—for example, whether the signal is
                        generated by the terminal driver or sent by an explicit call to
                            <span class="emphasis"><em>kill()</em></span>.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id33">Summary</h2></div></div></div><p>Sessions and process groups (also known as jobs) form a two-level hierarchy of
                processes: a session is a collection of process groups, and a process group is a
                collection of processes. A session leader is the process that created the session
                using <span class="emphasis"><em>setsid()</em></span>. Similarly, a process group leader is the
                process that created the group using <span class="emphasis"><em>setpgid()</em></span>. All of the
                members of a process group share the same process group ID (which is the same as the
                process ID of the process group leader), and all processes in the process groups
                that constitute a session have the same session ID (which is the same as the process
                ID of the session leader). Each session may have a controlling terminal (<code class="literal">/dev/tty</code>), which is established when the session
                leader opens a terminal device. Opening the controlling terminal also causes the
                session leader to become the controlling process for the terminal.<a id="IDX-CHP-34-5114" class="indexterm"/><a id="IDX-CHP-34-5115" class="indexterm"/><a id="IDX-CHP-34-5116" class="indexterm"/><a id="IDX-CHP-34-5117" class="indexterm"/><a id="IDX-CHP-34-5118" class="indexterm"/><a id="IDX-CHP-34-5119" class="indexterm"/><a id="IDX-CHP-34-5120" class="indexterm"/><a id="IDX-CHP-34-5121" class="indexterm"/></p><p>Sessions and process groups were defined to support shell job control (although
                occasionally they find other uses in applications). Under job control, the shell is
                the session leader and controlling process for the terminal on which it is running.
                Each job (a simple command or a pipeline) executed by the shell is created as a
                separate process group, and the shell provides commands to move a job between three
                states: running in the foreground, running in the background, and stopped in the
                background.</p><p>To support job control, the terminal driver maintains a record of the foreground
                process group (job) for the controlling terminal. The terminal driver delivers
                job-control signals to the foreground job when certain characters are typed. These
                signals either terminate or stop the foreground job.</p><p>The notion of the terminal’s foreground job is also used to arbitrate terminal I/O
                requests. Only processes in the foreground job may read from the controlling
                terminal. Background jobs are prevented from reading by delivery of the <code class="literal">SIGTTIN</code> signal, whose default action is to stop the
                job. If the terminal <code class="literal">TOSTOP</code> is set, then
                background jobs are also prevented from writing to the controlling terminal by
                delivery of a <code class="literal">SIGTTOU</code> signal, whose default
                action is to stop the job.</p><p>When a terminal disconnect occurs, the kernel delivers a <code class="literal">SIGHUP</code> signal to the controlling process to inform it of the fact.
                Such an event may result in a chain reaction whereby a <code class="literal">SIGHUP</code> signal is delivered to many other processes. First, if the
                controlling process is a shell (as is typically the case), then, before terminating,
                the shell sends <code class="literal">SIGHUP</code> to each of the process
                groups it has created. Second, if delivery of <code class="literal">SIGHUP</code> results in termination of a controlling process, then the
                kernel also sends <code class="literal">SIGHUP</code> to all of the members of
                the foreground process group of the controlling terminal.</p><p>In general, applications don’t need to be cognizant of job-control signals. One
                exception is when a program performs screen-handling operations. Such programs need
                to correctly handle the <code class="literal">SIGTSTP</code> signal, resetting
                terminal attributes to sane values before the process is suspended, and restoring
                the correct (application-specific) terminal attributes when the application is once
                more resumed following delivery of a <code class="literal">SIGCONT</code>
                signal.</p><p>A process group is considered to be orphaned if none of its member processes has a
                parent in a different process group in the same session. Orphaned process groups are
                significant because there is no process outside the group that can both monitor the
                state of any stopped processes within the group and is always allowed to send a
                    <code class="literal">SIGCONT</code> signal to these stopped processes in
                order to restart them. This could result in such stopped processes languishing
                forever on the system. To avoid this possibility, when a process group with stopped
                member processes becomes orphaned, all members of the process group are sent a
                    <code class="literal">SIGHUP</code> signal, followed by a <code class="literal">SIGCONT</code> signal, to notify them that they have become
                orphaned and ensure that they are restarted.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id45"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id46">Further information</h4></div></div></div><p><a class="xref" href="ch09.html" title="Chapter 9. Process Credentials">Chapter 9</a> of [Stevens &amp; Rago, 2005]
                        covers similar material to this chapter, and includes a description of the
                        steps that occur during login to establish the session for a login shell.
                        The <span class="emphasis"><em>glibc</em></span> manual contains a lengthy description of the
                        functions relating to job control and the implementation of job control
                        within the shell. The SUSv3 rationale contains an extensive discussion of
                        sessions, process groups, and job control.<a id="IDX-CHP-34-5122" class="indexterm"/></p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id22">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Suppose a parent process performs the following steps:</p><a id="I_programlisting34_d1e96673"/><pre class="programlisting">/* Call fork() to create a number of child processes, each of which
   remains in same process group as the parent */

/* Sometime later... */
signal(SIGUSR1, SIG_IGN);     /* Parent makes itself immune to SIGUSR1 */

killpg(getpgrp(), SIGUSR1);   /* Send signal to children created earlier */</pre><p>What problem might be encountered with this application design? (Consider
                        shell pipelines.) How could this problem be avoided?</p></li><li class="listitem"><p>Write a program to verify that a parent process can change the process
                        group ID of one of its children before the child performs an
                            <span class="emphasis"><em>exec()</em></span>, but not afterward.</p></li><li class="listitem"><p>Write a program to verify that a call to <span class="emphasis"><em>setsid()</em></span>
                        from a process group leader fails.</p></li><li class="listitem"><p>Modify the program in <a class="xref" href="ch34.html#catching_sighup_when_a_terminal_disconne" title="Example 34-4. Catching SIGHUP when a terminal disconnect occurs">Example 34-4</a> (<code class="literal">disc_SIGHUP.c</code>) to verify that, if the
                        controlling process doesn’t terminate as a consequence of receiving <code class="literal">SIGHUP</code>, then the kernel doesn’t send <code class="literal">SIGHUP</code> to the members of the foreground
                        process.</p></li><li class="listitem"><p>Suppose that, in the signal handler of <a class="xref" href="ch34.html#handling_sigtstp" title="Example 34-6. Handling SIGTSTP">Example 34-6</a>,
                        the code that unblocks the <code class="literal">SIGTSTP</code> signal
                        was moved to the start of the handler. What potential race condition does
                        this create?</p></li><li class="listitem"><p>Write a program to verify that when a process in an orphaned process group
                        attempts to <span class="emphasis"><em>read()</em></span> from the controlling terminal, the
                            <span class="emphasis"><em>read()</em></span> fails with the error <code class="literal">EIO</code>.</p></li><li class="listitem"><p>Write a program to verify that if one of the signals <code class="literal">SIGTTIN</code>, <code class="literal">SIGTTOU</code>, or <code class="literal">SIGTSTP</code> is
                        sent to a member of an orphaned process group, then the signal is discarded
                        (i.e., has no effect) if it would stop the process (i.e., the disposition is
                            <code class="literal">SIG_DFL</code>), but is delivered if a
                        handler is installed for the signal.</p></li></ol></div></div></section></body></html>
