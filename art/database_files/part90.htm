<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3.6   Null Values</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part89.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part91.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 6pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">3.6   <span style=" color: #00AEEF;">Null Values</span></p><p class="s63" style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Null values <span class="p">present special problems in relational operations, including arithmetic op- erations, comparison operations, and set operations.</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 83%;text-align: right;">The result of an arithmetic expression (involving, for example, <span class="s15">+</span>, <span class="s15">−</span>, <span class="s15">∗</span>, or <span class="s15">∕</span>) is null if any of the input values is null. For example, if a query has an expression <i>r</i><span class="s83">.</span><i>A </i><span class="s15">+ </span>5, and</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: right;">r<span class="s83">.</span>A <span class="p">is null for a particular tuple, then the expression result must also be null for that</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 10pt;text-align: left;">tuple.</p><p style="padding-top: 2pt;padding-left: 119pt;text-indent: 17pt;line-height: 76%;text-align: justify;">Comparisons involving nulls are more of a problem. For example, consider the comparison “1 <span class="s83">&lt; </span><b>null</b>”. It would be wrong to say this is true since we do not know what the null value represents. But it would likewise be wrong to claim this expression is false; if we did, “<b>not </b>(1 <span class="s83">&lt; </span><b>null</b>)” would evaluate to true, which does not make sense. <span class="s44">SQL </span>therefore treats as <b>unknown </b>the result of any comparison involving a null value</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">(other than predicates <b>is null </b>and <b>is not null</b>, which are described later in this section). This creates a third logical value in addition to <i>true </i>and <i>false</i>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Since the predicate in a <b>where </b>clause can involve Boolean operations such as <b>and</b>, <b>or</b>, and <b>not </b>on the results of comparisons, the deﬁnitions of the Boolean operations are extended to deal with the value <b>unknown</b>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s39">• </span><b>and</b><span class="p">: The result of </span>true <b>and </b>unknown <span class="p">is </span>unknown<span class="p">, </span>false <b>and </b>unknown <span class="p">is </span>false<span class="p">, while</span></p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;line-height: 13pt;text-align: left;">unknown <b>and </b>unknown <span class="p">is </span>unknown<span class="p">.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: left;"><span class="s39">• </span><b>or</b><span class="p">: The result of </span>true <b>or </b>unknown <span class="p">is </span>true<span class="p">, </span>false <b>or </b>unknown <span class="p">is </span>unknown<span class="p">, while </span>un- known <b>or </b>unknown <span class="p">is </span>unknown<span class="p">.</span></p><p style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><b>not</b>: The result of <b>not </b><i>unknown </i>is <i>unknown</i>.</p><p class="s13" style="padding-top: 12pt;padding-left: 88pt;text-indent: 17pt;line-height: 70%;text-align: justify;"><span class="p">You can verify that if </span>r<span class="s83">.</span>A <span class="p">is null, then “1 </span><span class="s83">&lt; </span>r<span class="s83">.</span>A<span class="p">” as well as “</span><b>not </b><span class="p">(1 </span><span class="s83">&lt; </span>r<span class="s83">.</span>A<span class="p">)” evaluate to unknown.</span></p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">If the <b>where </b>clause predicate evaluates to either <b>false </b>or <b>unknown </b>for a tuple, that tuple is not added to the result.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">uses the special keyword </span><b>null </b>in a predicate to test for a null value. Thus, to ﬁnd all instructors who appear in the <i>instructor </i>relation with null values for <i>salary</i>, we write:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 233pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 233pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 233pt;text-indent: 0pt;text-align: left;">where <i>salary </i>is null<span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">The predicate <b>is not null </b>succeeds if the value on which it is applied is not null.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;"><span class="s42">SQL </span><span class="s43">allows us to test whether the result of a comparison is unknown, rather than true or false, by using the clauses </span><b>is unknown </b>and <b>is not unknown</b>.<span class="s76">8</span> For example,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 202pt;text-indent: 0pt;text-align: left;">select <i>name</i></p><p class="s46" style="padding-left: 202pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 202pt;text-indent: 0pt;line-height: 20pt;text-align: left;">where <i>salary </i><span class="s83">&gt; </span><span class="p">10000 </span>is unknown<span class="p">;</span></p><p style="padding-top: 5pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">When a query uses the <b>select distinct </b>clause, duplicate tuples must be eliminated. For this purpose, when comparing values of corresponding attributes from two tuples, the values are treated as identical if either both are non-null and equal in value, or both are null. Thus, two copies of a tuple, such as <span class="s95">{</span>(&#39;A&#39;,null), (&#39;A&#39;,null)<span class="s95">}</span>, are treated as being identical, even if some of the attributes have a null value. Using the <b>distinct </b>clause then retains only one copy of such identical tuples. Note that the treatment of null above is diﬀerent from the way nulls are treated in predicates, where a comparison “null=null” would return unknown, rather than true.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The approach of treating tuples as identical if they have the same values for all attributes, even if some of the values are null, is also used for the set operations union, intersection, and except.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_380.png"/></span></p><p class="s79" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;"><span class="s77">8</span><span class="s78">The </span>is unknown <span class="s80">and </span>is not unknown <span class="s80">constructs are not supported by several databases.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part89.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part91.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
