<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>36.8 Case Study: A Simple IDE Disk Driver</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part373.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part375.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">36.8 Case Study: A Simple IDE Disk Driver</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To dig a little deeper here, let’s take a quick look at an actual device: an IDE disk drive [L94]. We summarize the protocol as described in this ref- erence [W10]; we’ll also peek at the xv6 source code for a simple example of a working IDE driver [CK+08].</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">An IDE disk presents a simple interface to the system, consisting of four types of register: control, command block, status, and error. These registers are available by reading or writing to specific “I/O addresses” (such as <span class="s41">0x3F6 </span>below) using (on x86) the <span class="s41">in </span>and <span class="s41">out </span>I/O instructions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Control Register:</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">Address 0x3F6 = 0x80 (0000 1RE0): R=reset, E=0 means &quot;enable interrupt&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 49pt;text-indent: -8pt;text-align: left;">Command Block Registers: Address 0x1F0 = Data Port Address 0x1F1 = Error Address 0x1F2 = Sector Count Address 0x1F3 = LBA low byte Address 0x1F4 = LBA mid byte Address 0x1F5 = LBA hi byte</p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">Address 0x1F6 = 1B1D TOP4LBA: B=LBA, D=drive Address 0x1F7 = Command/status</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Status Register (Address 0x1F7):</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">7   6  5   4  3  2  1  0</p><p class="s38" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">BUSY READY FAULT SEEK DRQ CORR IDDEX ERROR</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Error Register (Address 0x1F1): (check when Status ERROR==1)</p><table style="border-collapse:collapse;margin-left:51.0611pt" cellspacing="0"><tr style="height:8pt"><td style="width:23pt"><p class="s42" style="padding-right: 5pt;text-indent: 0pt;line-height: 6pt;text-align: center;">7</p></td><td style="width:28pt"><p class="s42" style="padding-left: 1pt;text-indent: 0pt;line-height: 6pt;text-align: center;">6</p></td><td style="width:21pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 6pt;text-align: left;">5</p></td><td style="width:113pt"><p class="s42" style="padding-left: 7pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">4  3  2  1  0</p></td></tr><tr style="height:8pt"><td style="width:23pt"><p class="s42" style="padding-left: 1pt;padding-right: 7pt;text-indent: 0pt;line-height: 6pt;text-align: center;">BBK</p></td><td style="width:28pt"><p class="s42" style="padding-left: 7pt;padding-right: 5pt;text-indent: 0pt;line-height: 6pt;text-align: center;">UNC</p></td><td style="width:21pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 6pt;text-align: left;">MC</p></td><td style="width:113pt"><p class="s42" style="padding-left: 7pt;padding-right: 3pt;text-indent: 0pt;line-height: 6pt;text-align: center;">IDNF MCR ABRT T0NF AMNF</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">BBK = Bad Block</p><p class="s38" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">UNC = Uncorrectable data error MC = Media Changed</p><p class="s38" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">IDNF = ID mark Not Found</p><p class="s38" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">MCR = Media Change Requested ABRT = Command aborted</p><p class="s38" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">T0NF = Track 0 Not Found AMNF = Address Mark Not Found</p><p style="padding-top: 2pt;padding-left: 124pt;text-indent: 0pt;text-align: left;">Figure 36.4: <b>The IDE Interface</b></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The basic protocol to interact with the device is as follows, assuming it has already been initialized.</p><p class="s4" style="padding-top: 7pt;padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Wait for drive to be ready. </span><span class="p">Read Status Register (0x1F7) until drive is not busy and READY.</span></p><p class="s4" style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Write parameters to command registers. </span><span class="p">Write the sector count, logical block address (LBA) of the sectors to be accessed, and drive number (master=0x00 or slave=0x10, as IDE permits just two drives) to command registers (0x1F2-0x1F6).</span></p><p class="s4" style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Start the I/O. </span><span class="p">by issuing read/write to command register. Write READ—WRITE command to command register (0x1F7).</span></p><p class="s4" style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Data transfer (for writes): </span><span class="p">Wait until drive status is READY and DRQ (drive request for data); write data to data port.</span></p><p class="s4" style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Handle interrupts. </span><span class="p">In the simplest case, handle an interrupt for each sector transferred; more complex approaches allow batching and thus one final interrupt when the entire transfer is complete.</span></p><p class="s4" style="padding-left: 64pt;text-indent: -9pt;line-height: 89%;text-align: justify;">• <span class="s27">Error handling. </span><span class="p">After each operation, read the status register. If the ERROR bit is on, read the error register for details.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_526.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_527.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_528.png"/></span></p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Most of this protocol is found in the xv6 IDE driver (Figure <span style=" color: #00AEEF;">36.5</span>), which (after initialization) works through four primary functions. The first is <span class="s41">ide rw()</span>, which queues a request (if there are others pending), or issues it directly to the disk (via <span class="s41">ide start request()</span>); in either</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 27pt;text-indent: 0pt;text-align: center;">static int ide_wait_ready() {</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;text-align: center;">while (((int r = inb(0x1f7)) &amp; IDE_BSY) || !(r &amp; IDE_DRDY))</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;text-align: center;">;            // loop until drive isn’t busy</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 77pt;text-indent: -8pt;line-height: 89%;text-align: left;">static void ide_start_request(struct buf <span class="s39">*</span>b) { ide_wait_ready();</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">outb(0x3f6, 0);       // generate interrupt</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">outb(0x1f2, 1);       // how many sectors? outb(0x1f3, b-&gt;sector &amp; 0xff);  // LBA goes here ... outb(0x1f4, (b-&gt;sector &gt;&gt; 8) &amp; 0xff);  // ... and here outb(0x1f5, (b-&gt;sector &gt;&gt; 16) &amp; 0xff); // ... and here! outb(0x1f6, 0xe0 | ((b-&gt;dev&amp;1)&lt;&lt;4) | ((b-&gt;sector&gt;&gt;24)&amp;0x0f)); if(b-&gt;flags &amp; B_DIRTY){</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;text-align: left;">outb(0x1f7, IDE_CMD_WRITE);  // this is a WRITE outsl(0x1f0, b-&gt;data, 512/4); // transfer data too!</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;line-height: 8pt;text-align: left;">} else {</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;text-align: left;">outb(0x1f7, IDE_CMD_READ);  // this is a READ (no data)</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;line-height: 8pt;text-align: left;">}</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 77pt;text-indent: -8pt;line-height: 90%;text-align: left;">void ide_rw(struct buf <span class="s39">*</span>b) { acquire(&amp;ide_lock);</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;line-height: 9pt;text-align: left;">for (struct buf <span class="s39">**</span>pp = &amp;ide_queue; <span class="s39">*</span>pp; pp=&amp;(<span class="s39">*</span>pp)-&gt;qnext)</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;line-height: 8pt;text-align: left;">;            // walk queue</p><p class="s39" style="padding-left: 77pt;text-indent: 0pt;line-height: 8pt;text-align: left;">*<span class="s38">pp = b;          // add request to end</span></p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;line-height: 7pt;text-align: left;">if (ide_queue == b)      // if q is empty</p><p class="s38" style="padding-left: 77pt;text-indent: 8pt;text-align: left;">ide_start_request(b);    // send req to disk while ((b-&gt;flags &amp; (B_VALID|B_DIRTY)) != B_VALID)</p><p class="s38" style="padding-left: 77pt;text-indent: 8pt;text-align: left;">sleep(b, &amp;ide_lock);    // wait for completion release(&amp;ide_lock);</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 77pt;text-indent: -8pt;text-align: left;">void ide_intr() { struct buf <span class="s39">*</span>b; acquire(&amp;ide_lock);</p><p class="s38" style="padding-left: 85pt;text-indent: -8pt;text-align: left;">if (!(b-&gt;flags &amp; B_DIRTY) &amp;&amp; ide_wait_ready(1) &gt;= 0) insl(0x1f0, b-&gt;data, 512/4);  // if READ: get data</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">b-&gt;flags |= B_VALID; b-&gt;flags &amp;= ˜B_DIRTY;</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">wakeup(b);         // wake waiting process if ((ide_queue = b-&gt;qnext) != 0) // start next request</p><p class="s38" style="padding-left: 77pt;text-indent: 8pt;text-align: left;">ide_start_request(ide_queue); // (if one exists) release(&amp;ide_lock);</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 7pt;text-align: left;">}</p><p style="padding-left: 111pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 36.5: <b>The xv6 IDE Disk Driver (Simplified)</b></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_529.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_530.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_531.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_532.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_533.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_534.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_535.png"/></span></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: justify;">case, the routine waits for the request to complete and the calling pro- cess is put to sleep. The second is <span class="s41">ide start request()</span>, which is used to send a request (and perhaps data, in the case of a write) to the disk; the <span class="s41">in </span>and <span class="s41">out </span>x86 instructions are called to read and write device registers, respectively. The start request routine uses the third function, <span class="s41">ide wait ready()</span>, to ensure the drive is ready before issuing a request to it. Finally, <span class="s41">ide intr() </span>is invoked when an interrupt takes place; it reads data from the device (if the request is a read, not a write), wakes the process waiting for the I/O to complete, and (if there are more requests in the I/O queue), launches the next I/O via <span class="s41">ide start request()</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part373.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part375.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
