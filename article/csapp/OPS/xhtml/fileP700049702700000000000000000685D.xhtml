<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>8.4 Process Control</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P700049702700000000000000000685D" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000045056" data-uri="chapter08.xhtml#P7000497027000000000000000045056" epub:type="title"><span class="pcalibre label pcalibre1">8.4 </span>Process Control</h1></header>
<p id="P7000497027000000000000000045057" data-uri="chapter08.xhtml#P7000497027000000000000000045057" class="pcalibre1 pcalibre calibre2">Unix provides a number of system calls for manipulating processes from C programs. This section describes the important functions and gives examples of how they are used.</p>

<section id="P7000497027000000000000000006860" data-uri="chapter08.xhtml#P7000497027000000000000000006860" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045058" data-uri="chapter08.xhtml#P7000497027000000000000000045058" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006862" title="739" data-uri="chapter08.xhtml#P7000497027000000000000000006862" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">8.4.1  </span>Obtaining Process IDs</h1></header>
<p id="P7000497027000000000000000045059" data-uri="chapter08.xhtml#P7000497027000000000000000045059" class="pcalibre1 pcalibre calibre2">Each process has a unique positive (nonzero) <i class="calibre5 pcalibre pcalibre1">process ID (PID)</i>. The <code id="P700049702700000000000000004505A" data-uri="chapter08.xhtml#P700049702700000000000000004505A" class="pcalibre1 calibre8 pcalibre">getpid</code> function returns the PID of the calling process. The <code id="P700049702700000000000000004505B" data-uri="chapter08.xhtml#P700049702700000000000000004505B" class="pcalibre1 calibre8 pcalibre">getppid</code> function returns the PID of its <i class="calibre5 pcalibre pcalibre1">parent</i> (i.e., the process that created the calling process).</p>
<pre id="P700049702700000000000000004505C" data-uri="chapter08.xhtml#P700049702700000000000000004505C" class="calibre9 pcalibre pcalibre1">
<code id="P700049702700000000000000004505D" data-uri="chapter08.xhtml#P700049702700000000000000004505D" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t getpid(void);
pid_t getppid(void);
				Returns: PID of either the caller or the parent
</code>
</pre>
<p id="P700049702700000000000000004505E" data-uri="chapter08.xhtml#P700049702700000000000000004505E" class="pcalibre1 pcalibre calibre2">The <code id="P700049702700000000000000004505F" data-uri="chapter08.xhtml#P700049702700000000000000004505F" class="pcalibre1 calibre8 pcalibre">getpid</code> and <code id="P7000497027000000000000000045060" data-uri="chapter08.xhtml#P7000497027000000000000000045060" class="pcalibre1 calibre8 pcalibre">getppid</code> routines return an integer value of type <code id="P7000497027000000000000000045061" data-uri="chapter08.xhtml#P7000497027000000000000000045061" class="pcalibre1 calibre8 pcalibre">pid_t</code>, which on Linux systems is defined in <code id="P7000497027000000000000000045062" data-uri="chapter08.xhtml#P7000497027000000000000000045062" class="pcalibre1 calibre8 pcalibre">types.h</code> as an int.</p>
</section>

<section id="P700049702700000000000000000686D" data-uri="chapter08.xhtml#P700049702700000000000000000686D" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045063" data-uri="chapter08.xhtml#P7000497027000000000000000045063" epub:type="title"><span class="pcalibre label pcalibre1">8.4.2  </span>Creating and Terminating Processes</h1></header>
<p id="P7000497027000000000000000045064" data-uri="chapter08.xhtml#P7000497027000000000000000045064" class="pcalibre1 pcalibre calibre2">From a programmer's perspective, we can think of a process as being in one of three states:</p>
<ul class="pcalibre ul_none pcalibre1" id="P7000497027000000000000000045065" data-uri="chapter08.xhtml#P7000497027000000000000000045065">
<li id="P7000497027000000000000000045066" data-uri="chapter08.xhtml#P7000497027000000000000000045066" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045067" data-uri="chapter08.xhtml#P7000497027000000000000000045067" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Running. </span>The process is either executing on the CPU or waiting to be executed and will eventually be scheduled by the kernel.</p></li>
<li id="P7000497027000000000000000045068" data-uri="chapter08.xhtml#P7000497027000000000000000045068" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045069" data-uri="chapter08.xhtml#P7000497027000000000000000045069" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Stopped. </span>The execution of the process is <i class="calibre5 pcalibre pcalibre1">suspended</i> and will not be scheduled. A process stops as a result of receiving a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal, and it remains stopped until it receives a SIGCONT signal, at which point it becomes running again. (A <i class="calibre5 pcalibre pcalibre1">signal</i> is a form of software interrupt that we will describe in detail in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006993"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">8.5</span></a>.)</p></li>
<li id="P700049702700000000000000004506A" data-uri="chapter08.xhtml#P700049702700000000000000004506A" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004506B" data-uri="chapter08.xhtml#P700049702700000000000000004506B" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Terminated. </span>The process is stopped permanently. A process becomes terminated for one of three reasons: (1) receiving a signal whose default action is to terminate the process, (2) returning from the main routine, or (3) calling the <code id="P700049702700000000000000004506C" data-uri="chapter08.xhtml#P700049702700000000000000004506C" class="pcalibre1 calibre8 pcalibre">exit</code> function.</p></li>
</ul>
<pre id="P700049702700000000000000004506D" data-uri="chapter08.xhtml#P700049702700000000000000004506D" class="calibre9 pcalibre pcalibre1">
<code id="P700049702700000000000000004506E" data-uri="chapter08.xhtml#P700049702700000000000000004506E" class="calibre10 pcalibre pcalibre1">
#include &lt;stdlib.h&gt;
void exit(int status);
				This function does not return
</code>
</pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004506F" data-uri="chapter08.xhtml#P700049702700000000000000004506F">The <code id="P7000497027000000000000000045070" data-uri="chapter08.xhtml#P7000497027000000000000000045070" class="pcalibre1 calibre8 pcalibre">exit</code> function terminates the process with an <i class="calibre5 pcalibre pcalibre1">exit status</i> of <code id="P7000497027000000000000000045071" data-uri="chapter08.xhtml#P7000497027000000000000000045071" class="pcalibre1 calibre8 pcalibre">status</code>. (The other way to set the exit status is to return an integer value from the main routine.)</p>

<p id="P7000497027000000000000000045072" data-uri="chapter08.xhtml#P7000497027000000000000000045072" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000687E" title="740" data-uri="chapter08.xhtml#P700049702700000000000000000687E" epub:type="pagebreak"></span>A <i class="calibre5 pcalibre pcalibre1">parent process</i> creates a new running <i class="calibre5 pcalibre pcalibre1">child process</i> by calling the <code id="P7000497027000000000000000045073" data-uri="chapter08.xhtml#P7000497027000000000000000045073" class="pcalibre1 calibre8 pcalibre">fork</code> function.</p>
<pre id="P7000497027000000000000000045074" data-uri="chapter08.xhtml#P7000497027000000000000000045074" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045075" data-uri="chapter08.xhtml#P7000497027000000000000000045075" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t fork(void);
			Returns: 0 to child, PID of child to parent, -1 on error
</code>
</pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045076" data-uri="chapter08.xhtml#P7000497027000000000000000045076">The newly created child process is almost, but not quite, identical to the parent. The child gets an identical (but separate) copy of the parent's user-level virtual address space, including the code and data segments, heap, shared libraries, and user stack. The child also gets identical copies of any of the parent's open file descriptors, which means the child can read and write any files that were open in the parent when it called <code id="P7000497027000000000000000045077" data-uri="chapter08.xhtml#P7000497027000000000000000045077" class="pcalibre1 calibre8 pcalibre">fork</code>. The most significant difference between the parent and the newly created child is that they have different PIDs.</p>
<p id="P7000497027000000000000000045078" data-uri="chapter08.xhtml#P7000497027000000000000000045078" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045079" data-uri="chapter08.xhtml#P7000497027000000000000000045079" class="pcalibre1 calibre8 pcalibre">fork</code> function is interesting (and often confusing) because it is called <i class="calibre5 pcalibre pcalibre1">once</i> but it returns <i class="calibre5 pcalibre pcalibre1">twice:</i> once in the calling process (the parent), and once in the newly created child process. In the parent, <code id="P700049702700000000000000004507A" data-uri="chapter08.xhtml#P700049702700000000000000004507A" class="pcalibre1 calibre8 pcalibre">fork</code> returns the PID of the child. In the child, <code id="P700049702700000000000000004507B" data-uri="chapter08.xhtml#P700049702700000000000000004507B" class="pcalibre1 calibre8 pcalibre">fork</code> returns a value of 0. Since the PID of the child is always nonzero, the return value provides an unambiguous way to tell whether the program is executing in the parent or the child.</p>
<p id="P700049702700000000000000004507C" data-uri="chapter08.xhtml#P700049702700000000000000004507C" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000689A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.15 </span></a>shows a simple example of a parent process that uses <code id="P700049702700000000000000004507D" data-uri="chapter08.xhtml#P700049702700000000000000004507D" class="pcalibre1 calibre8 pcalibre">fork</code> to create a child process. When the <code id="P700049702700000000000000004507E" data-uri="chapter08.xhtml#P700049702700000000000000004507E" class="pcalibre1 calibre8 pcalibre">fork</code> call returns in line 6, <code id="P700049702700000000000000004507F" data-uri="chapter08.xhtml#P700049702700000000000000004507F" class="pcalibre1 calibre8 pcalibre">x</code> has a value of 1 in both the parent and child. The child increments and prints its copy of <code id="P7000497027000000000000000045080" data-uri="chapter08.xhtml#P7000497027000000000000000045080" class="pcalibre1 calibre8 pcalibre">x</code> in line 8. Similarly, the parent decrements and prints its copy of <code id="P7000497027000000000000000045081" data-uri="chapter08.xhtml#P7000497027000000000000000045081" class="pcalibre1 calibre8 pcalibre">x</code> in line 13.</p>
<p id="P7000497027000000000000000045082" data-uri="chapter08.xhtml#P7000497027000000000000000045082" class="pcalibre1 pcalibre calibre2">When we run the program on our Unix system, we get the following result:</p>
<pre id="P7000497027000000000000000045083" data-uri="chapter08.xhtml#P7000497027000000000000000045083" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045084" data-uri="chapter08.xhtml#P7000497027000000000000000045084" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">./fork</i>
parent: x=0
child : x=2
</code>
</pre>
<p id="P7000497027000000000000000045085" data-uri="chapter08.xhtml#P7000497027000000000000000045085" class="pcalibre1 pcalibre calibre2">There are some subtle aspects to this simple example.</p>
<ul class="pcalibre ul_none pcalibre1" id="P7000497027000000000000000045086" data-uri="chapter08.xhtml#P7000497027000000000000000045086">
<li id="P7000497027000000000000000045087" data-uri="chapter08.xhtml#P7000497027000000000000000045087" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045088" data-uri="chapter08.xhtml#P7000497027000000000000000045088" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Call once, return twice. </span>The <code id="P7000497027000000000000000045089" data-uri="chapter08.xhtml#P7000497027000000000000000045089" class="pcalibre1 calibre8 pcalibre">fork</code> function is called once by the parent, but it returns twice: once to the parent and once to the newly created child. This is fairly straightforward for programs that create a single child. But programs with multiple instances of <code id="P700049702700000000000000004508A" data-uri="chapter08.xhtml#P700049702700000000000000004508A" class="pcalibre1 calibre8 pcalibre">fork</code> can be confusing and need to be reasoned about carefully.</p></li>
<li id="P700049702700000000000000004508B" data-uri="chapter08.xhtml#P700049702700000000000000004508B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004508C" data-uri="chapter08.xhtml#P700049702700000000000000004508C" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Concurrent execution. </span>The parent and the child are separate processes that run concurrently. The instructions in their logical control flows can be interleaved by the kernel in an arbitrary way. When we run the program on our system, the parent process completes its <code id="P700049702700000000000000004508D" data-uri="chapter08.xhtml#P700049702700000000000000004508D" class="pcalibre1 calibre8 pcalibre">printf</code> statement first, followed by the child. However, on another system the reverse might be true. In general, as programmers we can never make assumptions about the interleaving of the instructions in different processes.</p>

<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000689A" data-uri="chapter08.xhtml#P700049702700000000000000000689A">
<p id="P700049702700000000000000004508E" data-uri="chapter08.xhtml#P700049702700000000000000004508E" class="calibre13 pcalibre pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000689C" title="741" data-uri="chapter08.xhtml#P700049702700000000000000000689C" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/fork.c</i></p>
<pre id="P700049702700000000000000004508F" data-uri="chapter08.xhtml#P700049702700000000000000004508F" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045090" data-uri="chapter08.xhtml#P7000497027000000000000000045090" class="calibre10 pcalibre pcalibre1">
1	int main()
2	{
3		pid_t pid;
4		int x = 1;
5	
6		pid = Fork();
7		if (pid == 0) { /* Child */
8			printf("child : x=%d\n", ++x);
9			exit(0);
10		}
11	
12		/* Parent */
13			printf("parent: x=%d\n", --x);
14			exit(0);
15	}
</code>
</pre>
<p id="P7000497027000000000000000045091" data-uri="chapter08.xhtml#P7000497027000000000000000045091" class="calibre13 pcalibre pcalibre1">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/fork.c</i></p>

<figcaption id="P7000497027000000000000000045092" data-uri="chapter08.xhtml#P7000497027000000000000000045092" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045093" data-uri="chapter08.xhtml#P7000497027000000000000000045093" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">8.15 </span>Using <code id="P7000497027000000000000000045094" data-uri="chapter08.xhtml#P7000497027000000000000000045094" class="pcalibre1 calibre8 pcalibre">fork</code> to create a new process.</h1></header>
</figcaption>
</figure>
</li>
<li id="P7000497027000000000000000045095" data-uri="chapter08.xhtml#P7000497027000000000000000045095" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045096" data-uri="chapter08.xhtml#P7000497027000000000000000045096" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Duplicate but separate address spaces. </span>If we could halt both the parent and the child immediately after the <code id="P7000497027000000000000000045097" data-uri="chapter08.xhtml#P7000497027000000000000000045097" class="pcalibre1 calibre8 pcalibre">fork</code> function returned in each process, we would see that the address space of each process is identical. Each process has the same user stack, the same local variable values, the same heap, the same global variable values, and the same code. Thus, in our example program, local variable <code id="P7000497027000000000000000045098" data-uri="chapter08.xhtml#P7000497027000000000000000045098" class="pcalibre1 calibre8 pcalibre">x</code> has a value of 1 in both the parent and the child when the <code id="P7000497027000000000000000045099" data-uri="chapter08.xhtml#P7000497027000000000000000045099" class="pcalibre1 calibre8 pcalibre">fork</code> function returns in line 6. However, since the parent and the child are separate processes, they each have their own private address spaces. Any subsequent changes that a parent or child makes to <code id="P700049702700000000000000004509A" data-uri="chapter08.xhtml#P700049702700000000000000004509A" class="pcalibre1 calibre8 pcalibre">x</code> are private and are not reflected in the memory of the other process. This is why the variable <code id="P700049702700000000000000004509B" data-uri="chapter08.xhtml#P700049702700000000000000004509B" class="pcalibre1 calibre8 pcalibre">x</code> has different values in the parent and child when they call their respective <code id="P700049702700000000000000004509C" data-uri="chapter08.xhtml#P700049702700000000000000004509C" class="pcalibre1 calibre8 pcalibre">printf</code> statements.</p></li>
<li id="P700049702700000000000000004509D" data-uri="chapter08.xhtml#P700049702700000000000000004509D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004509E" data-uri="chapter08.xhtml#P700049702700000000000000004509E" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Shared files. </span>When we run the example program, we notice that both parent and child print their output on the screen. The reason is that the child inherits all of the parent's open files. When the parent calls <code id="P700049702700000000000000004509F" data-uri="chapter08.xhtml#P700049702700000000000000004509F" class="pcalibre1 calibre8 pcalibre">fork</code>, the <code id="P70004970270000000000000000450A0" data-uri="chapter08.xhtml#P70004970270000000000000000450A0" class="pcalibre1 calibre8 pcalibre">stdout</code> file is open and directed to the screen. The child inherits this file, and thus its output is also directed to the screen.</p></li>
</ul>

<p id="P70004970270000000000000000450A1" data-uri="chapter08.xhtml#P70004970270000000000000000450A1" class="pcalibre1 pcalibre calibre2">When you are first learning about the <code id="P70004970270000000000000000450A2" data-uri="chapter08.xhtml#P70004970270000000000000000450A2" class="pcalibre1 calibre8 pcalibre">fork</code> function, it is often helpful to sketch the <i class="calibre5 pcalibre pcalibre1">process graph</i>, which is a simple kind of precedence graph that captures the partial ordering of program statements. Each vertex <var class="calibre5 pcalibre pcalibre1">a</var> corresponds to the execution of a program statement. A directed edge <var class="calibre5 pcalibre pcalibre1">a</var> → <var class="calibre5 pcalibre pcalibre1">b</var> denotes that statement <var class="calibre5 pcalibre pcalibre1">a</var> “happens before” statement <var class="calibre5 pcalibre pcalibre1">b</var>. Edges can be labeled with information such as the current value of a variable. Vertices corresponding to <code id="P70004970270000000000000000450A3" data-uri="chapter08.xhtml#P70004970270000000000000000450A3" class="pcalibre1 calibre8 pcalibre">printf</code> statements can be labeled with the output of the <code id="P70004970270000000000000000450A4" data-uri="chapter08.xhtml#P70004970270000000000000000450A4" class="pcalibre1 calibre8 pcalibre">printf</code>. Each graph begins with a vertex that</p>

<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000068B3" data-uri="chapter08.xhtml#P70004970270000000000000000068B3">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000068B4" title="742" data-uri="chapter08.xhtml#P70004970270000000000000000068B4" epub:type="pagebreak"></span><img alt="A diagram shows a process graph." id="P70004970270000000000000000450A5" data-uri="P700049702700000000000000000B76C" src="../images/p742-1.png" class="calibre249 pcalibre pcalibre1"/>
<figcaption id="P70004970270000000000000000450A6" data-uri="chapter08.xhtml#P70004970270000000000000000450A6" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000450A7" data-uri="chapter08.xhtml#P70004970270000000000000000450A7" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">8.16 </span>Process graph for the example program in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000689A"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">8.15</span></a>.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000253CB" data-uri="chapter08.xhtml#P70004970270000000000000000253CB">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000450A8" data-uri="chapter08.xhtml#P70004970270000000000000000450A8" class="pcalibre1 pcalibre calibre2">A diagram shows a process graph flowing as summarized below.</p>
<ul id="P70004970270000000000000000450A9" data-uri="chapter08.xhtml#P70004970270000000000000000450A9" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000450AA" data-uri="chapter08.xhtml#P70004970270000000000000000450AA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450AB" data-uri="chapter08.xhtml#P70004970270000000000000000450AB" class="pcalibre calibre3 pcalibre1">X==1 from main to fork, splitting toward Child and Parent:</p>
<ul id="P70004970270000000000000000450AC" data-uri="chapter08.xhtml#P70004970270000000000000000450AC" class="pcalibre calibre39 pcalibre1">
<li id="P70004970270000000000000000450AD" data-uri="chapter08.xhtml#P70004970270000000000000000450AD" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450AE" data-uri="chapter08.xhtml#P70004970270000000000000000450AE" class="pcalibre calibre3 pcalibre1">To printf at child: x=2, and then exit at Child</p></li>
<li id="P70004970270000000000000000450AF" data-uri="chapter08.xhtml#P70004970270000000000000000450AF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450B0" data-uri="chapter08.xhtml#P70004970270000000000000000450B0" class="pcalibre calibre3 pcalibre1">To printf at parent: x=0, and then exit at Parent</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000068B8" data-uri="chapter08.xhtml#P70004970270000000000000000068B8">
<img alt="A diagram shows a code and associated process graph." id="P70004970270000000000000000450B1" data-uri="P700049702700000000000000000B76D" src="../images/p742-2.png" class="pcalibre calibre250 pcalibre1"/>
<figcaption id="P70004970270000000000000000450B2" data-uri="chapter08.xhtml#P70004970270000000000000000450B2" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000450B3" data-uri="chapter08.xhtml#P70004970270000000000000000450B3" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">8.17 </span>Process graph for a nested <code id="P70004970270000000000000000450B4" data-uri="chapter08.xhtml#P70004970270000000000000000450B4" class="pcalibre1 calibre8 pcalibre">fork</code>.</h1></header>

<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000253D9" data-uri="chapter08.xhtml#P70004970270000000000000000253D9">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000450B5" data-uri="chapter08.xhtml#P70004970270000000000000000450B5" class="pcalibre1 pcalibre calibre2">The lines of the code are listed below.</p>
<ul id="P70004970270000000000000000450B6" data-uri="chapter08.xhtml#P70004970270000000000000000450B6" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000450B7" data-uri="chapter08.xhtml#P70004970270000000000000000450B7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450B8" data-uri="chapter08.xhtml#P70004970270000000000000000450B8" class="pcalibre calibre3 pcalibre1">Int main()</p></li>
<li id="P70004970270000000000000000450B9" data-uri="chapter08.xhtml#P70004970270000000000000000450B9" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450BA" data-uri="chapter08.xhtml#P70004970270000000000000000450BA" class="pcalibre calibre3 pcalibre1">{</p></li>
<li id="P70004970270000000000000000450BB" data-uri="chapter08.xhtml#P70004970270000000000000000450BB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450BC" data-uri="chapter08.xhtml#P70004970270000000000000000450BC" class="pcalibre calibre3 pcalibre1">Fork();</p></li>
<li id="P70004970270000000000000000450BD" data-uri="chapter08.xhtml#P70004970270000000000000000450BD" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450BE" data-uri="chapter08.xhtml#P70004970270000000000000000450BE" class="pcalibre calibre3 pcalibre1">Fork();</p></li>
<li id="P70004970270000000000000000450BF" data-uri="chapter08.xhtml#P70004970270000000000000000450BF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450C0" data-uri="chapter08.xhtml#P70004970270000000000000000450C0" class="pcalibre calibre3 pcalibre1">printf(“hello\n”);</p></li>
<li id="P70004970270000000000000000450C1" data-uri="chapter08.xhtml#P70004970270000000000000000450C1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450C2" data-uri="chapter08.xhtml#P70004970270000000000000000450C2" class="pcalibre calibre3 pcalibre1">exit(0);</p></li>
<li id="P70004970270000000000000000450C3" data-uri="chapter08.xhtml#P70004970270000000000000000450C3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450C4" data-uri="chapter08.xhtml#P70004970270000000000000000450C4" class="pcalibre calibre3 pcalibre1">}</p></li>
</ul>
<p id="P70004970270000000000000000450C5" data-uri="chapter08.xhtml#P70004970270000000000000000450C5" class="pcalibre calibre3 pcalibre1">The graph has an arrow from main leading to a fork, which splits into two other forks. Each of the forks splits to two printf at hello and then exit.</p>
</details>
</figcaption>
</figure>

<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000450C6" data-uri="chapter08.xhtml#P70004970270000000000000000450C6">corresponds to the parent process calling main. This vertex has no inedges and exactly one outedge. The sequence of vertices for each process ends with a vertex corresponding to a call to <code id="P70004970270000000000000000450C7" data-uri="chapter08.xhtml#P70004970270000000000000000450C7" class="pcalibre1 calibre8 pcalibre">exit</code>. This vertex has one inedge and no outedges.</p>
<p id="P70004970270000000000000000450C8" data-uri="chapter08.xhtml#P70004970270000000000000000450C8" class="pcalibre1 pcalibre calibre2">For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000068B3"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.16 </span></a>shows the process graph for the example program in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000689A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.15</span></a>. Initially, the parent sets variable <code id="P70004970270000000000000000450C9" data-uri="chapter08.xhtml#P70004970270000000000000000450C9" class="pcalibre1 calibre8 pcalibre">x</code> to 1. The parent calls <code id="P70004970270000000000000000450CA" data-uri="chapter08.xhtml#P70004970270000000000000000450CA" class="pcalibre1 calibre8 pcalibre">fork</code>, which creates a child process that runs concurrently with the parent in its own private address space.</p>

<p id="P70004970270000000000000000450CB" data-uri="chapter08.xhtml#P70004970270000000000000000450CB" class="pcalibre1 pcalibre calibre2">For a program running on a single processor, any <i class="calibre5 pcalibre pcalibre1">topological sort</i> of the vertices in the corresponding process graph represents a feasible total ordering of the statements in the program. Here's a simple way to understand the idea of a topological sort: Given some permutation of the vertices in the process graph, draw the sequence of vertices in a line from left to right, and then draw each of the directed edges. The permutation is a topological sort if and only if each edge in the drawing goes from left to right. Thus, in our example program in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000689A"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.15</span></a>, the <code id="P70004970270000000000000000450CC" data-uri="chapter08.xhtml#P70004970270000000000000000450CC" class="pcalibre1 calibre8 pcalibre">printf</code> statements in the parent and child can occur in either order because each of the orderings corresponds to some topological sort of the graph vertices.</p>
<p id="P70004970270000000000000000450CD" data-uri="chapter08.xhtml#P70004970270000000000000000450CD" class="pcalibre1 pcalibre calibre2">The process graph can be especially helpful in understanding programs with nested <code id="P70004970270000000000000000450CE" data-uri="chapter08.xhtml#P70004970270000000000000000450CE" class="pcalibre1 calibre8 pcalibre">fork</code> calls. For example, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000068B8"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.17</span></a> shows a program with two calls to <code id="P70004970270000000000000000450CF" data-uri="chapter08.xhtml#P70004970270000000000000000450CF" class="pcalibre1 calibre8 pcalibre">fork</code> in the source code. The corresponding process graph helps us see that this program runs four processes, each of which makes a call to <code id="P70004970270000000000000000450D0" data-uri="chapter08.xhtml#P70004970270000000000000000450D0" class="pcalibre1 calibre8 pcalibre">printf</code> and which can execute in any order.</p>


<section id="P70004970270000000000000000068C8" data-uri="chapter08.xhtml#P70004970270000000000000000068C8" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000450D1" data-uri="chapter08.xhtml#P70004970270000000000000000450D1" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000068CA" title="743" data-uri="chapter08.xhtml#P70004970270000000000000000068CA" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">8.2 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000006E81.xhtml#P7000497027000000000000000006F86">795</a>)</h1></header>
<p id="P70004970270000000000000000450D2" data-uri="chapter08.xhtml#P70004970270000000000000000450D2" class="pcalibre1 pcalibre calibre2">Consider the following program:</p>
<p id="P70004970270000000000000000450D3" data-uri="chapter08.xhtml#P70004970270000000000000000450D3" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/forkprob0.c</i></p>

<pre id="P70004970270000000000000000450D4" data-uri="chapter08.xhtml#P70004970270000000000000000450D4" class="calibre9 pcalibre pcalibre1">
<code id="P70004970270000000000000000450D5" data-uri="chapter08.xhtml#P70004970270000000000000000450D5" class="calibre10 pcalibre pcalibre1">
1	int main()
2	{
3		int x = 1;
4	
5		if (Fork() == 0)
6			printf("p1: x=%d\n", ++x);
7		printf("p2: x=%d\n", --x);
8		exit(0);
9	}
</code>
</pre>
<p id="P70004970270000000000000000450D6" data-uri="chapter08.xhtml#P70004970270000000000000000450D6" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/forkprob0.c</i></p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P70004970270000000000000000450D7" data-uri="chapter08.xhtml#P70004970270000000000000000450D7">
<li id="P70004970270000000000000000450D8" data-uri="chapter08.xhtml#P70004970270000000000000000450D8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450D9" data-uri="chapter08.xhtml#P70004970270000000000000000450D9" class="pcalibre calibre3 pcalibre1">What is the output of the child process?</p></li>
<li id="P70004970270000000000000000450DA" data-uri="chapter08.xhtml#P70004970270000000000000000450DA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450DB" data-uri="chapter08.xhtml#P70004970270000000000000000450DB" class="pcalibre calibre3 pcalibre1">What is the output of the parent process?</p></li>
</ol>
</section>
</section>

<section id="P70004970270000000000000000068D5" data-uri="chapter08.xhtml#P70004970270000000000000000068D5" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000450DC" data-uri="chapter08.xhtml#P70004970270000000000000000450DC" epub:type="title"><span class="pcalibre label pcalibre1">8.4.3  </span>Reaping Child Processes</h1></header>
<p id="P70004970270000000000000000450DD" data-uri="chapter08.xhtml#P70004970270000000000000000450DD" class="pcalibre1 pcalibre calibre2">When a process terminates for any reason, the kernel does not remove it from the system immediately. Instead, the process is kept around in a terminated state until it is <i class="calibre5 pcalibre pcalibre1">reaped</i> by its parent. When the parent reaps the terminated child, the kernel passes the child's exit status to the parent and then discards the terminated process, at which point it ceases to exist. A terminated process that has not yet been reaped is called a <i class="calibre5 pcalibre pcalibre1">zombie</i>.</p>
<p id="P70004970270000000000000000450DE" data-uri="chapter08.xhtml#P70004970270000000000000000450DE" class="pcalibre1 pcalibre calibre2">When a parent process terminates, the kernel arranges for the <code id="P70004970270000000000000000450DF" data-uri="chapter08.xhtml#P70004970270000000000000000450DF" class="pcalibre1 calibre8 pcalibre">init</code> process to become the adopted parent of any orphaned children. The <code id="P70004970270000000000000000450E0" data-uri="chapter08.xhtml#P70004970270000000000000000450E0" class="pcalibre1 calibre8 pcalibre">init</code> process, which has a PID of 1, is created by the kernel during system start-up, never terminates, and is the ancestor of every process. If a parent process terminates without reaping its zombie children, then the kernel arranges for the <code id="P70004970270000000000000000450E1" data-uri="chapter08.xhtml#P70004970270000000000000000450E1" class="pcalibre1 calibre8 pcalibre">init</code> process to reap them. However, long-running programs such as shells or servers should always reap their zombie children. Even though zombies are not running, they still consume system memory resources.</p>
<p id="P70004970270000000000000000450E2" data-uri="chapter08.xhtml#P70004970270000000000000000450E2" class="pcalibre1 pcalibre calibre2">A process waits for its children to terminate or stop by calling the <code id="P70004970270000000000000000450E3" data-uri="chapter08.xhtml#P70004970270000000000000000450E3" class="pcalibre1 calibre8 pcalibre">waitpid</code> function.</p>
<pre id="P70004970270000000000000000450E4" data-uri="chapter08.xhtml#P70004970270000000000000000450E4" class="calibre9 pcalibre pcalibre1">
<code id="P70004970270000000000000000450E5" data-uri="chapter08.xhtml#P70004970270000000000000000450E5" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
pid_t waitpid(pid_t pid, int *statusp, int options);
			Returns: PID of child if OK, 0 (if WNOHANG), or -1 on error
</code>
</pre>

<aside class="sidebar pcalibre5 pcalibre" id="P70004970270000000000000000450E6" data-uri="chapter08.xhtml#P70004970270000000000000000450E6"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P70004970270000000000000000450E7" data-uri="chapter08.xhtml#P70004970270000000000000000450E7" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000068E2" title="744" data-uri="chapter08.xhtml#P70004970270000000000000000068E2" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Why are terminated children called zombies?</h1></header>
<p id="P70004970270000000000000000450E8" data-uri="chapter08.xhtml#P70004970270000000000000000450E8" class="pcalibre calibre3 pcalibre1">In folklore, a zombie is a living corpse, an entity that is half alive and half dead. A zombie process is similar in the sense that although it has already terminated, the kernel maintains some of its state until it can be reaped by the parent.</p>
</aside>
<p id="P70004970270000000000000000450E9" data-uri="chapter08.xhtml#P70004970270000000000000000450E9" class="pcalibre1 pcalibre calibre2">The <code id="P70004970270000000000000000450EA" data-uri="chapter08.xhtml#P70004970270000000000000000450EA" class="pcalibre1 calibre8 pcalibre">waitpid</code> function is complicated. By default (when <code id="P70004970270000000000000000450EB" data-uri="chapter08.xhtml#P70004970270000000000000000450EB" class="pcalibre1 calibre8 pcalibre">options = 0</code>), <code id="P70004970270000000000000000450EC" data-uri="chapter08.xhtml#P70004970270000000000000000450EC" class="pcalibre1 calibre8 pcalibre">waitpid</code> suspends execution of the calling process until a child process in its <i class="calibre5 pcalibre pcalibre1">wait set</i> terminates. If a process in the wait set has already terminated at the time of the call, then <code id="P70004970270000000000000000450ED" data-uri="chapter08.xhtml#P70004970270000000000000000450ED" class="pcalibre1 calibre8 pcalibre">waitpid</code> returns immediately. In either case, <code id="P70004970270000000000000000450EE" data-uri="chapter08.xhtml#P70004970270000000000000000450EE" class="pcalibre1 calibre8 pcalibre">waitpid</code> returns the PID of the terminated child that caused <code id="P70004970270000000000000000450EF" data-uri="chapter08.xhtml#P70004970270000000000000000450EF" class="pcalibre1 calibre8 pcalibre">waitpid</code> to return. At this point, the terminated child has been reaped and the kernel removes all traces of it from the system.</p>
<section id="P70004970270000000000000000068EB" data-uri="chapter08.xhtml#P70004970270000000000000000068EB" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000450F0" data-uri="chapter08.xhtml#P70004970270000000000000000450F0" epub:type="title">Determining the Members of the Wait Set</h1></header>
<p id="P70004970270000000000000000450F1" data-uri="chapter08.xhtml#P70004970270000000000000000450F1" class="pcalibre1 pcalibre calibre2">The members of the wait set are determined by the <code id="P70004970270000000000000000450F2" data-uri="chapter08.xhtml#P70004970270000000000000000450F2" class="pcalibre1 calibre8 pcalibre">pid</code> argument:</p>
<ul id="P70004970270000000000000000450F3" data-uri="chapter08.xhtml#P70004970270000000000000000450F3" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000450F4" data-uri="chapter08.xhtml#P70004970270000000000000000450F4" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450F5" data-uri="chapter08.xhtml#P70004970270000000000000000450F5" class="pcalibre calibre3 pcalibre1">If <code id="P70004970270000000000000000450F6" data-uri="chapter08.xhtml#P70004970270000000000000000450F6" class="pcalibre1 calibre8 pcalibre">pid &gt; 0</code>, then the wait set is the singleton child process whose process ID is equal to <code id="P70004970270000000000000000450F7" data-uri="chapter08.xhtml#P70004970270000000000000000450F7" class="pcalibre1 calibre8 pcalibre">pid</code>.</p></li>
<li id="P70004970270000000000000000450F8" data-uri="chapter08.xhtml#P70004970270000000000000000450F8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000450F9" data-uri="chapter08.xhtml#P70004970270000000000000000450F9" class="pcalibre calibre3 pcalibre1">If <code id="P70004970270000000000000000450FA" data-uri="chapter08.xhtml#P70004970270000000000000000450FA" class="pcalibre1 calibre8 pcalibre">pid = -1</code>, then the wait set consists of all of the parent's child processes.</p></li>
</ul>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000450FB" data-uri="chapter08.xhtml#P70004970270000000000000000450FB">The <code id="P70004970270000000000000000450FC" data-uri="chapter08.xhtml#P70004970270000000000000000450FC" class="pcalibre1 calibre8 pcalibre">waitpid</code> function also supports other kinds of wait sets, involving Unix process groups, which we will not discuss.</p>
</section>
<section id="P70004970270000000000000000068F9" data-uri="chapter08.xhtml#P70004970270000000000000000068F9" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000450FD" data-uri="chapter08.xhtml#P70004970270000000000000000450FD" epub:type="title">Modifying the Default Behavior</h1></header>
<p id="P70004970270000000000000000450FE" data-uri="chapter08.xhtml#P70004970270000000000000000450FE" class="pcalibre1 pcalibre calibre2">The default behavior can be modified by setting <code id="P70004970270000000000000000450FF" data-uri="chapter08.xhtml#P70004970270000000000000000450FF" class="pcalibre1 calibre8 pcalibre">options</code> to various combinations of the WNOHANG, WUNTRACED, and WCONTINUED constants:</p>
<ul class="pcalibre ul_none pcalibre1" id="P7000497027000000000000000045100" data-uri="chapter08.xhtml#P7000497027000000000000000045100">
<li id="P7000497027000000000000000045101" data-uri="chapter08.xhtml#P7000497027000000000000000045101" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045102" data-uri="chapter08.xhtml#P7000497027000000000000000045102" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WNOHANG. </span>Return immediately (with a return value of 0) if none of the child processes in the wait set has terminated yet. The default behavior suspends the calling process until a child terminates; this option is useful in those cases where you want to continue doing useful work while waiting for a child to terminate.</p></li>
<li id="P7000497027000000000000000045103" data-uri="chapter08.xhtml#P7000497027000000000000000045103" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045104" data-uri="chapter08.xhtml#P7000497027000000000000000045104" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WUNTRACED. </span>Suspend execution of the calling process until a process in the wait set becomes either terminated or stopped. Return the PID of the terminated or stopped child that caused the return. The default behavior returns only for terminated children; this option is useful when you want to check for both terminated <i class="calibre5 pcalibre pcalibre1">and</i> stopped children.</p></li>
<li id="P7000497027000000000000000045105" data-uri="chapter08.xhtml#P7000497027000000000000000045105" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045106" data-uri="chapter08.xhtml#P7000497027000000000000000045106" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WCONTINUED. </span>Suspend execution of the calling process until a running process in the wait set is terminated or until a stopped process in the wait set has been resumed by the receipt of a SIGCONT signal. (Signals are explained in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006993"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">8.5</span></a>.)</p></li>
</ul>
<p id="P7000497027000000000000000045107" data-uri="chapter08.xhtml#P7000497027000000000000000045107" class="pcalibre1 pcalibre calibre2">You can combine options by <span class="smallcaps pcalibre pcalibre1">or</span>ing them together. For example:</p>

<ul id="P7000497027000000000000000045108" data-uri="chapter08.xhtml#P7000497027000000000000000045108" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000045109" data-uri="chapter08.xhtml#P7000497027000000000000000045109" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004510A" data-uri="chapter08.xhtml#P700049702700000000000000004510A" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006908" title="745" data-uri="chapter08.xhtml#P7000497027000000000000000006908" epub:type="pagebreak"></span>WNOHANG	|	WUNTRACED: Return immediately, with a return value of 0, if none of the children in the wait set has stopped or terminated, or with a return value equal to the PID of one of the stopped or terminated children.</p></li>
</ul>
</section>
<section id="P7000497027000000000000000006909" data-uri="chapter08.xhtml#P7000497027000000000000000006909" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004510B" data-uri="chapter08.xhtml#P700049702700000000000000004510B" epub:type="title">Checking the Exit Status of a Reaped Child</h1></header>
<p id="P700049702700000000000000004510C" data-uri="chapter08.xhtml#P700049702700000000000000004510C" class="pcalibre1 pcalibre calibre2">If the <code id="P700049702700000000000000004510D" data-uri="chapter08.xhtml#P700049702700000000000000004510D" class="pcalibre1 calibre8 pcalibre">statusp</code> argument is non-NULL, then <code id="P700049702700000000000000004510E" data-uri="chapter08.xhtml#P700049702700000000000000004510E" class="pcalibre1 calibre8 pcalibre">waitpid</code> encodes status information about the child that caused the return in status, which is the value pointed to by <code id="P700049702700000000000000004510F" data-uri="chapter08.xhtml#P700049702700000000000000004510F" class="pcalibre1 calibre8 pcalibre">statusp</code>. The <code id="P7000497027000000000000000045110" data-uri="chapter08.xhtml#P7000497027000000000000000045110" class="pcalibre1 calibre8 pcalibre">wait.h</code> include file defines several macros for interpreting the <code id="P7000497027000000000000000045111" data-uri="chapter08.xhtml#P7000497027000000000000000045111" class="pcalibre1 calibre8 pcalibre">status</code> argument:</p>
<ul class="pcalibre ul_none pcalibre1" id="P7000497027000000000000000045112" data-uri="chapter08.xhtml#P7000497027000000000000000045112">
<li id="P7000497027000000000000000045113" data-uri="chapter08.xhtml#P7000497027000000000000000045113" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045114" data-uri="chapter08.xhtml#P7000497027000000000000000045114" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WIFEXITED(<code id="P7000497027000000000000000045115" data-uri="chapter08.xhtml#P7000497027000000000000000045115" class="pcalibre1 calibre8 pcalibre">status</code>). </span>Returns true if the child terminated normally, via a call to <code id="P7000497027000000000000000045116" data-uri="chapter08.xhtml#P7000497027000000000000000045116" class="pcalibre1 calibre8 pcalibre">exit</code> or a return.</p></li>
<li id="P7000497027000000000000000045117" data-uri="chapter08.xhtml#P7000497027000000000000000045117" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045118" data-uri="chapter08.xhtml#P7000497027000000000000000045118" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WEXITSTATUS(<code id="P7000497027000000000000000045119" data-uri="chapter08.xhtml#P7000497027000000000000000045119" class="pcalibre1 calibre8 pcalibre">status</code>). </span>Returns the exit status of a normally terminated child. This status is only defined if WIFEXITED() returned true.</p></li>
<li id="P700049702700000000000000004511A" data-uri="chapter08.xhtml#P700049702700000000000000004511A" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004511B" data-uri="chapter08.xhtml#P700049702700000000000000004511B" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WIFSIGNALED(<code id="P700049702700000000000000004511C" data-uri="chapter08.xhtml#P700049702700000000000000004511C" class="pcalibre1 calibre8 pcalibre">status</code>). </span>Returns true if the child process terminated because of a signal that was not caught.</p></li>
<li id="P700049702700000000000000004511D" data-uri="chapter08.xhtml#P700049702700000000000000004511D" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004511E" data-uri="chapter08.xhtml#P700049702700000000000000004511E" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WTERMSIG(<code id="P700049702700000000000000004511F" data-uri="chapter08.xhtml#P700049702700000000000000004511F" class="pcalibre1 calibre8 pcalibre">status</code>). </span>Returns the number of the signal that caused the child process to terminate. This status is only defined if WIFSIGNALED() returned true.</p></li>
<li id="P7000497027000000000000000045120" data-uri="chapter08.xhtml#P7000497027000000000000000045120" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045121" data-uri="chapter08.xhtml#P7000497027000000000000000045121" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WIFSTOPPED(<code id="P7000497027000000000000000045122" data-uri="chapter08.xhtml#P7000497027000000000000000045122" class="pcalibre1 calibre8 pcalibre">status</code>). </span>Returns true if the child that caused the return is currently stopped.</p></li>
<li id="P7000497027000000000000000045123" data-uri="chapter08.xhtml#P7000497027000000000000000045123" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045124" data-uri="chapter08.xhtml#P7000497027000000000000000045124" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WSTOPSIG(<code id="P7000497027000000000000000045125" data-uri="chapter08.xhtml#P7000497027000000000000000045125" class="pcalibre1 calibre8 pcalibre">status</code>). </span>Returns the number of the signal that caused the child to stop. This status is only defined if WIFSTOPPED() returned true.</p></li>
<li id="P7000497027000000000000000045126" data-uri="chapter08.xhtml#P7000497027000000000000000045126" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045127" data-uri="chapter08.xhtml#P7000497027000000000000000045127" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">WIFCONTINUED(<code id="P7000497027000000000000000045128" data-uri="chapter08.xhtml#P7000497027000000000000000045128" class="pcalibre1 calibre8 pcalibre">status</code>). </span>Returns true if the child process was restarted by receipt of a SIGCONT signal.</p></li></ul>
</section>
<section id="P7000497027000000000000000006928" data-uri="chapter08.xhtml#P7000497027000000000000000006928" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045129" data-uri="chapter08.xhtml#P7000497027000000000000000045129" epub:type="title">Error Conditions</h1></header>
<p id="P700049702700000000000000004512A" data-uri="chapter08.xhtml#P700049702700000000000000004512A" class="pcalibre1 pcalibre calibre2">If the calling process has no children, then <code id="P700049702700000000000000004512B" data-uri="chapter08.xhtml#P700049702700000000000000004512B" class="pcalibre1 calibre8 pcalibre">waitpid</code> returns -1 and sets <code id="P700049702700000000000000004512C" data-uri="chapter08.xhtml#P700049702700000000000000004512C" class="pcalibre1 calibre8 pcalibre">errno</code> to ECHILD. If the <code id="P700049702700000000000000004512D" data-uri="chapter08.xhtml#P700049702700000000000000004512D" class="pcalibre1 calibre8 pcalibre">waitpid</code> function was interrupted by a signal, then it returns -1 and sets <code id="P700049702700000000000000004512E" data-uri="chapter08.xhtml#P700049702700000000000000004512E" class="pcalibre1 calibre8 pcalibre">errno</code> to EINTR.</p>
<section id="P700049702700000000000000000692F" data-uri="chapter08.xhtml#P700049702700000000000000000692F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P700049702700000000000000004512F" data-uri="chapter08.xhtml#P700049702700000000000000004512F" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">8.3 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>

<p id="P7000497027000000000000000045130" data-uri="chapter08.xhtml#P7000497027000000000000000045130" class="pcalibre1 pcalibre calibre2">List all of the possible output sequences for the following program:</p>
<p id="P7000497027000000000000000045131" data-uri="chapter08.xhtml#P7000497027000000000000000045131" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/waitprob0.c</i></p>
<pre id="P7000497027000000000000000045132" data-uri="chapter08.xhtml#P7000497027000000000000000045132" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045133" data-uri="chapter08.xhtml#P7000497027000000000000000045133" class="calibre10 pcalibre pcalibre1">
1	int main()
2	{
3		if (Fork() == 0) {
4			printf("a"); fflush(stdout);
5		}
6		else {
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006935" title="746" data-uri="chapter08.xhtml#P7000497027000000000000000006935" epub:type="pagebreak"></span>7			printf("b"); fflush(stdout);
8			waitpid(-1, NULL, 0);
9		}
10		printf("c"); fflush(stdout);
11		exit(0);
12	}
</code>
</pre>
<p id="P7000497027000000000000000045134" data-uri="chapter08.xhtml#P7000497027000000000000000045134" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/waitprob0.c</i></p>
</section>
</section>

<section id="P7000497027000000000000000006937" data-uri="chapter08.xhtml#P7000497027000000000000000006937" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045135" data-uri="chapter08.xhtml#P7000497027000000000000000045135" epub:type="title">The <code id="P7000497027000000000000000045136" data-uri="chapter08.xhtml#P7000497027000000000000000045136" class="calibre55 pcalibre pcalibre1">wait</code> Function</h1></header>
<p id="P7000497027000000000000000045137" data-uri="chapter08.xhtml#P7000497027000000000000000045137" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045138" data-uri="chapter08.xhtml#P7000497027000000000000000045138" class="pcalibre1 calibre8 pcalibre">wait</code> function is a simpler version of <code id="P7000497027000000000000000045139" data-uri="chapter08.xhtml#P7000497027000000000000000045139" class="pcalibre1 calibre8 pcalibre">waitpid</code>.</p>
<pre id="P700049702700000000000000004513A" data-uri="chapter08.xhtml#P700049702700000000000000004513A" class="calibre9 pcalibre pcalibre1">
<code id="P700049702700000000000000004513B" data-uri="chapter08.xhtml#P700049702700000000000000004513B" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
pid_t wait(int *statusp);
				Returns: PID of child if OK or -1 on error
</code>
</pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004513C" data-uri="chapter08.xhtml#P700049702700000000000000004513C">Calling <code id="P700049702700000000000000004513D" data-uri="chapter08.xhtml#P700049702700000000000000004513D" class="pcalibre1 calibre8 pcalibre">wait(&amp;status)</code> is equivalent to calling <code id="P700049702700000000000000004513E" data-uri="chapter08.xhtml#P700049702700000000000000004513E" class="pcalibre1 calibre8 pcalibre">waitpid(-1, &amp;status, 0).</code></p>
</section>
<section id="P7000497027000000000000000006942" data-uri="chapter08.xhtml#P7000497027000000000000000006942" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004513F" data-uri="chapter08.xhtml#P700049702700000000000000004513F" epub:type="title">Examples of Using <code id="P7000497027000000000000000045140" data-uri="chapter08.xhtml#P7000497027000000000000000045140" class="calibre55 pcalibre pcalibre1">waitpid</code></h1></header>
<p id="P7000497027000000000000000045141" data-uri="chapter08.xhtml#P7000497027000000000000000045141" class="pcalibre1 pcalibre calibre2">Because the <code id="P7000497027000000000000000045142" data-uri="chapter08.xhtml#P7000497027000000000000000045142" class="pcalibre1 calibre8 pcalibre">waitpid</code> function is somewhat complicated, it is helpful to look at a few examples. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006957"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.18 </span></a>shows a program that uses <code id="P7000497027000000000000000045143" data-uri="chapter08.xhtml#P7000497027000000000000000045143" class="pcalibre1 calibre8 pcalibre">waitpid</code> to wait, in no particular order, for all of its <var class="calibre5 pcalibre pcalibre1">N</var> children to terminate. In line 11, the parent creates each of the <var class="calibre5 pcalibre pcalibre1">N</var> children, and in line 12, each child exits with a unique exit status.</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000045144" data-uri="chapter08.xhtml#P7000497027000000000000000045144"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000045145" data-uri="chapter08.xhtml#P7000497027000000000000000045145" epub:type="title"><span class="pcalibre label1 pcalibre1">Aside </span>Constants associated with Unix functions</h1></header>
<p id="P7000497027000000000000000045146" data-uri="chapter08.xhtml#P7000497027000000000000000045146" class="calibre13 pcalibre pcalibre1">Constants such as WNOHANG and WUNTRACED are defined by system header files. For example, WNOHANG and WUNTRACED are defined (indirectly) by the <code id="P7000497027000000000000000045147" data-uri="chapter08.xhtml#P7000497027000000000000000045147" class="pcalibre1 calibre8 pcalibre">wait.h</code> header file:</p>
<pre id="P7000497027000000000000000045148" data-uri="chapter08.xhtml#P7000497027000000000000000045148" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045149" data-uri="chapter08.xhtml#P7000497027000000000000000045149" class="calibre10 pcalibre pcalibre1">
/* Bits in the third argument to ‘waitpid’. */
#define WNOHANG 1 /* Don't block waiting. */
#define WUNTRACED 2 /* Report status of stopped children. */
</code>
</pre>
<p class="calibre13 pcalibre pcalibre1" id="P700049702700000000000000004514A" data-uri="chapter08.xhtml#P700049702700000000000000004514A">In order to use these constants, you must include the <code id="P700049702700000000000000004514B" data-uri="chapter08.xhtml#P700049702700000000000000004514B" class="pcalibre1 calibre8 pcalibre">wait.h</code> header file in your code:</p>
<pre id="P700049702700000000000000004514C" data-uri="chapter08.xhtml#P700049702700000000000000004514C" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004514D" data-uri="chapter08.xhtml#P700049702700000000000000004514D" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/wait.h&gt;
</code>
</pre>
<p class="pcalibre calibre3 pcalibre1" id="P700049702700000000000000004514E" data-uri="chapter08.xhtml#P700049702700000000000000004514E">The <code id="P700049702700000000000000004514F" data-uri="chapter08.xhtml#P700049702700000000000000004514F" class="pcalibre1 calibre8 pcalibre">man</code> page for each Unix function lists the header files to include whenever you use that function in your code. Also, in order to check return codes such as ECHILD and EINTR, you must include <code id="P7000497027000000000000000045150" data-uri="chapter08.xhtml#P7000497027000000000000000045150" class="pcalibre1 calibre8 pcalibre">errno.h.</code> To simplify our code examples, we include a single header file called <code id="P7000497027000000000000000045151" data-uri="chapter08.xhtml#P7000497027000000000000000045151" class="pcalibre1 calibre8 pcalibre">csapp.h</code> that includes the header files for all of the functions used in the book. The <code id="P7000497027000000000000000045152" data-uri="chapter08.xhtml#P7000497027000000000000000045152" class="pcalibre1 calibre8 pcalibre">csapp.h</code> header file is available online from the CS:APP Web site.</p>
</aside>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000006957" data-uri="chapter08.xhtml#P7000497027000000000000000006957">
<p id="P7000497027000000000000000045153" data-uri="chapter08.xhtml#P7000497027000000000000000045153" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006959" title="747" data-uri="chapter08.xhtml#P7000497027000000000000000006959" epub:type="pagebreak"></span><i class="calibre5 pcalibre pcalibre1">code/ecf/waitpid1.c</i></p>
<pre id="P7000497027000000000000000045154" data-uri="chapter08.xhtml#P7000497027000000000000000045154" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045155" data-uri="chapter08.xhtml#P7000497027000000000000000045155" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	#define N 2
3	
4	int main()
5	{
6		int status, i;
7		pid_t pid;
8	
9		/* Parent creates N children */
10		for (i = 0; i &lt; N; i++)
11			if ((pid = Fork()) == 0) /* Child */
12				exit(100+i);
13	
14		/* Parent reaps N children in no particular order */
15		while ((pid = waitpid(-1, &amp;status, 0)) &gt; 0) {
16			if (WIFEXITED(status))
17				printf("child %d terminated normally with exit status=%d\n",
18					pid, WEXITSTATUS(status));
19		else
20			printf("child %d terminated abnormally\n", pid);
21		}
22	
23		/* The only normal termination is if there are no more children */
24		if (errno != ECHILD)
25			unix_error("waitpid error");
26	
27		exit(0);
28	}
</code>
</pre>
<p id="P7000497027000000000000000045156" data-uri="chapter08.xhtml#P7000497027000000000000000045156" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/waitpid1.c</i></p>
<figcaption id="P7000497027000000000000000045157" data-uri="chapter08.xhtml#P7000497027000000000000000045157" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045158" data-uri="chapter08.xhtml#P7000497027000000000000000045158" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">8.18 </span>Using the <code id="P7000497027000000000000000045159" data-uri="chapter08.xhtml#P7000497027000000000000000045159" class="pcalibre1 calibre8 pcalibre">waitpid</code> function to reap zombie children in no particular order.</h1></header>
</figcaption>
</figure>
<p id="P700049702700000000000000004515A" data-uri="chapter08.xhtml#P700049702700000000000000004515A" class="pcalibre1 pcalibre calibre2">---------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/waitpid1.c</i></p>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004515B" data-uri="chapter08.xhtml#P700049702700000000000000004515B">Before moving on, make sure you understand why line 12 is executed by each of the children, but not the parent.</p>
<p id="P700049702700000000000000004515C" data-uri="chapter08.xhtml#P700049702700000000000000004515C" class="pcalibre1 pcalibre calibre2">In line 15, the parent waits for all of its children to terminate by using <code id="P700049702700000000000000004515D" data-uri="chapter08.xhtml#P700049702700000000000000004515D" class="pcalibre1 calibre8 pcalibre">waitpid</code> as the test condition of a while loop. Because the first argument is -1, the call to <code id="P700049702700000000000000004515E" data-uri="chapter08.xhtml#P700049702700000000000000004515E" class="pcalibre1 calibre8 pcalibre">waitpid</code> blocks until an arbitrary child has terminated. As each child terminates, the call to <code id="P700049702700000000000000004515F" data-uri="chapter08.xhtml#P700049702700000000000000004515F" class="pcalibre1 calibre8 pcalibre">waitpid</code> returns with the nonzero PID of that child. Line 16 checks the exit status of the child. If the child terminated normally—in this case, by calling the <code id="P7000497027000000000000000045160" data-uri="chapter08.xhtml#P7000497027000000000000000045160" class="pcalibre1 calibre8 pcalibre">exit</code> function—then the parent extracts the exit status and prints it on <code id="P7000497027000000000000000045161" data-uri="chapter08.xhtml#P7000497027000000000000000045161" class="pcalibre1 calibre8 pcalibre">stdout</code>.</p>
<p id="P7000497027000000000000000045162" data-uri="chapter08.xhtml#P7000497027000000000000000045162" class="pcalibre1 pcalibre calibre2">When all of the children have been reaped, the next call to <code id="P7000497027000000000000000045163" data-uri="chapter08.xhtml#P7000497027000000000000000045163" class="pcalibre1 calibre8 pcalibre">waitpid</code> returns -1 and sets <code id="P7000497027000000000000000045164" data-uri="chapter08.xhtml#P7000497027000000000000000045164" class="pcalibre1 calibre8 pcalibre">errno</code> to ECHILD. Line 24 checks that the <code id="P7000497027000000000000000045165" data-uri="chapter08.xhtml#P7000497027000000000000000045165" class="pcalibre1 calibre8 pcalibre">waitpid</code> function terminated normally, and prints an error message otherwise. When we run the program on our Linux system, it produces the following output:</p>
<pre id="P7000497027000000000000000045166" data-uri="chapter08.xhtml#P7000497027000000000000000045166" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045167" data-uri="chapter08.xhtml#P7000497027000000000000000045167" class="calibre10 pcalibre pcalibre1">
<span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000696D" title="748" data-uri="chapter08.xhtml#P700049702700000000000000000696D" epub:type="pagebreak"></span>linux&gt; <i class="calibre5 pcalibre pcalibre1">./waitpid1</i>
child 22966 terminated normally with exit status=100
child 22967 terminated normally with exit status=101
</code>
</pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045168" data-uri="chapter08.xhtml#P7000497027000000000000000045168">Notice that the program reaps its children in no particular order. The order that they were reaped is a property of this specific computer system. On another system, or even another execution on the same system, the two children might have been reaped in the opposite order. This is an example of the <i class="calibre5 pcalibre pcalibre1">nondeterministic</i> behavior that can make reasoning about concurrency so difficult. Either of the two possible outcomes is equally correct, and as a programmer you may <i class="calibre5 pcalibre pcalibre1">never</i> assume that one outcome will always occur, no matter how unlikely the other outcome appears to be. The only correct assumption is that each possible outcome is equally likely.</p>
<p id="P7000497027000000000000000045169" data-uri="chapter08.xhtml#P7000497027000000000000000045169" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000697D"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.19 </span></a>shows a simple change that eliminates this nondeterminism in the output order by reaping the children in the same order that they were created by the parent. In line 11, the parent stores the PIDs of its children in order and then waits for each child in this same order by calling <code id="P700049702700000000000000004516A" data-uri="chapter08.xhtml#P700049702700000000000000004516A" class="pcalibre1 calibre8 pcalibre">waitpid</code> with the appropriate PID in the first argument.</p>

<section id="P7000497027000000000000000006971" data-uri="chapter08.xhtml#P7000497027000000000000000006971" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P700049702700000000000000004516B" data-uri="chapter08.xhtml#P700049702700000000000000004516B" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">8.4 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<p id="P700049702700000000000000004516C" data-uri="chapter08.xhtml#P700049702700000000000000004516C" class="pcalibre1 pcalibre calibre2">Consider the following program:</p>
<p id="P700049702700000000000000004516D" data-uri="chapter08.xhtml#P700049702700000000000000004516D" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/waitprob1.c</i></p>
<pre id="P700049702700000000000000004516E" data-uri="chapter08.xhtml#P700049702700000000000000004516E" class="calibre9 pcalibre pcalibre1">
<code id="P700049702700000000000000004516F" data-uri="chapter08.xhtml#P700049702700000000000000004516F" class="calibre10 pcalibre pcalibre1">
1	int main()
2	{
3		int status;
4		pid_t pid;
5	
6		printf("Hello\n");
7		pid = Fork();
8		printf("%d\n", !pid);
9		if (pid != 0) {
10			if (waitpid(-1, &amp;status, 0) &gt; 0) {
11				if (WIFEXITED(status) != 0)
12					printf("%d\n", WEXITSTATUS(status));
13				}
14		}
15		printf("Bye\n");
16		exit(2);
17	}
</code>
</pre>
<p id="P7000497027000000000000000045170" data-uri="chapter08.xhtml#P7000497027000000000000000045170" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/waitprob1.c</i></p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P7000497027000000000000000045171" data-uri="chapter08.xhtml#P7000497027000000000000000045171">
<li id="P7000497027000000000000000045172" data-uri="chapter08.xhtml#P7000497027000000000000000045172" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045173" data-uri="chapter08.xhtml#P7000497027000000000000000045173" class="pcalibre calibre3 pcalibre1">How many output lines does this program generate?</p></li>
<li id="P7000497027000000000000000045174" data-uri="chapter08.xhtml#P7000497027000000000000000045174" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000045175" data-uri="chapter08.xhtml#P7000497027000000000000000045175" class="pcalibre calibre3 pcalibre1">What is one possible ordering of these output lines?</p></li>
</ol>
</section>

<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000697D" data-uri="chapter08.xhtml#P700049702700000000000000000697D">

<p id="P7000497027000000000000000045176" data-uri="chapter08.xhtml#P7000497027000000000000000045176" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000697F" title="749" data-uri="chapter08.xhtml#P700049702700000000000000000697F" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/waitpid2.c</i></p>
<pre id="P7000497027000000000000000045177" data-uri="chapter08.xhtml#P7000497027000000000000000045177" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045178" data-uri="chapter08.xhtml#P7000497027000000000000000045178" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	#define N 2
3
4	int main()
5	{
6		int status, i;
7		pid_t pid[N], retpid;
8	
9		/* Parent creates N children */
10		for (i = 0; i &lt; N; i++)
11			if ((pid[i] = Fork()) == 0) /* Child */
12				exit(100+i);
13	
14		/* Parent reaps N children in order */
15		i = 0;
16		while ((retpid = waitpid(pid[i++], &amp;status, 0)) &gt; 0) {
17			if (WIFEXITED(status))
18				printf("child %d terminated normally with exit status=%d\n",
19					retpid, WEXITSTATUS(status));
20			else
21				printf("child %d terminated abnormally\n", retpid);
22		}
23	
24		/* The only normal termination is if there are no more children */
25		if (errno != ECHILD)
26		unix_error("waitpid error");
27	
28		exit(0);
29	}
</code>
</pre>
<p id="P7000497027000000000000000045179" data-uri="chapter08.xhtml#P7000497027000000000000000045179" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/waitpid2.c</i></p>

<figcaption id="P700049702700000000000000004517A" data-uri="chapter08.xhtml#P700049702700000000000000004517A" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004517B" data-uri="chapter08.xhtml#P700049702700000000000000004517B" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">8.19 </span>Using <code id="P700049702700000000000000004517C" data-uri="chapter08.xhtml#P700049702700000000000000004517C" class="pcalibre1 calibre8 pcalibre">waitpid</code> to reap zombie children in the order they were created.</h1></header>
</figcaption>
</figure>
</section>
</section>
<section id="P7000497027000000000000000006986" data-uri="chapter08.xhtml#P7000497027000000000000000006986" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004517D" data-uri="chapter08.xhtml#P700049702700000000000000004517D" epub:type="title"><span class="pcalibre label pcalibre1">8.4.4  </span>Putting Processes to Sleep</h1></header>
<p id="P700049702700000000000000004517E" data-uri="chapter08.xhtml#P700049702700000000000000004517E" class="pcalibre1 pcalibre calibre2">The sleep function suspends a process for a specified period of time.</p>
<pre id="P700049702700000000000000004517F" data-uri="chapter08.xhtml#P700049702700000000000000004517F" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045180" data-uri="chapter08.xhtml#P7000497027000000000000000045180" class="calibre10 pcalibre pcalibre1">
#include &lt;unistd.h&gt;
unsigned int sleep(unsigned int secs);
					Returns: seconds left to sleep
</code>
</pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045181" data-uri="chapter08.xhtml#P7000497027000000000000000045181"><code id="P7000497027000000000000000045182" data-uri="chapter08.xhtml#P7000497027000000000000000045182" class="pcalibre1 calibre8 pcalibre">Sleep</code> returns zero if the requested amount of time has elapsed, and the number of seconds still left to sleep otherwise. The latter case is possible if the <code id="P7000497027000000000000000045183" data-uri="chapter08.xhtml#P7000497027000000000000000045183" class="pcalibre1 calibre8 pcalibre">sleep</code> function <span class="pcalibre pagebreak pcalibre1" id="P700049702700000000000000000698E" title="750" data-uri="chapter08.xhtml#P700049702700000000000000000698E" epub:type="pagebreak"></span>returns prematurely because it was interrupted by a <i class="calibre5 pcalibre pcalibre1">signal.</i> We will discuss signals in detail in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006993"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">8.5</span></a>.</p>
<p id="P7000497027000000000000000045184" data-uri="chapter08.xhtml#P7000497027000000000000000045184" class="pcalibre1 pcalibre calibre2">Another function that we will find useful is the <code id="P7000497027000000000000000045185" data-uri="chapter08.xhtml#P7000497027000000000000000045185" class="pcalibre1 calibre8 pcalibre">pause</code> function, which puts the calling function to sleep until a signal is received by the process.</p>
<pre id="P7000497027000000000000000045186" data-uri="chapter08.xhtml#P7000497027000000000000000045186" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045187" data-uri="chapter08.xhtml#P7000497027000000000000000045187" class="calibre10 pcalibre pcalibre1">
#include &lt;unistd.h&gt;
int pause(void);
Always returns -1
</code>
</pre>

<section id="P7000497027000000000000000006993" data-uri="chapter08.xhtml#P7000497027000000000000000006993" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045188" data-uri="chapter08.xhtml#P7000497027000000000000000045188" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">8.5 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<p id="P7000497027000000000000000045189" data-uri="chapter08.xhtml#P7000497027000000000000000045189" class="pcalibre1 pcalibre calibre2">Write a wrapper function for <code id="P700049702700000000000000004518A" data-uri="chapter08.xhtml#P700049702700000000000000004518A" class="pcalibre1 calibre8 pcalibre">sleep</code>, called <code id="P700049702700000000000000004518B" data-uri="chapter08.xhtml#P700049702700000000000000004518B" class="pcalibre1 calibre8 pcalibre">snooze</code>, with the following interface:</p>
<pre id="P700049702700000000000000004518C" data-uri="chapter08.xhtml#P700049702700000000000000004518C" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004518D" data-uri="chapter08.xhtml#P700049702700000000000000004518D" class="calibre10 pcalibre pcalibre1">unsigned int snooze(unsigned int secs);</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004518E" data-uri="chapter08.xhtml#P700049702700000000000000004518E">The <code id="P700049702700000000000000004518F" data-uri="chapter08.xhtml#P700049702700000000000000004518F" class="pcalibre1 calibre8 pcalibre">snooze</code> function behaves exactly as the <code id="P7000497027000000000000000045190" data-uri="chapter08.xhtml#P7000497027000000000000000045190" class="pcalibre1 calibre8 pcalibre">sleep</code> function, except that it prints a message describing how long the process actually slept:</p>
<pre id="P7000497027000000000000000045191" data-uri="chapter08.xhtml#P7000497027000000000000000045191" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045192" data-uri="chapter08.xhtml#P7000497027000000000000000045192" class="calibre10 pcalibre pcalibre1">Slept for 4 of 5 secs.</code></pre>
</section>
</section>
<section id="P700049702700000000000000000699F" data-uri="chapter08.xhtml#P700049702700000000000000000699F" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045193" data-uri="chapter08.xhtml#P7000497027000000000000000045193" epub:type="title"><span class="pcalibre label pcalibre1">8.4.5  </span>Loading and Running Programs</h1></header>
<p id="P7000497027000000000000000045194" data-uri="chapter08.xhtml#P7000497027000000000000000045194" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000045195" data-uri="chapter08.xhtml#P7000497027000000000000000045195" class="pcalibre1 calibre8 pcalibre">execve</code> function loads and runs a new program in the context of the current process.</p>
<pre id="P7000497027000000000000000045196" data-uri="chapter08.xhtml#P7000497027000000000000000045196" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045197" data-uri="chapter08.xhtml#P7000497027000000000000000045197" class="calibre10 pcalibre pcalibre1">
#include &lt;unistd.h&gt;
int execve(const char *filename, const char *argv[],
const char *envp[]);
Does not return if OK; returns -1 on error
</code>
</pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045198" data-uri="chapter08.xhtml#P7000497027000000000000000045198">The <code id="P7000497027000000000000000045199" data-uri="chapter08.xhtml#P7000497027000000000000000045199" class="pcalibre1 calibre8 pcalibre">execve</code> function loads and runs the executable object file <code id="P700049702700000000000000004519A" data-uri="chapter08.xhtml#P700049702700000000000000004519A" class="pcalibre1 calibre8 pcalibre">filename</code> with the argument list <code id="P700049702700000000000000004519B" data-uri="chapter08.xhtml#P700049702700000000000000004519B" class="pcalibre1 calibre8 pcalibre">argv</code> and the environment variable list <code id="P700049702700000000000000004519C" data-uri="chapter08.xhtml#P700049702700000000000000004519C" class="pcalibre1 calibre8 pcalibre">envp. Execve</code> returns to the calling program only if there is an error, such as not being able to find <code id="P700049702700000000000000004519D" data-uri="chapter08.xhtml#P700049702700000000000000004519D" class="pcalibre1 calibre8 pcalibre">filename</code>. So unlike <code id="P700049702700000000000000004519E" data-uri="chapter08.xhtml#P700049702700000000000000004519E" class="pcalibre1 calibre8 pcalibre">fork</code>, which is called once but returns twice, <code id="P700049702700000000000000004519F" data-uri="chapter08.xhtml#P700049702700000000000000004519F" class="pcalibre1 calibre8 pcalibre">execve</code> is called once and never returns.</p>
<p id="P70004970270000000000000000451A0" data-uri="chapter08.xhtml#P70004970270000000000000000451A0" class="pcalibre1 pcalibre calibre2">The argument list is represented by the data structure shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000069B1"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.20</span></a>. The <code id="P70004970270000000000000000451A1" data-uri="chapter08.xhtml#P70004970270000000000000000451A1" class="pcalibre1 calibre8 pcalibre">argv</code> variable points to a null-terminated array of pointers, each of which points to an argument string. By convention, <code id="P70004970270000000000000000451A2" data-uri="chapter08.xhtml#P70004970270000000000000000451A2" class="pcalibre1 calibre8 pcalibre">argv [0]</code> is the name of the executable object file. The list of environment variables is represented by a similar data structure, shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000069B6"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.21</span></a>. The <code id="P70004970270000000000000000451A3" data-uri="chapter08.xhtml#P70004970270000000000000000451A3" class="pcalibre1 calibre8 pcalibre">envp</code> variable points to a null-terminated array of pointers to environment variable strings, each of which is a name-value pair of the form <i class="calibre5 pcalibre pcalibre1">name=value.</i></p>

<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000069B1" data-uri="chapter08.xhtml#P70004970270000000000000000069B1">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000069B2" title="751" data-uri="chapter08.xhtml#P70004970270000000000000000069B2" epub:type="pagebreak"></span><img alt="A diagram shows the organization of an argument list." id="P70004970270000000000000000451A4" data-uri="P700049702700000000000000000B76E" src="../images/p751-1.png" class="pcalibre1 pcalibre calibre251"/>
<figcaption id="P70004970270000000000000000451A5" data-uri="chapter08.xhtml#P70004970270000000000000000451A5" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000451A6" data-uri="chapter08.xhtml#P70004970270000000000000000451A6" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">8.20 </span>Organization of an argument list.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000254CC" data-uri="chapter08.xhtml#P70004970270000000000000000254CC">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000451A7" data-uri="chapter08.xhtml#P70004970270000000000000000451A7" class="pcalibre1 pcalibre calibre2">A stack titled argv[] has the following sections from top to bottom:</p>
<ul id="P70004970270000000000000000451A8" data-uri="chapter08.xhtml#P70004970270000000000000000451A8" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000451A9" data-uri="chapter08.xhtml#P70004970270000000000000000451A9" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451AA" data-uri="chapter08.xhtml#P70004970270000000000000000451AA" class="pcalibre calibre3 pcalibre1">argv[0] (input argv, output “ls”)</p></li>
<li id="P70004970270000000000000000451AB" data-uri="chapter08.xhtml#P70004970270000000000000000451AB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451AC" data-uri="chapter08.xhtml#P70004970270000000000000000451AC" class="pcalibre calibre3 pcalibre1">argv[1] (output “-lt”)</p></li>
<li id="P70004970270000000000000000451AD" data-uri="chapter08.xhtml#P70004970270000000000000000451AD" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451AE" data-uri="chapter08.xhtml#P70004970270000000000000000451AE" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P70004970270000000000000000451AF" data-uri="chapter08.xhtml#P70004970270000000000000000451AF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451B0" data-uri="chapter08.xhtml#P70004970270000000000000000451B0" class="pcalibre calibre3 pcalibre1">Argv[argc-1] (output “/user/include”)</p></li>
<li id="P70004970270000000000000000451B1" data-uri="chapter08.xhtml#P70004970270000000000000000451B1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451B2" data-uri="chapter08.xhtml#P70004970270000000000000000451B2" class="pcalibre calibre3 pcalibre1">NULL</p></li>
</ul>
</details>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000069B6" data-uri="chapter08.xhtml#P70004970270000000000000000069B6">
<img alt="A diagram shows the organization of an environment variable list." id="P70004970270000000000000000451B3" data-uri="P700049702700000000000000000B76F" src="../images/p751-2.png" class="calibre252 pcalibre pcalibre1"/>
<figcaption id="P70004970270000000000000000451B4" data-uri="chapter08.xhtml#P70004970270000000000000000451B4" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000451B5" data-uri="chapter08.xhtml#P70004970270000000000000000451B5" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">8.21 </span>Organization of an environment variable list.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P70004970270000000000000000254DC" data-uri="chapter08.xhtml#P70004970270000000000000000254DC">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000451B6" data-uri="chapter08.xhtml#P70004970270000000000000000451B6" class="pcalibre1 pcalibre calibre2">A stack titled envp[] has the following sections from top to bottom:</p>
<ul id="P70004970270000000000000000451B7" data-uri="chapter08.xhtml#P70004970270000000000000000451B7" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000451B8" data-uri="chapter08.xhtml#P70004970270000000000000000451B8" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451B9" data-uri="chapter08.xhtml#P70004970270000000000000000451B9" class="pcalibre calibre3 pcalibre1">envp[0] (input envp, output “PWD=/usr/droh”)</p></li>
<li id="P70004970270000000000000000451BA" data-uri="chapter08.xhtml#P70004970270000000000000000451BA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451BB" data-uri="chapter08.xhtml#P70004970270000000000000000451BB" class="pcalibre calibre3 pcalibre1">envp[1] (output “PRINTER=iron”)</p></li>
<li id="P70004970270000000000000000451BC" data-uri="chapter08.xhtml#P70004970270000000000000000451BC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451BD" data-uri="chapter08.xhtml#P70004970270000000000000000451BD" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P70004970270000000000000000451BE" data-uri="chapter08.xhtml#P70004970270000000000000000451BE" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451BF" data-uri="chapter08.xhtml#P70004970270000000000000000451BF" class="pcalibre calibre3 pcalibre1">envp[n-1] (output “USER=droh”)</p></li>
<li id="P70004970270000000000000000451C0" data-uri="chapter08.xhtml#P70004970270000000000000000451C0" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451C1" data-uri="chapter08.xhtml#P70004970270000000000000000451C1" class="pcalibre calibre3 pcalibre1">NULL</p></li>
</ul>
</details>
</figcaption>
</figure>
<p id="P70004970270000000000000000451C2" data-uri="chapter08.xhtml#P70004970270000000000000000451C2" class="pcalibre1 pcalibre calibre2">After <code id="P70004970270000000000000000451C3" data-uri="chapter08.xhtml#P70004970270000000000000000451C3" class="pcalibre1 calibre8 pcalibre">execve</code> loads <code id="P70004970270000000000000000451C4" data-uri="chapter08.xhtml#P70004970270000000000000000451C4" class="pcalibre1 calibre8 pcalibre">filename</code>, it calls the start-up code described in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006385.xhtml#P7000497027000000000000000006385"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">7.9</span></a>. The start-up code sets up the stack and passes control to the main routine of the new program, which has a prototype of the form</p>
<pre id="P70004970270000000000000000451C5" data-uri="chapter08.xhtml#P70004970270000000000000000451C5" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000451C6" data-uri="chapter08.xhtml#P70004970270000000000000000451C6" class="calibre10 pcalibre pcalibre1">int main(int arge, char **argv, char **envp);</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000451C7" data-uri="chapter08.xhtml#P70004970270000000000000000451C7">or equivalently,</p>
<pre id="P70004970270000000000000000451C8" data-uri="chapter08.xhtml#P70004970270000000000000000451C8" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000451C9" data-uri="chapter08.xhtml#P70004970270000000000000000451C9" class="calibre10 pcalibre pcalibre1">int main(int arge, char *argv[], char *envp[]);</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000451CA" data-uri="chapter08.xhtml#P70004970270000000000000000451CA">When <code id="P70004970270000000000000000451CB" data-uri="chapter08.xhtml#P70004970270000000000000000451CB" class="pcalibre1 calibre8 pcalibre">main</code> begins executing, the user stack has the organization shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000069D2"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.22</span></a>. Let's work our way from the bottom of the stack (the highest address) to the top (the lowest address). First are the argument and environment strings. These are followed further up the stack by a null-terminated array of pointers, each of which points to an environment variable string on the stack. The global variable <code id="P70004970270000000000000000451CC" data-uri="chapter08.xhtml#P70004970270000000000000000451CC" class="pcalibre1 calibre8 pcalibre">environ</code> points to the first of these pointers, <code id="P70004970270000000000000000451CD" data-uri="chapter08.xhtml#P70004970270000000000000000451CD" class="pcalibre1 calibre8 pcalibre">envp [0]</code>. The environment array is followed by the null-terminated <code id="P70004970270000000000000000451CE" data-uri="chapter08.xhtml#P70004970270000000000000000451CE" class="pcalibre1 calibre8 pcalibre">argv []</code> array, with each element pointing to an argument string on the stack. At the top of the stack is the stack frame for the system start-up function, <code id="P70004970270000000000000000451CF" data-uri="chapter08.xhtml#P70004970270000000000000000451CF" class="pcalibre1 calibre8 pcalibre">libc_start_main</code> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006385.xhtml#P7000497027000000000000000006385"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">7.9</span></a>).</p>
<p id="P70004970270000000000000000451D0" data-uri="chapter08.xhtml#P70004970270000000000000000451D0" class="pcalibre1 pcalibre calibre2">There are three arguments to function main, each stored in a register according to the x86-64 stack discipline: (1) <code id="P70004970270000000000000000451D1" data-uri="chapter08.xhtml#P70004970270000000000000000451D1" class="pcalibre1 calibre8 pcalibre">argc</code>, which gives the number of non-null pointers in the <code id="P70004970270000000000000000451D2" data-uri="chapter08.xhtml#P70004970270000000000000000451D2" class="pcalibre1 calibre8 pcalibre">argv []</code> array; (2) <code id="P70004970270000000000000000451D3" data-uri="chapter08.xhtml#P70004970270000000000000000451D3" class="pcalibre1 calibre8 pcalibre">argv</code>, which points to the first entry in the <code id="P70004970270000000000000000451D4" data-uri="chapter08.xhtml#P70004970270000000000000000451D4" class="pcalibre1 calibre8 pcalibre">argv []</code> array; and (3) <code id="P70004970270000000000000000451D5" data-uri="chapter08.xhtml#P70004970270000000000000000451D5" class="pcalibre1 calibre8 pcalibre">envp</code>, which points to the first entry in the <code id="P70004970270000000000000000451D6" data-uri="chapter08.xhtml#P70004970270000000000000000451D6" class="pcalibre1 calibre8 pcalibre">envp []</code> array.</p>
<p id="P70004970270000000000000000451D7" data-uri="chapter08.xhtml#P70004970270000000000000000451D7" class="pcalibre1 pcalibre calibre2">Linux provides several functions for manipulating the environment array:</p>
<pre id="P70004970270000000000000000451D8" data-uri="chapter08.xhtml#P70004970270000000000000000451D8" class="calibre9 pcalibre pcalibre1">
<code id="P70004970270000000000000000451D9" data-uri="chapter08.xhtml#P70004970270000000000000000451D9" class="calibre10 pcalibre pcalibre1">
#include &lt;stdlib.h&gt;
char *getenv(const char *name);
				Returns: pointer to name if it exists, NULL if no match
</code>
</pre>

<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000069D2" data-uri="chapter08.xhtml#P70004970270000000000000000069D2">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000069D3" title="752" data-uri="chapter08.xhtml#P70004970270000000000000000069D3" epub:type="pagebreak"></span><img alt="A diagram shows the typical organization of the user stack." id="P70004970270000000000000000451DA" data-uri="P700049702700000000000000000B770" src="../images/p752-1.png" class="pcalibre1 calibre253 pcalibre"/>
<figcaption id="P70004970270000000000000000451DB" data-uri="chapter08.xhtml#P70004970270000000000000000451DB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000451DC" data-uri="chapter08.xhtml#P70004970270000000000000000451DC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">8.22 </span>Typical organization of the user stack when a new program starts.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000025504" data-uri="chapter08.xhtml#P7000497027000000000000000025504">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000451DD" data-uri="chapter08.xhtml#P70004970270000000000000000451DD" class="pcalibre1 pcalibre calibre2">The sections of the stack are summarized below from bottom to top:</p>
<ul id="P70004970270000000000000000451DE" data-uri="chapter08.xhtml#P70004970270000000000000000451DE" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000451DF" data-uri="chapter08.xhtml#P70004970270000000000000000451DF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451E0" data-uri="chapter08.xhtml#P70004970270000000000000000451E0" class="pcalibre calibre3 pcalibre1">Future stack frame for main, below top of stack</p></li>
<li id="P70004970270000000000000000451E1" data-uri="chapter08.xhtml#P70004970270000000000000000451E1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451E2" data-uri="chapter08.xhtml#P70004970270000000000000000451E2" class="pcalibre calibre3 pcalibre1">Stack frame for libc_start_main, labeled argc (in %rdi), above top of stack</p></li>
<li id="P70004970270000000000000000451E3" data-uri="chapter08.xhtml#P70004970270000000000000000451E3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451E4" data-uri="chapter08.xhtml#P70004970270000000000000000451E4" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P70004970270000000000000000451E5" data-uri="chapter08.xhtml#P70004970270000000000000000451E5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451E6" data-uri="chapter08.xhtml#P70004970270000000000000000451E6" class="pcalibre calibre3 pcalibre1">Argv[0], arrow from argv (in %rsi) (arrow to above gap near bottom of stack)</p></li>
<li id="P70004970270000000000000000451E7" data-uri="chapter08.xhtml#P70004970270000000000000000451E7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451E8" data-uri="chapter08.xhtml#P70004970270000000000000000451E8" class="pcalibre calibre3 pcalibre1">…</p></li>
<li id="P70004970270000000000000000451E9" data-uri="chapter08.xhtml#P70004970270000000000000000451E9" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451EA" data-uri="chapter08.xhtml#P70004970270000000000000000451EA" class="pcalibre calibre3 pcalibre1">argv[argc-1]</p></li>
<li id="P70004970270000000000000000451EB" data-uri="chapter08.xhtml#P70004970270000000000000000451EB" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451EC" data-uri="chapter08.xhtml#P70004970270000000000000000451EC" class="pcalibre calibre3 pcalibre1">argv[argc] = NULL</p></li>
<li id="P70004970270000000000000000451ED" data-uri="chapter08.xhtml#P70004970270000000000000000451ED" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451EE" data-uri="chapter08.xhtml#P70004970270000000000000000451EE" class="pcalibre calibre3 pcalibre1">envp[0], arrow from environ (global var) and envp (in %rdx), and arrow to bottom of stack</p></li>
<li id="P70004970270000000000000000451EF" data-uri="chapter08.xhtml#P70004970270000000000000000451EF" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451F0" data-uri="chapter08.xhtml#P70004970270000000000000000451F0" class="pcalibre calibre3 pcalibre1">…</p></li>
<li id="P70004970270000000000000000451F1" data-uri="chapter08.xhtml#P70004970270000000000000000451F1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451F2" data-uri="chapter08.xhtml#P70004970270000000000000000451F2" class="pcalibre calibre3 pcalibre1">envp[n-1]</p></li>
<li id="P70004970270000000000000000451F3" data-uri="chapter08.xhtml#P70004970270000000000000000451F3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451F4" data-uri="chapter08.xhtml#P70004970270000000000000000451F4" class="pcalibre calibre3 pcalibre1">envp[n] == NULL</p></li>
<li id="P70004970270000000000000000451F5" data-uri="chapter08.xhtml#P70004970270000000000000000451F5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451F6" data-uri="chapter08.xhtml#P70004970270000000000000000451F6" class="pcalibre calibre3 pcalibre1">Gap</p></li>
<li id="P70004970270000000000000000451F7" data-uri="chapter08.xhtml#P70004970270000000000000000451F7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451F8" data-uri="chapter08.xhtml#P70004970270000000000000000451F8" class="pcalibre calibre3 pcalibre1">Null-terminated command-line arg strings (arrow from argv[0])</p></li>
<li id="P70004970270000000000000000451F9" data-uri="chapter08.xhtml#P70004970270000000000000000451F9" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000451FA" data-uri="chapter08.xhtml#P70004970270000000000000000451FA" class="pcalibre calibre3 pcalibre1">Null-terminated environment variable strings to bottom of stack (arrow from envp[0])</p></li>
</ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000451FB" data-uri="chapter08.xhtml#P70004970270000000000000000451FB">The <code id="P70004970270000000000000000451FC" data-uri="chapter08.xhtml#P70004970270000000000000000451FC" class="pcalibre1 calibre8 pcalibre">getenv</code> function searches the environment array for a string <code id="P70004970270000000000000000451FD" data-uri="chapter08.xhtml#P70004970270000000000000000451FD" class="pcalibre1 calibre8 pcalibre">name=<i class="calibre5 pcalibre pcalibre1">value.</i></code> If found, it returns a pointer to <i class="calibre5 pcalibre pcalibre1">value;</i> otherwise, it returns <code id="P70004970270000000000000000451FE" data-uri="chapter08.xhtml#P70004970270000000000000000451FE" class="pcalibre1 calibre8 pcalibre">NULL</code>.</p>
<pre id="P70004970270000000000000000451FF" data-uri="chapter08.xhtml#P70004970270000000000000000451FF" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045200" data-uri="chapter08.xhtml#P7000497027000000000000000045200" class="calibre10 pcalibre pcalibre1">
#include &lt;stdlib.h&gt;
int setenv(const char *name, const char *newvalue, int overwrite);
					Returns: 0 on success, -1 on error
void unsetenv(const char *name);
							 Returns: nothing
</code>
</pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000045201" data-uri="chapter08.xhtml#P7000497027000000000000000045201">If the environment array contains a string of the form <code id="P7000497027000000000000000045202" data-uri="chapter08.xhtml#P7000497027000000000000000045202" class="pcalibre1 calibre8 pcalibre">name=<i class="calibre5 pcalibre pcalibre1">oldvalue</i></code>, then <code id="P7000497027000000000000000045203" data-uri="chapter08.xhtml#P7000497027000000000000000045203" class="pcalibre1 calibre8 pcalibre">unsetenv</code> deletes it and <code id="P7000497027000000000000000045204" data-uri="chapter08.xhtml#P7000497027000000000000000045204" class="pcalibre1 calibre8 pcalibre">setenv</code> replaces <i class="calibre5 pcalibre pcalibre1">oldvalue</i> with <code id="P7000497027000000000000000045205" data-uri="chapter08.xhtml#P7000497027000000000000000045205" class="pcalibre1 calibre8 pcalibre">newvalue</code>, but only if <code id="P7000497027000000000000000045206" data-uri="chapter08.xhtml#P7000497027000000000000000045206" class="pcalibre1 calibre8 pcalibre">overwrite</code> is nonzero. If name does not exist, then <code id="P7000497027000000000000000045207" data-uri="chapter08.xhtml#P7000497027000000000000000045207" class="pcalibre1 calibre8 pcalibre">setenv</code> adds <code id="P7000497027000000000000000045208" data-uri="chapter08.xhtml#P7000497027000000000000000045208" class="pcalibre1 calibre8 pcalibre">name=newvalue</code> to the array.</p>
<section id="P70004970270000000000000000069E5" data-uri="chapter08.xhtml#P70004970270000000000000000069E5" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000045209" data-uri="chapter08.xhtml#P7000497027000000000000000045209" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">8.6 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000006F9A.xhtml#P7000497027000000000000000006FBC">797</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P700049702700000000000000004520A" data-uri="chapter08.xhtml#P700049702700000000000000004520A">
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004520B" data-uri="chapter08.xhtml#P700049702700000000000000004520B"><div class="edition pcalibre pcalibre1" id="P700049702700000000000000004520C" data-uri="chapter08.xhtml#P700049702700000000000000004520C"><p id="P700049702700000000000000004520D" data-uri="chapter08.xhtml#P700049702700000000000000004520D" class="pcalibre calibre3 pcalibre1">Write a program called <code id="P700049702700000000000000004520E" data-uri="chapter08.xhtml#P700049702700000000000000004520E" class="pcalibre1 calibre8 pcalibre">myecho</code> that prints its command-line arguments and environment variables. For example:</p></div>
<pre id="P700049702700000000000000004520F" data-uri="chapter08.xhtml#P700049702700000000000000004520F" class="calibre9 pcalibre pcalibre1">
<code id="P7000497027000000000000000045210" data-uri="chapter08.xhtml#P7000497027000000000000000045210" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">./myecho argl arg2</i>
Command-ine arguments:
argv[ 0]: myecho
argv[ 1]: arg1
argv[ 2]: arg2
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000069EE" title="753" data-uri="chapter08.xhtml#P70004970270000000000000000069EE" epub:type="pagebreak"></span>Environment variables :
envp[ 0]: PWD=/usr0/droh/ics/code/ecf
envp [ 1]: TERM=emacs
⋮
envp[25]: USER=droh
envp[26]: SHELL=/usr/local/bin/tcsh
envp[27]: HOME=/usr0/droh
</code>
</pre>
</li>
</ol>
</section>
</section>


<section id="P70004970270000000000000000069EF" data-uri="chapter08.xhtml#P70004970270000000000000000069EF" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000045211" data-uri="chapter08.xhtml#P7000497027000000000000000045211" epub:type="title"><span class="pcalibre label pcalibre1">8.4.6 </span>Using <code id="P7000497027000000000000000045212" data-uri="chapter08.xhtml#P7000497027000000000000000045212" class="pcalibre1 calibre8 pcalibre">fork</code> and <code id="P7000497027000000000000000045213" data-uri="chapter08.xhtml#P7000497027000000000000000045213" class="pcalibre1 calibre8 pcalibre">execve</code> to Run Programs</h1></header>

<p id="P7000497027000000000000000045214" data-uri="chapter08.xhtml#P7000497027000000000000000045214" class="pcalibre1 pcalibre calibre2">Programs such as Unix shells and Web servers make heavy use of the <code id="P7000497027000000000000000045215" data-uri="chapter08.xhtml#P7000497027000000000000000045215" class="pcalibre1 calibre8 pcalibre">fork</code> and <code id="P7000497027000000000000000045216" data-uri="chapter08.xhtml#P7000497027000000000000000045216" class="pcalibre1 calibre8 pcalibre">execve</code> functions. A <i class="calibre5 pcalibre pcalibre1">shell</i> is an interactive application-level program that runs other programs on behalf of the user. The original shell was the <code id="P7000497027000000000000000045217" data-uri="chapter08.xhtml#P7000497027000000000000000045217" class="pcalibre1 calibre8 pcalibre">sh</code> program, which was followed by variants such as <code id="P7000497027000000000000000045218" data-uri="chapter08.xhtml#P7000497027000000000000000045218" class="pcalibre1 calibre8 pcalibre">csh, tcsh, ksh</code>, and <code id="P7000497027000000000000000045219" data-uri="chapter08.xhtml#P7000497027000000000000000045219" class="pcalibre1 calibre8 pcalibre">bash</code>. A shell performs a sequence of <i class="calibre5 pcalibre pcalibre1">read/evaluate</i> steps and then terminates. The read step reads a command line from the user. The evaluate step parses the command line and runs programs on behalf of the user.</p>
<p id="P700049702700000000000000004521A" data-uri="chapter08.xhtml#P700049702700000000000000004521A" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006A09"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.23 </span></a>shows the main routine of a simple shell. The shell prints a command-line prompt, waits for the user to type a command line on <code id="P700049702700000000000000004521B" data-uri="chapter08.xhtml#P700049702700000000000000004521B" class="pcalibre1 calibre8 pcalibre">stdin</code>, and then evaluates the command line.</p>
<p id="P700049702700000000000000004521C" data-uri="chapter08.xhtml#P700049702700000000000000004521C" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006A1B"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.24 </span></a>shows the code that evaluates the command line. Its first task is to call the <code id="P700049702700000000000000004521D" data-uri="chapter08.xhtml#P700049702700000000000000004521D" class="pcalibre1 calibre8 pcalibre">parseline</code> function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000006A24"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">8.25</span></a>), which parses the space-separated command-line arguments and builds the <code id="P700049702700000000000000004521E" data-uri="chapter08.xhtml#P700049702700000000000000004521E" class="pcalibre1 calibre8 pcalibre">argv</code> vector that will eventually be passed to <code id="P700049702700000000000000004521F" data-uri="chapter08.xhtml#P700049702700000000000000004521F" class="pcalibre1 calibre8 pcalibre">execve</code>. The first argument is assumed to be either the name of a built-in shell command that is interpreted immediately, or an executable object file that will be loaded and run in the context of a new child process.</p>
<p id="P7000497027000000000000000045220" data-uri="chapter08.xhtml#P7000497027000000000000000045220" class="pcalibre1 pcalibre calibre2">If the last argument is an ‘&amp;’ character, then <code id="P7000497027000000000000000045221" data-uri="chapter08.xhtml#P7000497027000000000000000045221" class="pcalibre1 calibre8 pcalibre">parseline</code> returns 1, indicating that the program should be executed in the <i class="calibre5 pcalibre pcalibre1">background</i> (the shell does not wait for it to complete). Otherwise, it returns 0, indicating that the program should be run in the <i class="calibre5 pcalibre pcalibre1">foreground</i> (the shell waits for it to complete).</p>

<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000045222" data-uri="chapter08.xhtml#P7000497027000000000000000045222"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000045223" data-uri="chapter08.xhtml#P7000497027000000000000000045223" epub:type="title"><span class="pcalibre label1 pcalibre1">Aside </span>Programs versus processes</h1></header>
<p id="P7000497027000000000000000045224" data-uri="chapter08.xhtml#P7000497027000000000000000045224" class="pcalibre calibre3 pcalibre1">This is a good place to pause and make sure you understand the distinction between a program and a process. A program is a collection of code and data; programs can exist as object files on disk or as segments in an address space. A process is a specific instance of a program in execution; a program always runs in the context of some process. Understanding this distinction is important if you want to understand the <code id="P7000497027000000000000000045225" data-uri="chapter08.xhtml#P7000497027000000000000000045225" class="pcalibre1 calibre8 pcalibre">fork</code> and <code id="P7000497027000000000000000045226" data-uri="chapter08.xhtml#P7000497027000000000000000045226" class="pcalibre1 calibre8 pcalibre">execve</code> functions. The <code id="P7000497027000000000000000045227" data-uri="chapter08.xhtml#P7000497027000000000000000045227" class="pcalibre1 calibre8 pcalibre">fork</code> function runs the same program in a new child process that is a duplicate of the parent. The <code id="P7000497027000000000000000045228" data-uri="chapter08.xhtml#P7000497027000000000000000045228" class="pcalibre1 calibre8 pcalibre">execve</code> function loads and runs a new program in the context of the current process. While it overwrites the address space of the current process, it does <i class="calibre5 pcalibre pcalibre1">not</i> create a new process. The new program still has the same PID, and it inherits all of the file descriptors that were open at the time of the call to the <code id="P7000497027000000000000000045229" data-uri="chapter08.xhtml#P7000497027000000000000000045229" class="pcalibre1 calibre8 pcalibre">execve</code> function.</p>
</aside>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000006A09" data-uri="chapter08.xhtml#P7000497027000000000000000006A09">
<p id="P700049702700000000000000004522A" data-uri="chapter08.xhtml#P700049702700000000000000004522A" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006A0B" title="754" data-uri="chapter08.xhtml#P7000497027000000000000000006A0B" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/shellex.c</i></p>
<pre id="P700049702700000000000000004522B" data-uri="chapter08.xhtml#P700049702700000000000000004522B" class="calibre9 pcalibre pcalibre1">
<code id="P700049702700000000000000004522C" data-uri="chapter08.xhtml#P700049702700000000000000004522C" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	#define MAXARGS 128
3	
4	/* Function prototypes */
5	void evaKchar *cmdline);
6	int parseline(char *buf, char **argv);
7	int builtin_command(char **argv);
8	
9	int main()
10	{
11		char cmdline[MAXLINE]; /* Command line */
12	
13		while (1) {
14		/* Read */
15		printf("&gt; ");
16		Fgets(cmdline, MAXLINE, stdin);
17		if (feof(stdin))
18			exit(0);
19	
20		/* Evaluate */
21		eval(cmdline);
22	}
23	}
</code>
</pre>
<p id="P700049702700000000000000004522D" data-uri="chapter08.xhtml#P700049702700000000000000004522D" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/shellex.c</i></p>
<figcaption id="P700049702700000000000000004522E" data-uri="chapter08.xhtml#P700049702700000000000000004522E" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004522F" data-uri="chapter08.xhtml#P700049702700000000000000004522F" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">8.23 </span>The main routine for a simple shell program.</h1></header>
</figcaption>
</figure>

<p id="P7000497027000000000000000045230" data-uri="chapter08.xhtml#P7000497027000000000000000045230" class="pcalibre1 pcalibre calibre2">After parsing the command line, the <code id="P7000497027000000000000000045231" data-uri="chapter08.xhtml#P7000497027000000000000000045231" class="pcalibre1 calibre8 pcalibre">eval</code> function calls the <code id="P7000497027000000000000000045232" data-uri="chapter08.xhtml#P7000497027000000000000000045232" class="pcalibre1 calibre8 pcalibre">builtin_command</code> function, which checks whether the first command-line argument is a built-in shell command. If so, it interprets the command immediately and returns 1. Otherwise, it returns 0. Our simple shell has just one built-in command, the <code id="P7000497027000000000000000045233" data-uri="chapter08.xhtml#P7000497027000000000000000045233" class="pcalibre1 calibre8 pcalibre">quit</code> command, which terminates the shell. Real shells have numerous commands, such as <code id="P7000497027000000000000000045234" data-uri="chapter08.xhtml#P7000497027000000000000000045234" class="pcalibre1 calibre8 pcalibre">pwd, jobs</code>, and <code id="P7000497027000000000000000045235" data-uri="chapter08.xhtml#P7000497027000000000000000045235" class="pcalibre1 calibre8 pcalibre">fg</code>.</p>
<p id="P7000497027000000000000000045236" data-uri="chapter08.xhtml#P7000497027000000000000000045236" class="pcalibre1 pcalibre calibre2">If <code id="P7000497027000000000000000045237" data-uri="chapter08.xhtml#P7000497027000000000000000045237" class="pcalibre1 calibre8 pcalibre">builtin_command</code> returns 0, then the shell creates a child process and executes the requested program inside the child. If the user has asked for the program to run in the background, then the shell returns to the top of the loop and waits for the next command line. Otherwise the shell uses the <code id="P7000497027000000000000000045238" data-uri="chapter08.xhtml#P7000497027000000000000000045238" class="pcalibre1 calibre8 pcalibre">waitpid</code> function to wait for the job to terminate. When the job terminates, the shell goes on to the next iteration.</p>
<p id="P7000497027000000000000000045239" data-uri="chapter08.xhtml#P7000497027000000000000000045239" class="pcalibre1 pcalibre calibre2">Notice that this simple shell is flawed because it does not reap any of its background children. Correcting this flaw requires the use of signals, which we describe in the next section.</p>


<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000006A1B" data-uri="chapter08.xhtml#P7000497027000000000000000006A1B">
<p id="P700049702700000000000000004523A" data-uri="chapter08.xhtml#P700049702700000000000000004523A" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006A1D" title="755" data-uri="chapter08.xhtml#P7000497027000000000000000006A1D" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/shellex.c</i></p>
<pre id="P700049702700000000000000004523B" data-uri="chapter08.xhtml#P700049702700000000000000004523B" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004523C" data-uri="chapter08.xhtml#P700049702700000000000000004523C" class="calibre10 pcalibre pcalibre1">
1	/* eval - Evaluate a command line */
2	void evaKchar *cmdline)
3	{
4		char *argv[MAXARGS];	/* Argument list execve() */
5		char buf[MAXLINE];	/* Holds modified command line */
6		int bg;	/* Should the job run in bg or fg? */
7		pid_t pid;	/* Process id */
8	
9		strcpy(buf, cmdline);
10		bg = parseline(buf, argv);
11		if (argv[0] == NULL)
12			return;	/* Ignore empty lines */
13	
14		if (!builtin_command(argv)) {
15			if ((pid = Fork()) == 0) {	/* Child runs user job */
16				if (execve(argv[0], argv, environ) &lt; 0) {
17					printf("%s: Command not found.\n", argv[0]);
18					exit(0);
19				}
20			}
21	
22			/* Parent waits for foreground job to terminate */
23			if (!bg) {
24				int status;
25				if (waitpid(pid, &amp;status, 0) &lt; 0)
26					unix_error("waitfg: waitpid error");
27			}
28			else
29				printf (%d %s", pid, cmdline);
30		}
31		return;
32	}
33	
34	/* If first arg is a builtin command, run it and return true */
35	int builtin_command(char **argv)
36	{
37		if (!strcmp(argv[0], "quit"))	/* quit command */
38			exit(0);
39		if (!strcmp(argv[0], "&amp;"))	/* Ignore singleton &amp; */
40		return 1;
41		return 0;	/* Not a builtin command */
42	}
</code>
</pre>
<p id="P700049702700000000000000004523D" data-uri="chapter08.xhtml#P700049702700000000000000004523D" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/shellex.c</i></p>
<figcaption id="P700049702700000000000000004523E" data-uri="chapter08.xhtml#P700049702700000000000000004523E" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004523F" data-uri="chapter08.xhtml#P700049702700000000000000004523F" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">8.24 </span><code id="P7000497027000000000000000045240" data-uri="chapter08.xhtml#P7000497027000000000000000045240" class="pcalibre1 calibre8 pcalibre">eval</code> evaluates the shell command line.</h1></header>
</figcaption>
</figure>


<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000006A24" data-uri="chapter08.xhtml#P7000497027000000000000000006A24">


<p id="P7000497027000000000000000045241" data-uri="chapter08.xhtml#P7000497027000000000000000045241" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000006A26" title="756" data-uri="chapter08.xhtml#P7000497027000000000000000006A26" epub:type="pagebreak"></span>------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/shellex.c</i></p>
<pre id="P7000497027000000000000000045242" data-uri="chapter08.xhtml#P7000497027000000000000000045242" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000045243" data-uri="chapter08.xhtml#P7000497027000000000000000045243" class="calibre10 pcalibre pcalibre1">
1	/* parseline - Parse the command line and build the argv array */
2	int parseline(char *buf, char **argv)
3	{
4		char *delim;	/* Points to first space delimiter */
5		int argc;	/* Number of args */
6		int bg;	/* Background job? */ 7
7	
8		buf[strlen(buf) -1] = ‘ ’;	/* Replace trailing ‘\n’ with space */
9		while (*buf &amp;&amp; (*buf == ‘ ’)) /* Ignore leading spaces */
10			buf++;
11	
12		/* Build the argv list */
13		argc = 0;
14		while ((delim = strchr(buf, ‘ ’))) {
15			argv [argc++] = buf;
16			*delim = ‘\0’;
17			buf = delim + 1;
18			while (*buf &amp;&amp; (*buf == ‘ ’)) /* Ignore spaces */
19				buf++;
20		}
21		argv [argc] = NULL;
22	
23		if (argc == 0) /* Ignore blank line */
24			return 1;
25	
26		/* Should the job run in the background? */
27		if ((bg = (*argv[argc-1] == ‘&amp;’)) != 0)
28			argv[—argc] = NULL;
29	
30		return bg;
31	}
</code>
</pre>
<p id="P7000497027000000000000000045244" data-uri="chapter08.xhtml#P7000497027000000000000000045244" class="pcalibre1 pcalibre calibre2">------------------------------------------------------------------------------------------------------<i class="calibre5 pcalibre pcalibre1">code/ecf/shellex.c</i></p>
<figcaption id="P7000497027000000000000000045245" data-uri="chapter08.xhtml#P7000497027000000000000000045245" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000045246" data-uri="chapter08.xhtml#P7000497027000000000000000045246" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">8.25 </span><code id="P7000497027000000000000000045247" data-uri="chapter08.xhtml#P7000497027000000000000000045247" class="pcalibre1 calibre8 pcalibre">parseline</code> parses a line of input for the shell.</h1></header>
</figcaption>
</figure>
</section>
</section></body></html>
