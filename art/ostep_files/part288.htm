<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.9 Compare-And-Swap</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part287.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part289.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">28.9 Compare-And-Swap</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Another hardware primitive that some systems provide is known as the <b>compare-and-swap </b>instruction (as it is called on SPARC, for exam- ple), or <b>compare-and-exchange </b>(as it called on x86). The C pseudocode for this single instruction is found in Figure <span style=" color: #00AEEF;">28.3</span>.</p><p style="padding-left: 52pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">The basic idea is for compare-and-swap to test whether the value at the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">1  </span>int CompareAndSwap(int <span class="s39">*</span>ptr, int expected, int new) {</p><p class="s38" style="padding-left: 26pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">2    </span>int actual = <span class="s39">*</span>ptr;</p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">3    <span class="s38">if (actual == expected)</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: left;">4       <span class="s39">*</span><span class="s38">ptr = new;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;line-height: 7pt;text-align: left;">5    <span class="s38">return actual;</span></p><p class="s37" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">6  <span class="s38">}</span></p><p style="padding-left: 120pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 28.3: <b>Compare-and-swap</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: right;">address specified by <span class="s41">ptr </span>is equal to <span class="s41">expected</span>; if so, update the memory location pointed to by <span class="s41">ptr </span>with the new value. If not, do nothing. In either case, return the actual value at that memory location, thus allowing the code calling compare-and-swap to know whether it succeeded or not. With the compare-and-swap instruction, we can build a lock in a man- ner quite similar to that with test-and-set. For example, we could just</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 10pt;text-align: left;">replace the <span class="s41">lock() </span>routine above with the following:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">1  </span>void lock(lock_t <span class="s39">*</span>lock) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">2     <span class="s38">while (CompareAndSwap(&amp;lock-&gt;flag, 0, 1) == 1)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3       <span class="s38">; // spin</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The rest of the code is the same as the test-and-set example above. This code works quite similarly; it simply checks if the flag is 0 and if so, atomically swaps in a 1 thus acquiring the lock. Threads that try to acquire the lock while it is held will get stuck spinning until the lock is finally released.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">If you want to see how to really make a C-callable x86-version of compare-and-swap, this code sequence might be useful (from [S05]):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">1  </span>char CompareAndSwap(int <span class="s39">*</span>ptr, int old, int new) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">2    <span class="s38">unsigned char ret;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">3</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4     <span class="s38">// Note that sete sets a ’byte’ not the word</span></p><p class="s75" style="padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">5 </span><span class="s137">&nbsp;</span><span class="s38">asm</span>  <span class="s133"> </span>&nbsp; <span class="s38">volatile</span>  <span class="s133"> </span><span class="s38">(</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6        <span class="s38">&quot; lock\n&quot;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7         <span class="s38">&quot; cmpxchgl %2,%1\n&quot;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8         <span class="s38">&quot; sete %0\n&quot;</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">9        </span>: &quot;=q&quot; (ret), &quot;=m&quot; (<span class="s39">*</span>ptr)</p><p class="s38" style="padding-left: 51pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">10         </span>: &quot;r&quot; (new), &quot;m&quot; (<span class="s39">*</span>ptr), &quot;a&quot; (old)</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">11        <span class="s38">: &quot;memory&quot;);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">12    <span class="s38">return ret;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">13  <span class="s38">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Finally, as you may have sensed, compare-and-swap is a more power- ful instruction than test-and-set. We will make some use of this power in the future when we briefly delve into <b>wait-free synchronization </b>[H91]. However, if we just build a simple spin lock with it, its behavior is iden- tical to the spin lock we analyzed above.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part287.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part289.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
