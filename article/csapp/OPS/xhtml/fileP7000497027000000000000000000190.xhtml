<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>1.7 The Operating System Manages the Hardware</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000000190" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P700049702700000000000000003E5A3" data-uri="chapter01.xhtml#P700049702700000000000000003E5A3" epub:type="title"><span class="pcalibre label pcalibre1">1.7 </span>The Operating System Manages the Hardware</h1></header>
<p id="P700049702700000000000000003E5A4" data-uri="chapter01.xhtml#P700049702700000000000000003E5A4" class="pcalibre1 pcalibre calibre2">Back to our <code id="P700049702700000000000000003E5A5" data-uri="chapter01.xhtml#P700049702700000000000000003E5A5" class="pcalibre1 calibre8 pcalibre">hello</code> example. When the shell loaded and ran the <code id="P700049702700000000000000003E5A6" data-uri="chapter01.xhtml#P700049702700000000000000003E5A6" class="pcalibre1 calibre8 pcalibre">hello</code> program, and when the <code id="P700049702700000000000000003E5A7" data-uri="chapter01.xhtml#P700049702700000000000000003E5A7" class="pcalibre1 calibre8 pcalibre">hello</code> program printed its message, neither program accessed the</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000000196" data-uri="chapter01.xhtml#P7000497027000000000000000000196">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000000197" title="15" data-uri="chapter01.xhtml#P7000497027000000000000000000197" epub:type="pagebreak"></span>
<img alt="A diagram of the layered view of a computer system shows Application programs on top and Operating system in the center (each part of the software), and hardware processor, main memory, and I/O devices on bottom." id="P700049702700000000000000003E5A8" data-uri="P700049702700000000000000000B6AB" src="../images/p15-1.png" class="calibre40 pcalibre pcalibre1"/>
<figcaption id="P700049702700000000000000003E5A9" data-uri="chapter01.xhtml#P700049702700000000000000003E5A9" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000003E5AA" data-uri="chapter01.xhtml#P700049702700000000000000003E5AA" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">1.10 </span>Layered view of a computer system.</h1></header></figcaption></figure>
<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000019B" data-uri="chapter01.xhtml#P700049702700000000000000000019B">
<img alt="A diagram of abstractions shows the hardware components processor, main memory, and I/O devices as Processes, main memory and I/O devices as virtual memory, and I/O devices as Files." id="P700049702700000000000000003E5AB" data-uri="P700049702700000000000000000B6AC" src="../images/p15-2.png" class="calibre41 pcalibre pcalibre1"/>
<figcaption id="P700049702700000000000000003E5AC" data-uri="chapter01.xhtml#P700049702700000000000000003E5AC" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000003E5AD" data-uri="chapter01.xhtml#P700049702700000000000000003E5AD" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">1.11 </span>Abstractions provided by an operating system.</h1></header></figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000003E5AE" data-uri="chapter01.xhtml#P700049702700000000000000003E5AE">keyboard, display, disk, or main memory directly. Rather, they relied on the services provided by the <i class="calibre5 pcalibre pcalibre1">operating system</i>. We can think of the operating system as a layer of software interposed between the application program and the hardware, as shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000000196"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">1.10</span></a>. All attempts by an application program to manipulate the hardware must go through the operating system.</p>
<p id="P700049702700000000000000003E5AF" data-uri="chapter01.xhtml#P700049702700000000000000003E5AF" class="pcalibre1 pcalibre calibre2">The operating system has two primary purposes: (1) to protect the hardware from misuse by runaway applications and (2) to provide applications with simple and uniform mechanisms for manipulating complicated and often wildly different low-level hardware devices. The operating system achieves both goals via the fundamental abstractions shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000019B"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">1.11</span></a>: <i class="calibre5 pcalibre pcalibre1">processes</i>, <i class="calibre5 pcalibre pcalibre1">virtual memory</i>, and <i class="calibre5 pcalibre pcalibre1">files</i>. As this figure suggests, files are abstractions for I/O devices, virtual memory is an abstraction for both the main memory and disk I/O devices, and processes are abstractions for the processor, main memory, and I/O devices. We will discuss each in turn.</p>
<section id="P70004970270000000000000000001A1" data-uri="chapter01.xhtml#P70004970270000000000000000001A1" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000003E5B0" data-uri="chapter01.xhtml#P700049702700000000000000003E5B0" epub:type="title"><span class="pcalibre label pcalibre1">1.7.1 </span>Processes</h1></header>
<p id="P700049702700000000000000003E5B1" data-uri="chapter01.xhtml#P700049702700000000000000003E5B1" class="pcalibre1 pcalibre calibre2">When a program such as <code id="P700049702700000000000000003E5B2" data-uri="chapter01.xhtml#P700049702700000000000000003E5B2" class="pcalibre1 calibre8 pcalibre">hello</code> runs on a modern system, the operating system provides the illusion that the program is the only one running on the system. The program appears to have exclusive use of both the processor, main memory, and I/O devices. The processor appears to execute the instructions in the program, one after the other, without interruption. And the code and data of the program appear to be the only objects in the system's memory. These illusions are provided by the notion of a process, one of the most important and successful ideas in computer science.</p>
<p id="P700049702700000000000000003E5B3" data-uri="chapter01.xhtml#P700049702700000000000000003E5B3" class="pcalibre1 pcalibre calibre2">A <i class="calibre5 pcalibre pcalibre1">process</i> is the operating system's abstraction for a running program. Multiple processes can run concurrently on the same system, and each process appears to have exclusive use of the hardware. By <i class="calibre5 pcalibre pcalibre1">concurrently</i>, we mean that the instructions of one process are interleaved with the instructions of another process. In most systems, there are more processes to run than there are CPUs to run them.</p>
<aside class="sidebar pcalibre5 pcalibre" id="P70004970270000000000000000001A6" data-uri="chapter01.xhtml#P70004970270000000000000000001A6"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P700049702700000000000000003E5B4" data-uri="chapter01.xhtml#P700049702700000000000000003E5B4" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000001A8" title="16" data-uri="chapter01.xhtml#P70004970270000000000000000001A8" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Unix, Posix, and the Standard Unix Specification</h1></header>
<p id="P700049702700000000000000003E5B5" data-uri="chapter01.xhtml#P700049702700000000000000003E5B5" class="calibre13 pcalibre pcalibre1">The 1960s was an era of huge, complex operating systems, such as IBM's OS/360 and Honeywell's Multics systems. While OS/360 was one of the most successful software projects in history, Multics dragged on for years and never achieved wide-scale use. Bell Laboratories was an original partner in the Multics project but dropped out in 1969 because of concern over the complexity of the project and the lack of progress. In reaction to their unpleasant Multics experience, a group of Bell Labs researchers—Ken Thompson, Dennis Ritchie, Doug McIlroy, and Joe Ossanna—began work in 1969 on a simpler operating system for a Digital Equipment Corporation PDP-7 computer, written entirely in machine language. Many of the ideas in the new system, such as the hierarchical file system and the notion of a shell as a user-level process, were borrowed from Multics but implemented in a smaller, simpler package. In 1970, Brian Kernighan dubbed the new system "Unix" as a pun on the complexity of "Multics." The kernel was rewritten in C in 1973, and Unix was announced to the outside world in 1974 [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B45E">93</a>].</p>
<p id="P700049702700000000000000003E5B6" data-uri="chapter01.xhtml#P700049702700000000000000003E5B6" class="calibre13 pcalibre pcalibre1">Because Bell Labs made the source code available to schools with generous terms, Unix developed a large following at universities. The most influential work was done at the University of California at Berkeley in the late 1970s and early 1980s, with Berkeley researchers adding virtual memory and the Internet protocols in a series of releases called Unix 4.xBSD (Berkeley Software Distributimn). Concurrently, Bell Labs was releasing their own versions, which became known as System V Unix. Versions from other vendors, such as the Sun Microsystems Solaris system, were derived from these original BSD and System V versions.</p>
<p id="P700049702700000000000000003E5B7" data-uri="chapter01.xhtml#P700049702700000000000000003E5B7" class="pcalibre calibre3 pcalibre1">Trouble arose in the mid 1980s as Unix vendors tried to differentiate themselves by adding new and often incompatible features. To combat this trend, IEEE (Institute for Electrical and Electronics Engineers) sponsored an effort to standardize Unix, later dubbed "Posix" by Richard Stallman. The result was a family of standards, known as the Posix standards, that cover such issues as the C language interface for Unix system calls, shell programs and utilities, threads, and network programming. More recently, a separate standardization effort, known as the "Standard Unix Specification," has joined forces with Posix to create a single, unified standard for Unix systems. As a result of these standardization efforts, the differences between Unix versions have largely disappeared.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000003E5B8" data-uri="chapter01.xhtml#P700049702700000000000000003E5B8">Traditional systems could only execute one program at a time, while newer <i class="calibre5 pcalibre pcalibre1">multi-core</i> processors can execute several programs simultaneously. In either case, a single CPU can appear to execute multiple processes concurrently by having the processor switch among them. The operating system performs this interleaving with a mechanism known as <i class="calibre5 pcalibre pcalibre1">context switching</i>. To simplify the rest of this discussion, we consider only a <i class="calibre5 pcalibre pcalibre1">uniprocessor system</i> containing a single CPU. We will return to the discussion of <i class="calibre5 pcalibre pcalibre1">multiprocessor</i> systems in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000226"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">1.9.2</span></a>.</p>
<p id="P700049702700000000000000003E5B9" data-uri="chapter01.xhtml#P700049702700000000000000003E5B9" class="pcalibre1 pcalibre calibre2">The operating system keeps track of all the state information that the process needs in order to run. This state, which is known as the <i class="calibre5 pcalibre pcalibre1">context</i>, includes information such as the current values of the PC, the register file, and the contents of main memory. At any point in time, a uniprocessor system can only execute the code for a single process. When the operating system decides to transfer control from the current process to some new process, it performs a <i class="calibre5 pcalibre pcalibre1">context switch</i> by saving the context of the current process, restoring the context of the new process, and</p>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000001AE" data-uri="chapter01.xhtml#P70004970270000000000000000001AE">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000001AF" title="17" data-uri="chapter01.xhtml#P70004970270000000000000000001AF" epub:type="pagebreak"></span>
<img alt="A diagram illustrates process context switching." id="P700049702700000000000000003E5BA" data-uri="P700049702700000000000000000B6AF" src="../images/p17-1.png" class="calibre42 pcalibre pcalibre1"/>
<figcaption id="P700049702700000000000000003E5BB" data-uri="chapter01.xhtml#P700049702700000000000000003E5BB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000003E5BC" data-uri="chapter01.xhtml#P700049702700000000000000003E5BC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">1.12 </span>Process context switching.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P700049702700000000000000001E887" data-uri="chapter01.xhtml#P700049702700000000000000001E887">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P700049702700000000000000003E5BD" data-uri="chapter01.xhtml#P700049702700000000000000003E5BD" class="pcalibre calibre3 pcalibre1">A diagram shows a flow of steps over time, moving between Process A and Process B. The flow extends through user code in Process A to read, and then moves through kernel code (context switch), switching from Process A to Process B. In Process B, the flow moves through user code to disk interrupt, and then through kernel code (context switch) from Process B to Process A, to Return from read, before moving through user code in Process A.</p>
</details>
</figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000003E5BE" data-uri="chapter01.xhtml#P700049702700000000000000003E5BE">then passing control to the new process. The new process picks up exactly where it left off. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000001AE"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">1.12</span></a> shows the basic idea for our example <code id="P700049702700000000000000003E5BF" data-uri="chapter01.xhtml#P700049702700000000000000003E5BF" class="pcalibre1 calibre8 pcalibre">hello</code> scenario.</p>
<p id="P700049702700000000000000003E5C0" data-uri="chapter01.xhtml#P700049702700000000000000003E5C0" class="pcalibre1 pcalibre calibre2">There are two concurrent processes in our example scenario: the shell process and the <code id="P700049702700000000000000003E5C1" data-uri="chapter01.xhtml#P700049702700000000000000003E5C1" class="pcalibre1 calibre8 pcalibre">hello</code> process. Initially, the shell process is running alone, waiting for input on the command line. When we ask it to run the <code id="P700049702700000000000000003E5C2" data-uri="chapter01.xhtml#P700049702700000000000000003E5C2" class="pcalibre1 calibre8 pcalibre">hello</code> program, the shell carries out our request by invoking a special function known as a <i class="calibre5 pcalibre pcalibre1">system call</i> that passes control to the operating system. The operating system saves the shell's context, creates a new <code id="P700049702700000000000000003E5C3" data-uri="chapter01.xhtml#P700049702700000000000000003E5C3" class="pcalibre1 calibre8 pcalibre">hello</code> process and its context, and then passes control to the new <code id="P700049702700000000000000003E5C4" data-uri="chapter01.xhtml#P700049702700000000000000003E5C4" class="pcalibre1 calibre8 pcalibre">hello</code> process. After <code id="P700049702700000000000000003E5C5" data-uri="chapter01.xhtml#P700049702700000000000000003E5C5" class="pcalibre1 calibre8 pcalibre">hello</code> terminates, the operating system restores the context of the shell process and passes control back to it, where it waits for the next command-line input.</p>
<p id="P700049702700000000000000003E5C6" data-uri="chapter01.xhtml#P700049702700000000000000003E5C6" class="pcalibre1 pcalibre calibre2">As <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000001AE"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">1.12</span></a> indicates, the transition from one process to another is managed by the operating system <i class="calibre5 pcalibre pcalibre1">kernel</i>. The kernel is the portion of the operating system code that is always resident in memory. When an application program requires some action by the operating system, such as to read or write a file, it executes a special <i class="calibre5 pcalibre pcalibre1">system call</i> instruction, transferring control to the kernel. The kernel then performs the requested operation and returns back to the application program. Note that the kernel is not a separate process. Instead, it is a collection of code and data structures that the system uses to manage all the processes.</p>
<p id="P700049702700000000000000003E5C7" data-uri="chapter01.xhtml#P700049702700000000000000003E5C7" class="pcalibre1 pcalibre calibre2">Implementing the process abstraction requires close cooperation between both the low-level hardware and the operating system software. We will explore how this works, and how applications can create and control their own processes, in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">8</span></a>.</p>
</section>
<section id="P70004970270000000000000000001BD" data-uri="chapter01.xhtml#P70004970270000000000000000001BD" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000003E5C8" data-uri="chapter01.xhtml#P700049702700000000000000003E5C8" epub:type="title"><span class="pcalibre label pcalibre1">1.7.2 </span>Threads</h1></header>
<p id="P700049702700000000000000003E5C9" data-uri="chapter01.xhtml#P700049702700000000000000003E5C9" class="pcalibre1 pcalibre calibre2">Although we normally think of a process as having a single control flow, in modern systems a process can actually consist of multiple execution units, called <i class="calibre5 pcalibre pcalibre1">threads</i>, each running in the context of the process and sharing the same code and global data. Threads are an increasingly important programming model because of the requirement for concurrency in network servers, because it is easier to share data between multiple threads than between multiple processes, and because threads are typically more efficient than processes. Multi-threading is also one way to make programs run faster when multiple processors are available, as we will discuss in</p>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000001C0" data-uri="chapter01.xhtml#P70004970270000000000000000001C0">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000001C1" title="18" data-uri="chapter01.xhtml#P70004970270000000000000000001C1" epub:type="pagebreak"></span>
<img alt="A diagram illustrates process virtual address space." id="P700049702700000000000000003E5CA" data-uri="P700049702700000000000000000B6B0" src="../images/p18-1.png" class="calibre43 pcalibre pcalibre1"/>
<figcaption id="P700049702700000000000000003E5CB" data-uri="chapter01.xhtml#P700049702700000000000000003E5CB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000003E5CC" data-uri="chapter01.xhtml#P700049702700000000000000003E5CC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">1.13 </span>Process virtual address space.</h1></header>
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000003E5CD" data-uri="chapter01.xhtml#P700049702700000000000000003E5CD"><p id="P700049702700000000000000003E5CE" data-uri="chapter01.xhtml#P700049702700000000000000003E5CE" class="pcalibre calibre3 pcalibre1">(The regions are not drawn to scale.)</p></div>
<details class="longdesc pcalibre pcalibre1" id="P700049702700000000000000001E89A" data-uri="chapter01.xhtml#P700049702700000000000000001E89A">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P700049702700000000000000003E5CF" data-uri="chapter01.xhtml#P700049702700000000000000003E5CF" class="pcalibre calibre3 pcalibre1">A diagram shows a stack of regions. The bottom region extends from 0 to Program start. The next two regions, loaded from the hello executable file, represent read-only code and data and read/write data. The next region is Run-time heap (created by nalloc), moving through a blank region above. The next region, the printf function, contains Memory-mapped region for shared libraries. In a blank space above, arrows point from the regions above and below. The top two regions are User stack (created at run time) and Kernel virtual memory, leading to memory invisible to user code.</p>
</details>
</figcaption></figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000003E5D0" data-uri="chapter01.xhtml#P700049702700000000000000003E5D0"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000001FF.xhtml#P7000497027000000000000000000226"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">1.9.2</span></a>. You will learn the basic concepts of concurrency, including how to write threaded programs, in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">12</span></a>.</p>
</section>
<section id="P70004970270000000000000000001C8" data-uri="chapter01.xhtml#P70004970270000000000000000001C8" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000003E5D1" data-uri="chapter01.xhtml#P700049702700000000000000003E5D1" epub:type="title"><span class="pcalibre label pcalibre1">1.7.3 </span>Virtual Memory</h1></header>
<p id="P700049702700000000000000003E5D2" data-uri="chapter01.xhtml#P700049702700000000000000003E5D2" class="pcalibre1 pcalibre calibre2"><i class="calibre5 pcalibre pcalibre1">Virtual memory</i> is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its <i class="calibre5 pcalibre pcalibre1">virtual address space</i>. The virtual address space for Linux processes is shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000001C0"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">1.13</span></a>. (Other Unix systems use a similar layout.) In Linux, the topmost region of the address space is reserved for code and data in the operating system that is common to all processes. The lower region of the address space holds the code and data defined by the user's process. Note that addresses in the figure increase from the bottom to the top.</p>
<p id="P700049702700000000000000003E5D3" data-uri="chapter01.xhtml#P700049702700000000000000003E5D3" class="pcalibre1 pcalibre calibre2">The virtual address space seen by each process consists of a number of well-defined areas, each with a specific purpose. You will learn more about these areas later in the book, but it will be helpful to look briefly at each, starting with the lowest addresses and working our way up:</p>
<ul id="P700049702700000000000000003E5D4" data-uri="chapter01.xhtml#P700049702700000000000000003E5D4" class="calibre28 pcalibre pcalibre1">
<li id="P700049702700000000000000003E5D5" data-uri="chapter01.xhtml#P700049702700000000000000003E5D5" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000003E5D6" data-uri="chapter01.xhtml#P700049702700000000000000003E5D6" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Program code and data. </span>Code begins at the same fixed address for all processes, followed by data locations that correspond to global C variables. The code and data areas are initialized directly from the contents of an executable object file—in our case, the <code id="P700049702700000000000000003E5D7" data-uri="chapter01.xhtml#P700049702700000000000000003E5D7" class="pcalibre1 calibre8 pcalibre">hello</code> executable. You will learn more about this part of the address space when we study linking and loading in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000005FB4.xhtml#P7000497027000000000000000005FB4"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">7</span></a>.</p></li>
<li id="P700049702700000000000000003E5D8" data-uri="chapter01.xhtml#P700049702700000000000000003E5D8" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000003E5D9" data-uri="chapter01.xhtml#P700049702700000000000000003E5D9" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Heap. </span>The code and data areas are followed immediately by the run-time <i class="calibre5 pcalibre pcalibre1">heap</i>. Unlike the code and data areas, which are fixed in size once the process begins <span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000001D2" title="19" data-uri="chapter01.xhtml#P70004970270000000000000000001D2" epub:type="pagebreak"></span>running, the heap expands and contracts dynamically at run time as a result of calls to C standard library routines such as <code id="P700049702700000000000000003E5DA" data-uri="chapter01.xhtml#P700049702700000000000000003E5DA" class="pcalibre1 calibre8 pcalibre">malloc</code> and <code id="P700049702700000000000000003E5DB" data-uri="chapter01.xhtml#P700049702700000000000000003E5DB" class="pcalibre1 calibre8 pcalibre">free</code>. We will study heaps in detail when we learn about managing virtual memory in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">9</span></a>.</p></li>
<li id="P700049702700000000000000003E5DC" data-uri="chapter01.xhtml#P700049702700000000000000003E5DC" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000003E5DD" data-uri="chapter01.xhtml#P700049702700000000000000003E5DD" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Shared libraries. </span>Near the middle of the address space is an area that holds the code and data for <i class="calibre5 pcalibre pcalibre1">shared libraries</i> such as the C standard library and the math library. The notion of a shared library is a powerful but somewhat difficult concept. You will learn how they work when we study dynamic linking in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000005FB4.xhtml#P7000497027000000000000000005FB4"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">7</span></a>.</p></li>
<li id="P700049702700000000000000003E5DE" data-uri="chapter01.xhtml#P700049702700000000000000003E5DE" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000003E5DF" data-uri="chapter01.xhtml#P700049702700000000000000003E5DF" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Stack. </span>At the top of the user's virtual address space is the <i class="calibre5 pcalibre pcalibre1">user stack</i> that the compiler uses to implement function calls. Like the heap, the user stack expands and contracts dynamically during the execution of the program. In particular, each time we call a function, the stack grows. Each time we return from a function, it contracts. You will learn how the compiler uses the stack in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000001DCE.xhtml#P7000497027000000000000000001DCE"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">3</span></a>.</p></li>
<li id="P700049702700000000000000003E5E0" data-uri="chapter01.xhtml#P700049702700000000000000003E5E0" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000003E5E1" data-uri="chapter01.xhtml#P700049702700000000000000003E5E1" class="pcalibre calibre3 pcalibre1"><span class="pcalibre leadin pcalibre1">Kernel virtual memory. </span>The top region of the address space is reserved for the kernel. Application programs are not allowed to read or write the contents of this area or to directly call functions defined in the kernel code. Instead, they must invoke the kernel to perform these operations.</p></li>
</ul>
<p id="P700049702700000000000000003E5E2" data-uri="chapter01.xhtml#P700049702700000000000000003E5E2" class="pcalibre1 pcalibre calibre2">For virtual memory to work, a sophisticated interaction is required between the hardware and the operating system software, including a hardware translation of every address generated by the processor. The basic idea is to store the contents of a process's virtual memory on disk and then use the main memory as a cache for the disk. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">9</span></a> explains how this works and why it is so important to the operation of modern systems.</p>
</section>
<section id="P70004970270000000000000000001DC" data-uri="chapter01.xhtml#P70004970270000000000000000001DC" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000003E5E3" data-uri="chapter01.xhtml#P700049702700000000000000003E5E3" epub:type="title"><span class="pcalibre label pcalibre1">1.7.4 </span>Files</h1></header>
<p id="P700049702700000000000000003E5E4" data-uri="chapter01.xhtml#P700049702700000000000000003E5E4" class="pcalibre1 pcalibre calibre2">A <i class="calibre5 pcalibre pcalibre1">file</i> is a sequence of bytes, nothing more and nothing less. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as <i class="calibre5 pcalibre pcalibre1">Unix I/O</i>.</p>
<p id="P700049702700000000000000003E5E5" data-uri="chapter01.xhtml#P700049702700000000000000003E5E5" class="pcalibre1 pcalibre calibre2">This simple and elegant notion of a file is nonetheless very powerful because it provides applications with a uniform view of all the varied I/O devices that might be contained in the system. For example, application programmers who manipulate the contents of a disk file are blissfully unaware of the specific disk technology. Further, the same program will run on different systems that use different disk technologies. You will learn about Unix I/O in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007867.xhtml#P7000497027000000000000000007867"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">10</span></a>.</p>
</section>
</section></body></html>
