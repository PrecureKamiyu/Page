<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>15.1   Overview</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part279.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part281.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">15.1   <span style=" color: #00AEEF;">Overview</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">The steps involved in processing a query appear in Figure 15.1. The basic steps are:</p><p class="s63" style="padding-top: 6pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">1. <span class="p">Parsing and translation.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">2. <span class="p">Optimization.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 128pt;text-indent: 0pt;text-align: left;">3. <span class="p">Evaluation.</span></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Before query processing can begin, the system must translate the query into a us- able form. A language such as <span class="s44">SQL </span>is suitable for human use, but it is ill suited to be the system’s internal representation of a query. A more useful internal representation is one based on the extended relational algebra.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Thus, the ﬁrst action the system must take in query processing is to translate a given query into its internal form. This translation process is similar to the work performed by the parser of a compiler. In generating the internal form of the query, the parser checks the syntax of the user’s query, veriﬁes that the relation names appearing in the query are names of the relations in the database, and so on. The system constructs a parse-tree representation of the query, which it then translates into a relational-algebra expression. If the query was expressed in terms of a view, the translation phase also replaces all uses of the view by the relational-algebra expression that deﬁnes the view.<span class="s76">1</span> Most compiler texts cover parsing in detail.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2756.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">1<span class="s78">For materialized views, the expression deﬁning the view has already been evaluated and stored. Therefore, the stored relation can be used, instead of uses of the view being replaced by the expression deﬁning the view. Recursive views are handled diﬀerently, via a ﬁxed-point procedure, as discussed in Section 5.4 and Section 27.4.7.</span></p><p class="s20" style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">689</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="217" height="62" alt="image" src="Image_2757.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="368" height="168" alt="image" src="Image_2758.png"/></span></p><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">parser and</p><p class="s185" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">translator</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">optimizer</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="text-indent: 0pt;line-height: 10pt;text-align: left;">evaluation engine</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">execution plan</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="padding-left: 5pt;text-indent: 0pt;line-height: 12pt;text-align: left;">query</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="padding-left: 19pt;text-indent: -13pt;text-align: left;">relational-algebra expression</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="padding-left: 3pt;text-indent: 1pt;text-align: left;">query output</p><p style="text-indent: 0pt;text-align: left;"/><p class="s185" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">data                  statistics</p><p class="s185" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">about data</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 15.1 <span class="s74">Steps in query processing.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Given a query, there are generally a variety of methods for computing the answer. For example, we have seen that, in <span class="s44">SQL</span>, a query could be expressed in several diﬀer- ent ways. Each <span class="s44">SQL </span>query can itself be translated into a relational-algebra expression in one of several ways. Furthermore, the relational-algebra representation of a query spec- iﬁes only partially how to evaluate a query; there are usually several ways to evaluate relational-algebra expressions. As an illustration, consider the query:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 227pt;text-indent: 0pt;text-align: left;">select <i>salary</i></p><p class="s46" style="padding-left: 227pt;text-indent: 0pt;line-height: 11pt;text-align: left;">from <i>instructor</i></p><p class="s46" style="padding-left: 227pt;text-indent: 0pt;line-height: 20pt;text-align: left;">where <i>salary </i><span class="s83">&lt; </span><span class="p">75000;</span></p><p style="padding-top: 8pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">This query can be translated into either of the following relational-algebra expressions:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s117" style="padding-left: 91pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><span class="s362">• </span>σ<span class="s109">salary</span><span class="s126">&lt;</span><span class="s119">75000 </span><span class="s120">(</span>Π<span class="s109">salary </span><span class="s122">(</span><span class="s121">instructor</span><span class="s122">))</span></p><p class="s117" style="padding-left: 91pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><span class="s362">• </span>Π<span class="s109">salary </span><span class="s122">(</span>σ<span class="s109">salary</span><span class="s126">&lt;</span><span class="s119">75000 </span><span class="s120">(</span><span class="s121">instructor</span><span class="s122">))</span></p><p style="padding-top: 8pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Further, we can execute each relational-algebra operation by one of several dif- ferent algorithms. For example, to implement the preceding selection, we can search every tuple in <i>instructor </i>to ﬁnd tuples with salary less than 75000. If a B<span class="s181">+</span>-tree index is available on the attribute <i>salary</i>, we can use the index instead to locate the tuples.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To specify fully how to evaluate a query, we need not only to provide the relational- algebra expression, but also to annotate it with instructions specifying how to evaluate each operation. Annotations may state the algorithm to be used for a speciﬁc opera- tion or the particular index or indices to use. A relational-algebra operation annotated</p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">15.1 <span style=" color: #00AEEF;">Overview  </span><span class="s164">691</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">with instructions on how to evaluate it is called an <span class="s63">evaluation primitive</span>. A sequence of primitive operations that can be used to evaluate a query is a <span class="s63">query-execution plan </span>or <span class="s63">query-evaluation plan</span>. Figure 15.2 illustrates an evaluation plan for our example query, in which a particular index (denoted in the ﬁgure as “index 1”) is speciﬁed for the se- lection operation. The <span class="s63">query-execution engine </span>takes a query-evaluation plan, executes that plan, and returns the answers to the query.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The diﬀerent evaluation plans for a given query can have diﬀerent costs. We do not expect users to write their queries in a way that suggests the most eﬃcient evalua- tion plan. Rather, it is the responsibility of the system to construct a query-evaluation plan that minimizes the cost of query evaluation; this task is called <i>query optimization</i>. Chapter 16 describes query optimization in detail.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Once the query plan is chosen, the query is evaluated with that plan, and the result of the query is output.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The sequence of steps already described for processing a query is representative; not all databases exactly follow those steps. For instance, instead of using the relational- algebra representation, several databases use an annotated parse-tree representation based on the structure of the given <span class="s44">SQL </span>query. However, the concepts that we describe here form the basis of query processing in databases.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In order to optimize a query, a query optimizer must know the cost of each opera- tion. Although the exact cost is hard to compute, since it depends on many parameters such as actual memory available to the operation, it is possible to get a rough estimate of execution cost for each operation.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In this chapter, we study how to evaluate individual operations in a query plan and how to estimate their cost; we return to query optimization in Chapter 16. Section 15.2 outlines how we measure the cost of a query. Section 15.3 through Section 15.6 cover the evaluation of individual relational-algebra operations. Several operations may be grouped together into a <b>pipeline</b>, in which each of the operations starts working on its input tuples even as they are being generated by another operation. In Section 15.7, we examine how to coordinate the execution of multiple operations in a query evaluation</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-top: 3pt;padding-bottom: 2pt;padding-left: 263pt;text-indent: 0pt;text-align: left;">π <span class="s111">salary</span></p><p style="padding-left: 265pt;text-indent: 0pt;text-align: left;"><span><img width="1" height="42" alt="image" src="Image_2759.png"/></span></p><p class="s117" style="padding-bottom: 1pt;padding-left: 263pt;text-indent: 0pt;text-align: left;">σ <span class="s111">salary </span><span class="s230">&lt; 75000; use index 1</span></p><p style="padding-left: 265pt;text-indent: 0pt;text-align: left;"><span><img width="1" height="42" alt="image" src="Image_2760.png"/></span></p><p class="s111" style="padding-top: 3pt;padding-left: 44pt;text-indent: 0pt;text-align: center;">instructor</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">Figure 15.2 <span class="s74">A query-evaluation plan.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><a name="bookmark325">plan, in particular, how to use pipelined operations to avoid writing intermediate results to disk.</a><a name="bookmark346">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part279.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part281.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
