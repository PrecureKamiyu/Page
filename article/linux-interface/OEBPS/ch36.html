<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 36. Process Resources</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch35.html" title="Chapter 35. Process Priorities and Scheduling"/><link rel="next" href="ch37.html" title="Chapter 37. Daemons"/></head><body><section class="chapter" title="Chapter 36. Process Resources" epub:type="chapter" id="process_resources"><div class="titlepage"><div><div><h2 class="title">Chapter 36. Process Resources</h2></div></div></div><p>Each process consumes system resources such as memory and CPU time. This chapter looks
            at resource-related system calls. We begin with the <span class="emphasis"><em>getrusage()</em></span>
            system call, which allows a process to monitor the resources that it has used or that
            its children have used. We then look at the <span class="emphasis"><em>setrlimit()</em></span> and
                <span class="emphasis"><em>getrlimit()</em></span> system calls, which can be used to change and
            retrieve limits on the calling process’s consumption of various resources.<a id="IDX-CHP-36-5235" class="indexterm"/></p><div class="sect1" title="Process Resource Usage"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="process_resource_usage">Process Resource Usage</h2></div></div></div><p>The <span class="emphasis"><em>getrusage()</em></span> system call retrieves statistics about
                various system resources used by the calling process or by all of its
                    children.<a id="IDX-CHP-36-5236" class="indexterm"/><a id="IDX-CHP-36-5237" class="indexterm"/><a id="IDX-CHP-36-5238" class="indexterm"/><a id="IDX-CHP-36-5239" class="indexterm"/><a id="IDX-CHP-36-5240" class="indexterm"/><a id="IDX-CHP-36-5241" class="indexterm"/><a id="IDX-CHP-36-5242" class="indexterm"/><a id="IDX-CHP-36-5243" class="indexterm"/><a id="IDX-CHP-36-5244" class="indexterm"/></p><a id="I_programlisting36_d1e99195"/><pre class="programlisting">#include &lt;sys/resource.h&gt;

int <strong class="userinput"><code>getrusage</code></strong>(int <span class="emphasis"><em>who</em></span>, struct rusage *<span class="emphasis"><em>res_usage</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>who</em></span> argument specifies the process(es) for which resource
                usage information is to be retrieved. It has one of the following values:</p><div class="variablelist"><dl><dt><span class="term">
                        <code class="literal">RUSAGE_SELF</code>
                    </span></dt><dd><p>Return information about the calling process.</p></dd><dt><span class="term">
                        <code class="literal">RUSAGE_CHILDREN</code>
                    </span></dt><dd><p>Return information about all children of the calling process that have
                            terminated and been waited for.</p></dd><dt><span class="term"><code class="literal">RUSAGE_THREAD</code> (since Linux
                        2.6.26)</span></dt><dd><p>Return information about the calling thread. This value is
                            Linux-specific.</p></dd></dl></div><p>The <span class="emphasis"><em>res_usage</em></span> argument is a pointer to a structure of type
                    <span class="emphasis"><em>rusage</em></span>, defined as shown in <a class="xref" href="ch36.html#definition_of_the_rusage_structure" title="Example 36-1. Definition of the rusage structure">Example 36-1</a>.</p><div class="example"><a id="definition_of_the_rusage_structure"/><div class="example-title">Example 36-1. Definition of the <span class="emphasis"><em>rusage</em></span> structure</div><div class="example-contents"><pre class="programlisting">struct rusage {
    struct timeval ru_utime;      /* User CPU time used */
    struct timeval ru_stime;      /* System CPU time used */
    long           ru_maxrss;     /* Maximum size of resident set (kilobytes)
                                     [used since Linux 2.6.32] */
    long           ru_ixrss;      /* Integral (shared) text memory size
                                     (kilobyte-seconds) [unused] */
    long           ru_idrss;      /* Integral (unshared) data memory used
                                     (kilobyte-seconds) [unused] */
    long           ru_isrss;      /* Integral (unshared) stack memory used
                                     (kilobyte-seconds) [unused] */
    long           ru_minflt;     /* Soft page faults (I/O not required) */
    long           ru_majflt;     /* Hard page faults (I/O required) */
    long           ru_nswap;      /* Swaps out of physical memory [unused] */
    long           ru_inblock;    /* Block input operations via file
                                     system [used since Linux 2.6.22] */
    long           ru_oublock;    /* Block output operations via file
                                     system [used since Linux 2.6.22] */
    long           ru_msgsnd;     /* IPC messages sent [unused] */
    long           ru_msgrcv;     /* IPC messages received [unused] */
    long           ru_nsignals;   /* Signals received [unused] */
    long           ru_nvcsw;      /* Voluntary context switches (process
                                     relinquished CPU before its time slice
                                     expired) [used since Linux 2.6] */
    long          ru_nivcsw;      /* Involuntary context switches (higher
                                     priority process became runnable or time
                                     slice ran out) [used since Linux 2.6] */
};</pre></div></div><p>As indicated in the comments in <a class="xref" href="ch36.html#definition_of_the_rusage_structure" title="Example 36-1. Definition of the rusage structure">Example 36-1</a>, on Linux, many of the fields in the <span class="emphasis"><em>rusage</em></span> structure are
                not filled in by <span class="emphasis"><em>getrusage()</em></span> (or <span class="emphasis"><em>wait3()</em></span>
                and <span class="emphasis"><em>wait4()</em></span>), or they are filled in only by more recent kernel
                versions. Some of the fields that are unused on Linux are used on other UNIX
                implementations. These fields are provided on Linux so that, if they are implemented
                at a future date, the <span class="emphasis"><em>rusage</em></span> structure does not need to undergo
                a change that would break existing application binaries.<a id="IDX-CHP-36-5245" class="indexterm"/><a id="IDX-CHP-36-5246" class="indexterm"/><a id="IDX-CHP-36-5247" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although <span class="emphasis"><em>getrusage()</em></span> appears on most UNIX
                    implementations, it is only weakly specified in SUSv3 (which specifies only the
                    fields <span class="emphasis"><em>ru_utime</em></span> and <span class="emphasis"><em>ru_stime</em></span>). In
                    part, this is because the meaning of much of the information in the
                        <span class="emphasis"><em>rusage</em></span> structure is implementation-dependent.</p></div><p>The <span class="emphasis"><em>ru_utime</em></span> and <span class="emphasis"><em>ru_stime</em></span> fields are
                structures of type <span class="emphasis"><em>timeval</em></span> (<a class="xref" href="ch10.html#calendar_time" title="Calendar Time">Calendar Time</a>),
                which return the number of seconds and microseconds of CPU time consumed by a
                process in user mode and kernel mode, respectively. (Similar information is
                retrieved by the <span class="emphasis"><em>times()</em></span> system call described in Section
                    10.7.)<a id="IDX-CHP-36-5248" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The Linux-specific <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/stat</code> files expose some resource usage information (CPU time and
                    page faults) about all processes on the system. See the
                        <span class="emphasis"><em>proc(5)</em></span> manual page for further details.</p></div><p>The <span class="emphasis"><em>rusage</em></span> structure returned by the
                    <span class="emphasis"><em>getrusage()</em></span>
                <code class="literal">RUSAGE_CHILDREN</code> operation includes the resource
                usage statistics of all of the descendants of the calling process. For example, if
                we have three processes related as parent, child, and grandchild, then, when the
                child does a <span class="emphasis"><em>wait()</em></span> on the grandchild, the resource usage
                values of the grandchild are added to the child’s <code class="literal">RUSAGE_CHILDREN</code> values; when the parent performs a
                    <span class="emphasis"><em>wait()</em></span> for the child, the resource usage values of both the
                child and the grandchild are added to the parent’s <code class="literal">RUSAGE_CHILDREN</code> values. Conversely, if the child does not
                    <span class="emphasis"><em>wait()</em></span> on the grandchild, then the grandchild’s resource
                usages are not recorded in the <code class="literal">RUSAGE_CHILDREN</code>
                values of the parent.</p><p>For the <code class="literal">RUSAGE_CHILDREN</code> operation, the
                    <span class="emphasis"><em>ru_maxrss</em></span> field returns the maximum resident set size among
                all of the descendants of the calling process (rather than a sum for all
                descendants).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 specifies that if <code class="literal">SIGCHLD</code> is being
                    ignored (so that children are not turned into zombies that can be waited on),
                    then the child statistics should not be added to the values returned by <code class="literal">RUSAGE_CHILDREN</code>. However, as noted in <a class="xref" href="ch26.html#ignoring_dead_child_processes" title="Ignoring Dead Child Processes">Ignoring Dead Child Processes</a>, in kernels before 2.6.9, Linux
                    deviates from this requirement—if <code class="literal">SIGCHLD</code> is
                    ignored, then the resource usage values for dead children
                        <span class="emphasis"><em>are</em></span> included in the values returned for <code class="literal">RUSAGE_CHILDREN</code>.</p></div></div><div class="sect1" title="Process Resource Limits"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="process_resource_limits">Process Resource Limits</h2></div></div></div><p>Each process has a set of resource limits that can be used to restrict the amounts
                of various system resources that the process may consume. For example, we may want
                to set resource limits on a process before execing an arbitrary program, if we are
                concerned that it may consume excessive resources. We can set the resource limits of
                the shell using the <span class="emphasis"><em>ulimit</em></span> built-in command
                    (<span class="emphasis"><em>limit</em></span> in the C shell). These limits are inherited by the
                processes that the shell creates to execute user commands.<a id="IDX-CHP-36-5249" class="indexterm"/><a id="IDX-CHP-36-5250" class="indexterm"/><a id="IDX-CHP-36-5251" class="indexterm"/><a id="IDX-CHP-36-5252" class="indexterm"/><a id="IDX-CHP-36-5253" class="indexterm"/><a id="IDX-CHP-36-5254" class="indexterm"/><a id="IDX-CHP-36-5255" class="indexterm"/><a id="IDX-CHP-36-5256" class="indexterm"/><a id="IDX-CHP-36-5257" class="indexterm"/><a id="IDX-CHP-36-5258" class="indexterm"/><a id="IDX-CHP-36-5259" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since kernel 2.6.24, the Linux-specific <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/limits</code> file can be used to view all of the resource limits of
                    any process. This file is owned by the real user ID of the corresponding process
                    and its permissions allow reading only by that user ID (or by a privileged
                        process).<a id="IDX-CHP-36-5260" class="indexterm"/></p></div><p>The <span class="emphasis"><em>getrlimit()</em></span> and <span class="emphasis"><em>setrlimit()</em></span> system
                calls allow a process to fetch and modify its resource limits.<a id="IDX-CHP-36-5261" class="indexterm"/><a id="IDX-CHP-36-5262" class="indexterm"/></p><a id="I_programlisting36_d1e99508"/><pre class="programlisting">#include &lt;sys/resource.h&gt;

int <strong class="userinput"><code>getrlimit</code></strong>(int <span class="emphasis"><em>resource</em></span>, struct rlimit *<span class="emphasis"><em>rlim</em></span>);
int <strong class="userinput"><code>setrlimit</code></strong>(int <span class="emphasis"><em>resource</em></span>, const struct rlimit *<span class="emphasis"><em>rlim</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>resource</em></span> argument identifies the resource limit to be
                retrieved or changed. The <span class="emphasis"><em>rlim</em></span> argument is used to return
                resource limit values <code class="literal">(getrlimit())</code> or to specify
                new resource limit values <code class="literal">(setrlimit())</code>, and is a
                pointer to a structure containing two fields:</p><a id="I_programlisting36_d1e99546"/><pre class="programlisting">struct rlimit {
    rlim_t rlim_cur;        /* Soft limit (actual process limit) */
    rlim_t rlim_max;        /* Hard limit (ceiling for rlim_cur) */
};</pre><p>These fields correspond to the two associated limits for a resource: the
                    <span class="emphasis"><em>soft</em></span> (<span class="emphasis"><em>rlim_cur</em></span>) and
                    <span class="emphasis"><em>hard</em></span> (<span class="emphasis"><em>rlim_max</em></span>) limits. (The
                    <span class="emphasis"><em>rlim_t</em></span> data type is an integer type.) The soft limit
                governs the amount of the resource that may be consumed by the process. A process
                can adjust the soft limit to any value from 0 up to the hard limit. For most
                resources, the sole purpose of the hard limit is to provide this ceiling for the
                soft limit. A privileged (<code class="literal">CAP_SYS_RESOURCE</code>)
                process can adjust the hard limit in either direction (as long as its value remains
                greater than the soft limit), but an unprivileged process can adjust the hard limit
                only to a lower value (irreversibly). The value <code class="literal">RLIM_INFINITY</code> in <span class="emphasis"><em>rlim_cur</em></span> or
                    <span class="emphasis"><em>rlim_max</em></span> means infinity (no limit on the resource), both
                when retrieved via <span class="emphasis"><em>getrlimit()</em></span> and when set via
                    <span class="emphasis"><em>setrlimit()</em></span>.<a id="IDX-CHP-36-5263" class="indexterm"/></p><p>In most cases, resource limits are enforced for both privileged and unprivileged
                processes. They are inherited by child processes created via
                    <span class="emphasis"><em>fork()</em></span> and are preserved across an
                    <span class="emphasis"><em>exec()</em></span>.</p><p>The values that can be specified for the <span class="emphasis"><em>resource</em></span> argument of
                    <span class="emphasis"><em>getrlimit()</em></span> and <span class="emphasis"><em>setrlimit()</em></span> are
                summarized in <a class="xref" href="ch36.html#resource_values_for_getrlimit_open_paren" title="Table 36-1. Resource values for getrlimit() and setrlimit()">Table 36-1</a> and
                detailed in Section 36.3.</p><p>Although a resource limit is a per-process attribute, in some cases, the limit is
                measured against not just that process’s consumption of the corresponding resource,
                but also against the sum of resources consumed by all processes with the same real
                user ID. The <code class="literal">RLIMIT_NPROC</code> limit, which places a
                limit on the number of processes that can be created, is a good example of the
                rationale for this approach. Applying this limit against only the number of children
                that the process itself created would be ineffective, since each child that the
                process created would also be able to create further children, which could create
                more children, and so on. Instead, the limit is measured against the count of all
                processes that have the same real user ID. Note, however, that the resource limit is
                checked only in the processes where it has been set (i.e., the process itself and
                its descendants, which inherit the limit). If another process owned by the same real
                user ID has not set the limit (i.e., the limit is infinite) or has set a different
                limit, then that process’s capacity to create children will be checked according to
                the limit that it has set.</p><p>As we describe each resource limit below, we note those limits that are measured
                against the resources consumed by all processes with the same real user ID. If not
                otherwise specified, then a resource limit is measured only against the process’s
                own consumption of the resource.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Be aware that, in many cases, the shell commands for getting and setting
                    resource limits (<span class="emphasis"><em>ulimit</em></span> in <span class="emphasis"><em>bash</em></span> and
                    the Korn shell, and <span class="emphasis"><em>limit</em></span> in the C shell) use different
                    units from those used in <span class="emphasis"><em>getrlimit()</em></span> and
                        <span class="emphasis"><em>setrlimit()</em></span>. For example, the shell commands typically
                    express the limits on the size of various memory segments in kilobytes.</p></div><div class="table"><a id="resource_values_for_getrlimit_open_paren"/><div class="table-title">Table 36-1. Resource values for <span class="emphasis"><em>getrlimit()</em></span> and
                        <span class="emphasis"><em>setrlimit()</em></span></div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>resource</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Limit on</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p>SUSv3</p>
                            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_AS</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Process virtual memory size (bytes)</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_CORE</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Core file size (bytes)</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_CPU</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>CPU time (seconds)</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_DATA</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Process data segment (bytes)</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_FSIZE</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>File size (bytes)</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_MEMLOCK</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Locked memory (bytes)</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_MSGQUEUE</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Bytes allocated for POSIX message queues for real user ID
                                    (since Linux 2.6.8)</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_NICE</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Nice value (since Linux 2.6.12)</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_NOFILE</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Maximum file descriptor number plus one</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>•</p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_NPROC</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Number of processes for real user ID</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_RSS</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Resident set size (bytes; not implemented)</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_RTPRIO</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Realtime scheduling priority (since Linux 2.6.12)</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_RTTIME</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Realtime CPU time (microseconds; since Linux 2.6.25)</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_SIGPENDING</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Number of queued signals for real user ID (since Linux
                                    2.6.8)</p>
                            </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">RLIMIT_STACK</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>Size of stack segment (bytes)</p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>•</p>
                            </td></tr></tbody></table></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="example_program-id49"/></div></div></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id50">Example program</h4></div></div></div><p>Before going into the specifics of each resource limit, we look at a
                        simple example of the use of resource limits. <a class="xref" href="ch36.html#displaying_process_resource_limits" title="Example 36-2. Displaying process resource limits">Example 36-2</a> defines the function
                            <span class="emphasis"><em>printRlimit()</em></span>, which displays a message, along with
                        the soft and hard limits for a specified resource.<a id="IDX-CHP-36-5264" class="indexterm"/><a id="IDX-CHP-36-5265" class="indexterm"/><a id="IDX-CHP-36-5266" class="indexterm"/><a id="IDX-CHP-36-5267" class="indexterm"/><a id="IDX-CHP-36-5268" class="indexterm"/><a id="IDX-CHP-36-5269" class="indexterm"/><a id="IDX-CHP-36-5270" class="indexterm"/><a id="IDX-CHP-36-5271" class="indexterm"/><a id="IDX-CHP-36-5272" class="indexterm"/><a id="IDX-CHP-36-5273" class="indexterm"/><a id="IDX-CHP-36-5274" class="indexterm"/><a id="IDX-CHP-36-5275" class="indexterm"/><a id="IDX-CHP-36-5276" class="indexterm"/><a id="IDX-CHP-36-5277" class="indexterm"/><a id="IDX-CHP-36-5278" class="indexterm"/><a id="IDX-CHP-36-5279" class="indexterm"/><a id="IDX-CHP-36-5280" class="indexterm"/><a id="IDX-CHP-36-5281" class="indexterm"/><a id="IDX-CHP-36-5282" class="indexterm"/><a id="IDX-CHP-36-5283" class="indexterm"/><a id="IDX-CHP-36-5284" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>rlim_t</em></span> data type is typically represented in
                            the same way as <span class="emphasis"><em>off_t</em></span>, to handle the representation
                            of <code class="literal">RLIMIT_FSIZE</code>, the file size
                            resource limit. For this reason, when printing
                                <span class="emphasis"><em>rlim_t</em></span> values (as in <a class="xref" href="ch36.html#displaying_process_resource_limits" title="Example 36-2. Displaying process resource limits">Example 36-2</a>), we cast them to
                                <span class="emphasis"><em>long long</em></span> and use the <code class="literal">%lld</code>
                            <span class="emphasis"><em>printf()</em></span> specifier, as explained in <a class="xref" href="ch05.html#i_solidus_o_on_large_files" title="I/O on Large Files">I/O on Large Files</a>.</p></div><p>The program in <a class="xref" href="ch36.html#setting_the_rlimit_underscore_nproc_reso" title="Example 36-3. Setting the RLIMIT_NPROC resource limit">Example 36-3</a>
                        calls <span class="emphasis"><em>setrlimit()</em></span> to set the soft and hard limits on
                        the number of processes that a user may create (<code class="literal">RLIMIT_NPROC</code>), uses the <span class="emphasis"><em>printRlimit()</em></span>
                        function of <a class="xref" href="ch36.html#displaying_process_resource_limits" title="Example 36-2. Displaying process resource limits">Example 36-2</a> to display
                        the limits before and after the change, and then creates as many processes
                        as possible. When we run this program, setting the soft limit to 30 and the
                        hard limit to 100, we see the following:</p><a id="I_programlisting36_d1e99983"/><pre class="programlisting">$ <strong class="userinput"><code>./rlimit_nproc 30 100</code></strong>
Initial maximum process limits:  soft=1024; hard=1024
New maximum process limits:      soft=30; hard=100
Child 1 (PID=15674) started
Child 2 (PID=15675) started
Child 3 (PID=15676) started
Child 4 (PID=15677) started
ERROR [EAGAIN Resource temporarily unavailable] fork</pre><p>In this example, the program managed to create only 4 new processes,
                        because 26 processes were already running for this user.</p><div class="example"><a id="displaying_process_resource_limits"/><div class="example-title">Example 36-2. Displaying process resource limits</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procres/print_rlimit.c</code></strong>
#include &lt;sys/resource.h&gt;
#include "print_rlimit.h"           /* Declares function defined here */
#include "tlpi_hdr.h"

int                     /* Print 'msg' followed by limits for 'resource' */
printRlimit(const char *msg, int resource)
{
    struct rlimit rlim;

    if (getrlimit(resource, &amp;rlim) == -1)
        return -1;

    printf("%s soft=", msg);
    if (rlim.rlim_cur == RLIM_INFINITY)
        printf("infinite");
#ifdef RLIM_SAVED_CUR               /* Not defined on some implementations */
    else if (rlim.rlim_cur == RLIM_SAVED_CUR)
        printf("unrepresentable");
#endif
    else
        printf("%lld", (long long) rlim.rlim_cur);

    printf("; hard=");
    if (rlim.rlim_max == RLIM_INFINITY)
        printf("infinite\n");
#ifdef RLIM_SAVED_MAX               /* Not defined on some implementations */
    else if (rlim.rlim_max == RLIM_SAVED_MAX)
        printf("unrepresentable");
#endif
    else
        printf("%lld\n", (long long) rlim.rlim_max);

    return 0;
}
     <strong class="userinput"><code>procres/print_rlimit.c</code></strong></pre></div></div><div class="example"><a id="setting_the_rlimit_underscore_nproc_reso"/><div class="example-title">Example 36-3. Setting the <code class="literal">RLIMIT_NPROC</code> resource
                            limit</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>procres/rlimit_nproc.c</code></strong>
#include &lt;sys/resource.h&gt;
#include "print_rlimit.h"               /* Declaration of printRlimit() */
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    struct rlimit rl;
    int j;
    pid_t childPid;

    if (argc &lt; 2 || argc &gt; 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s soft-limit [hard-limit]\n", argv[0]);

    printRlimit("Initial maximum process limits: ", RLIMIT_NPROC);

    /* Set new process limits (hard == soft if not specified) */

    rl.rlim_cur = (argv[1][0] == 'i') ? RLIM_INFINITY :
                                getInt(argv[1], 0, "soft-limit");
    rl.rlim_max = (argc == 2) ? rl.rlim_cur :
                (argv[2][0] == 'i') ? RLIM_INFINITY :
                                getInt(argv[2], 0, "hard-limit");
    if (setrlimit(RLIMIT_NPROC, &amp;rl) == -1)
        errExit("setrlimit");

    printRlimit("New maximum process limits:     ", RLIMIT_NPROC);

    /* Create as many children as possible */

    for (j = 1; ; j++) {
        switch (childPid = fork()) {
        case -1: errExit("fork");

        case 0: _exit(EXIT_SUCCESS);            /* Child */

        default:        /* Parent: display message about each new child
                           and let the resulting zombies accumulate */
            printf("Child %d (PID=%ld) started\n", j, (long) childPid);
            break;
        }
    }
}
     <strong class="userinput"><code>procres/rlimit_nproc.c</code></strong></pre></div></div></div><div class="sect3" title="Unrepresentable limit values"><div class="titlepage"><div><div><h4 class="title" id="unrepresentable_limit_values">Unrepresentable limit values</h4></div></div></div><p>In some programming environments, the <span class="emphasis"><em>rlim_t</em></span> data
                        type may not be able to represent the full range of values that could be
                        maintained for a particular resource limit. This may be the case on a system
                        that offers multiple programming environments in which the size of the
                            <span class="emphasis"><em>rlim_t</em></span> data type differs. Such systems can arise if
                        a large-file compilation environment with a 64-bit
                            <span class="emphasis"><em>off_t</em></span> is added to a system on which
                            <span class="emphasis"><em>off_t</em></span> was traditionally 32 bits. (In each
                        environment, <span class="emphasis"><em>rlim_t</em></span> would be the same size as
                            <span class="emphasis"><em>off_t</em></span>.) This leads to the situation where a program
                        with a small <span class="emphasis"><em>rlim_t</em></span> can, after being execed by a
                        program with a 64-bit <span class="emphasis"><em>off_t</em></span>, inherit a resource limit
                        (e.g., the file size limit) that is greater than the maximum
                            <span class="emphasis"><em>rlim_t</em></span> value.<a id="IDX-CHP-36-5285" class="indexterm"/><a id="IDX-CHP-36-5286" class="indexterm"/><a id="IDX-CHP-36-5287" class="indexterm"/><a id="IDX-CHP-36-5288" class="indexterm"/><a id="IDX-CHP-36-5289" class="indexterm"/><a id="IDX-CHP-36-5290" class="indexterm"/><a id="IDX-CHP-36-5291" class="indexterm"/></p><p>To assist portable applications in handling the possibility that a
                        resource limit may be unrepresentable, SUSv3 specifies two constants to
                        indicate unrepresentable limit values: <code class="literal">RLIM_SAVED_CUR</code> and <code class="literal">RLIM_SAVED_MAX</code>. If a soft resource limit can’t be represented
                        in <span class="emphasis"><em>rlim_t</em></span>, then <span class="emphasis"><em>getrlimit()</em></span> will
                        return <code class="literal">RLIM_SAVED_CUR</code> in the
                            <span class="emphasis"><em>rlim_cur</em></span> field. <code class="literal">RLIM_SAVED_MAX</code> performs an analogous function for an
                        unrepresentable hard limit returned in the <span class="emphasis"><em>rlim_max</em></span>
                            field.<a id="IDX-CHP-36-5292" class="indexterm"/><a id="IDX-CHP-36-5293" class="indexterm"/></p><p>If all possible resource limit values can be represented in
                            <span class="emphasis"><em>rlim_t</em></span>, then SUSv3 permits an implementation to
                        define <code class="literal">RLIM_SAVED_CUR</code> and <code class="literal">RLIM_SAVED_MAX</code> to be the same as <code class="literal">RLIM_INFINITY</code>. This is how these constants are
                        defined on Linux, implying that all possible resource limit values can be
                        represented in <span class="emphasis"><em>rlim_t</em></span>. However, this is not the case on
                        32-bit architectures such as x86-32. On those architectures, in a large-file
                        compilation environment (i.e., setting the <code class="literal">_FILE_OFFSET_BITS</code> feature test macro to 64 as described in
                            <a class="xref" href="ch05.html#i_solidus_o_on_large_files" title="I/O on Large Files">I/O on Large Files</a>), the
                            <span class="emphasis"><em>glibc</em></span> definition of <span class="emphasis"><em>rlim_t</em></span> is
                        64 bits wide, but the kernel data type for representing a resource limit is
                            <span class="emphasis"><em>unsigned long</em></span>, which is only 32 bits wide. Current
                        versions of <span class="emphasis"><em>glibc</em></span> deal with this situation as follows:
                        if a program compiled with <code class="literal">_FILE_OFFSET_BITS=64</code> tries to set a resource limit to a value
                        larger than can be represented in a 32-bit <span class="emphasis"><em>unsigned
                            long</em></span>, then the <span class="emphasis"><em>glibc</em></span> wrapper for
                            <span class="emphasis"><em>setrlimit()</em></span> silently converts the value to <code class="literal">RLIM_INFINITY</code>. In other words, the requested
                        setting of the resource limit is not honored.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Because utilities that handle files are normally compiled with
                                <code class="literal">_FILE_OFFSET_BITS=64</code> in many
                            x86-32 distributions, the failure to honor resource limits larger than
                            the value that can be represented in 32 bits is a problem that can
                            affect not only application programmers, but also end users.</p><p>One could argue that it might be better for the <span class="emphasis"><em>glibc
                                setrlimit()</em></span> wrapper to give an error if the requested
                            resource limit exceeds the capacity of a 32-bit <span class="emphasis"><em>unsigned
                                long</em></span>. However, the fundamental problem is a kernel
                            limitation, and the behavior described in the main text is the approach
                            that the <span class="emphasis"><em>glibc</em></span> developers have taken to dealing
                            with it.</p></div></div></div></div><div class="sect1" title="Details of Specific Resource Limits"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="details_of_specific_resource_limits">Details of Specific Resource Limits</h2></div></div></div><p>In this section, we provide details on each of the resource limits available on
                Linux, noting those that are Linux-specific.<a id="IDX-CHP-36-5294" class="indexterm"/><a id="IDX-CHP-36-5295" class="indexterm"/><a id="IDX-CHP-36-5296" class="indexterm"/><a id="IDX-CHP-36-5297" class="indexterm"/><a id="IDX-CHP-36-5298" class="indexterm"/><a id="IDX-CHP-36-5299" class="indexterm"/><a id="IDX-CHP-36-5300" class="indexterm"/><a id="IDX-CHP-36-5301" class="indexterm"/><a id="IDX-CHP-36-5302" class="indexterm"/><a id="IDX-CHP-36-5303" class="indexterm"/><a id="IDX-CHP-36-5304" class="indexterm"/><a id="IDX-CHP-36-5305" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="rlimit_underscore_as"/></div></div></div><div class="sect3" title="RLIMIT_AS"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_as-id1">
                        <code class="literal">RLIMIT_AS</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_AS</code> limit specifies the
                        maximum size for the process’s virtual memory (address space), in bytes.
                        Attempts (<span class="emphasis"><em>brk()</em></span>, <span class="emphasis"><em>sbrk()</em></span>,
                            <span class="emphasis"><em>mmap()</em></span>, <span class="emphasis"><em>mremap()</em></span>, and
                            <span class="emphasis"><em>shmat()</em></span>) to exceed this limit fail with the error
                            <code class="literal">ENOMEM</code>. In practice, the most common
                        place where a program may hit this limit is in calls to functions in the
                            <span class="emphasis"><em>malloc</em></span> package, which make use of
                            <span class="emphasis"><em>sbrk()</em></span> and <span class="emphasis"><em>mmap()</em></span>. Upon
                        encountering this limit, stack growth can also fail with the consequences
                        listed below for <code class="literal">RLIMIT_STACK</code>.</p></div><div class="sect3" title="RLIMIT_CORE"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_core">
                        <code class="literal">RLIMIT_CORE</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_CORE</code> limit specifies the
                        maximum size, in bytes, for core dump files produced when a process is
                        terminated by certain signals (<a class="xref" href="ch22.html#core_dump_files" title="Core Dump Files">Core Dump Files</a>).
                        Production of a core dump file will stop at this limit. Specifying a limit
                        of 0 prevents creation of core dump files, which is sometimes useful because
                        core dump files can be very large, and end users usually don’t know what to
                        do with them. Another reason for disabling core dumps is security—to prevent
                        the contents of a program’s memory from being dumped to disk. If the
                            <code class="literal">RLIMIT_FSIZE</code> limit is lower than this
                        limit, core dump files are limited to <code class="literal">RLIMIT_FSIZE</code> bytes.</p></div><div class="sect3" title="RLIMIT_CPU"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_cpu">
                        <code class="literal">RLIMIT_CPU</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_CPU</code> limit specifies the
                        maximum number of seconds of CPU time (in both system and user mode) that
                        can be used by the process. SUSv3 requires that the <code class="literal">SIGXCPU</code> signal be sent to the process when the soft limit is
                        reached, but leaves other details unspecified. (The default action for
                            <code class="literal">SIGXCPU</code> is to terminate a process
                        with a core dump.) It is possible to establish a handler for <code class="literal">SIGXCPU</code> that does whatever processing is
                        desired and then returns control to the main program. Thereafter, (on Linux)
                            <code class="literal">SIGXCPU</code> is sent once per second of
                        consumed CPU time. If the process continues executing until the hard CPU
                        limit is reached, then the kernel sends it a <code class="literal">SIGKILL</code> signal, which always terminates the
                            process.<a id="IDX-CHP-36-5306" class="indexterm"/><a id="IDX-CHP-36-5307" class="indexterm"/></p><p>UNIX implementations vary in the details of how they deal with processes
                        that continue consuming CPU time after handling a <code class="literal">SIGXCPU</code> signal. Most continue to deliver <code class="literal">SIGXCPU</code> at regular intervals. If aiming for
                        portable use of this signal, we should code an application so that, on first
                        receipt of this signal, it does whatever cleanup is required and terminates.
                        (Alternatively, the program could change the resource limit after receiving
                        the signal.)</p></div><div class="sect3" title="RLIMIT_DATA"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_data">
                        <code class="literal">RLIMIT_DATA</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_DATA</code> limit specifies the
                        maximum size, in bytes, of the process’s data segment (the sum of the
                        initialized data, uninitialized data, and heap segments described in <a class="xref" href="ch06.html#memory_layout_of_a_process" title="Memory Layout of a Process">Memory Layout of a Process</a>). Attempts
                            (<span class="emphasis"><em>sbrk()</em></span> and <span class="emphasis"><em>brk()</em></span>) to extend
                        the data segment (program break) beyond this limit fail with the error
                            <code class="literal">ENOMEM</code>. As with <code class="literal">RLIMIT_AS</code>, the most common place where a
                        program may hit this limit is in calls to functions in the
                            <span class="emphasis"><em>malloc</em></span> package.<a id="IDX-CHP-36-5308" class="indexterm"/><a id="IDX-CHP-36-5309" class="indexterm"/><a id="IDX-CHP-36-5310" class="indexterm"/><a id="IDX-CHP-36-5311" class="indexterm"/><a id="IDX-CHP-36-5312" class="indexterm"/><a id="IDX-CHP-36-5313" class="indexterm"/><a id="IDX-CHP-36-5314" class="indexterm"/><a id="IDX-CHP-36-5315" class="indexterm"/><a id="IDX-CHP-36-5316" class="indexterm"/><a id="IDX-CHP-36-5317" class="indexterm"/><a id="IDX-CHP-36-5318" class="indexterm"/><a id="IDX-CHP-36-5319" class="indexterm"/><a id="IDX-CHP-36-5320" class="indexterm"/><a id="IDX-CHP-36-5321" class="indexterm"/><a id="IDX-CHP-36-5322" class="indexterm"/><a id="IDX-CHP-36-5323" class="indexterm"/><a id="IDX-CHP-36-5324" class="indexterm"/><a id="IDX-CHP-36-5325" class="indexterm"/><a id="IDX-CHP-36-5326" class="indexterm"/><a id="IDX-CHP-36-5327" class="indexterm"/><a id="IDX-CHP-36-5328" class="indexterm"/><a id="IDX-CHP-36-5329" class="indexterm"/><a id="IDX-CHP-36-5330" class="indexterm"/></p></div><div class="sect3" title="RLIMIT_FSIZE"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_fsize">
                        <code class="literal">RLIMIT_FSIZE</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_FSIZE</code> limit specifies the
                        maximum size of files that the process may create, in bytes. If a process
                        attempts to extend a file beyond the soft limit, it is sent a <code class="literal">SIGXFSZ</code> signal, and the system call (e.g.,
                            <span class="emphasis"><em>write()</em></span> or <span class="emphasis"><em>truncate()</em></span>) fails
                        with the error <code class="literal">EFBIG</code>. The default action
                        for <code class="literal">SIGXFSZ</code> is to terminate a process and
                        produce a core dump. It is possible to instead catch this signal and return
                        control to the main program. However, any further attempt to extend the file
                        will yield the same signal and error.<a id="IDX-CHP-36-5331" class="indexterm"/></p></div><div class="sect3" title="RLIMIT_MEMLOCK"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_memlock">
                        <code class="literal">RLIMIT_MEMLOCK</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_MEMLOCK</code> limit (BSD-derived;
                        absent from SUSv3 and available only on Linux and the BSDs) specifies the
                        maximum number of bytes of virtual memory that a process may lock into
                        physical memory, to prevent the memory from being swapped out. This limit
                        affects the <span class="emphasis"><em>mlock()</em></span> and <span class="emphasis"><em>mlockall()</em></span>
                        system calls, and the locking options for the <span class="emphasis"><em>mmap()</em></span>
                        and <span class="emphasis"><em>shmctl()</em></span> system calls. We describe the details in
                        Section 50.2.<a id="IDX-CHP-36-5332" class="indexterm"/><a id="IDX-CHP-36-5333" class="indexterm"/></p><p>If the <code class="literal">MCL_FUTURE</code> flag is specified
                        when calling <span class="emphasis"><em>mlockall()</em></span>, then the <code class="literal">RLIMIT_MEMLOCK</code> limit may also cause later
                        calls to <span class="emphasis"><em>brk()</em></span>, <span class="emphasis"><em>sbrk()</em></span>,
                            <span class="emphasis"><em>mmap()</em></span>, or <span class="emphasis"><em>mremap()</em></span> to
                            fail.<a id="IDX-CHP-36-5334" class="indexterm"/></p></div><div class="sect3" title="RLIMIT_MSGQUEUE"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_msgqueue">
                        <code class="literal">RLIMIT_MSGQUEUE</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_MSGQUEUE</code> limit
                        (Linux-specific; since Linux 2.6.8) specifies the maximum number of bytes
                        that can be allocated for POSIX message queues for the real user ID of the
                        calling process. When a POSIX message queue is created using
                            <span class="emphasis"><em>mq_open()</em></span>, bytes are deducted against this limit
                        according to the following formula:</p><a id="I_programlisting36_d1e100641"/><pre class="programlisting">bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +
        attr.mq_maxmsg * attr.mq_msgsize;</pre><p>In this formula, <span class="emphasis"><em>attr</em></span> is the
                            <span class="emphasis"><em>mq_attr</em></span> structure that is passed as the fourth
                        argument to <span class="emphasis"><em>mq_open()</em></span>. The addend that includes
                            <span class="emphasis"><em>sizeof(struct msg_msg *)</em></span> ensures that the user
                        can’t queue an unlimited number of zero-length messages. (The
                            <span class="emphasis"><em>msg_msg</em></span> structure is a data type used internally by
                        the kernel.) This is necessary because, although zero-length messages
                        contain no data, they do consume some system memory for bookkeeping
                        overhead.</p><p>The <code class="literal">RLIMIT_MSGQUEUE</code> limit affects only
                        the calling process. Other processes belonging to this user are not affected
                        unless they also set this limit or inherit it.</p></div><div class="sect3" title="RLIMIT_NICE"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_nice">
                        <code class="literal">RLIMIT_NICE</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_NICE</code> limit (Linux-specific;
                        since Linux 2.6.12) specifies a ceiling on the nice value that may be set
                        for this process using <span class="emphasis"><em>sched_setscheduler()</em></span> and
                            <span class="emphasis"><em>nice()</em></span>. The ceiling is calculated as <span class="emphasis"><em>20 –
                            rlim_cur</em></span>, where <span class="emphasis"><em>rlim_cur</em></span> is the current
                            <code class="literal">RLIMIT_NICE</code> soft resource limit.
                        Refer to <a class="xref" href="ch35.html#process_priorities_open_parenthesis_nice" title="Process Priorities (Nice Values)">Process Priorities (Nice Values)</a> for
                        further details.<a id="IDX-CHP-36-5335" class="indexterm"/><a id="IDX-CHP-36-5336" class="indexterm"/><a id="IDX-CHP-36-5337" class="indexterm"/><a id="IDX-CHP-36-5338" class="indexterm"/><a id="IDX-CHP-36-5339" class="indexterm"/><a id="IDX-CHP-36-5340" class="indexterm"/><a id="IDX-CHP-36-5341" class="indexterm"/><a id="IDX-CHP-36-5342" class="indexterm"/><a id="IDX-CHP-36-5343" class="indexterm"/><a id="IDX-CHP-36-5344" class="indexterm"/><a id="IDX-CHP-36-5345" class="indexterm"/><a id="IDX-CHP-36-5346" class="indexterm"/><a id="IDX-CHP-36-5347" class="indexterm"/><a id="IDX-CHP-36-5348" class="indexterm"/><a id="IDX-CHP-36-5349" class="indexterm"/><a id="IDX-CHP-36-5350" class="indexterm"/><a id="IDX-CHP-36-5351" class="indexterm"/><a id="IDX-CHP-36-5352" class="indexterm"/><a id="IDX-CHP-36-5353" class="indexterm"/><a id="IDX-CHP-36-5354" class="indexterm"/><a id="IDX-CHP-36-5355" class="indexterm"/></p></div><div class="sect3" title="RLIMIT_NOFILE"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_nofile">
                        <code class="literal">RLIMIT_NOFILE</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_NOFILE</code> limit specifies a
                        number one greater than the maximum file descriptor number that a process
                        may allocate. Attempts (e.g., <span class="emphasis"><em>open()</em></span>,
                            <span class="emphasis"><em>pipe()</em></span>, <span class="emphasis"><em>socket()</em></span>,
                            <span class="emphasis"><em>accept()</em></span>, <span class="emphasis"><em>shm_open()</em></span>,
                            <span class="emphasis"><em>dup()</em></span>, <span class="emphasis"><em>dup2()</em></span>,
                            <span class="emphasis"><em>fcntl(F_DUPFD)</em></span>, and
                            <span class="emphasis"><em>epoll_create()</em></span>) to allocate descriptors beyond this
                        limit fail. In most cases, the error is <code class="literal">EMFILE</code>, but for <span class="emphasis"><em>dup2(fd, newfd)</em></span> it is
                            <code class="literal">EBADF</code>, and for <span class="emphasis"><em>fcntl(fd,
                            F_DUPFD, newfd)</em></span> with <span class="emphasis"><em>newfd</em></span> is greater
                        than or equal to the limit, it is <code class="literal">EINVAL</code>.</p><p>Changes to the <code class="literal">RLIMIT_NOFILE</code> limit are
                        reflected in the value returned by
                            <span class="emphasis"><em>sysconf(_SC_OPEN_MAX)</em></span>. SUSv3 permits, but doesn’t
                        require, an implementation to return different values for a call to
                            <span class="emphasis"><em>sysconf(_SC_OPEN_MAX)</em></span> before and after changing the
                            <code class="literal">RLIMIT_NOFILE</code> limit; other
                        implementations may not behave the same as Linux on this point.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 states that if an application sets the soft or hard <code class="literal">RLIMIT_NOFILE</code> limit to a value less than
                            or equal to the number of the highest file descriptor that the process
                            currently has open, unexpected behavior may occur.</p><p>On Linux, we can check which file descriptors a process currently has
                            open by using <span class="emphasis"><em>readdir()</em></span> to scan the contents of the
                                <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/fd</code> directory, which contains symbolic links for each of
                            the file descriptors currently opened by the process.<a id="IDX-CHP-36-5356" class="indexterm"/></p></div><p>The kernel imposes a ceiling on the value to which the <code class="literal">RLIMIT_NOFILE</code> limit may be raised. In kernels
                        before 2.6.25, this ceiling is a hard-coded value defined by the kernel
                        constant <code class="literal">NR_OPEN</code>, whose value is
                        1,048,576. (A kernel rebuild is required to raise this ceiling.) Since
                        kernel 2.6.25, the limit is defined by the value in the Linux-specific
                            <code class="literal">/proc/sys/fs/nr_open</code> file. The
                        default value in this file is 1,048,576; this can be modified by the
                        superuser. Attempts to set the soft or hard <code class="literal">RLIMIT_NOFILE</code> limit higher than the ceiling value yield the
                        error <code class="literal">EPERM</code>.<a id="IDX-CHP-36-5357" class="indexterm"/></p><p>There is also a system-wide limit on the total number of files that may be
                        opened by all processes. This limit can be retrieved and modified via the
                        Linux-specific <code class="literal">/proc/sys/fs/file-max</code>
                        file. (Referring to <a class="xref" href="ch05.html#relationship_between_file_descriptors_an" title="Relationship Between File Descriptors and Open Files">Relationship Between File Descriptors and Open Files</a>, we can define <code class="literal">file-max</code> more precisely
                        as a system-wide limit on the number of open file descriptions.) Only
                        privileged (<code class="literal">CAP_SYS_ADMIN</code>) processes can
                        exceed the <code class="literal">file-max</code> limit. In an
                        unprivileged process, a system call that encounters the <code class="literal">file-max</code> limit fails with the error <code class="literal">ENFILE</code>.<a id="IDX-CHP-36-5358" class="indexterm"/></p></div><div class="sect3" title="RLIMIT_NPROC"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_nproc">
                        <code class="literal">RLIMIT_NPROC</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_NPROC</code> limit (BSD-derived;
                        absent from SUSv3 and available only on Linux and the BSDs) specifies the
                        maximum number of processes that may be created for the real user ID of the
                        calling process. Attempts (<span class="emphasis"><em>fork()</em></span>,
                            <span class="emphasis"><em>vfork()</em></span>, and <span class="emphasis"><em>clone()</em></span>) to
                        exceed this limit fail with the error <code class="literal">EAGAIN</code>.<a id="IDX-CHP-36-5359" class="indexterm"/><a id="IDX-CHP-36-5360" class="indexterm"/><a id="IDX-CHP-36-5361" class="indexterm"/><a id="IDX-CHP-36-5362" class="indexterm"/><a id="IDX-CHP-36-5363" class="indexterm"/><a id="IDX-CHP-36-5364" class="indexterm"/><a id="IDX-CHP-36-5365" class="indexterm"/><a id="IDX-CHP-36-5366" class="indexterm"/><a id="IDX-CHP-36-5367" class="indexterm"/><a id="IDX-CHP-36-5368" class="indexterm"/><a id="IDX-CHP-36-5369" class="indexterm"/></p><p>The <code class="literal">RLIMIT_NPROC</code> limit affects only the
                        calling process. Other processes belonging to this user are not affected
                        unless they also set or inherit this limit. This limit is not enforced for
                        privileged (<code class="literal">CAP_SYS_ADMIN</code> or <code class="literal">CAP_SYS_RESOURCE</code>) processes.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Linux also imposes a system-wide limit on the number of processes that
                            can be created by all users. On Linux 2.4 and later, the Linux-specific
                                <code class="literal">/proc/sys/kernel/threads-max</code> file
                            can be used to retrieve and modify this limit.<a id="IDX-CHP-36-5370" class="indexterm"/></p><p>To be precise, the <code class="literal">RLIMIT_NPROC</code>
                            resource limit and the <code class="literal">threads-max</code>
                            file are actually limits on the numbers of threads that can be created,
                            rather than the number of processes.<a id="IDX-CHP-36-5371" class="indexterm"/><a id="IDX-CHP-36-5372" class="indexterm"/><a id="IDX-CHP-36-5373" class="indexterm"/></p></div><p>The manner in which the default value for the <code class="literal">RLIMIT_NPROC</code> resource limit is set has varied across kernel
                        versions. In Linux 2.2, it was calculated according to a fixed formula. In
                        Linux 2.4 and later, it is calculated using a formula based on the amount of
                        available physical memory.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 doesn’t specify the <code class="literal">RLIMIT_NPROC</code> resource limit. The SUSv3-mandated method
                            for retrieving (but not changing) the maximum number of processes
                            permitted to a user ID is via the call
                                <span class="emphasis"><em>sysconf(_SC_CHILD_MAX)</em></span>. This
                                <span class="emphasis"><em>sysconf()</em></span> call is supported on Linux, but in
                            kernel versions before 2.6.23, the call does not return accurate
                            information—it always returns the value 999. Since Linux 2.6.23 (and
                            with <span class="emphasis"><em>glibc</em></span> 2.4 and later), this call correctly
                            reports the limit (by checking the value of the <code class="literal">RLIMIT_NPROC</code> resource limit).</p><p>There is no portable way of discovering how many processes have
                            already been created for a specific user ID. On Linux, we can try
                            scanning all of the <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/status</code> files on the system and examining the information
                            under the <code class="literal">Uid</code> entry (which lists the
                            four process user IDs in the order: real, effective, saved set, and file
                            system) in order to estimate the number of processes currently owned by
                            a user. Be aware, however, that by the time we have completed such a
                            scan, this information may already have changed.</p></div></div><div class="sect3" title="RLIMIT_RSS"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_rss">
                        <code class="literal">RLIMIT_RSS</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_RSS</code> limit (BSD-derived;
                        absent from SUSv3, but widely available) specifies the maximum number of
                        pages in the process’s resident set; that is, the total number of virtual
                        memory pages currently in physical memory. This limit is provided on Linux,
                        but it currently has no effect.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In older Linux 2.4 kernels (up to and including 2.4.29), <code class="literal">RLIMIT_RSS</code> did have an effect on the
                            behavior of the <span class="emphasis"><em>madvise()</em></span>
                            <code class="literal">MADV_WILLNEED</code> operation (<a class="xref" href="ch50.html#advising_future_memory_usage_patterns_co" title="Advising Future Memory Usage Patterns: madvise()">Advising Future Memory Usage Patterns: <span class="emphasis"><em>madvise()</em></span></a>). If this
                            operation could not be performed as a result of encountering the
                                <code class="literal">RLIMIT_RSS</code> limit, the error
                                <code class="literal">EIO</code> was returned in
                                <span class="emphasis"><em>errno</em></span>.</p></div></div><div class="sect3" title="RLIMIT_RTPRIO"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_rtprio">
                        <code class="literal">RLIMIT_RTPRIO</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_RTPRIO</code> limit
                        (Linux-specific; since Linux 2.6.12) specifies a ceiling on the realtime
                        priority that may be set for this process using
                            <span class="emphasis"><em>sched_setscheduler()</em></span> and
                            <span class="emphasis"><em>sched_setparam()</em></span>. Refer to <a class="xref" href="ch35.html#modifying_and_retrieving_policies_and_pr" title="Modifying and Retrieving Policies and Priorities">Modifying and Retrieving Policies and Priorities</a> for further
                            details.<a id="IDX-CHP-36-5374" class="indexterm"/><a id="IDX-CHP-36-5375" class="indexterm"/><a id="IDX-CHP-36-5376" class="indexterm"/><a id="IDX-CHP-36-5377" class="indexterm"/><a id="IDX-CHP-36-5378" class="indexterm"/><a id="IDX-CHP-36-5379" class="indexterm"/><a id="IDX-CHP-36-5380" class="indexterm"/><a id="IDX-CHP-36-5381" class="indexterm"/><a id="IDX-CHP-36-5382" class="indexterm"/><a id="IDX-CHP-36-5383" class="indexterm"/><a id="IDX-CHP-36-5384" class="indexterm"/><a id="IDX-CHP-36-5385" class="indexterm"/><a id="IDX-CHP-36-5386" class="indexterm"/><a id="IDX-CHP-36-5387" class="indexterm"/><a id="IDX-CHP-36-5388" class="indexterm"/><a id="IDX-CHP-36-5389" class="indexterm"/></p></div><div class="sect3" title="RLIMIT_RTTIME"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_rttime">
                        <code class="literal">RLIMIT_RTTIME</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_RTTIME</code> limit
                        (Linux-specific; since Linux 2.6.25) specifies the maximum amount of CPU
                        time in microseconds that a process running under a realtime scheduling
                        policy may consume without sleeping (i.e., performing a blocking system
                        call). The behavior if this limit is reached is the same as for <code class="literal">RLIMIT_CPU</code>: if the process reaches the soft
                        limit, then a <code class="literal">SIGXCPU</code> signal is sent to
                        the process, and further <code class="literal">SIGXCPU</code> signals
                        are sent for each additional second of CPU time consumed. On reaching the
                        hard limit, a <code class="literal">SIGKILL</code> signal is sent.
                        Refer to <a class="xref" href="ch35.html#modifying_and_retrieving_policies_and_pr" title="Modifying and Retrieving Policies and Priorities">Modifying and Retrieving Policies and Priorities</a> for
                        further details.<a id="IDX-CHP-36-5390" class="indexterm"/><a id="IDX-CHP-36-5391" class="indexterm"/></p></div><div class="sect3" title="RLIMIT_SIGPENDING"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_sigpending">
                        <code class="literal">RLIMIT_SIGPENDING</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_SIGPENDING</code> limit
                        (Linux-specific; since Linux 2.6.8) specifies the maximum number of signals
                        that may be queued for the real user ID of the calling process. Attempts
                            (<span class="emphasis"><em>sigqueue()</em></span>) to exceed this limit fail with the
                        error <code class="literal">EAGAIN</code>.</p><p>The <code class="literal">RLIMIT_SIGPENDING</code> limit affects
                        only the calling process. Other processes belonging to this user are not
                        affected unless they also set or inherit this limit.</p><p>As initially implemented, the default value for the <code class="literal">RLIMIT_SIGPENDING</code> limit was 1024. Since kernel
                        2.6.12, the default value has been changed to be the same as the default
                        value for <code class="literal">RLIMIT_NPROC</code>.</p><p>For the purposes of checking the <code class="literal">RLIMIT_SIGPENDING</code> limit, the count of queued signals includes
                        both realtime and standard signals. (Standard signals can be queued only
                        once to a process.) However, this limit is enforced only for
                            <span class="emphasis"><em>sigqueue()</em></span>. Even if the number of signals specified
                        by this limit has already been queued to processes belonging to this real
                        user ID, it is still possible to use <span class="emphasis"><em>kill()</em></span> to queue
                        one instance of each of the signals (including realtime signals) that are
                        not already queued to a process.</p><p>From kernel 2.6.12 onward, the <code class="literal">SigQ</code>
                        field of the Linux-specific <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/status</code> file displays the current and maximum number of
                        queued signals for the real user ID of the process.<a id="IDX-CHP-36-5392" class="indexterm"/></p></div><div class="sect3" title="RLIMIT_STACK"><div class="titlepage"><div><div><h4 class="title" id="rlimit_underscore_stack">
                        <code class="literal">RLIMIT_STACK</code>
                    </h4></div></div></div><p>The <code class="literal">RLIMIT_STACK</code> limit specifies the
                        maximum size of the process stack, in bytes. Attempts to grow the stack
                        beyond this limit result in the generation of a <code class="literal">SIGSEGV</code> signal for the process. Since the stack is exhausted,
                        the only way to catch this signal is by establishing an alternate signal
                        stack, as described in Section 21.3.<a id="IDX-CHP-36-5393" class="indexterm"/><a id="IDX-CHP-36-5394" class="indexterm"/><a id="IDX-CHP-36-5395" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since Linux 2.6.23, the <code class="literal">RLIMIT_STACK</code> limit also determines the amount of space
                            available for holding the process’s command-line arguments and
                            environment variables. See the <span class="emphasis"><em>execve(2)</em></span> manual
                            page for details.</p></div></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id35">Summary</h2></div></div></div><p>Processes consume various system resources. The <span class="emphasis"><em>getrusage()</em></span>
                system call allows a process to monitor certain of the resources consumed by itself
                and by its children.<a id="IDX-CHP-36-5396" class="indexterm"/></p><p>The <span class="emphasis"><em>setrlimit()</em></span> and <span class="emphasis"><em>getrlimit()</em></span> system
                calls allow a process to set and retrieve limits on its consumption of various
                resources. Each resource limit has two components: a soft limit, which is what the
                kernel enforces when checking a process’s resource consumption, and a hard limit,
                which acts as a ceiling on the value of the soft limit. An unprivileged process can
                set the soft limit for a resource to any value in the range from 0 up to the hard
                limit, but can only lower the hard limit. A privileged process can make any changes
                to either limit value, as long as the soft limit is less than or equal to the hard
                limit. If a process encounters a soft limit, it is typically informed of the fact
                either by receiving a signal or via failure of the system call that attempts to
                exceed the limit.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id24">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Write a program that shows that the <span class="emphasis"><em>getrusage()</em></span>
                        <code class="literal">RUSAGE_CHILDREN</code> flag retrieves
                        information about only the children for which a <span class="emphasis"><em>wait()</em></span>
                        call has been performed. (Have the program create a child process that
                        consumes some CPU time, and then have the parent call
                            <span class="emphasis"><em>getrusage()</em></span> before and after calling
                            <span class="emphasis"><em>wait()</em></span>.)<a id="IDX-CHP-36-5397" class="indexterm"/></p></li><li class="listitem"><p>Write a program that executes a command and then displays its resource
                        usage. This is analogous to what the <span class="emphasis"><em>time(1)</em></span> command
                        does. Thus, we would use this program as follows:</p><a id="I_programlisting36_d1e101477"/><pre class="programlisting">$ <strong class="userinput"><code>./rusage</code></strong> <strong class="userinput"><code><em class="replaceable"><code>command arg...</code></em></code></strong></pre></li><li class="listitem"><p>Write programs to determine what happens if a process’s consumption of
                        various resources already exceeds the soft limit specified in a call to
                            <span class="emphasis"><em>setrlimit()</em></span>.</p></li></ol></div></div></section></body></html>
