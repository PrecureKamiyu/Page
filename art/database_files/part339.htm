<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>18.11  Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part338.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part340.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">18.11  <span style=" color: #00AEEF;">Summary</span></p><p class="s39" style="padding-top: 9pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s40">When several transactions execute concurrently in the database, the consistency of data may no longer be preserved. It is necessary for the system to control the in-</span></p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">18.11 <span style=" color: #00AEEF;">Summary  </span><span class="s164">895</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">teraction among the concurrent transactions, and this control is achieved through one ofa variety of mechanisms called <i>concurrency-control </i>schemes.</p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">To ensure serializability, we can use various concurrency-control schemes. All these schemes either delay an operation or abort the transaction that issued the operation. The most common ones are locking protocols, timestamp-ordering schemes, validation techniques, and multiversion schemes.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">A locking protocol is a set of rules that state when a transaction may lock and unlock each of the data items in the database.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The two-phase locking protocol allows a transaction to lock a new data item only if that transaction has not yet unlocked any data item. The protocol ensures serial- izability, but not deadlock freedom. In the absence of information concerning the manner in which data items are accessed, the two-phase locking protocol is both necessary and suﬃcient for ensuring serializability.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The strict two-phase locking protocol permits release of exclusive locks only at the end of transaction, in order to ensure recoverability and cascadelessness of the resulting schedules. The rigorous two-phase locking protocol releases all locks only at the end of the transaction.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Various locking protocols do not guard against deadlocks. One way to prevent deadlock is to use an ordering of data items and to request locks in a sequence consistent with the ordering.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Another way to prevent deadlock is to use preemption and transaction rollbacks. To control the preemption, we assign a unique timestamp to each transaction. The system uses these timestamps to decide whether a transaction should wait or roll back. The wound– wait scheme is a preemptive scheme.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">If deadlocks are not prevented, the system must deal with them by using a deadlock detection and recovery scheme. To do so, the system constructs a wait-for graph. A system is in a deadlock state if and only if the wait-for graph contains a cycle. When the deadlock detection algorithm determines that a deadlock exists, the system rolls back one or more transactions to break the deadlock.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">There are circumstances where it would be advantageous to group several data items and to treat them as one aggregate data item for purposes of working, re- sulting in multiple levels of granularity. We allow data items of various sizes, and we deﬁne a hierarchy of data items where the small items are nested within larger ones. Such a hierarchy can be represented graphically as a tree. In such multi- granularity locking protocols, locks are acquired in root-to-leaf order; they are re- leased in leaf-to-root order. Intention lock modes are used at higher levels to get better concurrency, without aﬀecting serializability.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">A timestamp-ordering scheme ensures serializability by selecting an ordering in advance between every pair of transactions. A unique ﬁxed timestamp is associated with each transaction in the system. The timestamps of the transactions determine the serializability order. Thus, if the timestamp of transaction </span><span class="s13">T</span><span class="s97">i </span><span class="p">is smaller than the</span></p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 79%;text-align: left;">timestamp of transaction <i>T</i><span class="s97">j </span>, then the scheme ensures that the produced schedule</p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 13pt;text-align: left;">is equivalent to a serial schedule in which transaction <i>T</i><span class="s145">i </span>appears before transaction</p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;line-height: 14pt;text-align: left;">T<span class="s145">j </span><span class="p">. It does so by rolling back a transaction whenever such an order is violated.</span></p><p class="s39" style="padding-top: 1pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">A validation scheme is an appropriate concurrency-control method in cases where a majority of transactions are read-only transactions, and thus the rate of conﬂicts among these transactions is low. A unique ﬁxed timestamp is associated with each transaction in the system. The serializability order is determined by the timestamp of the transaction. A transaction in this scheme is never delayed. It must, however, pass a validation test to complete. If it does not pass the validation test, the system rolls it back to its initial state.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">A multiversion concurrency-control scheme is based on the creation of a new ver- sion of a data item for each transaction that writes that item. When a read opera- tion is issued, the system selects one of the versions to be read. The concurrency- control scheme ensures that the version to be read is selected in a manner that ensures serializability by using timestamps. A read operation always succeeds.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s50" style="padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: left;">° <span class="s51">In multiversion timestamp ordering, a write operation may result in the rollback of the transaction.</span></p><p class="s50" style="padding-top: 8pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: left;">° <span class="s51">In multiversion two-phase locking, write operations may result in a lock wait or, possibly, in deadlock.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Snapshot isolation is a multiversion concurrency-control protocol based on valida- tion, which, unlike multiversion two-phase locking, does not require transactions to be declared as read-only or update. Snapshot isolation does not guarantee se- rializability but is nevertheless supported by many database systems. Serializable snapshot isolation is an extension of snapshot isolation which guarantees serializ- ability.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">A </span><span class="s46">delete </span><span class="p">operation may be performed only if the transaction deleting the tuple has an exclusive lock on the tuple to be deleted. A transaction that inserts a new tuple into the database is given an exclusive lock on the tuple.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Insertions can lead to the phantom phenomenon, in which an insertion logically conﬂicts with a query even though the two transactions may access no tuple in common. Such conﬂict cannot be detected if locking is done only on tuples ac- cessed by the transactions. Locking is required on the data used to ﬁnd the tuples in the relation. The index-locking technique solves this problem by requiring locks on certain index nodes. These locks ensure that all conﬂicting transactions conﬂict on a real data item, rather than on a phantom.</span></p><p class="s64" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Review Terms  <span class="s164">897</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Weak levels of consistency are used in some applications where consistency of query results is not critical, and using serializability would result in queries adversely aﬀecting transaction processing. Degree-two consistency is one such weaker level of consistency; cursor stability is a special case of degree-two con- sistency and is widely used.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Concurrency control is a challenging task for transactions that span user interac- tions. Applications often implement a scheme based on validation of writes using version numbers stored in tuples; this scheme provides a weak level of serializabil- ity and can be implemented at the application level without modiﬁcations to the database.</span></p><p class="s181" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">Special concurrency-control techniques can be developed for special data struc- tures. Often, special techniques are applied in B</span>+<span class="p">-trees to allow greater concur- rency. These techniques allow nonserializable access to the B</span>+<span class="p">-tree, but they en- sure that the B</span>+<span class="p">-tree structure is correct, and they ensure that accesses to the database itself are serializable. Latch-free data structures are used to implement high-performance indices and other data structures in main-memory databases.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part338.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part340.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
