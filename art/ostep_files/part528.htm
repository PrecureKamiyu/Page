<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>48.9 The Cache Consistency Problem</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part527.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part529.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">48.9 The Cache Consistency Problem</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The cache consistency problem is best illustrated with two clients and a single server. Imagine client C1 reads a file F, and keeps a copy of the file in its local cache. Now imagine a different client, C2, overwrites the file F, thus changing its contents; let’s call the new version of the file F</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 4pt;text-indent: 0pt;text-align: center;">C1</p><p class="s91" style="padding-left: 4pt;text-indent: 0pt;text-align: center;">cache: F[v1]</p><p class="s91" style="padding-top: 4pt;padding-left: 4pt;text-indent: 0pt;text-align: center;">C2</p><p class="s91" style="padding-left: 4pt;text-indent: 0pt;text-align: center;">cache: F[v2]</p><p class="s91" style="padding-top: 4pt;padding-left: 4pt;text-indent: 0pt;text-align: center;">C3</p><p class="s91" style="padding-left: 4pt;text-indent: 0pt;text-align: center;">cache: empty</p><p class="s72" style="padding-left: 103pt;text-indent: 0pt;text-align: left;">		</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 16pt;text-indent: 12pt;line-height: 112%;text-align: left;">Server S disk: F[v1] at first</p><p class="s91" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">F[v2] eventually</p><p style="padding-left: 170pt;text-indent: 0pt;text-align: left;"/><p style="padding-top: 4pt;padding-left: 122pt;text-indent: 0pt;text-align: left;">Figure 48.6: <b>The Cache Consistency Problem</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">(version 2), or F[v2] and the old version F[v1] so we can keep the two distinct (but of course the file has the same name, just different contents). Finally, there is a third client, C3, which has not yet accessed the file F.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">You can probably see the problem that is upcoming (Figure <span style=" color: #00AEEF;">48.6</span>). In fact, there are two subproblems. The first subproblem is that the client C2 may buffer its writes in its cache for a time before propagating them to the server; in this case, while F[v2] sits in C2’s memory, any access of F from another client (say C3) will fetch the old version of the file (F[v1]). Thus, by buffering writes at the client, other clients may get stale versions of the file, which may be undesirable; indeed, imagine the case where you log into machine C2, update F, and then log into C3 and try to read the file, only to get the old copy! Certainly this could be frustrating. Thus, let us call this aspect of the cache consistency problem <b>update visibility</b>; when do updates from one client become visible at other clients?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The second subproblem of cache consistency is a <b>stale cache</b>; in this case, C2 has finally flushed its writes to the file server, and thus the server has the latest version (F[v2]). However, C1 still has F[v1] in its cache; if a program running on C1 reads file F, it will get a stale version (F[v1]) and not the most recent copy (F[v2]), which is (often) undesirable.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">NFSv2 implementations solve these cache consistency problems in two ways. First, to address update visibility, clients implement what is some- times called <b>flush-on-close </b>(a.k.a., <b>close-to-open</b>) consistency semantics; specifically, when a file is written to and subsequently closed by a client application, the client flushes all updates (i.e., dirty pages in the cache) to the server. With flush-on-close consistency, NFS ensures that a subse- quent open from another node will see the latest file version.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Second, to address the stale-cache problem, NFSv2 clients first check to see whether a file has changed before using its cached contents. Specifi- cally, when opening a file, the client-side file system will issue a GETATTR request to the server to fetch the file’s attributes. The attributes, impor- tantly, include information as to when the file was last modified on the server; if the time-of-modification is more recent than the time that the file was fetched into the client cache, the client <b>invalidates </b>the file, thus removing it from the client cache and ensuring that subsequent reads will go to the server and retrieve the latest version of the file. If, on the other</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">hand, the client sees that it has the latest version of the file, it will go ahead and use the cached contents, thus increasing performance.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">When the original team at Sun implemented this solution to the stale- cache problem, they realized a new problem; suddenly, the NFS server was flooded with GETATTR requests. A good engineering principle to follow is to design for the <b>common case</b>, and to make it work well; here, although the common case was that a file was accessed only from a sin- gle client (perhaps repeatedly), the client always had to send GETATTR requests to the server to make sure no one else had changed the file. A client thus bombards the server, constantly asking “has anyone changed this file?”, when most of the time no one had.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To remedy this situation (somewhat), an <b>attribute cache </b>was added to each client. A client would still validate a file before accessing it, but most often would just look in the attribute cache to fetch the attributes. The attributes for a particular file were placed in the cache when the file was first accessed, and then would timeout after a certain amount of time (say 3 seconds). Thus, during those three seconds, all file accesses would determine that it was OK to use the cached file and thus do so with no network communication with the server.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part527.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part529.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
