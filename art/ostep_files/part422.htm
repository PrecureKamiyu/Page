<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>39.6 Writing Immediately with fsync()</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part421.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part423.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">39.6 Writing Immediately with <span class="s51">fsync()</span></p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Most times when a program calls <span class="s41">write()</span>, it is just telling the file system: please write this data to persistent storage, at some point in the future. The file system, for performance reasons, will <b>buffer </b>such writes in memory for some time (say 5 seconds, or 30); at that later point in time, the write(s) will actually be issued to the storage device. From the perspective of the calling application, writes seem to complete quickly, and only in rare cases (e.g., the machine crashes after the <span class="s41">write() </span>call but before the write to disk) will data be lost.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">However, some applications require something more than this even- tual guarantee. For example, in a database management system (DBMS), development of a correct recovery protocol requires the ability to force writes to disk from time to time.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To support these types of applications, most file systems provide some additional control APIs. In the U<span class="s7">NIX </span>world, the interface provided to ap- plications is known as <span class="s41">fsync(int fd)</span>. When a process calls <span class="s41">fsync() </span>for a particular file descriptor, the file system responds by forcing all <b>dirty </b>(i.e., not yet written) data to disk, for the file referred to by the specified</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: justify;">file descriptor. The <span class="s41">fsync() </span>routine returns once all of these writes are complete.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">Here is a simple example of how to use <span class="s41">fsync()</span>. The code opens the file <span class="s41">foo</span>, writes a single chunk of data to it, and then calls <span class="s41">fsync() </span>to ensure the writes are forced immediately to disk. Once the <span class="s41">fsync() </span>returns, the application can safely move on, knowing that the data has been persisted (if <span class="s41">fsync() </span>is correctly implemented, that is).</p><p class="s38" style="padding-top: 7pt;padding-left: 77pt;text-indent: 0pt;text-align: left;">int fd = open(&quot;foo&quot;, O_CREAT | O_WRONLY | O_TRUNC); assert(fd &gt; -1);</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">int rc = write(fd, buffer, size); assert(rc == size);</p><p class="s38" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">rc = fsync(fd); assert(rc == 0);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Interestingly, this sequence does not guarantee everything that you might expect; in some cases, you also need to <span class="s41">fsync() </span>the directory that contains the file <span class="s41">foo</span>. Adding this step ensures not only that the file itself is on disk, but that the file, if newly created, also is durably a part of the directory. Not surprisingly, this type of detail is often overlooked, leading to many application-level bugs [P+13].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part421.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part423.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
