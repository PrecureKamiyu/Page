<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>SSTF: Shortest Seek Time First</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part386.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part388.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">SSTF: Shortest Seek Time First</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">One early disk scheduling approach is known as <b>shortest-seek-time-first </b>(<b>SSTF</b>) (also called <b>shortest-seek-first </b>or <b>SSF</b>). SSTF orders the queue of I/O requests by track, picking requests on the nearest track to complete first. For example, assuming the current position of the head is over the inner track, and we have requests for sectors 21 (middle track) and 2 (outer track), we would then issue the request to 21 first, wait for it to complete, and then issue the request to 2 (Figure <span style=" color: #00AEEF;">37.5</span>).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">SSTF works well in this example, seeking to the middle track first and then the outer track. However, SSTF is not a panacea, for the following reasons. First, the drive geometry is not available to the host OS; rather, it sees an array of blocks. Fortunately, this problem is rather easily fixed. Instead of SSTF, an OS can simply implement <b>nearest-block-first </b>(<b>NBF</b>), which schedules the request with the nearest block address next.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The second problem is more fundamental: <b>starvation</b>. Imagine in our example above if there were a steady stream of requests to the in- ner track, where the head currently is positioned. Requests to any other tracks would then be ignored completely by a pure SSTF approach. And thus the crux of the problem:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 64pt;text-indent: 0pt;line-height: 11pt;text-align: left;">C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>H<span class="s7">ANDLE </span>D<span class="s7">ISK </span>S<span class="s7">TARVATION</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 11pt;text-align: left;">How can we implement SSTF-like scheduling but avoid starvation?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part386.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part388.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
