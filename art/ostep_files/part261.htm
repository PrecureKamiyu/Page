<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Concurrency: An Introduction</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part260.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part262.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 142pt;text-indent: 0pt;text-align: left;">Concurrency: An Introduction</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Thus far, we have seen the development of the basic abstractions that the OS performs. We have seen how to take a single physical CPU and turn it into multiple <b>virtual CPUs</b>, thus enabling the illusion of multiple pro- grams running at the same time. We have also seen how to create the illusion of a large, private <b>virtual memory </b>for each process; this abstrac- tion of the <b>address space </b>enables each program to behave as if it has its own memory when indeed the OS is secretly multiplexing address spaces across physical memory (and sometimes, disk).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In this note, we introduce a new abstraction for a single running pro- cess: that of a <b>thread</b>. Instead of our classic view of a single point of execution within a program (i.e., a single PC where instructions are be- ing fetched from and executed), a <b>multi-threaded </b>program has more than one point of execution (i.e., multiple PCs, each of which is being fetched and executed from). Perhaps another way to think of this is that each thread is very much like a separate process, except for one difference: they <i>share </i>the same address space and thus can access the same data.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The state of a single thread is thus very similar to that of a process. It has a program counter (PC) that tracks where the program is fetch- ing instructions from. Each thread has its own private set of registers it uses for computation; thus, if there are two threads that are running on a single processor, when switching from running one (T1) to running the other (T2), a <b>context switch </b>must take place. The context switch between threads is quite similar to the context switch between processes, as the register state of T1 must be saved and the register state of T2 restored before running T2. With processes, we saved state to a <b>process control block (PCB)</b>; now, we’ll need one or more <b>thread control blocks (TCBs) </b>to store the state of each thread of a process. There is one major difference, though, in the context switch we perform between threads as compared to processes: the address space remains the same (i.e., there is no need to switch which page table we are using).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One other major difference between threads and processes concerns the stack. In our simple model of the address space of a classic process (which we can now call a <b>single-threaded </b>process), there is a single stack, usually residing at the bottom of the address space (Figure <span style=" color: #00AEEF;">26.1</span>, left).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">0KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">1KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">2KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">15KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 38pt;text-indent: 0pt;text-align: right;">16KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 68pt;text-indent: 0pt;line-height: 92%;text-align: center;">the code segment: where instructions live</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="76" height="113" alt="image" src="Image_308.png"/></span></p><p class="s65" style="text-indent: 0pt;line-height: 6pt;text-align: left;">(free)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 20pt;text-indent: 0pt;text-align: center;">Stack</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 20pt;text-indent: 0pt;text-align: center;">Heap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">Program Code</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="padding-left: 72pt;text-indent: 0pt;line-height: 92%;text-align: center;">the heap segment: contains malloc’d data dynamic data structures (it grows downward)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-top: 3pt;padding-left: 71pt;text-indent: 0pt;line-height: 92%;text-align: center;">(it grows upward) the stack segment:</p><p class="s84" style="padding-left: 111pt;text-indent: 0pt;line-height: 92%;text-align: center;">contains local variables arguments to routines, return values, etc.</p><p class="s65" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">0KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="76" height="113" alt="image" src="Image_309.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 16pt;text-indent: 0pt;text-align: left;">Stack (1)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 20pt;text-indent: 0pt;text-align: center;">(free)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 16pt;text-indent: 0pt;text-align: left;">Stack (2)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 20pt;text-indent: 0pt;text-align: center;">(free)</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 20pt;text-indent: 0pt;text-align: center;">Heap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">Program Code</p><p style="text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">1KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">15KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">16KB</p><p style="padding-top: 1pt;padding-left: 118pt;text-indent: 0pt;text-align: left;">Figure 26.1: <b>A Single-Threaded Address Space</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">However, in a multi-threaded process, each thread runs independently and of course may call into various routines to do whatever work it is do- ing. Instead of a single stack in the address space, there will be one per thread. Let’s say we have a multi-threaded process that has two threads in it; the resulting address space looks different (Figure <span style=" color: #00AEEF;">26.1</span>, right).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this figure, you can see two stacks spread throughout the address space of the process. Thus, any stack-allocated variables, parameters, re- turn values, and other things that we put on the stack will be placed in what is sometimes called <b>thread-local </b>storage, i.e., the stack of the rele- vant thread.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">You might also notice how this ruins our beautiful address space lay- out. Before, the stack and heap could grow independently and trouble only arose when you ran out of room in the address space. Here, we no longer have such a nice situation. Fortunately, this is usually OK, as stacks do not generally have to be very large (the exception being in pro- grams that make heavy use of recursion).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part262.htm">26.1 An Example: Thread Creation</a><a class="toc0" href="part263.htm">26.2 Why It Gets Worse: Shared Data</a><a class="toc0" href="part264.htm">26.3 The Heart of the Problem: Uncontrolled Scheduling</a><a class="toc0" href="part265.htm">26.4 The Wish For Atomicity</a><a class="toc0" href="part266.htm">26.5 One More Problem: Waiting For Another</a><a class="toc0" href="part267.htm">26.6 Summary: Why in OS Class?</a><a class="toc0" href="part268.htm">References</a><a class="toc0" href="part269.htm">Homework</a><a class="toc1" href="part270.htm">Questions</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part260.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part262.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
