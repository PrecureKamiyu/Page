<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>26.5  Data Management in a Blockchain</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part465.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part467.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 13pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">26.5  <span style=" color: #00AEEF;">Data Management in a Blockchain</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Until now we have not been concerned about the eﬃciency of looking up information in a blockchain. While individual users can track their unspent transactions, that is not suﬃcient to validate a block. Each node needs to be able to check each transaction in a block to see if it was already spent. In principle, that could be done by searching the entire blockchain, but that is far too costly since it could involve searching backwards to the very ﬁrst block in the chain. In this section, we shall consider data structures to make such lookups eﬃcient.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Furthermore, not every blockchain uses a transaction model in which transac- tion inputs are restricted to be the direct output of other transactions. Some, notably Ethereum, allow for the maintenance of a state for each user (account, in Ethereum parlance) that holds the account balance (in the Ethereum currency, Ether) and some</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">associated storage. This transaction and data model comes closer to that of a database system. Simply storing this information in a database, however, would not preserve the blockchain properties we listed in Section 26.2. In this section, we consider this richer model and how it can be represented physically either via specialized data structures or with the help of database system concepts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">26.5.1 Efficient Lookup in a Blockchain</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">As we noted earlier, in order to validate a Bitcoin-style transaction, a node needs to check three items:</p><p class="s63" style="padding-top: 8pt;padding-left: 113pt;text-indent: -16pt;text-align: justify;">1. <span class="p">The transaction is syntactically well formed (proper data format, sum of inputs equals sum of outputs, and so on). This is relatively straightforward.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">2. <span class="p">The transaction is signed by the user submitting it. This is a matter of ensuring that the signature, which should have been produced by the user submitting the transaction using her or his private key, can be decrypted with that user’s public key to obtain the transaction itself. This is not a highly costly step.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">3. <span class="p">The transaction’s inputs have not been spent already. This entails looking up each individual input transaction in the blockchain. These transactions could be anywhere in the blockchain since they can be arbitrarily old. Without a good means of performing this lookup, this step would be prohibitively costly.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">To test for an input transaction having been used already, it is necessary to be able to check that transaction did not appear earlier as input to another transaction. Thus, it suﬃces for each node to maintain an index on all unspent transactions. Entries in this index point to the location of the corresponding transaction in the blockchain, allowing the details of the input transaction to be validated.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Bitcoin, like many other blockchains, facilitates lookup and validation by storing transactions within a block in a Merkle tree, which we discussed in Section 23.6.6. In that section, we noted that a Merkle tree enables the eﬃcient veriﬁcation of a collection (transactions, in the case of a blockchain) that may have been corrupted by a malicious user. In a blockchain, there are optimizations to the Merkle tree possible, such as trun- cating the tree to remove subtrees consisting solely of spent transactions. This reduces signiﬁcantly the space requirements for nodes to store the full blockchain. Space is a major consideration since major blockchains grow faster that one gigabyte per month, a rate likely to increase as blockchain applications grow.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The Merkle-tree structure is particularly useful for light nodes (i.e., nodes that do not store the entire blockchain) since they need to retain only the root hash of the tree for veriﬁcation. A full node can then provide any needed data to the light node by providing those data plus the hashes needed for the light node to verify that the provided data are consistent with its stored hash value (see Section 23.6.6).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;"><a name="bookmark566">26.5.2 Maintaining Blockchain State</a><a name="bookmark596">&zwnj;</a></p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The simple blockchain transaction model of Section 26.3.3 showed how a basic Bitcoin transaction works. There are more complex transactions possible in Bitcoin, but they follow the same pattern of a set of input transactions and a set of payments to users.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In this section, we look at the model used by certain other blockchains, notably Ethereum, that maintain a <i>state </i>that holds the balance in each account. Transactions move currency units (<i>ether </i>in Ethereum) among accounts. Since transactions are se- rialized into blocks by miners, there is no need for concurrency-control protocols like those of Chapter 18. Each block contains a sequence of transactions but also contains the state as it existed after execution of transactions in the block. It would be wasteful to replicate the entire state in each block since the modest number of transactions in one block are likely to change a relatively small fraction of the overall state. This creates a need for a data structure allowing better use of storage.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Recall that transactions within a block are stored in a Merkle tree. State is stored similarly. This would appear to oﬀer the possibility of saving space by allowing pointers (plus the associated hash) back to earlier blocks for those parts of the state that are unchanged. The only challenge here is that it must be possible not only to change tree nodes, but also to insert and delete them. A variant of the Merkle-tree data structure, called a <span class="s63">Merkle-Patricia tree</span>, is used for this purpose in some blockchains, including Ethereum. This data structure allows for eﬃcient key-based search in the tree. Instead of actually deleting and inserting tree nodes, a new tree root is created and the tree itself structured so as to reference (and thus reuse) subtrees of prior trees. Those prior trees are immutable, so rather than making new parent pointer (which we can’t do), a leaf-to-root path is generated by reversing a root-to-leaf path that is easily obtained in the Merkle-Patricia tree structure. Details of this data structure can be found in the references in the Further Reading section at the end of the chapter.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Corda, Hyperledger Fabric, and BigchainDB are examples of blockchains that use a database to store state and allow querying of that state. Fabric and Bigchain<span class="s44">DB </span>use No<span class="s44">SQL </span>databases. Corda uses an embedded-<span class="s44">SQL </span>database. In contrast, Ethereum state is stored in a key-value store.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part465.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part467.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
