<?xml version="1.0" encoding="utf-8"?><html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/"><head>
<meta name="dcterms.conformsTo" content="PXE Basic 1.0"></meta>
<meta name="generator" content="PXE Tools version 1.39.109"></meta>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.109, partial=false-->
<title>3.4 Principles of Reliable Data Transfer</title><link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/sepia.css"></link><link rel="alternate stylesheet" type="text/css" title="night" href="../css/night.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/main.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/print.css"></link>
<script src="js/format_lg_obj.js"></script>
</head><body epub:type="bodymatter">
<section id="P700101195200000000000000000120D" class="level1"><header><h1 class="title" id="P700101195200000000000000000A17D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A17D" epub:type="title"><span class="number">3.4</span> Principles of Reliable Data Transfer</h1></header>
<p id="P700101195200000000000000000A17E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A17E">In this section, we consider the problem of reliable data transfer in a general context. This is appropriate since the problem of implementing reliable data transfer occurs not only at the transport layer, but also at the link layer and the application layer as well. The general problem is thus of central importance to networking. Indeed, if one had to identify a “top-ten” list of fundamentally important problems in all of networking, this would be a candidate to lead the list. In the next section we’ll examine TCP and show, in particular, that TCP exploits many of the principles that we are about to describe.</p>
<p id="P700101195200000000000000000A17F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A17F"><a class="xref" href="#P7001011952000000000000000001215" data-foobar="1"><span class="label">Figure</span> <span class="number">3.8</span></a> illustrates the framework for our study of reliable data transfer. The service abstraction provided to the upper-layer entities is that of a reliable channel through which data can be transferred. With a reliable channel, no transferred data bits are corrupted (flipped from 0 to 1, or vice versa) or lost, and all are delivered in the order in which they were sent. This is precisely the service model offered by TCP to the Internet applications that invoke it.</p>
<p id="P700101195200000000000000000A180" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A180">It is the responsibility of a <span class="keyword" id="P7001011952000000000000000001212" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001212"><b>reliable data transfer protocol</b></span> to implement this service abstraction. This task is made difficult by the fact that the layer <i>below</i> the reliable data transfer protocol may be unreliable. For example, TCP is a reliable data transfer protocol that is implemented on top of an unreliable (IP) end-to-end network layer. More generally, the layer beneath the two reliably communicating end points might consist of a single physical link (as in the case of a link-level data transfer protocol) or a global internetwork (as in the case of a transport-level protocol). For our purposes, however, we can view this lower layer simply as an unreliable point-to-point channel.</p>
<p id="P700101195200000000000000000A181" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A181">In this section, we will incrementally develop the sender and receiver sides of a reliable data transfer protocol, considering increasingly complex models of the underlying channel. For example, we’ll consider what protocol mechanisms are<span class="pagebreak" title="207" id="P7001011952000000000000000001214" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001214" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001215" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001215">
<img alt="Reliable data transfer: Provided service" height="521" width="330" aria-describedby="P7001011952000000000000000001219" id="P700101195200000000000000000A182" data-uri="P7001011952000000000000000005544" src="../images/4055103008.png"></img>
<figcaption id="P700101195200000000000000000A183" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A183"><header><h1 class="title" id="P700101195200000000000000000A184" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A184" epub:type="title"><span class="label">Figure </span><span class="number">3.8</span> Reliable data transfer: Service model and service implementation</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001219" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001219" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103008.xhtml#la_4055103008"><span class="label">Description</span></a></div>
<figure id="P700101195200000000000000000121C" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000121C">
<img alt="Reliable data transfer: Service implementation" height="464" width="361" aria-describedby="P700101195200000000000000000121E" id="P700101195200000000000000000A187" data-uri="P7001011952000000000000000005545" src="../images/4055103008a.png"></img>
<details class="longdesc" id="P700101195200000000000000000121E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000121E">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000A188" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A188">This illustration is similar to the previous illustration, in that it includes two computers side-by-side above the application, transport and network layers. In this image, a blue arrow extends vertically downward from the first computer, passing through the application layer. In the transport layer, the blue arrow points to a large text box labeled "Reliable data transfer protocol (sending side)." The arrow at this point is labeled "rdt_send ( )," and we see a small blue rectangle representing the data heading towards this text box. Beneath the text box, the blue arrow points vertically in both directions and is labeled "udt_send ( )." The small blue rectangle has become a large blue rectangle, representing a data packet. The blue arrow now enters the network layer, where it makes a 90-degree turn to the right and extends horizontally through a tube labeled "Unreliable channel." Then it makes a 90-degree turn to the left and extends vertically upwards into the transport layer and towards a text box labeled "Reliable data transfer protocol (receiving side)." The blue arrow here is labeled "rdt_rcv ( )" and appears beside a data packet. Above the text box, the blue arrow is labeled "deliver_data" and appears beside the small blue data file. From here it extends to the receiving computer.</p>
</details>
</figure>
<p class="continued" id="P700101195200000000000000000A189" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A189">needed when the underlying channel can corrupt bits or lose entire packets. One assumption we’ll adopt throughout our discussion here is that packets will be delivered in the order in which they were sent, with some packets possibly being lost; that is, the underlying channel will not reorder packets. <a class="xref" href="#P7001011952000000000000000001215" data-foobar="1"><span class="label">Figure</span> <span class="number">3.8(b)</span></a> illustrates the interfaces for our data transfer protocol. The sending side of the data transfer protocol will be invoked from above by a call to <code id="P700101195200000000000000000A18A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A18A">rdt_send()</code>. It will pass the data to be delivered to the upper layer at the receiving side. (Here <code id="P700101195200000000000000000A18B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A18B">rdt</code> stands for <i>reliable data transfer</i> protocol and <code id="P700101195200000000000000000A18C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A18C">_send</code> indicates that the sending side of <code id="P700101195200000000000000000A18D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A18D">rdt</code> is being called. The first step in developing any protocol is to choose a good name!) On the receiving side, <code id="P700101195200000000000000000A18E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A18E">rdt_rcv()</code> will be called when a packet arrives from the receiving side of the channel. When the <code id="P700101195200000000000000000A18F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A18F">rdt</code> protocol wants to deliver data to the upper layer, it will do so by calling <code id="P700101195200000000000000000A190" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A190">deliver_data()</code>. In the following we use the terminology “packet” rather than transport-layer “segment.” Because the theory developed in this section <span class="pagebreak" title="208" id="P7001011952000000000000000001228" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001228" epub:type="pagebreak" role="doc-pagebreak"></span>applies to computer networks in general and not just to the Internet transport layer, the generic term “packet” is perhaps more appropriate here.</p>
<p id="P700101195200000000000000000A191" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A191">In this section we consider only the case of <span class="keyword" id="P700101195200000000000000000122A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000122A"><b>unidirectional data transfer</b></span>, that is, data transfer from the sending to the receiving side. The case of reliable <span class="keyword" id="P700101195200000000000000000122B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000122B"><b>bidirectional</b></span> (that is, full-duplex) <span class="keyword" id="P700101195200000000000000000122C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000122C"><b>data transfer</b></span> is conceptually no more difficult but considerably more tedious to explain. Although we consider only unidirectional data transfer, it is important to note that the sending and receiving sides of our protocol will nonetheless need to transmit packets in <i>both</i> directions, as indicated in <a class="xref" href="#P7001011952000000000000000001215" data-foobar="1"><span class="label">Figure</span> <span class="number">3.8</span></a>. We will see shortly that, in addition to exchanging packets containing the data to be transferred, the sending and receiving sides of <code id="P700101195200000000000000000A192" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A192">rdt</code> will also need to exchange control packets back and forth. Both the send and receive sides of <code id="P700101195200000000000000000A193" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A193">rdt</code> send packets to the other side by a call to <code id="P700101195200000000000000000A194" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A194">udt_send()</code> (where udt stands for <i>unreliable data transfer</i>).</p>
<section id="P7001011952000000000000000001230" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001230" class="level2"><header><h1 class="title" id="P700101195200000000000000000A195" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A195" epub:type="title"><span class="number">3.4.1</span> Building a Reliable Data Transfer Protocol</h1></header>
<p id="P700101195200000000000000000A196" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A196">We now step through a series of protocols, each one becoming more complex, arriving at a flawless, reliable data transfer protocol.</p>
<section id="P7001011952000000000000000001233" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001233" class="level3"><header><h1 class="title" id="P700101195200000000000000000A197" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A197" epub:type="title">Reliable Data Transfer over a Perfectly Reliable Channel: <code id="P700101195200000000000000000A198" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A198">rdt1.0</code></h1></header>
<p id="P700101195200000000000000000A199" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A199">We first consider the simplest case, in which the underlying channel is completely reliable. The protocol itself, which we’ll call <code id="P700101195200000000000000000A19A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A19A">rdt1.0</code>, is trivial. The <span class="keyword" id="P7001011952000000000000000001237" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001237"><b>finite-state machine (FSM)</b></span> definitions for the <code id="P700101195200000000000000000A19B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A19B">rdt1.0</code> sender and receiver are shown in <a class="xref" href="#P7001011952000000000000000001240" data-foobar="1"><span class="label">Figure</span> <span class="number">3.9</span></a>. The FSM in <a class="xref" href="#P7001011952000000000000000001240" data-foobar="1"><span class="label">Figure</span> <span class="number">3.9(a)</span></a> defines the operation of the sender, while the FSM in <a class="xref" href="#P7001011952000000000000000001240" data-foobar="1"><span class="label">Figure</span> <span class="number">3.9(b)</span></a> defines the operation of the receiver. It is important to note that there are <i>separate</i> FSMs for the sender and for the receiver. The sender and receiver FSMs in <a class="xref" href="#P7001011952000000000000000001240" data-foobar="1"><span class="label">Figure</span> <span class="number">3.9</span></a> each have just one state. The arrows in the FSM description indicate the transition of the protocol from one state to another. (Since each FSM in <a class="xref" href="#P7001011952000000000000000001240" data-foobar="1"><span class="label">Figure</span> <span class="number">3.9</span></a> has just one state, a transition is necessarily from the one state back to itself; we’ll see more complicated state diagrams shortly.) The event causing the transition is shown above the horizontal line labeling the transition, and the actions taken when the event occurs are shown below the horizontal line. When no action is taken on an event, or no event occurs and an action is taken, we’ll use the symbol Λ below or above the horizontal, respectively, to explicitly denote the lack of an action or event. The initial state of the FSM is indicated by the dashed arrow. Although the FSMs in <a class="xref" href="#P7001011952000000000000000001240" data-foobar="1"><span class="label">Figure</span> <span class="number">3.9</span></a> have but one state, the FSMs we will see shortly have multiple states, so it will be important to identify the initial state of each FSM.</p>
<p id="P700101195200000000000000000A19C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A19C">The sending side of <code id="P700101195200000000000000000A19D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A19D">rdt</code> simply accepts data from the upper layer via the <code id="P700101195200000000000000000A19E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A19E">rdt_send(data)</code> event, creates a packet containing the data (via the action <code id="P700101195200000000000000000A19F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A19F">make_pkt(data)</code>) and sends the packet into the channel. In practice, the <code id="P700101195200000000000000000A1A0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1A0">rdt_send(data)</code> event would result from a procedure call (for example, to <code id="P700101195200000000000000000A1A1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1A1">rdt_send()</code>) by the upper-layer application.<span class="pagebreak" title="209" id="P700101195200000000000000000123F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000123F" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001240" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001240">
<img alt="Illustration of a reliable data transfer over a reliable channel, from sending side and receiving side." height="418" width="391" aria-describedby="P7001011952000000000000000001245" id="P700101195200000000000000000A1A2" data-uri="P7001011952000000000000000005546" src="../images/4055103009.png"></img>
<figcaption id="P700101195200000000000000000A1A3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1A3"><header><h1 class="title" id="P700101195200000000000000000A1A4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1A4" epub:type="title"><span class="label">Figure </span><span class="number">3.9</span> <code id="P700101195200000000000000000A1A5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1A5"><b>rdt1.0</b></code> – A protocol for a completely reliable channel</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001245" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001245" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103009.xhtml#la_4055103009"><span class="label">Description</span></a></div>
<p id="P700101195200000000000000000A1AA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1AA">On the receiving side, rdt receives a packet from the underlying channel via the <code id="P700101195200000000000000000A1AB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1AB">rdt_rcv(packet)</code> event, removes the data from the packet (via the action <code id="P700101195200000000000000000A1AC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1AC">extract (packet, data)</code>) and passes the data up to the upper layer (via the action <code id="P700101195200000000000000000A1AD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1AD">deliver_data(data)</code>). In practice, the <code id="P700101195200000000000000000A1AE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1AE">rdt_rcv(packet)</code> event would result from a procedure call (for example, to <code id="P700101195200000000000000000A1AF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1AF">rdt_rcv()</code>) from the lower-layer protocol.</p>
<p id="P700101195200000000000000000A1B0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B0">In this simple protocol, there is no difference between a unit of data and a packet. Also, all packet flow is from the sender to receiver; with a perfectly reliable channel there is no need for the receiver side to provide any feedback to the sender since nothing can go wrong! Note that we have also assumed that the receiver is able to receive data as fast as the sender happens to send data. Thus, there is no need for the receiver to ask the sender to slow down!</p>
</section>
<section id="P7001011952000000000000000001251" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001251" class="level3"><header><h1 class="title" id="P700101195200000000000000000A1B1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B1" epub:type="title">Reliable Data Transfer over a Channel with Bit Errors: <code id="P700101195200000000000000000A1B2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B2"><b>rdt2.0</b></code></h1></header>
<p id="P700101195200000000000000000A1B3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B3">A more realistic model of the underlying channel is one in which bits in a packet may be corrupted. Such bit errors typically occur in the physical components of a network as a packet is transmitted, propagates, or is buffered. We’ll continue to assume for the moment that all transmitted packets are received (although their bits may be corrupted) in the order in which they were sent.</p>
<p id="P700101195200000000000000000A1B4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B4">Before developing a protocol for reliably communicating over such a channel, first consider how people might deal with such a situation. Consider how you yourself <span class="pagebreak" title="210" id="P7001011952000000000000000001256" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001256" epub:type="pagebreak" role="doc-pagebreak"></span>might dictate a long message over the phone. In a typical scenario, the message taker might say “OK” after each sentence has been heard, understood, and recorded. If the message taker hears a garbled sentence, you’re asked to repeat the garbled sentence. This message-dictation protocol uses both <span class="keyword" id="P7001011952000000000000000001257" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001257"><b>positive acknowledgments</b></span> (“OK”) and <span class="keyword" id="P7001011952000000000000000001258" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001258"><b>negative acknowledgments</b></span> (“Please repeat that.”). These control messages allow the receiver to let the sender know what has been received correctly, and what has been received in error and thus requires repeating. In a computer network setting, reliable data transfer protocols based on such retransmission are known as <span class="keyword" id="P7001011952000000000000000001259" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001259"><b>ARQ (Automatic Repeat reQuest) protocols</b></span>.</p>
<p id="P700101195200000000000000000A1B5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B5">Fundamentally, three additional protocol capabilities are required in ARQ protocols to handle the presence of bit errors:</p>
<ul id="P700101195200000000000000000A1B6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B6">
<li id="P700101195200000000000000000A1B7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B7"><p id="P700101195200000000000000000A1B8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B8"><span class="leadin">Error detection.</span> First, a mechanism is needed to allow the receiver to detect when bit errors have occurred. Recall from the previous section that UDP uses the Internet checksum field for exactly this purpose. In <a class="xref" href="fileP70010119520000000000000000023B1.xhtml#P70010119520000000000000000023B1" data-foobar="7"><span class="label">Chapter</span> <span class="number">6</span></a> we’ll examine error-detection and -correction techniques in greater detail; these techniques allow the receiver to detect and possibly correct packet bit errors. For now, we need only know that these techniques require that extra bits (beyond the bits of original data to be transferred) be sent from the sender to the receiver; these bits will be gathered into the packet checksum field of the <code id="P700101195200000000000000000A1B9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1B9">rdt2.0</code> data packet.</p></li>
<li id="P700101195200000000000000000A1BA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1BA"><p id="P700101195200000000000000000A1BB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1BB"><span class="leadin">Receiver feedback.</span> Since the sender and receiver are typically executing on different end systems, possibly separated by thousands of miles, the only way for the sender to learn of the receiver’s view of the world (in this case, whether or not a packet was received correctly) is for the receiver to provide explicit feedback to the sender. The positive (ACK) and negative (NAK) acknowledgment replies in the message-dictation scenario are examples of such feedback. Our <code id="P700101195200000000000000000A1BC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1BC">rdt2.0</code> protocol will similarly send ACK and NAK packets back from the receiver to the sender. In principle, these packets need only be one bit long; for example, a 0 value could indicate a NAK and a value of 1 could indicate an ACK.</p></li>
<li id="P700101195200000000000000000A1BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1BD"><p id="P700101195200000000000000000A1BE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1BE"><span class="leadin">Retransmission.</span> A packet that is received in error at the receiver will be retransmitted by the sender.</p></li>
</ul>
<p id="P700101195200000000000000000A1BF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1BF"><a class="xref" href="#P700101195200000000000000000126C" data-foobar="1"><span class="label">Figure</span> <span class="number">3.10</span></a> shows the FSM representation of <code id="P700101195200000000000000000A1C0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C0">rdt2.0</code>, a data transfer protocol employing error detection, positive acknowledgments, and negative acknowledgments.</p>
<p id="P700101195200000000000000000A1C1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C1">The send side of <code id="P700101195200000000000000000A1C2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C2">rdt2.0</code> has two states. In the leftmost state, the send-side protocol is waiting for data to be passed down from the upper layer. When the <code id="P700101195200000000000000000A1C3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C3">rdt_send(data)</code> event occurs, the sender will create a packet (<code id="P700101195200000000000000000A1C4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C4">sndpkt</code>) containing the data to be sent, along with a packet checksum (for example, as discussed in <a class="xref" href="fileP70010119520000000000000000011C0.xhtml#P70010119520000000000000000011DF" data-foobar="7"><span class="label">Section</span> <span class="number">3.3.2</span></a> for the case of a UDP segment), and then send the packet via the <code id="P700101195200000000000000000A1C5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C5">udt_send(sndpkt)</code> operation. In the rightmost state, the sender protocol is waiting for an ACK or a NAK packet from the receiver. If an ACK packet is received<span class="pagebreak" title="211" id="P700101195200000000000000000126B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000126B" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P700101195200000000000000000126C" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000126C">
<img alt="Illustration of a protocol for a channel with bit errors, sending side." height="281" width="618" aria-describedby="P7001011952000000000000000001271" id="P700101195200000000000000000A1C6" data-uri="P7001011952000000000000000005547" src="../images/4055103010.png"></img>
<figcaption id="P700101195200000000000000000A1C7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C7"><header><h1 class="title" id="P700101195200000000000000000A1C8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C8" epub:type="title"><span class="label">Figure </span><span class="number">3.10</span> <code id="P700101195200000000000000000A1C9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1C9"><b>rdt2.0</b></code> – A protocol for a channel with bit errors</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001271" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001271" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103010.xhtml#la_4055103010"><span class="label">Description</span></a></div>
<figure id="P7001011952000000000000000001277" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001277">
<img alt="Illustration of a protocol for a channel with bit errors, receiving side." height="276" width="395" aria-describedby="P7001011952000000000000000001279" id="P700101195200000000000000000A1CF" data-uri="P7001011952000000000000000005548" src="../images/4055103010a.png"></img>
<details class="longdesc" id="P7001011952000000000000000001279" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001279">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000A1D0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D0">In this illustration, a black arrow extends diagonally downward from left to right and points to a blue circle labeled "Wait for call from below." A blue arrow extends from the upper left side of the circle and travels in a clockwise motion to the upper right side of the circle. This arrow has two labels, separated by a horizontal line. On top: "rdt_rcv (rcvpkt) &amp;&amp; corrupt (rcvpkt)."</p>
<p id="P700101195200000000000000000A1D1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D1">On bottom: "sndpkt=make_pkt (NAK) udt_send (sndpkt)."</p>
<p id="P700101195200000000000000000A1D2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D2">A second blue arrow extends from the bottom left of the circle and travels in a counter-clockwise motion to the bottom right of the circle. This arrow also has two labels separated by a horizontal line. On top: "rdt_rcv (rcvpkt) &amp;&amp; notcorrupt (rcvpkt)." On bottom: "extract (rcvpkt, data)</p>
<p id="P700101195200000000000000000A1D3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D3">deliver_data (data) sndpkt=make_pkt (ACK) udt_send (sndpkt)."</p>
</details>
</figure>
<p class="continued" id="P700101195200000000000000000A1D4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D4">(the notation <code id="P700101195200000000000000000A1D5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D5">rdt_rcv(rcvpkt) &amp;&amp; isACK (rcvpkt)</code> in <a class="xref" href="#P700101195200000000000000000126C" data-foobar="1"><span class="label">Figure</span> <span class="number">3.10</span></a> corresponds to this event), the sender knows that the most recently transmitted packet has been received correctly and thus the protocol returns to the state of waiting for data from the upper layer. If a NAK is received, the protocol retransmits the last packet and waits for an ACK or NAK to be returned by the receiver in response to the retransmitted data packet. It is important to note that when the sender is in the wait-for-ACK-or-NAK state, it <i>cannot</i> get more data from the upper layer; that is, the <code id="P700101195200000000000000000A1D6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D6">rdt_send()</code> event can not occur; that will happen only after the sender receives an ACK and leaves this state. Thus, the sender will not send a new piece of data until it is sure that the receiver has correctly received the current packet. Because of this behavior, protocols such as <code id="P700101195200000000000000000A1D7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D7">rdt2.0</code> are known as <span class="keyword" id="P7001011952000000000000000001282" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001282"><b>stop-and-wait</b></span> protocols.</p>
<p id="P700101195200000000000000000A1D8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D8"><span class="pagebreak" title="212" id="P7001011952000000000000000001284" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001284" epub:type="pagebreak" role="doc-pagebreak"></span>The receiver-side FSM for <code id="P700101195200000000000000000A1D9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1D9">rdt2.0</code> still has a single state. On packet arrival, the receiver replies with either an ACK or a NAK, depending on whether or not the received packet is corrupted. In <a class="xref" href="#P700101195200000000000000000126C" data-foobar="1"><span class="label">Figure</span> <span class="number">3.10</span></a>, the notation <code id="P700101195200000000000000000A1DA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1DA">rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt)</code> corresponds to the event in which a packet is received and is found to be in error.</p>
<p id="P700101195200000000000000000A1DB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1DB">Protocol <code id="P700101195200000000000000000A1DC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1DC">rdt2.0</code> may look as if it works but, unfortunately, it has a fatal flaw. In particular, we haven’t accounted for the possibility that the ACK or NAK packet could be corrupted! (Before proceeding on, you should think about how this problem may be fixed.) Unfortunately, our slight oversight is not as innocuous as it may seem. Minimally, we will need to add checksum bits to ACK/NAK packets in order to detect such errors. The more difficult question is how the protocol should recover from errors in ACK or NAK packets. The difficulty here is that if an ACK or NAK is corrupted, the sender has no way of knowing whether or not the receiver has correctly received the last piece of transmitted data.</p>
<p id="P700101195200000000000000000A1DD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1DD">Consider three possibilities for handling corrupted ACKs or NAKs:</p>
<ul id="P700101195200000000000000000A1DE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1DE">
<li id="P700101195200000000000000000A1DF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1DF"><p id="P700101195200000000000000000A1E0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E0">For the first possibility, consider what a human might do in the message-dictation scenario. If the speaker didn’t understand the “OK” or “Please repeat that” reply from the receiver, the speaker would probably ask, “What did you say?” (thus introducing a new type of sender-to-receiver packet to our protocol). The receiver would then repeat the reply. But what if the speaker’s “What did you say?” is corrupted? The receiver, having no idea whether the garbled sentence was part of the dictation or a request to repeat the last reply, would probably then respond with “What did <i>you</i> say?” And then, of course, that response might be garbled. Clearly, we’re heading down a difficult path.</p></li>
<li id="P700101195200000000000000000A1E1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E1"><p id="P700101195200000000000000000A1E2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E2">A second alternative is to add enough checksum bits to allow the sender not only to detect, but also to recover from, bit errors. This solves the immediate problem for a channel that can corrupt packets but not lose them.</p></li>
<li id="P700101195200000000000000000A1E3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E3"><p id="P700101195200000000000000000A1E4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E4">A third approach is for the sender simply to resend the current data packet when it receives a garbled ACK or NAK packet. This approach, however, introduces <span class="keyword" id="P7001011952000000000000000001291" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001291"><b>duplicate packets</b></span> into the sender-to-receiver channel. The fundamental difficulty with duplicate packets is that the receiver doesn’t know whether the ACK or NAK it last sent was received correctly at the sender. Thus, it cannot know <i>a priori</i> whether an arriving packet contains new data or is a retransmission!</p></li>
</ul>
<p id="P700101195200000000000000000A1E5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E5">A simple solution to this new problem (and one adopted in almost all existing data transfer protocols, including TCP) is to add a new field to the data packet and have the sender number its data packets by putting a <span class="keyword" id="P7001011952000000000000000001293" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001293"><b>sequence number</b></span> into this field. The receiver then need only check this sequence number to determine whether or not the received packet is a retransmission. For this simple case of a stop-and-wait protocol, a 1-bit sequence number will suffice, since it will allow the receiver to know whether the sender is resending the previously transmitted packet <span class="pagebreak" title="213" id="P7001011952000000000000000001294" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001294" epub:type="pagebreak" role="doc-pagebreak"></span>(the sequence number of the received packet has the same sequence number as the most recently received packet) or a new packet (the sequence number changes, moving “forward” in modulo-2 arithmetic). Since we are currently assuming a channel that does not lose packets, ACK and NAK packets do not themselves need to indicate the sequence number of the packet they are acknowledging. The sender knows that a received ACK or NAK packet (whether garbled or not) was generated in response to its most recently transmitted data packet.</p>
<p id="P700101195200000000000000000A1E6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E6"><a class="xref" href="#P700101195200000000000000000129B" data-foobar="1"><span class="label">Figures</span> <span class="number">3.11</span></a> and <a class="xref" href="#P70010119520000000000000000012AD" data-foobar="1"><span class="number">3.12</span></a> show the FSM description for <code id="P700101195200000000000000000A1E7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E7">rdt2.1</code>, our fixed version of <code id="P700101195200000000000000000A1E8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E8">rdt2.0</code>. The <code id="P700101195200000000000000000A1E9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1E9">rdt2.1</code> sender and receiver FSMs each now have twice as many states as before. This is because the protocol state must now reflect whether the packet currently being sent (by the sender) or expected (at the receiver) should have a sequence number of 0 or 1. Note that the actions in those states where a 0-numbered packet is being sent or expected are mirror images of those where a 1-numbered packet is being sent or expected; the only differences have to do with the handling of the sequence number.</p>
<p id="P700101195200000000000000000A1EA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1EA">Protocol <code id="P700101195200000000000000000A1EB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1EB">rdt2.1</code> uses both positive and negative acknowledgments from the receiver to the sender. When an out-of-order packet is received, the receiver sends a positive acknowledgment for the packet it has received. When a corrupted packet</p>
<figure id="P700101195200000000000000000129B" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000129B">
<img alt="Illustration of rdt2.1, sender." height="514" width="712" aria-describedby="P70010119520000000000000000012A0" id="P700101195200000000000000000A1EC" data-uri="P7001011952000000000000000005549" src="../images/4055103011.png"></img>
<figcaption id="P700101195200000000000000000A1ED" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1ED"><header><h1 class="title" id="P700101195200000000000000000A1EE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1EE" epub:type="title"><span class="label">Figure </span><span class="number">3.11</span> <code id="P700101195200000000000000000A1EF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1EF"><b>rdt2.1</b></code> sender</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000012A0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012A0" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103011.xhtml#la_4055103011"><span class="label">Description</span></a></div>
<figure id="P70010119520000000000000000012AD" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012AD">
<img alt="Illustration of rdt2.1, receiver." height="458" width="867" aria-describedby="P70010119520000000000000000012B3" id="P700101195200000000000000000A1FC" data-uri="P700101195200000000000000000554A" src="../images/4055103012.png"></img>
<figcaption id="P700101195200000000000000000A1FD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1FD"><header><h1 class="title" id="P700101195200000000000000000A1FE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1FE" epub:type="title"><span class="pagebreak" title="214" id="P70010119520000000000000000012B1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012B1" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">Figure </span><span class="number">3.12</span> <code id="P700101195200000000000000000A1FF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A1FF"><b>rdt2.1</b></code> receiver</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000012B3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012B3" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103012.xhtml#la_4055103012"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A20B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A20B">is received, the receiver sends a negative acknowledgment. We can accomplish the same effect as a NAK if, instead of sending a NAK, we send an ACK for the last correctly received packet. A sender that receives two ACKs for the same packet (that is, receives <span class="keyword" id="P70010119520000000000000000012C0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012C0"><b>duplicate ACKs</b></span>) knows that the receiver did not correctly receive the packet following the packet that is being ACKed twice. Our NAK-free reliable data transfer protocol for a channel with bit errors is <code id="P700101195200000000000000000A20C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A20C">rdt2.2</code>, shown in <a class="xref" href="#P70010119520000000000000000012D1" data-foobar="1"><span class="label">Figures</span> <span class="number">3.13</span></a> and <a class="xref" href="#P70010119520000000000000000012E8" data-foobar="1"><span class="number">3.14</span></a>. One subtle change between <code id="P700101195200000000000000000A20D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A20D">rtdt2.1</code> and <code id="P700101195200000000000000000A20E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A20E">rdt2.2</code> is that the receiver must now include the sequence number of the packet being acknowledged by an ACK message (this is done by including the <code id="P700101195200000000000000000A20F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A20F">ACK</code>, <code id="P700101195200000000000000000A210" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A210">0</code> or <code id="P700101195200000000000000000A211" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A211">ACK</code>, <code id="P700101195200000000000000000A212" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A212">1</code> argument in <code id="P700101195200000000000000000A213" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A213">make_pkt()</code> in the receiver FSM), and the sender must now check the sequence number of the packet being acknowledged by a received ACK message (this is done by including the <code id="P700101195200000000000000000A214" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A214">0</code> or <code id="P700101195200000000000000000A215" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A215">1</code> argument in <code id="P700101195200000000000000000A216" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A216">isACK()</code> in the sender FSM).</p>
</section>
<section id="P70010119520000000000000000012CC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012CC" class="level3"><header><h1 class="title" id="P700101195200000000000000000A217" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A217" epub:type="title">Reliable Data Transfer over a Lossy Channel with Bit Errors: <code id="P700101195200000000000000000A218" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A218">rdt3.0</code></h1></header>
<p id="P700101195200000000000000000A219" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A219">Suppose now that in addition to corrupting bits, the underlying channel can <i>lose</i> packets as well, a not-uncommon event in today’s computer networks (including the Internet). Two additional concerns must now be addressed by the protocol: how to detect packet loss and what to do when packet loss occurs. The use of checksumming, sequence numbers, ACK packets, and retransmissions—the techniques<span class="pagebreak" title="215" id="P70010119520000000000000000012D0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012D0" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000012D1" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012D1">
<img alt="Illustration of rdt2.2, sender." height="514" width="714" aria-describedby="P70010119520000000000000000012D6" id="P700101195200000000000000000A21A" data-uri="P700101195200000000000000000554B" src="../images/4055103013.png"></img>
<figcaption id="P700101195200000000000000000A21B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A21B"><header><h1 class="title" id="P700101195200000000000000000A21C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A21C" epub:type="title"><span class="label">Figure </span><span class="number">3.13</span> <code id="P700101195200000000000000000A21D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A21D"><b>rdt2.2</b></code> sender</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000012D6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012D6" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103013.xhtml#la_4055103013"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A22A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A22A">already developed in <code id="P700101195200000000000000000A22B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A22B">rdt2.2</code>—will allow us to answer the latter concern. Handling the first concern will require adding a new protocol mechanism.</p>
<p id="P700101195200000000000000000A22C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A22C">There are many possible approaches toward dealing with packet loss (several more of which are explored in the exercises at the end of the chapter). Here, we’ll put the burden of detecting and recovering from lost packets on the sender. Suppose that the sender transmits a data packet and either that packet, or the receiver’s ACK of that packet, gets lost. In either case, no reply is forthcoming at the sender from the receiver. If the sender is willing to wait long enough so that it is <i>certain</i> that a packet has been lost, it can simply retransmit the data packet. You should convince yourself that this protocol does indeed work.</p>
<p id="P700101195200000000000000000A22D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A22D">But how long must the sender wait to be certain that something has been lost? The sender must clearly wait at least as long as a round-trip delay between the sender and receiver (which may include buffering at intermediate routers) plus whatever amount of time is needed to process a packet at the receiver. In many networks, this worst-case maximum delay is very difficult even to estimate, much less know with certainty. Moreover, the protocol should ideally recover from packet loss as soon as possible; waiting for a worst-case delay could mean a long wait until error recovery<span class="pagebreak" title="216" id="P70010119520000000000000000012E7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012E7" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000012E8" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012E8">
<img alt="Illustration of rdt2.2, receiver." height="422" width="865" aria-describedby="P70010119520000000000000000012ED" id="P700101195200000000000000000A22E" data-uri="P700101195200000000000000000554C" src="../images/4055103014.png"></img>
<figcaption id="P700101195200000000000000000A22F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A22F"><header><h1 class="title" id="P700101195200000000000000000A230" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A230" epub:type="title"><span class="label">Figure </span><span class="number">3.14</span> <code id="P700101195200000000000000000A231" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A231"><b>rdt2.2</b></code> receiver</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000012ED" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012ED" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103014.xhtml#la_4055103014"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A23A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A23A">is initiated. The approach thus adopted in practice is for the sender to judiciously choose a time value such that packet loss is likely, although not guaranteed, to have happened. If an ACK is not received within this time, the packet is retransmitted. Note that if a packet experiences a particularly large delay, the sender may retransmit the packet even though neither the data packet nor its ACK have been lost. This introduces the possibility of <span class="keyword" id="P70010119520000000000000000012F7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012F7"><b>duplicate data packets</b></span> in the sender-to-receiver channel. Happily, protocol <code id="P700101195200000000000000000A23B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A23B">rdt2.2</code> already has enough functionality (that is, sequence numbers) to handle the case of duplicate packets.</p>
<p id="P700101195200000000000000000A23C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A23C">From the sender’s viewpoint, retransmission is a panacea. The sender does not know whether a data packet was lost, an ACK was lost, or if the packet or ACK was simply overly delayed. In all cases, the action is the same: retransmit. Implementing a time-based retransmission mechanism requires a <span class="keyword" id="P70010119520000000000000000012FA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012FA"><b>countdown timer</b></span> that can interrupt the sender after a given amount of time has expired. The sender will thus need to be able to (1) start the timer each time a packet (either a first-time packet or a retransmission) is sent, (2) respond to a timer interrupt (taking appropriate actions), and (3) stop the timer.</p>
<p id="P700101195200000000000000000A23D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A23D"><a class="xref" href="#P70010119520000000000000000012FF" data-foobar="1"><span class="label">Figure</span> <span class="number">3.15</span></a> shows the sender FSM for <code id="P700101195200000000000000000A23E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A23E">rdt3.0</code>, a protocol that reliably transfers data over a channel that can corrupt or lose packets; in the homework problems, you’ll be asked to provide the receiver FSM for <code id="P700101195200000000000000000A23F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A23F">rdt3.0</code>. <a class="xref" href="#P7001011952000000000000000001327" data-foobar="1"><span class="label">Figure</span> <span class="number">3.16</span></a> shows how the protocol operates with no lost or delayed packets and how it handles lost data packets. In <a class="xref" href="#P7001011952000000000000000001327" data-foobar="1"><span class="label">Figure</span> <span class="number">3.16</span></a>, time moves forward from the top of the diagram toward the bottom of the<span class="pagebreak" title="217" id="P70010119520000000000000000012FE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012FE" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000012FF" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000012FF">
<img alt="Illustration of rdt3.0, sender." height="550" width="723" aria-describedby="P7001011952000000000000000001304" id="P700101195200000000000000000A240" data-uri="P700101195200000000000000000554D" src="../images/4055103015.png"></img>
<figcaption id="P700101195200000000000000000A241" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A241"><header><h1 class="title" id="P700101195200000000000000000A242" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A242" epub:type="title"><span class="label">Figure </span><span class="number">3.15</span> <code id="P700101195200000000000000000A243" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A243">rdt3.0</code> sender</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001304" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001304" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103015.xhtml#la_4055103015"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A258" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A258">diagram; note that a receive time for a packet is necessarily later than the send time for a packet as a result of transmission and propagation delays. In <a class="xref" href="#P7001011952000000000000000001327" data-foobar="1"><span class="label">Figures</span> <span class="number">3.16(b)</span></a>–<a class="xref" href="#P7001011952000000000000000001327" data-foobar="1"><span class="number">(d)</span></a>, the send-side brackets indicate the times at which a timer is set and later times out. Several of the more subtle aspects of this protocol are explored in the exercises at the end of this chapter. Because packet sequence numbers alternate between 0 and 1, protocol <code id="P700101195200000000000000000A259" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A259">rdt3.0</code> is sometimes known as the <span class="keyword" id="P700101195200000000000000000131B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000131B"><b>alternating-bit protocol</b></span>.</p>
<p id="P700101195200000000000000000A25A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A25A">We have now assembled the key elements of a data transfer protocol. Checksums, sequence numbers, timers, and positive and negative acknowledgment packets each play a crucial and necessary role in the operation of the protocol. We now have a working reliable data transfer protocol!</p>
<aside class="marginalia" id="P700101195200000000000000000131D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000131D">
<p id="P700101195200000000000000000A25B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A25B"><img alt="" height="55" width="58" id="P700101195200000000000000000A25C" data-uri="P7001011952000000000000000005893" src="../images/VideoNote.png"></img></p>
<p id="P700101195200000000000000000A25D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A25D">Developing a protocol and FSM representation for a simple application-layer protocol</p>
</aside>
</section>
</section>
<section id="P7001011952000000000000000001321" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001321" class="level2"><header><h1 class="title" id="P700101195200000000000000000A25E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A25E" epub:type="title"><span class="number">3.4.2</span> Pipelined Reliable Data Transfer Protocols</h1></header>
<p id="P700101195200000000000000000A25F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A25F">Protocol <code id="P700101195200000000000000000A260" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A260">rdt3.0</code> is a functionally correct protocol, but it is unlikely that anyone would be happy with its performance, particularly in today’s high-speed networks. At the heart of <code id="P700101195200000000000000000A261" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A261">rdt3.0</code>’s performance problem is the fact that it is a stop-and-wait protocol.<span class="pagebreak" title="218" id="P7001011952000000000000000001326" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001326" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001327" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001327">
<img alt="Illustration of operation of rt3.0, operation with no loss." height="353" width="301" aria-describedby="P700101195200000000000000000132C" id="P700101195200000000000000000A262" data-uri="P700101195200000000000000000554E" src="../images/4055103016.png"></img>
<figcaption id="P700101195200000000000000000A263" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A263"><header><h1 class="title" id="P700101195200000000000000000A264" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A264" epub:type="title"><span class="label">Figure </span><span class="number">3.16</span> Operation of <code id="P700101195200000000000000000A265" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A265">rdt3.0</code>, the alternating-bit protocol</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000132C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000132C" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103016.xhtml#la_4055103016"><span class="label">Description</span></a></div>
<figure id="P700101195200000000000000000132F" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000132F">
<img alt="Illustration of operation of rt3.0, lost packet." height="376" width="305" aria-describedby="P7001011952000000000000000001331" id="P700101195200000000000000000A268" data-uri="P700101195200000000000000000554F" src="../images/4055103016b.png"></img>
<details class="longdesc" id="P7001011952000000000000000001331" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001331">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000A269" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A269">This illustration uses the same structure as 3.16(a). The operation begins at the topmost point on the sender's timeline, labeled "send pkt0." A blue arrow labeled "pkt0" extends diagonally downward to the right to a point on the receiver's timeline labeled "rcv pkt 0, send ACK0." A blue arrow labeled "ACK0" extends to a point on the sender's timeline labeled "rcv ACK0, send pkt1." A blue arrow extends halfway to the receiver's timeline and disappears. This disruption is labeled "X (loss)." The operation resumes further down the sender's timeline. This lag is labeled "timeout, resend pkt1." An arrow labeled "pkt1" extends to a point on the receiver's timeline labeled "rcv pkt1, send ACK 1." The operation completes the same as it did in figure 3.16(a).</p>
</details>
</figure>
<figure id="P7001011952000000000000000001333" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001333">
<img alt="Illustration of operation of rdt3.0, lost ACK." height="397" width="309" aria-describedby="P7001011952000000000000000001335" id="P700101195200000000000000000A26A" data-uri="P7001011952000000000000000005550" src="../images/4055103016c.png"></img>
<details class="longdesc" id="P7001011952000000000000000001335" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001335">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000A26B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A26B">This illustration uses the same structure as 3.16(a). The operation begins at the topmost point on the sender's timeline, labeled "send pkt0." A blue arrow labeled "pkt0" extends diagonally downward to the right to a point on the receiver's timeline labeled "rcv pkt 0, send ACK0." A blue arrow labeled "ACK0" extends to a point on the sender's timeline labeled "rcv ACK0, send pkt1." An arrow labeled "pkt1" extends to a point on the receiver's timeline labeled "rcv pkt1, send ACK1." A blue arrow labeled "ACK1" extends halfway to the sender's timeline and disappears. This disruption is labeled "(loss) X." The operation resumes from the sender's timeline, at a point labeled "timeout, resend pkt1." A blue arrow labeled "pkt1" extends to a point on the receiver's timeline labeled "rcv pkt1, (detect duplicate), send ACK1." An arrow labeled "ACK1" extends to a point on the sender's timeline labeled "rcv ACK1, send pkt0." An arrow labeled "pkt0" extends to a point on the receiver's timeline labeled "rcv pkt0, send ACK0." An arrow labeled "ACK0" extends to the sender's timeline.</p>
</details>
</figure>
<figure id="P7001011952000000000000000001337" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001337">
<img alt="Illustration of operation of rdt3.0, premature timeout." height="397" width="382" aria-describedby="P7001011952000000000000000001339" id="P700101195200000000000000000A26C" data-uri="P7001011952000000000000000005551" src="../images/4055103016d.png"></img>
<details class="longdesc" id="P7001011952000000000000000001339" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001339">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000A26D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A26D">This illustration uses the same structure as 3.16(a). The operation begins at the topmost point on the sender's timeline, labeled "send pkt0." A blue arrow labeled "pkt0" extends diagonally downward to the right to a point on the receiver's timeline labeled "rcv pkt 0, send ACK0." A blue arrow labeled "ACK0" extends to a point on the sender's timeline labeled "rcv ACK0, send pkt1." A second operation begins just below this on the sender's timeline, labeled "timeout, resend pkt1." Blue arrows now extend from the previous point on the sender's timeline and from this one. Operations from the previous point on the timeline resume and resolve as normal. From the timeout, an arrow labeled "pkt1" extends to a point on the receiver's timeline labeled "rcv pkt1 (detect duplicate), send ACK1." An arrow labeled "ACK1" extends to a point on the sender's timeline labeled "rcv ACK1, do nothing."</p>
</details>
</figure>
<figure id="P700101195200000000000000000133B" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000133B">
<img alt="Illustration of a stop-and-wait protocol." height="217" width="316" aria-describedby="P7001011952000000000000000001340" id="P700101195200000000000000000A26E" data-uri="P7001011952000000000000000005552" src="../images/4055103017.png"></img>
<figcaption id="P700101195200000000000000000A26F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A26F"><header><h1 class="title" id="P700101195200000000000000000A270" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A270" epub:type="title"><span class="pagebreak" title="219" id="P700101195200000000000000000133F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000133F" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">Figure </span><span class="number">3.17</span> Stop-and-wait versus pipelined protocol</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001340" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001340" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103017.xhtml#la_4055103017"><span class="label">Description</span></a></div>
<figure id="P7001011952000000000000000001342" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001342">
<img alt="Illustration of a pipelined protocol." height="217" width="316" aria-describedby="P7001011952000000000000000001344" id="P700101195200000000000000000A272" data-uri="P7001011952000000000000000005553" src="../images/4055103017a.png"></img>
<details class="longdesc" id="P7001011952000000000000000001344" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001344">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000A273" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A273">This illustration is the same as in the previous figure; however, we see a series of data packets moving from the West Coast server to the East Coast server along the top cable between the two servers. Along the bottom cable, we see a series of packets moving from the East Coast server to the West Coast server, and these are identified as ACK packets.</p>
</details>
</figure>
<p class="continued" id="P700101195200000000000000000A274" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A274">To appreciate the performance impact of this stop-and-wait behavior, consider an idealized case of two hosts, one located on the West Coast of the United States and the other located on the East Coast, as shown in <a class="xref" href="#P700101195200000000000000000133B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.17</span></a>. The speed-of-light round-trip propagation delay between these two end systems, RTT, is approximately 30 milliseconds. Suppose that they are connected by a channel with a transmission rate, <i>R</i>, of 1 Gbps (10<sup>9</sup> bits per second). With a packet size, <i>L,</i> of 1,000 bytes (8,000 bits) per packet, including both header fields and data, the time needed to actually transmit the packet into the 1 Gbps link is</p>
<div class="informalequation" id="P7001011952000000000000000001347" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001347"><m:math display="block" alttext="" data-uri="" altimg-width="393" altimg-height="44" altimg="../images/ch03math06.png"><m:mrow><m:msub><m:mi>d</m:mi><m:mrow><m:mi>t</m:mi><m:mi>r</m:mi><m:mi>a</m:mi><m:mi>n</m:mi><m:mi>s</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mfrac><m:mi>L</m:mi><m:mi>R</m:mi></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:mn>8000</m:mn><m:mtext> bits</m:mtext><m:mo>/</m:mo><m:mtext>packet</m:mtext></m:mrow><m:mrow><m:msup><m:mrow><m:mn>10</m:mn></m:mrow><m:mn>9</m:mn></m:msup><m:mtext> bits</m:mtext><m:mo>/</m:mo><m:mtext>sec</m:mtext></m:mrow></m:mfrac><m:mo>=</m:mo><m:mn>8</m:mn><m:mtext> microseconds</m:mtext></m:mrow></m:math></div>
<p id="P700101195200000000000000000A275" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A275"><a class="xref" href="#P700101195200000000000000000134B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.18(a)</span></a> shows that with our stop-and-wait protocol, if the sender begins sending the packet at <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="50" altimg-height="16" altimg="../images/ch03math07.png"><m:mrow><m:mi>t</m:mi><m:mo>=</m:mo><m:mn>0</m:mn><m:mo>,</m:mo></m:mrow></m:math></span> then at <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="102" altimg-height="13" altimg="../images/ch03math08.png"><m:mrow><m:mi>t</m:mi><m:mo>=</m:mo><m:mi>L</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mo>=</m:mo><m:mn>8</m:mn></m:mrow></m:math></span> microseconds, the last bit enters the channel at the sender side. The packet then makes its 15-msec cross-country journey, with the last bit of the packet emerging at the receiver at <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="162" altimg-height="13" altimg="../images/ch03math09.png"><m:mrow><m:mi>t</m:mi><m:mo>=</m:mo><m:mtext>RTT</m:mtext><m:mo>/</m:mo><m:mn>2</m:mn><m:mo>+</m:mo><m:mi>L</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mo>=</m:mo></m:mrow></m:math></span> 15.008 msec. Assuming for simplicity that ACK packets are extremely small (so that we can ignore their transmission time) and that the receiver can send an ACK as soon as the last bit of a data packet is received, the ACK emerges back at the sender at <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="259" altimg-height="13" altimg="../images/ch03math10.png"><m:mrow><m:mi>t</m:mi><m:mo>=</m:mo><m:mtext>RTT</m:mtext><m:mo>+</m:mo><m:mi>L</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mo>=</m:mo><m:mn>30.008</m:mn><m:mtext> msec</m:mtext><m:mo>.</m:mo></m:mrow></m:math></span> At this point, the sender can now transmit the next message. Thus, in 30.008 msec, the sender was sending for only 0.008 msec. If we define the <span class="keyword" id="P7001011952000000000000000001349" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001349"><b>utilization</b></span> of the sender (or the channel) as the fraction of time the sender is actually busy sending bits into the channel, the analysis in <a class="xref" href="#P700101195200000000000000000134B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.18(a)</span></a> shows that the stop-and-wait protocol has a rather dismal sender utilization, <i>U</i><sub>sender</sub>, of</p>
<div class="informalequation" id="P700101195200000000000000000134A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000134A"><m:math display="block" alttext="" data-uri="" altimg-width="348" altimg-height="48" altimg="../images/ch03math11.png"><m:mrow><m:msub><m:mi>U</m:mi><m:mrow><m:mtext>sender</m:mtext></m:mrow></m:msub><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>L</m:mi><m:mo>/</m:mo><m:mi>R</m:mi></m:mrow><m:mrow><m:mi>R</m:mi><m:mi>T</m:mi><m:mi>T</m:mi><m:mo>+</m:mo><m:mi>L</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mtext> </m:mtext></m:mrow></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:mn>.008</m:mn></m:mrow><m:mrow><m:mn>30.008</m:mn></m:mrow></m:mfrac><m:mo>=</m:mo><m:mn>0.00027</m:mn></m:mrow></m:math></div>
<figure id="P700101195200000000000000000134B" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000134B">
<img alt="Illustration of a stop-and-wait operation." height="381" width="709" aria-describedby="P7001011952000000000000000001350" id="P700101195200000000000000000A276" data-uri="P7001011952000000000000000005554" src="../images/4055103018.png"></img>
<figcaption id="P700101195200000000000000000A277" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A277"><header><h1 class="title" id="P700101195200000000000000000A278" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A278" epub:type="title"><span class="pagebreak" title="220" id="P700101195200000000000000000134F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000134F" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">Figure </span><span class="number">3.18</span> Stop-and-wait and pipelined sending</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001350" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001350" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103018.xhtml#la_4055103018"><span class="label">Description</span></a></div>
<figure id="P7001011952000000000000000001353" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001353">
<img alt="Illustration of a pipelined operation." height="407" width="709" aria-describedby="P7001011952000000000000000001355" id="P700101195200000000000000000A27B" data-uri="P7001011952000000000000000005555" src="../images/4055103018a.png"></img>
<details class="longdesc" id="P7001011952000000000000000001355" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001355">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000A27C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A27C">This illustration is similar to the previous, however there are multiple packets being sent from sender to receiver. The operation begins at the topmost point on the sender's timeline, which is labeled "First bit of first packet transmitted, t=0." A blue line extends from here diagonally downward to the right to the receiver's timeline, which is labeled "First bit of first packet arrives." A second blue line extends from the sender's timeline-just under the first, from a point labeled "Last bit of first packet transmitted, t=L/R"-to the receiver's timeline, to a point labeled "Last bit of first packet arrives, send ACK." A third blue line extends from the sender to the receiver, as does a fourth. All four of these are shaded together to form a single thick band of blue that extends from the sender to the receiver. The third blue line intersects with the receiver's timeline at a point labeled "Last bit of 2nd packet arrives, send ACK," and the fourth blue line intersects with the receiver's timeline at a point labeled "Last bit of 3rd packet arrives, send ACK." The second blue line (last bit of first packet) extends diagonally down and to the left back to the sender's timeline at a point labeled "ACK arrives, send next packet, t=RTT + L/R." The third blue line (last bit of 2nd packet) extends back to the sender's timeline, as does the fourth blue line (last bit of 3rd packet). The portion of the sender's timeline between "Last bit of first packet transmitted" and "ACK arrives" is labeled "RTT." The operation continues from here.</p>
</details>
</figure>
<p id="P700101195200000000000000000A27D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A27D"><span class="pagebreak" title="221" id="P7001011952000000000000000001358" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001358" epub:type="pagebreak" role="doc-pagebreak"></span>That is, the sender was busy only 2.7 hundredths of one percent of the time! Viewed another way, the sender was able to send only 1,000 bytes in 30.008 milliseconds, an effective throughput of only 267 kbps—even though a 1 Gbps link was available! Imagine the unhappy network manager who just paid a fortune for a gigabit capacity link but manages to get a throughput of only 267 kilobits per second! This is a graphic example of how network protocols can limit the capabilities provided by the underlying network hardware. Also, we have neglected lower-layer protocol-processing times at the sender and receiver, as well as the processing and queuing delays that would occur at any intermediate routers between the sender and receiver. Including these effects would serve only to further increase the delay and further accentuate the poor performance.</p>
<p id="P700101195200000000000000000A27E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A27E">The solution to this particular performance problem is simple: Rather than operate in a stop-and-wait manner, the sender is allowed to send multiple packets without waiting for acknowledgments, as illustrated in <a class="xref" href="#P700101195200000000000000000133B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.17(b)</span></a>. <a class="xref" href="#P700101195200000000000000000134B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.18(b)</span></a> shows that if the sender is allowed to transmit three packets before having to wait for acknowledgments, the utilization of the sender is essentially tripled. Since the many in-transit sender-to-receiver packets can be visualized as filling a pipeline, this technique is known as <span class="keyword" id="P700101195200000000000000000135A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000135A"><b>pipelining</b></span>. Pipelining has the following consequences for reliable data transfer protocols:</p>
<ul id="P700101195200000000000000000A27F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A27F">
<li id="P700101195200000000000000000A280" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A280"><p id="P700101195200000000000000000A281" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A281">The range of sequence numbers must be increased, since each in-transit packet (not counting retransmissions) must have a unique sequence number and there may be multiple, in-transit, unacknowledged packets.</p></li>
<li id="P700101195200000000000000000A282" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A282"><p id="P700101195200000000000000000A283" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A283">The sender and receiver sides of the protocols may have to buffer more than one packet. Minimally, the sender will have to buffer packets that have been transmitted but not yet acknowledged. Buffering of correctly received packets may also be needed at the receiver, as discussed below.</p></li>
<li id="P700101195200000000000000000A284" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A284"><p id="P700101195200000000000000000A285" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A285">The range of sequence numbers needed and the buffering requirements will depend on the manner in which a data transfer protocol responds to lost, corrupted, and overly delayed packets. Two basic approaches toward pipelined error recovery can be identified: <span class="keyword" id="P7001011952000000000000000001362" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001362"><b>Go-Back-N</b></span> and <span class="keyword" id="P7001011952000000000000000001363" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001363"><b>selective repeat</b></span>.</p></li>
</ul>
</section>
<section id="P7001011952000000000000000001364" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001364" class="level2"><header><h1 class="title" id="P700101195200000000000000000A286" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A286" epub:type="title"><span class="number">3.4.3</span> Go-Back-N (GBN)</h1></header>
<p id="P700101195200000000000000000A287" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A287">In a <span class="keyword" id="P7001011952000000000000000001367" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001367"><b>Go-Back-N (GBN) protocol</b></span>, the sender is allowed to transmit multiple packets (when available) without waiting for an acknowledgment, but is constrained to have no more than some maximum allowable number, <i>N,</i> of unacknowledged packets in the pipeline. We describe the GBN protocol in some detail in this section. But before reading on, you are encouraged to play with the GBN applet (an awesome applet!) at the companion Web site.</p>
<p id="P700101195200000000000000000A288" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A288"><a class="xref" href="#P700101195200000000000000000136B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.19</span></a> shows the sender’s view of the range of sequence numbers in a GBN protocol. If we define <code id="P700101195200000000000000000A289" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A289">base</code> to be the sequence number of the oldest unacknowledged<span class="pagebreak" title="222" id="P700101195200000000000000000136A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000136A" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P700101195200000000000000000136B" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000136B">
<img alt="Illustration of the sender's view of sequence numbers in Go-Back-N." height="153" width="771" aria-describedby="P700101195200000000000000000136F" id="P700101195200000000000000000A28A" data-uri="P7001011952000000000000000005556" src="../images/4055103019.png"></img>
<figcaption id="P700101195200000000000000000A28B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A28B"><header><h1 class="title" id="P700101195200000000000000000A28C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A28C" epub:type="title"><span class="label">Figure </span><span class="number">3.19</span> Sender’s view of sequence numbers in Go-Back-N</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000136F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000136F" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103019.xhtml#la_4055103019"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A28E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A28E">packet and <code id="P700101195200000000000000000A28F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A28F">nextseqnum</code> to be the smallest unused sequence number (that is, the sequence number of the next packet to be sent), then four intervals in the range of sequence numbers can be identified. Sequence numbers in the interval [<code id="P700101195200000000000000000A290" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A290">0, base-1</code>] correspond to packets that have already been transmitted and acknowledged. The interval <code id="P700101195200000000000000000A291" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A291">[base, nextseqnum-1]</code> corresponds to packets that have been sent but not yet acknowledged. Sequence numbers in the interval <code id="P700101195200000000000000000A292" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A292">[nextseqnum, base+N-1]</code> can be used for packets that can be sent immediately, should data arrive from the upper layer. Finally, sequence numbers greater than or equal to <code id="P700101195200000000000000000A293" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A293">base+N</code> cannot be used until an unacknowledged packet currently in the pipeline (specifically, the packet with sequence number <code id="P700101195200000000000000000A294" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A294">base</code>) has been acknowledged.</p>
<p id="P700101195200000000000000000A295" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A295">As suggested by <a class="xref" href="#P700101195200000000000000000136B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.19</span></a>, the range of permissible sequence numbers for transmitted but not yet acknowledged packets can be viewed as a window of size <i>N</i> over the range of sequence numbers. As the protocol operates, this window slides forward over the sequence number space. For this reason, <i>N</i> is often referred to as the <span class="keyword" id="P7001011952000000000000000001379" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001379"><b>window size</b></span> and the GBN protocol itself as a <span class="keyword" id="P700101195200000000000000000137A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000137A"><b>sliding-window protocol</b></span>. You might be wondering why we would even limit the number of outstanding, unacknowledged packets to a value of <i>N</i> in the first place. Why not allow an unlimited number of such packets? We’ll see in <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P7001011952000000000000000001442" data-foobar="7"><span class="label">Section</span> <span class="number">3.5</span></a> that flow control is one reason to impose a limit on the sender. We’ll examine another reason to do so in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="label">Section</span> <span class="number">3.7</span></a>, when we study TCP congestion control.</p>
<p id="P700101195200000000000000000A296" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A296">In practice, a packet’s sequence number is carried in a fixed-length field in the packet header. If <i>k</i> is the number of bits in the packet sequence number field, the range of sequence numbers is thus <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="85" altimg-height="19" altimg="../images/ch03math12.png"><m:mrow><m:mo>[</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:msup><m:mn>2</m:mn><m:mi>k</m:mi></m:msup><m:mo>−</m:mo><m:mn>1</m:mn><m:mo>]</m:mo><m:mo>.</m:mo></m:mrow></m:math></span> With a finite range of sequence numbers, all arithmetic involving sequence numbers must then be done using modulo 2<sup><i>k</i></sup> arithmetic. (That is, the sequence number space can be thought of as a ring of size 2<sup><i>k</i></sup>, where sequence number <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="53" altimg-height="17" altimg="../images/ch03math13.png"><m:mrow><m:msup><m:mn>2</m:mn><m:mi>k</m:mi></m:msup><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> is immediately followed by sequence number 0.) Recall that <code id="P700101195200000000000000000A297" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A297">rdt3.0</code> had a 1-bit sequence number and a range of sequence numbers of [0,1]. Several of the problems at the end of this chapter explore the consequences of a finite range of sequence numbers. We will see in <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P7001011952000000000000000001442" data-foobar="7"><span class="label">Section</span> <span class="number">3.5</span></a> that TCP has a 32-bit sequence number field, where TCP sequence numbers count bytes in the byte stream rather than packets.</p>
<p id="P700101195200000000000000000A298" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A298"><a class="xref" href="#P700101195200000000000000000137F" data-foobar="1"><span class="label">Figures</span> <span class="number">3.20</span></a> and <a class="xref" href="#P700101195200000000000000000138D" data-foobar="1"><span class="number">3.21</span></a> give an extended FSM description of the sender and receiver sides of an ACK-based, NAK-free, GBN protocol. We refer to this FSM<span class="pagebreak" title="223" id="P700101195200000000000000000137E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000137E" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P700101195200000000000000000137F" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000137F">
<img alt="Extended FSM description of GBN sender." height="492" width="758" aria-describedby="P7001011952000000000000000001383" id="P700101195200000000000000000A299" data-uri="P7001011952000000000000000005557" src="../images/4055103020.png"></img>
<figcaption id="P700101195200000000000000000A29A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A29A"><header><h1 class="title" id="P700101195200000000000000000A29B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A29B" epub:type="title"><span class="label">Figure </span><span class="number">3.20</span> Extended FSM description of the GBN sender</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001383" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001383" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103020.xhtml#la_4055103020"><span class="label">Description</span></a></div>
<figure id="P700101195200000000000000000138D" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000138D">
<img alt="Extended FSM description of GBN receiver." height="316" width="500" aria-describedby="P7001011952000000000000000001391" id="P700101195200000000000000000A2A5" data-uri="P7001011952000000000000000005558" src="../images/4055103021.png"></img>
<figcaption id="P700101195200000000000000000A2A6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2A6"><header><h1 class="title" id="P700101195200000000000000000A2A7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2A7" epub:type="title"><span class="label">Figure </span><span class="number">3.21</span> Extended FSM description of the GBN receiver</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001391" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001391" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103021.xhtml#la_4055103021"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A2AC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2AC"><span class="pagebreak" title="224" id="P7001011952000000000000000001397" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001397" epub:type="pagebreak" role="doc-pagebreak"></span>description as an <i>extended FSM</i> because we have added variables (similar to programming-language variables) for <code id="P700101195200000000000000000A2AD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2AD">base</code> and <code id="P700101195200000000000000000A2AE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2AE">nextseqnum</code>, and added operations on these variables and conditional actions involving these variables. Note that the extended FSM specification is now beginning to look somewhat like a programming-language specification. <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003847" data-foobar="7">[Bochman 1984]</a> provides an excellent survey of additional extensions to FSM techniques as well as other programming-language-based techniques for specifying protocols.</p>
<p id="P700101195200000000000000000A2AF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2AF">The GBN sender must respond to three types of events:</p>
<ul id="P700101195200000000000000000A2B0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B0">
<li id="P700101195200000000000000000A2B1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B1"><p id="P700101195200000000000000000A2B2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B2"><span class="leadin">Invocation from above.</span> When <code id="P700101195200000000000000000A2B3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B3">rdt_send()</code> is called from above, the sender first checks to see if the window is full, that is, whether there are <i>N</i> outstanding, unacknowledged packets. If the window is not full, a packet is created and sent, and variables are appropriately updated. If the window is full, the sender simply returns the data back to the upper layer, an implicit indication that the window is full. The upper layer would presumably then have to try again later. In a real implementation, the sender would more likely have either buffered (but not immediately sent) this data, or would have a synchronization mechanism (for example, a semaphore or a flag) that would allow the upper layer to call <code id="P700101195200000000000000000A2B4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B4">rdt_send()</code> only when the window is not full.</p></li>
<li id="P700101195200000000000000000A2B5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B5"><p id="P700101195200000000000000000A2B6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B6"><span class="leadin">Receipt of an ACK.</span> In our GBN protocol, an acknowledgment for a packet with sequence number <i>n</i> will be taken to be a <span class="keyword" id="P70010119520000000000000000013A2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013A2"><b>cumulative acknowledgment</b></span>, indicating that all packets with a sequence number up to and including <i>n</i> have been correctly received at the receiver. We’ll come back to this issue shortly when we examine the receiver side of GBN.</p></li>
<li id="P700101195200000000000000000A2B7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B7"><p id="P700101195200000000000000000A2B8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B8"><span class="leadin">A timeout event.</span> The protocol’s name, “Go-Back-N,” is derived from the sender’s behavior in the presence of lost or overly delayed packets. As in the stop-and-wait protocol, a timer will again be used to recover from lost data or acknowledgment packets. If a timeout occurs, the sender resends <i>all</i> packets that have been previously sent but that have not yet been acknowledged. Our sender in <a class="xref" href="#P700101195200000000000000000137F" data-foobar="1"><span class="label">Figure</span> <span class="number">3.20</span></a> uses only a single timer, which can be thought of as a timer for the oldest transmitted but not yet acknowledged packet. If an ACK is received but there are still additional transmitted but not yet acknowledged packets, the timer is restarted. If there are no outstanding, unacknowledged packets, the timer is stopped.</p></li>
</ul>
<p id="P700101195200000000000000000A2B9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2B9">The receiver’s actions in GBN are also simple. If a packet with sequence number <i>n</i> is received correctly and is in order (that is, the data last delivered to the upper layer came from a packet with sequence number <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="48" altimg-height="13" altimg="../images/ch03math14.png"><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:math></span>), the receiver sends an ACK for packet <i>n</i> and delivers the data portion of the packet to the upper layer. In all other cases, the receiver discards the packet and resends an ACK for the most recently received in-order packet. Note that since packets are delivered one at a time to the upper layer, if packet <i>k</i> has been received and delivered, then all packets with a <span class="pagebreak" title="225" id="P70010119520000000000000000013A6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013A6" epub:type="pagebreak" role="doc-pagebreak"></span>sequence number lower than <i>k</i> have also been delivered. Thus, the use of cumulative acknowledgments is a natural choice for GBN.</p>
<p id="P700101195200000000000000000A2BA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2BA">In our GBN protocol, the receiver discards out-of-order packets. Although it may seem silly and wasteful to discard a correctly received (but out-of-order) packet, there is some justification for doing so. Recall that the receiver must deliver data in order to the upper layer. Suppose now that packet <i>n</i> is expected, but packet <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="47" altimg-height="13" altimg="../images/ch03math15.png"><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> arrives. Because data must be delivered in order, the receiver <i>could</i> buffer (save) packet <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="47" altimg-height="13" altimg="../images/ch03math16.png"><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> and then deliver this packet to the upper layer after it had later received and delivered packet <i>n</i>. However, if packet <i>n</i> is lost, both it and packet <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="47" altimg-height="13" altimg="../images/ch03math17.png"><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> will eventually be retransmitted as a result of the GBN retransmission rule at the sender. Thus, the receiver can simply discard packet <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="47" altimg-height="13" altimg="../images/ch03math18.png"><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span>. The advantage of this approach is the simplicity of receiver buffering—the receiver need not buffer <i>any</i> out-of-order packets. Thus, while the sender must maintain the upper and lower bounds of its window and the position of <code id="P700101195200000000000000000A2BB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2BB">nextseqnum</code> within this window, the only piece of information the receiver need maintain is the sequence number of the next in-order packet. This value is held in the variable <code id="P700101195200000000000000000A2BC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2BC">expectedseqnum</code>, shown in the receiver FSM in <a class="xref" href="#P700101195200000000000000000138D" data-foobar="1"><span class="label">Figure</span> <span class="number">3.21</span></a>. Of course, the disadvantage of throwing away a correctly received packet is that the subsequent retransmission of that packet might be lost or garbled and thus even more retransmissions would be required.</p>
<p id="P700101195200000000000000000A2BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2BD"><a class="xref" href="#P70010119520000000000000000013B3" data-foobar="1"><span class="label">Figure</span> <span class="number">3.22</span></a> shows the operation of the GBN protocol for the case of a window size of four packets. Because of this window size limitation, the sender sends packets 0 through 3 but then must wait for one or more of these packets to be acknowledged before proceeding. As each successive ACK (for example, <code id="P700101195200000000000000000A2BE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2BE">ACK0</code> and <code id="P700101195200000000000000000A2BF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2BF">ACK1</code>) is received, the window slides forward and the sender can transmit one new packet (pkt4 and pkt5, respectively). On the receiver side, packet 2 is lost and thus packets 3, 4, and 5 are found to be out of order and are discarded.</p>
<p id="P700101195200000000000000000A2C0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2C0">Before closing our discussion of GBN, it is worth noting that an implementation of this protocol in a protocol stack would likely have a structure similar to that of the extended FSM in <a class="xref" href="#P700101195200000000000000000137F" data-foobar="1"><span class="label">Figure</span> <span class="number">3.20</span></a>. The implementation would also likely be in the form of various procedures that implement the actions to be taken in response to the various events that can occur. In such <span class="keyword" id="P70010119520000000000000000013AE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013AE"><b>event-based programming</b></span>, the various procedures are called (invoked) either by other procedures in the protocol stack, or as the result of an interrupt. In the sender, these events would be (1) a call from the upper-layer entity to invoke <code id="P700101195200000000000000000A2C1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2C1">rdt_send()</code>, (2) a timer interrupt, and (3) a call from the lower layer to invoke <code id="P700101195200000000000000000A2C2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2C2">rdt_rcv()</code> when a packet arrives. The programming exercises at the end of this chapter will give you a chance to actually implement these routines in a simulated, but realistic, network setting.</p>
<p id="P700101195200000000000000000A2C3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2C3">We note here that the GBN protocol incorporates almost all of the techniques that we will encounter when we study the reliable data transfer components of TCP in <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P7001011952000000000000000001442" data-foobar="7"><span class="label">Section</span> <span class="number">3.5</span></a>. These techniques include the use of sequence numbers, cumulative acknowledgments, checksums, and a timeout/retransmit operation.<span class="pagebreak" title="226" id="P70010119520000000000000000013B2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013B2" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000013B3" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013B3">
<img alt="Illustration of a Go-Back-N operation." height="719" width="548" aria-describedby="P70010119520000000000000000013B7" id="P700101195200000000000000000A2C4" data-uri="P7001011952000000000000000005559" src="../images/4055103022.png"></img>
<figcaption id="P700101195200000000000000000A2C5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2C5"><header><h1 class="title" id="P700101195200000000000000000A2C6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A2C6" epub:type="title"><span class="label">Figure </span><span class="number">3.22</span> Go-Back-N in operation</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000013B7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013B7" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103022.xhtml#la_4055103022"><span class="label">Description</span></a></div>
</section>
<section id="P70010119520000000000000000013F3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013F3" class="level2"><header><h1 class="title" id="P700101195200000000000000000A302" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A302" epub:type="title"><span class="number">3.4.4</span> Selective Repeat (SR)</h1></header>
<p id="P700101195200000000000000000A303" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A303">The GBN protocol allows the sender to potentially “fill the pipeline” in <a class="xref" href="#P700101195200000000000000000133B" data-foobar="1"><span class="label">Figure</span> <span class="number">3.17</span></a> with packets, thus avoiding the channel utilization problems we noted with stop-and-wait protocols. There are, however, scenarios in which GBN itself suffers from performance problems. In particular, when the window size and bandwidth-delay product are both large, many packets can be in the pipeline. A single packet error can thus cause GBN to retransmit a large number of packets, many unnecessarily. As the probability of channel errors increases, the pipeline can become filled with these unnecessary retransmissions. Imagine, in our message-dictation scenario, that <span class="pagebreak" title="227" id="P70010119520000000000000000013F6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013F6" epub:type="pagebreak" role="doc-pagebreak"></span>if every time a word was garbled, the surrounding 1,000 words (for example, a window size of 1,000 words) had to be repeated. The dictation would be slowed by all of the reiterated words.</p>
<p id="P700101195200000000000000000A304" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A304">As the name suggests, selective-repeat protocols avoid unnecessary retransmissions by having the sender retransmit only those packets that it suspects were received in error (that is, were lost or corrupted) at the receiver. This individual, as-needed, retransmission will require that the receiver <i>individually</i> acknowledge correctly received packets. A window size of <i>N</i> will again be used to limit the number of outstanding, unacknowledged packets in the pipeline. However, unlike GBN, the sender will have already received ACKs for some of the packets in the window. <a class="xref" href="#P70010119520000000000000000013F9" data-foobar="1"><span class="label">Figure</span> <span class="number">3.23</span></a> shows the SR sender’s view of the sequence number space. <a class="xref" href="#P7001011952000000000000000001400" data-foobar="1"><span class="label">Figure</span> <span class="number">3.24</span></a> details the various actions taken by the SR sender.</p>
<p id="P700101195200000000000000000A305" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A305">The SR receiver will acknowledge a correctly received packet whether or not it is in order. Out-of-order packets are buffered until any missing packets (that is, packets with lower sequence numbers) are received, at which point a batch of packets can be delivered in order to the upper layer. <a class="xref" href="#P7001011952000000000000000001405" data-foobar="1"><span class="label">Figure</span> <span class="number">3.25</span></a> itemizes the various actions taken by the SR receiver. <a class="xref" href="#P700101195200000000000000000140C" data-foobar="1"><span class="label">Figure</span> <span class="number">3.26</span></a> shows an example of SR operation in the presence of lost packets. Note that in <a class="xref" href="#P700101195200000000000000000140C" data-foobar="1"><span class="label">Figure</span> <span class="number">3.26</span></a>, the receiver initially buffers packets 3, 4, and 5, and delivers them together with packet 2 to the upper layer when packet 2 is finally received.</p>
<figure id="P70010119520000000000000000013F9" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013F9">
<img alt="Illustration of selective-repeat, sender view of sequence numbers." height="467" width="791" aria-describedby="P70010119520000000000000000013FD" id="P700101195200000000000000000A306" data-uri="P700101195200000000000000000555A" src="../images/4055103023.png"></img>
<figcaption id="P700101195200000000000000000A307" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A307"><header><h1 class="title" id="P700101195200000000000000000A308" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A308" epub:type="title"><span class="label">Figure </span><span class="number">3.23</span> Selective-repeat (SR) sender and receiver views of sequence-number space</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000013FD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000013FD" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103023.xhtml#la_4055103023"><span class="label">Description</span></a></div>
<figure id="P7001011952000000000000000001400" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001400">
<img alt="" height="372" width="672" id="P700101195200000000000000000A30B" data-uri="P700101195200000000000000000555B" src="../images/4055103024.png"></img>
<figcaption id="P700101195200000000000000000A30C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A30C"><header><h1 class="title" id="P700101195200000000000000000A30D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A30D" epub:type="title"><span class="pagebreak" title="228" id="P7001011952000000000000000001404" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001404" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">Figure </span><span class="number">3.24</span> SR sender events and actions</h1></header>
</figcaption>
</figure>
<figure id="P7001011952000000000000000001405" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001405">
<img alt="" height="372" width="672" id="P700101195200000000000000000A30E" data-uri="P700101195200000000000000000555C" src="../images/4055103025.png"></img>
<figcaption id="P700101195200000000000000000A30F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A30F"><header><h1 class="title" id="P700101195200000000000000000A310" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A310" epub:type="title"><span class="label">Figure </span><span class="number">3.25</span> SR receiver events and actions</h1></header>
</figcaption>
</figure>
<p id="P700101195200000000000000000A311" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A311">It is important to note that in Step 2 in <a class="xref" href="#P7001011952000000000000000001405" data-foobar="1"><span class="label">Figure</span> <span class="number">3.25</span></a>, the receiver reacknowledges (rather than ignores) already received packets with certain sequence numbers <i>below</i> the current window base. You should convince yourself that this reacknowledgment is indeed needed. Given the sender and receiver sequence number spaces in <a class="xref" href="#P70010119520000000000000000013F9" data-foobar="1"><span class="label">Figure</span> <span class="number">3.23</span></a>, for example, if there is no ACK for packet <code id="P700101195200000000000000000A312" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A312"><b>send_base</b></code> propagating from the<span class="pagebreak" title="229" id="P700101195200000000000000000140B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000140B" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P700101195200000000000000000140C" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000140C">
<img alt="Illustration of SR operation." height="744" width="785" aria-describedby="P7001011952000000000000000001410" id="P700101195200000000000000000A313" data-uri="P700101195200000000000000000555D" src="../images/4055103026.png"></img>
<figcaption id="P700101195200000000000000000A314" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A314"><header><h1 class="title" id="P700101195200000000000000000A315" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A315" epub:type="title"><span class="label">Figure </span><span class="number">3.26</span> SR operation</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001410" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001410" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103026.xhtml#la_4055103026"><span class="label">Description</span></a></div>
<p class="continued" id="P700101195200000000000000000A31C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A31C">receiver to the sender, the sender will eventually retransmit packet <code id="P700101195200000000000000000A31D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A31D"><b>send_base</b></code>, even though it is clear (to us, not the sender!) that the receiver has already received that packet. If the receiver were not to acknowledge this packet, the sender’s window would never move forward! This example illustrates an important aspect of SR protocols (and many other protocols as well). The sender and receiver will not always have an identical view of what has been received correctly and what has not. For SR protocols, this means that the sender and receiver windows will not always coincide.</p>
<p id="P700101195200000000000000000A31E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A31E"><span class="pagebreak" title="230" id="P700101195200000000000000000141A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000141A" epub:type="pagebreak" role="doc-pagebreak"></span>The lack of synchronization between sender and receiver windows has important consequences when we are faced with the reality of a finite range of sequence numbers. Consider what could happen, for example, with a finite range of four packet sequence numbers, 0, 1, 2, 3, and a window size of three. Suppose packets 0 through 2 are transmitted and correctly received and acknowledged at the receiver. At this point, the receiver’s window is over the fourth, fifth, and sixth packets, which have sequence numbers 3, 0, and 1, respectively. Now consider two scenarios. In the first scenario, shown in <a class="xref" href="#P7001011952000000000000000001421" data-foobar="1"><span class="label">Figure</span> <span class="number">3.27(a)</span></a>, the ACKs for the first three packets are lost and the sender retransmits these packets. The receiver thus next receives a packet with sequence number 0—a copy of the first packet sent.</p>
<p id="P700101195200000000000000000A31F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A31F">In the second scenario, shown in <a class="xref" href="#P7001011952000000000000000001421" data-foobar="1"><span class="label">Figure</span> <span class="number">3.27(b)</span></a>, the ACKs for the first three packets are all delivered correctly. The sender thus moves its window forward and sends the fourth, fifth, and sixth packets, with sequence numbers 3, 0, and 1, respectively. The packet with sequence number 3 is lost, but the packet with sequence number 0 arrives—a packet containing <i>new</i> data.</p>
<p id="P700101195200000000000000000A320" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A320">Now consider the receiver’s viewpoint in <a class="xref" href="#P7001011952000000000000000001421" data-foobar="1"><span class="label">Figure</span> <span class="number">3.27</span></a>, which has a figurative curtain between the sender and the receiver, since the receiver cannot “see” the actions taken by the sender. All the receiver observes is the sequence of messages it receives from the channel and sends into the channel. As far as it is concerned, the two scenarios in <a class="xref" href="#P7001011952000000000000000001421" data-foobar="1"><span class="label">Figure</span> <span class="number">3.27</span></a> are <i>identical.</i> There is no way of distinguishing the retransmission of the first packet from an original transmission of the fifth packet. Clearly, a window size that is 1 less than the size of the sequence number space won’t work. But how small must the window size be? A problem at the end of the chapter asks you to show that the window size must be less than or equal to half the size of the sequence number space for SR protocols.</p>
<p id="P700101195200000000000000000A321" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A321">At the companion Web site, you will find an applet that animates the operation of the SR protocol. Try performing the same experiments that you did with the GBN applet. Do the results agree with what you expect?</p>
<p id="P700101195200000000000000000A322" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A322">This completes our discussion of reliable data transfer protocols. We’ve covered a <i>lot</i> of ground and introduced numerous mechanisms that together provide for reliable data transfer. <a class="xref" href="#P700101195200000000000000000142E" data-foobar="1"><span class="label">Table</span> <span class="number">3.1</span></a> summarizes these mechanisms. Now that we have seen all of these mechanisms in operation and can see the “big picture,” we encourage you to review this section again to see how these mechanisms were incrementally added to cover increasingly complex (and realistic) models of the channel connecting the sender and receiver, or to improve the performance of the protocols.</p>
<p id="P700101195200000000000000000A323" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A323">Let’s conclude our discussion of reliable data transfer protocols by considering one remaining assumption in our underlying channel model. Recall that we have assumed that packets cannot be reordered within the channel between the sender and receiver. This is generally a reasonable assumption when the sender and receiver are connected by a single physical wire. However, when the “channel” connecting the two is a network, packet reordering can occur. One manifestation of packet reordering is that old copies of a packet with a sequence or acknowledgment<span class="pagebreak" title="231" id="P7001011952000000000000000001420" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001420" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000001421" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001421">
<img alt="Illustration of SR receiver dilemma with too-large windows: A new packet or a retransmission?" height="353" width="515" aria-describedby="P7001011952000000000000000001425" id="P700101195200000000000000000A324" data-uri="P700101195200000000000000000555E" src="../images/4055103027.png"></img>
<figcaption id="P700101195200000000000000000A325" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A325"><header><h1 class="title" id="P700101195200000000000000000A326" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A326" epub:type="title"><span class="label">Figure </span><span class="number">3.27</span> SR receiver dilemma with too-large windows: A new packet or a retransmission?</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001425" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001425" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103027.xhtml#la_4055103027"><span class="label">Description</span></a></div>
<figure id="P7001011952000000000000000001429" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001429">
<img alt="Illustration of SR receiver dilemma with too-large windows: A new packet or a retransmission?" height="359" width="516" aria-describedby="P700101195200000000000000000142B" id="P700101195200000000000000000A32A" data-uri="P700101195200000000000000000555F" src="../images/4055103027a.png"></img>
<details class="longdesc" id="P700101195200000000000000000142B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000142B">
<summary><span class="label">Description</span></summary>
<p id="P700101195200000000000000000A32B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A32B">This illustration uses the same structure as the previous illustration. Operations begin at the topmost portion of the sender's timeline, when pkt0 is sent. A blue arrow extends vertically to the right and passes through the curtain where it intersects with the receiver's timeline. The number sequence 012 is highlighted. In response to pkt0, the receiver sends ACK0, which is represented by a blue arrow that extends diagonally downward to the left, passes through the curtain, and intersects with the sender's timeline. The number sequence 123 is highlighted for this action. Below pkt0 on the sender's timeline, pkt1 is sent. Number sequence 012 is highlighted. An arrow extends through the curtain and intersects with the receiver's timeline. In response to pkt1, the receiver sends ACK1. The number sequence 230 is highlighted. An arrow extends diagonally downward to the left, passes through the curtain, and intersects with the sender's timeline. Below pkt1 on the sender's timeline, pkt2 is sent. Number sequence 012 is highlighted. An arrow extends horizontally to the right, through the curtain, and intersects with the receiver's timeline. In response to pkt2, the receiver sends ACK2. Number sequence 301 is highlighted. ACK2 is sent.</p>
<p id="P700101195200000000000000000A32C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A32C">At this point on the sender's timeline, ACK0 is received and pkt3 is sent. Sequence number 123 is highlighted. An arrow extends diagonally rightward and terminates. Below this, ACK1 is received and pkt0 is sent. Number sequence 230 is highlighted. An arrow extends diagonally to the right, passes through the curtain, and intersects with the receiver's timeline at a point labeled "receive packet with seq number 0."</p>
</details>
</figure>
<figure id="P700101195200000000000000000142E" class="table" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000142E">
<figcaption id="P700101195200000000000000000A32D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A32D"><header><h1 class="title" id="P700101195200000000000000000A32E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A32E" epub:type="title"><span class="pagebreak" title="232" id="P7001011952000000000000000001431" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001431" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">Table </span><span class="number">3.1</span> Summary of reliable data transfer mechanisms and their use</h1></header></figcaption>
<table id="P700101195200000000000000000A32F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A32F">
<tbody>
<tr>
<td id="P700101195200000000000000000A330" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A330">Mechanism</td>
<td id="P700101195200000000000000000A331" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A331">Use, Comments</td>
</tr>
<tr>
<td id="P700101195200000000000000000A332" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A332">Checksum</td>
<td id="P700101195200000000000000000A333" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A333">Used to detect bit errors in a transmitted packet.</td>
</tr>
<tr>
<td id="P700101195200000000000000000A334" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A334">Timer</td>
<td id="P700101195200000000000000000A335" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A335">Used to timeout/retransmit a packet, possibly because the packet (or its ACK) was lost within the channel. Because timeouts can occur when a packet is delayed but not lost (premature timeout), or when a packet has been received by the receiver but the receiver-to-sender ACK has been lost, duplicate copies of a packet may be received by a receiver.</td>
</tr>
<tr>
<td id="P700101195200000000000000000A336" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A336">Sequence number</td>
<td id="P700101195200000000000000000A337" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A337">Used for sequential numbering of packets of data flowing from sender to receiver. Gaps in the sequence numbers of received packets allow the receiver to detect a lost packet. Packets with duplicate sequence numbers allow the receiver to detect duplicate copies of a packet.</td>
</tr>
<tr>
<td id="P700101195200000000000000000A338" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A338">Acknowledgment</td>
<td id="P700101195200000000000000000A339" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A339">Used by the receiver to tell the sender that a packet or set of packets has been received correctly. Acknowledgments will typically carry the sequence number of the packet or packets being acknowledged. Acknowledgments may be individual or cumulative, depending on the protocol.</td>
</tr>
<tr>
<td id="P700101195200000000000000000A33A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A33A">Negative acknowledgment</td>
<td id="P700101195200000000000000000A33B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A33B">Used by the receiver to tell the sender that a packet has not been received correctly. Negative acknowledgments will typically carry the sequence number of the packet that was not received correctly.</td>
</tr>
<tr>
<td id="P700101195200000000000000000A33C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A33C">Window, pipelining</td>
<td id="P700101195200000000000000000A33D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A33D">The sender may be restricted to sending only packets with sequence numbers that fall within a given range. By allowing multiple packets to be transmitted but not yet acknowledged, sender utilization can be increased over a stop-and-wait mode of operation. We’ll see shortly that the window size may be set on the basis of the receiver’s ability to receive and buffer messages, or the level of congestion in the network, or both.</td>
</tr>
</tbody>
</table>
</figure>
<p class="continued" id="P700101195200000000000000000A33E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A33E">number of <i>x</i> can appear, even though neither the sender’s nor the receiver’s window contains <i>x</i>. With packet reordering, the channel can be thought of as essentially buffering packets and spontaneously emitting these packets at <i>any</i> point in the future. Because sequence numbers may be reused, some care must be taken to guard against such duplicate packets. The approach taken in practice is to ensure that a sequence number is not reused until the sender is “sure” that any previously sent packets with sequence number <i>x</i> are no longer in the network. This is done by assuming that a packet cannot “live” in the network for longer than some fixed maximum amount of time. A maximum packet lifetime of approximately three minutes is assumed in the TCP extensions for high-speed networks <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003B05" data-foobar="7">[RFC 1323]</a>. <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C3D" data-foobar="7">[Sunshine 1978]</a> describes a method for using sequence numbers such that reordering problems can be completely avoided.</p>
</section>
</section></body></html>