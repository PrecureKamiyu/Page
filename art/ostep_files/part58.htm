<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Saving and Restoring Context</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part57.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part59.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">Saving and Restoring Context</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Now that the OS has regained control, whether cooperatively via a sys- tem call, or more forcefully via a timer interrupt, a decision has to be made: whether to continue running the currently-running process, or switch to a different one. This decision is made by a part of the operating system known as the <b>scheduler</b>; we will discuss scheduling policies in great detail in the next few chapters.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">If the decision is made to switch, the OS then executes a low-level piece of code which we refer to as a <b>context switch</b>. A context switch is conceptually simple: all the OS has to do is save a few register values for the currently-executing process (onto its kernel stack, for example) and restore a few for the soon-to-be-executing process (from its kernel stack). By doing so, the OS thus ensures that when the return-from-trap instruction is finally executed, instead of returning to the process that was running, the system resumes execution of another process.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To save the context of the currently-running process, the OS will exe- cute some low-level assembly code to save the general purpose registers, PC, as well as the kernel stack pointer of the currently-running process, and then restore said registers, PC, and switch to the kernel stack for the soon-to-be-executing process. By switching stacks, the kernel enters the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-top: 3pt;padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">OS @ boot             Hardware</p><p style="text-indent: 0pt;text-align: left;"><span><img width="369" height="1" alt="image" src="Image_036.png"/></span></p><p class="s36" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">(kernel mode) initialize trap table</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-top: 6pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">start interrupt timer</p><p class="s12" style="padding-left: 56pt;text-indent: -4pt;line-height: 91%;text-align: left;">remember addresses of... syscall handler</p><p class="s12" style="padding-left: 56pt;text-indent: 0pt;line-height: 8pt;text-align: left;">timer handler</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">start timer</p><p class="s12" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">interrupt CPU in X ms</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-top: 3pt;padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">OS @ run              Hardware           Program</p><p class="s36" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">(kernel mode)                           (user mode)</p><p style="padding-left: 46pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="369" height="1" alt="image" src="Image_037.png"/></span></p><p class="s12" style="padding-left: 279pt;text-indent: 0pt;line-height: 7pt;text-align: left;">Process A</p><p class="s12" style="padding-left: 279pt;text-indent: 0pt;line-height: 8pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-top: 5pt;padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Handle the trap</p><p class="s12" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Call <span class="s38">switch() </span>routine</p><p class="s12" style="padding-left: 56pt;text-indent: 0pt;line-height: 92%;text-align: left;">save regs(A) to proc-struct(A) restore regs(B) from proc-struct(B) switch to k-stack(B)</p><p class="s36" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">return-from-trap (into B)</p><p class="s36" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">timer interrupt</p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 92%;text-align: left;">save regs(A) to k-stack(A) move to kernel mode jump to trap handler</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 91%;text-align: left;">restore regs(B) from k-stack(B) move to user mode</p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">jump to B’s PC</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Process B</p><p class="s12" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part59.htm">Table 6.3: Limited Direction Execution Protocol (Timer Interrupt)</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part57.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part59.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
