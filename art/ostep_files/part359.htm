<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>33.7 Another Problem: State Management</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part358.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part360.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">33.7 Another Problem: State Management</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Another issue with the event-based approach is that such code is gen- erally more complicated to write than traditional thread-based code. The reason is as follows: when an event handler issues an asynchronous I/O, it must package up some program state for the next event handler to use when the I/O finally completes; this additional work is not needed in thread-based programs, as the state the program needs is on the stack of the thread. Adya et al. call this work <b>manual stack management</b>, and it is fundamental to event-based programming [A+02].</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To make this point more concrete, let’s look at a simple example in which a thread-based server needs to read from a file descriptor (<span class="s41">fd</span>) and, once complete, write the data that it read from the file to a network socket descriptor (<span class="s41">sd</span>). The code (ignoring error checking) looks like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">int rc = read(fd, buffer, size); rc = write(sd, buffer, size);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">As you can see, in a multi-threaded program, doing this kind of work is trivial; when the <span class="s41">read() </span>finally returns, the code immediately knows which socket to write to because that information is on the stack of the thread (in the variable <span class="s41">sd</span>).</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_510.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In an event-based system, life is not so easy. To perform the same task, we’d first issue the read asynchronously, using the AIO calls described above. Let’s say we then periodically check for completion of the read using the <span class="s41">aio error() </span>call; when that call informs us that the read is complete, how does the event-based server know what to do?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The solution, as described by Adya et al. [A+02], is to use an old pro- gramming language construct known as a <b>continuation </b>[FHK84]. Though it sounds complicated, the idea is rather simple: basically, record the needed information to finish processing this event in some data struc- ture; when the event happens (i.e., when the disk I/O completes), look up the needed information and process the event.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this specific case, the solution would be to record the socket de- scriptor (<span class="s41">sd</span>) in some kind of data structure (e.g., a hash table), indexed by the file descriptor (<span class="s41">fd</span>). When the disk I/O completes, the event han- dler would use the file descriptor to look up the continuation, which will return the value of the socket descriptor to the caller. At this point (fi- nally), the server can then do the last bit of work to write the data to the socket.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part358.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part360.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
