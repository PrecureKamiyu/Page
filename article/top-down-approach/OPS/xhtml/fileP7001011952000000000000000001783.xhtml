<?xml version="1.0" encoding="utf-8"?><html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/"><head>
<meta name="dcterms.conformsTo" content="PXE Basic 1.0"></meta>
<meta name="generator" content="PXE Tools version 1.39.109"></meta>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.109, partial=false-->
<title>Homework Problems and Questions</title><link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/sepia.css"></link><link rel="alternate stylesheet" type="text/css" title="night" href="../css/night.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/main.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/print.css"></link>
<script src="js/format_lg_obj.js"></script>
</head><body epub:type="bodymatter">
<section id="P7001011952000000000000000001783" class="conclusion level1"><header><h1 class="title" id="P700101195200000000000000000A5AF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5AF" epub:type="title">Homework Problems and Questions</h1></header>
<section id="P7001011952000000000000000001785" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001785" epub:type="practice" class="practice level2"><header><h1 class="title" id="P700101195200000000000000000A5B0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B0" epub:type="title"><span class="label">Chapter </span> <span class="number">3</span> Review Questions</h1></header>
<section id="P7001011952000000000000000001787" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001787" class="practicediv level3"><header><h1 class="title" id="P700101195200000000000000000A5B1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B1" epub:type="title"><span class="label">SECTIONS </span><span class="number">3.1</span>–<span class="number">3.3</span> </h1></header>
<ol class="practicelist dynamiclist" id="P700101195200000000000000000A5B2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B2">
<li class="general-problem" id="P700101195200000000000000000178A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000178A"><div class="question" id="P700101195200000000000000000A5B3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B3"><p id="P700101195200000000000000000A5B4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B4"><span class="lc_labelnum"><span class="label">R</span><span class="number">1.</span></span> Suppose the network layer provides the following service. The network layer in the source host accepts a segment of maximum size 1,200 bytes and a destination host address from the transport layer. The network layer then guarantees to deliver the segment to the transport layer at the destination host. Suppose many network application processes can be running at the destination host.</p></div>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A5B5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B5">
<li id="P700101195200000000000000000A5B6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B6"><p id="P700101195200000000000000000A5B7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B7">Design the simplest possible transport-layer protocol that will get application data to the desired process at the destination host. Assume the operating system in the destination host has assigned a 4-byte port number to each running application process.</p></li>
<li id="P700101195200000000000000000A5B8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B8"><p id="P700101195200000000000000000A5B9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5B9">Modify this protocol so that it provides a “return address” to the destination process.</p></li>
<li id="P700101195200000000000000000A5BA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5BA"><p id="P700101195200000000000000000A5BB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5BB">In your protocols, does the transport layer “have to do anything” in the core of the computer network?</p></li>
</ol></li>
<li class="general-problem" id="P7001011952000000000000000001794" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001794"><div class="question" id="P700101195200000000000000000A5BC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5BC"><p id="P700101195200000000000000000A5BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5BD"><span class="pagebreak" title="287" id="P7001011952000000000000000001797" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001797" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">R</span><span class="number">2.</span></span> Consider a planet where everyone belongs to a family of six, every family lives in its own house, each house has a unique address, and each person in a given house has a unique name. Suppose this planet has a mail service that delivers letters from source house to destination house. The mail service requires that (1) the letter be in an envelope, and that (2) the address of the destination house (and nothing more) be clearly written on the envelope. Suppose each family has a delegate family member who collects and distributes letters for the other family members. The letters do not necessarily provide any indication of the recipients of the letters.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A5BE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5BE">
<li id="P700101195200000000000000000A5BF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5BF"><p id="P700101195200000000000000000A5C0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C0">Using the solution to Problem R1 above as inspiration, describe a protocol that the delegates can use to deliver letters from a sending family member to a receiving family member.</p></li>
<li id="P700101195200000000000000000A5C1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C1"><p id="P700101195200000000000000000A5C2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C2">In your protocol, does the mail service ever have to open the envelope and examine the letter in order to provide its service?</p></li>
</ol></div></li>
<li class="general-problem" id="P700101195200000000000000000179D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000179D"><div class="question" id="P700101195200000000000000000A5C3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C3"><p id="P700101195200000000000000000A5C4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C4"><span class="lc_labelnum"><span class="label">R</span><span class="number">3.</span></span> Consider a TCP connection between Host A and Host B. Suppose that the TCP segments traveling from Host A to Host B have source port number <i>x</i> and destination port number <i>y</i>. What are the source and destination port numbers for the segments traveling from Host B to Host A?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017A0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017A0"><div class="question" id="P700101195200000000000000000A5C5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C5"><p id="P700101195200000000000000000A5C6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C6"><span class="lc_labelnum"><span class="label">R</span><span class="number">4.</span></span> Describe why an application developer might choose to run an application over UDP rather than TCP.</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017A3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017A3"><div class="question" id="P700101195200000000000000000A5C7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C7"><p id="P700101195200000000000000000A5C8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C8"><span class="lc_labelnum"><span class="label">R</span><span class="number">5.</span></span> Why is it that voice and video traffic is often sent over TCP rather than UDP in today’s Internet? (<i>Hint</i>: The answer we are looking for has nothing to do with TCP’s congestion-control mechanism.)</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017A6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017A6"><div class="question" id="P700101195200000000000000000A5C9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5C9"><p id="P700101195200000000000000000A5CA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5CA"><span class="lc_labelnum"><span class="label">R</span><span class="number">6.</span></span> Is it possible for an application to enjoy reliable data transfer even when the application runs over UDP? If so, how?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017A9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017A9"><div class="question" id="P700101195200000000000000000A5CB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5CB"><p id="P700101195200000000000000000A5CC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5CC"><span class="lc_labelnum"><span class="label">R</span><span class="number">7.</span></span> Suppose a process in Host C has a UDP socket with port number 6789. Suppose both Host A and Host B each send a UDP segment to Host C with destination port number 6789. Will both of these segments be directed to the same socket at Host C? If so, how will the process at Host C know that these two segments originated from two different hosts?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017AC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017AC"><div class="question" id="P700101195200000000000000000A5CD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5CD"><p id="P700101195200000000000000000A5CE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5CE"><span class="lc_labelnum"><span class="label">R</span><span class="number">8.</span></span> Suppose that a Web server runs in Host C on port 80. Suppose this Web server uses persistent connections, and is currently receiving requests from two different Hosts, A and B. Are all of the requests being sent through the same socket at Host C? If they are being passed through different sockets, do both of the sockets have port 80? Discuss and explain.</p></div></li>
</ol>
</section>
<section id="P70010119520000000000000000017AF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017AF" class="practicediv level3"><header><h1 class="title" id="P700101195200000000000000000A5CF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5CF" epub:type="title"><span class="label">SECTION </span><span class="number">3.4</span></h1></header>
<ol class="practicelist dynamiclist" id="P700101195200000000000000000A5D0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D0">
<li class="general-problem" id="P70010119520000000000000000017B2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017B2"><div class="question" id="P700101195200000000000000000A5D1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D1"><p id="P700101195200000000000000000A5D2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D2"><span class="lc_labelnum"><span class="label">R</span><span class="number">9.</span></span> In our <code id="P700101195200000000000000000A5D3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D3">rdt</code> protocols, why did we need to introduce sequence numbers?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017B6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017B6"><div class="question" id="P700101195200000000000000000A5D4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D4"><p id="P700101195200000000000000000A5D5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D5"><span class="lc_labelnum"><span class="label">R</span><span class="number">10.</span></span> In our <code id="P700101195200000000000000000A5D6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D6">rdt</code> protocols, why did we need to introduce timers?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017BA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017BA"><div class="question" id="P700101195200000000000000000A5D7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D7"><p id="P700101195200000000000000000A5D8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D8"><span class="pagebreak" title="288" id="P70010119520000000000000000017BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017BD" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">R</span><span class="number">11.</span></span> Suppose that the roundtrip delay between sender and receiver is constant and known to the sender. Would a timer still be necessary in protocol <code id="P700101195200000000000000000A5D9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5D9">rdt 3.0</code>, assuming that packets can be lost? Explain.</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017BF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017BF"><div class="question" id="P700101195200000000000000000A5DA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5DA"><p id="P700101195200000000000000000A5DB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5DB"><span class="lc_labelnum"><span class="label">R</span><span class="number">12.</span></span> Visit the Go-Back-N Java applet at the companion Web site.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A5DC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5DC">
<li id="P700101195200000000000000000A5DD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5DD"><p id="P700101195200000000000000000A5DE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5DE">Have the source send five packets, and then pause the animation before any of the five packets reach the destination. Then kill the first packet and resume the animation. Describe what happens.</p></li>
<li id="P700101195200000000000000000A5DF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5DF"><p id="P700101195200000000000000000A5E0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E0">Repeat the experiment, but now let the first packet reach the destination and kill the first acknowledgment. Describe again what happens.</p></li>
<li id="P700101195200000000000000000A5E1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E1"><p id="P700101195200000000000000000A5E2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E2">Finally, try sending six packets. What happens?</p></li>
</ol></div></li>
<li class="general-problem" id="P70010119520000000000000000017C9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017C9"><div class="question" id="P700101195200000000000000000A5E3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E3"><p id="P700101195200000000000000000A5E4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E4"><span class="lc_labelnum"><span class="label">R</span><span class="number">13.</span></span> Repeat R12, but now with the Selective Repeat Java applet. How are Selective Repeat and Go-Back-N different?</p></div></li>
</ol>
</section>
<section id="P70010119520000000000000000017CC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017CC" class="practicediv level3"><header><h1 class="title" id="P700101195200000000000000000A5E5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E5" epub:type="title"><span class="label">SECTION </span><span class="number">3.5</span></h1></header>
<ol class="practicelist dynamiclist" id="P700101195200000000000000000A5E6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E6">
<li class="general-problem" id="P70010119520000000000000000017CF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017CF"><div class="question" id="P700101195200000000000000000A5E7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E7"><p id="P700101195200000000000000000A5E8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E8"><span class="lc_labelnum"><span class="label">R</span><span class="number">14.</span></span> True or false?</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A5E9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5E9">
<li id="P700101195200000000000000000A5EA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5EA"><p id="P700101195200000000000000000A5EB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5EB">Host A is sending Host B a large file over a TCP connection. Assume Host B has no data to send Host A. Host B will not send acknowledgments to Host A because Host B cannot piggyback the acknowledgments on data.</p></li>
<li id="P700101195200000000000000000A5EC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5EC"><p id="P700101195200000000000000000A5ED" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5ED">The size of the TCP <code id="P700101195200000000000000000A5EE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5EE">rwnd</code> never changes throughout the duration of the connection.</p></li>
<li id="P700101195200000000000000000A5EF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5EF"><p id="P700101195200000000000000000A5F0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F0">Suppose Host A is sending Host B a large file over a TCP connection. The number of unacknowledged bytes that A sends cannot exceed the size of the receive buffer.</p></li>
<li id="P700101195200000000000000000A5F1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F1"><p id="P700101195200000000000000000A5F2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F2">Suppose Host A is sending a large file to Host B over a TCP connection. If the sequence number for a segment of this connection is <i>m</i>, then the sequence number for the subsequent segment will necessarily be <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="53" altimg-height="13" altimg="../images/ch03math47.png"><m:mrow><m:mi>m</m:mi><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:math></span>.</p></li>
<li id="P700101195200000000000000000A5F3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F3"><p id="P700101195200000000000000000A5F4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F4">The TCP segment has a field in its header for <code id="P700101195200000000000000000A5F5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F5">rwnd</code>.</p></li>
<li id="P700101195200000000000000000A5F6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F6"><p id="P700101195200000000000000000A5F7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F7">Suppose that the last <code id="P700101195200000000000000000A5F8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F8">SampleRTT</code> in a TCP connection is equal to 1 sec. The current value of <code id="P700101195200000000000000000A5F9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5F9">TimeoutInterval</code> for the connection will necessarily be <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="30" altimg-height="13" altimg="../images/ch03math48.png"><m:mrow><m:mo>≥</m:mo><m:mn>1</m:mn></m:mrow></m:math></span> sec.</p></li>
<li id="P700101195200000000000000000A5FA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5FA"><p id="P700101195200000000000000000A5FB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5FB">Suppose Host A sends one segment with sequence number 38 and 4 bytes of data over a TCP connection to Host B. In this same segment the acknowledgment number is necessarily 42.</p></li>
</ol></div></li>
<li class="general-problem" id="P70010119520000000000000000017E5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017E5"><div class="question" id="P700101195200000000000000000A5FC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5FC"><p id="P700101195200000000000000000A5FD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5FD"><span class="lc_labelnum"><span class="label">R</span><span class="number">15.</span></span> Suppose Host A sends two TCP segments back to back to Host B over a TCP connection. The first segment has sequence number 90; the second has sequence number 110.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A5FE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5FE">
<li id="P700101195200000000000000000A5FF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A5FF"><p id="P700101195200000000000000000A600" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A600">How much data is in the first segment?</p></li>
<li id="P700101195200000000000000000A601" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A601"><p id="P700101195200000000000000000A602" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A602">Suppose that the first segment is lost but the second segment arrives at B. In the acknowledgment that Host B sends to Host A, what will be the acknowledgment number?</p></li>
</ol></div></li>
<li class="general-problem" id="P70010119520000000000000000017ED" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017ED"><div class="question" id="P700101195200000000000000000A603" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A603"><p id="P700101195200000000000000000A604" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A604"><span class="pagebreak" title="289" id="P70010119520000000000000000017F0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017F0" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">R</span><span class="number">16.</span></span> Consider the Telnet example discussed in <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P7001011952000000000000000001442" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5</span></span> </a>. A few seconds after the user types the letter ‘C,’ the user types the letter ‘R.’ After typing the letter ‘R,’ how many segments are sent, and what is put in the sequence number and acknowledgment fields of the segments?</p></div></li>
</ol>
</section>
<section id="P70010119520000000000000000017F1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017F1" class="practicediv level3"><header><h1 class="title" id="P700101195200000000000000000A605" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A605" epub:type="title"><span class="label">SECTION </span><span class="number">3.7</span></h1></header>
<ol class="practicelist dynamiclist" id="P700101195200000000000000000A606" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A606">
<li class="general-problem" id="P70010119520000000000000000017F4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017F4"><div class="question" id="P700101195200000000000000000A607" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A607"><p id="P700101195200000000000000000A608" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A608"><span class="lc_labelnum"><span class="label">R</span><span class="number">17.</span></span> Suppose two TCP connections are present over some bottleneck link of rate <i>R</i> bps. Both connections have a huge file to send (in the same direction over the bottleneck link). The transmissions of the files start at the same time. What transmission rate would TCP like to give to each of the connections?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017F7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017F7"><div class="question" id="P700101195200000000000000000A609" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A609"><p id="P700101195200000000000000000A60A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A60A"><span class="lc_labelnum"><span class="label">R</span><span class="number">18.</span></span> True or false? Consider congestion control in TCP. When the timer expires at the sender, the value of <code id="P700101195200000000000000000A60B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A60B">ssthresh</code> is set to one half of its previous value.</p></div></li>
<li class="general-problem" id="P70010119520000000000000000017FB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017FB"><div class="question" id="P700101195200000000000000000A60C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A60C"><p id="P700101195200000000000000000A60D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A60D"><span class="lc_labelnum"><span class="label">R</span><span class="number">19.</span></span> In the discussion of TCP splitting in the sidebar in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.7</span></span> </a>, it was claimed that the response time with TCP splitting is approximately <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="305" altimg-height="17" altimg="../images/ch03math49.png"><m:mrow><m:mn>4</m:mn><m:mo>⋅</m:mo><m:msub><m:mrow><m:mtext>RTT</m:mtext></m:mrow><m:mrow><m:mtext>FE</m:mtext></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mrow><m:mtext>RTT</m:mtext></m:mrow><m:mrow><m:mtext>BE</m:mtext></m:mrow></m:msub><m:mo>+</m:mo><m:mtext>processing time</m:mtext><m:mo>.</m:mo></m:mrow></m:math></span> Justify this claim.</p></div></li>
</ol>
</section>
</section>
<section id="P70010119520000000000000000017FE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000017FE" epub:type="practice" class="practice level2"><header><h1 class="title" id="P700101195200000000000000000A60E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A60E" epub:type="title"><span class="label">Problems </span></h1></header>
<ol class="practicelist dynamiclist" id="P700101195200000000000000000A60F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A60F">
<li class="general-problem" id="P7001011952000000000000000001801" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001801"><div class="question" id="P700101195200000000000000000A610" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A610"><p id="P700101195200000000000000000A611" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A611"><span class="lc_labelnum"><span class="label">P</span><span class="number">1.</span></span> Suppose Client A initiates a Telnet session with Server S. At about the same time, Client B also initiates a Telnet session with Server S. Provide possible source and destination port numbers for</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A612" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A612">
<li id="P700101195200000000000000000A613" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A613"><p id="P700101195200000000000000000A614" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A614">The segments sent from A to S.</p></li>
<li id="P700101195200000000000000000A615" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A615"><p id="P700101195200000000000000000A616" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A616">The segments sent from B to S.</p></li>
<li id="P700101195200000000000000000A617" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A617"><p id="P700101195200000000000000000A618" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A618">The segments sent from S to A.</p></li>
<li id="P700101195200000000000000000A619" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A619"><p id="P700101195200000000000000000A61A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A61A">The segments sent from S to B.</p></li>
<li id="P700101195200000000000000000A61B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A61B"><p id="P700101195200000000000000000A61C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A61C">If A and B are different hosts, is it possible that the source port number in the segments from A to S is the same as that from B to S?</p></li>
<li id="P700101195200000000000000000A61D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A61D"><p id="P700101195200000000000000000A61E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A61E">How about if they are the same host?</p></li>
</ol></div></li>
<li class="general-problem" id="P7001011952000000000000000001811" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001811"><div class="question" id="P700101195200000000000000000A61F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A61F"><p id="P700101195200000000000000000A620" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A620"><span class="lc_labelnum"><span class="label">P</span><span class="number">2.</span></span> Consider <a class="xref" href="fileP7001011952000000000000000001139.xhtml#P700101195200000000000000000119F" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.5</span></span> </a>. What are the source and destination port values in the segments flowing from the server back to the clients’ processes? What are the IP addresses in the network-layer datagrams carrying the transport-layer segments?</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001814" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001814"><div class="question" id="P700101195200000000000000000A621" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A621"><p id="P700101195200000000000000000A622" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A622"><span class="lc_labelnum"><span class="label">P</span><span class="number">3.</span></span> UDP and TCP use 1s complement for their checksums. Suppose you have the following three 8-bit bytes: 01010011, 01100110, 01110100. What is the 1s complement of the sum of these 8-bit bytes? (Note that although UDP and TCP use 16-bit words in computing the checksum, for this problem you are being asked to consider 8-bit sums.) Show all work. Why is it that UDP takes the 1s complement of the sum; that is, why not just use the sum? With the 1s complement scheme, how does the receiver detect errors? Is it possible that a 1-bit error will go undetected? How about a 2-bit error?</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001817" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001817"><div class="question" id="P700101195200000000000000000A623" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A623"><p id="P700101195200000000000000000A624" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A624"><span class="pagebreak" title="290" id="P700101195200000000000000000181A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000181A" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">P</span><span class="number">4.</span></span></p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A625" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A625">
<li id="P700101195200000000000000000A626" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A626"><p id="P700101195200000000000000000A627" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A627">Suppose you have the following 2 bytes: 01011100 and 01100101. What is the 1s complement of the sum of these 2 bytes?</p></li>
<li id="P700101195200000000000000000A628" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A628"><p id="P700101195200000000000000000A629" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A629">Suppose you have the following 2 bytes: 11011010 and 01100101. What is the 1s complement of the sum of these 2 bytes?</p></li>
<li id="P700101195200000000000000000A62A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A62A"><p id="P700101195200000000000000000A62B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A62B">For the bytes in part (a), give an example where one bit is flipped in each of the 2 bytes and yet the 1s complement doesn’t change.</p></li>
</ol></div></li>
<li class="general-problem" id="P7001011952000000000000000001822" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001822"><div class="question" id="P700101195200000000000000000A62C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A62C"><p id="P700101195200000000000000000A62D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A62D"><span class="lc_labelnum"><span class="label">P</span><span class="number">5.</span></span> Suppose that the UDP receiver computes the Internet checksum for the received UDP segment and finds that it matches the value carried in the checksum field. Can the receiver be absolutely certain that no bit errors have occurred? Explain.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001825" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001825"><div class="question" id="P700101195200000000000000000A62E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A62E"><p id="P700101195200000000000000000A62F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A62F"><span class="lc_labelnum"><span class="label">P</span><span class="number">6.</span></span> Consider our motivation for correcting protocol <code id="P700101195200000000000000000A630" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A630">rdt2.1</code>. Show that the receiver, shown in <a class="xref" href="#P700101195200000000000000000182D" data-foobar="1"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.57</span></span> </a>, when operating with the sender shown in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P700101195200000000000000000129B" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.11</span></span> </a>, can lead the sender and receiver to enter into a deadlock state, where each is waiting for an event that will never occur.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001829" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001829"><div class="question" id="P700101195200000000000000000A631" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A631"><p id="P700101195200000000000000000A632" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A632"><span class="lc_labelnum"><span class="label">P</span><span class="number">7.</span></span> In protocol <code id="P700101195200000000000000000A633" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A633">rdt3.0</code>, the ACK packets flowing from the receiver to the sender do not have sequence numbers (although they do have an ACK field that contains the sequence number of the packet they are acknowledging). Why is it that our ACK packets do not require sequence numbers?</p>
<figure id="P700101195200000000000000000182D" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000182D">
<img alt="Illustration of an incorrect receiver for protocol at rdt 2.1." height="457" width="812" aria-describedby="P7001011952000000000000000001832" id="P700101195200000000000000000A634" data-uri="P700101195200000000000000000557E" src="../images/4055103057.png"></img>
<figcaption id="P700101195200000000000000000A635" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A635"><header><h1 class="title" id="P700101195200000000000000000A636" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A636" epub:type="title"><span class="label">Figure </span><span class="number">3.57</span> An incorrect receiver for protocol <code id="P700101195200000000000000000A637" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A637"><b>rdt 2.1</b></code></h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001832" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001832" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103057.xhtml#la_4055103057"><span class="label">Description</span></a></div></div></li>
<li class="general-problem" id="P7001011952000000000000000001838" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001838"><div class="question" id="P700101195200000000000000000A63D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A63D"><p id="P700101195200000000000000000A63E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A63E"><span class="pagebreak" title="291" id="P700101195200000000000000000183B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000183B" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">P</span><span class="number">8.</span></span> Draw the FSM for the receiver side of protocol <code id="P700101195200000000000000000A63F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A63F">rdt3.0</code>.</p></div></li>
<li class="general-problem" id="P700101195200000000000000000183D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000183D"><div class="question" id="P700101195200000000000000000A640" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A640"><p id="P700101195200000000000000000A641" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A641"><span class="lc_labelnum"><span class="label">P</span><span class="number">9.</span></span> Give a trace of the operation of protocol <code id="P700101195200000000000000000A642" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A642">rdt3.0</code> when data packets and acknowledgment packets are garbled. Your trace should be similar to that used in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P7001011952000000000000000001327" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.16</span></span> </a>.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001841" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001841"><div class="question" id="P700101195200000000000000000A643" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A643"><p id="P700101195200000000000000000A644" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A644"><span class="lc_labelnum"><span class="label">P</span><span class="number">10.</span></span> Consider a channel that can lose packets but has a maximum delay that is known. Modify protocol <code id="P700101195200000000000000000A645" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A645">rdt2.1</code> to include sender timeout and retransmit. Informally argue why your protocol can communicate correctly over this channel.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001845" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001845"><div class="question" id="P700101195200000000000000000A646" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A646"><p id="P700101195200000000000000000A647" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A647"><span class="lc_labelnum"><span class="label">P</span><span class="number">11.</span></span> Consider the <code id="P700101195200000000000000000A648" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A648">rdt2.2</code> receiver in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P70010119520000000000000000012E8" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.14</span></span> </a>, and the creation of a new packet in the self-transition (i.e., the transition from the state back to itself) in the Wait-for-0-from-below and the Wait-for-1-from-below states: <code id="P700101195200000000000000000A649" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A649">sndpkt=make_pkt(ACK, 1, checksum)</code> and <code id="P700101195200000000000000000A64A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A64A">sndpkt=make_pkt(ACK, 0, checksum)</code>. Would the protocol work correctly if this action were removed from the self-transition in the Wait-for-1-from-below state? Justify your answer. What if this event were removed from the self-transition in the Wait-for-0-from-below state? [<i>Hint</i>: In this latter case, consider what would happen if the first sender-to-receiver packet were corrupted.]</p></div></li>
<li class="general-problem" id="P700101195200000000000000000184B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000184B"><div class="question" id="P700101195200000000000000000A64B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A64B"><p id="P700101195200000000000000000A64C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A64C"><span class="lc_labelnum"><span class="label">P</span><span class="number">12.</span></span> The sender side of <code id="P700101195200000000000000000A64D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A64D">rdt3.0</code> simply ignores (that is, takes no action on) all received packets that are either in error or have the wrong value in the <code id="P700101195200000000000000000A64E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A64E">acknum</code> field of an acknowledgment packet. Suppose that in such circumstances, <code id="P700101195200000000000000000A64F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A64F">rdt3.0</code> were simply to retransmit the current data packet. Would the protocol still work? (<i>Hint</i>: Consider what would happen if there were only bit errors; there are no packet losses but premature timeouts can occur. Consider how many times the <i>n</i>th packet is sent, in the limit as <i>n</i> approaches infinity.)</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001851" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001851"><div class="question" id="P700101195200000000000000000A650" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A650"><p id="P700101195200000000000000000A651" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A651"><span class="lc_labelnum"><span class="label">P</span><span class="number">13.</span></span> Consider the <code id="P700101195200000000000000000A652" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A652">rdt</code> <code id="P700101195200000000000000000A653" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A653">3.0</code> protocol. Draw a diagram showing that if the network connection between the sender and receiver can reorder messages (that is, that two messages propagating in the medium between the sender and receiver can be reordered), then the alternating-bit protocol will not work correctly (make sure you clearly identify the sense in which it will not work correctly). Your diagram should have the sender on the left and the receiver on the right, with the time axis running down the page, showing data (D) and acknowledgment (A) message exchange. Make sure you indicate the sequence number associated with any data or acknowledgment segment.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001856" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001856"><div class="question" id="P700101195200000000000000000A654" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A654"><p id="P700101195200000000000000000A655" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A655"><span class="lc_labelnum"><span class="label">P</span><span class="number">14.</span></span> Consider a reliable data transfer protocol that uses only negative acknowledgments. Suppose the sender sends data only infrequently. Would a NAK-only protocol be preferable to a protocol that uses ACKs? Why? Now suppose the sender has a lot of data to send and the end-to-end connection experiences few losses. In this second case, would a NAK-only protocol be preferable to a protocol that uses ACKs? Why?</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001859" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001859"><div class="question" id="P700101195200000000000000000A656" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A656"><p id="P700101195200000000000000000A657" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A657"><span class="pagebreak" title="292" id="P700101195200000000000000000185C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000185C" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">P</span><span class="number">15.</span></span> Consider the cross-country example shown in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P700101195200000000000000000133B" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.17</span></span> </a>. How big would the window size have to be for the channel utilization to be greater than 98 percent? Suppose that the size of a packet is 1,500 bytes, including both header fields and data.</p></div></li>
<li class="general-problem" id="P700101195200000000000000000185D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000185D"><div class="question" id="P700101195200000000000000000A658" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A658"><p id="P700101195200000000000000000A659" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A659"><span class="lc_labelnum"><span class="label">P</span><span class="number">16.</span></span> Suppose an application uses <code id="P700101195200000000000000000A65A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A65A">rdt 3.0</code> as its transport layer protocol. As the stop-and-wait protocol has very low channel utilization (shown in the cross-country example), the designers of this application let the receiver keep sending back a number (more than two) of alternating ACK 0 and ACK 1 even if the corresponding data have not arrived at the receiver. Would this application design increase the channel utilization? Why? Are there any potential problems with this approach? Explain.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001861" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001861"><div class="question" id="P700101195200000000000000000A65B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A65B"><p id="P700101195200000000000000000A65C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A65C"><span class="lc_labelnum"><span class="label">P</span><span class="number">17.</span></span> Consider two network entities, A and B, which are connected by a perfect bi-directional channel (i.e., any message sent will be received correctly; the channel will not corrupt, lose, or re-order packets). A and B are to deliver data messages to each other in an alternating manner: First, A must deliver a message to B, then B must deliver a message to A, then A must deliver a message to B and so on. If an entity is in a state where it should not attempt to deliver a message to the other side, and there is an event like <code id="P700101195200000000000000000A65D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A65D">rdt_send(data)</code> call from above that attempts to pass data down for transmission to the other side, this call from above can simply be ignored with a call to <code id="P700101195200000000000000000A65E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A65E">rdt_unable_to_send(data)</code>, which informs the higher layer that it is currently not able to send data. [Note: This simplifying assumption is made so you don’t have to worry about buffering data.]</p>
<p id="P700101195200000000000000000A65F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A65F">Draw a FSM specification for this protocol (one FSM for A, and one FSM for B!). Note that you do not have to worry about a reliability mechanism here; the main point of this question is to create a FSM specification that reflects the synchronized behavior of the two entities. You should use the following events and actions that have the same meaning as protocol rdt1.0 in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P7001011952000000000000000001240" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.9</span></span> </a>: <code id="P700101195200000000000000000A660" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A660">rdt_send(data), packet = make_pkt(data)</code>, <code id="P700101195200000000000000000A661" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A661">udt_send(packet), rdt_rcv(packet)</code>, <code id="P700101195200000000000000000A662" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A662">extract (packet, data), deliver_data(data)</code>. Make sure your protocol reflects the strict alternation of sending between A and B. Also, make sure to indicate the initial states for A and B in your FSM descriptions.</p></div></li>
<li class="general-problem" id="P700101195200000000000000000186A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000186A"><div class="question" id="P700101195200000000000000000A663" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A663"><p id="P700101195200000000000000000A664" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A664"><span class="lc_labelnum"><span class="label">P</span><span class="number">18.</span></span> In the generic SR protocol that we studied in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P70010119520000000000000000013F3" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.4.4</span></span> </a>, the sender transmits a message as soon as it is available (if it is in the window) without waiting for an acknowledgment. Suppose now that we want an SR protocol that sends messages two at a time. That is, the sender will send a pair of messages and will send the next pair of messages only when it knows that both messages in the first pair have been received correctly.</p>
<p id="P700101195200000000000000000A665" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A665">Suppose that the channel may lose messages but will not corrupt or reorder messages. Design an error-control protocol for the unidirectional reliable <span class="pagebreak" title="293" id="P700101195200000000000000000186E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000186E" epub:type="pagebreak" role="doc-pagebreak"></span>transfer of messages. Give an FSM description of the sender and receiver. Describe the format of the packets sent between sender and receiver, and vice versa. If you use any procedure calls other than those in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P700101195200000000000000000120D" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.4</span></span> </a> (for example, <code id="P700101195200000000000000000A666" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A666">udt_send()</code>, <code id="P700101195200000000000000000A667" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A667">start_timer()</code>, <code id="P700101195200000000000000000A668" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A668">rdt_rcv()</code>, and so on), clearly state their actions. Give an example (a timeline trace of sender and receiver) showing how your protocol recovers from a lost packet.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001872" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001872"><div class="question" id="P700101195200000000000000000A669" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A669"><p id="P700101195200000000000000000A66A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A66A"><span class="lc_labelnum"><span class="label">P</span><span class="number">19.</span></span> Consider a scenario in which Host A wants to simultaneously send packets to Hosts B and C. A is connected to B and C via a broadcast channel—a packet sent by A is carried by the channel to both B and C. Suppose that the broadcast channel connecting A, B, and C can independently lose and corrupt packets (and so, for example, a packet sent from A might be correctly received by B, but not by C). Design a stop-and-wait-like error-control protocol for reliably transferring packets from A to B and C, such that A will not get new data from the upper layer until it knows that both B and C have correctly received the current packet. Give FSM descriptions of A and C. (<i>Hint:</i> The FSM for B should be essentially the same as for C.) Also, give a description of the packet format(s) used.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001875" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001875"><div class="question" id="P700101195200000000000000000A66B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A66B"><p id="P700101195200000000000000000A66C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A66C"><span class="lc_labelnum"><span class="label">P</span><span class="number">20.</span></span> Consider a scenario in which Host A and Host B want to send messages to Host C. Hosts A and C are connected by a channel that can lose and corrupt (but not reorder) messages. Hosts B and C are connected by another channel (independent of the channel connecting A and C) with the same properties. The transport layer at Host C should alternate in delivering messages from A and B to the layer above (that is, it should first deliver the data from a packet from A, then the data from a packet from B, and so on). Design a stop-and-wait-like error-control protocol for reliably transferring packets from A and B to C, with alternating delivery at C as described above. Give FSM descriptions of A and C. (<i>Hint:</i> The FSM for B should be essentially the same as for A.) Also, give a description of the packet format(s) used.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001878" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001878"><div class="question" id="P700101195200000000000000000A66D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A66D"><p id="P700101195200000000000000000A66E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A66E"><span class="lc_labelnum"><span class="label">P</span><span class="number">21.</span></span> Suppose we have two network entities, A and B. B has a supply of data messages that will be sent to A according to the following conventions. When A gets a request from the layer above to get the next data (D) message from B, A must send a request (R) message to B on the A-to-B channel. Only when B receives an R message can it send a data (D) message back to A on the B-to-A channel. A should deliver exactly one copy of each D message to the layer above. R messages can be lost (but not corrupted) in the A-to-B channel; D messages, once sent, are always delivered correctly. The delay along both channels is unknown and variable.</p>
<p id="P700101195200000000000000000A66F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A66F">Design (give an FSM description of) a protocol that incorporates the appropriate mechanisms to compensate for the loss-prone A-to-B channel and implements message passing to the layer above at entity A, as discussed above. Use only those mechanisms that are absolutely necessary.</p></div></li>
<li class="general-problem" id="P700101195200000000000000000187C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000187C"><div class="question" id="P700101195200000000000000000A670" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A670"><p id="P700101195200000000000000000A671" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A671"><span class="pagebreak" title="294" id="P700101195200000000000000000187F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000187F" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">P</span><span class="number">22.</span></span> Consider the GBN protocol with a sender window size of 4 and a sequence number range of 1,024. Suppose that at time <i>t</i>, the next in-order packet that the receiver is expecting has a sequence number of <i>k</i>. Assume that the medium does not reorder messages. Answer the following questions:</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A672" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A672">
<li id="P700101195200000000000000000A673" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A673"><p id="P700101195200000000000000000A674" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A674">What are the possible sets of sequence numbers inside the sender’s window at time <i>t</i>? Justify your answer.</p></li>
<li id="P700101195200000000000000000A675" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A675"><p id="P700101195200000000000000000A676" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A676">What are all possible values of the ACK field in all possible messages currently propagating back to the sender at time <i>t</i>? Justify your answer.</p></li>
</ol></div></li>
<li class="general-problem" id="P7001011952000000000000000001885" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001885"><div class="question" id="P700101195200000000000000000A677" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A677"><p id="P700101195200000000000000000A678" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A678"><span class="lc_labelnum"><span class="label">P</span><span class="number">23.</span></span> Consider the GBN and SR protocols. Suppose the sequence number space is of size <i>k</i>. What is the largest allowable sender window that will avoid the occurrence of problems such as that in <a class="xref" href="fileP700101195200000000000000000120D.xhtml#P7001011952000000000000000001421" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.27</span></span> </a> for each of these protocols?</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001888" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001888"><div class="question" id="P700101195200000000000000000A679" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A679"><p id="P700101195200000000000000000A67A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A67A"><span class="lc_labelnum"><span class="label">P</span><span class="number">24.</span></span> Answer true or false to the following questions and briefly justify your answer:</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A67B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A67B">
<li id="P700101195200000000000000000A67C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A67C"><p id="P700101195200000000000000000A67D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A67D">With the SR protocol, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</p></li>
<li id="P700101195200000000000000000A67E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A67E"><p id="P700101195200000000000000000A67F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A67F">With GBN, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</p></li>
<li id="P700101195200000000000000000A680" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A680"><p id="P700101195200000000000000000A681" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A681">The alternating-bit protocol is the same as the SR protocol with a sender and receiver window size of 1.</p></li>
<li id="P700101195200000000000000000A682" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A682"><p id="P700101195200000000000000000A683" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A683">The alternating-bit protocol is the same as the GBN protocol with a sender and receiver window size of 1.</p></li>
</ol></div></li>
<li class="general-problem" id="P7001011952000000000000000001894" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001894"><div class="question" id="P700101195200000000000000000A684" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A684"><p id="P700101195200000000000000000A685" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A685"><span class="lc_labelnum"><span class="label">P</span><span class="number">25.</span></span> We have said that an application may choose UDP for a transport protocol because UDP offers finer application control (than TCP) of what data is sent in a segment and when.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A686" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A686">
<li id="P700101195200000000000000000A687" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A687"><p id="P700101195200000000000000000A688" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A688">Why does an application have more control of what data is sent in a segment?</p></li>
<li id="P700101195200000000000000000A689" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A689"><p id="P700101195200000000000000000A68A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A68A">Why does an application have more control on when the segment is sent?</p></li>
</ol></div></li>
<li class="general-problem" id="P700101195200000000000000000189C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000189C"><div class="question" id="P700101195200000000000000000A68B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A68B"><p id="P700101195200000000000000000A68C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A68C"><span class="lc_labelnum"><span class="label">P</span><span class="number">26.</span></span> Consider transferring an enormous file of <i>L</i> bytes from Host A to Host B. Assume an MSS of 536 bytes.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A68D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A68D">
<li id="P700101195200000000000000000A68E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A68E"><p id="P700101195200000000000000000A68F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A68F">What is the maximum value of <i>L</i> such that TCP sequence numbers are not exhausted? Recall that the TCP sequence number field has 4 bytes.</p></li>
<li id="P700101195200000000000000000A690" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A690"><p id="P700101195200000000000000000A691" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A691">For the <i>L</i> you obtain in (a), find how long it takes to transmit the file. Assume that a total of 66 bytes of transport, network, and data-link header are added to each segment before the resulting packet is sent out over a 155 Mbps link. Ignore flow control and congestion control so A can pump out the segments back to back and continuously.</p></li>
</ol></div></li>
<li class="general-problem" id="P70010119520000000000000000018A4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018A4"><div class="question" id="P700101195200000000000000000A692" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A692"><p id="P700101195200000000000000000A693" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A693"><span class="lc_labelnum"><span class="label">P</span><span class="number">27.</span></span> Host A and B are communicating over a TCP connection, and Host B has already received from A all bytes up through byte 126. Suppose Host A then sends two segments to Host B back-to-back. The first and second <span class="pagebreak" title="295" id="P70010119520000000000000000018A7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018A7" epub:type="pagebreak" role="doc-pagebreak"></span>segments contain 80 and 40 bytes of data, respectively. In the first segment, the sequence number is 127, the source port number is 302, and the destination port number is 80. Host B sends an acknowledgment whenever it receives a segment from Host A.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A694" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A694">
<li id="P700101195200000000000000000A695" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A695"><p id="P700101195200000000000000000A696" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A696">In the second segment sent from Host A to B, what are the sequence number, source port number, and destination port number?</p></li>
<li id="P700101195200000000000000000A697" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A697"><p id="P700101195200000000000000000A698" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A698">If the first segment arrives before the second segment, in the acknowledgment of the first arriving segment, what is the acknowledgment number, the source port number, and the destination port number?</p></li>
<li id="P700101195200000000000000000A699" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A699"><p id="P700101195200000000000000000A69A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A69A">If the second segment arrives before the first segment, in the acknowledgment of the first arriving segment, what is the acknowledgment number?</p></li>
<li id="P700101195200000000000000000A69B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A69B"><p id="P700101195200000000000000000A69C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A69C">Suppose the two segments sent by A arrive in order at B. The first acknowledgment is lost and the second acknowledgment arrives after the first timeout interval. Draw a timing diagram, showing these segments and all other segments and acknowledgments sent. (Assume there is no additional packet loss.) For each segment in your figure, provide the sequence number and the number of bytes of data; for each acknowledgment that you add, provide the acknowledgment number.</p></li>
</ol></div></li>
<li class="general-problem" id="P70010119520000000000000000018B1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018B1"><div class="question" id="P700101195200000000000000000A69D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A69D"><p id="P700101195200000000000000000A69E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A69E"><span class="lc_labelnum"><span class="label">P</span><span class="number">28.</span></span> Host A and B are directly connected with a 100 Mbps link. There is one TCP connection between the two hosts, and Host A is sending to Host B an enormous file over this connection. Host A can send its application data into its TCP socket at a rate as high as 120 Mbps but Host B can read out of its TCP receive buffer at a maximum rate of 50 Mbps. Describe the effect of TCP flow control.</p></div></li>
<li class="general-problem" id="P70010119520000000000000000018B4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018B4"><div class="question" id="P700101195200000000000000000A69F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A69F"><p id="P700101195200000000000000000A6A0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A0"><span class="lc_labelnum"><span class="label">P</span><span class="number">29.</span></span> SYN cookies were discussed in <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P70010119520000000000000000015D1" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5.6</span></span> </a>.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A6A1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A1">
<li id="P700101195200000000000000000A6A2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A2"><p id="P700101195200000000000000000A6A3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A3">Why is it necessary for the server to use a special initial sequence number in the SYNACK?</p></li>
<li id="P700101195200000000000000000A6A4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A4"><p id="P700101195200000000000000000A6A5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A5">Suppose an attacker knows that a target host uses SYN cookies. Can the attacker create half-open or fully open connections by simply sending an ACK packet to the target? Why or why not?</p></li>
<li id="P700101195200000000000000000A6A6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A6"><p id="P700101195200000000000000000A6A7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A7">Suppose an attacker collects a large amount of initial sequence numbers sent by the server. Can the attacker cause the server to create many fully open connections by sending ACKs with those initial sequence numbers? Why?</p></li>
</ol></div></li>
<li class="general-problem" id="P70010119520000000000000000018BE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018BE"><div class="question" id="P700101195200000000000000000A6A8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A8"><p id="P700101195200000000000000000A6A9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6A9"><span class="lc_labelnum"><span class="label">P</span><span class="number">30.</span></span> Consider the network shown in Scenario 2 in <a class="xref" href="fileP7001011952000000000000000001627.xhtml#P700101195200000000000000000162B" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.6.1</span></span> </a>. Suppose both sending hosts A and B have some fixed timeout values.</p></div>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A6AA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6AA">
<li id="P700101195200000000000000000A6AB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6AB"><p id="P700101195200000000000000000A6AC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6AC">Argue that increasing the size of the finite buffer of the router might possibly decrease the throughput (λ<sub><i>out</i></sub>).</p></li>
<li id="P700101195200000000000000000A6AD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6AD"><p id="P700101195200000000000000000A6AE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6AE">Now suppose both hosts dynamically adjust their timeout values (like what TCP does) based on the buffering delay at the router. Would increasing the buffer size help to increase the throughput? Why?</p></li>
</ol></li>
<li class="general-problem" id="P70010119520000000000000000018C6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018C6"><div class="question" id="P700101195200000000000000000A6AF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6AF"><p id="P700101195200000000000000000A6B0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B0"><span class="pagebreak" title="296" id="P70010119520000000000000000018C9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018C9" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">P</span><span class="number">31.</span></span> Suppose that the five measured <code id="P700101195200000000000000000A6B1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B1">SampleRTT</code> values (see <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P70010119520000000000000000014D4" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5.3</span></span> </a>) are 106 ms, 120 ms, 140 ms, 90 ms, and 115 ms. Compute the <code id="P700101195200000000000000000A6B2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B2">EstimatedRTT</code> after each of these SampleRTT values is obtained, using a value of <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="85" altimg-height="13" altimg="../images/ch03math50.png"><m:mrow><m:mi>α</m:mi><m:mo>=</m:mo><m:mn>0.125</m:mn></m:mrow></m:math></span> and assuming that the value of <code id="P700101195200000000000000000A6B3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B3">EstimatedRTT</code> was 100 ms just before the first of these five samples were obtained. Compute also the <code id="P700101195200000000000000000A6B4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B4">DevRTT</code> after each sample is obtained, assuming a value of <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="75" altimg-height="17" altimg="../images/ch03math51.png"><m:mrow><m:mi>β</m:mi><m:mo>=</m:mo><m:mn>0.25</m:mn></m:mrow></m:math></span> and assuming the value of <code id="P700101195200000000000000000A6B5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B5">DevRTT</code> was 5 ms just before the first of these five samples was obtained. Last, compute the TCP <code id="P700101195200000000000000000A6B6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B6">TimeoutInterval</code> after each of these samples is obtained.</p></div></li>
<li class="general-problem" id="P70010119520000000000000000018D0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018D0"><div class="question" id="P700101195200000000000000000A6B7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B7"><p id="P700101195200000000000000000A6B8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B8"><span class="lc_labelnum"><span class="label">P</span><span class="number">32.</span></span> Consider the TCP procedure for estimating RTT. Suppose that <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="66" altimg-height="13" altimg="../images/ch03math52.png"><m:mrow><m:mi>α</m:mi><m:mo>=</m:mo><m:mn>0.1</m:mn></m:mrow></m:math></span>. Let <code id="P700101195200000000000000000A6B9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6B9">SampleRTT</code><b><sub>1</sub></b> be the most recent sample RTT, let <code id="P700101195200000000000000000A6BA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6BA">SampleRTT</code><b><sub>2</sub></b> be the next most recent sample RTT, and so on.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A6BB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6BB">
<li id="P700101195200000000000000000A6BC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6BC"><p id="P700101195200000000000000000A6BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6BD">For a given TCP connection, suppose four acknowledgments have been returned with corresponding sample RTTs: <code id="P700101195200000000000000000A6BE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6BE">SampleRTT</code><b><sub>4</sub></b>, <code id="P700101195200000000000000000A6BF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6BF">SampleRTT</code><b><sub>3</sub></b>, <code id="P700101195200000000000000000A6C0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C0">SampleRTT</code><b><sub>2</sub></b>, and <code id="P700101195200000000000000000A6C1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C1">SampleRTT</code><b><sub>1</sub></b>. Express <code id="P700101195200000000000000000A6C2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C2">EstimatedRTT</code> in terms of the four sample RTTs.</p></li>
<li id="P700101195200000000000000000A6C3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C3"><p id="P700101195200000000000000000A6C4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C4">Generalize your formula for <i>n</i> sample RTTs.</p></li>
<li id="P700101195200000000000000000A6C5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C5"><p id="P700101195200000000000000000A6C6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C6">For the formula in part (b) let <i>n</i> approach infinity. Comment on why this averaging procedure is called an exponential moving average.</p></li>
</ol></div></li>
<li class="general-problem" id="P70010119520000000000000000018E1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018E1"><div class="question" id="P700101195200000000000000000A6C7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C7"><p id="P700101195200000000000000000A6C8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C8"><span class="lc_labelnum"><span class="label">P</span><span class="number">33.</span></span> In <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P70010119520000000000000000014D4" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5.3</span></span> </a>, we discussed TCP’s estimation of RTT. Why do you think TCP avoids measuring the <code id="P700101195200000000000000000A6C9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6C9">SampleRTT</code> for retransmitted segments?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000018E5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018E5"><div class="question" id="P700101195200000000000000000A6CA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6CA"><p id="P700101195200000000000000000A6CB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6CB"><span class="lc_labelnum"><span class="label">P</span><span class="number">34.</span></span> What is the relationship between the variable <code id="P700101195200000000000000000A6CC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6CC">SendBase</code> in <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P700101195200000000000000000152A" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5.4</span></span> </a> and the variable <code id="P700101195200000000000000000A6CD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6CD">LastByteRcvd</code> in <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P7001011952000000000000000001599" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5.5</span></span> </a>?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000018EA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018EA"><div class="question" id="P700101195200000000000000000A6CE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6CE"><p id="P700101195200000000000000000A6CF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6CF"><span class="lc_labelnum"><span class="label">P</span><span class="number">35.</span></span> What is the relationship between the variable <code id="P700101195200000000000000000A6D0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D0">LastByteRcvd</code> in <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P7001011952000000000000000001599" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5.5</span></span> </a> and the variable y in Section <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P700101195200000000000000000152A" data-foobar="7"><span class="number">3.5.4</span></a>?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000018EE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018EE"><div class="question" id="P700101195200000000000000000A6D1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D1"><p id="P700101195200000000000000000A6D2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D2"><span class="lc_labelnum"><span class="label">P</span><span class="number">36.</span></span> In <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P700101195200000000000000000152A" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5.4</span></span> </a>, we saw that TCP waits until it has received three duplicate ACKs before performing a fast retransmit. Why do you think the TCP designers chose not to perform a fast retransmit after the first duplicate ACK for a segment is received?</p></div></li>
<li class="general-problem" id="P70010119520000000000000000018F1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018F1"><div class="question" id="P700101195200000000000000000A6D3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D3"><p id="P700101195200000000000000000A6D4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D4"><span class="lc_labelnum"><span class="label">P</span><span class="number">37.</span></span> Compare GBN, SR, and TCP (no delayed ACK). Assume that the timeout values for all three protocols are sufficiently long such that 5 consecutive data segments and their corresponding ACKs can be received (if not lost in the channel) by the receiving host (Host B) and the sending host (Host A) respectively. Suppose Host A sends 5 data segments to Host B, and the 2nd segment (sent from A) is lost. In the end, all 5 data segments have been correctly received by Host B.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A6D5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D5">
<li id="P700101195200000000000000000A6D6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D6"><p id="P700101195200000000000000000A6D7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D7">How many segments has Host A sent in total and how many ACKs has Host B sent in total? What are their sequence numbers? Answer this question for all three protocols.</p></li>
<li id="P700101195200000000000000000A6D8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D8"><p id="P700101195200000000000000000A6D9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6D9"><span class="pagebreak" title="297" id="P70010119520000000000000000018F9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018F9" epub:type="pagebreak" role="doc-pagebreak"></span>If the timeout values for all three protocol are much longer than 5 RTT, then which protocol successfully delivers all five data segments in shortest time interval?</p></li>
</ol></div></li>
<li class="general-problem" id="P70010119520000000000000000018FA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000018FA"><div class="question" id="P700101195200000000000000000A6DA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6DA"><p id="P700101195200000000000000000A6DB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6DB"><span class="lc_labelnum"><span class="label">P</span><span class="number">38.</span></span> In our description of TCP in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P7001011952000000000000000001729" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.53</span></span> </a>, the value of the threshold, <code id="P700101195200000000000000000A6DC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6DC">ssthresh</code>, is set as <code id="P700101195200000000000000000A6DD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6DD">ssthresh=cwnd/2</code> in several places and <code id="P700101195200000000000000000A6DE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6DE">ssthresh</code> value is referred to as being set to half the window size when a loss event occurred. Must the rate at which the sender is sending when the loss event occurred be approximately equal to <code id="P700101195200000000000000000A6DF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6DF">cwnd</code> segments per RTT? Explain your answer. If your answer is no, can you suggest a different manner in which <code id="P700101195200000000000000000A6E0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E0">ssthresh</code> should be set?</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001902" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001902"><div class="question" id="P700101195200000000000000000A6E1" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E1"><p id="P700101195200000000000000000A6E2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E2"><span class="lc_labelnum"><span class="label">P</span><span class="number">39.</span></span> Consider <a class="xref" href="fileP7001011952000000000000000001627.xhtml#P700101195200000000000000000165B" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.46(b)</span></span> </a>. If <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="25" altimg-height="17" altimg="../images/ch03math53.png"><m:mrow><m:msub><m:msup><m:mi>λ</m:mi><m:mo>′</m:mo></m:msup><m:mrow><m:mtext>in</m:mtext></m:mrow></m:msub></m:mrow></m:math></span> increases beyond <i>R</i>/2, can λ<sub>out</sub> increase beyond <i>R</i>/3? Explain. Now consider <a class="xref" href="fileP7001011952000000000000000001627.xhtml#P700101195200000000000000000165B" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.46(c)</span></span> </a>. If <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="25" altimg-height="17" altimg="../images/ch03math54.png"><m:mrow><m:msub><m:msup><m:mi>λ</m:mi><m:mo>′</m:mo></m:msup><m:mrow><m:mtext>in</m:mtext></m:mrow></m:msub></m:mrow></m:math></span> increases beyond <i>R</i>/2, can λ<sub>out</sub> increase beyond R/4 under the assumption that a packet will be forwarded twice on average from the router to the receiver? Explain.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001905" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001905"><div class="question" id="P700101195200000000000000000A6E3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E3"><p id="P700101195200000000000000000A6E4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E4"><span class="lc_labelnum"><span class="label">P</span><span class="number">40.</span></span> Consider <a class="xref" href="#P7001011952000000000000000001915" data-foobar="1"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.58</span></span> </a>. Assuming TCP Reno is the protocol experiencing the behavior shown above, answer the following questions. In all cases, you should provide a short discussion justifying your answer.</p>
<aside class="marginalia" id="P7001011952000000000000000001908" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001908">
<p id="P700101195200000000000000000A6E5" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E5"><img alt="" height="55" width="58" id="P700101195200000000000000000A6E6" data-uri="P7001011952000000000000000005893" src="../images/VideoNote.png"></img></p>
<p id="P700101195200000000000000000A6E7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E7">Examining the behavior of TCP</p>
</aside>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A6E8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E8">
<li id="P700101195200000000000000000A6E9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6E9"><p id="P700101195200000000000000000A6EA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6EA">Identify the intervals of time when TCP slow start is operating.</p></li>
<li id="P700101195200000000000000000A6EB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6EB"><p id="P700101195200000000000000000A6EC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6EC">Identify the intervals of time when TCP congestion avoidance is operating.</p></li>
<li id="P700101195200000000000000000A6ED" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6ED"><p id="P700101195200000000000000000A6EE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6EE">After the 16th transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</p></li>
<li id="P700101195200000000000000000A6EF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6EF"><p id="P700101195200000000000000000A6F0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6F0">After the 22nd transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</p>
<figure id="P7001011952000000000000000001915" class="figure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001915">
<img alt="Illustration of TCP window size as a function of time." height="362" width="467" aria-describedby="P7001011952000000000000000001919" id="P700101195200000000000000000A6F1" data-uri="P700101195200000000000000000557F" src="../images/4055103058.png"></img>
<figcaption id="P700101195200000000000000000A6F2" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6F2"><header><h1 class="title" id="P700101195200000000000000000A6F3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6F3" epub:type="title"><span class="label">Figure </span><span class="number">3.58</span> TCP window size as a function of time</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000001919" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001919" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055103058.xhtml#la_4055103058"><span class="label">Description</span></a></div></li>
<li id="P700101195200000000000000000A6F6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6F6"><p id="P700101195200000000000000000A6F7" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6F7"><span class="pagebreak" title="298" id="P700101195200000000000000000191E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000191E" epub:type="pagebreak" role="doc-pagebreak"></span>What is the initial value of <code id="P700101195200000000000000000A6F8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6F8">ssthresh</code> at the first transmission round?</p></li>
<li id="P700101195200000000000000000A6F9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6F9"><p id="P700101195200000000000000000A6FA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6FA">What is the value of <code id="P700101195200000000000000000A6FB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6FB">ssthresh</code> at the 18th transmission round?</p></li>
<li id="P700101195200000000000000000A6FC" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6FC"><p id="P700101195200000000000000000A6FD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6FD">What is the value of <code id="P700101195200000000000000000A6FE" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6FE">ssthresh</code> at the 24th transmission round?</p></li>
<li id="P700101195200000000000000000A6FF" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A6FF"><p id="P700101195200000000000000000A700" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A700">During what transmission round is the 70th segment sent?</p></li>
<li id="P700101195200000000000000000A701" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A701"><p id="P700101195200000000000000000A702" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A702">Assuming a packet loss is detected after the 26th round by the receipt of a triple duplicate ACK, what will be the values of the congestion window size and of <code id="P700101195200000000000000000A703" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A703">ssthresh</code>?</p></li>
<li id="P700101195200000000000000000A704" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A704"><p id="P700101195200000000000000000A705" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A705">Suppose TCP Tahoe is used (instead of TCP Reno), and assume that triple duplicate ACKs are received at the 16th round. What are the <code id="P700101195200000000000000000A706" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A706">ssthresh</code> and the congestion window size at the 19th round?</p></li>
<li id="P700101195200000000000000000A707" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A707"><p id="P700101195200000000000000000A708" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A708">Again suppose TCP Tahoe is used, and there is a timeout event at 22nd round. How many packets have been sent out from 17th round till 22nd round, inclusive?</p></li>
</ol></div></li>
<li class="general-problem" id="P7001011952000000000000000001930" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001930"><div class="question" id="P700101195200000000000000000A709" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A709"><p id="P700101195200000000000000000A70A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A70A"><span class="lc_labelnum"><span class="label">P</span><span class="number">41.</span></span> Refer to <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P7001011952000000000000000001753" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.55</span></span> </a>, which illustrates the convergence of TCP’s AIMD algorithm. Suppose that instead of a multiplicative decrease, TCP decreased the window size by a constant amount. Would the resulting AIAD algorithm converge to an equal share algorithm? Justify your answer using a diagram similar to <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P7001011952000000000000000001753" data-foobar="7"><span class="lc_labelnum"><span class="label">Figure</span> <span class="number">3.55</span></span> </a>.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001933" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001933"><div class="question" id="P700101195200000000000000000A70B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A70B"><p id="P700101195200000000000000000A70C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A70C"><span class="lc_labelnum"><span class="label">P</span><span class="number">42.</span></span> In <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P700101195200000000000000000152A" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.5.4</span></span> </a>, we discussed the doubling of the timeout interval after a timeout event. This mechanism is a form of congestion control. Why does TCP need a window-based congestion-control mechanism (as studied in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.7</span></span> </a>) in addition to this doubling-timeout-interval mechanism?</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001936" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001936"><div class="question" id="P700101195200000000000000000A70D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A70D"><p id="P700101195200000000000000000A70E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A70E"><span class="lc_labelnum"><span class="label">P</span><span class="number">43.</span></span> Host A is sending an enormous file to Host B over a TCP connection. Over this connection there is never any packet loss and the timers never expire. Denote the transmission rate of the link connecting Host A to the Internet by <i>R</i> bps. Suppose that the process in Host A is capable of sending data into its TCP socket at a rate <i>S</i> bps, where <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="88" altimg-height="13" altimg="../images/ch03math55.png"><m:mrow><m:mi>S</m:mi><m:mo>=</m:mo><m:mn>10</m:mn><m:mo>⋅</m:mo><m:mi>R</m:mi><m:mo>.</m:mo></m:mrow></m:math></span> Further suppose that the TCP receive buffer is large enough to hold the entire file, and the send buffer can hold only one percent of the file. What would prevent the process in Host A from continuously passing data to its TCP socket at rate <i>S</i> bps? TCP flow control? TCP congestion control? Or something else? Elaborate.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001939" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001939"><div class="question" id="P700101195200000000000000000A70F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A70F"><p id="P700101195200000000000000000A710" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A710"><span class="lc_labelnum"><span class="label">P</span><span class="number">44.</span></span> Consider sending a large file from a host to another over a TCP connection that has no loss.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A711" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A711">
<li id="P700101195200000000000000000A712" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A712"><p id="P700101195200000000000000000A713" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A713">Suppose TCP uses AIMD for its congestion control without slow start. Assuming <code id="P700101195200000000000000000A714" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A714">cwnd</code> increases by 1 MSS every time a batch of ACKs is received and assuming approximately constant round-trip times, how long does it take for <code id="P700101195200000000000000000A715" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A715">cwnd</code> increase from 6 MSS to 12 MSS (assuming no loss events)?</p></li>
<li id="P700101195200000000000000000A716" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A716"><p id="P700101195200000000000000000A717" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A717">What is the average throughout (in terms of MSS and RTT) for this connection up through <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="116" altimg-height="13" altimg="../images/ch03math56.png"><m:mrow><m:mtext>time</m:mtext><m:mo>=</m:mo><m:mn>6</m:mn><m:mtext> RTT</m:mtext></m:mrow></m:math></span>?</p></li>
</ol></div></li>
<li class="general-problem" id="P7001011952000000000000000001943" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001943"><div class="question" id="P700101195200000000000000000A718" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A718"><p id="P700101195200000000000000000A719" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A719"><span class="pagebreak" title="299" id="P7001011952000000000000000001946" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001946" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">P</span><span class="number">45.</span></span> Recall the macroscopic description of TCP throughput. In the period of time from when the connection’s rate varies from <i>W</i>/(2 · RTT) to <i>W/RTT</i>, only one packet is lost (at the very end of the period).</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A71A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A71A">
<li id="P700101195200000000000000000A71B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A71B"><p id="P700101195200000000000000000A71C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A71C">Show that the loss rate (fraction of packets lost) is equal to</p>
<div class="informalequation" id="P700101195200000000000000000194A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000194A"><m:math display="block" alttext="" data-uri="" altimg-width="237" altimg-height="67" altimg="../images/ch03math57.png"><m:mrow><m:mi>L</m:mi><m:mo>=</m:mo><m:mtext>loss rate</m:mtext><m:mo>=</m:mo><m:mfrac><m:mn>1</m:mn><m:mrow><m:mfrac><m:mn>3</m:mn><m:mn>8</m:mn></m:mfrac><m:msup><m:mi>W</m:mi><m:mn>2</m:mn></m:msup><m:mo>+</m:mo><m:mfrac><m:mn>3</m:mn><m:mn>4</m:mn></m:mfrac><m:mi>W</m:mi></m:mrow></m:mfrac></m:mrow></m:math></div></li>
<li id="P700101195200000000000000000A71D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A71D"><p id="P700101195200000000000000000A71E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A71E">Use the result above to show that if a connection has loss rate <i>L</i>, then its average rate is approximately given by</p>
<div class="informalequation" id="P700101195200000000000000000194D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000194D"><m:math display="block" alttext="" data-uri="" altimg-width="107" altimg-height="46" altimg="../images/ch03math58.png"><m:mrow><m:mo>≈</m:mo><m:mfrac><m:mrow><m:mn>1.22</m:mn><m:mo>⋅</m:mo><m:mi>M</m:mi><m:mi>S</m:mi><m:mi>S</m:mi></m:mrow><m:mrow><m:mi>R</m:mi><m:mi>T</m:mi><m:mi>T</m:mi><m:msqrt><m:mi>L</m:mi></m:msqrt></m:mrow></m:mfrac></m:mrow></m:math></div></li>
</ol></div></li>
<li class="general-problem" id="P700101195200000000000000000194E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000194E"><div class="question" id="P700101195200000000000000000A71F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A71F"><p id="P700101195200000000000000000A720" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A720"><span class="lc_labelnum"><span class="label">P</span><span class="number">46.</span></span> Consider that only a single TCP (Reno) connection uses one 10Mbps link which does not buffer any data. Suppose that this link is the only congested link between the sending and receiving hosts. Assume that the TCP sender has a huge file to send to the receiver, and the receiver’s receive buffer is much larger than the congestion window. We also make the following assumptions: each TCP segment size is 1,500 bytes; the two-way propagation delay of this connection is 150 msec; and this TCP connection is always in congestion avoidance phase, that is, ignore slow start.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A721" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A721">
<li id="P700101195200000000000000000A722" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A722"><p id="P700101195200000000000000000A723" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A723">What is the maximum window size (in segments) that this TCP connection can achieve?</p></li>
<li id="P700101195200000000000000000A724" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A724"><p id="P700101195200000000000000000A725" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A725">What is the average window size (in segments) and average throughput (in bps) of this TCP connection?</p></li>
<li id="P700101195200000000000000000A726" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A726"><p id="P700101195200000000000000000A727" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A727">How long would it take for this TCP connection to reach its maximum window again after recovering from a packet loss?</p></li>
</ol></div></li>
<li class="general-problem" id="P7001011952000000000000000001958" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001958"><div class="question" id="P700101195200000000000000000A728" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A728"><p id="P700101195200000000000000000A729" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A729"><span class="lc_labelnum"><span class="label">P</span><span class="number">47.</span></span> Consider the scenario described in the previous problem. Suppose that the 10Mbps link can buffer a finite number of segments. Argue that in order for the link to always be busy sending data, we would like to choose a buffer size that is at least the product of the link speed <i>C</i> and the two-way propagation delay between the sender and the receiver.</p></div></li>
<li class="general-problem" id="P700101195200000000000000000195B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000195B"><div class="question" id="P700101195200000000000000000A72A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A72A"><p id="P700101195200000000000000000A72B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A72B"><span class="lc_labelnum"><span class="label">P</span><span class="number">48.</span></span> Repeat Problem 46, but replacing the 10 Mbps link with a 10 Gbps link. Note that in your answer to part c, you will realize that it takes a very long time for the congestion window size to reach its maximum window size after recovering from a packet loss. Sketch a solution to solve this problem.</p></div></li>
<li class="general-problem" id="P700101195200000000000000000195E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000195E"><div class="question" id="P700101195200000000000000000A72C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A72C"><p id="P700101195200000000000000000A72D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A72D"><span class="lc_labelnum"><span class="label">P</span><span class="number">49.</span></span> Let <i>T</i> (measured by RTT) denote the time interval that a TCP connection takes to increase its congestion window size from <i>W/2</i> to <i>W</i>, where <i>W</i> is the maximum congestion window size. Argue that T is a function of TCP’s average throughput.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001961" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001961"><div class="question" id="P700101195200000000000000000A72E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A72E"><p id="P700101195200000000000000000A72F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A72F"><span class="pagebreak" title="300" id="P7001011952000000000000000001964" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001964" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">P</span><span class="number">50.</span></span> Consider a simplified TCP’s AIMD algorithm where the congestion window size is measured in number of segments, not in bytes. In additive increase, the congestion window size increases by one segment in each RTT. In multiplicative decrease, the congestion window size decreases by half (if the result is not an integer, round down to the nearest integer). Suppose that two TCP connections, C<sub>1</sub> and C<sub>2</sub>, share a single congested link of speed 30 segments per second. Assume that both C<sub>1</sub> and C<sub>2</sub> are in the congestion avoidance phase. Connection C<sub>1</sub>’s RTT is 50 msec and connection C<sub>2</sub>’s RTT is 100 msec. Assume that when the data rate in the link exceeds the link’s speed, all TCP connections experience data segment loss.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A730" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A730">
<li id="P700101195200000000000000000A731" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A731"><p id="P700101195200000000000000000A732" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A732">If both C<sub>1</sub> and C<sub>2</sub> at time t<sub>0</sub> have a congestion window of 10 segments, what are their congestion window sizes after 1000 msec?</p></li>
<li id="P700101195200000000000000000A733" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A733"><p id="P700101195200000000000000000A734" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A734">In the long run, will these two connections get the same share of the bandwidth of the congested link? Explain.</p></li>
</ol></div></li>
<li class="general-problem" id="P700101195200000000000000000196A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000196A"><div class="question" id="P700101195200000000000000000A735" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A735"><p id="P700101195200000000000000000A736" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A736"><span class="lc_labelnum"><span class="label">P</span><span class="number">51.</span></span> Consider the network described in the previous problem. Now suppose that the two TCP connections, C1 and C2, have the same RTT of 100 msec. Suppose that at time t<sub>0</sub>, C1’s congestion window size is 15 segments but C2’s congestion window size is 10 segments.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A737" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A737">
<li id="P700101195200000000000000000A738" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A738"><p id="P700101195200000000000000000A739" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A739">What are their congestion window sizes after 2200 msec?</p></li>
<li id="P700101195200000000000000000A73A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A73A"><p id="P700101195200000000000000000A73B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A73B">In the long run, will these two connections get about the same share of the bandwidth of the congested link?</p></li>
<li id="P700101195200000000000000000A73C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A73C"><p id="P700101195200000000000000000A73D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A73D">We say that two connections are synchronized, if both connections reach their maximum window sizes at the same time and reach their minimum window sizes at the same time. In the long run, will these two connections get synchronized eventually? If so, what are their maximum window sizes?</p></li>
<li id="P700101195200000000000000000A73E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A73E"><p id="P700101195200000000000000000A73F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A73F">Will this synchronization help to improve the utilization of the shared link? Why? Sketch some idea to break this synchronization.</p></li>
</ol></div></li>
<li class="general-problem" id="P7001011952000000000000000001976" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001976"><div class="question" id="P700101195200000000000000000A740" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A740"><p id="P700101195200000000000000000A741" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A741"><span class="lc_labelnum"><span class="label">P</span><span class="number">52.</span></span> Consider a modification to TCP’s congestion control algorithm. Instead of additive increase, we can use multiplicative increase. A TCP sender increases its window size by a small positive constant <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="117" altimg-height="17" altimg="../images/ch03math59.png"><m:mrow><m:mi>a</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mn>0</m:mn><m:mo>&lt;</m:mo><m:mi>a</m:mi><m:mo>&lt;</m:mo><m:mn>1</m:mn></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:math></span> whenever it receives a valid ACK. Find the functional relationship between loss rate L and maximum congestion window W. Argue that for this modified TCP, regardless of TCP’s average throughput, a TCP connection always spends the same amount of time to increase its congestion window size from <i>W/2</i> to <i>W</i>.</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001979" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001979"><div class="question" id="P700101195200000000000000000A742" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A742"><p id="P700101195200000000000000000A743" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A743"><span class="lc_labelnum"><span class="label">P</span><span class="number">53.</span></span> In our discussion of TCP futures in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.7</span></span> </a>, we noted that to achieve a throughput of 10 Gbps, TCP could only tolerate a segment loss probability of <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="67" altimg-height="16" altimg="../images/ch03math60.png"><m:mrow><m:mn>2</m:mn><m:mo>⋅</m:mo><m:msup><m:mrow><m:mn>10</m:mn></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>10</m:mn></m:mrow></m:msup></m:mrow></m:math></span> (or equivalently, one loss event for every 5,000,000,000 segments). Show the derivation for the values of <span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="67" altimg-height="17" altimg="../images/ch03math61.png"><m:mrow><m:mn>2</m:mn><m:mo>⋅</m:mo><m:msup><m:mrow><m:mn>10</m:mn></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>10</m:mn></m:mrow></m:msup></m:mrow></m:math></span> (1 out of 5,000,000) for the RTT and MSS values given in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.7</span></span> </a>. If TCP needed to support a 100 Gbps connection, what would the tolerable loss be?</p></div></li>
<li class="general-problem" id="P700101195200000000000000000197C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000197C"><div class="question" id="P700101195200000000000000000A744" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A744"><p id="P700101195200000000000000000A745" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A745"><span class="pagebreak" title="301" id="P700101195200000000000000000197F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000197F" epub:type="pagebreak" role="doc-pagebreak"></span><span class="lc_labelnum"><span class="label">P</span><span class="number">54.</span></span> In our discussion of TCP congestion control in <a class="xref" href="fileP700101195200000000000000000168F.xhtml#P700101195200000000000000000168F" data-foobar="7"><span class="lc_labelnum"><span class="label">Section</span> <span class="number">3.7</span></span> </a>, we implicitly assumed that the TCP sender always had data to send. Consider now the case that the TCP sender sends a large amount of data and then goes idle (since it has no more data to send) at <i>t</i><sub>1</sub>. TCP remains idle for a relatively long period of time and then wants to send more data at <i>t</i><sub>2</sub>. What are the advantages and disadvantages of having TCP use the <code id="P700101195200000000000000000A746" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A746">cwnd</code> and <code id="P700101195200000000000000000A747" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A747">ssthresh</code> values from <i>t</i><sub>1</sub> when starting to send data at <i>t</i><sub>2</sub>? What alternative would you recommend? Why?</p></div></li>
<li class="general-problem" id="P7001011952000000000000000001982" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001982"><div class="question" id="P700101195200000000000000000A748" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A748"><p id="P700101195200000000000000000A749" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A749"><span class="lc_labelnum"><span class="label">P</span><span class="number">55.</span></span> In this problem we investigate whether either UDP or TCP provides a degree of end-point authentication.</p>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A74A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A74A">
<li id="P700101195200000000000000000A74B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A74B"><p id="P700101195200000000000000000A74C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A74C">Consider a server that receives a request within a UDP packet and responds to that request within a UDP packet (for example, as done by a DNS server). If a client with IP address X spoofs its address with address Y, where will the server send its response?</p></li>
<li id="P700101195200000000000000000A74D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A74D"><p id="P700101195200000000000000000A74E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A74E">Suppose a server receives a SYN with IP source address Y, and after responding with a SYNACK, receives an ACK with IP source address Y with the correct acknowledgment number. Assuming the server chooses a random initial sequence number and there is no “man-in-the-middle,” can the server be certain that the client is indeed at Y (and not at some other address X that is spoofing Y)?</p></li>
</ol></div></li>
<li class="general-problem" id="P700101195200000000000000000198A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000198A"><div class="question" id="P700101195200000000000000000A74F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A74F"><p id="P700101195200000000000000000A750" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A750"><span class="lc_labelnum"><span class="label">P</span><span class="number">56.</span></span> In this problem, we consider the delay introduced by the TCP slow-start phase. Consider a client and a Web server directly connected by one link of rate <i>R</i>. Suppose the client wants to retrieve an object whose size is exactly equal to 15 <i>S</i>, where <i>S</i> is the maximum segment size (MSS). Denote the round-trip time between client and server as RTT (assumed to be constant). Ignoring protocol headers, determine the time to retrieve the object (including TCP connection establishment) when</p></div>
<ol class="ol_lower-alpha" type="a" id="P700101195200000000000000000A751" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A751">
<li id="P700101195200000000000000000A752" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A752"><p id="P700101195200000000000000000A753" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A753"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="225" altimg-height="14" altimg="../images/ch03math62.png"><m:mrow><m:mn>4</m:mn><m:mtext> </m:mtext><m:mi>S</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mo>&gt;</m:mo><m:mi>S</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mo>+</m:mo><m:mi>R</m:mi><m:mi>T</m:mi><m:mi>T</m:mi><m:mo>&gt;</m:mo><m:mn>2</m:mn><m:mi>S</m:mi><m:mo>/</m:mo><m:mi>R</m:mi></m:mrow></m:math></span></p></li>
<li id="P700101195200000000000000000A754" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A754"><p id="P700101195200000000000000000A755" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A755"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="160" altimg-height="14" altimg="../images/ch03math63.png"><m:mrow><m:mi>S</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mo>+</m:mo><m:mi>R</m:mi><m:mi>T</m:mi><m:mi>T</m:mi><m:mo>&gt;</m:mo><m:mn>4</m:mn><m:mtext> </m:mtext><m:mi>S</m:mi><m:mo>/</m:mo><m:mi>R</m:mi></m:mrow></m:math></span></p></li>
<li id="P700101195200000000000000000A756" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A756"><p id="P700101195200000000000000000A757" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A757"><span class="inlineequation"><m:math display="inline" alttext="" data-uri="" altimg-width="92" altimg-height="13" altimg="../images/ch03math64.png"><m:mrow><m:mi>S</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mo>&gt;</m:mo><m:mi>R</m:mi><m:mi>T</m:mi><m:mi>T</m:mi></m:mrow></m:math></span>.</p></li>
</ol></li>
</ol>
</section>
<section id="P7001011952000000000000000001994" data-uri="M03_KURO4140_07_SE_C03.xhtml#P7001011952000000000000000001994" epub:type="practice" class="practice level2"><header><h1 class="title" id="P700101195200000000000000000A758" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A758" epub:type="title"><span class="label">Programming Assignments </span></h1></header>
<ol class="practicelist dynamiclist" id="P700101195200000000000000000A759" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A759">
<li class="general-problem" id="P700101195200000000000000000A75A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A75A"><div class="question" id="P700101195200000000000000000A75B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A75B"><p id="P700101195200000000000000000A75C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A75C"></p></div></li>
</ol>
<section id="P700101195200000000000000000199A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000199A" class="practicediv level3"><header><h1 class="title" id="P700101195200000000000000000A75D" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A75D" epub:type="title">Implementing a Reliable Transport Protocol</h1></header>
<p id="P700101195200000000000000000A75E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A75E">In this laboratory programming assignment, you will be writing the sending and receiving transport-level code for implementing a simple reliable data transfer protocol. There are two versions of this lab, the alternating-bit-protocol version and the GBN version. This lab should be fun—your implementation will differ very little from what would be required in a real-world situation.</p>
<p id="P700101195200000000000000000A75F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A75F"><span class="pagebreak" title="302" id="P700101195200000000000000000199E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000199E" epub:type="pagebreak" role="doc-pagebreak"></span>Since you probably don’t have standalone machines (with an OS that you can modify), your code will have to execute in a simulated hardware/software environment. However, the programming interface provided to your routines—the code that would call your entities from above and from below—is very close to what is done in an actual UNIX environment. (Indeed, the software interfaces described in this programming assignment are much more realistic than the infinite loop senders and receivers that many texts describe.) Stopping and starting timers are also simulated, and timer interrupts will cause your timer handling routine to be activated.</p>
<p id="P700101195200000000000000000A760" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A760">The full lab assignment, as well as code you will need to compile with your own code, are available at this book’s Web site: <a class="ulink" href="http://www.pearsonhighered.com/cs-resources">www.pearsonhighered.com/<wbr></wbr>cs-resources</a>.</p>
</section>
<section id="P70010119520000000000000000019A0" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019A0" class="practicediv level3"><header><h1 class="title" id="P700101195200000000000000000A761" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A761" epub:type="title"><span class="label">Wireshark Lab: Exploring TCP </span></h1></header>
<p id="P700101195200000000000000000A762" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A762">In this lab, you’ll use your Web browser to access a file from a Web server. As in earlier Wireshark labs, you’ll use Wireshark to capture the packets arriving at your computer. Unlike earlier labs, you’ll <i>also</i> be able to download a Wireshark-readable packet trace from the Web server from which you downloaded the file. In this server trace, you’ll find the packets that were generated by your own access of the Web server. You’ll analyze the client- and server-side traces to explore aspects of TCP. In particular, you’ll evaluate the performance of the TCP connection between your computer and the Web server. You’ll trace TCP’s window behavior, and infer packet loss, retransmission, flow control and congestion control behavior, and estimated roundtrip time.</p>
<p id="P700101195200000000000000000A763" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A763">As is the case with all Wireshark labs, the full description of this lab is available at this book’s Web site, <a class="ulink" href="http://www.pearsonhighered.com/cs-resources">www.pearsonhighered.com/<wbr></wbr>cs-resources</a>.</p>
</section>
<section id="P70010119520000000000000000019A4" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019A4" class="practicediv level3"><header><h1 class="title" id="P700101195200000000000000000A764" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A764" epub:type="title"><span class="label">Wireshark Lab: Exploring UDP </span></h1></header>
<p id="P700101195200000000000000000A765" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A765">In this short lab, you’ll do a packet capture and analysis of your favorite application that uses UDP (for example, DNS or a multimedia application such as Skype). As we learned in <a class="xref" href="fileP70010119520000000000000000011C0.xhtml#P70010119520000000000000000011C0" data-foobar="7"><span class="label">Section</span> <span class="number">3.3</span></a>, UDP is a simple, no-frills transport protocol. In this lab, you’ll investigate the header fields in the UDP segment as well as the checksum calculation.</p>
<p id="P700101195200000000000000000A766" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A766">As is the case with all Wireshark labs, the full description of this lab is available at this book’s Web site, <a class="ulink" href="http://www.pearsonhighered.com/cs-resources">www.pearsonhighered.com/<wbr></wbr>cs-resources</a>.</p>
</section>
</section>
<aside class="sidebar" id="P70010119520000000000000000019A8" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019A8"><header><h1 class="title" id="P700101195200000000000000000A767" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A767" epub:type="title"><span class="pagebreak" title="303" id="P70010119520000000000000000019AA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019AA" epub:type="pagebreak" role="doc-pagebreak"></span><span class="label">AN INTERVIEW WITH... </span></h1></header>
<section class="read" id="P70010119520000000000000000019AB" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019AB">
<div class="authorgroup" id="P700101195200000000000000000A768" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A768"><div class="author" id="P700101195200000000000000000A769" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A769"><div class="name" id="P700101195200000000000000000A76A" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A76A"><p id="P700101195200000000000000000A76B" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A76B">Van Jacobson</p></div></div></div>
<p id="P700101195200000000000000000A76C" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A76C">Van Jacobson works at Google and was previously a Research Fellow at PARC. Prior to that, he was co-founder and Chief Scientist of Packet Design. Before that, he was Chief Scientist at Cisco. Before joining Cisco, he was head of the Network Research Group at Lawrence Berkeley National Laboratory and taught at UC Berkeley and Stanford. Van received the ACM SIGCOMM Award in 2001 for outstanding lifetime contribution to the field of communication networks and the IEEE Kobayashi Award in 2002 for “contributing to the understanding of network congestion and developing congestion control mechanisms that enabled the successful scaling of the Internet”. He was elected to the U.S. National Academy of Engineering in 2004.</p>
<figure id="P70010119520000000000000000019B1" class="informalfigure" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019B1">
<img alt="Photo of Van Jacobson." height="288" width="192" id="P700101195200000000000000000A76D" data-uri="P7001011952000000000000000005580" src="../images/4055103059.jpg"></img>
</figure>
</section>
<section id="P70010119520000000000000000019B3" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019B3"><header><h1 class="title" id="P700101195200000000000000000A76E" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A76E" epub:type="title">Please describe one or two of the most exciting projects you have worked on during your career. What were the biggest challenges?</h1></header>
<p id="P700101195200000000000000000A76F" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A76F">School teaches us lots of ways to find answers. In every interesting problem I’ve worked on, the challenge has been finding the right question. When Mike Karels and I started looking at TCP congestion, we spent months staring at protocol and packet traces asking “Why is it failing?”. One day in Mike’s office, one of us said “The reason I can’t figure out why it fails is because I don’t understand how it ever worked to begin with.” That turned out to be the right question and it forced us to figure out the “ack clocking” that makes TCP work. After that, the rest was easy.</p>
</section>
<section id="P70010119520000000000000000019B6" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019B6"><header><h1 class="title" id="P700101195200000000000000000A770" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A770" epub:type="title">More generally, where do you see the future of networking and the Internet?</h1></header>
<p id="P700101195200000000000000000A771" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A771">For most people, the Web is the Internet. Networking geeks smile politely since we know the Web is an application running over the Internet but what if they’re right? The Internet is about enabling conversations between pairs of hosts. The Web is about distributed information production and consumption. “Information propagation” is a very general view of communication of which “pairwise conversation” is a tiny subset. We need to move into the larger tent. Networking today deals with broadcast media (radios, PONs, etc.) by pretending it’s a point-to-point wire. That’s massively inefficient. Terabits-per-second of data are being exchanged all over the World via thumb drives or smart phones but we don’t know how to treat that as “networking”. ISPs are busily setting up caches and CDNs to scalably distribute video and audio. Caching is a necessary part of the solution but there’s no part of today’s networking—from Information, Queuing or Traffic Theory down to the Internet protocol <span class="pagebreak" title="304" id="P70010119520000000000000000019B9" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019B9" epub:type="pagebreak" role="doc-pagebreak"></span>specs—that tells us how to engineer and deploy it. I think and hope that over the next few years, networking will evolve to embrace the much larger vision of communication that underlies the Web.</p>
</section>
<section id="P70010119520000000000000000019BA" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019BA"><header><h1 class="title" id="P700101195200000000000000000A772" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A772" epub:type="title">What people inspired you professionally?</h1></header>
<p id="P700101195200000000000000000A773" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A773">When I was in grad school, Richard Feynman visited and gave a colloquium. He talked about a piece of Quantum theory that I’d been struggling with all semester and his explanation was so simple and lucid that what had been incomprehensible gibberish to me became obvious and inevitable. That ability to see and convey the simplicity that underlies our complex world seems to me a rare and wonderful gift.</p>
</section>
<section id="P70010119520000000000000000019BD" data-uri="M03_KURO4140_07_SE_C03.xhtml#P70010119520000000000000000019BD"><header><h1 class="title" id="P700101195200000000000000000A774" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A774" epub:type="title">What are your recommendations for students who want careers in computer science and networking?</h1></header>
<p id="P700101195200000000000000000A775" data-uri="M03_KURO4140_07_SE_C03.xhtml#P700101195200000000000000000A775">It’s a wonderful field—computers and networking have probably had more impact on society than any invention since the book. Networking is fundamentally about connecting stuff, and studying it helps you make intellectual connections: Ant foraging &amp; Bee dances demonstrate protocol design better than RFCs, traffic jams or people leaving a packed stadium are the essence of congestion, and students finding flights back to school in a post-Thanksgiving blizzard are the core of dynamic routing. If you’re interested in lots of stuff and want to have an impact, it’s hard to imagine a better field.</p>
</section>
</aside>
</section></body></html>