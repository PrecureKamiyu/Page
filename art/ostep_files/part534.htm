<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>49.1 AFS Version 1</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part533.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part535.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">49.1 AFS Version 1</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We will discuss two versions of AFS [H+88, S+85]. The first version (which we will call AFSv1, but actually the original system was called the ITC distributed file system [S+85]) had some of the basic design in place, but didn’t scale as desired, which led to a re-design and the final protocol (which we will call AFSv2, or just AFS) [H+88]. We now discuss the first version.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">One of the basic tenets of all versions of AFS is <b>whole-file caching </b>on the <b>local disk </b>of the client machine that is accessing a file. When you <span class="s41">open() </span>a file, the entire file (if it exists) is fetched from the server and stored in a file on your local disk. Subsequent application <span class="s41">read() </span>and <span class="s41">write() </span>operations are redirected to the local file system where the file is</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">575</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">TestAuth  Test whether a file has changed</p><p class="s38" style="padding-left: 68pt;text-indent: 58pt;text-align: left;">(used to validate cached entries) GetFileStat  Get the stat info for a file Fetch    Fetch the contents of file</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">Store    Store this file on the server SetFileStat  Set the stat info for a file ListDir   List the contents of a directory</p><p style="padding-top: 5pt;padding-left: 133pt;text-indent: 0pt;text-align: left;">Figure 49.1: <b>AFSv1 Protocol Highlights</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">stored; thus, these operations require no network communication and are fast. Finally, upon <span class="s41">close()</span>, the file (if it has been modified) is flushed back to the server. Note the obvious contrasts with NFS, which caches <i>blocks </i>(not whole files, although NFS could of course cache every block of an entire file) and does so in client <i>memory </i>(not local disk).</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let’s get into the details a bit more. When a client application first calls <span class="s41">open()</span>, the AFS client-side code (which the AFS designers call <b>Venus</b>) would send a Fetch protocol message to the server. The Fetch protocol message would pass the entire pathname of the desired file (for exam- ple, <span class="s41">/home/remzi/notes.txt</span>) to the file server (the group of which they called <b>Vice</b>), which would then traverse the pathname, find the de- sired file, and ship the entire file back to the client. The client-side code would then cache the file on the local disk of the client (by writing it to local disk). As we said above, subsequent <span class="s41">read() </span>and <span class="s41">write() </span>system calls are strictly <i>local </i>in AFS (no communication with the server occurs); they are just redirected to the local copy of the file. Because the <span class="s41">read() </span>and <span class="s41">write() </span>calls act just like calls to a local file system, once a block is accessed, it also may be cached in client memory. Thus, AFS also uses client memory to cache copies of blocks that it has in its local disk. Fi- nally, when finished, the AFS client checks if the file has been modified (i.e., that it has been opened for writing); if so, it flushes the new version back to the server with a Store protocol message, sending the entire file and pathname to the server for permanent storage.</p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">The next time the file is accessed, AFSv1 does so much more effi-</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">ciently. Specifically, the client-side code first contacts the server (using the TestAuth protocol message) in order to determine whether the file has changed. If not, the client would use the locally-cached copy, thus improving performance by avoiding a network transfer. The figure above shows some of the protocol messages in AFSv1. Note that this early ver- sion of the protocol only cached file contents; directories, for example, were only kept at the server.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part533.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part535.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
