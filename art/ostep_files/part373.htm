<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>36.7 Fitting Into The OS: The Device Driver</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part372.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part374.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">36.7 Fitting Into The OS: The Device Driver</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One final problem we will discuss: how to fit devices, each of which have very specific interfaces, into the OS, which we would like to keep as general as possible. For example, consider a file system. We’d like to build a file system that worked on top of SCSI disks, IDE disks, USB keychain drives, and so forth, and we’d like the file system to be relatively oblivious to all of the details of how to issue a read or write request to these difference types of drives. Thus, our problem:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>B<span class="s7">UILD </span>A D<span class="s7">EVICE</span>-<span class="s7">NEUTRAL </span>OS</p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: left;">How can we keep most of the OS device-neutral, thus hiding the de- tails of device interactions from major OS subsystems?</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The problem is solved through the age-old technique of <b>abstraction</b>. At the lowest level, a piece of software in the OS must know in detail how a device works. We call this piece of software a <b>device driver</b>, and any specifics of device interaction are encapsulated within.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Let us see how this abstraction might help OS design and implemen- tation by examining the Linux file system software stack. Figure <span style=" color: #00AEEF;">36.3 </span>is a rough and approximate depiction of the Linux software organization. As you can see from the diagram, a file system (and certainly, an appli- cation above) is completely oblivious to the specifics of which disk class it is using; it simply issues block read and write requests to the generic block layer, which routes them to the appropriate device driver, which handles the details of issuing the specific request. Although simplified, the diagram shows how such detail can be hidden from most of the OS.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="288" height="128" alt="image" src="Image_525.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 8pt;text-indent: 0pt;text-align: left;">Application</p><p class="s91" style="padding-top: 5pt;padding-left: 8pt;text-indent: 16pt;line-height: 167%;text-align: left;">POSIX API [open, read, write, close, etc.] File System</p><p class="s91" style="padding-left: 8pt;text-indent: 16pt;line-height: 167%;text-align: left;">Generic Block Interface [block read/write] Generic Block Layer</p><p style="text-indent: 0pt;text-align: left;"/><p class="s91" style="padding-left: 24pt;text-indent: 0pt;line-height: 4pt;text-align: left;">Specific Block Interface [protocol-specific read/write]</p><p class="s91" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">Device Driver [SCSI, ATA, etc.]</p><p style="text-indent: 0pt;text-align: left;"/><p class="s91" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">kernel mode</p><p style="text-indent: 0pt;text-align: left;"/><p class="s91" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">user</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 143pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Figure 36.3: <b>The File System Stack</b></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Note that such encapsulation can have its downside as well. For ex- ample, if there is a device that has many special capabilities, but has to present a generic interface to the rest of the kernel, those special capabili- ties will go unused. This situation arises, for example, in Linux with SCSI devices, which have very rich error reporting; because other block de- vices (e.g., ATA/IDE) have much simpler error handling, all that higher levels of software ever receive is a generic <span class="s41">EIO </span>(generic IO error) error code; any extra detail that SCSI may have provided is thus lost to the file system [G08].</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Interestingly, because device drivers are needed for any device you might plug into your system, over time they have come to represent a huge percentage of kernel code. Studies of the Linux kernel reveal that over 70% of OS code is found in device drivers [C01]; for Windows-based systems, it is likely quite high as well. Thus, when people tell you that the OS has millions of lines of code, what they are really saying is that the OS has millions of lines of device-driver code. Of course, for any given in- stallation, most of that code may not be active (i.e., only a few devices are connected to the system at a time). Perhaps more depressingly, as drivers are often written by “amateurs” (instead of full-time kernel developers), they tend to have many more bugs and thus are a primary contributor to kernel crashes [S03].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part372.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part374.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
