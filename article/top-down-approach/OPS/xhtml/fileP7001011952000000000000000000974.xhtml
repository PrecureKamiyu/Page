<?xml version="1.0" encoding="utf-8"?><html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/"><head>
<meta name="dcterms.conformsTo" content="PXE Basic 1.0"></meta>
<meta name="generator" content="PXE Tools version 1.39.109"></meta>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.109, partial=false-->
<title>2.1 Principles of Network Applications</title><link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/sepia.css"></link><link rel="alternate stylesheet" type="text/css" title="night" href="../css/night.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/main.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/print.css"></link></head><body epub:type="bodymatter">
<section id="P7001011952000000000000000000974" class="level1"><header><h1 class="title" id="P7001011952000000000000000009AB3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AB3" epub:type="title"><span class="number">2.1</span> Principles of Network Applications</h1></header>
<p id="P7001011952000000000000000009AB4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AB4">Suppose you have an idea for a new network application. Perhaps this application will be a great service to humanity, or will please your professor, or will bring you great wealth, or will simply be fun to develop. Whatever the motivation may be, let’s now examine how you transform the idea into a real-world network application.</p>
<p id="P7001011952000000000000000009AB5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AB5">At the core of network application development is writing programs that run on different end systems and communicate with each other over the network. For example, in the Web application there are two distinct programs that communicate with each other: the browser program running in the user’s host (desktop, laptop, tablet, smartphone, and so on); and the Web server program running in the Web server host. As another example, in a P2P file-sharing system there is a program in each host that participates in the file-sharing community. In this case, the programs in the various hosts may be similar or identical.</p>
<p id="P7001011952000000000000000009AB6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AB6">Thus, when developing your new application, you need to write software that will run on multiple end systems. This software could be written, for example, in C, Java, or Python. Importantly, you do not need to write software that runs on network-core devices, such as routers or link-layer switches. Even if you wanted to write application software for these network-core devices, you wouldn’t be able to do so. As we learned in <a class="xref" href="fileP7001011952000000000000000000458.xhtml#P7001011952000000000000000000458" data-foobar="7"><span class="label">Chapter</span> <span class="number">1</span></a>, and as shown earlier in <a class="xref" href="fileP700101195200000000000000000065D.xhtml#P70010119520000000000000000006E6" data-foobar="7"><span class="label">Figure</span> <span class="number">1.24</span></a>, network-core devices do not function at the application layer but instead function at lower layers—specifically at the network layer and below. This basic design—namely, confining application software to the end systems—as shown in <a class="xref" href="#P700101195200000000000000000097A" data-foobar="1"><span class="label">Figure</span> <span class="number">2.1</span></a>, has facilitated the rapid development and deployment of a vast array of network applications.<span class="pagebreak" title="85" id="P7001011952000000000000000000979" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000979" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P700101195200000000000000000097A" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P700101195200000000000000000097A">
<img alt="Illustration of a communication for a network application between end systems at the application layer. " height="921" width="799" aria-describedby="P700101195200000000000000000097E" id="P7001011952000000000000000009AB7" data-uri="P700101195200000000000000000551E" src="../images/4055102001.png"></img>
<figcaption id="P7001011952000000000000000009AB8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AB8"><header><h1 class="title" id="P7001011952000000000000000009AB9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AB9" epub:type="title"><span class="label">Figure </span><span class="number">2.1</span> Communication for a network application takes place between end systems at the application layer</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000097E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P700101195200000000000000000097E" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055102001.xhtml#la_4055102001"><span class="label">Description</span></a></div>
<section id="P700101195200000000000000000098C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P700101195200000000000000000098C" class="level2"><header><h1 class="title" id="P7001011952000000000000000009AC7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AC7" epub:type="title"><span class="pagebreak" title="86" id="P700101195200000000000000000098E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P700101195200000000000000000098E" epub:type="pagebreak" role="doc-pagebreak"></span><span class="number">2.1.1</span> Network Application Architectures</h1></header>
<p id="P7001011952000000000000000009AC8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AC8">Before diving into software coding, you should have a broad architectural plan for your application. Keep in mind that an application’s architecture is distinctly different from the network architecture (e.g., the five-layer Internet architecture discussed in <a class="xref" href="fileP7001011952000000000000000000458.xhtml#P7001011952000000000000000000458" data-foobar="7"><span class="label">Chapter</span> <span class="number">1</span></a>). From the application developer’s perspective, the network architecture is fixed and provides a specific set of services to applications. The <span class="keyword" id="P7001011952000000000000000000990" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000990"><b>application architecture</b></span>, on the other hand, is designed by the application developer and dictates how the application is structured over the various end systems. In choosing the application architecture, an application developer will likely draw on one of the two predominant architectural paradigms used in modern network applications: the client-server architecture or the peer-to-peer (P2P) architecture.</p>
<p id="P7001011952000000000000000009AC9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AC9">In a <span class="keyword" id="P7001011952000000000000000000992" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000992"><b>client-server architecture</b></span>, there is an always-on host, called the <i>server</i>, which services requests from many other hosts, called <i>clients</i>. A classic example is the Web application for which an always-on Web server services requests from browsers running on client hosts. When a Web server receives a request for an object from a client host, it responds by sending the requested object to the client host. Note that with the client-server architecture, clients do not directly communicate with each other; for example, in the Web application, two browsers do not directly communicate. Another characteristic of the client-server architecture is that the server has a fixed, well-known address, called an IP address (which we’ll discuss soon). Because the server has a fixed, well-known address, and because the server is always on, a client can always contact the server by sending a packet to the server’s IP address. Some of the better-known applications with a client-server architecture include the Web, FTP, Telnet, and e-mail. The client-server architecture is shown in <a class="xref" href="#P7001011952000000000000000000998" data-foobar="1"><span class="label">Figure</span> <span class="number">2.2(a)</span></a>.</p>
<p id="P7001011952000000000000000009ACA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ACA">Often in a client-server application, a single-server host is incapable of keeping up with all the requests from clients. For example, a popular social-networking site can quickly become overwhelmed if it has only one server handling all of its requests. For this reason, a <span class="keyword" id="P7001011952000000000000000000994" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000994"><b>data center</b></span>, housing a large number of hosts, is often used to create a powerful virtual server. The most popular Internet services—such as search engines (e.g., Google, Bing, Baidu), Internet commerce (e.g., Amazon, eBay, Alibaba), Web-based e-mail (e.g., Gmail and Yahoo Mail), social networking (e.g., Facebook, Instagram, Twitter, and WeChat)—employ one or more data centers. As discussed in <a class="xref" href="fileP7001011952000000000000000000542.xhtml#P70010119520000000000000000005AF" data-foobar="7"><span class="label">Section</span> <span class="number">1.3.3</span></a>, Google has 30 to 50 data centers distributed around the world, which collectively handle search, YouTube, Gmail, and other services. A data center can have hundreds of thousands of servers, which must be powered and maintained. Additionally, the service providers must pay recurring interconnection and bandwidth costs for sending data from their data centers.</p>
<p id="P7001011952000000000000000009ACB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ACB">In a <span class="keyword" id="P7001011952000000000000000000996" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000996">P2P architecture</span>, there is minimal (or no) reliance on dedicated servers in data centers. Instead the application exploits direct communication between pairs of intermittently connected hosts, called <i>peers</i>. The peers are not owned by the service provider, but are instead desktops and laptops controlled by users, with most of the<span class="pagebreak" title="87" id="P7001011952000000000000000000997" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000997" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000000998" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000998">
<img alt="An illustration of client-server architecture." height="503" width="362" aria-describedby="P700101195200000000000000000099D" id="P7001011952000000000000000009ACC" data-uri="P700101195200000000000000000551F" src="../images/4055102002.png"></img>
<img alt="" height="506" width="362" id="P7001011952000000000000000009ACD" data-uri="P7001011952000000000000000005520" aria-describedby="P700101195200000000000000000099D" src="../images/4055102002a.png"></img>
<figcaption id="P7001011952000000000000000009ACE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ACE"><header><h1 class="title" id="P7001011952000000000000000009ACF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ACF" epub:type="title"><span class="label">Figure </span><span class="number">2.2</span> (a) Client-server architecture; (b) P2P architecture</h1></header>

</figcaption>
</figure><div class="longdesc" id="P700101195200000000000000000099D" data-uri="M02_KURO4140_07_SE_C02.xhtml#P700101195200000000000000000099D" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055102002.xhtml#la_4055102002"><span class="label">Description</span></a></div>
<figure id="P700101195200000000000000000099F" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P700101195200000000000000000099F">
<img alt="An illustration of peer-to-peer architecture." height="506" width="362" aria-describedby="P70010119520000000000000000009A1" id="P7001011952000000000000000009AD1" data-uri="P7001011952000000000000000005520" src="../images/4055102002a.png"></img>
<details class="longdesc" id="P70010119520000000000000000009A1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009A1">
<summary><span class="label">Description</span></summary>
<p id="P7001011952000000000000000009AD2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AD2">This illustration uses the same image of interconnected networks, but includes blue arrows to show the relationship between peers. One arrow connects a laptop computer in the Mobile Network to a desktop computer in the Home Network. Another connects a laptop computer in the Home Network to a desktop computer in the Enterprise Network. A third connects a laptop to a desktop in the Enterprise Network.</p>
</details>
</figure>
<p class="continued" id="P7001011952000000000000000009AD3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AD3">peers residing in homes, universities, and offices. Because the peers communicate without passing through a dedicated server, the architecture is called peer-to-peer. Many of today’s most popular and traffic-intensive applications are based on P2P architectures. These applications include file sharing (e.g., BitTorrent), peer-assisted download acceleration (e.g., Xunlei), and Internet telephony and video conference (e.g., Skype). The P2P architecture is illustrated in <a class="xref" href="#P7001011952000000000000000000998" data-foobar="1"><span class="label">Figure</span> <span class="number">2.2(b)</span></a>. We mention that some applications have hybrid architectures, combining both client-server and P2P elements. For example, for many instant messaging applications, servers are used to track the IP addresses of users, but user-to-user messages are sent directly between user hosts (without passing through intermediate servers).</p>
<p id="P7001011952000000000000000009AD4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AD4">One of the most compelling features of P2P architectures is their <span class="keyword" id="P70010119520000000000000000009A5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009A5"><b>self-scalability</b></span>. For example, in a P2P file-sharing application, although each peer generates workload by requesting files, each peer also adds service capacity to the system by distributing files to other peers. P2P architectures are also cost effective, since they normally don’t require significant server infrastructure and server bandwidth <span class="pagebreak" title="88" id="P70010119520000000000000000009A6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009A6" epub:type="pagebreak" role="doc-pagebreak"></span>(in contrast with clients-server designs with datacenters). However, P2P applications face challenges of security, performance, and reliability due to their highly decentralized structure.</p>
</section>
<section id="P70010119520000000000000000009A7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009A7" class="level2"><header><h1 class="title" id="P7001011952000000000000000009AD5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AD5" epub:type="title"><span class="number">2.1.2</span> Processes Communicating</h1></header>
<p id="P7001011952000000000000000009AD6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AD6">Before building your network application, you also need a basic understanding of how the programs, running in multiple end systems, communicate with each other. In the jargon of operating systems, it is not actually programs but <span class="keyword" id="P70010119520000000000000000009AA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009AA"><b>processes</b></span> that communicate. A process can be thought of as a program that is running within an end system. When processes are running on the same end system, they can communicate with each other with interprocess communication, using rules that are governed by the end system’s operating system. But in this book we are not particularly interested in how processes in the same host communicate, but instead in how processes running on <i>different</i> hosts (with potentially different operating systems) communicate.</p>
<p id="P7001011952000000000000000009AD7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AD7">Processes on two different end systems communicate with each other by exchanging <span class="keyword" id="P70010119520000000000000000009AC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009AC">messages</span> across the computer network. A sending process creates and sends messages into the network; a receiving process receives these messages and possibly responds by sending messages back. <a class="xref" href="#P700101195200000000000000000097A" data-foobar="1"><span class="label">Figure</span> <span class="number">2.1</span></a> illustrates that processes communicating with each other reside in the application layer of the five-layer protocol stack.</p>
<section id="P70010119520000000000000000009AD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009AD" class="level3"><header><h1 class="title" id="P7001011952000000000000000009AD8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AD8" epub:type="title">Client and Server Processes</h1></header>
<p id="P7001011952000000000000000009AD9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AD9">A network application consists of pairs of processes that send messages to each other over a network. For example, in the Web application a client browser process exchanges messages with a Web server process. In a P2P file-sharing system, a file is transferred from a process in one peer to a process in another peer. For each pair of communicating processes, we typically label one of the two processes as the <span class="keyword" id="P70010119520000000000000000009B0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009B0"><b>client</b></span> and the other process as the <span class="keyword" id="P70010119520000000000000000009B1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009B1"><b>server</b></span>. With the Web, a browser is a client process and a Web server is a server process. With P2P file sharing, the peer that is downloading the file is labeled as the client, and the peer that is uploading the file is labeled as the server.</p>
<p id="P7001011952000000000000000009ADA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ADA">You may have observed that in some applications, such as in P2P file sharing, a process can be both a client and a server. Indeed, a process in a P2P file-sharing system can both upload and download files. Nevertheless, in the context of any given communication session between a pair of processes, we can still label one process as the client and the other process as the server. We define the client and server processes as follows:</p>
<div class="blockquotegroup" id="P7001011952000000000000000009ADB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ADB"><blockquote class="extract" id="P7001011952000000000000000009ADC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ADC"><p id="P7001011952000000000000000009ADD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ADD"><i>In the context of a communication session between a pair of processes, the process that initiates the communication (that is, initially contacts the other process at the beginning of the session) is labeled as the</i> client. <i>The process that waits to be contacted to begin the session is the</i> server.</p></blockquote></div>
<p id="P7001011952000000000000000009ADE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ADE"><span class="pagebreak" title="89" id="P70010119520000000000000000009B7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009B7" epub:type="pagebreak" role="doc-pagebreak"></span>In the Web, a browser process initializes contact with a Web server process; hence the browser process is the client and the Web server process is the server. In P2P file sharing, when Peer A asks Peer B to send a specific file, Peer A is the client and Peer B is the server in the context of this specific communication session. When there’s no confusion, we’ll sometimes also use the terminology “client side and server side of an application.” At the end of this chapter, we’ll step through simple code for both the client and server sides of network applications.</p>
</section>
<section id="P70010119520000000000000000009B8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009B8" class="level3"><header><h1 class="title" id="P7001011952000000000000000009ADF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ADF" epub:type="title">The Interface Between the Process and the Computer Network</h1></header>
<p id="P7001011952000000000000000009AE0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AE0">As noted above, most applications consist of pairs of communicating processes, with the two processes in each pair sending messages to each other. Any message sent from one process to another must go through the underlying network. A process sends messages into, and receives messages from, the network through a software interface called a <span class="keyword" id="P70010119520000000000000000009BB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009BB"><b>socket</b></span>. Let’s consider an analogy to help us understand processes and sockets. A process is analogous to a house and its socket is analogous to its door. When a process wants to send a message to another process on another host, it shoves the message out its door (socket). This sending process assumes that there is a transportation infrastructure on the other side of its door that will transport the message to the door of the destination process. Once the message arrives at the destination host, the message passes through the receiving process’s door (socket), and the receiving process then acts on the message.</p>
<p id="P7001011952000000000000000009AE1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AE1"><a class="xref" href="#P70010119520000000000000000009C2" data-foobar="1"><span class="label">Figure</span> <span class="number">2.3</span></a> illustrates socket communication between two processes that communicate over the Internet. (<a class="xref" href="#P70010119520000000000000000009C2" data-foobar="1"><span class="label">Figure</span> <span class="number">2.3</span></a> assumes that the underlying transport protocol used by the processes is the Internet’s TCP protocol.) As shown in this figure, a socket is the interface between the application layer and the transport layer within a host. It is also referred to as the <span class="keyword" id="P70010119520000000000000000009BD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009BD"><b>Application Programming Interface (API)</b></span> between the application and the network, since the socket is the programming interface with which network applications are built. The application developer has control of everything on the application-layer side of the socket but has little control of the transport-layer side of the socket. The only control that the application developer has on the transport-layer side is (1) the choice of transport protocol and (2) perhaps the ability to fix a few transport-layer parameters such as maximum buffer and maximum segment sizes (to be covered in <a class="xref" href="fileP70010119520000000000000000010EC.xhtml#P70010119520000000000000000010EC" data-foobar="7"><span class="label">Chapter</span> <span class="number">3</span></a>). Once the application developer chooses a transport protocol (if a choice is available), the application is built using the transport-layer services provided by that protocol. We’ll explore sockets in some detail in <a class="xref" href="fileP7001011952000000000000000000E42.xhtml#P7001011952000000000000000000E42" data-foobar="7"><span class="label">Section</span> <span class="number">2.7</span></a>.</p>
</section>
<section id="P70010119520000000000000000009BE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009BE" class="level3"><header><h1 class="title" id="P7001011952000000000000000009AE2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AE2" epub:type="title">Addressing Processes</h1></header>
<p id="P7001011952000000000000000009AE3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AE3">In order to send postal mail to a particular destination, the destination needs to have an address. Similarly, in order for a process running on one host to send packets to a process running on another host, the receiving process needs to have an address.<span class="pagebreak" title="90" id="P70010119520000000000000000009C1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009C1" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P70010119520000000000000000009C2" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009C2">
<img alt="An illustration of application processes, sockets, and underlying transport protocol." height="357" width="784" aria-describedby="P70010119520000000000000000009C6" id="P7001011952000000000000000009AE4" data-uri="P7001011952000000000000000005521" src="../images/4055102003.png"></img>
<figcaption id="P7001011952000000000000000009AE5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AE5"><header><h1 class="title" id="P7001011952000000000000000009AE6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AE6" epub:type="title"><span class="label">Figure </span><span class="number">2.3</span> Application processes, sockets, and underlying transport protocol</h1></header>

</figcaption>
</figure><div class="longdesc" id="P70010119520000000000000000009C6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009C6" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055102003.xhtml#la_4055102003"><span class="label">Description</span></a></div>
<p class="continued" id="P7001011952000000000000000009AEE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AEE">To identify the receiving process, two pieces of information need to be specified: (1) the address of the host and (2) an identifier that specifies the receiving process in the destination host.</p>
<p id="P7001011952000000000000000009AEF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AEF">In the Internet, the host is identified by its <span class="keyword" id="P70010119520000000000000000009D0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009D0"><b>IP address</b></span>. We’ll discuss IP addresses in great detail in <a class="xref" href="fileP70010119520000000000000000019C1.xhtml#P70010119520000000000000000019C1" data-foobar="7"><span class="label">Chapter</span> <span class="number">4</span></a>. For now, all we need to know is that an IP address is a 32-bit quantity that we can think of as uniquely identifying the host. In addition to knowing the address of the host to which a message is destined, the sending process must also identify the receiving process (more specifically, the receiving socket) running in the host. This information is needed because in general a host could be running many network applications. A destination <span class="keyword" id="P70010119520000000000000000009D1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009D1"><b>port number</b></span> serves this purpose. Popular applications have been assigned specific port numbers. For example, a Web server is identified by port number 80. A mail server process (using the SMTP protocol) is identified by port number 25. A list of well-known port numbers for all Internet standard protocols can be found at <a class="ulink" href="http://www.iana.org">www.iana.org</a>. We’ll examine port numbers in detail in <a class="xref" href="fileP70010119520000000000000000010EC.xhtml#P70010119520000000000000000010EC" data-foobar="7"><span class="label">Chapter</span> <span class="number">3</span></a>.</p>
</section>
</section>
<section id="P70010119520000000000000000009D2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009D2" class="level2"><header><h1 class="title" id="P7001011952000000000000000009AF0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF0" epub:type="title"><span class="number">2.1.3</span> Transport Services Available to Applications</h1></header>
<p id="P7001011952000000000000000009AF1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF1">Recall that a socket is the interface between the application process and the transport-layer protocol. The application at the sending side pushes messages through the socket. At the other side of the socket, the transport-layer protocol has the responsibility of getting the messages to the socket of the receiving process.</p>
<p id="P7001011952000000000000000009AF2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF2">Many networks, including the Internet, provide more than one transport-layer protocol. When you develop an application, you must choose one of the available <span class="pagebreak" title="91" id="P70010119520000000000000000009D6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009D6" epub:type="pagebreak" role="doc-pagebreak"></span>transport-layer protocols. How do you make this choice? Most likely, you would study the services provided by the available transport-layer protocols, and then pick the protocol with the services that best match your application’s needs. The situation is similar to choosing either train or airplane transport for travel between two cities. You have to choose one or the other, and each transportation mode offers different services. (For example, the train offers downtown pickup and drop-off, whereas the plane offers shorter travel time.)</p>
<p id="P7001011952000000000000000009AF3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF3">What are the services that a transport-layer protocol can offer to applications invoking it? We can broadly classify the possible services along four dimensions: reliable data transfer, throughput, timing, and security.</p>
<section id="P70010119520000000000000000009D8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009D8" class="level3"><header><h1 class="title" id="P7001011952000000000000000009AF4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF4" epub:type="title">Reliable Data Transfer</h1></header>
<p id="P7001011952000000000000000009AF5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF5">As discussed in <a class="xref" href="fileP7001011952000000000000000000458.xhtml#P7001011952000000000000000000458" data-foobar="7"><span class="label">Chapter</span> <span class="number">1</span></a>, packets can get lost within a computer network. For example, a packet can overflow a buffer in a router, or can be discarded by a host or router after having some of its bits corrupted. For many applications—such as electronic mail, file transfer, remote host access, Web document transfers, and financial applications—data loss can have devastating consequences (in the latter case, for either the bank or the customer!). Thus, to support these applications, something has to be done to guarantee that the data sent by one end of the application is delivered correctly and completely to the other end of the application. If a protocol provides such a guaranteed data delivery service, it is said to provide <span class="keyword" id="P70010119520000000000000000009DB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009DB"><b>reliable data transfer</b></span>. One important service that a transport-layer protocol can potentially provide to an application is process-to-process reliable data transfer. When a transport protocol provides this service, the sending process can just pass its data into the socket and know with complete confidence that the data will arrive without errors at the receiving process.</p>
<p id="P7001011952000000000000000009AF6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF6">When a transport-layer protocol doesn’t provide reliable data transfer, some of the data sent by the sending process may never arrive at the receiving process. This may be acceptable for <span class="keyword" id="P70010119520000000000000000009DD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009DD"><b>loss-tolerant applications</b></span>, most notably multimedia applications such as conversational audio/video that can tolerate some amount of data loss. In these multimedia applications, lost data might result in a small glitch in the audio/video—not a crucial impairment.</p>
</section>
<section id="P70010119520000000000000000009DE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009DE" class="level3"><header><h1 class="title" id="P7001011952000000000000000009AF7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF7" epub:type="title">Throughput</h1></header>
<p id="P7001011952000000000000000009AF8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF8">In <a class="xref" href="fileP7001011952000000000000000000458.xhtml#P7001011952000000000000000000458" data-foobar="7"><span class="label">Chapter</span> <span class="number">1</span></a> we introduced the concept of available throughput, which, in the context of a communication session between two processes along a network path, is the rate at which the sending process can deliver bits to the receiving process. Because other sessions will be sharing the bandwidth along the network path, and because these other sessions will be coming and going, the available throughput can fluctuate with time. These observations lead to another natural service that a transport-layer protocol could provide, namely, guaranteed available throughput at <span class="pagebreak" title="92" id="P70010119520000000000000000009E1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009E1" epub:type="pagebreak" role="doc-pagebreak"></span>some specified rate. With such a service, the application could request a guaranteed throughput of <i>r</i> bits/sec, and the transport protocol would then ensure that the available throughput is always at least <i>r</i> bits/sec. Such a guaranteed throughput service would appeal to many applications. For example, if an Internet telephony application encodes voice at 32 kbps, it needs to send data into the network and have data delivered to the receiving application at this rate. If the transport protocol cannot provide this throughput, the application would need to encode at a lower rate (and receive enough throughput to sustain this lower coding rate) or may have to give up, since receiving, say, half of the needed throughput is of little or no use to this Internet telephony application. Applications that have throughput requirements are said to be <span class="keyword" id="P70010119520000000000000000009E2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009E2"><b>bandwidth-sensitive applications</b></span>. Many current multimedia applications are bandwidth sensitive, although some multimedia applications may use adaptive coding techniques to encode digitized voice or video at a rate that matches the currently available throughput.</p>
<p id="P7001011952000000000000000009AF9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AF9">While bandwidth-sensitive applications have specific throughput requirements, <span class="keyword" id="P70010119520000000000000000009E4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009E4"><b>elastic applications</b></span> can make use of as much, or as little, throughput as happens to be available. Electronic mail, file transfer, and Web transfers are all elastic applications. Of course, the more throughput, the better. There’san adage that says that one cannot be too rich, too thin, or have too much throughput!</p>
</section>
<section id="P70010119520000000000000000009E5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009E5" class="level3"><header><h1 class="title" id="P7001011952000000000000000009AFA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AFA" epub:type="title">Timing</h1></header>
<p id="P7001011952000000000000000009AFB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AFB">A transport-layer protocol can also provide timing guarantees. As with throughput guarantees, timing guarantees can come in many shapes and forms. An example guarantee might be that every bit that the sender pumps into the socket arrives at the receiver’s socket no more than 100 msec later. Such a service would be appealing to interactive real-time applications, such as Internet telephony, virtual environments, teleconferencing, and multiplayer games, all of which require tight timing constraints on data delivery in order to be effective. (See <a class="xref" href="fileP70010119520000000000000000033D7.xhtml#P70010119520000000000000000033D7" data-foobar="7"><span class="label">Chapter</span> <span class="number">9</span></a>, <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P700101195200000000000000000391F" data-foobar="7">[Gauthier 1999</a>; <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003AD0" data-foobar="7">Ramjee 1994]</a>.) Long delays in Internet telephony, for example, tend to result in unnatural pauses in the conversation; in a multiplayer game or virtual interactive environment, a long delay between taking an action and seeing the response from the environment (for example, from another player at the end of an end-to-end connection) makes the application feel less realistic. For non-real-time applications, lower delay is always preferable to higher delay, but no tight constraint is placed on the end-to-end delays.</p>
</section>
<section id="P70010119520000000000000000009E8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009E8" class="level3"><header><h1 class="title" id="P7001011952000000000000000009AFC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AFC" epub:type="title">Security</h1></header>
<p id="P7001011952000000000000000009AFD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AFD">Finally, a transport protocol can provide an application with one or more security services. For example, in the sending host, a transport protocol can encrypt all data transmitted by the sending process, and in the receiving host, the transport-layer protocol can decrypt the data before delivering the data to the receiving process. Such a service would provide confidentiality between the two processes, even if the data is <span class="pagebreak" title="93" id="P70010119520000000000000000009EB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009EB" epub:type="pagebreak" role="doc-pagebreak"></span>somehow observed between sending and receiving processes. A transport protocol can also provide other security services in addition to confidentiality, including data integrity and end-point authentication, topics that we’ll cover in detail in <a class="xref" href="fileP70010119520000000000000000033D7.xhtml#P70010119520000000000000000033D7" data-foobar="7"><span class="label">Chapter</span> <span class="number">8</span></a>.</p>
</section>
</section>
<section id="P70010119520000000000000000009EC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009EC" class="level2"><header><h1 class="title" id="P7001011952000000000000000009AFE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AFE" epub:type="title"><span class="number">2.1.4</span> Transport Services Provided by the Internet</h1></header>
<p id="P7001011952000000000000000009AFF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009AFF">Up until this point, we have been considering transport services that a computer network <i>could</i> provide in general. Let’s now get more specific and examine the type of transport services provided by the Internet. The Internet (and, more generally, TCP/IP networks) makes two transport protocols available to applications, UDP and TCP. When you (as an application developer) create a new network application for the Internet, one of the first decisions you have to make is whether to use UDP or TCP. Each of these protocols offers a different set of services to the invoking applications. <a class="xref" href="#P70010119520000000000000000009F6" data-foobar="1"><span class="label">Figure</span> <span class="number">2.4</span></a> shows the service requirements for some selected applications.</p>
<section id="P70010119520000000000000000009EF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009EF" class="level3"><header><h1 class="title" id="P7001011952000000000000000009B00" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B00" epub:type="title">TCP Services</h1></header>
<p id="P7001011952000000000000000009B01" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B01">The TCP service model includes a connection-oriented service and a reliable data transfer service. When an application invokes TCP as its transport protocol, the application receives both of these services from TCP.</p>
<ul id="P7001011952000000000000000009B02" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B02">
<li id="P7001011952000000000000000009B03" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B03"><p id="P7001011952000000000000000009B04" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B04"><span class="leadin">Connection-oriented service.</span> TCP has the client and server exchange transport-layer control information with each other <i>before</i> the application-level messages begin to flow. This so-called handshaking procedure alerts the client and server, allowing them to prepare for an onslaught of packets. After the handshaking phase, a <span class="keyword" id="P70010119520000000000000000009F5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009F5"><b>TCP connection</b></span> is said to exist between the sockets</p>
<figure id="P70010119520000000000000000009F6" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009F6">
<img alt="" height="335" width="673" id="P7001011952000000000000000009B05" data-uri="P7001011952000000000000000005522" src="../images/4055102004.png"></img>
<figcaption id="P7001011952000000000000000009B06" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B06"><header><h1 class="title" id="P7001011952000000000000000009B07" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B07" epub:type="title"><span class="label">Figure </span><span class="number">2.4</span> Requirements of selected network applications</h1></header>
</figcaption>
</figure>
<p class="continued" id="P7001011952000000000000000009B08" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B08"><span class="pagebreak" title="94" id="P70010119520000000000000000009FB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009FB" epub:type="pagebreak" role="doc-pagebreak"></span>of the two processes. The connection is a full-duplex connection in that the two processes can send messages to each other over the connection at the same time. When the application finishes sending messages, it must tear down the connection. In <a class="xref" href="fileP70010119520000000000000000010EC.xhtml#P70010119520000000000000000010EC" data-foobar="7"><span class="label">Chapter</span> <span class="number">3</span></a> we’ll discuss connection-oriented service in detail and examine how it is implemented.</p></li>
<li id="P7001011952000000000000000009B09" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B09"><p id="P7001011952000000000000000009B0A" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B0A"><span class="leadin">Reliable data transfer service.</span> The communicating processes can rely on TCP to deliver all data sent without error and in the proper order. When one side of the application passes a stream of bytes into a socket, it can count on TCP to deliver the same stream of bytes to the receiving socket, with no missing or duplicate bytes.</p></li>
</ul>
<p id="P7001011952000000000000000009B0B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B0B">TCP also includes a congestion-control mechanism, a service for the general welfare of the Internet rather than for the direct benefit of the communicating processes. The TCP congestion-control mechanism throttles a sending process (client or server) when the network is congested between sender and receiver. As we will see</p>
<aside class="sidebar" id="P70010119520000000000000000009FF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P70010119520000000000000000009FF"><header><h1 class="title" id="P7001011952000000000000000009B0C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B0C" epub:type="title"><span class="label">FOCUS ON SECURITY </span></h1></header>
<section id="P7001011952000000000000000000A01" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A01"><header><h1 class="title" id="P7001011952000000000000000009B0D" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B0D" epub:type="title">SECURING TCP</h1></header>
<p id="P7001011952000000000000000009B0E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B0E">Neither TCP nor UDP provides any encryption—the data that the sending process passes into its socket is the same data that travels over the network to the destination process. So, for example, if the sending process sends a password in cleartext (i.e., unencrypted) into its socket, the cleartext password will travel over all the links between sender and receiver, potentially getting sniffed and discovered at any of the intervening links. Because privacy and other security issues have become critical for many applications, the Internet community has developed an enhancement for TCP, called <span class="keyword" id="P7001011952000000000000000000A04" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A04"><b>Secure Sockets Layer (SSL)</b></span>. TCP-enhanced-with-SSL not only does everything that traditional TCP does but also provides critical process-to-process security services, including encryption, data integrity, and end-point authentication. We emphasize that SSL is not a third Internet transport protocol, on the same level as TCP and UDP, but instead is an enhancement of TCP, with the enhancements being implemented in the application layer. In particular, if an application wants to use the services of SSL, it needs to include SSL code (existing, highly optimized libraries and classes) in both the client and server sides of the application. SSL has its own socket API that is similar to the traditional TCP socket API. When an application uses SSL, the sending process passes cleartext data to the SSL socket; SSL in the sending host then encrypts the data and passes the encrypted data to the TCP socket. The encrypted data travels over the Internet to the TCP socket in the receiving process. The receiving socket passes the encrypted data to SSL, which decrypts the data. Finally, SSL passes the cleartext data through its SSL socket to the receiving process. We’ll cover SSL in some detail in <a class="xref" href="fileP7001011952000000000000000002D4B.xhtml#P7001011952000000000000000002D4B" data-foobar="7"><span class="label">Chapter</span> <span class="number">8</span></a>.</p>
</section>
</aside>
<p class="continued" id="P7001011952000000000000000009B0F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B0F"><span class="pagebreak" title="95" id="P7001011952000000000000000000A06" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A06" epub:type="pagebreak" role="doc-pagebreak"></span>in <a class="xref" href="fileP70010119520000000000000000010EC.xhtml#P70010119520000000000000000010EC" data-foobar="7"><span class="label">Chapter</span> <span class="number">3</span></a>, TCP congestion control also attempts to limit each TCP connection to its fair share of network bandwidth.</p>
</section>
<section id="P7001011952000000000000000000A07" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A07" class="level3"><header><h1 class="title" id="P7001011952000000000000000009B10" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B10" epub:type="title">UDP Services</h1></header>
<p id="P7001011952000000000000000009B11" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B11">UDP is a no-frills, lightweight transport protocol, providing minimal services. UDP is connectionless, so there is no handshaking before the two processes start to communicate. UDP provides an unreliable data transfer service—that is, when a process sends a message into a UDP socket, UDP provides <i>no</i> guarantee that the message will ever reach the receiving process. Furthermore, messages that do arrive at the receiving process may arrive out of order.</p>
<p id="P7001011952000000000000000009B12" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B12">UDP does not include a congestion-control mechanism, so the sending side of UDP can pump data into the layer below (the network layer) at any rate it pleases. (Note, however, that the actual end-to-end throughput may be less than this rate due to the limited transmission capacity of intervening links or due to congestion).</p>
</section>
<section id="P7001011952000000000000000000A0B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A0B" class="level3"><header><h1 class="title" id="P7001011952000000000000000009B13" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B13" epub:type="title">Services Not Provided by Internet Transport Protocols</h1></header>
<p id="P7001011952000000000000000009B14" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B14">We have organized transport protocol services along four dimensions: reliable data transfer, throughput, timing, and security. Which of these services are provided by TCP and UDP? We have already noted that TCP provides reliable end-to-end data transfer. And we also know that TCP can be easily enhanced at the application layer with SSL to provide security services. But in our brief description of TCP and UDP, conspicuously missing was any mention of throughput or timing guarantees— services <i>not</i> provided by today’s Internet transport protocols. Does this mean that time-sensitive applications such as Internet telephony cannot run in today’s Internet? The answer is clearly no—the Internet has been hosting time-sensitive applications for many years. These applications often work fairly well because they have been designed to cope, to the greatest extent possible, with this lack of guarantee. We’ll investigate several of these design tricks in <a class="xref" href="fileP70010119520000000000000000033D7.xhtml#P70010119520000000000000000033D7" data-foobar="7"><span class="label">Chapter</span> <span class="number">9</span></a>. Nevertheless, clever design has its limitations when delay is excessive, or the end-to-end throughput is limited. In summary, today’s Internet can often provide satisfactory service to time-sensitive applications, but it cannot provide any timing or throughput guarantees.</p>
<p id="P7001011952000000000000000009B15" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B15"><a class="xref" href="#P7001011952000000000000000000A10" data-foobar="1"><span class="label">Figure</span> <span class="number">2.5</span></a> indicates the transport protocols used by some popular Internet applications. We see that e-mail, remote terminal access, the Web, and file transfer all use TCP. These applications have chosen TCP primarily because TCP provides reliable data transfer, guaranteeing that all data will eventually get to its destination. Because Internet telephony applications (such as Skype) can often tolerate some loss but require a minimal rate to be effective, developers of Internet telephony applications usually prefer to run their applications over UDP, thereby circumventing TCP’s congestion control mechanism and packet overheads. But because many firewalls are configured to block (most types of) UDP traffic, Internet telephony applications often are designed to use TCP as a backup if UDP communication fails.<span class="pagebreak" title="96" id="P7001011952000000000000000000A0F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A0F" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000000A10" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A10">
<img alt="" height="274" width="672" id="P7001011952000000000000000009B16" data-uri="P7001011952000000000000000005523" src="../images/4055102005.png"></img>
<figcaption id="P7001011952000000000000000009B17" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B17"><header><h1 class="title" id="P7001011952000000000000000009B18" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B18" epub:type="title"><span class="label">Figure </span><span class="number">2.5</span> Popular Internet applications, their application-layer protocols, and their underlying transport protocols</h1></header>
</figcaption>
</figure>
</section>
</section>
<section id="P7001011952000000000000000000A14" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A14" class="level2"><header><h1 class="title" id="P7001011952000000000000000009B19" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B19" epub:type="title"><span class="number">2.1.5</span> Application-Layer Protocols</h1></header>
<p id="P7001011952000000000000000009B1A" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B1A">We have just learned that network processes communicate with each other by sending messages into sockets. But how are these messages structured? What are the meanings of the various fields in the messages? When do the processes send the messages? These questions bring us into the realm of application-layer protocols. An <span class="keyword" id="P7001011952000000000000000000A17" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A17"><b>application-layer protocol</b></span> defines how an application’s processes, running on different end systems, pass messages to each other. In particular, an application-layer protocol defines:</p>
<ul id="P7001011952000000000000000009B1B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B1B">
<li id="P7001011952000000000000000009B1C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B1C"><p id="P7001011952000000000000000009B1D" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B1D">The types of messages exchanged, for example, request messages and response messages</p></li>
<li id="P7001011952000000000000000009B1E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B1E"><p id="P7001011952000000000000000009B1F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B1F">The syntax of the various message types, such as the fields in the message and how the fields are delineated</p></li>
<li id="P7001011952000000000000000009B20" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B20"><p id="P7001011952000000000000000009B21" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B21">The semantics of the fields, that is, the meaning of the information in the fields</p></li>
<li id="P7001011952000000000000000009B22" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B22"><p id="P7001011952000000000000000009B23" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B23">Rules for determining when and how a process sends messages and responds to messages</p></li>
</ul>
<p class="continued" id="P7001011952000000000000000009B24" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B24">Some application-layer protocols are specified in RFCs and are therefore in the public domain. For example, the Web’s application-layer protocol, HTTP (the HyperText Transfer Protocol <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003B45" data-foobar="7">[RFC 2616]</a>), is available as an RFC. If a browser developer follows the rules of the HTTP RFC, the browser will be able to retrieve Web pages from any Web server that has also followed the rules of the HTTP RFC. Many other application-layer protocols are proprietary and intentionally not available in the public domain. For example, Skype uses proprietary application-layer protocols.</p>
<p id="P7001011952000000000000000009B25" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B25"><span class="pagebreak" title="97" id="P7001011952000000000000000000A23" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A23" epub:type="pagebreak" role="doc-pagebreak"></span>It is important to distinguish between network applications and application-layer protocols. An application-layer protocol is only one piece of a network application (albeit, a very important piece of the application from our point of view!). Let’s look at a couple of examples. The Web is a client-server application that allows users to obtain documents from Web servers on demand. The Web application consists of many components, including a standard for document formats (that is, HTML), Web browsers (for example, Firefox and Microsoft Internet Explorer), Web servers (for example, Apache and Microsoft servers), and an application-layer protocol. The Web’s application-layer protocol, HTTP, defines the format and sequence of messages exchanged between browser and Web server. Thus, HTTP is only one piece (albeit, an important piece) of the Web application. As another example, an Internet e-mail application also has many components, including mail servers that house user mailboxes; mail clients (such as Microsoft Outlook) that allow users to read and create messages; a standard for defining the structure of an e-mail message; and application-layer protocols that define how messages are passed between servers, how messages are passed between servers and mail clients, and how the contents of message headers are to be interpreted. The principal application-layer protocol for electronic mail is SMTP (Simple Mail Transfer Protocol) <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003BB0" data-foobar="7">[RFC 5321]</a>. Thus, e-mail’s principal application-layer protocol, SMTP, is only one piece (albeit an important piece) of the e-mail application.</p>
</section>
<section id="P7001011952000000000000000000A24" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000A24" class="level2"><header><h1 class="title" id="P7001011952000000000000000009B26" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B26" epub:type="title"><span class="number">2.1.6</span> Network Applications Covered in This Book</h1></header>
<p id="P7001011952000000000000000009B27" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009B27">New public domain and proprietary Internet applications are being developed every day. Rather than covering a large number of Internet applications in an encyclopedic manner, we have chosen to focus on a small number of applications that are both pervasive and important. In this chapter we discuss five important applications: the Web, electronic mail, directory service video streaming, and P2P applications. We first discuss the Web, not only because it is an enormously popular application, but also because its application-layer protocol, HTTP, is straightforward and easy to understand. We then discuss electronic mail, the Internet’s first killer application. E-mail is more complex than the Web in the sense that it makes use of not one but several application-layer protocols. After e-mail, we cover DNS, which provides a directory service for the Internet. Most users do not interact with DNS directly; instead, users invoke DNS indirectly through other applications (including the Web, file transfer, and electronic mail). DNS illustrates nicely how a piece of core network functionality (network-name to network-address translation) can be implemented at the application layer in the Internet. We then discuss P2P file sharing applications, and complete our application study by discussing video streaming on demand, including distributing stored video over content distribution networks. In <a class="xref" href="fileP70010119520000000000000000033D7.xhtml#P70010119520000000000000000033D7" data-foobar="7"><span class="label">Chapter</span> <span class="number">9</span></a>, we’ll cover multimedia applications in more depth, including voice over IP and video conferencing.</p>
</section>
</section></body></html>