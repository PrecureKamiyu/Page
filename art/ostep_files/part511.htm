<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>47.3 Reliable Communication Layers</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part510.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part512.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">47.3 Reliable Communication Layers</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To build a reliable communication layer, we need some new mech- anisms and techniques to handle packet loss. Let us consider a simple example in which a client is sending a message to a server over an unreli- able connection. The first question we must answer: how does the sender know that the receiver has actually received the message?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The technique that we will use is known as an <b>acknowledgment</b>, or <b>ack </b>for short. The idea is simple: the sender sends a message to the re- ceiver; the receiver then sends a short message back to <i>acknowledge </i>its receipt. Figure <span style=" color: #00AEEF;">47.3 </span>depicts the process.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-top: 3pt;padding-left: 54pt;text-indent: 0pt;line-height: 10pt;text-align: center;">Sender</p><p style="text-indent: 0pt;text-align: left;"><span><img width="164" height="15" alt="image" src="Image_654.png"/></span></p><p class="s91" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: center;">[send message]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">[receive ack]  <span><img width="163" height="20" alt="image" src="Image_655.png"/></span></p><p class="s67" style="padding-top: 3pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">Receiver</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 1pt;text-indent: 0pt;line-height: 112%;text-align: left;">[receive message] [send ack]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">Figure 47.3: <b>Message Plus Acknowledgment</b></p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">When the sender receives an acknowledgment of the message, it can then rest assured that the message did indeed receive the original mes- sage. However, what should the sender do if it does not receive an ac- knowledgment?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="83" height="11" alt="image" src="Image_656.png"/></span></p><p class="s67" style="padding-top: 3pt;padding-left: 95pt;text-indent: 10pt;line-height: 106%;text-align: left;">Sender <span class="s233">[send message; keep copy;</span></p><p class="s91" style="padding-left: 97pt;text-indent: 0pt;text-align: left;">set timer]</p><p class="s91" style="padding-top: 5pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">...</p><p class="s91" style="padding-left: 97pt;text-indent: 0pt;text-align: left;">(waiting for ack)</p><p class="s91" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><span><img width="163" height="15" alt="image" src="Image_657.png"/></span></p><p class="s91" style="padding-top: 5pt;padding-left: 97pt;text-indent: -1pt;line-height: 112%;text-align: left;">[timer goes off; set timer/retry]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 97pt;text-indent: -1pt;text-align: left;">[receive ack;  <span><img width="164" height="20" alt="image" src="Image_658.png"/></span><span class="s234"> </span>delete copy/timer off]</p><p class="s67" style="padding-top: 3pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">Receiver</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 1pt;text-indent: 0pt;line-height: 112%;text-align: left;">[receive message] [send ack]</p><p style="padding-top: 5pt;padding-left: 84pt;text-indent: 0pt;text-align: justify;">Figure 47.4: <b>Message Plus Acknowledgment: Dropped Request</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To handle this case, we need an additional mechanism, known as a <b>timeout</b>. When the sender sends a message, the sender now sets a timer to go off after some period of time. If, in that time, no acknowledgment has been received, the sender concludes that the message has been lost. The sender then simply performs a <b>retry </b>of the send, sending the same message again with hopes that this time, it will get through. For this approach to work, the sender must keep a copy of the message around, in case it needs to send it again. The combination of the timeout and the retry have led some to call the approach <b>timeout/retry</b>; pretty clever crowd, those networking types, no? Figure <span style=" color: #00AEEF;">47.4 </span>shows an example.</p><p style="padding-left: 80pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">Unfortunately, timeout/retry in this form is not quite enough. Figure</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;"><span style=" color: #00AEEF;">47.5 </span>shows an example of packet loss which could lead to trouble. In this example, it is not the original message that gets lost, but the acknowledg- ment. From the perspective of the sender, the situation seems the same: no ack was received, and thus a timeout and retry are in order. But from the perspective of the receiver, it is quite different: now the same message has been received twice! While there may be cases where this is OK, in general it is not; imagine what would happen when you are downloading a file and extra packets are repeated inside the download. Thus, when we are aiming for a reliable message layer, we also usually want to guarantee that each message is received <b>exactly once </b>by the receiver.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To enable the receiver to detect duplicate message transmission, the sender has to identify each message in some unique way, and the receiver needs some way to track whether it has already seen each message be- fore. When the receiver sees a duplicate transmission, it simply acks the message, but (critically) does <i>not </i>pass the message to the application that receives the data. Thus, the sender receives the ack but the message is not received twice, preserving the exactly-once semantics mentioned above.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">There are myriad ways to detect duplicate messages. For example, the sender could generate a unique ID for each message; the receiver could track every ID it has ever seen. This approach could work, but it is pro- hibitively costly, requiring unbounded memory to track all IDs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="164" height="9" alt="image" src="Image_659.png"/></span></p><p class="s67" style="padding-top: 3pt;padding-left: 67pt;text-indent: 10pt;line-height: 106%;text-align: left;">Sender <span class="s233">[send message; keep copy;</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="102" height="11" alt="image" src="Image_660.png"/></span></p><p class="s91" style="padding-left: 69pt;text-indent: 0pt;text-align: left;">set timer]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">...</p><p class="s91" style="padding-left: 69pt;text-indent: 0pt;text-align: left;">(waiting for ack)</p><p class="s91" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="164" height="15" alt="image" src="Image_661.png"/></span></p><p class="s91" style="padding-left: 69pt;text-indent: -1pt;line-height: 112%;text-align: left;">[timer goes off; set timer/retry]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-top: 4pt;padding-left: 69pt;text-indent: -1pt;text-align: left;">[receive ack;  <span><img width="163" height="20" alt="image" src="Image_662.png"/></span><span class="s234"> </span>delete copy/timer off]</p><p class="s67" style="padding-top: 3pt;padding-left: 1pt;text-indent: 10pt;text-align: left;">Receiver</p><p class="s91" style="padding-top: 4pt;padding-left: 1pt;text-indent: 0pt;line-height: 112%;text-align: left;">[receive message] [send ack]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 1pt;text-indent: 0pt;line-height: 112%;text-align: left;">[receive message] [send ack]</p><p style="padding-top: 5pt;padding-left: 61pt;text-indent: 0pt;text-align: left;">Figure 47.5: <b>Message Plus Acknowledgment: Dropped Reply</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A simpler approach, requiring little memory, solves this problem, and the mechanism is known as a <b>sequence counter</b>. With a sequence counter, the sender and receiver agree upon a start value (e.g., 1) for a counter that each side will maintain. Whenever a message is sent, the current value of the counter is sent along with the message; this counter value (<span class="s43">N </span>) serves as an ID for the message. After the message is sent, the sender then increments the value (to <span class="s43">N </span><span class="s44">+ 1</span>).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The receiver uses its counter value as the expected value for the ID of the incoming message from that sender. If the ID of a received mes- sage (<span class="s43">N </span>) matches the receiver’s counter (also <span class="s43">N </span>), it acks the message and passes it up to the application; in this case, the receiver concludes this is the first time this message has been received. The receiver then incre- ments its counter (to <span class="s43">N </span><span class="s44">+ 1</span>), and waits for the next message.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">If the ack is lost, the sender will timeout and re-send message <span class="s43">N </span>. This time, the receiver’s counter is higher (<span class="s43">N </span><span class="s44">+ 1</span>), and thus the receiver knows it has already received this message. Thus it acks the message but does <i>not </i>pass it up to the application. In this simple manner, sequence counters can be used to avoid duplicates.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The most commonly used reliable communication layer is known as <b>TCP/IP</b>, or just <b>TCP </b>for short. TCP has a great deal more sophistication than we describe above, including machinery to handle congestion in the network [VJ90], multiple outstanding requests, and hundreds of other small tweaks and optimizations. Read more about it if you’re curious; better yet, take a networking course and learn that material well.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part510.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part512.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
