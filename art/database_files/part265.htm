<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>14.5  Hash Indices</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part264.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part266.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">14.5  <span style=" color: #00AEEF;">Hash Indices</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Hashing is a widely used technique for building indices in main memory; such indices may be transiently created to process a join operation (as we will see in Section 15.5.5) or may be a permanent structure in a main memory database. Hashing has also been used as a way of organizing records in a ﬁle, although hash ﬁle organizations are not very widely used. We initially consider only in-memory hash indices, and we consider disk-based hashing later in this section.</p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">14.5 <span style=" color: #00AEEF;">Hash Indices  </span><span class="s164">659</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In our description of hashing, we shall use the term <span class="s63">bucket </span>to denote a unit of storage that can store one or more records. For in-memory hash indices, a bucket could be a linked list of index entries or records. For disk-based indices, a bucket would be a linked list of disk blocks. In a <span class="s63">hash ﬁle organization</span>, instead of record pointers, buckets store the actual records; such structures only make sense with disk-resident data. The rest of our description does not depend on whether the buckets store record pointers or actual records.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Formally, let <i>K </i>denote the set of all search-key values, and let <i>B </i>denote the set of all bucket addresses. A <span class="s63">hash function </span><i>h </i>is a function from <i>K </i>to <i>B</i>. Let <i>h </i>denote a hash function. With in-memory hash indices, the set of buckets is simply an array of pointers, with the <i>i</i>th bucket at oﬀset <i>i</i>. Each pointer stores the head of a linked list containing the entries in that bucket.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 87%;text-align: justify;">To insert a record with search key <i>K</i><span class="s97">i</span>, we compute <i>h</i>(<i>K</i><span class="s97">i</span>), which gives the address of the bucket for that record. We add the index entry for the record to the list at oﬀset</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;"><i>i</i>. Note that there are other variants of hash indices that handle the case of multiple records in a bucket diﬀerently; the form described here is the most widely used variant and is called <span class="s63">overﬂow chaining</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 13pt;text-align: right;">Hash indexing using overﬂow chaining is also called <span class="s63">closed addressing </span>(or, less commonly, <span class="s63">closed hashing</span>). An alternative hashing scheme called open addressing is used in some applications, but is not suitable for most database indexing applications since open addressing does not support deletes eﬃciently. We do not consider it further. Hash indices eﬃciently support equality queries on search keys. To perform a lookup on a search-key value <i>K</i><span class="s145">i</span>, we simply compute <i>h</i>(<i>K</i><span class="s145">i</span>), then search the bucket with that address. Suppose that two search keys, <i>K</i><span class="s98">5</span> and <i>K</i><span class="s98">7</span>, have the same hash value; that</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 87%;text-align: right;"><span class="p">is, </span>h<span class="p">(</span>K<span class="s130">5</span><span class="s94">) </span><span class="s15">= </span>h<span class="p">(</span>K<span class="s130">7</span><span class="s94">). If we perform a lookup on </span>K<span class="s130">5</span><span class="s94">, the bucket </span>h<span class="p">(</span>K<span class="s130">5</span><span class="s94">) contains records with search-key values </span>K<span class="s98">5</span><span class="p"> and records with search-key values </span>K<span class="s98">7</span><span class="p">. Thus, we have to check</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">the search-key value of every record in the bucket to verify that the record is one that we want.</p><p class="s13" style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 88%;text-align: justify;"><span class="p">Unlike B</span><span class="s181">+</span><span class="p">-tree indices, hash indices do not support range queries; for example, a query that wishes to retrieve all search key values </span>v <span class="p">such that </span>l <span class="s86">≤ </span>v <span class="s86">≤ </span>u <span class="p">cannot be eﬃciently answered using a hash index.</span></p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 13pt;text-align: justify;">Deletion is equally straightforward. If the search-key value of the record to be deleted is <i>K</i><span class="s97">i</span>, we compute <i>h</i>(<i>K</i><span class="s97">i</span>), then search the corresponding bucket for that record and delete the record from the bucket. With a linked list representation, deletion from the linked list is straightforward.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In a disk-based hash index, when we insert a record, we locate the bucket by using hashing on the search key, as described earlier. Assume for now that there is space in the bucket to store the record. Then, the record is stored in that bucket. If the bucket does not have enough space, a <span class="s63">bucket overﬂow </span>is said to occur. We handle bucket overﬂow by using <span class="s63">overﬂow buckets</span>. If a record must be inserted into a bucket <i>b</i>, and <i>b </i>is already full, the system provides an overﬂow bucket for <i>b </i>and inserts the record into the overﬂow bucket. If the overﬂow bucket is also full, the system provides another overﬂow bucket, and so on. All the overﬂow buckets of a given bucket are chained together in a linked</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="89" height="59" alt="image" src="Image_2698.png"/></span></p><p class="s33" style="padding-top: 4pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">bucket 0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="322" height="59" alt="image" src="Image_2699.png"/></span></p><p class="s33" style="padding-top: 7pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">bucket 1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="89" height="59" alt="image" src="Image_2700.png"/></span></p><p class="s33" style="padding-left: 285pt;text-indent: 0pt;text-align: left;">overﬂow buckets for bucket 1</p><p class="s33" style="padding-top: 8pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">bucket 2</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="89" height="59" alt="image" src="Image_2701.png"/></span></p><p class="s33" style="padding-top: 7pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">bucket 3</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 14.25 <span class="s74">Overflow chaining in a disk-based hash structure.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">list, as in Figure 14.25. With overﬂow chaining, given search key <i>k</i>, the lookup algorithm must then search not only bucket <i>h</i>(<i>k</i>), but also the overﬂow buckets linked from bucket <i>h</i>(<i>k</i>).</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Bucket overﬂow can occur if there are insuﬃcient buckets for the given number of records. If the number of records that are indexed is known ahead of time, the required number of buckets can be allocated; we will shortly see how to deal with situations where the number of records becomes signiﬁcantly more than what was initially antic- ipated. Bucket overﬂow can also occur if some buckets are assigned more records than are others, resulting in one bucket overﬂowing even when other buckets still have a lot of free space.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Such <span class="s63">skew </span>in the distribution of records can occur if multiple records may have the same search key. But even if there is only one record per search key, skew may occur if the chosen hash function results in nonuniform distribution of search keys. This chance of this problem can be minimized by choosing hash functions carefully, to ensure the distribution of keys across buckets is uniform and random. Nevertheless, some skew may occur.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">So that the probability of bucket overﬂow is reduced, the number of buckets is chosen to be (<i>n</i><span class="s97">r </span><span class="s15">∕</span><i>f</i><span class="s97">r</span>) <span class="s15">∗ </span>(1 <span class="s15">+ </span><i>d</i>), where <i>n</i><span class="s97">r </span>denotes the number of records, <i>f</i><span class="s97">r </span>denotes the</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 65%;text-align: justify;">number of records per bucket, <i>d </i>is a fudge factor, typically around 0<span class="s83">.</span>2. With a fudge factor of 0<span class="s83">.</span>2, about 20 percent of the space in the buckets will be empty. But the beneﬁt is that the probability of overﬂow is reduced.</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Despite allocation of a few more buckets than required, bucket overﬂow can still occur, especially if the number of records increases beyond what was initially expected.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;"><a name="bookmark281">Hash indexing as described above, where the number of buckets is ﬁxed when the index is created, is called </a><span class="s63">static hashing</span>. One of the problems with static hashing is that we need to know how many records are going to be stored in the index. If over time a large number of records are added, resulting in far more records than buckets, lookups would have to search through a large number of records stored in a single bucket, or in one or more overﬂow buckets, and would thus become ineﬃcient.<a name="bookmark314">&zwnj;</a></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To handle this problem, the hash index can be rebuilt with an increased number of buckets. For example, if the number of records becomes twice the number of buckets, the index can be rebuilt with twice as many buckets as before. However, rebuilding the index has the drawback that it can take a long time if the relations are large, causing disruption of normal processing. Several schemes have been proposed that allow the number of buckets to be increased in a more incremental fashion. Such schemes are called <span class="s63">dynamic hashing </span>techniques; the <i>linear hashing </i>technique and the <i>extendable hashing </i>technique are two such schemes; see Section 24.5 for further details of these techniques.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part264.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part266.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
