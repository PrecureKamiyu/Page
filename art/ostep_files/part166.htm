<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Tracking The Size Of Allocated Regions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part165.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part167.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Tracking The Size Of Allocated Regions</p><p class="s41" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 85%;text-align: justify;"><span class="p">You might have noticed that the interface to </span>free(void <span class="s86">*</span>ptr) <span class="p">does not take a size parameter; thus it is assumed that given a pointer, the malloc library can quickly determine the size of the region of memory being freed and thus incorporate the space back into the free list.</span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To accomplish this task, most allocators store a little bit of extra infor- mation in a <b>header </b>block which is kept in memory, usually just before the handed-out chunk of memory. Let’s look at an example again (Fig- ure <span style=" color: #00AEEF;">17.1</span>). In this example, we are examining an allocated block of size 20 bytes, pointed to by <span class="s41">ptr</span>; imagine the user called <span class="s41">malloc() </span>and stored the results in <span class="s41">ptr</span>, e.g., <span class="s41">ptr = malloc(20);</span>.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The header minimally contains the size of the allocated region (in this case, 20); it may also contain additional pointers to speed up dealloca- tion, a magic number to provide additional integrity checking, and other information. Let’s assume a simple header which contains the size of the region and a magic number, like this:</p><p class="s38" style="padding-top: 6pt;padding-left: 57pt;text-indent: -16pt;text-align: left;">typedef struct <span class="s75">&nbsp;</span>header_t { int size;</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">int magic;</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">} header_t;</p><p style="padding-top: 5pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">The example above would look like what you see in Figure <span style=" color: #00AEEF;">17.2</span>. When</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: left;">the user calls <span class="s41">free(ptr)</span>, the library then uses simple pointer arithmetic to figure out where the header begins:</p><p class="s38" style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">void free(void <span class="s39">*</span>ptr) {</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;line-height: 79%;text-align: left;">header_t <span class="s39">*</span>hptr = (void <span class="s39">*</span>)ptr - sizeof(header_t);</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">After obtaining such a pointer to the header, the library can easily de- termine whether the magic number matches the expected value as a san- ity check (<span class="s41">assert(hptr-&gt;magic == 1234567)</span>) and calculate the to- tal size of the newly-freed region via simple math (i.e., adding the size of the header to size of the region). Note the small but critical detail in the last sentence: the size of the free region is the size of the header plus the size of the space allocated to the user. Thus, when a user requests <span class="s43">N </span>bytes of memory, the library does not search for a free chunk of size <span class="s43">N </span>; rather, it searches for a free chunk of size <span class="s43">N </span>plus the size of the header.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part165.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part167.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
