<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>7.8   Atomic Domains and First Normal Form</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part158.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part160.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">7.8   <span style=" color: #00AEEF;">Atomic Domains and First Normal Form</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2059.png"/></span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The <span class="s44">E-R </span>model allows entity sets and relationship sets to have attributes that have some degree of substructure. Speciﬁcally, it allows multivalued attributes such as <i>phone number </i>in Figure 6.8 and composite attributes (such as an attribute <i>address </i>with com- ponent attributes <i>street</i>, <i>city</i>, and <i>state</i>). When we create tables from <span class="s44">E-R </span>designs that contain these types of attributes, we eliminate this substructure. For composite at- tributes, we let each component be an attribute in its own right. For multivalued at- tributes, we create one tuple for each item in a multivalued set.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In the relational model, we formalize this idea that attributes do not have any sub- structure. A domain is <span class="s63">atomic </span>if elements of the domain are considered to be indivisible units. We say that a relation schema <i>R </i>is in <span class="s63">first normal form </span>(<span class="s64">1NF</span>) if the domains of all attributes of <i>R </i>are atomic.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A set of names is an example of a non-atomic value. For example, if the schema of a relation <i>employee </i>included an attribute <i>children </i>whose domain elements are sets of names, the schema would not be in ﬁrst normal form.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">Composite attributes, such as an attribute <i>address </i>with component attributes <i>street</i></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">and <i>city </i>also have non-atomic domains.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Integers are assumed to be atomic, so the set of integers is an atomic domain; however, the set of all sets of integers is a non-atomic domain. The distinction is that we do not normally consider integers to have subparts, but we consider sets of integers to have subparts — namely, the integers making up the set. But the important issue is not what the domain itself is, but rather how we use domain elements in our database. The domain of all integers would be non-atomic if we considered each integer to be an ordered list of digits.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As a practical illustration of this point, consider an organization that assigns em- ployees identiﬁcation numbers of the following form: The ﬁrst two letters specify the department and the remaining four digits are a unique number within the department for the employee. Examples of such numbers would be “CS001” and “EE1127”. Such identiﬁcation numbers can be divided into smaller units and are therefore non-atomic. If a relation schema had an attribute whose domain consists of identiﬁcation numbers encoded as above, the schema would not be in ﬁrst normal form.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When such identiﬁcation numbers are used, the department of an employee can be found by writing code that breaks up the structure of an identiﬁcation number. Doing so requires extra programming, and information gets encoded in the application program rather than in the database. Further problems arise if such identiﬁcation numbers are used as primary keys: When an employee changes departments, the employee’s identi- ﬁcation number must be changed everywhere it occurs, which can be a diﬃcult task, or the code that interprets the number would give a wrong result.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;"><a name="bookmark142">From this discussion, it may appear that our use of course identiﬁers such as “CS- 101”, where “CS” indicates the Computer Science department, means that the domain of course identiﬁers is not atomic. Such a domain is not atomic as far as humans using the system are concerned. However, the database application still treats the domain as atomic, as long as it does not attempt to split the identiﬁer and interpret parts of the identiﬁer as a department abbreviation. The </a><i>course </i>schema stores the department name as a separate attribute, and the database application can use this attribute value to ﬁnd the department of a course, instead of interpreting particular characters of the course identiﬁer. Thus, our university schema can be considered to be in ﬁrst normal form.<a name="bookmark170">&zwnj;</a></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The use of set-valued attributes can lead to designs with redundant storage of data, which in turn can result in inconsistencies. For instance, instead of having the relation- ship between instructors and sections being represented as a separate relation <i>teaches</i>, a database designer may be tempted to store a set of course section identiﬁers with each instructor and a set of instructor identiﬁers with each section. (The primary keys of <i>section </i>and <i>instructor </i>are used as identiﬁers.) Whenever data pertaining to which instructor teaches which section is changed, the update has to be performed at two places: in the set of instructors for the section, and in the set of sections for the instruc- tor. Failure to perform both updates can leave the database in an inconsistent state. Keeping only one of these sets would avoid repeated information; however keeping only one of these would complicate some queries, and it is unclear which of the two it would be better to retain.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Some types of non-atomic values can be useful, although they should be used with care. For example, composite-valued attributes are often useful, and set-valued attributes are also useful in many cases, which is why both are supported in the <span class="s44">E- R </span>model. In many domains where entities have a complex structure, forcing a ﬁrst normal form representation represents an unnecessary burden on the application pro- grammer, who has to write code to convert data into atomic form. There is also the runtime overhead of converting data back and forth from the atomic form. Support for non-atomic values can thus be very useful in such domains. In fact, modern database systems do support many types of non-atomic values, as we shall see in Chapter 29 restrict ourselves to relations in ﬁrst normal form, and thus all domains are atomic.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part158.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part160.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
