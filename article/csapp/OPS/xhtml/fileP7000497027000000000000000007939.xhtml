<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>10.4 Reading and Writing Files</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000007939" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000046428" data-uri="chapter10.xhtml#P7000497027000000000000000046428" epub:type="title"><span class="pcalibre label pcalibre1">10.4 </span>Reading and Writing Files</h1></header>
<p id="P7000497027000000000000000046429" data-uri="chapter10.xhtml#P7000497027000000000000000046429" class="pcalibre1 pcalibre calibre2">Applications perform input and output by calling the <code id="P700049702700000000000000004642A" data-uri="chapter10.xhtml#P700049702700000000000000004642A" class="pcalibre1 calibre8 pcalibre">read</code> and <code id="P700049702700000000000000004642B" data-uri="chapter10.xhtml#P700049702700000000000000004642B" class="pcalibre1 calibre8 pcalibre">write</code> functions, respectively.</p>
<pre id="P700049702700000000000000004642C" data-uri="chapter10.xhtml#P700049702700000000000000004642C" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004642D" data-uri="chapter10.xhtml#P700049702700000000000000004642D" class="calibre10 pcalibre pcalibre1">
#include &lt;unistd.h&gt;
ssize_t read(int fd, void *buf, size_t n);
					Returns: number of bytes read if OK, 0 on EOF, −1 on error
ssize_t write(int fd, const void *buf, size_t n);
					Returns: number of bytes written if OK, −1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004642E" data-uri="chapter10.xhtml#P700049702700000000000000004642E">The <code id="P700049702700000000000000004642F" data-uri="chapter10.xhtml#P700049702700000000000000004642F" class="pcalibre1 calibre8 pcalibre">read</code> function copies at most <code id="P7000497027000000000000000046430" data-uri="chapter10.xhtml#P7000497027000000000000000046430" class="pcalibre1 calibre8 pcalibre">n</code> bytes from the current file position of descriptor <code id="P7000497027000000000000000046431" data-uri="chapter10.xhtml#P7000497027000000000000000046431" class="pcalibre1 calibre8 pcalibre">fd</code> to memory location <code id="P7000497027000000000000000046432" data-uri="chapter10.xhtml#P7000497027000000000000000046432" class="pcalibre1 calibre8 pcalibre">buf</code>. A return value of −1 indicates an error, and a return value of 0 indicates EOF. Otherwise, the return value indicates the number of bytes that were actually transferred.</p>
<p id="P7000497027000000000000000046433" data-uri="chapter10.xhtml#P7000497027000000000000000046433" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046434" data-uri="chapter10.xhtml#P7000497027000000000000000046434" class="pcalibre1 calibre8 pcalibre">write</code> function copies at most <code id="P7000497027000000000000000046435" data-uri="chapter10.xhtml#P7000497027000000000000000046435" class="pcalibre1 calibre8 pcalibre">n</code> bytes from memory location <code id="P7000497027000000000000000046436" data-uri="chapter10.xhtml#P7000497027000000000000000046436" class="pcalibre1 calibre8 pcalibre">buf</code> to the current file position of descriptor <code id="P7000497027000000000000000046437" data-uri="chapter10.xhtml#P7000497027000000000000000046437" class="pcalibre1 calibre8 pcalibre">fd</code>. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P700049702700000000000000000795F"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">10.3</span></a> shows a program that uses <code id="P7000497027000000000000000046438" data-uri="chapter10.xhtml#P7000497027000000000000000046438" class="pcalibre1 calibre8 pcalibre">read</code> and <code id="P7000497027000000000000000046439" data-uri="chapter10.xhtml#P7000497027000000000000000046439" class="pcalibre1 calibre8 pcalibre">write</code> calls to copy the standard input to the standard output, 1 byte at a time.</p>
<p id="P700049702700000000000000004643A" data-uri="chapter10.xhtml#P700049702700000000000000004643A" class="pcalibre1 pcalibre calibre2">Applications can explicitly modify the current file position by calling the <code id="P700049702700000000000000004643B" data-uri="chapter10.xhtml#P700049702700000000000000004643B" class="pcalibre1 calibre8 pcalibre">lseek</code> function, which is beyond our scope.</p>
<p id="P700049702700000000000000004643C" data-uri="chapter10.xhtml#P700049702700000000000000004643C" class="pcalibre1 pcalibre calibre2">In some situations, <code id="P700049702700000000000000004643D" data-uri="chapter10.xhtml#P700049702700000000000000004643D" class="pcalibre1 calibre8 pcalibre">read</code> and <code id="P700049702700000000000000004643E" data-uri="chapter10.xhtml#P700049702700000000000000004643E" class="pcalibre1 calibre8 pcalibre">write</code> transfer fewer bytes than the application requests. Such <i class="calibre5 pcalibre pcalibre1">short counts</i> do <i class="calibre5 pcalibre pcalibre1">not</i> indicate an error. They occur for a number of reasons:</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000007951" data-uri="chapter10.xhtml#P7000497027000000000000000007951"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P700049702700000000000000004643F" data-uri="chapter10.xhtml#P700049702700000000000000004643F" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007953" title="896" data-uri="chapter10.xhtml#P7000497027000000000000000007953" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>What's the difference between <code id="P7000497027000000000000000046440" data-uri="chapter10.xhtml#P7000497027000000000000000046440" class="calibre55 pcalibre pcalibre1">ssize_t</code> and <code id="P7000497027000000000000000046441" data-uri="chapter10.xhtml#P7000497027000000000000000046441" class="calibre55 pcalibre pcalibre1">size_t?</code></h1></header>
<p id="P7000497027000000000000000046442" data-uri="chapter10.xhtml#P7000497027000000000000000046442" class="pcalibre calibre3 pcalibre1">You might have noticed that the <code id="P7000497027000000000000000046443" data-uri="chapter10.xhtml#P7000497027000000000000000046443" class="pcalibre1 calibre8 pcalibre">read</code> function has a <code id="P7000497027000000000000000046444" data-uri="chapter10.xhtml#P7000497027000000000000000046444" class="pcalibre1 calibre8 pcalibre">size_t</code> input argument and an <code id="P7000497027000000000000000046445" data-uri="chapter10.xhtml#P7000497027000000000000000046445" class="pcalibre1 calibre8 pcalibre">ssize_t</code> return value. So what's the difference between these two types? On x86-64 systems, a <code id="P7000497027000000000000000046446" data-uri="chapter10.xhtml#P7000497027000000000000000046446" class="pcalibre1 calibre8 pcalibre">size_t</code> is defined as an <code id="P7000497027000000000000000046447" data-uri="chapter10.xhtml#P7000497027000000000000000046447" class="pcalibre1 calibre8 pcalibre">unsigned long</code>, and an <code id="P7000497027000000000000000046448" data-uri="chapter10.xhtml#P7000497027000000000000000046448" class="pcalibre1 calibre8 pcalibre">ssize_t</code> (<i class="calibre5 pcalibre pcalibre1">signed size</i>) is defined as a <code id="P7000497027000000000000000046449" data-uri="chapter10.xhtml#P7000497027000000000000000046449" class="pcalibre1 calibre8 pcalibre">long</code>. The read function returns a signed size rather than an unsigned size because it must return a −1 on error. Interestingly, the possibility of returning a single −1 reduces the maximum size of a <code id="P700049702700000000000000004644A" data-uri="chapter10.xhtml#P700049702700000000000000004644A" class="pcalibre1 calibre8 pcalibre">read</code> by a factor of 2.</p>
</aside>
<figure class="pcalibre5 figure pcalibre" id="P700049702700000000000000000795F" data-uri="chapter10.xhtml#P700049702700000000000000000795F">
<pre id="P700049702700000000000000004644B" data-uri="chapter10.xhtml#P700049702700000000000000004644B" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004644C" data-uri="chapter10.xhtml#P700049702700000000000000004644C" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	
3	int main(void)
4	{
5		char c;
6	
7		while(Read(STDIN_FILENO, &amp;c, 1) != 0)
8			Write(STDOUT_FILENO, &amp;c, 1);
9		exit(0);
10	}
</code></pre>

<figcaption id="P700049702700000000000000004644D" data-uri="chapter10.xhtml#P700049702700000000000000004644D" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004644E" data-uri="chapter10.xhtml#P700049702700000000000000004644E" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">10.3 </span>Using read and write to copy standard input to standard output 1 byte at a time.</h1></header>
</figcaption>
</figure>
<ul class="pcalibre ul_none pcalibre1" id="P700049702700000000000000004644F" data-uri="chapter10.xhtml#P700049702700000000000000004644F">
<li id="P7000497027000000000000000046450" data-uri="chapter10.xhtml#P7000497027000000000000000046450" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046451" data-uri="chapter10.xhtml#P7000497027000000000000000046451" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Encountering EOF on reads. </span>Suppose that we are ready to read from a file that contains only 20 more bytes from the current file position and that we are reading the file in 50-byte chunks. Then the next read will return a short count of 20, and the <code id="P7000497027000000000000000046452" data-uri="chapter10.xhtml#P7000497027000000000000000046452" class="pcalibre1 calibre8 pcalibre">read</code> after that will signal EOF by returning a short count of 0.</p></li>
<li id="P7000497027000000000000000046453" data-uri="chapter10.xhtml#P7000497027000000000000000046453" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046454" data-uri="chapter10.xhtml#P7000497027000000000000000046454" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Reading text lines from a terminal. </span>If the open file is associated with a terminal (i.e., a keyboard and display), then each <code id="P7000497027000000000000000046455" data-uri="chapter10.xhtml#P7000497027000000000000000046455" class="pcalibre1 calibre8 pcalibre">read</code> function will transfer one text line at a time, returning a short count equal to the size of the text line.</p></li>
<li id="P7000497027000000000000000046456" data-uri="chapter10.xhtml#P7000497027000000000000000046456" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046457" data-uri="chapter10.xhtml#P7000497027000000000000000046457" class="calibre13 pcalibre pcalibre1"><span class="pcalibre leadin pcalibre1">Reading and writing network sockets. </span>If the open file corresponds to a network socket (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007CC1.xhtml#P7000497027000000000000000007CC1"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">11.4</span></a>), then internal buffering constraints and long network delays can cause <code id="P7000497027000000000000000046458" data-uri="chapter10.xhtml#P7000497027000000000000000046458" class="pcalibre1 calibre8 pcalibre">read</code> and <code id="P7000497027000000000000000046459" data-uri="chapter10.xhtml#P7000497027000000000000000046459" class="pcalibre1 calibre8 pcalibre">write</code> to return short counts. Short counts can also occur when you call <code id="P700049702700000000000000004645A" data-uri="chapter10.xhtml#P700049702700000000000000004645A" class="pcalibre1 calibre8 pcalibre">read</code> and <code id="P700049702700000000000000004645B" data-uri="chapter10.xhtml#P700049702700000000000000004645B" class="pcalibre1 calibre8 pcalibre">write</code> on a Linux <i class="calibre5 pcalibre pcalibre1">pipe</i>, an interprocess communication mechanism that is beyond our scope.</p></li>
</ul>
<p id="P700049702700000000000000004645C" data-uri="chapter10.xhtml#P700049702700000000000000004645C" class="pcalibre1 pcalibre calibre2">In practice, you will never encounter short counts when you read from disk files except on EOF, and you will never encounter short counts when you write to disk files. However, if you want to build robust (reliable) network applications <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007972" title="897" data-uri="chapter10.xhtml#P7000497027000000000000000007972" epub:type="pagebreak"></span>such as Web servers, then you must deal with short counts by repeatedly calling <code id="P700049702700000000000000004645D" data-uri="chapter10.xhtml#P700049702700000000000000004645D" class="pcalibre1 calibre8 pcalibre">read</code> and <code id="P700049702700000000000000004645E" data-uri="chapter10.xhtml#P700049702700000000000000004645E" class="pcalibre1 calibre8 pcalibre">write</code> until all requested bytes have been transferred.</p>
</section></body></html>
