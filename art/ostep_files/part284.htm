<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.5 Controlling Interrupts</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part283.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part285.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">28.5 Controlling Interrupts</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One of the earliest solutions used to provide mutual exclusion was to disable interrupts for critical sections; this solution was invented for single-processor systems. The code would look like this:</p><p class="s37" style="padding-top: 3pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">void lock() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2    <span class="s38">DisableInterrupts();</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">}</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38">void unlock() {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5    <span class="s38">EnableInterrupts();</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6  <span class="s38">}</span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Assume we are running on such a single-processor system. By turn- ing off interrupts (using some kind of special hardware instruction) be- fore entering a critical section, we ensure that the code inside the critical section will <i>not </i>be interrupted, and thus will execute as if it were atomic. When we are finished, we re-enable interrupts (again, via a hardware in- struction) and thus the program proceeds as usual.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The main positive of this approach is its simplicity. You certainly don’t have to scratch your head too hard to figure out why this works. Without interruption, a thread can be sure that the code it executes will execute and that no other thread will interfere with it.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: right;">The negatives, unfortunately, are many. First, this approach requires us to allow any calling thread to perform a <i>privileged </i>operation (turning interrupts on and off), and thus <i>trust </i>that this facility is not abused. As you already know, any time we are required to trust an arbitrary pro- gram, we are probably in trouble. Here, the trouble manifests in numer- ous ways: a greedy program could call <span class="s41">lock() </span>at the beginning of its execution and thus monopolize the processor; worse, an errant or mali- cious program could call <span class="s41">lock() </span>and go into an endless loop. In this latter case, the OS never regains control of the system, and there is only one recourse: restart the system. Using interrupt disabling as a general- purpose synchronization solution requires too much trust in applications. Second, the approach does not work on multiprocessors. If multiple threads are running on different CPUs, and each try to enter the same critical section, it does not matter whether interrupts are disabled; threads will be able to run on other processors, and thus could enter the critical section. As multiprocessors are now commonplace, our general solution</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">will have to do better than this.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Third, and probably least important, this approach can be inefficient. Compared to normal instruction execution, code that masks or unmasks interrupts tends to be executed slowly by modern CPUs.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">For these reasons, turning off interrupts is only used in limited con- texts as a mutual-exclusion primitive. For example, in some cases an operating system itself will sometimes use interrupt masking to guaran- tee atomicity when accessing its own data structures, or at least to pre- vent certain messy interrupt handling situations from arising. This usage makes sense, as the trust issue disappears inside the OS, which always trusts itself to perform privileged operations anyhow.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="408" height="495" alt="image" src="Image_362.png"/></span></p><p class="s27" style="padding-top: 2pt;padding-left: 80pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>D<span class="s45">EKKER</span>’<span class="s45">S AND </span>P<span class="s45">ETERSON</span>’<span class="s45">S </span>A<span class="s45">LGORITHMS</span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In the 1960’s, Dijkstra posed the concurrency problem to his friends, and one of them, a mathematician named Theodorus Jozef Dekker, came up with a solution [D68]. Unlike the solutions we discuss here, which use special hardware instructions and even OS support, Dekker’s approach uses just loads and stores (assuming they are atomic with respect to each other, which was true on early hardware).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Dekker’s approach was later refined by Peterson [P81] (and thus “Pe- terson’s algorithm”), shown here. Once again, just loads and stores are used, and the idea is to ensure that two threads never enter a critical sec- tion at the same time. Here is Peterson’s algorithm (for two threads); see if you can understand it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">int flag[2]; int turn;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">void init() {</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">flag[0] = flag[1] = 0;  // 1-&gt;thread wants to grab lock turn = 0;       // whose turn? (thread 0 or 1?)</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">void lock() {</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">flag[self] = 1;     // self: thread ID of caller turn = 1 - self;    // make it other thread’s turn while ((flag[1-self] == 1) &amp;&amp; (turn == 1 - self))</p><p class="s38" style="padding-left: 74pt;text-indent: 0pt;line-height: 8pt;text-align: left;">; // spin-wait</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">void unlock() {</p><p class="s38" style="padding-left: 57pt;text-indent: 0pt;text-align: left;">flag[self] = 0;    // simply undo your intent</p><p class="s38" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">For some reason, developing locks that work without special hard- ware support became all the rage for a while, giving theory-types a lot of problems to work on. Of course, this all became quite useless when people realized it is much easier to assume a little hardware support (and indeed that support had been around from the very earliest days of multi- processing). Further, algorithms like the ones above don’t work on mod- ern hardware (due to relaxed memory consistency models), thus making them even less useful than they were before. Yet more research relegated to the dustbin of history...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part283.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part285.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
