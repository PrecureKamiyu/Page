<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 21" epub:type="pagebreak" id="page_21" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 2: Mutual exclusion</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter covers classical mutual exclusion algorithms that work by reading and writing shared memory. Although these algorithms are not used in practice, they introduce the kinds of algorithmic and correctness issues that arise in every area of synchronization. This chapter also includes an impossibility proof that demonstrates the limitations of solutions to mutual exclusion using read–write memory, and helps motivate the real-world mutual exclusion algorithms that appear in later chapters.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">mutual exclusion; critical section; lock; deadlock-free; starvation-free; first-come-first-served; Bakery algorithm; bounded timestamps; impossibility proof</p></section></header><p class="textfl" id="p0010">Mutual exclusion is perhaps the most prevalent form of coordination in multiprocessor programming. This chapter covers classical mutual exclusion algorithms that work by reading and writing shared memory. Although these algorithms are not used in practice, we study them because they provide an ideal introduction to the kinds of algorithmic and correctness issues that arise in every area of synchronization. The chapter also provides an impossibility proof. This proof teaches us the limitations of solutions to mutual exclusion that work by reading and writing shared memory, which helps to motivate the real-world mutual exclusion algorithms that appear in later chapters. This chapter is one of the few that contains proofs of algorithms. Though the reader should feel free to skip these proofs, it is helpful to understand the kind of reasoning they present, because we can use the same approach to reason about the practical algorithms considered in later chapters.</p><section><h2 class="h1hd" id="s0010"><a id="st0020"/>2.1 Time and events</h2><p class="textfl" id="p0015">Reasoning about concurrent computation is mostly reasoning about time. Sometimes we want things to happen simultaneously, and sometimes we want them to happen at different times. To reason about complicated conditions involving how multiple time intervals can overlap, or how they cannot, we need a simple but unambiguous language to talk about events and durations in time. Everyday English is too ambiguous and imprecise. Instead, we introduce a simple vocabulary and notation to describe how concurrent threads behave in time.</p><p class="text" id="p0020">In 1687, Isaac Newton wrote, “Absolute, True, and Mathematical Time, of itself, and from its own nature flows equably without relation to any thing external.” We endorse his notion of time, if not his prose style. Threads share a common time (though not necessarily a common clock). A thread is a <i>state machine</i>, and its state transitions are called <i>events</i>.</p><p class="text" id="p0025">Events are <i>instantaneous</i>: they occur at a single instant of time. It is convenient to require that events are never simultaneous: Distinct events occur at distinct times. (As a practical matter, if we are unsure about the order of two events that happen very close in time, then either order will do.) A thread <i>A</i> produces a sequence of events <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000112/si1.png" style="vertical-align:middle" width="64"/></span>. Programs typically contain loops, so a single program statement can produce many events. One event <i>a precedes</i> another event <i>b</i>, written <span class="hiddenClass"><mml:math><mml:mi>a</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>b</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si2.png" style="vertical-align:middle" width="44"/></span>, if <i>a</i> occurs at an earlier time. The <i>precedence</i> relation → is a total order on events.<span aria-label="Page 22" epub:type="pagebreak" id="page_22" role="doc-pagebreak"/></p><p class="text" id="p0030">Let <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si3.png" style="vertical-align:middle" width="18"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si4.png" style="vertical-align:middle" width="16"/></span> be events such that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">→</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si5.png" style="vertical-align:middle" width="55"/></span>. An <i>interval</i> <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si6.png" style="vertical-align:middle" width="49"/></span> is the duration between <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si3.png" style="vertical-align:middle" width="18"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si4.png" style="vertical-align:middle" width="16"/></span>. Interval <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si7.png" style="vertical-align:middle" width="86"/></span> <i>precedes</i> <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si8.png" style="vertical-align:middle" width="86"/></span>, written <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">→</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si9.png" style="vertical-align:middle" width="58"/></span>, if <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">→</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si10.png" style="vertical-align:middle" width="57"/></span> (that is, if the final event of <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si11.png" style="vertical-align:middle" width="17"/></span> precedes the starting event of <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si12.png" style="vertical-align:middle" width="17"/></span>). The → relation is a partial order on intervals. Intervals that are unrelated by → are said to be <i>concurrent</i>. We also say that an event <i>a precedes</i> an interval <span class="hiddenClass"><mml:math><mml:mi>I</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si13.png" style="vertical-align:middle" width="78"/></span>, written <span class="hiddenClass"><mml:math><mml:mi>a</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>I</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si14.png" style="vertical-align:middle" width="44"/></span>, if <span class="hiddenClass"><mml:math><mml:mi>a</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si15.png" style="vertical-align:middle" width="50"/></span>, and that <i>I precedes a</i>, written <span class="hiddenClass"><mml:math><mml:mi>I</mml:mi><mml:mo stretchy="false">→</mml:mo><mml:mi>a</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si16.png" style="vertical-align:middle" width="43"/></span>, if <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">→</mml:mo><mml:mi>a</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si17.png" style="vertical-align:middle" width="49"/></span>.</p></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>2.2 Critical sections</h2><p class="textfl" id="p0035">In Chapter <a href="B9780124159501000094.xhtml">1</a>, we discussed the <img alt="Image" height="9" src="images/B9780124159501000112/fx001.jpg" width="46"/> class implementation shown in <a href="#f0010" id="cf0035">Fig. 2.1</a>. We observed that this implementation is correct in a single-thread system, but misbehaves when used by two or more threads. The problem occurs if both threads read the <img alt="Image" height="9" src="images/B9780124159501000112/fx002.jpg" width="32"/> field at the line marked “start of danger zone,” and then both update that field at the line marked “end of danger zone.”</p><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="191" src="images/B9780124159501000112/gr001.jpg" width="351"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.1</span> The <img alt="Image" height="9" src="images/B9780124159501000112/fx001.jpg" width="46"/> class.</div></figcaption></figure></div><p class="text" id="p0040">We can avoid this problem by making these two lines into a <i>critical section</i>: a block of code that can be executed by only one thread at a time. We call this property <i>mutual exclusion</i>. The standard way to achieve mutual exclusion is through a <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> object satisfying the interface shown in <a href="#f0015" id="cf0040">Fig. 2.2</a>.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="60" src="images/B9780124159501000112/gr002.jpg" width="382"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.2</span> The <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> interface.</div></figcaption></figure></div><p class="text" id="p0045"><span aria-label="Page 23" epub:type="pagebreak" id="page_23" role="doc-pagebreak"/><a href="#f0020" id="cf0045">Fig. 2.3</a> shows how to use a <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> object to add mutual exclusion to a shared counter implementation. Threads using the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>() methods must follow a specific format. A thread is <i>well formed</i> if:</p><div><ol><li class="numlist" id="o0010">1.  each critical section is associated with a <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> object,</li><li class="numlist" id="o0015">2.  the thread calls that object's <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method when it wants to enter the critical section, and</li><li class="numlist" id="o0020">3.  the thread calls the <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>() method when it leaves the critical section.</li></ol></div><p class="textfl"/><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="240" src="images/B9780124159501000112/gr003.jpg" width="398"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.3</span> Using a lock object.</div></figcaption></figure></div><p class="text" id="p0065"/><div class="boxg1" id="enun0010"><p class="b1num">Pragma 2.2.1 </p><div><p class="b1textfl" id="p0070">In Java, the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() and <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>() methods should be used in the following structured way:</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" class="img" height="109" src="images/B9780124159501000112/fx006.jpg" width="235"/></figure></div><p class="textfl"> This idiom ensures that the lock is acquired before entering the <img alt="Image" height="11" src="images/B9780124159501000112/fx007.jpg" width="19"/> block, and that the lock is released when control leaves the block. If a statement in the block throws an unexpected exception, it may be necessary to restore the object to a consistent state before returning.</p></div></div><p class="textfl"/><p class="text" id="p0075"><span aria-label="Page 24" epub:type="pagebreak" id="page_24" role="doc-pagebreak"/>We say that a thread <i>acquires</i> (alternatively, <i>locks</i>) a lock when it returns from a <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method call, and <i>releases</i> (alternatively, <i>unlocks</i>) the lock when it invokes the <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>() method. If a thread has acquired and not subsequently released a lock, we say that the thread <i>holds</i> the lock. No thread may acquire the lock while any other thread holds it, so at most one thread holds the lock at any time. We say the lock is <i>busy</i> if a thread holds it; otherwise, we say the lock is <i>free</i>.</p><p class="text" id="p0080">Multiple critical sections may be associated with the same <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/>, in which case no thread may execute a critical section while any other thread is executing a critical section associated with the same <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/>. From the perspective of a <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm, a thread starts a critical section when its call to the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method returns, and it ends the critical section by invoking the <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>() method; that is, a thread executes the critical section while it holds the lock.</p><p class="text" id="p0085">We now state more precisely the properties that a good <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm should satisfy, assuming that every thread that acquires the lock eventually releases it. </p><p class="definition" id="p0090"><span class="def_term"><b>Mutual exclusion</b></span> At most one thread holds the lock at any time.</p><p class="definition" id="p0095"><span class="def_term"><b>Freedom from deadlock</b></span> If a thread is attempting to acquire or release the lock (i.e., it invoked <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() or <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>() and has not returned), then eventually some thread acquires or releases the lock (i.e., it returns from invoking <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() or <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>()). If a thread calls <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() and never returns, then other threads must complete an infinite number of critical sections.</p><p class="definition" id="p0100"><span class="def_term"><b>Freedom from starvation</b></span> Every thread that attempts to acquire or release the lock eventually succeeds (i.e., every call to <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() or <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>() eventually returns).</p><p class="textfl"> Note that starvation-freedom implies deadlock-freedom.</p><p class="text" id="p0105">The mutual exclusion property is clearly essential. It guarantees that the critical section, that is, the code executed between the acquisition and release of the lock, is executed by at most one thread at a time. In other words, executions of the critical section cannot overlap. Without this property, we cannot guarantee that a computation's results are correct.</p><p class="text" id="p0110">Let <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000112/si18.png" style="vertical-align:middle" width="29"/></span> be the interval during which thread <i>A</i> executes the critical section for the <i>j</i>th time. Thus, <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000112/si19.png" style="vertical-align:middle" width="98"/></span>, where <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si3.png" style="vertical-align:middle" width="18"/></span> is the response event for <i>A</i>'s <i>j</i>th call to <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si4.png" style="vertical-align:middle" width="16"/></span> is the invocation event for <i>A</i>'s <i>j</i>th call to <img alt="Image" height="9" src="images/B9780124159501000112/fx005.jpg" width="39"/>(). For two distinct threads <i>A</i> and <i>B</i> and integers <i>j</i> and <i>k</i>, either <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">→</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000112/si20.png" style="vertical-align:middle" width="82"/></span> or <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>k</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">→</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000112/si21.png" style="vertical-align:middle" width="81"/></span>.</p><p class="text" id="p0115">The deadlock-freedom property is important. It implies that the system never “freezes.” If some thread calls <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() and never acquires the lock, then either some other thread acquires and never releases the lock or other threads must be completing an infinite number of critical sections. Individual threads may be stuck forever (called <i>starvation</i>), but some thread makes progress.</p><p class="text" id="p0120">The starvation-freedom property, while clearly desirable, is the least compelling of the three. This property is sometimes called <i>lockout-freedom</i>. In later chapters, we discuss practical mutual exclusion algorithms that are not starvation-free. These algorithms are typically deployed in circumstances where starvation is a theoretical possibility, but is unlikely to occur in practice. Nevertheless, the ability to reason about starvation is essential for understanding whether it is a realistic threat.</p><p class="text" id="p0125"><span aria-label="Page 25" epub:type="pagebreak" id="page_25" role="doc-pagebreak"/>The starvation-freedom property is also weak in the sense that there is no guarantee for how long a thread waits before it enters the critical section. In later chapters, we look at algorithms that place bounds on how long a thread can wait.</p><p class="text" id="p0130">In the terminology of Chapter <a href="B9780124159501000094.xhtml">1</a>, mutual exclusion is a safety property, and deadlock-freedom and starvation-freedom are liveness properties.</p></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>2.3 Two-thread solutions</h2><p class="textfl" id="p0135">We now consider algorithms that solve the mutual exclusion problem for two threads. Our two-thread lock algorithms follow the following conventions: The threads have IDs 0 and 1, and a thread can acquire its ID by calling <img alt="Image" height="12" src="images/B9780124159501000112/fx008.jpg" width="91"/>. We store the calling thread's ID in <i>i</i> and the other thread's ID in <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>i</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si22.png" style="vertical-align:middle" width="61"/></span>.</p><p class="text" id="p0140">We begin with two inadequate but interesting algorithms.</p><section><h3 class="h2hd" id="s0025"><a id="st0035"/>2.3.1 The <span class="inlinecode">LockOne</span> class</h3><p class="textfl" id="p0145"><a href="#f0030" id="cf0050">Fig. 2.4</a> shows the <img alt="Image" height="9" src="images/B9780124159501000112/fx009.jpg" width="45"/> algorithm, which maintains a Boolean <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> variable for each thread. To acquire the lock, a thread sets its <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> to <i>true</i> and waits until the other thread's <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> is <i>false</i>. The thread releases the flag by setting its <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> back to <i>false</i>.</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="224" src="images/B9780124159501000112/gr004.jpg" width="382"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.4</span> Pseudocode for the <img alt="Image" height="9" src="images/B9780124159501000112/fx009.jpg" width="45"/> algorithm.</div></figcaption></figure></div><p class="text" id="p0150">We use <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext>write</mml:mtext></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si23.png" style="vertical-align:middle" width="93"/></span> to denote the event in which thread <i>A</i> assigns value <i>v</i> to field <i>x</i>, and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext>read</mml:mtext></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si24.png" style="vertical-align:middle" width="100"/></span> to denote the event in which <i>A</i> reads <i>v</i> from field <i>x</i>. For example, in <a href="#f0030" id="cf0055">Fig. 2.4</a>, the event <img alt="Image" height="12" src="images/B9780124159501000112/fx011.jpg" width="133"/> is caused by line 7 of the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method. We sometimes omit the value when it is unimportant.</p><p class="text" id="p0155"/><div class="boxg1" id="enun0015"><p class="b1num">Lemma 2.3.1 </p><div><p class="b1textfl" id="p0160">The <img alt="Image" height="9" src="images/B9780124159501000112/fx009.jpg" width="45"/> algorithm satisfies mutual exclusion.</p></div></div><p class="textfl"/><p class="text" id="p0165"><span aria-label="Page 26" epub:type="pagebreak" id="page_26" role="doc-pagebreak"/></p><div class="boxg1" id="enun0020"><p class="b1num">Pragma 2.3.1 </p><div><p class="b1textfl" id="p0170">In practice, the Boolean <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> variables in <a href="#f0030" id="cf0060">Fig. 2.4</a>, as well as the <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> and <img alt="Image" height="9" src="images/B9780124159501000112/fx013.jpg" width="29"/> variables in later algorithms, must all be declared <img alt="Image" height="9" src="images/B9780124159501000112/fx014.jpg" width="53"/> to work properly. We explain the reasons in Chapter <a href="B9780124159501000124.xhtml">3</a> and Appendix <a href="B978012415950100032X.xhtml">B</a>. For readability, we omit the <img alt="Image" height="9" src="images/B9780124159501000112/fx014.jpg" width="53"/> declarations for now. We begin declaring the appropriate variables as volatile in Chapter <a href="B9780124159501000173.xhtml">7</a>.</p></div></div><p class="textfl"/><p class="text" id="p0175"/><div class="boxg1" id="enun0025"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0180">Suppose not. Then there are overlapping critical sections <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000112/si25.png" style="vertical-align:middle" width="27"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000112/si26.png" style="vertical-align:middle" width="27"/></span> of threads <i>A</i> and <i>B</i>, respectively (<span class="hiddenClass"><mml:math><mml:mi>A</mml:mi><mml:mo>≠</mml:mo><mml:mi>B</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si27.png" style="vertical-align:middle" width="44"/></span>). Consider each thread's last execution of the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method before entering its critical section. Inspecting the code, we see that</p><div class="showClass"><p class="fig"><img alt="Image" height="37" src="images/B9780124159501000112/fx015.jpg" width="366"/><a id="deq1"/></p></div><p class="b1textfl"/><p class="b1text" id="p0185">Note that once <img alt="Image" height="12" src="images/B9780124159501000112/fx016.jpg" width="46"/> is set to <i>true</i> it remains <i>true</i> until <i>B</i> exits its critical section. Since the critical sections overlap, <i>A</i> must read <img alt="Image" height="12" src="images/B9780124159501000112/fx016.jpg" width="46"/> before <i>B</i> sets it to <i>true</i>. Similarly, <i>B</i> must read <img alt="Image" height="12" src="images/B9780124159501000112/fx017.jpg" width="45"/> before <i>A</i> sets it to <i>true</i>. Combining these, we get</p><div class="showClass"><p class="fig"><img alt="Image" height="57" src="images/B9780124159501000112/fx018.jpg" width="351"/><a id="deq2"/></p></div><p class="b1textfl"> There is a cycle in →, which is a contradiction, because → is a partial order (an event cannot precede itself). □</p></div></div><p class="textfl"/><p class="text" id="p0190">The <img alt="Image" height="9" src="images/B9780124159501000112/fx009.jpg" width="45"/> algorithm is inadequate because it can deadlock if thread executions are interleaved: If <img alt="Image" height="12" src="images/B9780124159501000112/fx019.jpg" width="139"/> and <img alt="Image" height="12" src="images/B9780124159501000112/fx020.jpg" width="140"/> events occur before <img alt="Image" height="12" src="images/B9780124159501000112/fx021.jpg" width="92"/> and <img alt="Image" height="12" src="images/B9780124159501000112/fx022.jpg" width="92"/> events, then both threads wait forever. Nevertheless, <img alt="Image" height="9" src="images/B9780124159501000112/fx009.jpg" width="45"/> has an interesting property: If one thread runs before the other, no deadlock occurs, and all is well.</p></section><section><h3 class="h2hd" id="s0030"><a id="st0040"/>2.3.2 The <span class="inlinecode">LockTwo</span> class</h3><p class="textfl" id="p0195"><a href="#f0035" id="cf0065">Fig. 2.5</a> shows an alternative lock algorithm, the <img alt="Image" height="9" src="images/B9780124159501000112/fx023.jpg" width="45"/> class, which uses a single <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> field that indicates which thread should yield. To acquire the lock, a thread sets the <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> field to its own ID and then waits until the other thread changes it.</p><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="142" src="images/B9780124159501000112/gr005.jpg" width="344"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.5</span> Pseudocode for the <img alt="Image" height="9" src="images/B9780124159501000112/fx023.jpg" width="45"/> algorithm.</div></figcaption></figure></div><p class="text" id="p0200"/><div class="boxg1" id="enun0030"><p class="b1num">Lemma 2.3.2 </p><div><p class="b1textfl" id="p0205">The <img alt="Image" height="9" src="images/B9780124159501000112/fx023.jpg" width="45"/> algorithm satisfies mutual exclusion.</p></div></div><p class="textfl"/><p class="text" id="p0210"/><div class="boxg1" id="enun0035"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0215">Suppose not. Then there are overlapping critical sections <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000112/si25.png" style="vertical-align:middle" width="27"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000112/si26.png" style="vertical-align:middle" width="27"/></span> of threads <i>A</i> and <i>B</i>, respectively (<span class="hiddenClass"><mml:math><mml:mi>A</mml:mi><mml:mo>≠</mml:mo><mml:mi>B</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si27.png" style="vertical-align:middle" width="44"/></span>). As before, consider each thread's last execution of the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method before entering its critical section. Inspecting the code, we see that </p><div class="showClass"><p class="fig"><img alt="Image" height="35" src="images/B9780124159501000112/fx024.jpg" width="330"/><a id="deq3"/></p></div><p class="b1textfl"> Thread <i>B</i> must assign <i>B</i> to the <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> field between events <img alt="Image" height="12" src="images/B9780124159501000112/fx025.jpg" width="122"/> and <img alt="Image" height="12" src="images/B9780124159501000112/fx026.jpg" width="117"/>, so in particular, <i>B</i> must write <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> after <i>A</i>. However, by the same reasoning, <i>A</i> must write <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> after <i>B</i>, which is a contradiction. □</p></div></div><p class="textfl"/><p class="text" id="p0220"><span aria-label="Page 27" epub:type="pagebreak" id="page_27" role="doc-pagebreak"/>The <img alt="Image" height="9" src="images/B9780124159501000112/fx023.jpg" width="45"/> algorithm is inadequate because it gets stuck <i>unless</i> the threads run concurrently. Nevertheless, <img alt="Image" height="9" src="images/B9780124159501000112/fx023.jpg" width="45"/> has an interesting property: If the threads run concurrently, the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method succeeds. The <img alt="Image" height="9" src="images/B9780124159501000112/fx009.jpg" width="45"/> and <img alt="Image" height="9" src="images/B9780124159501000112/fx023.jpg" width="45"/> classes complement one another: Each succeeds under conditions that cause the other to get stuck.</p></section><section><h3 class="h2hd" id="s0035"><a id="st0045"/>2.3.3 The Peterson lock</h3><p class="textfl" id="p0225">We combine the <img alt="Image" height="9" src="images/B9780124159501000112/fx009.jpg" width="45"/> and <img alt="Image" height="9" src="images/B9780124159501000112/fx023.jpg" width="45"/> algorithms to construct a starvation-free lock algorithm, shown in <a href="#f0040" id="cf0070">Fig. 2.6</a>. This algorithm—known as <i>Peterson's algorithm</i>, after its inventor—is arguably the most succinct and elegant two-thread mutual exclusion algorithm.</p><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="257" src="images/B9780124159501000112/gr006.jpg" width="334"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.6</span> Pseudocode for the <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> lock algorithm.</div></figcaption></figure></div><p class="text" id="p0230"/><div class="boxg1" id="enun0040"><p class="b1num">Lemma 2.3.3 </p><div><p class="b1textfl" id="p0235">The <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> lock algorithm satisfies mutual exclusion.</p></div></div><p class="textfl"/><p class="text" id="p0240"/><div class="boxg1" id="enun0045"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0245">Suppose not. As before, consider the last executions of the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method by threads <i>A</i> and <i>B</i> before overlapping critical sections <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000112/si25.png" style="vertical-align:middle" width="27"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000112/si26.png" style="vertical-align:middle" width="27"/></span>. Inspecting the code, we see that</p><div class="showClass"><p class="fig"><img alt="Image" height="12" src="images/B9780124159501000112/fx028.jpg" width="285"/><a id="deq4"/><span class="eqnum">(2.3.1) </span></p></div><p class="b1textfl"/><div class="showClass"><p class="fig"><img alt="Image" height="59" src="images/B9780124159501000112/fx029.jpg" width="295"/><a id="deq5"/><span class="eqnum">(2.3.2) </span></p></div><p class="b1textfl"><span aria-label="Page 28" epub:type="pagebreak" id="page_28" role="doc-pagebreak"/></p><p class="b1text" id="p0250">Assume, without loss of generality, that <i>A</i> was the last thread to write to the <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> field, i.e.,</p><div class="showClass"><p class="fig"><img alt="Image" height="12" src="images/B9780124159501000112/fx030.jpg" width="273"/><a id="deq7"/><span class="eqnum">(2.3.3) </span></p></div><p class="b1textfl"> Eq. <a href="#deq7" id="cf0075">(2.3.3)</a> implies that <i>A</i> observed <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> to be <i>A</i> in Eq. <a href="#deq4" id="cf0080">(2.3.1)</a>. Since <i>A</i> nevertheless entered its critical section, it must have observed <img alt="Image" height="12" src="images/B9780124159501000112/fx016.jpg" width="46"/> to be <i>false</i>, so we have</p><div class="showClass"><p class="fig"><img alt="Image" height="13" src="images/B9780124159501000112/fx031.jpg" width="301"/><a id="deq8"/><span class="eqnum">(2.3.4) </span></p></div><p class="b1textfl"> Putting Eqs. <a href="#deq5" id="cf0085">(2.3.2)</a> to <a href="#deq8" id="cf0090">(2.3.4)</a> together yields:</p><div class="showClass"><p class="fig"><img alt="Image" height="36" src="images/B9780124159501000112/fx032.jpg" width="339"/><a id="deq9"/><span class="eqnum">(2.3.5) </span></p></div><p class="b1textfl"> By the transitivity of →, <img alt="Image" height="13" src="images/B9780124159501000112/fx033.jpg" width="314"/>. This observation yields a contradiction because no other write to <img alt="Image" height="12" src="images/B9780124159501000112/fx016.jpg" width="46"/> was performed before the critical section executions. □</p></div></div><p class="textfl"/><p class="text" id="p0255"/><div class="boxg1" id="enun0050"><p class="b1num">Lemma 2.3.4 </p><div><p class="b1textfl" id="p0260">The <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> lock algorithm is starvation-free.</p></div></div><p class="textfl"/><p class="text" id="p0265"/><div class="boxg1" id="enun0055"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0270">Suppose not, so some thread runs forever in the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method. Suppose (without loss of generality) that it is <i>A</i>. It must be executing the <img alt="Image" height="9" src="images/B9780124159501000112/fx034.jpg" width="33"/> statement, waiting until either <img alt="Image" height="12" src="images/B9780124159501000112/fx016.jpg" width="46"/> becomes <i>false</i> or <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> is set to <i>B</i>.</p><p class="b1text" id="p0275">What is <i>B</i> doing while <i>A</i> fails to make progress? Perhaps <i>B</i> is repeatedly entering and leaving its critical section. If so, however, then <i>B</i> sets <span aria-label="Page 29" epub:type="pagebreak" id="page_29" role="doc-pagebreak"/><img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> to <i>B</i> before it reenters the critical section. Once <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> is set to <i>B</i>, it does not change, and <i>A</i> must eventually return from the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method, a contradiction.</p><p class="b1text" id="p0280">So it must be that <i>B</i> is also stuck in its <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method call, waiting until either <img alt="Image" height="12" src="images/B9780124159501000112/fx035.jpg" width="45"/> becomes <i>false</i> or <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> is set to <i>A</i>. But <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> cannot be both <i>A</i> and <i>B</i>, a contradiction. □</p></div></div><p class="textfl"/><p class="text" id="p0285"/><div class="boxg1" id="enun0060"><p class="b1num">Corollary 2.3.5 </p><div><p class="b1textfl" id="p0290">The <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> lock algorithm is deadlock-free.</p></div></div><p class="textfl"/></section></section><section><h2 class="h1hd" id="s0040"><a id="st0050"/>2.4 Notes on deadlock</h2><p class="textfl" id="p0295">Although the <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> lock algorithm is deadlock-free (and even starvation-free), another kind of deadlock can arise in programs that use multiple <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> locks (or any other lock implementation). For example, suppose that threads <i>A</i> and <i>B</i> share locks <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si28.png" style="vertical-align:middle" width="16"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si29.png" style="vertical-align:middle" width="15"/></span>, and that <i>A</i> acquires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si28.png" style="vertical-align:middle" width="16"/></span> and <i>B</i> acquires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si29.png" style="vertical-align:middle" width="15"/></span>. If <i>A</i> then tries to acquire <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si29.png" style="vertical-align:middle" width="15"/></span> and <i>B</i> tries to acquire <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si28.png" style="vertical-align:middle" width="16"/></span>, the threads deadlock because each one waits for the other to release its lock.</p><p class="text" id="p0300">In the literature, the term <i>deadlock</i> is sometimes used more narrowly to refer to the case in which the system enters a state from which there is no way for threads to make progress. The <img alt="Image" height="9" src="images/B9780124159501000112/fx009.jpg" width="45"/> and <img alt="Image" height="9" src="images/B9780124159501000112/fx023.jpg" width="45"/> algorithms are susceptible to this kind of deadlock: In both algorithms, both threads can get stuck waiting in their respective while loops.</p><p class="text" id="p0305">This narrower notion of deadlock is distinguished from <i>livelock</i>, in which two or more threads actively prevent each other from making progress by taking steps that subvert steps taken by other threads. When the system is livelocked rather than deadlocked, there is some way to schedule the threads so that the system can make progress (but also some way to schedule them so that there is no progress). Our definition of deadlock-freedom proscribes livelock as well as this narrower notion of deadlock.</p><p class="text" id="p0310">Consider, for example, the <img alt="Image" height="9" src="images/B9780124159501000112/fx036.jpg" width="52"/> algorithm in <a href="#f0045" id="cf0095">Fig. 2.7</a>. (This is a variant of the flag protocol described in Section <a href="B9780124159501000094.xhtml">1.2</a> in which both threads follow Bob's part of the protocol.) If both threads execute the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method, they may indefinitely repeat the following steps:</p><div><ul><li class="bulllist" id="u0010">•  Set their respective <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> variables to <i>true</i>.</li><li class="bulllist" id="u0015">•  See that the other thread's <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> is <i>true</i>.</li><li class="bulllist" id="u0020">•  Set their respective <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> variables to <i>false</i>.</li><li class="bulllist" id="u0025">•  See that the other thread's <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> is <i>false</i>.</li></ul></div><p class="textfl"> Because of this possible livelock, <img alt="Image" height="9" src="images/B9780124159501000112/fx036.jpg" width="52"/> is not deadlock-free by our definition.</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="290" src="images/B9780124159501000112/gr007.jpg" width="272"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.7</span> Pseudocode for a lock algorithm that may livelock.</div></figcaption></figure></div><p class="text" id="p0335">However, <img alt="Image" height="9" src="images/B9780124159501000112/fx036.jpg" width="52"/> does not deadlock by the narrower definition because there is always some way to schedule the threads so that one of them makes progress: If one thread's <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> is <i>false</i>, then execute the other thread until it exits the loop and returns. If both threads' <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> variables are <i>true</i>, then execute one thread until it sets its <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> to <i>false</i>, and then execute the other as described above (i.e., until it returns).<span aria-label="Page 30" epub:type="pagebreak" id="page_30" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>2.5 The filter lock</h2><p class="textfl" id="p0340">The <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> lock, shown in <a href="#f0050" id="cf0100">Fig. 2.8</a>, generalizes the <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> lock to work for <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si30.png" style="vertical-align:middle" width="39"/></span> threads. It creates <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span> “waiting rooms,” called <i>levels</i>, that a thread must traverse before acquiring the lock. The levels are depicted in <a href="#f0055" id="cf0105">Fig. 2.9</a>. Levels satisfy two important properties:</p><div><ul><li class="bulllist" id="u0030">•  At least one thread trying to enter level <i>ℓ</i> succeeds.</li><li class="bulllist" id="u0035">•  If more than one thread is trying to enter level <i>ℓ</i>, then at least one is blocked (i.e., continues to wait without entering that level).</li></ul></div><p class="textfl"/><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="388" src="images/B9780124159501000112/gr008.jpg" width="399"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.8</span> Pseudocode for the <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> lock algorithm.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="183" src="images/B9780124159501000112/gr009.jpg" width="184"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.9</span> Threads pass through <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">n</mml:mtext><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mtext mathvariant="sans-serif">1</mml:mtext></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si32.png" style="vertical-align:middle" width="37"/></span> levels, the last of which is the critical section. Initially, all <i>n</i> threads are at level 0. At most <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">n</mml:mtext><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mtext mathvariant="sans-serif">1</mml:mtext></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si32.png" style="vertical-align:middle" width="37"/></span> enter level 1, at most <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">n</mml:mtext><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si33.png" style="vertical-align:middle" width="38"/></span> enter level 2, and so on, so that only one thread enters the critical section at level <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">n</mml:mtext><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mtext mathvariant="sans-serif">1</mml:mtext></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si32.png" style="vertical-align:middle" width="37"/></span>.</div></figcaption></figure></div><p class="text" id="p0355">The <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> lock uses a two-element Boolean <img alt="Image" height="11" src="images/B9780124159501000112/fx010.jpg" width="25"/> array to indicate whether a thread is trying to enter the critical section. The <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> lock generalizes this notion with an <i>n</i>-element integer <img alt="Image" height="12" src="images/B9780124159501000112/fx038.jpg" width="41"/> array, where the value of <img alt="Image" height="12" src="images/B9780124159501000112/fx039.jpg" width="52"/> indicates the highest level that thread <i>A</i> is trying to enter. Each thread must pass through <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span> levels of “exclusion” to enter its critical section. Each level <i>ℓ</i> has a distinct <img alt="Image" height="12" src="images/B9780124159501000112/fx040.jpg" width="55"/> field used to “filter out” one thread, excluding it from that level unless no thread is at that level or higher.</p><p class="text" id="p0360">Initially, a thread <i>A</i> is at level 0. <i>A enters</i> level <i>ℓ</i> for <span class="hiddenClass"><mml:math><mml:mi>ℓ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si34.png" style="vertical-align:middle" width="37"/></span> when it completes the waiting loop on line 17 with <img alt="Image" height="12" src="images/B9780124159501000112/fx041.jpg" width="77"/> (i.e., when it stops waiting at that loop). <i>A</i> enters its critical section when it enters level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span>. When <i>A</i> leaves the critical section, it sets <img alt="Image" height="12" src="images/B9780124159501000112/fx042.jpg" width="52"/> to <span aria-label="Page 31" epub:type="pagebreak" id="page_31" role="doc-pagebreak"/>0.<span aria-label="Page 32" epub:type="pagebreak" id="page_32" role="doc-pagebreak"/></p><p class="text" id="p0365"/><div class="boxg1" id="enun0065"><p class="b1num">Lemma 2.5.1 </p><div><p class="b1textfl" id="p0370">For <i>j</i> between 0 and <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span>, at most <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span> threads have entered level <i>j</i> (and not subsequently exited the critical section).</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0070"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0375">We prove this by induction on <i>j</i>. The base case, where <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>0</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si36.png" style="vertical-align:middle" width="38"/></span>, is trivial. For the induction step, the induction hypothesis implies that at most <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si37.png" style="vertical-align:middle" width="64"/></span> threads have entered level <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si38.png" style="vertical-align:middle" width="36"/></span>. To show that at least one thread does not enter level <i>j</i>, we argue by contradiction. Assume that <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si37.png" style="vertical-align:middle" width="64"/></span> threads have entered level <i>j</i>. Because <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo>⩽</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si39.png" style="vertical-align:middle" width="63"/></span>, there must be at least two such threads.</p><p class="b1text" id="p0380">Let <i>A</i> be the last thread to write <img alt="Image" height="12" src="images/B9780124159501000112/fx043.jpg" width="56"/>. <i>A</i> must have entered level <i>j</i> since <img alt="Image" height="12" src="images/B9780124159501000112/fx043.jpg" width="56"/> is written only by threads that have entered level <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si38.png" style="vertical-align:middle" width="36"/></span>, and, by the induction hypothesis, every thread that has entered level <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si38.png" style="vertical-align:middle" width="36"/></span> has also entered level <i>j</i>. Let <i>B</i> be any thread other than <i>A</i> that has entered level <i>j</i>. Inspecting the code, we see that before <i>B</i> enters level <i>j</i>, it first writes <i>j</i> to <img alt="Image" height="12" src="images/B9780124159501000112/fx044.jpg" width="52"/> and then writes <i>B</i> to <img alt="Image" height="12" src="images/B9780124159501000112/fx043.jpg" width="56"/>. Since <i>A</i> is the last to write <img alt="Image" height="12" src="images/B9780124159501000112/fx043.jpg" width="56"/>, we have</p><div class="showClass"><p class="fig"><img alt="Image" height="13" src="images/B9780124159501000112/fx045.jpg" width="402"/><a id="deq11"/></p></div><p class="b1textfl"> We also see that <i>A</i> reads <img alt="Image" height="12" src="images/B9780124159501000112/fx044.jpg" width="52"/> (line 17) after it writes to <img alt="Image" height="12" src="images/B9780124159501000112/fx043.jpg" width="56"/>, so</p><div class="showClass"><p class="fig"><img alt="Image" height="35" src="images/B9780124159501000112/fx046.jpg" width="273"/><a id="deq12"/></p></div><p class="b1textfl"> Because <i>B</i> has entered level <i>j</i>, every time <i>A</i> reads <img alt="Image" height="12" src="images/B9780124159501000112/fx047.jpg" width="52"/>, it observes a value greater than or equal to <i>j</i>, and since <img alt="Image" height="12" src="images/B9780124159501000112/fx048.jpg" width="85"/> (because <i>A</i> was the last to write it), <i>A</i> could not have completed its waiting loop on line 17, a contradiction. □</p></div></div><p class="textfl"/><p class="text" id="p0385"/><div class="boxg1" id="enun0075"><p class="b1num">Corollary 2.5.2 </p><div><p class="b1textfl" id="p0390">The <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> lock algorithm satisfies mutual exclusion.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0080"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0395">Entering the critical section is equivalent to entering level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span>, so at most one thread enters the critical section. □</p></div></div><p class="textfl"/><p class="text" id="p0400"/><div class="boxg1" id="enun0085"><p class="b1num">Lemma 2.5.3 </p><div><p class="b1textfl" id="p0405">The <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> lock algorithm is starvation-free.</p></div></div><p class="textfl"/><p class="text" id="p0410"/><div class="boxg1" id="enun0090"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0415">We prove by induction on <i>j</i> that every thread that enters level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span> eventually enters and leaves the critical section (assuming that it keeps taking steps and that every thread that enters the critical section eventually leaves it). The base case, with <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si40.png" style="vertical-align:middle" width="36"/></span>, is trivial because level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span> is the critical section.</p><p class="b1text" id="p0420">For the induction step, we suppose that every thread that enters level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span> or higher eventually enters and leaves the critical section, and show that every thread that enters level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si41.png" style="vertical-align:middle" width="64"/></span> does too.</p><p class="b1text" id="p0425">Suppose, for contradiction, that a thread <i>A</i> has entered level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si41.png" style="vertical-align:middle" width="64"/></span> and is stuck. By the induction hypothesis, it never enters level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span>, so it must be stuck at line 17 with <img alt="Image" height="12" src="images/B9780124159501000112/fx049.jpg" width="103"/> and <img alt="Image" height="12" src="images/B9780124159501000112/fx050.jpg" width="111"/>. After <i>A</i> writes <img alt="Image" height="12" src="images/B9780124159501000112/fx051.jpg" width="82"/>, no thread enters level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si41.png" style="vertical-align:middle" width="64"/></span> because any thread that did would overwrite <img alt="Image" height="12" src="images/B9780124159501000112/fx051.jpg" width="82"/>, allowing <i>A</i> to enter level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span>. Furthermore, any other thread <i>B</i> trying to enter level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span> will eventually succeed because <img alt="Image" height="12" src="images/B9780124159501000112/fx052.jpg" width="140"/>, so eventually no threads other than <i>A</i> are trying to enter level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span>. Moreover, any thread that enters level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span> will, by the induction hypothesis, enter and leave the critical section, setting its level to 0. At some point, <i>A</i> is the only thread that has entered level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si41.png" style="vertical-align:middle" width="64"/></span> and not entered and left the critical section. In particular, after this point, <img alt="Image" height="12" src="images/B9780124159501000112/fx053.jpg" width="104"/> for every thread <i>B</i> other than <i>A</i>, so <i>A</i> can enter level <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si35.png" style="vertical-align:middle" width="38"/></span>, a contradiction. □</p></div></div><p class="textfl"/><p class="text" id="p0430"><span aria-label="Page 33" epub:type="pagebreak" id="page_33" role="doc-pagebreak"/></p><div class="boxg1" id="enun0095"><p class="b1num">Corollary 2.5.4 </p><div><p class="b1textfl" id="p0435">The <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> lock algorithm is deadlock-free.</p></div></div><p class="textfl"/></section><section><h2 class="h1hd" id="s0050"><a id="st0060"/>2.6 Fairness</h2><p class="textfl" id="p0440">The starvation-freedom property guarantees that every thread that calls <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() eventually enters the critical section, but it makes no guarantees about how long this may take, nor does it guarantee that the lock will be “fair” to the threads attempting to acquire it. For example, although the <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> lock algorithm is starvation-free, a thread attempting to acquire the lock may be overtaken arbitrarily many times by another thread.</p><p class="text" id="p0445">Ideally (and very informally), if <i>A</i> calls <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() before <i>B</i>, then <i>A</i> should enter the critical section before <i>B</i>. That is, the lock should be “first-come-first-served.” However, with the tools we have introduced so far, we cannot determine which thread called <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() first.</p><p class="text" id="p0450">To define fairness, we split the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method into a <i>doorway</i> section and a <i>waiting</i> section, where the doorway section always completes in a bounded number of steps (the waiting section may take an unbounded number of steps). That is, there is a fixed limit on the number of steps a thread may take after invoking <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() before it completes the doorway section.</p><p class="text" id="p0455">A section of code that is guaranteed to complete in a bounded number of steps is said to be <i>bounded wait-free</i>. The bounded wait-free property is a strong progress requirement. It is satisfied by code that has no loops. In later chapters, we discuss ways to provide this property in code that has loops. With this definition, we define the following fairness property.</p><p class="text" id="p0460"/><div class="boxg1" id="enun0100"><p class="b1num">Definition 2.6.1 </p><div><p class="b1textfl" id="p0465">A lock is <i>first-come-first-served</i> if its <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method can be split into a bounded wait-free doorway section followed by a waiting section so that whenever thread <i>A</i> finishes its doorway before thread <i>B</i> starts its doorway, <i>A</i> cannot be overtaken by <i>B</i>. That is,</p><p class="hiddenClass"><mml:math><mml:mtext>if </mml:mtext><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">D</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">→</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">D</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>k</mml:mi></mml:mrow></mml:msubsup><mml:mtext> then </mml:mtext><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">→</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="30" src="images/B9780124159501000112/si42.png" width="269"/><a id="deq13"/></p></div><p class="b1textfl"> for any threads <i>A</i> and <i>B</i> and integers <i>j</i> and <i>k</i>, where <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">D</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000112/si43.png" style="vertical-align:middle" width="23"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi mathvariant="italic">CS</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000112/si18.png" style="vertical-align:middle" width="29"/></span> are the intervals during which <i>A</i> executes the doorway section of its <i>j</i>th call to the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method and its <i>j</i>th critical section, respectively.</p></div></div><p class="textfl"/><p class="text" id="p0470">Note that any algorithm that is both deadlock-free and first-come-first-served is also starvation-free.<span aria-label="Page 34" epub:type="pagebreak" id="page_34" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0055"><a id="st0065"/>2.7 Lamport's Bakery algorithm</h2><p class="textfl" id="p0475">Perhaps the most elegant solution to the mutual exclusion problem for <i>n</i> threads is the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock algorithm, which appears in <a href="#f0060" id="cf0110">Fig. 2.10</a>. It guarantees the <i>first-come-first-served</i> property by using a distributed version of the number-dispensing machines often found in bakeries: Each thread takes a number in the doorway, and then waits until no thread with an earlier number is trying to enter the critical section.</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="322" src="images/B9780124159501000112/gr010.jpg" width="418"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.10</span> Pseudocode for the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock algorithm.</div></figcaption></figure></div><p class="text" id="p0480">In the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock, <img alt="Image" height="12" src="images/B9780124159501000112/fx035.jpg" width="45"/> is a Boolean flag that indicates whether <i>A</i> wants to enter the critical section, and <span class="sans-serif">label</span><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si45.png" style="vertical-align:middle" width="23"/></span> is an integer that indicates the thread's relative order when entering the bakery, for each thread <i>A</i>. To acquire the lock, a thread first raises its flag, and then picks a new label by reading the labels of all the threads (in any order) and generating a label greater than all the labels it read. The code from the invocation of the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method to the writing of the new label (line 14) is the <i>doorway</i>: it establishes that thread's order with respect to other threads trying to acquire the lock. Threads that execute their doorways concurrently may read the same labels and pick the same new label. To break this symmetry, the algorithm uses a lexicographical ordering &lt;&lt; on pairs of labels and thread IDs:</p><p class="hiddenClass"><mml:math><mml:mo id="mmlbr0007" stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">&lt;</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">&lt;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo indentalign="id" indenttarget="mmlbr0007" linebreak="newline" linebreakstyle="after" stretchy="false">)</mml:mo><mml:mrow><mml:mspace width="1.00em"/><mml:mtext>if and only if</mml:mtext><mml:mspace width="0.25em"/><mml:mspace width="1.00em"/></mml:mrow><mml:mspace linebreak="newline"/><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo linebreak="badbreak" linebreakstyle="after">&lt;</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mspace width="1em"/><mml:mtext>or</mml:mtext><mml:mspace width="1em"/><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mspace width="1em"/><mml:mtext>and</mml:mtext><mml:mspace width="1em"/><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="86" src="images/B9780124159501000112/si46.png" width="522"/><a id="deq14"/><span class="eqnum">(2.7.1) </span></p></div><p class="textfl"><span aria-label="Page 35" epub:type="pagebreak" id="page_35" role="doc-pagebreak"/> In the waiting section of the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> algorithm (line 15), a thread repeatedly reads the flags and labels of the other threads in any order until it determines that no thread with a raised flag has a lexicographically smaller label/ID pair.</p><p class="text" id="p0485">Since releasing a lock does not reset the <span class="sans-serif">label</span>[], it is easy to see that each thread's labels are strictly increasing. Interestingly, in both the doorway and waiting sections, threads read the labels asynchronously and in an arbitrary order. For example, the set of labels seen prior to picking a new one may have never existed in memory at the same time. Nevertheless, the algorithm works.</p><p class="text" id="p0490"/><div class="boxg1" id="enun0105"><p class="b1num">Lemma 2.7.1 </p><div><p class="b1textfl" id="p0495">The <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock algorithm is deadlock-free.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0110"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0500">Some waiting thread <i>A</i> has the unique least <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si47.png" style="vertical-align:middle" width="87"/></span> pair, and that thread never waits for another thread. □</p></div></div><p class="textfl"/><p class="text" id="p0505"/><div class="boxg1" id="enun0115"><p class="b1num">Lemma 2.7.2 </p><div><p class="b1textfl" id="p0510">The <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock algorithm is first-come-first-served.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0120"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0515">If <i>A</i>'s doorway precedes <i>B</i>'s, then <i>A</i>'s label is smaller since</p><div class="showClass"><p class="fig"><img alt="Image" height="13" src="images/B9780124159501000112/fx055.jpg" width="470"/><a id="deq16"/></p></div><p class="b1textfl"> so <i>B</i> is locked out while <img alt="Image" height="12" src="images/B9780124159501000112/fx035.jpg" width="45"/> is <i>true</i>. □</p></div></div><p class="textfl"/><p class="text" id="p0520"/><div class="boxg1" id="enun0125"><p class="b1num">Corollary 2.7.3 </p><div><p class="b1textfl" id="p0525">The <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock algorithm is starvation-free.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0130"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0530">This follows immediately from <a href="#enun0105" id="cs0010">Lemmas 2.7.1</a> and <a href="#enun0115">2.7.2</a> because any deadlock-free first-come-first-served lock algorithm is also starvation-free. □</p></div></div><p class="textfl"/><p class="text" id="p0535"/><div class="boxg1" id="enun0135"><p class="b1num">Lemma 2.7.4 </p><div><p class="b1textfl" id="p0540">The <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock algorithm satisfies mutual exclusion.</p></div></div><p class="textfl"> </p><div class="boxg1" id="enun0140"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0545">Suppose not. Let <i>A</i> and <i>B</i> be two threads concurrently in the critical section with <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">&lt;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si48.png" style="vertical-align:middle" width="202"/></span>. Let <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext>labeling</mml:mtext></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si49.png" style="vertical-align:middle" width="62"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext>labeling</mml:mtext></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si50.png" style="vertical-align:middle" width="63"/></span> be the last respective sequences of acquiring new labels (line 14) prior to entering the critical section. To complete its waiting section, <i>B</i> must have read either that <img alt="Image" height="12" src="images/B9780124159501000112/fx035.jpg" width="45"/> was <i>false</i> or that <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">&lt;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si51.png" style="vertical-align:middle" width="202"/></span>. However, for a given thread, its ID is fixed and its <span class="sans-serif">label</span>[] values are strictly increasing, so <i>B</i> must have seen that <img alt="Image" height="12" src="images/B9780124159501000112/fx035.jpg" width="45"/> was <i>false</i>. It follows that</p><p class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext>labeling</mml:mtext></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">→</mml:mo><mml:msub><mml:mrow><mml:mtext>read</mml:mtext></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mtext>flag</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mtext mathvariant="italic">false</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">→</mml:mo><mml:msub><mml:mrow><mml:mtext>write</mml:mtext></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mtext>flag</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mtext mathvariant="italic">true</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">→</mml:mo><mml:msub><mml:mrow><mml:mtext>labeling</mml:mtext></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="21" src="images/B9780124159501000112/si52.png" width="689"/><a id="deq17"/></p></div><p class="b1textfl"> which contradicts the assumption that <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">&lt;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext mathvariant="sans-serif">label</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si48.png" style="vertical-align:middle" width="202"/></span>. □</p></div></div><p class="textfl"/></section><section><h2 class="h1hd" id="s0060"><a id="st0070"/>2.8 Bounded timestamps</h2><p class="textfl" id="p0550">Note that the labels of the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock grow without bound, so in a long-lived system we may have to worry about overflow. If a thread's label field silently rolls over from a large number to zero, then the first-come-first-served property no longer holds.</p><p class="text" id="p0555"><span aria-label="Page 36" epub:type="pagebreak" id="page_36" role="doc-pagebreak"/>In later chapters, we discuss constructions in which counters are used to order threads, or even to produce unique IDs. How important is the overflow problem in the real world? It is difficult to generalize. Sometimes it matters a great deal. The celebrated “Y2K” bug that captivated the media in the last years of the 20th century is an example of a genuine overflow problem, even if the consequences were not as dire as predicted. On January 19, 2038, the Unix <img alt="Image" height="13" src="images/B9780124159501000112/fx056.jpg" width="38"/> data structure will overflow when the number of seconds since January 1, 1970 exceeds 2<sup>31</sup>. No one knows whether it will matter. Sometimes, of course, counter overflow is a nonissue. Most applications that use, say, a 64-bit counter are unlikely to last long enough for roll-over to occur. (Let the grandchildren worry!)</p><p class="text" id="p0560">In the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock, labels act as <i>timestamps</i>: They establish an order among the contending threads. Informally, we need to ensure that if one thread takes a label after another, then the latter has the larger label. Inspecting the code for the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock, we see that a thread needs two abilities:</p><div><ul><li class="bulllist" id="u0040">•  to read the other threads' timestamps (<i>scan</i>), and</li><li class="bulllist" id="u0045">•  to assign itself a later timestamp (<i>label</i>).</li></ul></div><p class="textfl"> A Java interface to such a timestamping system appears in <a href="#f0065" id="cf0115">Fig. 2.11</a>. Since our principal application for a bounded timestamping system is to implement the doorway section of the <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> class, the timestamping system must be wait-free. It is possible to construct such a wait-free <i>concurrent</i> timestamping system (see the chapter notes), but the construction is long and technical. Instead, we focus on a simpler problem, interesting in its own right: constructing a <i>sequential</i> timestamping system, in which threads perform <i>scan</i>-and-<i>label</i> operations one completely after the other, that is, as if each were performed using mutual exclusion. In other words, we consider only executions in which a thread can perform a scan of the other threads' labels, or a scan and then an assignment of a new label, where each such sequence is a single atomic step. Although the details of concurrent and sequential timestamping systems differ substantially, the principles underlying them are essentially the same.</p><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="109" src="images/B9780124159501000112/gr011.jpg" width="317"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.11</span> A timestamping system interface.</div></figcaption></figure></div><p class="text" id="p0575">Think of the range of possible timestamps as nodes of a directed graph (called a <i>precedence graph</i>). An edge from node <i>a</i> to node <i>b</i> means that <i>a</i> is a later timestamp than <i>b</i>. The timestamp order is <i>irreflexive</i>: There is no edge from any node <i>a</i> to itself. The order is also <i>antisymmetric</i>: If there is an edge <span aria-label="Page 37" epub:type="pagebreak" id="page_37" role="doc-pagebreak"/>from <i>a</i> to <i>b</i>, then there is no edge from <i>b</i> to <i>a</i>. We do <i>not</i> require that the order be <i>transitive</i>: There can be an edge from <i>a</i> to <i>b</i> and from <i>b</i> to <i>c</i>, without necessarily implying there is an edge from <i>a</i> to <i>c</i>.</p><p class="text" id="p0580">Think of assigning a timestamp to a thread as placing that thread's token on that timestamp's node. A thread performs a scan by locating the other threads' tokens, and it assigns itself a new timestamp by moving its own token to a node <i>a</i> such that there is an edge from <i>a</i> to every other thread's node.</p><p class="text" id="p0585">Pragmatically, we can implement such a system as an array of single-writer multi-reader fields, with an element for each thread <i>A</i> that indicates the node that <i>A</i> most recently assigned its token. The <img alt="Image" height="6" src="images/B9780124159501000112/fx057.jpg" width="25"/>() method takes a “snapshot” of the array, and the <img alt="Image" height="9" src="images/B9780124159501000112/fx013.jpg" width="29"/>() method for thread <i>A</i> updates the array element for <i>A</i>.</p><p class="text" id="p0590"><a href="#f0070" id="cf0120">Fig. 2.12</a> illustrates the precedence graph for the unbounded timestamp system used in the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock. Not surprisingly, the graph is infinite: There is one node for each natural number, with a directed edge from node <i>a</i> to node <i>b</i> whenever <span class="hiddenClass"><mml:math><mml:mi>a</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mi>b</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si53.png" style="vertical-align:middle" width="39"/></span>.</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="81" src="images/B9780124159501000112/gr012.jpg" width="236"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.12</span> The precedence graph for an unbounded timestamping system. The nodes represent the set of all natural numbers and the edges represent the total order among them.</div></figcaption></figure></div><p class="text" id="p0595">Consider the precedence graph <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> shown in <a href="#f0075" id="cf0125">Fig. 2.13</a>. This graph has three nodes, labeled 0, 1, and 2, and its edges define an ordering relation on the nodes in which 0 is less than 1, 1 is less than 2, and 2 is less than 0. If there are only two threads, then we can use this graph to define a bounded (sequential) timestamping system. The system satisfies the following invariant: The two threads always have tokens on adjacent nodes, with the direction of the edge indicating their relative order. Suppose <i>A</i>'s token is on node 0, and <i>B</i>'s token on node 1 (so <i>B</i> has the later timestamp). For <i>B</i>, the <img alt="Image" height="9" src="images/B9780124159501000112/fx013.jpg" width="29"/>() method is trivial: It already has the latest timestamp, so it does nothing. For <i>A</i>, the <img alt="Image" height="9" src="images/B9780124159501000112/fx013.jpg" width="29"/>() method “leapfrogs” <i>B</i>'s node by jumping from 0 to 2.</p><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="192" src="images/B9780124159501000112/gr013.jpg" width="437"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.13</span> The precedence graph for a bounded timestamping system. Consider an initial situation in which there is a token <i>A</i> on node 12 (node 2 in subgraph 1) and tokens <i>B</i> and <i>C</i> on nodes 21 and 22 (nodes 1 and 2 in subgraph 2). Token <i>B</i> will move to node 20 to dominate the others. Token <i>C</i> will then move to node 21 to dominate the others, and <i>B</i> and <i>C</i> can continue to cycle in the <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">T</mml:mtext></mml:mrow><mml:mrow><mml:mspace width="0.20em"/><mml:mtext mathvariant="sans-serif">2</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si61.png" style="vertical-align:middle" width="19"/></span> subgraph 2 forever. If <i>A</i> is to move to dominate <i>B</i> and <i>C</i>, it cannot pick a node in subgraph 2 since it is full (any <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mtext mathvariant="italic">T</mml:mtext></mml:mrow><mml:mrow><mml:mspace width="0.20em"/><mml:mtext mathvariant="italic">k</mml:mtext></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si62.png" style="vertical-align:middle" width="18"/></span> subgraph can accommodate at most <i>k</i> tokens). Instead, token <i>A</i> moves to node 00. If <i>B</i> now moves, it will choose node 01, <i>C</i> will choose node 10, and so on.</div></figcaption></figure></div><p class="text" id="p0600">Recall that a <i>cycle</i> in a directed graph is a set of nodes <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000112/si55.png" style="vertical-align:middle" width="91"/></span> such that there is an edge from <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si56.png" style="vertical-align:middle" width="18"/></span> to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si57.png" style="vertical-align:middle" width="17"/></span>, from <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si57.png" style="vertical-align:middle" width="17"/></span> to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si58.png" style="vertical-align:middle" width="18"/></span>, and eventually from <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si59.png" style="vertical-align:middle" width="32"/></span> to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si60.png" style="vertical-align:middle" width="18"/></span>, and back from <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si60.png" style="vertical-align:middle" width="18"/></span> to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000112/si56.png" style="vertical-align:middle" width="18"/></span>.</p><p class="text" id="p0605">The only cycle in the graph <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> has length three, and there are only two threads, so the order among the threads is never ambiguous. To go beyond two threads, we need additional conceptual tools. Let <i>G</i> be a precedence graph, and <i>A</i> and <i>B</i> subgraphs of <i>G</i> (possibly single nodes). We say that <i>A dominates B</i> in <i>G</i> if every node of <i>A</i> has edges directed to every node of <i>B</i>. Let <i>graph multiplication</i> be the following noncommutative composition operation for graphs (denoted <span class="hiddenClass"><mml:math><mml:mi>G</mml:mi><mml:mo>∘</mml:mo><mml:mi>H</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si63.png" style="vertical-align:middle" width="43"/></span>): </p><p class="quote" id="sp0120">Replace every node <i>v</i> of <i>G</i> by a copy of <i>H</i> (denoted <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si64.png" style="vertical-align:middle" width="20"/></span>), and let <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si64.png" style="vertical-align:middle" width="20"/></span> dominate <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si65.png" style="vertical-align:middle" width="20"/></span> in <span class="hiddenClass"><mml:math><mml:mi>G</mml:mi><mml:mo>∘</mml:mo><mml:mi>H</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si63.png" style="vertical-align:middle" width="43"/></span> if <i>v</i> dominates <i>u</i> in <i>G</i>. <span aria-label="Page 38" epub:type="pagebreak" id="page_38" role="doc-pagebreak"/></p><p class="textfl"> Define the graph <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si66.png" style="vertical-align:middle" width="19"/></span> inductively as follows:</p><div><ol><li class="numlist" id="o0025">1.  <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si67.png" style="vertical-align:middle" width="18"/></span> is a single node.</li><li class="numlist" id="o0030">2.  <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> is the three-node graph defined earlier.</li><li class="numlist" id="o0035">3.  For <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si68.png" style="vertical-align:middle" width="38"/></span>, <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>∘</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si69.png" style="vertical-align:middle" width="99"/></span>.</li></ol></div><p class="textfl"> For example, the graph <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si70.png" style="vertical-align:middle" width="19"/></span> is illustrated in <a href="#f0075" id="cf0130">Fig. 2.13</a>.</p><p class="text" id="p0625">The precedence graph <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si71.png" style="vertical-align:middle" width="19"/></span> is the basis for an <i>n</i>-thread bounded sequential timestamping system. We can “address” any node in the <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si71.png" style="vertical-align:middle" width="19"/></span> graph with <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span> digits, using ternary notation. For example, the nodes in graph <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> are addressed by 0, 1, and 2. The nodes in graph <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si70.png" style="vertical-align:middle" width="19"/></span> are denoted by <span class="hiddenClass"><mml:math><mml:mn>00</mml:mn><mml:mo>,</mml:mo><mml:mn>01</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>22</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si72.png" style="vertical-align:middle" width="93"/></span>, where the high-order digit indicates one of the three subgraphs, and the low-order digit indicates one node within that subgraph.</p><p class="text" id="p0630">The key to understanding the <i>n</i>-thread labeling algorithm is that the nodes covered by tokens can never form a cycle. As mentioned, two threads can never form a cycle on <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span>, because the shortest cycle in <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> requires three nodes.</p><p class="text" id="p0635">How does the <img alt="Image" height="9" src="images/B9780124159501000112/fx013.jpg" width="29"/>() method work for three threads? When <i>A</i> calls <img alt="Image" height="9" src="images/B9780124159501000112/fx013.jpg" width="29"/>(), if both the other threads have tokens on the same <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> subgraph, then move to a node on the next highest <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> subgraph, the one whose nodes dominate that <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> subgraph. For example, consider the graph <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si70.png" style="vertical-align:middle" width="19"/></span> as illustrated in <a href="#f0075" id="cf0135">Fig. 2.13</a>. We assume an initial acyclic situation in which there is a token <i>A</i> on node 12 (node 2 in subgraph 1) and tokens <i>B</i> and <i>C</i> on nodes 21 and 22 (nodes 1 and 2 in subgraph 2). Token <i>B</i> will move to node 20 to dominate all others. Token <i>C</i> will then move to node 21 to dominate all others, and <i>B</i> and <i>C</i> can continue to cycle in the <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si54.png" style="vertical-align:middle" width="19"/></span> subgraph 2 forever. <span aria-label="Page 39" epub:type="pagebreak" id="page_39" role="doc-pagebreak"/>If <i>A</i> is to move to dominate <i>B</i> and <i>C</i>, it cannot pick a node in subgraph 2 since it is full (any <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si66.png" style="vertical-align:middle" width="19"/></span> subgraph can accommodate at most <i>k</i> tokens). Token <i>A</i> thus moves to node 00. If <i>B</i> now moves, it will choose node 01, <i>C</i> will choose node 10, and so on.</p></section><section><h2 class="h1hd" id="s0065"><a id="st0075"/>2.9 Lower bounds on the number of locations</h2><p class="textfl" id="p0640">The <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock is succinct, elegant, and fair. So why is it not considered practical? The principal drawback is the need to read and write <i>n</i> distinct locations, where <i>n</i> is the maximum number of concurrent threads (which may be very large).</p><p class="text" id="p0645">Is there a clever <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm based on reading and writing memory that avoids this overhead? We now demonstrate that the answer is <i>no</i>. Any deadlock-free mutual exclusion algorithm requires allocating and then reading or writing at least <i>n</i> distinct locations in the worst case. This result is crucial: it motivates us to augment our multiprocessor machines with synchronization operations stronger than reads and writes, and use them as the basis of our mutual exclusion algorithms. We discuss practical mutual exclusion algorithms in later chapters.</p><p class="text" id="p0650">In this section, we examine why this linear bound is inherent. We observe the following limitation of memory accessed solely by <i>read</i> or <i>write</i> instructions (typically called <i>loads</i> and <i>stores</i>): Information written by a thread to a given location may be <i>overwritten</i> (i.e., stored to) without any other thread ever seeing it.</p><p class="text" id="p0655">Our proof requires us to argue about the state of all memory used by a given multithreaded program. An object's <i>state</i> is just the state of its fields. A thread's <i>local state</i> is the state of its program counters and local variables. A <i>global state</i> or <i>system state</i> is the state of all objects, plus the local states of the threads.</p><p class="text" id="p0660"/><div class="boxg1" id="enun0145"><p class="b1num">Definition 2.9.1 </p><div><p class="b1textfl" id="p0665">A <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> object state <i>s</i> is <i>inconsistent</i> in any global state where some thread is in the critical section, but the lock state is compatible with a global state in which no thread is in the critical section or is trying to enter the critical section.</p></div></div><p class="textfl"/><p class="text" id="p0670"/><div class="boxg1" id="enun0150"><p class="b1num">Lemma 2.9.2 </p><div><p class="b1textfl" id="p0675">No deadlock-free <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm can enter an inconsistent state.</p></div></div><p class="textfl"/><p class="text" id="p0680"/><div class="boxg1" id="enun0155"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0685">Suppose the <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> object is in an inconsistent state <i>s</i>, where some thread <i>A</i> is in the critical section. If thread <i>B</i> tries to enter the critical section, it must eventually succeed because the algorithm is deadlock-free and <i>B</i> cannot determine that <i>A</i> is in the critical section, a contradiction. □</p></div></div><p class="textfl"/><p class="text" id="p0690">Any <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm that solves deadlock-free mutual exclusion must have <i>n</i> distinct locations. Here, we consider only the three-thread case, showing that a deadlock-free <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm accessed by three threads must use three distinct locations.</p><p class="text" id="p0695"/><div class="boxg1" id="enun0160"><p class="b1num">Definition 2.9.3 </p><div><p class="b1textfl" id="p0700">A <i>covering state</i> for a <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> object is one in which there is at least one thread about to write to each shared location, but the <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> object's locations “look” like the critical section is empty (i.e., the locations' states appear as if there is no thread either in the critical section or trying to enter the critical section).</p></div></div><p class="textfl"/><p class="text" id="p0705"><span aria-label="Page 40" epub:type="pagebreak" id="page_40" role="doc-pagebreak"/>In a covering state, we say that each thread <i>covers</i> the location it is about to write.</p><p class="text" id="p0710"/><div class="boxg1" id="enun0165"><p class="b1num">Theorem 2.9.4 </p><div><p class="b1textfl" id="p0715">Any <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm that, by reading and writing memory, solves deadlock-free mutual exclusion for three threads must use at least three distinct memory locations.</p></div></div><p class="textfl"/><p class="text" id="p0720"/><div class="boxg1" id="enun0170"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0725">Assume by way of contradiction that we have a deadlock-free <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm for three threads with only two locations. Initially, in state <i>s</i>, no thread is in the critical section or trying to enter. If we run any thread by itself, then it must write to at least one location before entering the critical section, as otherwise it creates an inconsistent state. It follows that every thread must write at least one location before entering. If the shared locations are single-writer locations as in the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock, then it is immediate that three distinct locations are needed.</p><p class="b1text" id="p0730">Now consider multiwriter locations such as elements of the <img alt="Image" height="9" src="images/B9780124159501000112/fx012.jpg" width="39"/> array in Peterson's algorithm (<a href="#f0040" id="cf0140">Fig. 2.6</a>). Assume that we can bring the system to a covering <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> state <i>s</i> where <i>A</i> and <i>B</i> cover distinct locations. Consider the following possible execution starting from state <i>s</i> as depicted in <a href="#f0080" id="cf0145">Fig. 2.14</a>: </p><p class="quote" id="sp0125">Let <i>C</i> run alone. Because the <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> algorithm satisfies the deadlock-free property, <i>C</i> enters the critical section eventually. Then let <i>A</i> and <i>B</i> respectively update their covered locations, leaving the <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> object in state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si73.png" style="vertical-align:middle" width="13"/></span>. <span aria-label="Page 41" epub:type="pagebreak" id="page_41" role="doc-pagebreak"/></p><p class="textfl"> The state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si73.png" style="vertical-align:middle" width="13"/></span> is inconsistent because no thread can tell whether <i>C</i> is in the critical section. Thus, a lock with two locations is impossible.</p><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" height="339" src="images/B9780124159501000112/gr014.jpg" width="413"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.14</span> Contradiction using a covering state for two locations. Initially both locations have the empty value ⊥.</div></figcaption></figure></div><p class="b1text" id="p0735">It remains to show how to maneuver threads <i>A</i> and <i>B</i> into a covering state. Consider an execution in which <i>B</i> runs through the critical section three times. Each time around, it must write to some location, so consider the first location to which it writes when trying to enter the critical section. Since there are only two locations, <i>B</i> must “write first” to the same location twice. Call that location <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si74.png" style="vertical-align:middle" width="22"/></span>.</p><p class="b1text" id="p0740">Let <i>B</i> run until it is poised to write to location <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si74.png" style="vertical-align:middle" width="22"/></span> for the first time. If <i>A</i> runs now, it would enter the critical section, since <i>B</i> has not written anything. <i>A</i> must write to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si75.png" style="vertical-align:middle" width="21"/></span> before entering the critical section. Otherwise, if <i>A</i> writes only to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si74.png" style="vertical-align:middle" width="22"/></span>, then let <i>A</i> enter the critical section, and let <i>B</i> write to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si74.png" style="vertical-align:middle" width="22"/></span> (obliterating <i>A</i>'s last write). The result is an inconsistent state: <i>B</i> cannot tell whether <i>A</i> is in the critical section.</p><p class="b1text" id="p0745">Let <i>A</i> run until it is poised to write to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si75.png" style="vertical-align:middle" width="21"/></span>. This state might not be a covering state because <i>A</i> could have written something to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si74.png" style="vertical-align:middle" width="22"/></span> indicating to thread <i>C</i> that it is trying to enter the critical section. Let <i>B</i> run, obliterating any value <i>A</i> might have written to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si74.png" style="vertical-align:middle" width="22"/></span>, entering and leaving the critical section at most three times, and halting just before its second write to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si74.png" style="vertical-align:middle" width="22"/></span>. Note that every time <i>B</i> enters and leaves the critical section, whatever it wrote to the locations is no longer relevant.</p><p class="b1text" id="p0750">In this state, <i>A</i> is about to write to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si75.png" style="vertical-align:middle" width="21"/></span>, <i>B</i> is about to write to <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si74.png" style="vertical-align:middle" width="22"/></span>, and the locations are consistent with no thread trying to enter or in the critical section, as required in a covering state. <a href="#f0085" id="cf0150">Fig. 2.15</a> illustrates this scenario. □</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="343" src="images/B9780124159501000112/gr015.jpg" width="482"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.15</span> Reaching a covering state. In the initial covering state for <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mtext mathvariant="italic">L</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">B</mml:mtext></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000112/si76.png" style="vertical-align:middle" width="20"/></span> both locations have the empty value ⊥.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0755">This line of argument can be extended to show that <i>n</i>-thread deadlock-free mutual exclusion requires <i>n</i> distinct locations. The <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> and <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> locks are thus optimal (within a constant factor). However, the need to allocate <i>n</i> locations per <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> makes them impractical.</p><p class="text" id="p0760">This proof shows the inherent limitation of read and write operations: Information written by a thread may be overwritten without any other thread ever reading it. We will recall this limitation when we discuss other algorithms.</p><p class="text" id="p0765">As discussed in later chapters, modern machine architectures provide specialized instructions that overcome the “overwriting” limitation of read and write instructions, allowing <i>n</i>-thread <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> implementations that use only a constant number of memory locations. However, making effective use of these instructions to solve mutual exclusion is far from trivial.<span aria-label="Page 42" epub:type="pagebreak" id="page_42" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0070"><a id="st0080"/>2.10 Chapter notes</h2><p class="textfl" id="p0770">Isaac Newton's ideas about the flow of time appear in his famous <i>Principia</i> <a epub:type="noteref" href="#br0675" id="cf0155" role="doc-noteref">[135]</a>. The “→” formalism is due to Leslie Lamport <a epub:type="noteref" href="#br0505" id="cf0160" role="doc-noteref">[101]</a>. The first three algorithms in this chapter are due to Gary Peterson, who published them in a two-page paper in 1981 <a epub:type="noteref" href="#br0690" id="cf0165" role="doc-noteref">[138]</a>. The <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock presented here is a simplification of the original Bakery algorithm due to Leslie Lamport <a epub:type="noteref" href="#br0500" id="cf0170" role="doc-noteref">[100]</a>. The sequential timestamp algorithm is due to Amos Israeli and Ming Li <a epub:type="noteref" href="#br0425" id="cf0175" role="doc-noteref">[85]</a>, who invented the notion of a bounded timestamping system. Danny Dolev and Nir Shavit <a epub:type="noteref" href="#br0195" id="cf0180" role="doc-noteref">[39]</a> invented the first bounded concurrent timestamping system. Other bounded timestamping schemes include ones by Sibsankar Haldar and Paul Vitányi <a epub:type="noteref" href="#br0280" id="cf0185" role="doc-noteref">[56]</a> and Cynthia Dwork and Orli Waarts <a epub:type="noteref" href="#br0210" id="cf0190" role="doc-noteref">[42]</a>. The lower bound on the number of lock fields is due to Jim Burns and Nancy Lynch <a epub:type="noteref" href="#br0120" id="cf0195" role="doc-noteref">[24]</a>. Their proof technique, called a <i>covering argument</i>, has since been widely used to prove lower bounds in distributed computing. Readers interested in further reading can find a historical survey of mutual exclusion algorithms in a classic book by Michel Raynal <a epub:type="noteref" href="#br0735" id="cf0200" role="doc-noteref">[147]</a>.</p></section><section><h2 class="h1hd" id="s0075"><a id="st0085"/>2.11 Exercises</h2><p class="textfl" id="p0775"/><div class="boxg1" id="enun0175"><p class="b1num">Exercise 2.1 </p><div><p class="b1textfl" id="p0780">A mutual exclusion algorithm provides <i>r-bounded waiting</i> if there is a way to define a doorway such that if <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">→</mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000112/si77.png" style="vertical-align:middle" width="68"/></span>, then <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mtext mathvariant="italic">CS</mml:mtext></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mspace width="0.2em"/><mml:mi>j</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">→</mml:mo><mml:msubsup><mml:mrow><mml:mtext mathvariant="italic">CS</mml:mtext></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000112/si78.png" style="vertical-align:middle" width="94"/></span>. Does the <img alt="Image" height="9" src="images/B9780124159501000112/fx027.jpg" width="51"/> algorithm provide <i>r</i>-bounded waiting for some value of <i>r</i>?</p></div></div><p class="textfl"/><p class="text" id="p0785"/><div class="boxg1" id="enun0180"><p class="b1num">Exercise 2.2 </p><div><p class="b1textfl" id="p0790">Why must we define a <i>doorway</i> section, rather than defining first-come-first-served in a mutual exclusion algorithm based on the order in which the first instruction in the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>() method was executed? Argue your answer in a case-by-case manner based on the nature of the first instruction executed by the <img alt="Image" height="9" src="images/B9780124159501000112/fx004.jpg" width="25"/>(): a read or a write, to separate locations or the same location.</p></div></div><p class="textfl"/><p class="text" id="p0795"><span aria-label="Page 43" epub:type="pagebreak" id="page_43" role="doc-pagebreak"/></p><div class="boxg1" id="enun0185"><p class="b1num">Exercise 2.3 </p><div><p class="b1textfl" id="p0800">Programmers at the Flaky Computer Corporation designed the protocol shown in <a href="#f0090" id="cf0205">Fig. 2.16</a> to achieve <i>n</i>-thread mutual exclusion. For each question, either sketch a proof, or display an execution where it fails.</p><div><ul><li class="b1bulllist" id="u0050">•  Does this protocol satisfy mutual exclusion?</li><li class="b1bulllist" id="u0055">•  Is this protocol starvation-free?</li><li class="b1bulllist" id="u0060">•  Is this protocol deadlock-free?</li><li class="b1bulllist" id="u0065">•  Is this protocol livelock-free?</li></ul></div><p class="b1textfl"/><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="257" src="images/B9780124159501000112/gr016.jpg" width="206"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.16</span> The Flaky lock used in Exercise <a href="#enun0185" id="cf0010">2.3</a>.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0825"/><div class="boxg1" id="enun0190"><p class="b1num">Exercise 2.4 </p><div><p class="b1textfl" id="p0830">Show that the <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> lock allows some threads to overtake others an arbitrary number of times.</p></div></div><p class="textfl"/><p class="text" id="p0835"/><div class="boxg1" id="enun0195"><p class="b1num">Exercise 2.5 </p><div><p class="b1textfl" id="p0840">Consider a variant of Peterson's algorithm, where we change the unlock method to be as shown in <a href="#f0095" id="cf0210">Fig. 2.17</a>. Does the modified algorithm satisfy deadlock-freedom? What about starvation-freedom? Sketch a proof showing why it satisfies both properties, or display an execution where it fails.</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="93" src="images/B9780124159501000112/gr017.jpg" width="185"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.17</span> The revised unlock method for Peterson's algorithm used in Exercise <a href="#enun0195" id="cf0015">2.5</a>.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0845"><span aria-label="Page 44" epub:type="pagebreak" id="page_44" role="doc-pagebreak"/></p><div class="boxg1" id="enun0200"><p class="b1num">Exercise 2.6 </p><div><p class="b1textfl" id="p0850">Another way to generalize the two-thread Peterson lock is to arrange a number of two-thread Peterson locks in a binary tree. Suppose <i>n</i> is a power of two. Each thread is assigned a leaf lock which it shares with one other thread. Each lock treats one thread as thread 0 and the other as thread 1.</p><p class="b1text" id="p0855">In the tree-lock's acquire method, the thread acquires every two-thread Peterson lock from that thread's leaf to the root. The tree-lock's release method for the tree-lock unlocks each of the two-thread Peterson locks that thread has acquired, from the root back to its leaf. At any time, a thread can be delayed for a finite duration. (In other words, threads can take naps, or even vacations, but they do not drop dead.) For each of the following properties, either sketch a proof that it holds, or describe a (possibly infinite) execution where it is violated:</p><div><ol><li class="b1numlist" id="o0040">1.  mutual exclusion,</li><li class="b1numlist" id="o0045">2.  freedom from deadlock,</li><li class="b1numlist" id="o0050">3.  freedom from starvation.</li></ol></div><p class="b1textfl"/><p class="b1text" id="p0875">Is there an upper bound on the number of times the tree-lock can be acquired and released between the time a thread starts acquiring the tree-lock and when it succeeds?</p></div></div><p class="textfl"/><p class="text" id="p0880"/><div class="boxg1" id="enun0205"><p class="b1num">Exercise 2.7 </p><div><p class="b1textfl" id="p0885">The <i>ℓ</i>-exclusion problem is a variant of the starvation-free mutual exclusion problem with two changes: Up to <i>ℓ</i> threads may be in the critical section at the same time, and fewer than <i>ℓ</i> threads might fail (by halting) in the critical section.</p><p class="b1text" id="p0890">An implementation must satisfy the following conditions: </p><p class="definition" id="p0895"><span class="def_term"><i>ℓ</i><b>-Exclusion:</b></span> At any time, at most <i>ℓ</i> threads are in the critical section.</p><p class="definition" id="p0900"><span class="def_term"><i>ℓ</i><b>-Starvation-freedom:</b></span> As long as fewer than <i>ℓ</i> threads are in the critical section, some thread that wants to enter the critical section will eventually succeed (even if some threads in the critical section have halted).</p><p class="textfl"> Modify the <i>n</i>-thread <img alt="Image" height="9" src="images/B9780124159501000112/fx037.jpg" width="38"/> mutual exclusion algorithm to solve <i>ℓ</i>-exclusion.</p></div></div><p class="textfl"/><p class="text" id="p0905"/><div class="boxg1" id="enun0210"><p class="b1num">Exercise 2.8 </p><div><p class="b1textfl" id="p0910">In practice, almost all lock acquisitions are uncontended, so the most practical measure of a lock's performance is the number of steps needed for a thread to acquire a lock when no other thread is concurrently trying to acquire the lock.</p><p class="b1text" id="p0915">Scientists at Cantaloupe-Melon University have devised the following “wrapper” for an arbitrary lock, shown in <a href="#f0100" id="cf0215">Fig. 2.18</a>. They claim that if the base <img alt="Image" height="9" src="images/B9780124159501000112/fx003.jpg" width="25"/> class provides mutual exclusion and is starvation-free, so does the <img alt="Image" height="9" src="images/B9780124159501000112/fx058.jpg" width="51"/> lock, but it can be acquired in a constant number of steps in the absence of contention. Sketch an argument why they are right, or give a counterexample.</p><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="257" src="images/B9780124159501000112/gr018.jpg" width="316"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.18</span> Fast-path mutual exclusion algorithm used in Exercise <a href="#enun0210" id="cf0020">2.8</a>.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0920"/><div class="boxg1" id="enun0215"><p class="b1num">Exercise 2.9 </p><div><p class="b1textfl" id="p0925">Suppose <i>n</i> threads call the <img alt="Image" height="9" src="images/B9780124159501000112/fx059.jpg" width="32"/>() method of the <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> class shown in <a href="#f0105" id="cf0220">Fig. 2.19</a>. Prove the following:</p><div><ul><li class="b1bulllist" id="u0070">•  At most one thread gets the value <img alt="Image" height="9" src="images/B9780124159501000112/fx061.jpg" width="26"/>.</li><li class="b1bulllist" id="u0075">•  At most <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span> threads get the value <img alt="Image" height="9" src="images/B9780124159501000112/fx062.jpg" width="25"/>.</li><li class="b1bulllist" id="u0080">•  At most <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000112/si31.png" style="vertical-align:middle" width="37"/></span> threads get the value <img alt="Image" height="9" src="images/B9780124159501000112/fx063.jpg" width="32"/>. (This is <i>not</i> symmetric with the proof for the previous item.) <span aria-label="Page 45" epub:type="pagebreak" id="page_45" role="doc-pagebreak"/></li></ul></div><p class="b1textfl"/><div class="pageavoid"><figure class="fig" id="f0105"><img alt="Image" height="290" src="images/B9780124159501000112/gr019.jpg" width="236"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.19</span> The <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> class implementation for <a href="#enun0215" id="cf0025">Exercise 2.9</a>.</div></figcaption></figure></div></div></div><p class="textfl"/><p class="text" id="p0945"/><div class="boxg1" id="enun0220"><p class="b1num">Exercise 2.10 </p><div><p class="b1textfl" id="p0950">So far, we have assumed that all <i>n</i> threads have small unique IDs. Here is one way to assign small unique IDs to threads. Arrange <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> objects in a triangular matrix, where each <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> is given <span aria-label="Page 46" epub:type="pagebreak" id="page_46" role="doc-pagebreak"/>an ID as shown in <a href="#f0110" id="cf0225">Fig. 2.20</a>. Each thread starts by visiting <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> 0. If it gets <img alt="Image" height="9" src="images/B9780124159501000112/fx061.jpg" width="26"/>, it stops. If it gets <img alt="Image" height="9" src="images/B9780124159501000112/fx063.jpg" width="32"/>, it visits 1, and if it gets <img alt="Image" height="9" src="images/B9780124159501000112/fx062.jpg" width="25"/>, it visits 2. In general, if a thread gets <img alt="Image" height="9" src="images/B9780124159501000112/fx061.jpg" width="26"/>, it stops. If it gets <img alt="Image" height="9" src="images/B9780124159501000112/fx063.jpg" width="32"/>, it visits the next <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> on that row, and if it gets <img alt="Image" height="9" src="images/B9780124159501000112/fx062.jpg" width="25"/>, it visits the next <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> in that column. Each thread takes the ID of the <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> object where it stops.</p><div class="pageavoid"><figure class="fig" id="f0110"><img alt="Image" height="140" src="images/B9780124159501000112/gr020.jpg" width="144"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.20</span> Array layout for <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> objects for <a href="#enun0220" id="cf0030">Exercise 2.10</a>.</div></figcaption></figure></div><p class="b1text" id="p0955"/><div><ul><li class="b1bulllist" id="u0085">•  Prove that each thread eventually stops at some <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> object.</li><li class="b1bulllist" id="u0090">•  How many <img alt="Image" height="9" src="images/B9780124159501000112/fx060.jpg" width="46"/> objects do you need in the array if you know in advance the total number <i>n</i> of threads?</li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0970"/><div class="boxg1" id="enun0225"><p class="b1num">Exercise 2.11 </p><div><p class="b1textfl" id="p0975">Prove, by way of a counterexample, that the sequential timestamp system <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000112/si70.png" style="vertical-align:middle" width="19"/></span>, starting in a valid state (with no cycles among the labels), does not work for three threads in the concurrent case. Note that it is not a problem to have two identical labels since one can break such ties using thread IDs. The counterexample should display a state of the execution where three labels are not totally ordered.</p></div></div><p class="textfl"/><p class="text" id="p0980"/><div class="boxg1" id="enun0230"><p class="b1num">Exercise 2.12 </p><div><p class="b1textfl" id="p0985">The sequential timestamp system <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000112/si71.png" style="vertical-align:middle" width="19"/></span> had a range of <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si79.png" style="vertical-align:middle" width="41"/></span> different possible label values. Design a sequential timestamp system that requires only <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000112/si80.png" style="vertical-align:middle" width="50"/></span> labels. Note that in a timestamp system, one may look at all the labels to choose a new label, yet once a label is chosen, it should be comparable to any other label without knowing what the other labels in the system are. Hint: Think of the labels in terms of their bit representation.</p></div></div><p class="textfl"/><p class="text" id="p0990"/><div class="boxg1" id="enun0235"><p class="b1num">Exercise 2.13 </p><div><p class="b1textfl" id="p0995">Give Java code to implement the <img alt="Image" height="11" src="images/B9780124159501000112/fx064.jpg" width="59"/> interface of <a href="#f0065" id="cf0230">Fig. 2.11</a> using unbounded labels. Then, show how to replace the pseudocode of the <img alt="Image" height="11" src="images/B9780124159501000112/fx054.jpg" width="39"/> lock of <a href="#f0060" id="cf0235">Fig. 2.10</a> using your <img alt="Image" height="11" src="images/B9780124159501000112/fx064.jpg" width="59"/> Java code.</p></div></div><p class="textfl"/><p class="text" id="p1000"/><div class="boxg1" id="enun0240"><p class="b1num">Exercise 2.14 </p><div><p class="b1textfl" id="p1005">We saw earlier the following theorem on the bounds of shared memory for mutual exclusion: Any deadlock-free mutual exclusion algorithm for <i>n</i> threads must use at least <i>n</i> shared registers. For this exercise, we examine a new algorithm that shows that the space lower bound of the above theorem is tight. Specifically, we will show the following: </p><p class="quote" id="sp0130"><b>Theorem</b>: There is a deadlock-free mutual exclusion algorithm for <i>n</i> threads that uses exactly <i>n</i> shared bits. <span aria-label="Page 47" epub:type="pagebreak" id="page_47" role="doc-pagebreak"/></p><p class="textfl"> To prove this new theorem, we study the <img alt="Image" height="9" src="images/B9780124159501000112/fx065.jpg" width="39"/> algorithm shown in <a href="#f0115" id="cf0240">Fig. 2.21</a>. This algorithm, developed independently by J. E. Burns and L. Lamport, uses exactly <i>n</i> bits to achieve mutual exclusion; that is, it uses the minimum possible shared space.</p><div class="pageavoid"><figure class="fig" id="f0115"><img alt="Image" height="404" src="images/B9780124159501000112/gr021.jpg" width="421"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 2.21</span> Pseudocode for the <img alt="Image" height="9" src="images/B9780124159501000112/fx065.jpg" width="39"/> algorithm.</div></figcaption></figure></div><p class="b1text" id="p1010">The <img alt="Image" height="9" src="images/B9780124159501000112/fx065.jpg" width="39"/> algorithm works as follows: First, a thread indicates that it wants to acquire the lock by setting its bit to <i>true</i>. Then, it loops and reads the bits of all threads with smaller IDs than its own. If all of these bits are <i>false</i> (while its own bit is <i>true</i>), then the thread exits the loop. Otherwise, the thread sets its bit to <i>false</i>, waits until the bit it found to be <i>true</i> becomes <i>false</i>, and starts all over again. Afterwards, the thread reads the bits of all threads that have IDs greater than its own, and waits until they are all <i>false</i>. Once this check passes, the thread can safely enter the critical section.</p><div><ul><li class="b1bulllist" id="u0095">•  Prove that the <img alt="Image" height="9" src="images/B9780124159501000112/fx065.jpg" width="39"/> algorithm satisfies mutual exclusion.</li><li class="b1bulllist" id="u0100">•  Prove that the <img alt="Image" height="9" src="images/B9780124159501000112/fx065.jpg" width="39"/> algorithm is deadlock-free.</li></ul></div><p class="b1textfl"/></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0615"><h2 class="reftitle" id="st0090">Bibliography</h2><p class="reflist1" epub:type="biblioentry footnote" id="br0120" role="doc-biblioentry">[24] James E. Burns, Nancy A. Lynch,  Bounds on shared memory for mutual exclusion,   <cite><i>Information and Computation</i></cite> December 1993;107(2):171–184.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0195" role="doc-biblioentry">[39] Danny Dolev, Nir Shavit,  Bounded concurrent time-stamping,   <cite><i>SIAM Journal on Computing</i></cite> 1997;26(2):418–455.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0210" role="doc-biblioentry">[42] Cynthia Dwork, Orli Waarts,  Simple and efficient bounded concurrent timestamping and the traceable use abstraction,   <cite><i>Journal of the ACM</i></cite> 1999;46(5):633–666.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0280" role="doc-biblioentry">[56] Sibsankar Haldar, Paul Vitányi,  Bounded concurrent timestamp systems using vector clocks,   <cite><i>Journal of the ACM</i></cite> 2002;49(1):101–126.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0425" role="doc-biblioentry">[85] Amos Israeli, Ming Li,  Bounded time stamps,   <cite><i>Distributed Computing</i></cite> 1993;6(5):205–209.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0500" role="doc-biblioentry">[100] Leslie Lamport,  A new solution of Dijkstra's concurrent programming problem,   <cite><i>Communications of the ACM</i></cite> 1974;17(5):543–545.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0505" role="doc-biblioentry">[101] Leslie Lamport,  Time, clocks, and the ordering of events,   <cite><i>Communications of the ACM</i></cite> July 1978;21(7):558–565.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0675" role="doc-biblioentry">[135] Isaac Newton, I. Bernard Cohen (Translator), Anne Whitman (Translator),  <i>The Principia: Mathematical Principles of Natural Philosophy</i>.  University of California Press; 1999.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0690" role="doc-biblioentry">[138] Gary Peterson,  Myths about the mutual exclusion problem,   <cite><i>Information Processing Letters</i></cite> June 1981;12(3):115–116.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0735" role="doc-biblioentry">[147] M. Raynal,  <i>Algorithms for Mutual Exclusion</i>.  Cambridge, MA: The MIT Press; 1986.</p></div></section></footer></section></body></html>