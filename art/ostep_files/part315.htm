<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>30.3 Covering Conditions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part314.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part316.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">30.3 Covering Conditions</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We’ll now look at one more example of how condition variables can be used. This code study is drawn from Lampson and Redell’s paper on Pilot [LR80], the same group who first implemented the <b>Mesa semantics </b>described above (the language they used was Mesa, hence the name).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The problem they ran into is best shown via simple example, in this case in a simple multi-threaded memory allocation library. Figure <span style=" color: #00AEEF;">30.11 </span>shows a code snippet which demonstrates the issue.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As you might see in the code, when a thread calls into the memory allocation code, it might have to wait in order for more memory to be- come free. Conversely, when a thread frees memory, it signals that more memory is free. However, our code above has a problem: which waiting thread (there can be more than one) should be woken up?</p><p class="s43" style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;"><span class="p">Consider the following scenario. Assume there are zero bytes free; thread </span>T<span class="s56">a</span> <span class="p">calls </span><span class="s41">allocate(100)</span><span class="p">, followed by thread </span>T<span class="s56">b</span> <span class="p">which asks for less memory by calling </span><span class="s41">allocate(10)</span><span class="p">. Both </span>T<span class="s56">a</span> <span class="p">and </span>T<span class="s56">b</span> <span class="p">thus wait on the condition and go to sleep; there aren’t enough free bytes to satisfy either of these requests.</span></p><p class="s61" style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">At that point, assume a third thread, <span class="s57">T</span><span class="s58">c</span>, calls <span class="s147">free(50)</span>. Unfortu- <span class="p">nately, when it calls signal to wake a waiting thread, it might not wake the correct waiting thread, </span><span class="s43">T</span><span class="s56">b</span><span class="p">, which is waiting for only 10 bytes to be </span>freed; <span class="s57">T</span><span class="s58">a </span>should remain waiting, as not enough memory is yet free. Thus, <span class="p">the code in the figure does not work, as the thread waking other threads does not know which thread (or threads) to wake up.</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_389.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_390.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_391.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_392.png"/></span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The solution suggested by Lampson and Redell is straightforward: re- place the <span class="s41">pthread cond signal() </span>call in the code above with a call to <span class="s41">pthread cond broadcast()</span>, which wakes up <i>all </i>waiting threads. By doing so, we guarantee that any threads that should be woken are. The downside, of course, can be a negative performance impact, as we might needlessly wake up many other waiting threads that shouldn’t (yet) be awake. Those threads will simply wake up, re-check the condition, and then go immediately back to sleep.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">// how many bytes of the heap are free?</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2  <span class="s38">int bytesLeft = MAX_HEAP_SIZE;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">3</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38">// need lock and condition too</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5  <span class="s38">cond_t c;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6  <span class="s38">mutex_t m;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">7</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">8  <span class="s38">void </span><span class="s39">*</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">9  <span class="s38">allocate(int size) {</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10    <span class="s38">Pthread_mutex_lock(&amp;m);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11    <span class="s38">while (bytesLeft &lt; size)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">12       <span class="s38">Pthread_cond_wait(&amp;c, &amp;m);</span></p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">13     </span>void <span class="s39">*</span>ptr = ...; // get mem from heap</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">14    <span class="s38">bytesLeft -= size;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">15    <span class="s38">Pthread_mutex_unlock(&amp;m);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">16    <span class="s38">return ptr;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">17  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">18</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">19  </span>void free(void <span class="s39">*</span>ptr, int size) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">20    <span class="s38">Pthread_mutex_lock(&amp;m);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">21    <span class="s38">bytesLeft += size;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">22    <span class="s38">Pthread_cond_signal(&amp;c); // whom to signal??</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">23    <span class="s38">Pthread_mutex_unlock(&amp;m);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">24  <span class="s38">}</span></p><p style="padding-top: 5pt;padding-left: 115pt;text-indent: 0pt;text-align: left;">Figure 30.11: <b>Covering Conditions: An Example</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Lampson and Redell call such a condition a <b>covering condition</b>, as it covers all the cases where a thread needs to wake up (conservatively); the cost, as we’ve discussed, is that too many threads might be woken. The astute reader might also have noticed we could have used this ap- proach earlier (see the producer/consumer problem with only a single condition variable). However, in that case, a better solution was avail- able to us, and thus we used it. In general, if you find that your program only works when you change your signals to broadcasts (but you don’t think it should need to), you probably have a bug; fix it! But in cases like the memory allocator above, broadcast may be the most straightforward solution available.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part314.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part316.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
