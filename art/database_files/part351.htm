<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.5  Buffer Management</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part350.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part352.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark399">19.5  </a><span style=" color: #00AEEF;">Buffer Management</span><a name="bookmark439">&zwnj;</a></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In this section, we consider several subtle details that are essential to the implementa- tion of a crash-recovery scheme that ensures data consistency and imposes a minimal amount of overhead on interactions with the database.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">19.5.1 Log-Record Buffering</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">So far, we have assumed that every log record is output to stable storage at the time it is created. This assumption imposes a high overhead on system execution for several reasons: Typically, output to stable storage is in units of blocks. In most cases, a log record is much smaller than a block. Thus, the output of each log record translates to a much larger output at the physical level. Furthermore, as we saw in Section 19.2.1, the output of a block to stable storage may involve several output operations at the physical level.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The cost of outputting a block to stable storage is suﬃciently high that it is desirable to output multiple log records at once. To do so, we write log records to a log buﬀer in main memory, where they stay temporarily until they are output to stable storage. Multiple log records can be gathered in the log buﬀer and output to stable storage in a single output operation. The order of log records in the stable storage must be exactly the same as the order in which they were written to the log buﬀer.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As a result of log buﬀering, a log record may reside in only main memory (volatile storage) for a considerable time before it is output to stable storage. Since such log records are lost if the system crashes, we must impose additional requirements on the recovery techniques to ensure transaction atomicity:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 107pt;text-indent: -16pt;line-height: 70%;text-align: justify;"><span class="s39">• </span><span class="s40">Transaction </span>T<span class="s97">i </span><span class="p">enters the commit state after the </span><span class="s83">&lt;</span>T<span class="s97">i </span><span class="s49">commit</span><span class="s83">&gt; </span><span class="p">log record has been output to stable storage.</span></p><p class="s83" style="padding-top: 8pt;padding-left: 107pt;text-indent: -16pt;line-height: 70%;text-align: justify;"><span class="s39">• </span><span class="s40">Before the </span>&lt;<span class="s13">T</span><span class="s145">i </span><span class="s49">commit</span>&gt; <span class="p">log record can be output to stable storage, all log records pertaining to transaction </span><span class="s13">T</span><span class="s145">i </span><span class="p">must have been output to stable storage.</span></p><p class="s39" style="padding-top: 2pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Before a block of data in main memory can be output to the database (in non- volatile storage), all log records pertaining to data in that block must have been output to stable storage.</span></p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">This rule is called the <span class="s63">write-ahead logging (WAL) </span>rule. (Strictly speaking, the <span class="s44">WAL </span>rule requires only that the undo information in the log has been output to sta- ble storage, and it permits the redo information to be written later. The diﬀerence is relevant in systems where undo information and redo information are stored in separate log records.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">The three rules state situations in which certain log records <i>must </i>have been output to stable storage. There is no problem resulting from the output of log records <i>earlier </i>than necessary. Thus, when the system ﬁnds it necessary to output a log record to</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">stable storage, it outputs an entire block of log records, if there are enough log records in main memory to ﬁll a block. If there are insuﬃcient log records to ﬁll the block, all log records in main memory are combined into a partially full block and are output to stable storage.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">Writing the buﬀered log to disk is sometimes referred to as a <span class="s63">log force</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">19.5.2 Database Buffering</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">In Section 19.2.2, we described the use of a two-level storage hierarchy. The system stores the database in non-volatile storage (disk), and brings blocks of data into main memory as needed. Since main memory is typically much smaller than the entire database, it may be necessary to overwrite a block <i>B</i><span class="s98">1</span> in main memory when another block <i>B</i><span class="s98">2</span> needs to be brought into memory. If <i>B</i><span class="s98">1</span> has been modiﬁed, <i>B</i><span class="s98">1</span> must be output prior to the input of <i>B</i><span class="s98">2</span>. As discussed in Section 13.5.1 this storage hierarchy is similar to the standard operating-system concept of <i>virtual memory</i>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">One might expect that transactions would force-output all modiﬁed blocks to disk when they commit. Such a policy is called the <span class="s63">force </span>policy. The alternative, the <span class="s63">no-force </span>policy, allows a transaction to commit even if it has modiﬁed some blocks that have not yet been written back to disk. All the recovery algorithms described in this chapter work correctly even with the no-force policy. The no-force policy allows faster commit of transactions; moreover it allows multiple updates to accumulate on a block before it is output to stable storage, which can reduce the number of output operations greatly for frequently updated blocks. As a result, the standard approach taken by most systems is the no-force policy.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Similarly, one might expect that blocks modiﬁed by a transaction that is still active should not be written to disk. This policy is called the <span class="s63">no-steal </span>policy. The alternative, the <span class="s63">steal </span>policy, allows the system to write modiﬁed blocks to disk even if the transac- tions that made those modiﬁcations have not all committed. As long as the write-ahead logging rule is followed, all the recovery algorithms we study in the chapter work cor- rectly even with the steal policy. Further, the no-steal policy does not work with trans- actions that perform a large number of updates, since the buﬀer may get ﬁlled with updated pages that cannot be evicted to disk, and the transaction cannot then proceed. As a result, the standard approach taken by most systems is the steal policy.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To illustrate the need for the write-ahead logging requirement, consider our banking example with transactions <i>T</i><span class="s98">0</span> and <i>T</i><span class="s98">1</span>. Suppose that the state of the log is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s83" style="padding-left: 261pt;text-indent: 0pt;line-height: 17pt;text-align: left;">&lt;<span class="s13">T</span><span class="s98">0</span><span class="p"> </span><span class="s49">start</span>&gt;</p><p class="s13" style="padding-left: 261pt;text-indent: 0pt;line-height: 17pt;text-align: left;"><span class="s83">&lt;</span>T<span class="s98">0</span><span class="p">, </span>A<span class="p">, 1000, 950</span><span class="s83">&gt;</span></p><p style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">and that transaction <i>T</i><span class="s98">0</span> issues a <span class="s49">read</span>(<i>B</i>). Assume that the block on which <i>B </i>resides is not in main memory and that main memory is full. Suppose that the block on which <i>A </i>resides is chosen to be output to disk. If the system outputs this block to disk and then a crash occurs, the values in the database for accounts <i>A</i>, <i>B</i>, and <i>C </i>are $950, $2000, and</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">$700, respectively. This database state is inconsistent. However, because of the <span class="s44">WAL</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">requirements, the log record:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 230pt;text-indent: 0pt;text-align: justify;"><span class="s83">&lt;</span>T<span class="s98">0</span><span class="p">, </span>A<span class="p">, 1000, 950</span><span class="s83">&gt;</span></p><p style="padding-top: 9pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">must be output to stable storage prior to output of the block on which <i>A </i>resides. The system can use the log record during recovery to bring the database back to a consistent state.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When a block <i>B</i><span class="s98">1</span> is to be output to disk, all log records pertaining to data in <i>B</i><span class="s98">1</span> must be output to stable storage before <i>B</i><span class="s98">1</span> is output. It is important that no writes to the block <i>B</i><span class="s98">1</span> be in progress while the block is being output, since such a write could violate the write-ahead logging rule. We can ensure that there are no writes in progress by using a special means of locking:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Before a transaction performs a write on a data item, it acquires an exclusive lock on the block in which the data item resides. The lock is released immediately after the update has been performed.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">The following sequence of actions is taken when a block is to be output:</span></p><p class="s50" style="padding-top: 9pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: left;">° <span class="s51">Obtain an exclusive lock on the block, to ensure that no transaction is perform- ing a write on the block.</span></p><p class="s50" style="padding-top: 6pt;padding-left: 113pt;text-indent: 0pt;line-height: 15pt;text-align: left;">° <span class="s51">Output log records to stable storage until all log records pertaining to block </span><span class="s13">B</span><span class="s98">1</span></p><p style="padding-left: 122pt;text-indent: 0pt;line-height: 11pt;text-align: left;">have been output.</p><p class="s50" style="padding-top: 6pt;padding-left: 113pt;text-indent: 0pt;text-align: left;">° <span class="s51">Output block </span><span class="s13">B</span><span class="s130">1 </span><span class="s94">to disk.</span></p><p class="s50" style="padding-top: 2pt;padding-left: 113pt;text-indent: 0pt;text-align: left;">° <span class="s51">Release the lock once the block output has completed.</span></p><p style="padding-top: 10pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Locks on buﬀer blocks are unrelated to locks used for concurrency control of trans- actions, and releasing them in a non-two-phase manner does not have any implications on transaction serializability. These locks, and other similar locks that are held for a short duration, are often referred to as <span class="s63">latches</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Locks on buﬀer blocks can also be used to ensure that buﬀer blocks are not up- dated, and log records are not generated, while a checkpoint is in progress. This re- striction may be enforced by acquiring exclusive locks on all buﬀer blocks, as well as an exclusive lock on the log, before the checkpoint operation is performed. These locks can be released as soon as the checkpoint operation has completed.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Database systems usually have a process that continually cycles through the buﬀer blocks, outputting modiﬁed buﬀer blocks back to disk. The above locking protocol must of course be followed when the blocks are output. As a result of continuous output of modiﬁed blocks, the number of <span class="s63">dirty blocks </span>in the buﬀer, that is, blocks that have been modiﬁed in the buﬀer but have not been subsequently output, is minimized. Thus, the number of blocks that have to be output during a checkpoint is minimized; further,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">when a block needs to be evicted from the buﬀer, it is likely that there will be a non- dirty block available for eviction, allowing the input to proceed immediately instead of waiting for an output to complete.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">19.5.3 Operating System Role in Buffer Management</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We can manage the database buﬀer by using one of two approaches:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span class="p">The database system reserves part of main memory to serve as a buﬀer that it, rather than the operating system, manages. The database system manages data- block transfer in accordance with the requirements in Section 19.5.2.</span></p><p style="padding-left: 145pt;text-indent: 14pt;text-align: justify;">This approach has the drawback of limiting ﬂexibility in the use of main mem- ory. The buﬀer must be kept small enough that other applications have suﬃcient main memory available for their needs. However, even when the other applica- tions are not running, the database will not be able to make use of all the available memory. Likewise, non-database applications may not use that part of main mem- ory reserved for the database buﬀer, even if some of the pages in the database buﬀer are not being used.</p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span class="p">The database system implements its buﬀer within the virtual memory provided by the operating system. Since the operating system knows about the memory requirements of all processes in the system, ideally it should be in charge of deciding what buﬀer blocks must be force-output to disk, and when. But, to en- sure the write-ahead logging requirements in Section 19.5.1, the operating system should not write out the database buﬀer pages itself, but instead should request the database system to force-output the buﬀer blocks. The database system in turn would force-output the buﬀer blocks to the database, after writing relevant log records to stable storage.</span></p><p style="padding-left: 145pt;text-indent: 15pt;line-height: 13pt;text-align: justify;">Unfortunately, almost all current-generation operating systems retain com- plete control of virtual memory. The operating system reserves space on disk for storing virtual-memory pages that are not currently in main memory; this space is called <span class="s63">swap space</span>. If the operating system decides to output a block <i>B</i><span class="s97">x</span>, that block is output to the swap space on disk, and there is no way for the database system to get control of the output of buﬀer blocks.</p><p style="padding-left: 145pt;text-indent: 16pt;text-align: right;">Therefore, if the database buﬀer is in virtual memory, transfers between database ﬁles and the buﬀer in virtual memory must be managed by the database system, which enforces the write-ahead logging requirements that we discussed.</p><p style="padding-left: 145pt;text-indent: 14pt;line-height: 93%;text-align: justify;">This approach may result in extra output of data to disk. If a block <i>B</i><span class="s97">x </span>is output by the operating system, that block is not output to the database. Instead, it is output to the swap space for the operating system’s virtual memory. When the database system needs to output <i>B</i><span class="s145">x</span>, the operating system may need ﬁrst to input <i>B</i><span class="s145">x </span>from its swap space. Thus, instead of a single output of <i>B</i><span class="s145">x</span>, there may be two outputs of <i>B</i><span class="s97">x </span>(one by the operating system, and one by the database system) and one extra input of <i>B</i><span class="s97">x</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;"><a name="bookmark400">Although both approaches suﬀer from some drawbacks, one or the other must be chosen unless the operating system is designed to support the requirements of database logging.</a><a name="bookmark440">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">19.5.4 Fuzzy Checkpointing</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The checkpointing technique described in Section 19.3.6 requires that all updates to the database be temporarily suspended while the checkpoint is in progress. If the number of pages in the buﬀer is large, a checkpoint may take a long time to ﬁnish, which can result in an unacceptable interruption in processing of transactions.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">To avoid such interruptions, the checkpointing technique can be modiﬁed to permit updates to start once the <span class="s49">checkpoint </span>record has been written, but before the modiﬁed buﬀer blocks are written to disk. The checkpoint thus generated is a <span class="s63">fuzzy checkpoint</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">Since pages are output to disk only after the <span class="s49">checkpoint </span>record has been written, it is possible that the system could crash before all pages are written. Thus, a checkpoint on disk may be incomplete. One way to deal with incomplete checkpoints is this: The location in the log of the checkpoint record of the last completed checkpoint is stored in a ﬁxed position, last-checkpoint, on disk. The system does not update this information when it writes the <span class="s49">checkpoint </span>record. Instead, before it writes the <span class="s49">checkpoint </span>record, it creates a list of all modiﬁed buﬀer blocks. The last-checkpoint information is updated only after all buﬀer blocks in the list of modiﬁed buﬀer blocks have been output to disk. Even with fuzzy checkpointing, a buﬀer block must not be updated while it is being output to disk, although other buﬀer blocks may be updated concurrently. The write- ahead log protocol must be followed so that (undo) log records pertaining to a block</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">are on stable storage before the block is output.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part350.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part352.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
