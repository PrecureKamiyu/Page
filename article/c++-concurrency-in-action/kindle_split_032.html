<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mbp="Kindle">
  <head>
    <title>C++ Concurrency in Action, Second Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="part" id="loe">List of Listings</h2>
      <p class="noind">Chapter 1. Hello, world of concurrency in C++!</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_011.html#ch01ex01" class="calibre4">Listing 1.1. A simple Hello Concurrent World program</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 2. Managing threads</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_012.html#ch02ex01" class="calibre4">Listing 2.1. A function that returns while a thread still has access to local variables</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch02ex02" class="calibre4">Listing 2.2. Waiting for a thread to finish</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch02ex03" class="calibre4">Listing 2.3. Using RAII to wait for a thread to complete</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch02ex04" class="calibre4">Listing 2.4. Detaching a thread to handle other documents</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch02ex05" class="calibre4">Listing 2.5. Returning a std::thread from a function</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch02ex06" class="calibre4">Listing 2.6. scoped_thread and example usage</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch02ex07" class="calibre4">Listing 2.7. A joining_thread class</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch02ex08" class="calibre4">Listing 2.8. Spawns some threads and waits for them to finish</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_012.html#ch02ex09" class="calibre4">Listing 2.9. A naïve parallel version of std::accumulate</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 3. Sharing data between threads</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_013.html#ch03ex01" class="calibre4">Listing 3.1. Protecting a list with a mutex</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex02" class="calibre4">Listing 3.2. Accidentally passing out a reference to protected data</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex03" class="calibre4">Listing 3.3. The interface to the std::stack container adapter</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex04" class="calibre4">Listing 3.4. An outline class definition for a thread-safe stack</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex05" class="calibre4">Listing 3.5. A fleshed-out class definition for a thread-safe stack</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex06" class="calibre4">Listing 3.6. Using std::lock() and std::lock_guard in a swap operation</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex07" class="calibre4">Listing 3.7. Using a lock hierarchy to prevent deadlock</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex08" class="calibre4">Listing 3.8. A simple hierarchical mutex</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex09" class="calibre4">Listing 3.9. Using std::lock() and std::unique_lock in a swap operation</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex10" class="calibre4">Listing 3.10. Locking one mutex at a time in a comparison operator</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex11" class="calibre4">Listing 3.11. Thread-safe lazy initialization using a mutex</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex12" class="calibre4">Listing 3.12. Thread-safe lazy initialization of a class member using std::call_once</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_013.html#ch03ex13" class="calibre4">Listing 3.13. Protecting a data structure with std::shared_mutex</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 4. Synchronizing concurrent operations</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_014.html#ch04ex01" class="calibre4">Listing 4.1. Waiting for data to process with std::condition_variable</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex02" class="calibre4">Listing 4.2. std::queue interface</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex03" class="calibre4">Listing 4.3. The interface of your threadsafe_queue</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex04" class="calibre4">Listing 4.4. Extracting push() and wait_and_pop() from listing 4.1</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex05" class="calibre4">Listing 4.5. Full class definition of a thread-safe queue using condition variables</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex06" class="calibre4">Listing 4.6. Using std::future to get the return value of an asynchronous task</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex07" class="calibre4">Listing 4.7. Passing arguments to a function with std::async</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex08" class="calibre4">Listing 4.8. Partial class definition for a specialization of std::packaged_task&lt; &gt;</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex09" class="calibre4">Listing 4.9. Running code on a GUI thread using std::packaged_task</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex10" class="calibre4">Listing 4.10. Handling multiple connections from a single thread using promises</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex11" class="calibre4">Listing 4.11. Waiting for a condition variable with a timeout</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex12" class="calibre4">Listing 4.12. A sequential implementation of Quicksort</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex13" class="calibre4">Listing 4.13. Parallel Quicksort using futures</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex14" class="calibre4">Listing 4.14. A sample implementation of spawn_task</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex15" class="calibre4">Listing 4.15. A simple implementation of an ATM logic class</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex16" class="calibre4">Listing 4.16. The getting_pin state function for the simple ATM implementation</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex17" class="calibre4">Listing 4.17. A simple equivalent to std::async for Concurrency TS futures</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex18" class="calibre4">Listing 4.18. A simple sequential function to process user login</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex19" class="calibre4">Listing 4.19. Processing user login with a single async task</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex20" class="calibre4">Listing 4.20. A function to process user login with continuations</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex21" class="calibre4">Listing 4.21. A function to process user login with fully asynchronous operations</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex22" class="calibre4">Listing 4.22. Gathering results from futures using std::async</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex23" class="calibre4">Listing 4.23. Gathering results from futures using std::experimental::when_all</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex24" class="calibre4">Listing 4.24. Using std::experimental::when_any to process the first value found</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex25" class="calibre4">Listing 4.25. Waiting for events with std::experimental::latch</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex26" class="calibre4">Listing 4.26. Using std::experimental::barrier</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_014.html#ch04ex27" class="calibre4">Listing 4.27. Using std::flex_barrier to provide a serial region</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 5. The C++ memory model and operations on atomic types</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_015.html#ch05ex01" class="calibre4">Listing 5.1. Implementation of a spinlock mutex using std::atomic_flag</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex02" class="calibre4">Listing 5.2. Reading and writing variables from different threads</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex03" class="calibre4">Listing 5.3. Order of evaluation of arguments to a function call is unspecified</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex04" class="calibre4">Listing 5.4. Sequential consistency implies a total ordering</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex05" class="calibre4">Listing 5.5. Relaxed operations have few ordering requirements</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex06" class="calibre4">Listing 5.6. Relaxed operations on multiple threads</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex07" class="calibre4">Listing 5.7. Acquire-release doesn’t imply a total ordering</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex08" class="calibre4">Listing 5.8. Acquire-release operations can impose ordering on relaxed operations</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex09" class="calibre4">Listing 5.9. Transitive synchronization using acquire and release ordering</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex10" class="calibre4">Listing 5.10. Using std::memory_order_consume to synchronize data</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex11" class="calibre4">Listing 5.11. Reading values from a queue with atomic operations</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex12" class="calibre4">Listing 5.12. Relaxed operations can be ordered with fences</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_015.html#ch05ex13" class="calibre4">Listing 5.13. Enforcing ordering on non-atomic operations</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 6. Designing lock-based concurrent data structures</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_016.html#ch06ex01" class="calibre4">Listing 6.1. A class definition for a thread-safe stack</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex02" class="calibre4">Listing 6.2. The full class definition for a thread-safe queue using condition variables</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex03" class="calibre4">Listing 6.3. A thread-safe queue holding std::shared_ptr&lt;&gt; instances</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex04" class="calibre4">Listing 6.4. A simple single-threaded queue implementation</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex05" class="calibre4">Listing 6.5. A simple queue with a dummy node</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex06" class="calibre4">Listing 6.6. A thread-safe queue with fine-grained locking</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex07" class="calibre4">Listing 6.7. A thread-safe queue with locking and waiting: internals and interface</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex08" class="calibre4">Listing 6.8. A thread-safe queue with locking and waiting: pushing new values</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex09" class="calibre4">Listing 6.9. A thread-safe queue with locking and waiting: wait_and_pop()</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex10" class="calibre4">Listing 6.10. A thread-safe queue with locking and waiting: try_pop() and empty()</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex11" class="calibre4">Listing 6.11. A thread-safe lookup table</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex12" class="calibre4">Listing 6.12. Obtaining contents of a threadsafe_lookup_table as std::map&lt;&gt;</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_016.html#ch06ex13" class="calibre4">Listing 6.13. A thread-safe list with iteration support</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 7. Designing lock-free concurrent data structures</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_017.html#ch07ex01" class="calibre4">Listing 7.1. Implementation of a spin-lock mutex using std::atomic_flag</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex02" class="calibre4">Listing 7.2. Implementing push() without locks</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex03" class="calibre4">Listing 7.3. A lock-free stack that leaks nodes</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex04" class="calibre4">Listing 7.4. Reclaiming nodes when no threads are in pop()</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex05" class="calibre4">Listing 7.5. The reference-counted reclamation machinery</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex06" class="calibre4">Listing 7.6. An implementation of pop() using hazard pointers</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex07" class="calibre4">Listing 7.7. A simple implementation of get_hazard_pointer_for_current_thread()</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex08" class="calibre4">Listing 7.8. A simple implementation of the reclaim functions</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex09" class="calibre4">Listing 7.9. A lock-free stack using a lock-free std::shared_ptr&lt;&gt; implementation</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex10" class="calibre4">Listing 7.10. Stack implementation using std::experimental::atomic_shared_ptr&lt;&gt;</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex11" class="calibre4">Listing 7.11. Pushing a node on a lock-free stack using split reference counts</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex12" class="calibre4">Listing 7.12. Popping a node from a lock-free stack using split reference counts</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex13" class="calibre4">Listing 7.13. A lock-free stack with reference counting and relaxed atomic operations</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex14" class="calibre4">Listing 7.14. A single-producer, single-consumer lock-free queue</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex15" class="calibre4">Listing 7.15. A (broken) first attempt at revising push()</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex16" class="calibre4">Listing 7.16. Implementing push() for a lock-free queue with a reference-counted tail</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex17" class="calibre4">Listing 7.17. Popping a node from a lock-free queue with a reference-counted tail</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex18" class="calibre4">Listing 7.18. Releasing a node reference in a lock-free queue</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex19" class="calibre4">Listing 7.19. Obtaining a new reference to a node in a lock-free queue</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex20" class="calibre4">Listing 7.20. Freeing an external counter to a node in a lock-free queue</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex21" class="calibre4">Listing 7.21. pop() modified to allow helping on the push() side</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_017.html#ch07ex22" class="calibre4">Listing 7.22. A sample push() with helping for a lock-free queue</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 8. Designing concurrent code</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_018.html#ch08ex01" class="calibre4">Listing 8.1. Parallel Quicksort using a stack of pending chunks to sort</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex02" class="calibre4">Listing 8.2. A naive parallel version of std::accumulate (from listing 2.9)</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex03" class="calibre4">Listing 8.3. A parallel version of std::accumulate using std::packaged_task</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex04" class="calibre4">Listing 8.4. An exception-safe parallel version of std::accumulate</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex05" class="calibre4">Listing 8.5. An exception-safe parallel version of std::accumulate using std::async</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex06" class="calibre4">Listing 8.6. Separating GUI thread from task thread</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex07" class="calibre4">Listing 8.7. A parallel version of std::for_each</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex08" class="calibre4">Listing 8.8. A parallel version of std::for_each using std::async</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex09" class="calibre4">Listing 8.9. An implementation of a parallel find algorithm</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex10" class="calibre4">Listing 8.10. An implementation of a parallel find algorithm using std::async</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex11" class="calibre4">Listing 8.11. Calculating partial sums in parallel by dividing the problem</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex12" class="calibre4">Listing 8.12. A simple barrier class</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_018.html#ch08ex13" class="calibre4">Listing 8.13. A parallel implementation of partial_sum by pairwise updates</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 9. Advanced thread management</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_019.html#ch09ex01" class="calibre4">Listing 9.1. Simple thread pool</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex02" class="calibre4">Listing 9.2. A thread pool with waitable tasks</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex03" class="calibre4">Listing 9.3. parallel_accumulate using a thread pool with waitable tasks</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex04" class="calibre4">Listing 9.4. An implementation of run_pending_task()</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex05" class="calibre4">Listing 9.5. A thread-pool–based implementation of Quicksort</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex06" class="calibre4">Listing 9.6. A thread pool with thread-local work queues</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex07" class="calibre4">Listing 9.7. Lock-based queue for work stealing</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex08" class="calibre4">Listing 9.8. A thread pool that uses work stealing</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex09" class="calibre4">Listing 9.9. Basic implementation of interruptible_thread</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex10" class="calibre4">Listing 9.10. A broken version of interruptible_wait for std::condition_variable</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex11" class="calibre4">Listing 9.11. Using a timeout in interruptible_wait for std::condition_variable</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex12" class="calibre4">Listing 9.12. interruptible_wait for std::condition_variable_any</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_019.html#ch09ex13" class="calibre4">Listing 9.13. Monitoring the filesystem in the background</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 10. Parallel algorithms</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_020.html#ch10ex01" class="calibre4">Listing 10.1. Parallel algorithms on a class with internal synchronization</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_020.html#ch10ex02" class="calibre4">Listing 10.2. Parallel algorithms on a class without internal synchronization</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_020.html#ch10ex03" class="calibre4">Listing 10.3. Using transform_reduce to count visits to pages of a website</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Chapter 11. Testing and debugging multithreaded applications</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_021.html#ch11ex01" class="calibre4">Listing 11.1. An example test for concurrent push() and pop() calls on a queue</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Appendix A. Brief reference for some C++11 language features</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_022.html#app01ex01" class="calibre4">Listing A.1. A class with a move constructor</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_022.html#app01ex02" class="calibre4">Listing A.2. A simple move-only type</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_022.html#app01ex03" class="calibre4">Listing A.3. A class with a trivial default constructor</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_022.html#app01ex04" class="calibre4">Listing A.4. A simple lambda with a deduced return type</a><br class="calibre15"/></p>
      </blockquote>
      <p class="noind">Appendix C. A message-passing framework and complete ATM example</p>
      <blockquote class="toc">
         <p class="ind"><a href="kindle_split_024.html#app03ex01" class="calibre4">Listing C.1. A simple message queue</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex02" class="calibre4">Listing C.2. The sender class</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex03" class="calibre4">Listing C.3. The receiver class</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex04" class="calibre4">Listing C.4. The dispatcher class</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex05" class="calibre4">Listing C.5. The TemplateDispatcher class template</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex06" class="calibre4">Listing C.6. ATM messages</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex07" class="calibre4">Listing C.7. The ATM state machine</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex08" class="calibre4">Listing C.8. The bank state machine</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex09" class="calibre4">Listing C.9. The user-interface state machine</a><br class="calibre15"/></p>
         <p class="ind"><a href="kindle_split_024.html#app03ex10" class="calibre4">Listing C.10. The driving code</a><br class="calibre15"/></p>
      </blockquote>
   
</body></html>
