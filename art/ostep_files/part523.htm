<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>48.4 Key To Fast Crash Recovery: Statelessness</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part522.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part524.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">48.4 Key To Fast Crash Recovery: Statelessness</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">This simple goal is realized in NFSv2 by designing what we refer to as a <b>stateless </b>protocol. The server, by design, does not keep track of any- thing about what is happening at each client. For example, the server does not know which clients are caching which blocks, or which files are currently open at each client, or the current file pointer position for a file, etc. Simply put, the server does not track anything about what clients are doing; rather, the protocol is designed to deliver in each protocol request <i>all the information </i>that is needed in order to complete the request. If it doesn’t now, this stateless approach will make more sense as we discuss the protocol in more detail below.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: left;">For an example of a <b>stateful </b>(not stateless) protocol, consider the <span class="s41">open() </span>system call. Given a pathname, <span class="s41">open() </span>returns a file descriptor (an inte- ger). This descriptor is used on subsequent <span class="s41">read() </span>or <span class="s41">write() </span>requests to access various file blocks, as in this application code (note that proper error checking of the system calls is omitted for space reasons):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">char buffer[MAX];</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">int fd = open(&quot;foo&quot;, O_RDONLY); // get descriptor &quot;fd&quot;</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">read(fd, buffer, MAX);    // read MAX bytes from foo (via fd) read(fd, buffer, MAX);    // read MAX bytes from foo</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">...</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">read(fd, buffer, MAX);    // read MAX bytes from foo close(fd);         // close file</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">Figure 48.3: <b>Client Code: Reading From A File</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Now imagine that the client-side file system opens the file by sending a protocol message to the server saying “open the file ’foo’ and give me back a descriptor”. The file server then opens the file locally on its side and sends the descriptor back to the client. On subsequent reads, the client application uses that descriptor to call the <span class="s41">read() </span>system call; the client-side file system then passes the descriptor in a message to the file server, saying “read some bytes from the file that is referred to by the descriptor I am passing you here”.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">In this example, the file descriptor is a piece of <b>shared state </b>between the client and the server (Ousterhout calls this <b>distributed state </b>[O91]). Shared state, as we hinted above, complicates crash recovery. Imagine the server crashes after the first read completes, but before the client has issued the second one. After the server is up and running again, the client then issues the second read. Unfortunately, the server has no idea to which file <span class="s41">fd </span>is referring; that information was ephemeral (i.e., in memory) and thus lost when the server crashed. To handle this situa- tion, the client and server would have to engage in some kind of <b>recovery protocol</b>, where the client would make sure to keep enough information around in its memory to be able to tell the server what it needs to know (in this case, that file descriptor <span class="s41">fd </span>refers to file <span class="s41">foo</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">It gets even worse when you consider the fact that a stateful server has to deal with client crashes. Imagine, for example, a client that opens a file and then crashes. The <span class="s41">open() </span>uses up a file descriptor on the server; how can the server know it is OK to close a given file? In normal operation, a client would eventually call <span class="s41">close() </span>and thus inform the server that the file should be closed. However, when a client crashes, the server never receives a <span class="s41">close()</span>, and thus has to notice the client has crashed in order to close the file.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">For these reasons, the designers of NFS decided to pursue a stateless approach: each client operation contains all the information needed to complete the request. No fancy crash recovery is needed; the server just starts running again, and a client, at worst, might have to retry a request.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part522.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part524.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
