<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>23.3 A Real Address Space</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part250.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part252.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">23.3 A Real Address Space</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One neat aspect of studying VMS is that we can see how a real address space is constructed (Figure <span style=" color: #00AEEF;">23.1</span>. Thus far, we have assumed a simple address space of just user code, user data, and user heap, but as we can see above, a real address space is notably more complex.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 29pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>W<span class="s45">HY </span>N<span class="s45">ULL </span>P<span class="s45">OINTER </span>A<span class="s45">CCESSES </span>C<span class="s45">AUSE </span>S<span class="s45">EG </span>F<span class="s45">AULTS</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">You should now have a good understanding of exactly what happens on a null-pointer dereference. A process generates a virtual address of 0, by doing something like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 8pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">int <span class="s39">*</span>p = NULL; // set p = 0</p><p class="s39" style="padding-left: 8pt;text-indent: 0pt;line-height: 91%;text-align: justify;">*<span class="s38">p = 10;   // try to store value 10 to virtual address 0</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The hardware tries to look up the VPN (also 0 here) in the TLB, and suf- fers a TLB miss. The page table is consulted, and the entry for VPN 0 is found to be marked invalid. Thus, we have an invalid access, which transfers control to the OS, which likely terminates the process (on U<span class="s7">NIX </span>systems, processes are sent a signal which allows them to react to such a fault; if uncaught, however, the process is killed).</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">For example, the code segment never begins at page 0. This page, instead, is marked inaccessible, in order to provide some support for de- tecting <b>null-pointer </b>accesses. Thus, one concern when designing an ad- dress space is support for debugging, which the inaccessible zero page provides here in some form.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Perhaps more importantly, the kernel virtual address space (i.e., its data structures and code) is a part of each user address space. On a con- text switch, the OS changes the <span class="s41">P0 </span>and <span class="s41">P1 </span>registers to point to the ap- propriate page tables of the soon-to-be-run process; however, it does not change the <span class="s41">S </span>base and bound registers, and as a result the “same” kernel structures are mapped into each user address space.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: right;">The kernel is mapped into each address space for a number of reasons. This construction makes life easier for the kernel; when, for example, the OS is handed a pointer from a user program (e.g., on a <span class="s41">write() </span>system call), it is easy to copy data from that pointer to its own structures. The OS is naturally written and compiled, without worry of where the data it is accessing comes from. If in contrast the kernel were located entirely in physical memory, it would be quite hard to do things like swap pages of the page table to disk; if the kernel were given its own address space, moving data between user applications and the kernel would again be complicated and painful. With this construction (now used widely), the kernel appears almost as a library to applications, albeit a protected one. One last point about this address space relates to protection. Clearly, the OS does not want user applications reading or writing OS data or code. Thus, the hardware must support different protection levels for pages to enable this. The VAX did so by specifying, in protection bits in the page table, what privilege level the CPU must be at in order to access a particular page. Thus, system data and code are set to a higher level of protection than user data and code; an attempted access to such information from user code will generate a trap into the OS, and (you</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 10pt;text-align: left;">guessed it) the likely termination of the offending process.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part250.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part252.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
