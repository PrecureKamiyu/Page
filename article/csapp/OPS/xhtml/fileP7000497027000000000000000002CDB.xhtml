<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>3.9 Heterogeneous Data Structures</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <script src="js/format_lg_obj.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000002CDB" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000040F3A" data-uri="chapter03.xhtml#P7000497027000000000000000040F3A" epub:type="title"><span class="pcalibre label pcalibre1">3.9 </span>Heterogeneous Data Structures</h1></header>
<p id="P7000497027000000000000000040F3B" data-uri="chapter03.xhtml#P7000497027000000000000000040F3B" class="pcalibre1 pcalibre calibre2">C provides two mechanisms for creating data types by combining objects of different types: <i class="calibre5 pcalibre pcalibre1">structures</i>, declared using the keyword <code id="P7000497027000000000000000040F3C" data-uri="chapter03.xhtml#P7000497027000000000000000040F3C" class="pcalibre1 calibre8 pcalibre">struct</code>, aggregate multiple objects into a single unit; <i class="calibre5 pcalibre pcalibre1">unions</i>, declared using the keyword <code id="P7000497027000000000000000040F3D" data-uri="chapter03.xhtml#P7000497027000000000000000040F3D" class="pcalibre1 calibre8 pcalibre">union</code>, allow an object to be referenced using several different types.</p>
<section id="P7000497027000000000000000002CE0" data-uri="chapter03.xhtml#P7000497027000000000000000002CE0" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000040F3E" data-uri="chapter03.xhtml#P7000497027000000000000000040F3E" epub:type="title"><span class="pcalibre label pcalibre1">3.9.1 </span>Structures</h1></header>
<p id="P7000497027000000000000000040F3F" data-uri="chapter03.xhtml#P7000497027000000000000000040F3F" class="pcalibre1 pcalibre calibre2">The C <code id="P7000497027000000000000000040F40" data-uri="chapter03.xhtml#P7000497027000000000000000040F40" class="pcalibre1 calibre8 pcalibre">struct</code> declaration creates a data type that groups objects of possibly different types into a single object. The different components of a structure are referenced by names. The implementation of structures is similar to that of arrays in that all of the components of a structure are stored in a contiguous region of memory and a pointer to a structure is the address of its first byte. The compiler maintains information about each structure type indicating the byte offset of each field. It generates references to structure elements using these offsets as displacements in memory referencing instructions.</p>
<p id="P7000497027000000000000000040F41" data-uri="chapter03.xhtml#P7000497027000000000000000040F41" class="pcalibre1 pcalibre calibre2">As an example, consider the following structure declaration:</p>
<pre id="P7000497027000000000000000040F42" data-uri="chapter03.xhtml#P7000497027000000000000000040F42" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F43" data-uri="chapter03.xhtml#P7000497027000000000000000040F43" class="calibre10 pcalibre pcalibre1">
struct rec {
	int i;
	int j;
	int a[2];
	int *p;
};
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040F44" data-uri="chapter03.xhtml#P7000497027000000000000000040F44">This structure contains four fields: two 4-byte values of type <code id="P7000497027000000000000000040F45" data-uri="chapter03.xhtml#P7000497027000000000000000040F45" class="pcalibre1 calibre8 pcalibre">int</code>, a two-element array of type <code id="P7000497027000000000000000040F46" data-uri="chapter03.xhtml#P7000497027000000000000000040F46" class="pcalibre1 calibre8 pcalibre">int</code>, and an 8-byte integer pointer, giving a total of 24 bytes:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002CEA" data-uri="chapter03.xhtml#P7000497027000000000000000002CEA">
<img alt="A diagram shows four fields: offset 0 to 4 with contents i; offset 4 to 8 with contents j; two offsets from 8 to 16 with contents a[0] and a[1]; offset 16 to 24 with contents p." id="P7000497027000000000000000040F47" data-uri="P700049702700000000000000000B6BC" src="../images/p265-1.png" class="calibre93 pcalibre pcalibre1"/>

</figure>
<p id="P7000497027000000000000000040F48" data-uri="chapter03.xhtml#P7000497027000000000000000040F48" class="pcalibre1 pcalibre calibre2">Observe that array a is embedded within the structure. The numbers along the top of the diagram give the byte offsets of the fields from the beginning of the structure.</p>
<p id="P7000497027000000000000000040F49" data-uri="chapter03.xhtml#P7000497027000000000000000040F49" class="pcalibre1 pcalibre calibre2">To access the fields of a structure, the compiler generates code that adds the appropriate offset to the address of the structure. For example, suppose variable <code id="P7000497027000000000000000040F4A" data-uri="chapter03.xhtml#P7000497027000000000000000040F4A" class="pcalibre1 calibre8 pcalibre">r</code></p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000002CEF" data-uri="chapter03.xhtml#P7000497027000000000000000002CEF"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000040F4B" data-uri="chapter03.xhtml#P7000497027000000000000000040F4B" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002CF1" title="266" data-uri="chapter03.xhtml#P7000497027000000000000000002CF1" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">New to C? </span>Representing an object as a <code id="P7000497027000000000000000040F4C" data-uri="chapter03.xhtml#P7000497027000000000000000040F4C" class="calibre55 pcalibre pcalibre1">struct</code></h1></header>
<p id="P7000497027000000000000000040F4D" data-uri="chapter03.xhtml#P7000497027000000000000000040F4D" class="calibre13 pcalibre pcalibre1">The <code id="P7000497027000000000000000040F4E" data-uri="chapter03.xhtml#P7000497027000000000000000040F4E" class="pcalibre1 calibre8 pcalibre">struct</code> data type constructor is the closest thing C provides to the objects of C++ and Java. It allows the programmer to keep information about some entity in a single data structure and to reference that information with names.</p>
<p id="P7000497027000000000000000040F4F" data-uri="chapter03.xhtml#P7000497027000000000000000040F4F" class="calibre13 pcalibre pcalibre1">For example, a graphics program might represent a rectangle as a structure:</p>
<pre id="P7000497027000000000000000040F50" data-uri="chapter03.xhtml#P7000497027000000000000000040F50" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F51" data-uri="chapter03.xhtml#P7000497027000000000000000040F51" class="calibre10 pcalibre pcalibre1">
struct rect {
	long llx;		/* X coordinate of lower-left corner */
	long lly;		/* Y coordinate of lower-left corner */
	unsigned long width;	 /* Width (in pixels)			*/
	unsigned long height;	/* Height (in pixels)			*/
	unsigned color;		/* Coding of color			*/
};
</code></pre>
<p id="P7000497027000000000000000040F52" data-uri="chapter03.xhtml#P7000497027000000000000000040F52" class="calibre13 pcalibre pcalibre1">We can declare a variable <code id="P7000497027000000000000000040F53" data-uri="chapter03.xhtml#P7000497027000000000000000040F53" class="pcalibre1 calibre8 pcalibre">r</code> of type <code id="P7000497027000000000000000040F54" data-uri="chapter03.xhtml#P7000497027000000000000000040F54" class="pcalibre1 calibre8 pcalibre">struct rect</code> and set its field values as follows:</p>
<pre id="P7000497027000000000000000040F55" data-uri="chapter03.xhtml#P7000497027000000000000000040F55" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F56" data-uri="chapter03.xhtml#P7000497027000000000000000040F56" class="calibre10 pcalibre pcalibre1">
struct rect r;
r.llx = r.lly = 0;
r.color = 0xFF00FF;
r.width = 10;
r.height = 20;
</code></pre>
<p class="calibre13 pcalibre pcalibre1" id="P7000497027000000000000000040F57" data-uri="chapter03.xhtml#P7000497027000000000000000040F57">where the expression <code id="P7000497027000000000000000040F58" data-uri="chapter03.xhtml#P7000497027000000000000000040F58" class="pcalibre1 calibre8 pcalibre">r.llx</code> selects field <code id="P7000497027000000000000000040F59" data-uri="chapter03.xhtml#P7000497027000000000000000040F59" class="pcalibre1 calibre8 pcalibre">llx</code> of structure <code id="P7000497027000000000000000040F5A" data-uri="chapter03.xhtml#P7000497027000000000000000040F5A" class="pcalibre1 calibre8 pcalibre">r</code>.</p>
<p id="P7000497027000000000000000040F5B" data-uri="chapter03.xhtml#P7000497027000000000000000040F5B" class="calibre13 pcalibre pcalibre1">Alternatively, we can both declare the variable and initialize its fields with a single statement:</p>
<pre id="P7000497027000000000000000040F5C" data-uri="chapter03.xhtml#P7000497027000000000000000040F5C" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F5D" data-uri="chapter03.xhtml#P7000497027000000000000000040F5D" class="calibre10 pcalibre pcalibre1">
struct rect r = { 0, 0, 0xFF00FF, 10, 20 };
</code></pre>
<p id="P7000497027000000000000000040F5E" data-uri="chapter03.xhtml#P7000497027000000000000000040F5E" class="calibre13 pcalibre pcalibre1">It is common to pass pointers to structures from one place to another rather than copying them. For example, the following function computes the area of a rectangle, where a pointer to the rectangle <code id="P7000497027000000000000000040F5F" data-uri="chapter03.xhtml#P7000497027000000000000000040F5F" class="pcalibre1 calibre8 pcalibre">struct</code> is passed to the function:</p>
<pre id="P7000497027000000000000000040F60" data-uri="chapter03.xhtml#P7000497027000000000000000040F60" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F61" data-uri="chapter03.xhtml#P7000497027000000000000000040F61" class="calibre10 pcalibre pcalibre1">
long area(struct rect *rp) {
	return (*rp).width * (*rp).height;
}
</code></pre>
<p id="P7000497027000000000000000040F62" data-uri="chapter03.xhtml#P7000497027000000000000000040F62" class="calibre13 pcalibre pcalibre1">The expression <code id="P7000497027000000000000000040F63" data-uri="chapter03.xhtml#P7000497027000000000000000040F63" class="pcalibre1 calibre8 pcalibre">(*rp)</code>.width dereferences the pointer and selects the width field of the resulting structure. Parentheses are required, because the compiler would interpret the expression <code id="P7000497027000000000000000040F64" data-uri="chapter03.xhtml#P7000497027000000000000000040F64" class="pcalibre1 calibre8 pcalibre">*rp.width</code> as <code id="P7000497027000000000000000040F65" data-uri="chapter03.xhtml#P7000497027000000000000000040F65" class="pcalibre1 calibre8 pcalibre">*(rp.width)</code>, which is not valid. This combination of dereferencing and field selection is so common that C provides an alternative notation using -&gt;. That is, <code id="P7000497027000000000000000040F66" data-uri="chapter03.xhtml#P7000497027000000000000000040F66" class="pcalibre1 calibre8 pcalibre">rp-&gt;width</code> is equivalent to the expression <code id="P7000497027000000000000000040F67" data-uri="chapter03.xhtml#P7000497027000000000000000040F67" class="pcalibre1 calibre8 pcalibre">(*rp).width.</code> For example, we can write a function that rotates a rectangle counterclockwise by 90 degrees as</p>
<pre id="P7000497027000000000000000040F68" data-uri="chapter03.xhtml#P7000497027000000000000000040F68" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F69" data-uri="chapter03.xhtml#P7000497027000000000000000040F69" class="calibre10 pcalibre pcalibre1">
void rotate_left(struct rect *rp) {
	/* Exchange width and height */
	long t = rp-&gt;height;
	rp-&gt;height = rp-&gt;width;
	rp-&gt;width = t;
	/* Shift to new lower-left corner */
	rp-&gt;llx -= t;
}
</code></pre>
<p id="P7000497027000000000000000040F6A" data-uri="chapter03.xhtml#P7000497027000000000000000040F6A" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002D11" title="267" data-uri="chapter03.xhtml#P7000497027000000000000000002D11" epub:type="pagebreak"></span>The objects of C++ and Java are more elaborate than structures in C, in that they also associate a set of <i class="calibre5 pcalibre pcalibre1">methods</i> with an object that can be invoked to perform computation. In C, we would simply write these as ordinary functions, such as the functions <code id="P7000497027000000000000000040F6B" data-uri="chapter03.xhtml#P7000497027000000000000000040F6B" class="pcalibre1 calibre8 pcalibre">area</code> and <code id="P7000497027000000000000000040F6C" data-uri="chapter03.xhtml#P7000497027000000000000000040F6C" class="pcalibre1 calibre8 pcalibre">rotate_left</code> shown previously.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040F6D" data-uri="chapter03.xhtml#P7000497027000000000000000040F6D">of type <code id="P7000497027000000000000000040F6E" data-uri="chapter03.xhtml#P7000497027000000000000000040F6E" class="pcalibre1 calibre8 pcalibre">struct rec *</code> is in register <code id="P7000497027000000000000000040F6F" data-uri="chapter03.xhtml#P7000497027000000000000000040F6F" class="pcalibre1 calibre8 pcalibre">%rdi</code>. Then the following code copies element <code id="P7000497027000000000000000040F70" data-uri="chapter03.xhtml#P7000497027000000000000000040F70" class="pcalibre1 calibre8 pcalibre">r-&gt;i</code> to element <code id="P7000497027000000000000000040F71" data-uri="chapter03.xhtml#P7000497027000000000000000040F71" class="pcalibre1 calibre8 pcalibre">r-&gt;j</code>:</p>
<pre id="P7000497027000000000000000040F72" data-uri="chapter03.xhtml#P7000497027000000000000000040F72" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F73" data-uri="chapter03.xhtml#P7000497027000000000000000040F73" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">Registers: r in %rdi</i>
1	movl	(%rdi), %eax		<i class="calibre5 pcalibre pcalibre1">Get r-&gt;i</i>
2	movl	%eax, 4(%rdi)		<i class="calibre5 pcalibre pcalibre1">Store in r-&gt;j</i>
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040F74" data-uri="chapter03.xhtml#P7000497027000000000000000040F74">Since the offset of field <code id="P7000497027000000000000000040F75" data-uri="chapter03.xhtml#P7000497027000000000000000040F75" class="pcalibre1 calibre8 pcalibre">i</code> is 0, the address of this field is simply the value of <code id="P7000497027000000000000000040F76" data-uri="chapter03.xhtml#P7000497027000000000000000040F76" class="pcalibre1 calibre8 pcalibre">r</code>. To store into field <code id="P7000497027000000000000000040F77" data-uri="chapter03.xhtml#P7000497027000000000000000040F77" class="pcalibre1 calibre8 pcalibre">j</code>, the code adds offset 4 to the address of <code id="P7000497027000000000000000040F78" data-uri="chapter03.xhtml#P7000497027000000000000000040F78" class="pcalibre1 calibre8 pcalibre">r</code>.</p>
<p id="P7000497027000000000000000040F79" data-uri="chapter03.xhtml#P7000497027000000000000000040F79" class="pcalibre1 pcalibre calibre2">To generate a pointer to an object within a structure, we can simply add the field's offset to the structure address. For example, we can generate the pointer <code id="P7000497027000000000000000040F7A" data-uri="chapter03.xhtml#P7000497027000000000000000040F7A" class="pcalibre1 calibre8 pcalibre">&amp;(r-&gt;a[1])</code> by adding offset 8 + 4 · 1 = 12. For pointer <code id="P7000497027000000000000000040F7B" data-uri="chapter03.xhtml#P7000497027000000000000000040F7B" class="pcalibre1 calibre8 pcalibre">r</code> in register <code id="P7000497027000000000000000040F7C" data-uri="chapter03.xhtml#P7000497027000000000000000040F7C" class="pcalibre1 calibre8 pcalibre">%rdi</code> and long integer variable <code id="P7000497027000000000000000040F7D" data-uri="chapter03.xhtml#P7000497027000000000000000040F7D" class="pcalibre1 calibre8 pcalibre">i</code> in register <code id="P7000497027000000000000000040F7E" data-uri="chapter03.xhtml#P7000497027000000000000000040F7E" class="pcalibre1 calibre8 pcalibre">%rsi</code>, we can generate the pointer value <code id="P7000497027000000000000000040F7F" data-uri="chapter03.xhtml#P7000497027000000000000000040F7F" class="pcalibre1 calibre8 pcalibre">&amp;(r-&gt;a[i])</code> with the single instruction</p>
<pre id="P7000497027000000000000000040F80" data-uri="chapter03.xhtml#P7000497027000000000000000040F80" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F81" data-uri="chapter03.xhtml#P7000497027000000000000000040F81" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">Registers: r in %rdi, i %rsi</i>
1	leaq	 8(%rdi,%rsi,4), %rax	<i class="calibre5 pcalibre pcalibre1">Set %rax to &amp;r-&gt;a[i]</i>
</code></pre>
<p id="P7000497027000000000000000040F82" data-uri="chapter03.xhtml#P7000497027000000000000000040F82" class="pcalibre1 pcalibre calibre2">As a final example, the following code implements the statement</p>
<pre id="P7000497027000000000000000040F83" data-uri="chapter03.xhtml#P7000497027000000000000000040F83" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F84" data-uri="chapter03.xhtml#P7000497027000000000000000040F84" class="calibre10 pcalibre pcalibre1">
r-&gt;p = &amp;r-&gt;a[r-&gt;i + r-&gt;j];
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040F85" data-uri="chapter03.xhtml#P7000497027000000000000000040F85">starting with <code id="P7000497027000000000000000040F86" data-uri="chapter03.xhtml#P7000497027000000000000000040F86" class="pcalibre1 calibre8 pcalibre">r</code> in register <code id="P7000497027000000000000000040F87" data-uri="chapter03.xhtml#P7000497027000000000000000040F87" class="pcalibre1 calibre8 pcalibre">%rdi:</code></p>
<pre id="P7000497027000000000000000040F88" data-uri="chapter03.xhtml#P7000497027000000000000000040F88" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F89" data-uri="chapter03.xhtml#P7000497027000000000000000040F89" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">Registers: r in %rdi</i>
1	movl	 4(%rdi), %eax		<i class="calibre5 pcalibre pcalibre1">Get r-&gt;j</i>
2	addl	 (%rdi), %eax		<i class="calibre5 pcalibre pcalibre1">Add r-&gt;i</i>
3	cltq				<i class="calibre5 pcalibre pcalibre1">Extend to 8 bytes</i>
4	leaq	 8(%rdi,%rax,4), %rax	<i class="calibre5 pcalibre pcalibre1">Compute &amp;r-&gt;a[r-&gt;i + r-&gt;j]</i>
5	movq	%rax, 16(%rdi)		<i class="calibre5 pcalibre pcalibre1">Store in r-&gt;p</i>
</code></pre>
<p id="P7000497027000000000000000040F8A" data-uri="chapter03.xhtml#P7000497027000000000000000040F8A" class="pcalibre1 pcalibre calibre2">As these examples show, the selection of the different fields of a structure is handled completely at compile time. The machine code contains no information about the field declarations or the names of the fields.</p>
<section id="P7000497027000000000000000002D32" data-uri="chapter03.xhtml#P7000497027000000000000000002D32" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000040F8B" data-uri="chapter03.xhtml#P7000497027000000000000000040F8B" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002D34" title="268" data-uri="chapter03.xhtml#P7000497027000000000000000002D34" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.41 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003838">343</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000040F8C" data-uri="chapter03.xhtml#P7000497027000000000000000040F8C">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000040F8D" data-uri="chapter03.xhtml#P7000497027000000000000000040F8D">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000040F8E" data-uri="chapter03.xhtml#P7000497027000000000000000040F8E"><p id="P7000497027000000000000000040F8F" data-uri="chapter03.xhtml#P7000497027000000000000000040F8F" class="pcalibre calibre3 pcalibre1">Consider the following structure declaration:</p>
<pre id="P7000497027000000000000000040F90" data-uri="chapter03.xhtml#P7000497027000000000000000040F90" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F91" data-uri="chapter03.xhtml#P7000497027000000000000000040F91" class="calibre10 pcalibre pcalibre1">
struct prob {
	int *p;
	struct {
	  int x;
	  int y;
	} s;
	struct prob *next;
};
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P7000497027000000000000000040F92" data-uri="chapter03.xhtml#P7000497027000000000000000040F92">This declaration illustrates that one structure can be embedded within another, just as arrays can be embedded within structures and arrays can be embedded within arrays.</p>
<p id="P7000497027000000000000000040F93" data-uri="chapter03.xhtml#P7000497027000000000000000040F93" class="pcalibre calibre3 pcalibre1">The following procedure (with some expressions omitted) operates on this structure:</p>
<pre id="P7000497027000000000000000040F94" data-uri="chapter03.xhtml#P7000497027000000000000000040F94" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F95" data-uri="chapter03.xhtml#P7000497027000000000000000040F95" class="calibre10 pcalibre pcalibre1">
void sp_init(struct prob *sp) {
	sp-&gt;s.x =	__________;
	sp-&gt;p =		__________;
	sp-&gt;next=	__________;
}
</code></pre>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P7000497027000000000000000040F96" data-uri="chapter03.xhtml#P7000497027000000000000000040F96">
<li id="P7000497027000000000000000040F97" data-uri="chapter03.xhtml#P7000497027000000000000000040F97" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040F98" data-uri="chapter03.xhtml#P7000497027000000000000000040F98" class="pcalibre calibre3 pcalibre1">What are the offsets (in bytes) of the following fields?</p>
<pre id="P7000497027000000000000000040F99" data-uri="chapter03.xhtml#P7000497027000000000000000040F99" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040F9A" data-uri="chapter03.xhtml#P7000497027000000000000000040F9A" class="calibre10 pcalibre pcalibre1">
p:	__________
s.x:	 __________
s.y:	__________
next:	__________
</code></pre>
</li>
<li id="P7000497027000000000000000040F9B" data-uri="chapter03.xhtml#P7000497027000000000000000040F9B" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040F9C" data-uri="chapter03.xhtml#P7000497027000000000000000040F9C" class="pcalibre calibre3 pcalibre1">How many total bytes does the structure require?</p></li>
<li id="P7000497027000000000000000040F9D" data-uri="chapter03.xhtml#P7000497027000000000000000040F9D" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040F9E" data-uri="chapter03.xhtml#P7000497027000000000000000040F9E" class="pcalibre calibre3 pcalibre1">The compiler generates the following assembly code for <code id="P7000497027000000000000000040F9F" data-uri="chapter03.xhtml#P7000497027000000000000000040F9F" class="pcalibre1 calibre8 pcalibre">sp_init:</code></p>
<pre id="P7000497027000000000000000040FA0" data-uri="chapter03.xhtml#P7000497027000000000000000040FA0" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040FA1" data-uri="chapter03.xhtml#P7000497027000000000000000040FA1" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">void sp_init(struct prob *sp)</i>
	<i class="calibre5 pcalibre pcalibre1">sp in %rdi</i>
1	sp_init:
2	movl	12(%rdi), %eax
3	movl	%eax, 8(%rdi)
4	leaq	8(%rdi), %rax
5	movq	%rax, (%rdi)
6	movq	%rdi, 16(%rdi)
7	ret
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P7000497027000000000000000040FA2" data-uri="chapter03.xhtml#P7000497027000000000000000040FA2">On the basis of this information, fill in the missing expressions in the code for <code id="P7000497027000000000000000040FA3" data-uri="chapter03.xhtml#P7000497027000000000000000040FA3" class="pcalibre1 calibre8 pcalibre">sp_init.</code></p>
</li></ol></div>
</li></ol>
</section>
<section id="P7000497027000000000000000002D4D" data-uri="chapter03.xhtml#P7000497027000000000000000002D4D" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000040FA4" data-uri="chapter03.xhtml#P7000497027000000000000000040FA4" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002D4F" title="269" data-uri="chapter03.xhtml#P7000497027000000000000000002D4F" epub:type="pagebreak"></span><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.42 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003838">343</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000040FA5" data-uri="chapter03.xhtml#P7000497027000000000000000040FA5">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000040FA6" data-uri="chapter03.xhtml#P7000497027000000000000000040FA6">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000040FA7" data-uri="chapter03.xhtml#P7000497027000000000000000040FA7"><p id="P7000497027000000000000000040FA8" data-uri="chapter03.xhtml#P7000497027000000000000000040FA8" class="pcalibre calibre3 pcalibre1">The following code shows the declaration of a structure of type <code id="P7000497027000000000000000040FA9" data-uri="chapter03.xhtml#P7000497027000000000000000040FA9" class="pcalibre1 calibre8 pcalibre">ELE</code> and the prototype for a function <code id="P7000497027000000000000000040FAA" data-uri="chapter03.xhtml#P7000497027000000000000000040FAA" class="pcalibre1 calibre8 pcalibre">fun</code>:</p>
<pre id="P7000497027000000000000000040FAB" data-uri="chapter03.xhtml#P7000497027000000000000000040FAB" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040FAC" data-uri="chapter03.xhtml#P7000497027000000000000000040FAC" class="calibre10 pcalibre pcalibre1">
struct ELE {
	long v;
	struct ELE *p;
};

long fun(struct ELE *ptr);
</code></pre>
<p id="P7000497027000000000000000040FAD" data-uri="chapter03.xhtml#P7000497027000000000000000040FAD" class="pcalibre calibre3 pcalibre1">When the code for <code id="P7000497027000000000000000040FAE" data-uri="chapter03.xhtml#P7000497027000000000000000040FAE" class="pcalibre1 calibre8 pcalibre">fun</code> is compiled, <span class="smallcaps pcalibre pcalibre1">gcc </span>generates the following assembly code:</p>
<pre id="P7000497027000000000000000040FAF" data-uri="chapter03.xhtml#P7000497027000000000000000040FAF" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040FB0" data-uri="chapter03.xhtml#P7000497027000000000000000040FB0" class="calibre10 pcalibre pcalibre1">
	<i class="calibre5 pcalibre pcalibre1">long fun(struct ELE *ptr)</i>
	<i class="calibre5 pcalibre pcalibre1">ptr in %rdi</i>
1	fun:
2	movl	$0, %eax
3	jmp	.L2
4	L3:
5	addq	(%rdi), %rax
6	movq	8(%rdi), %rdi
7	.L2:
8	testq	%rdi, %rdi
9	jne	.L3
10	rep; ret
</code></pre>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P7000497027000000000000000040FB1" data-uri="chapter03.xhtml#P7000497027000000000000000040FB1">
<li id="P7000497027000000000000000040FB2" data-uri="chapter03.xhtml#P7000497027000000000000000040FB2" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040FB3" data-uri="chapter03.xhtml#P7000497027000000000000000040FB3" class="pcalibre calibre3 pcalibre1">Use your reverse engineering skills to write C code for <code id="P7000497027000000000000000040FB4" data-uri="chapter03.xhtml#P7000497027000000000000000040FB4" class="pcalibre1 calibre8 pcalibre">fun</code>.</p></li>
<li id="P7000497027000000000000000040FB5" data-uri="chapter03.xhtml#P7000497027000000000000000040FB5" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000040FB6" data-uri="chapter03.xhtml#P7000497027000000000000000040FB6" class="pcalibre calibre3 pcalibre1">Describe the data structure that this structure implements and the operation performed by <code id="P7000497027000000000000000040FB7" data-uri="chapter03.xhtml#P7000497027000000000000000040FB7" class="pcalibre1 calibre8 pcalibre">fun</code>.</p></li>
</ol>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000002D63" data-uri="chapter03.xhtml#P7000497027000000000000000002D63" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000040FB8" data-uri="chapter03.xhtml#P7000497027000000000000000040FB8" epub:type="title"><span class="pcalibre label pcalibre1">3.9.2 </span>Unions</h1></header>
<p id="P7000497027000000000000000040FB9" data-uri="chapter03.xhtml#P7000497027000000000000000040FB9" class="pcalibre1 pcalibre calibre2">Unions provide a way to circumvent the type system of C, allowing a single object to be referenced according to multiple types. The syntax of a union declaration is identical to that for structures, but its semantics are very different. Rather than having the different fields reference different blocks of memory, they all reference the same block.</p>
<p id="P7000497027000000000000000040FBA" data-uri="chapter03.xhtml#P7000497027000000000000000040FBA" class="pcalibre1 pcalibre calibre2">Consider the following declarations:</p>
<pre id="P7000497027000000000000000040FBB" data-uri="chapter03.xhtml#P7000497027000000000000000040FBB" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040FBC" data-uri="chapter03.xhtml#P7000497027000000000000000040FBC" class="calibre10 pcalibre pcalibre1">
struct S3 {
	char c;
	int i[2];
	double v;
};
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002D69" title="270" data-uri="chapter03.xhtml#P7000497027000000000000000002D69" epub:type="pagebreak"></span>union U3 {
	char c;
	int i[2];
	double v;
};
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040FBD" data-uri="chapter03.xhtml#P7000497027000000000000000040FBD">When compiled on an x86-64 Linux machine, the offsets of the fields, as well as the total size of data types <code id="P7000497027000000000000000040FBE" data-uri="chapter03.xhtml#P7000497027000000000000000040FBE" class="pcalibre1 calibre8 pcalibre">S3</code> and <code id="P7000497027000000000000000040FBF" data-uri="chapter03.xhtml#P7000497027000000000000000040FBF" class="pcalibre1 calibre8 pcalibre">U3</code>, are as shown in the following table:</p>
<table id="P7000497027000000000000000040FC0" data-uri="chapter03.xhtml#P7000497027000000000000000040FC0" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000040FC1" data-uri="chapter03.xhtml#P7000497027000000000000000040FC1" class="calibre18 pcalibre pcalibre1">Type</th>
<th id="P7000497027000000000000000040FC2" data-uri="chapter03.xhtml#P7000497027000000000000000040FC2" class="calibre18 pcalibre pcalibre1"><code id="P7000497027000000000000000040FC3" data-uri="chapter03.xhtml#P7000497027000000000000000040FC3" class="calibre10 pcalibre pcalibre1">c</code></th>
<th id="P7000497027000000000000000040FC4" data-uri="chapter03.xhtml#P7000497027000000000000000040FC4" class="calibre18 pcalibre pcalibre1"><code id="P7000497027000000000000000040FC5" data-uri="chapter03.xhtml#P7000497027000000000000000040FC5" class="calibre10 pcalibre pcalibre1">i</code></th>
<th id="P7000497027000000000000000040FC6" data-uri="chapter03.xhtml#P7000497027000000000000000040FC6" class="calibre18 pcalibre pcalibre1"><code id="P7000497027000000000000000040FC7" data-uri="chapter03.xhtml#P7000497027000000000000000040FC7" class="calibre10 pcalibre pcalibre1">v</code></th>
<th id="P7000497027000000000000000040FC8" data-uri="chapter03.xhtml#P7000497027000000000000000040FC8" class="calibre18 pcalibre pcalibre1">Size</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000040FC9" data-uri="chapter03.xhtml#P7000497027000000000000000040FC9" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000040FCA" data-uri="chapter03.xhtml#P7000497027000000000000000040FCA" class="calibre10 pcalibre pcalibre1">S3</code></td>
<td id="P7000497027000000000000000040FCB" data-uri="chapter03.xhtml#P7000497027000000000000000040FCB" class="calibre20 pcalibre pcalibre1">0</td>
<td id="P7000497027000000000000000040FCC" data-uri="chapter03.xhtml#P7000497027000000000000000040FCC" class="calibre20 pcalibre pcalibre1">4</td>
<td id="P7000497027000000000000000040FCD" data-uri="chapter03.xhtml#P7000497027000000000000000040FCD" class="calibre20 pcalibre pcalibre1">16</td>
<td id="P7000497027000000000000000040FCE" data-uri="chapter03.xhtml#P7000497027000000000000000040FCE" class="calibre20 pcalibre pcalibre1">24</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000040FCF" data-uri="chapter03.xhtml#P7000497027000000000000000040FCF" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000040FD0" data-uri="chapter03.xhtml#P7000497027000000000000000040FD0" class="calibre10 pcalibre pcalibre1">U3</code></td>
<td id="P7000497027000000000000000040FD1" data-uri="chapter03.xhtml#P7000497027000000000000000040FD1" class="calibre20 pcalibre pcalibre1">0</td>
<td id="P7000497027000000000000000040FD2" data-uri="chapter03.xhtml#P7000497027000000000000000040FD2" class="calibre20 pcalibre pcalibre1">0</td>
<td id="P7000497027000000000000000040FD3" data-uri="chapter03.xhtml#P7000497027000000000000000040FD3" class="calibre20 pcalibre pcalibre1">0</td>
<td id="P7000497027000000000000000040FD4" data-uri="chapter03.xhtml#P7000497027000000000000000040FD4" class="calibre20 pcalibre pcalibre1">8</td>
</tr>
</tbody>
</table>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040FD5" data-uri="chapter03.xhtml#P7000497027000000000000000040FD5">(We will see shortly why <code id="P7000497027000000000000000040FD6" data-uri="chapter03.xhtml#P7000497027000000000000000040FD6" class="pcalibre1 calibre8 pcalibre">i</code> has offset 4 in <code id="P7000497027000000000000000040FD7" data-uri="chapter03.xhtml#P7000497027000000000000000040FD7" class="pcalibre1 calibre8 pcalibre">S3</code> rather than 1, and why <code id="P7000497027000000000000000040FD8" data-uri="chapter03.xhtml#P7000497027000000000000000040FD8" class="pcalibre1 calibre8 pcalibre">v</code> has offset 16, rather than 9 or 12.) For pointer <code id="P7000497027000000000000000040FD9" data-uri="chapter03.xhtml#P7000497027000000000000000040FD9" class="pcalibre1 calibre8 pcalibre">p</code> of type union <code id="P7000497027000000000000000040FDA" data-uri="chapter03.xhtml#P7000497027000000000000000040FDA" class="pcalibre1 calibre8 pcalibre">U3</code> *, references <code id="P7000497027000000000000000040FDB" data-uri="chapter03.xhtml#P7000497027000000000000000040FDB" class="pcalibre1 calibre8 pcalibre">p-&gt;c, p-&gt;i[0]</code>, and <code id="P7000497027000000000000000040FDC" data-uri="chapter03.xhtml#P7000497027000000000000000040FDC" class="pcalibre1 calibre8 pcalibre">p-&gt;v</code> would all reference the beginning of the data structure. Observe also that the overall size of a union equals the maximum size of any of its fields.</p>
<p id="P7000497027000000000000000040FDD" data-uri="chapter03.xhtml#P7000497027000000000000000040FDD" class="pcalibre1 pcalibre calibre2">Unions can be useful in several contexts. However, they can also lead to nasty bugs, since they bypass the safety provided by the C type system. One application is when we know in advance that the use of two different fields in a data structure will be mutually exclusive. Then, declaring these two fields as part of a union rather than a structure will reduce the total space allocated.</p>
<p id="P7000497027000000000000000040FDE" data-uri="chapter03.xhtml#P7000497027000000000000000040FDE" class="pcalibre1 pcalibre calibre2">For example, suppose we want to implement a binary tree data structure where each leaf node has two <code id="P7000497027000000000000000040FDF" data-uri="chapter03.xhtml#P7000497027000000000000000040FDF" class="pcalibre1 calibre8 pcalibre">double</code> data values and each internal node has pointers to two children but no data. If we declare this as</p>
<pre id="P7000497027000000000000000040FE0" data-uri="chapter03.xhtml#P7000497027000000000000000040FE0" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040FE1" data-uri="chapter03.xhtml#P7000497027000000000000000040FE1" class="calibre10 pcalibre pcalibre1">
struct node_s {
	struct node_s *left;
	struct node_s *right;
	double data[2];
};
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040FE2" data-uri="chapter03.xhtml#P7000497027000000000000000040FE2">then every node requires 32 bytes, with half the bytes wasted for each type of node. On the other hand, if we declare a node as</p>
<pre id="P7000497027000000000000000040FE3" data-uri="chapter03.xhtml#P7000497027000000000000000040FE3" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040FE4" data-uri="chapter03.xhtml#P7000497027000000000000000040FE4" class="calibre10 pcalibre pcalibre1">
union node_u {
	struct {
	  union node_u *left;
	  union node_u *right;
	} internal;
	double data[2];
};
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040FE5" data-uri="chapter03.xhtml#P7000497027000000000000000040FE5">then every node will require just 16 bytes. If <code id="P7000497027000000000000000040FE6" data-uri="chapter03.xhtml#P7000497027000000000000000040FE6" class="pcalibre1 calibre8 pcalibre">n</code> is a pointer to a node of type union <code id="P7000497027000000000000000040FE7" data-uri="chapter03.xhtml#P7000497027000000000000000040FE7" class="pcalibre1 calibre8 pcalibre">node_u *</code>, we would reference the data of a leaf node as <code id="P7000497027000000000000000040FE8" data-uri="chapter03.xhtml#P7000497027000000000000000040FE8" class="pcalibre1 calibre8 pcalibre">n-&gt;data[0]</code> and <code id="P7000497027000000000000000040FE9" data-uri="chapter03.xhtml#P7000497027000000000000000040FE9" class="pcalibre1 calibre8 pcalibre">n-&gt;data[1]</code>, and the children of an internal node as <code id="P7000497027000000000000000040FEA" data-uri="chapter03.xhtml#P7000497027000000000000000040FEA" class="pcalibre1 calibre8 pcalibre">n-&gt;internal.left</code> and <code id="P7000497027000000000000000040FEB" data-uri="chapter03.xhtml#P7000497027000000000000000040FEB" class="pcalibre1 calibre8 pcalibre">n-&gt;internal.right.</code></p>
<p id="P7000497027000000000000000040FEC" data-uri="chapter03.xhtml#P7000497027000000000000000040FEC" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002D9A" title="271" data-uri="chapter03.xhtml#P7000497027000000000000000002D9A" epub:type="pagebreak"></span>With this encoding, however, there is no way to determine whether a given node is a leaf or an internal node. A common method is to introduce an enumerated type defining the different possible choices for the union, and then create a structure containing a tag field and the union:</p>
<pre id="P7000497027000000000000000040FED" data-uri="chapter03.xhtml#P7000497027000000000000000040FED" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040FEE" data-uri="chapter03.xhtml#P7000497027000000000000000040FEE" class="calibre10 pcalibre pcalibre1">
typedef enum { N_LEAF, N_INTERNAL } nodetype_t;

struct node_t {
	nodetype_t type;
	union {
	  struct {
	  	struct node_t *left;
	  	struct node_t *right;
	  } internal;
	  double data[2];
	} info;
};
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040FEF" data-uri="chapter03.xhtml#P7000497027000000000000000040FEF">This structure requires a total of 24 bytes: 4 for <code id="P7000497027000000000000000040FF0" data-uri="chapter03.xhtml#P7000497027000000000000000040FF0" class="pcalibre1 calibre8 pcalibre">type</code>, and either 8 each for <code id="P7000497027000000000000000040FF1" data-uri="chapter03.xhtml#P7000497027000000000000000040FF1" class="pcalibre1 calibre8 pcalibre">info.internal.left</code> and <code id="P7000497027000000000000000040FF2" data-uri="chapter03.xhtml#P7000497027000000000000000040FF2" class="pcalibre1 calibre8 pcalibre">info.internal.right</code> or 16 for <code id="P7000497027000000000000000040FF3" data-uri="chapter03.xhtml#P7000497027000000000000000040FF3" class="pcalibre1 calibre8 pcalibre">info.data.</code> As we will discuss shortly, an additional 4 bytes of padding is required between the field for type and the union elements, bringing the total structure size to 4 + 4 + 16 = 24. In this case, the savings gain of using a union is small relative to the awkwardness of the resulting code. For data structures with more fields, the savings can be more compelling.</p>
<p id="P7000497027000000000000000040FF4" data-uri="chapter03.xhtml#P7000497027000000000000000040FF4" class="pcalibre1 pcalibre calibre2">Unions can also be used to access the bit patterns of different data types. For example, suppose we use a simple cast to convert a value d of type <code id="P7000497027000000000000000040FF5" data-uri="chapter03.xhtml#P7000497027000000000000000040FF5" class="pcalibre1 calibre8 pcalibre">double</code> to a value <code id="P7000497027000000000000000040FF6" data-uri="chapter03.xhtml#P7000497027000000000000000040FF6" class="pcalibre1 calibre8 pcalibre">u</code> of type unsigned <code id="P7000497027000000000000000040FF7" data-uri="chapter03.xhtml#P7000497027000000000000000040FF7" class="pcalibre1 calibre8 pcalibre">long</code>:</p>
<pre id="P7000497027000000000000000040FF8" data-uri="chapter03.xhtml#P7000497027000000000000000040FF8" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000040FF9" data-uri="chapter03.xhtml#P7000497027000000000000000040FF9" class="calibre10 pcalibre pcalibre1">
unsigned long u = (unsigned long) d;
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000040FFA" data-uri="chapter03.xhtml#P7000497027000000000000000040FFA">Value <code id="P7000497027000000000000000040FFB" data-uri="chapter03.xhtml#P7000497027000000000000000040FFB" class="pcalibre1 calibre8 pcalibre">u</code> will be an integer representation of <code id="P7000497027000000000000000040FFC" data-uri="chapter03.xhtml#P7000497027000000000000000040FFC" class="pcalibre1 calibre8 pcalibre">d</code>. Except for the case where <code id="P7000497027000000000000000040FFD" data-uri="chapter03.xhtml#P7000497027000000000000000040FFD" class="pcalibre1 calibre8 pcalibre">d</code> is 0.0, the bit representation of <code id="P7000497027000000000000000040FFE" data-uri="chapter03.xhtml#P7000497027000000000000000040FFE" class="pcalibre1 calibre8 pcalibre">u</code> will be very different from that of <code id="P7000497027000000000000000040FFF" data-uri="chapter03.xhtml#P7000497027000000000000000040FFF" class="pcalibre1 calibre8 pcalibre">d</code>. Now consider the following code to generate a value of type <code id="P7000497027000000000000000041000" data-uri="chapter03.xhtml#P7000497027000000000000000041000" class="pcalibre1 calibre8 pcalibre">unsigned</code> long from a <code id="P7000497027000000000000000041001" data-uri="chapter03.xhtml#P7000497027000000000000000041001" class="pcalibre1 calibre8 pcalibre">double</code>:</p>
<pre id="P7000497027000000000000000041002" data-uri="chapter03.xhtml#P7000497027000000000000000041002" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041003" data-uri="chapter03.xhtml#P7000497027000000000000000041003" class="calibre10 pcalibre pcalibre1">
unsigned long double2bits(double d) {
	union {
	  double d;
	  unsigned long u;
	} temp;
	temp.d = d;
	return temp.u;
};
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041004" data-uri="chapter03.xhtml#P7000497027000000000000000041004">In this code, we store the argument in the union using one data type and access it using another. The result will be that <code id="P7000497027000000000000000041005" data-uri="chapter03.xhtml#P7000497027000000000000000041005" class="pcalibre1 calibre8 pcalibre">u</code> will have the same bit representation as <code id="P7000497027000000000000000041006" data-uri="chapter03.xhtml#P7000497027000000000000000041006" class="pcalibre1 calibre8 pcalibre">d</code>, including fields for the sign bit, the exponent, and the significand, as described in <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002DB5" title="272" data-uri="chapter03.xhtml#P7000497027000000000000000002DB5" epub:type="pagebreak"></span><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000003080.xhtml#P7000497027000000000000000003080"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">3.11</span></a>. The numeric value of <code id="P7000497027000000000000000041007" data-uri="chapter03.xhtml#P7000497027000000000000000041007" class="pcalibre1 calibre8 pcalibre">u</code> will bear no relation to that of <code id="P7000497027000000000000000041008" data-uri="chapter03.xhtml#P7000497027000000000000000041008" class="pcalibre1 calibre8 pcalibre">d</code>, except for the case when <code id="P7000497027000000000000000041009" data-uri="chapter03.xhtml#P7000497027000000000000000041009" class="pcalibre1 calibre8 pcalibre">d</code> is 0.0.</p>
<p id="P700049702700000000000000004100A" data-uri="chapter03.xhtml#P700049702700000000000000004100A" class="pcalibre1 pcalibre calibre2">When using unions to combine data types of different sizes, byte-ordering issues can become important. For example, suppose we write a procedure that will create an 8-byte <code id="P700049702700000000000000004100B" data-uri="chapter03.xhtml#P700049702700000000000000004100B" class="pcalibre1 calibre8 pcalibre">double</code> using the bit patterns given by two 4-byte <code id="P700049702700000000000000004100C" data-uri="chapter03.xhtml#P700049702700000000000000004100C" class="pcalibre1 calibre8 pcalibre">unsigned</code> values:</p>
<pre id="P700049702700000000000000004100D" data-uri="chapter03.xhtml#P700049702700000000000000004100D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004100E" data-uri="chapter03.xhtml#P700049702700000000000000004100E" class="calibre10 pcalibre pcalibre1">
double uu2double(unsigned word0, unsigned word1)
{
	union {
	  double d;
	  unsigned u[2];
	} temp;
	temp.u[0] = word0;
	temp.u[1] = word1;
	return temp.d;
}
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004100F" data-uri="chapter03.xhtml#P700049702700000000000000004100F">On a little-endian machine, such as an x86-64 processor, argument <code id="P7000497027000000000000000041010" data-uri="chapter03.xhtml#P7000497027000000000000000041010" class="pcalibre1 calibre8 pcalibre">word0</code> will become the low-order 4 bytes of <code id="P7000497027000000000000000041011" data-uri="chapter03.xhtml#P7000497027000000000000000041011" class="pcalibre1 calibre8 pcalibre">d</code>, while <code id="P7000497027000000000000000041012" data-uri="chapter03.xhtml#P7000497027000000000000000041012" class="pcalibre1 calibre8 pcalibre">word1</code> will become the high-order 4 bytes. On a big-endian machine, the role of the two arguments will be reversed.</p>
<section id="P7000497027000000000000000002DC2" data-uri="chapter03.xhtml#P7000497027000000000000000002DC2" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041013" data-uri="chapter03.xhtml#P7000497027000000000000000041013" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.43 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P7000497027000000000000000003855">344</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000041014" data-uri="chapter03.xhtml#P7000497027000000000000000041014">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000041015" data-uri="chapter03.xhtml#P7000497027000000000000000041015">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041016" data-uri="chapter03.xhtml#P7000497027000000000000000041016"><p id="P7000497027000000000000000041017" data-uri="chapter03.xhtml#P7000497027000000000000000041017" class="pcalibre calibre3 pcalibre1">Suppose you are given the job of checking that a C compiler generates the proper code for structure and union access. You write the following structure declaration:</p>
<pre id="P7000497027000000000000000041018" data-uri="chapter03.xhtml#P7000497027000000000000000041018" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041019" data-uri="chapter03.xhtml#P7000497027000000000000000041019" class="calibre10 pcalibre pcalibre1">
typedef union {
	struct {
	  long u;
	  short v;
	  char w;
	} t1;
	struct {
	  int a[2];
	  char *p;
	} t2;
} u_type;
</code></pre>
<p id="P700049702700000000000000004101A" data-uri="chapter03.xhtml#P700049702700000000000000004101A" class="pcalibre calibre3 pcalibre1">You write a series of functions of the form</p>
<pre id="P700049702700000000000000004101B" data-uri="chapter03.xhtml#P700049702700000000000000004101B" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004101C" data-uri="chapter03.xhtml#P700049702700000000000000004101C" class="calibre10 pcalibre pcalibre1">
void get(u_type *up, <i class="calibre5 pcalibre pcalibre1">type</i> *dest) {
	*dest = <i class="calibre5 pcalibre pcalibre1">expr</i>;
}
</code></pre>
<p class="pcalibre calibre3 pcalibre1" id="P700049702700000000000000004101D" data-uri="chapter03.xhtml#P700049702700000000000000004101D">with different access expressions <i class="calibre5 pcalibre pcalibre1">expr</i> and with destination data type <i class="calibre5 pcalibre pcalibre1">type</i> set according to type associated with <i class="calibre5 pcalibre pcalibre1">expr</i>. You then examine the code generated when compiling the functions to see if they match your expectations.</p>
<p id="P700049702700000000000000004101E" data-uri="chapter03.xhtml#P700049702700000000000000004101E" class="pcalibre calibre3 pcalibre1"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002DCF" title="273" data-uri="chapter03.xhtml#P7000497027000000000000000002DCF" epub:type="pagebreak"></span>Suppose in these functions that <code id="P700049702700000000000000004101F" data-uri="chapter03.xhtml#P700049702700000000000000004101F" class="pcalibre1 calibre8 pcalibre">up</code> and <code id="P7000497027000000000000000041020" data-uri="chapter03.xhtml#P7000497027000000000000000041020" class="pcalibre1 calibre8 pcalibre">dest</code> are loaded into registers <code id="P7000497027000000000000000041021" data-uri="chapter03.xhtml#P7000497027000000000000000041021" class="pcalibre1 calibre8 pcalibre">%rdi</code> and <code id="P7000497027000000000000000041022" data-uri="chapter03.xhtml#P7000497027000000000000000041022" class="pcalibre1 calibre8 pcalibre">%rsi</code>, respectively. Fill in the following table with data type <i class="calibre5 pcalibre pcalibre1">type</i> and sequences of one to three instructions to compute the expression and store the result at <code id="P7000497027000000000000000041023" data-uri="chapter03.xhtml#P7000497027000000000000000041023" class="pcalibre1 calibre8 pcalibre">dest</code>.</p>
<table id="P7000497027000000000000000041024" data-uri="chapter03.xhtml#P7000497027000000000000000041024" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000041025" data-uri="chapter03.xhtml#P7000497027000000000000000041025" class="calibre18 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">expr</i></th>
<th id="P7000497027000000000000000041026" data-uri="chapter03.xhtml#P7000497027000000000000000041026" class="calibre18 pcalibre pcalibre1"><i class="calibre5 pcalibre pcalibre1">type</i></th>
<th id="P7000497027000000000000000041027" data-uri="chapter03.xhtml#P7000497027000000000000000041027" class="calibre18 pcalibre pcalibre1">Code</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041028" data-uri="chapter03.xhtml#P7000497027000000000000000041028" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041029" data-uri="chapter03.xhtml#P7000497027000000000000000041029" class="calibre10 pcalibre pcalibre1">up-&gt;t1.u</code></td>
<td id="P700049702700000000000000004102A" data-uri="chapter03.xhtml#P700049702700000000000000004102A" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004102B" data-uri="chapter03.xhtml#P700049702700000000000000004102B" class="calibre10 pcalibre pcalibre1">long</code></td>
<td id="P700049702700000000000000004102C" data-uri="chapter03.xhtml#P700049702700000000000000004102C" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004102D" data-uri="chapter03.xhtml#P700049702700000000000000004102D" class="calibre10 pcalibre pcalibre1">movq (%rdi), %rax</code><br class="edition pcalibre pcalibre1"/><code id="P700049702700000000000000004102E" data-uri="chapter03.xhtml#P700049702700000000000000004102E" class="calibre10 pcalibre pcalibre1">movq %rax, (%rsi)</code></td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004102F" data-uri="chapter03.xhtml#P700049702700000000000000004102F" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041030" data-uri="chapter03.xhtml#P7000497027000000000000000041030" class="calibre10 pcalibre pcalibre1">up-&gt;t1.v</code></td>
<td id="P7000497027000000000000000041031" data-uri="chapter03.xhtml#P7000497027000000000000000041031" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P7000497027000000000000000041032" data-uri="chapter03.xhtml#P7000497027000000000000000041032" class="calibre20 pcalibre pcalibre1">____________________<br class="edition pcalibre pcalibre1"/>____________________<br class="edition pcalibre pcalibre1"/>____________________</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041033" data-uri="chapter03.xhtml#P7000497027000000000000000041033" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041034" data-uri="chapter03.xhtml#P7000497027000000000000000041034" class="calibre10 pcalibre pcalibre1">up-&gt;t1.w</code></td>
<td id="P7000497027000000000000000041035" data-uri="chapter03.xhtml#P7000497027000000000000000041035" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P7000497027000000000000000041036" data-uri="chapter03.xhtml#P7000497027000000000000000041036" class="calibre20 pcalibre pcalibre1">____________________<br class="edition pcalibre pcalibre1"/>____________________<br class="edition pcalibre pcalibre1"/>____________________</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041037" data-uri="chapter03.xhtml#P7000497027000000000000000041037" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041038" data-uri="chapter03.xhtml#P7000497027000000000000000041038" class="calibre10 pcalibre pcalibre1">up-&gt;t2.a</code></td>
<td id="P7000497027000000000000000041039" data-uri="chapter03.xhtml#P7000497027000000000000000041039" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P700049702700000000000000004103A" data-uri="chapter03.xhtml#P700049702700000000000000004103A" class="calibre20 pcalibre pcalibre1">____________________<br class="edition pcalibre pcalibre1"/>____________________<br class="edition pcalibre pcalibre1"/>____________________</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004103B" data-uri="chapter03.xhtml#P700049702700000000000000004103B" class="calibre20 pcalibre pcalibre1"><code id="P700049702700000000000000004103C" data-uri="chapter03.xhtml#P700049702700000000000000004103C" class="calibre10 pcalibre pcalibre1">up-&gt;t2.a[up-&gt;t1.u]</code></td>
<td id="P700049702700000000000000004103D" data-uri="chapter03.xhtml#P700049702700000000000000004103D" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P700049702700000000000000004103E" data-uri="chapter03.xhtml#P700049702700000000000000004103E" class="calibre20 pcalibre pcalibre1">____________________<br class="edition pcalibre pcalibre1"/>____________________<br class="edition pcalibre pcalibre1"/>____________________</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004103F" data-uri="chapter03.xhtml#P700049702700000000000000004103F" class="calibre20 pcalibre pcalibre1"><code id="P7000497027000000000000000041040" data-uri="chapter03.xhtml#P7000497027000000000000000041040" class="calibre10 pcalibre pcalibre1">*up-&gt;t2.p</code></td>
<td id="P7000497027000000000000000041041" data-uri="chapter03.xhtml#P7000497027000000000000000041041" class="calibre20 pcalibre pcalibre1">__________</td>
<td id="P7000497027000000000000000041042" data-uri="chapter03.xhtml#P7000497027000000000000000041042" class="calibre20 pcalibre pcalibre1">____________________<br class="edition pcalibre pcalibre1"/>____________________<br class="edition pcalibre pcalibre1"/>____________________</td>
</tr>
</tbody>
</table>
</div></li></ol>
</section>
</section>
<section id="P7000497027000000000000000002DF4" data-uri="chapter03.xhtml#P7000497027000000000000000002DF4" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000041043" data-uri="chapter03.xhtml#P7000497027000000000000000041043" epub:type="title"><span class="pcalibre label pcalibre1">3.9.3 </span>Data Alignment</h1></header>
<p id="P7000497027000000000000000041044" data-uri="chapter03.xhtml#P7000497027000000000000000041044" class="pcalibre1 pcalibre calibre2">Many computer systems place restrictions on the allowable addresses for the primitive data types, requiring that the address for some objects must be a multiple of some value <var class="calibre5 pcalibre pcalibre1">K</var> (typically 2, 4, or 8). Such <i class="calibre5 pcalibre pcalibre1">alignment restrictions</i> simplify the design of the hardware forming the interface between the processor and the memory system. For example, suppose a processor always fetches 8 bytes from memory with an address that must be a multiple of 8. If we can guarantee that any double will be aligned to have its address be a multiple of 8, then the value can be read or written with a single memory operation. Otherwise, we may need to perform two memory accesses, since the object might be split across two 8-byte memory blocks.</p>
<p id="P7000497027000000000000000041045" data-uri="chapter03.xhtml#P7000497027000000000000000041045" class="pcalibre1 pcalibre calibre2">The x86-64 hardware will work correctly regardless of the alignment of data. However, Intel recommends that data be aligned to improve memory system performance. Their alignment rule is based on the principle that any primitive object of <var class="calibre5 pcalibre pcalibre1">K</var> bytes must have an address that is a multiple of <var class="calibre5 pcalibre pcalibre1">K</var>. We can see that this rule leads to the following alignments:</p>
<table id="P7000497027000000000000000041046" data-uri="chapter03.xhtml#P7000497027000000000000000041046" class="pcalibre largetable pcalibre1">
<thead class="pcalibre1 pcalibre calibre16">
<tr class="pcalibre calibre17 pcalibre1">
<th id="P7000497027000000000000000041047" data-uri="chapter03.xhtml#P7000497027000000000000000041047" class="calibre18 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">K</var></th>
<th id="P7000497027000000000000000041048" data-uri="chapter03.xhtml#P7000497027000000000000000041048" class="calibre18 pcalibre pcalibre1">Types</th>
</tr>
</thead>
<tbody class="calibre19 pcalibre pcalibre1">
<tr class="pcalibre calibre17 pcalibre1">
<td id="P7000497027000000000000000041049" data-uri="chapter03.xhtml#P7000497027000000000000000041049" class="calibre20 pcalibre pcalibre1">1</td>
<td id="P700049702700000000000000004104A" data-uri="chapter03.xhtml#P700049702700000000000000004104A" class="calibre20 pcalibre pcalibre1">char</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004104B" data-uri="chapter03.xhtml#P700049702700000000000000004104B" class="calibre20 pcalibre pcalibre1">2</td>
<td id="P700049702700000000000000004104C" data-uri="chapter03.xhtml#P700049702700000000000000004104C" class="calibre20 pcalibre pcalibre1">short</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004104D" data-uri="chapter03.xhtml#P700049702700000000000000004104D" class="calibre20 pcalibre pcalibre1">4</td>
<td id="P700049702700000000000000004104E" data-uri="chapter03.xhtml#P700049702700000000000000004104E" class="calibre20 pcalibre pcalibre1">int, float</td>
</tr>
<tr class="pcalibre calibre17 pcalibre1">
<td id="P700049702700000000000000004104F" data-uri="chapter03.xhtml#P700049702700000000000000004104F" class="calibre20 pcalibre pcalibre1">8</td>
<td id="P7000497027000000000000000041050" data-uri="chapter03.xhtml#P7000497027000000000000000041050" class="calibre20 pcalibre pcalibre1">long, double, char *</td>
</tr>
</tbody>
</table>
<p id="P7000497027000000000000000041051" data-uri="chapter03.xhtml#P7000497027000000000000000041051" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002E04" title="274" data-uri="chapter03.xhtml#P7000497027000000000000000002E04" epub:type="pagebreak"></span>Alignment is enforced by making sure that every data type is organized and allocated in such a way that every object within the type satisfies its alignment restrictions. The compiler places directives in the assembly code indicating the desired alignment for global data. For example, the assembly-code declaration of the jump table on page 235 contains the following directive on line 2:</p>
<pre id="P7000497027000000000000000041052" data-uri="chapter03.xhtml#P7000497027000000000000000041052" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041053" data-uri="chapter03.xhtml#P7000497027000000000000000041053" class="calibre10 pcalibre pcalibre1">
.align 8
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041054" data-uri="chapter03.xhtml#P7000497027000000000000000041054">This ensures that the data following it (in this case the start of the jump table) will start with an address that is a multiple of 8. Since each table entry is 8 bytes long, the successive elements will obey the 8-byte alignment restriction.</p>
<p id="P7000497027000000000000000041055" data-uri="chapter03.xhtml#P7000497027000000000000000041055" class="pcalibre1 pcalibre calibre2">For code involving structures, the compiler may need to insert gaps in the field allocation to ensure that each structure element satisfies its alignment requirement. The structure will then have some required alignment for its starting address.</p>
<p id="P7000497027000000000000000041056" data-uri="chapter03.xhtml#P7000497027000000000000000041056" class="pcalibre1 pcalibre calibre2">For example, consider the structure declaration</p>
<pre id="P7000497027000000000000000041057" data-uri="chapter03.xhtml#P7000497027000000000000000041057" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000041058" data-uri="chapter03.xhtml#P7000497027000000000000000041058" class="calibre10 pcalibre pcalibre1">
struct S1 {
	int i;
	char c;
	int j;
};
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041059" data-uri="chapter03.xhtml#P7000497027000000000000000041059">Suppose the compiler used the minimal 9-byte allocation, diagrammed as follows:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002E0D" data-uri="chapter03.xhtml#P7000497027000000000000000002E0D">
<img alt="A diagram shows three fields: offset 0 to 4 with contents i; offset 4 to 5 with contents c; offset 5 to 9 with contents j." id="P700049702700000000000000004105A" data-uri="P700049702700000000000000000B6BE" src="../images/p274-1.png" class="pcalibre1 calibre94 pcalibre"/>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004105B" data-uri="chapter03.xhtml#P700049702700000000000000004105B">Then it would be impossible to satisfy the 4-byte alignment requirement for both fields <code id="P700049702700000000000000004105C" data-uri="chapter03.xhtml#P700049702700000000000000004105C" class="pcalibre1 calibre8 pcalibre">i</code> (offset 0) and <code id="P700049702700000000000000004105D" data-uri="chapter03.xhtml#P700049702700000000000000004105D" class="pcalibre1 calibre8 pcalibre">j</code> (offset 5). Instead, the compiler inserts a 3-byte gap (shown here as shaded in blue) between fields <code id="P700049702700000000000000004105E" data-uri="chapter03.xhtml#P700049702700000000000000004105E" class="pcalibre1 calibre8 pcalibre">c</code> and <code id="P700049702700000000000000004105F" data-uri="chapter03.xhtml#P700049702700000000000000004105F" class="pcalibre1 calibre8 pcalibre">j</code>:</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002E14" data-uri="chapter03.xhtml#P7000497027000000000000000002E14">
<img alt="A diagram shows four fields: offset 0 to 4 with contents i; offset 4 to 5 with contents c; offset 5 to 8 with a blue gap; offset 8 to 12 with contents j." id="P7000497027000000000000000041060" data-uri="P700049702700000000000000000B6BF" src="../images/p274-2.png" class="calibre95 pcalibre pcalibre1"/>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041061" data-uri="chapter03.xhtml#P7000497027000000000000000041061">As a result, <code id="P7000497027000000000000000041062" data-uri="chapter03.xhtml#P7000497027000000000000000041062" class="pcalibre1 calibre8 pcalibre">j</code> has offset 8, and the overall structure size is 12 bytes. Furthermore, the compiler must ensure that any pointer <code id="P7000497027000000000000000041063" data-uri="chapter03.xhtml#P7000497027000000000000000041063" class="pcalibre1 calibre8 pcalibre">p</code> of type <code id="P7000497027000000000000000041064" data-uri="chapter03.xhtml#P7000497027000000000000000041064" class="pcalibre1 calibre8 pcalibre">struct S1*</code> satisfies a 4-byte alignment. Using our earlier notation, let pointer <code id="P7000497027000000000000000041065" data-uri="chapter03.xhtml#P7000497027000000000000000041065" class="pcalibre1 calibre8 pcalibre">p</code> have value <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041066" data-uri="chapter03.xhtml#P7000497027000000000000000041066" class="pcalibre1 pcalibre calibre74">p</code></sub>. Then <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041067" data-uri="chapter03.xhtml#P7000497027000000000000000041067" class="pcalibre1 pcalibre calibre74">p</code></sub> must be a multiple of 4. This guarantees that both <code id="P7000497027000000000000000041068" data-uri="chapter03.xhtml#P7000497027000000000000000041068" class="pcalibre1 calibre8 pcalibre">p-&gt;i</code> (address <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041069" data-uri="chapter03.xhtml#P7000497027000000000000000041069" class="pcalibre1 pcalibre calibre74">p</code></sub>) and <code id="P700049702700000000000000004106A" data-uri="chapter03.xhtml#P700049702700000000000000004106A" class="pcalibre1 calibre8 pcalibre">p-&gt;j</code> (address <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P700049702700000000000000004106B" data-uri="chapter03.xhtml#P700049702700000000000000004106B" class="pcalibre1 pcalibre calibre74">p</code></sub> + 8) will satisfy their 4-byte alignment requirements.</p>
<p id="P700049702700000000000000004106C" data-uri="chapter03.xhtml#P700049702700000000000000004106C" class="pcalibre1 pcalibre calibre2">In addition, the compiler may need to add padding to the end of the structure so that each element in an array of structures will satisfy its alignment requirement. For example, consider the following structure declaration:</p>
<pre id="P700049702700000000000000004106D" data-uri="chapter03.xhtml#P700049702700000000000000004106D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004106E" data-uri="chapter03.xhtml#P700049702700000000000000004106E" class="calibre10 pcalibre pcalibre1">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002E24" title="275" data-uri="chapter03.xhtml#P7000497027000000000000000002E24" epub:type="pagebreak"></span>struct S2 {
	int i;
	int j;
	char c;
};
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004106F" data-uri="chapter03.xhtml#P700049702700000000000000004106F">If we pack this structure into 9 bytes, we can still satisfy the alignment requirements for fields <code id="P7000497027000000000000000041070" data-uri="chapter03.xhtml#P7000497027000000000000000041070" class="pcalibre1 calibre8 pcalibre">i</code> and <code id="P7000497027000000000000000041071" data-uri="chapter03.xhtml#P7000497027000000000000000041071" class="pcalibre1 calibre8 pcalibre">j</code> by making sure that the starting address of the structure satisfies a 4-byte alignment requirement. Consider, however, the following declaration:</p>
<code id="P7000497027000000000000000041072" data-uri="chapter03.xhtml#P7000497027000000000000000041072" class="pcalibre1 calibre8 pcalibre">struct S2 d[4];</code>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000041073" data-uri="chapter03.xhtml#P7000497027000000000000000041073">With the 9-byte allocation, it is not possible to satisfy the alignment requirement for each element of <code id="P7000497027000000000000000041074" data-uri="chapter03.xhtml#P7000497027000000000000000041074" class="pcalibre1 calibre8 pcalibre">d</code>, because these elements will have addresses <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041075" data-uri="chapter03.xhtml#P7000497027000000000000000041075" class="pcalibre1 pcalibre calibre74">d</code></sub>, <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041076" data-uri="chapter03.xhtml#P7000497027000000000000000041076" class="pcalibre1 pcalibre calibre74">d</code></sub> + 9, <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041077" data-uri="chapter03.xhtml#P7000497027000000000000000041077" class="pcalibre1 pcalibre calibre74">d</code></sub> + 18, and <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041078" data-uri="chapter03.xhtml#P7000497027000000000000000041078" class="pcalibre1 pcalibre calibre74">d</code></sub> + 27. Instead, the compiler allocates 12 bytes for structure <code id="P7000497027000000000000000041079" data-uri="chapter03.xhtml#P7000497027000000000000000041079" class="pcalibre1 calibre8 pcalibre">S2</code>, with the final 3 bytes being wasted space:</p>

<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000002E30" data-uri="chapter03.xhtml#P7000497027000000000000000002E30">
<img alt="A diagram shows four fields: offset 0 to 4 with contents i; offset 4 to 8 with contents j; offset 8 to 9 with contents c; offset 9 to 12 with a blue gap." id="P700049702700000000000000004107A" data-uri="P700049702700000000000000000B6C0" src="../images/p275-1.png" class="calibre95 pcalibre pcalibre1"/>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004107B" data-uri="chapter03.xhtml#P700049702700000000000000004107B">That way, the elements of <code id="P700049702700000000000000004107C" data-uri="chapter03.xhtml#P700049702700000000000000004107C" class="pcalibre1 calibre8 pcalibre">d</code> will have addresses <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P700049702700000000000000004107D" data-uri="chapter03.xhtml#P700049702700000000000000004107D" class="pcalibre1 pcalibre calibre74">d</code></sub>, <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P700049702700000000000000004107E" data-uri="chapter03.xhtml#P700049702700000000000000004107E" class="pcalibre1 pcalibre calibre74">d</code></sub> + 12, <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P700049702700000000000000004107F" data-uri="chapter03.xhtml#P700049702700000000000000004107F" class="pcalibre1 pcalibre calibre74">d</code></sub> + 24, and <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041080" data-uri="chapter03.xhtml#P7000497027000000000000000041080" class="pcalibre1 pcalibre calibre74">d</code></sub> + 36. As long as <var class="calibre5 pcalibre pcalibre1">x</var><sub class="pcalibre1 calibre47 pcalibre"><code id="P7000497027000000000000000041081" data-uri="chapter03.xhtml#P7000497027000000000000000041081" class="pcalibre1 pcalibre calibre74">d</code></sub> is a multiple of 4, all of the alignment restrictions will be satisfied.</p>
<section id="P7000497027000000000000000002E39" data-uri="chapter03.xhtml#P7000497027000000000000000002E39" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041082" data-uri="chapter03.xhtml#P7000497027000000000000000041082" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.44 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P700049702700000000000000000389F">345</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000041083" data-uri="chapter03.xhtml#P7000497027000000000000000041083">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000041084" data-uri="chapter03.xhtml#P7000497027000000000000000041084">
<div class="edition pcalibre pcalibre1" id="P7000497027000000000000000041085" data-uri="chapter03.xhtml#P7000497027000000000000000041085"><p id="P7000497027000000000000000041086" data-uri="chapter03.xhtml#P7000497027000000000000000041086" class="pcalibre calibre3 pcalibre1">For each of the following structure declarations, determine the offset of each field, the total size of the structure, and its alignment requirement for x86-64:</p>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P7000497027000000000000000041087" data-uri="chapter03.xhtml#P7000497027000000000000000041087">
<li id="P7000497027000000000000000041088" data-uri="chapter03.xhtml#P7000497027000000000000000041088" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041089" data-uri="chapter03.xhtml#P7000497027000000000000000041089" class="pcalibre calibre3 pcalibre1"><code id="P700049702700000000000000004108A" data-uri="chapter03.xhtml#P700049702700000000000000004108A" class="pcalibre1 calibre8 pcalibre">struct P1 { int i; char c; int j; char d; };</code></p></li>
<li id="P700049702700000000000000004108B" data-uri="chapter03.xhtml#P700049702700000000000000004108B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004108C" data-uri="chapter03.xhtml#P700049702700000000000000004108C" class="pcalibre calibre3 pcalibre1"><code id="P700049702700000000000000004108D" data-uri="chapter03.xhtml#P700049702700000000000000004108D" class="pcalibre1 calibre8 pcalibre">struct P2 { int i; char c; char d; long j; };</code></p></li>
<li id="P700049702700000000000000004108E" data-uri="chapter03.xhtml#P700049702700000000000000004108E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004108F" data-uri="chapter03.xhtml#P700049702700000000000000004108F" class="pcalibre calibre3 pcalibre1"><code id="P7000497027000000000000000041090" data-uri="chapter03.xhtml#P7000497027000000000000000041090" class="pcalibre1 calibre8 pcalibre">struct P3 { short w[3]; char c[3] };</code></p></li>
<li id="P7000497027000000000000000041091" data-uri="chapter03.xhtml#P7000497027000000000000000041091" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041092" data-uri="chapter03.xhtml#P7000497027000000000000000041092" class="pcalibre calibre3 pcalibre1"><code id="P7000497027000000000000000041093" data-uri="chapter03.xhtml#P7000497027000000000000000041093" class="pcalibre1 calibre8 pcalibre">struct P4 { short w[5]; char *c[3] };</code></p></li>
<li id="P7000497027000000000000000041094" data-uri="chapter03.xhtml#P7000497027000000000000000041094" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000041095" data-uri="chapter03.xhtml#P7000497027000000000000000041095" class="pcalibre calibre3 pcalibre1"><code id="P7000497027000000000000000041096" data-uri="chapter03.xhtml#P7000497027000000000000000041096" class="pcalibre1 calibre8 pcalibre">struct P5 { struct P3 a[2]; struct P2 t };</code></p></li>
</ol>
</div></li></ol>
</section>
<section id="P7000497027000000000000000002E4F" data-uri="chapter03.xhtml#P7000497027000000000000000002E4F" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000041097" data-uri="chapter03.xhtml#P7000497027000000000000000041097" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">3.45 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP700049702700000000000000000344D_split_001.xhtml#P700049702700000000000000000389F">345</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P7000497027000000000000000041098" data-uri="chapter03.xhtml#P7000497027000000000000000041098">
<li class="general-problem pcalibre pcalibre1" id="P7000497027000000000000000041099" data-uri="chapter03.xhtml#P7000497027000000000000000041099">
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000004109A" data-uri="chapter03.xhtml#P700049702700000000000000004109A"><p id="P700049702700000000000000004109B" data-uri="chapter03.xhtml#P700049702700000000000000004109B" class="pcalibre calibre3 pcalibre1">Answer the following for the structure declaration</p>
<pre id="P700049702700000000000000004109C" data-uri="chapter03.xhtml#P700049702700000000000000004109C" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004109D" data-uri="chapter03.xhtml#P700049702700000000000000004109D" class="calibre10 pcalibre pcalibre1">
struct {
	char	*a;
	short	b;
	double	c;
	char	d;
	float	e;
	char	f;
</code></pre>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000002E57" data-uri="chapter03.xhtml#P7000497027000000000000000002E57"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P700049702700000000000000004109E" data-uri="chapter03.xhtml#P700049702700000000000000004109E" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000002E59" title="276" data-uri="chapter03.xhtml#P7000497027000000000000000002E59" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>A case of mandatory alignment</h1></header>
<p id="P700049702700000000000000004109F" data-uri="chapter03.xhtml#P700049702700000000000000004109F" class="pcalibre calibre3 pcalibre1">For most x86-64 instructions, keeping data aligned improves efficiency, but it does not affect program behavior. On the other hand, some models of Intel and AMD processors will not work correctly with unaligned data for some of the SSE instructions implementing multimedia operations. These instructions operate on 16-byte blocks of data, and the instructions that transfer data between the SSE unit and memory require the memory addresses to be multiples of 16. Any attempt to access memory with an address that does not satisfy this alignment will lead to an <i class="calibre5 pcalibre pcalibre1">exception</i> (see <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP70004970270000000000000000066A6.xhtml#P70004970270000000000000000066A6"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">8.1</span></a>), with the default behavior for the program to terminate.</p>
<p id="P70004970270000000000000000410A0" data-uri="chapter03.xhtml#P70004970270000000000000000410A0" class="pcalibre calibre3 pcalibre1">As a result, any compiler and run-time system for an x86-64 processor must ensure that any memory allocated to hold a data structure that may be read from or stored into an SSE register must satisfy a 16-byte alignment. This requirement has the following two consequences:</p>
<ul id="P70004970270000000000000000410A1" data-uri="chapter03.xhtml#P70004970270000000000000000410A1" class="calibre79 pcalibre pcalibre1">
<li id="P70004970270000000000000000410A2" data-uri="chapter03.xhtml#P70004970270000000000000000410A2" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410A3" data-uri="chapter03.xhtml#P70004970270000000000000000410A3" class="pcalibre calibre3 pcalibre1">The starting address for any block generated by a memory allocation function (<code id="P70004970270000000000000000410A4" data-uri="chapter03.xhtml#P70004970270000000000000000410A4" class="pcalibre1 calibre8 pcalibre">alloca, malloc, calloc</code>, or <code id="P70004970270000000000000000410A5" data-uri="chapter03.xhtml#P70004970270000000000000000410A5" class="pcalibre1 calibre8 pcalibre">realloc</code>) must be a multiple of 16.</p></li>
<li id="P70004970270000000000000000410A6" data-uri="chapter03.xhtml#P70004970270000000000000000410A6" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410A7" data-uri="chapter03.xhtml#P70004970270000000000000000410A7" class="pcalibre calibre3 pcalibre1">The stack frame for most functions must be aligned on a 16-byte boundary. (This requirement has a number of exceptions.)</p></li>
</ul>
<p id="P70004970270000000000000000410A8" data-uri="chapter03.xhtml#P70004970270000000000000000410A8" class="pcalibre calibre3 pcalibre1">More recent versions of x86-64 processors implement the AVX multimedia instructions. In addition to providing a superset of the SSE instructions, processors supporting AVX also do not have a mandatory alignment requirement.</p>
</aside>
<pre id="P70004970270000000000000000410A9" data-uri="chapter03.xhtml#P70004970270000000000000000410A9" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000410AA" data-uri="chapter03.xhtml#P70004970270000000000000000410AA" class="calibre10 pcalibre pcalibre1">
long	g;
int	h;
} rec;
</code></pre>
<ol class="pcalibre ol_upper-alpha pcalibre1" id="P70004970270000000000000000410AB" data-uri="chapter03.xhtml#P70004970270000000000000000410AB">
<li id="P70004970270000000000000000410AC" data-uri="chapter03.xhtml#P70004970270000000000000000410AC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410AD" data-uri="chapter03.xhtml#P70004970270000000000000000410AD" class="pcalibre calibre3 pcalibre1">What are the byte offsets of all the fields in the structure?</p></li>
<li id="P70004970270000000000000000410AE" data-uri="chapter03.xhtml#P70004970270000000000000000410AE" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410AF" data-uri="chapter03.xhtml#P70004970270000000000000000410AF" class="pcalibre calibre3 pcalibre1">What is the total size of the structure?</p></li>
<li id="P70004970270000000000000000410B0" data-uri="chapter03.xhtml#P70004970270000000000000000410B0" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000410B1" data-uri="chapter03.xhtml#P70004970270000000000000000410B1" class="pcalibre calibre3 pcalibre1">Rearrange the fields of the structure to minimize wasted space, and then show the byte offsets and total size for the rearranged structure.</p></li>
</ol>
</div></li></ol>
</section>
</section>
</section></body></html>
