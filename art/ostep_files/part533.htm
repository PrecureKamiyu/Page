<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>The Andrew File System (AFS)</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part532.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part534.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 131pt;text-indent: 0pt;text-align: left;">The Andrew File System (AFS)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: left;">The Andrew File System was introduced by researchers at Carnegie-Mellon University (CMU) in the 1980’s [H+88]. Led by the well-known Profes- sor M. Satyanarayanan of Carnegie-Mellon University (“Satya” for short), the main goal of this project was simple: <b>scale</b>. Specifically, how can one design a distributed file system such that a server can support as many clients as possible?</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Interestingly, there are numerous aspects of design and implementa- tion that affect scalability. Most important is the design of the <b>protocol </b>be- tween clients and servers. In NFS, for example, the protocol forces clients to check with the server periodically to determine if cached contents have changed; because each check uses server resources (including CPU and network bandwidth), frequent checks like this will limit the number of clients a server can respond to and thus limit scalability.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">AFS also differs from NFS in that from the beginning, reasonable user- visible behavior was a first-class concern. In NFS, cache consistency is hard to describe because it depends directly on low-level implementa- tion details, including client-side cache timeout intervals. In AFS, cache consistency is simple and readily understood: when the file is opened, a client will generally receive the latest consistent copy from the server.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part534.htm">49.1 AFS Version 1</a><a class="toc0" href="part535.htm">49.2 Problems with Version 1</a><a class="toc0" href="part536.htm">49.3 Improving the Protocol</a><a class="toc0" href="part537.htm">49.4 AFS Version 2</a><a class="toc1" href="part538.htm">Table 49.1: Reading A File: Client-side And File Server Actions</a><a class="toc0" href="part539.htm">49.5 Cache Consistency</a><a class="toc0" href="part540.htm">49.6 Crash Recovery</a><a class="toc0" href="part541.htm">49.7 Scale And Performance Of AFSv2</a><a class="toc0" href="part542.htm">49.8 AFS: Other Improvements</a><a class="toc0" href="part543.htm">49.9 Summary</a><a class="toc0" href="part544.htm">References</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part532.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part534.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
