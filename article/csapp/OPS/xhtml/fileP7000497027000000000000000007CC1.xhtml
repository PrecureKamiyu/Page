<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>11.4 The Sockets Interface</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000007CC1" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P70004970270000000000000000467FF" data-uri="chapter11.xhtml#P70004970270000000000000000467FF" epub:type="title"><span class="pcalibre label pcalibre1">11.4 </span>The Sockets Interface</h1></header>
<p id="P7000497027000000000000000046800" data-uri="chapter11.xhtml#P7000497027000000000000000046800" class="pcalibre1 pcalibre calibre2">The <i class="calibre5 pcalibre pcalibre1">sockets interface</i> is a set of functions that are used in conjunction with the Unix I/O functions to build network applications. It has been implemented on most modern systems, including all Unix variants as well as Windows and Macintosh systems. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007CC4"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.12</span></a> gives an overview of the sockets interface in the context of a typical client-server transaction. You should use this picture as a road map when we discuss the individual functions.</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007CC4" data-uri="chapter11.xhtml#P7000497027000000000000000007CC4">
<img alt="A diagram illustrates network applications based on the sockets interface." id="P7000497027000000000000000046801" data-uri="P700049702700000000000000000B7C5" src="../images/p932-1.png" class="pcalibre1 pcalibre calibre325"/>
<figcaption id="P7000497027000000000000000046802" data-uri="chapter11.xhtml#P7000497027000000000000000046802" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046803" data-uri="chapter11.xhtml#P7000497027000000000000000046803" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">11.12 </span>Overview of network applications based on the sockets interface.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026B70" data-uri="chapter11.xhtml#P7000497027000000000000000026B70">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000046804" data-uri="chapter11.xhtml#P7000497027000000000000000046804" class="pcalibre1 pcalibre calibre2">A diagram shows a flow of connections under client and server, with the components summarized below.</p>
<ul id="P7000497027000000000000000046805" data-uri="chapter11.xhtml#P7000497027000000000000000046805" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000046806" data-uri="chapter11.xhtml#P7000497027000000000000000046806" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046807" data-uri="chapter11.xhtml#P7000497027000000000000000046807" class="pcalibre calibre3 pcalibre1">Client</p>
<ul id="P7000497027000000000000000046808" data-uri="chapter11.xhtml#P7000497027000000000000000046808" class="pcalibre calibre39 pcalibre1">
<li id="P7000497027000000000000000046809" data-uri="chapter11.xhtml#P7000497027000000000000000046809" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004680A" data-uri="chapter11.xhtml#P700049702700000000000000004680A" class="pcalibre calibre3 pcalibre1">Open_clientfd, including:</p>
<ul id="P700049702700000000000000004680B" data-uri="chapter11.xhtml#P700049702700000000000000004680B" class="calibre112 pcalibre pcalibre1">
<li id="P700049702700000000000000004680C" data-uri="chapter11.xhtml#P700049702700000000000000004680C" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004680D" data-uri="chapter11.xhtml#P700049702700000000000000004680D" class="pcalibre calibre3 pcalibre1">Getaddrinfo</p></li>
<li id="P700049702700000000000000004680E" data-uri="chapter11.xhtml#P700049702700000000000000004680E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004680F" data-uri="chapter11.xhtml#P700049702700000000000000004680F" class="pcalibre calibre3 pcalibre1">Socket</p></li>
<li id="P7000497027000000000000000046810" data-uri="chapter11.xhtml#P7000497027000000000000000046810" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046811" data-uri="chapter11.xhtml#P7000497027000000000000000046811" class="pcalibre calibre3 pcalibre1">Connect (connection request to accept under server)</p></li>
</ul></li>
<li id="P7000497027000000000000000046812" data-uri="chapter11.xhtml#P7000497027000000000000000046812" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046813" data-uri="chapter11.xhtml#P7000497027000000000000000046813" class="pcalibre calibre3 pcalibre1">Rio_writen (to rio_readlineb under server)</p></li>
<li id="P7000497027000000000000000046814" data-uri="chapter11.xhtml#P7000497027000000000000000046814" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046815" data-uri="chapter11.xhtml#P7000497027000000000000000046815" class="pcalibre calibre3 pcalibre1">Rio_readlineb (from rio_writen under server)</p></li>
<li id="P7000497027000000000000000046816" data-uri="chapter11.xhtml#P7000497027000000000000000046816" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046817" data-uri="chapter11.xhtml#P7000497027000000000000000046817" class="pcalibre calibre3 pcalibre1">Close (EOF to rio_readlineb)</p></li>
</ul></li>
<li id="P7000497027000000000000000046818" data-uri="chapter11.xhtml#P7000497027000000000000000046818" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046819" data-uri="chapter11.xhtml#P7000497027000000000000000046819" class="pcalibre calibre3 pcalibre1">Server:</p>
<ul id="P700049702700000000000000004681A" data-uri="chapter11.xhtml#P700049702700000000000000004681A" class="pcalibre calibre39 pcalibre1">
<li id="P700049702700000000000000004681B" data-uri="chapter11.xhtml#P700049702700000000000000004681B" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004681C" data-uri="chapter11.xhtml#P700049702700000000000000004681C" class="pcalibre calibre3 pcalibre1">Open_listenfd, including:</p>
<ul id="P700049702700000000000000004681D" data-uri="chapter11.xhtml#P700049702700000000000000004681D" class="calibre112 pcalibre pcalibre1">
<li id="P700049702700000000000000004681E" data-uri="chapter11.xhtml#P700049702700000000000000004681E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004681F" data-uri="chapter11.xhtml#P700049702700000000000000004681F" class="pcalibre calibre3 pcalibre1">Getaddrinfo</p></li>
<li id="P7000497027000000000000000046820" data-uri="chapter11.xhtml#P7000497027000000000000000046820" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046821" data-uri="chapter11.xhtml#P7000497027000000000000000046821" class="pcalibre calibre3 pcalibre1">Socket</p></li>
<li id="P7000497027000000000000000046822" data-uri="chapter11.xhtml#P7000497027000000000000000046822" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046823" data-uri="chapter11.xhtml#P7000497027000000000000000046823" class="pcalibre calibre3 pcalibre1">Bind</p></li>
<li id="P7000497027000000000000000046824" data-uri="chapter11.xhtml#P7000497027000000000000000046824" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046825" data-uri="chapter11.xhtml#P7000497027000000000000000046825" class="pcalibre calibre3 pcalibre1">Listen</p></li>
</ul></li>
<li id="P7000497027000000000000000046826" data-uri="chapter11.xhtml#P7000497027000000000000000046826" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046827" data-uri="chapter11.xhtml#P7000497027000000000000000046827" class="pcalibre calibre3 pcalibre1">Accept (connection request from connect under Client and await connection request from next client from close below)</p></li>
<li id="P7000497027000000000000000046828" data-uri="chapter11.xhtml#P7000497027000000000000000046828" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046829" data-uri="chapter11.xhtml#P7000497027000000000000000046829" class="pcalibre calibre3 pcalibre1">Rio_readlineb (from rio_writen under client)</p></li>
<li id="P700049702700000000000000004682A" data-uri="chapter11.xhtml#P700049702700000000000000004682A" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004682B" data-uri="chapter11.xhtml#P700049702700000000000000004682B" class="pcalibre calibre3 pcalibre1">Rio_writen (to rio_readlineb under client)</p></li>
<li id="P700049702700000000000000004682C" data-uri="chapter11.xhtml#P700049702700000000000000004682C" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004682D" data-uri="chapter11.xhtml#P700049702700000000000000004682D" class="pcalibre calibre3 pcalibre1">Rio_readlineb (EOF from close under client)</p></li>
<li id="P700049702700000000000000004682E" data-uri="chapter11.xhtml#P700049702700000000000000004682E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004682F" data-uri="chapter11.xhtml#P700049702700000000000000004682F" class="pcalibre calibre3 pcalibre1">Close (await connection request from next client to accept)</p></li>
</ul></li>
</ul>
</details>
</figcaption>
</figure>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000007CC8" data-uri="chapter11.xhtml#P7000497027000000000000000007CC8"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000046830" data-uri="chapter11.xhtml#P7000497027000000000000000046830" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007CCA" title="933" data-uri="chapter11.xhtml#P7000497027000000000000000007CCA" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>What does the <code id="P7000497027000000000000000046831" data-uri="chapter11.xhtml#P7000497027000000000000000046831" class="calibre55 pcalibre pcalibre1">_in</code> suffix mean?</h1></header>
<p id="P7000497027000000000000000046832" data-uri="chapter11.xhtml#P7000497027000000000000000046832" class="pcalibre calibre3 pcalibre1">The <code id="P7000497027000000000000000046833" data-uri="chapter11.xhtml#P7000497027000000000000000046833" class="pcalibre1 calibre8 pcalibre">_in</code> suffix is short for <i class="calibre5 pcalibre pcalibre1">internet</i>, not <i class="calibre5 pcalibre pcalibre1">input</i>.</p>
</aside>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007CCE" data-uri="chapter11.xhtml#P7000497027000000000000000007CCE">
<pre id="P7000497027000000000000000046834" data-uri="chapter11.xhtml#P7000497027000000000000000046834" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046835" data-uri="chapter11.xhtml#P7000497027000000000000000046835" class="calibre10 pcalibre pcalibre1">
/* IP socket address structure */
struct sockaddr_in {
  uint16_t	sin_family;	/* Protocol family (always AF_INET) */
  uint16_t	sin_port;	/* Port number in network byte order */
  struct in_addr	sin_addr;	/* IP address in network byte order */
  unsigned char	sin_zero[8];	/* Pad to sizeof(struct sockaddr) */
};
/* Generic socket address structure (for connect, bind, and accept) */ struct sockaddr {
  uint16_t	sa_family;	/* Protocol family */
  char		sa_data[14];	/* Address data */
};
</code></pre>
<figcaption id="P7000497027000000000000000046836" data-uri="chapter11.xhtml#P7000497027000000000000000046836" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046837" data-uri="chapter11.xhtml#P7000497027000000000000000046837" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">11.13 </span>Socket address structures.</h1></header>
</figcaption>
</figure>
<section id="P7000497027000000000000000007CD3" data-uri="chapter11.xhtml#P7000497027000000000000000007CD3" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046838" data-uri="chapter11.xhtml#P7000497027000000000000000046838" epub:type="title"><span class="pcalibre label pcalibre1">11.4.1 </span>Socket Address Structures</h1></header>
<p id="P7000497027000000000000000046839" data-uri="chapter11.xhtml#P7000497027000000000000000046839" class="pcalibre1 pcalibre calibre2">From the perspective of the Linux kernel, a socket is an end point for communication. From the perspective of a Linux program, a socket is an open file with a corresponding descriptor.</p>
<p id="P700049702700000000000000004683A" data-uri="chapter11.xhtml#P700049702700000000000000004683A" class="pcalibre1 pcalibre calibre2">Internet socket addresses are stored in 16-byte structures having the type <code id="P700049702700000000000000004683B" data-uri="chapter11.xhtml#P700049702700000000000000004683B" class="pcalibre1 calibre8 pcalibre">sockaddr_in</code>, shown in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007CCE"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.13</span></a>. For Internet applications, the <code id="P700049702700000000000000004683C" data-uri="chapter11.xhtml#P700049702700000000000000004683C" class="pcalibre1 calibre8 pcalibre">sin_family</code> field is AF_INET, the <code id="P700049702700000000000000004683D" data-uri="chapter11.xhtml#P700049702700000000000000004683D" class="pcalibre1 calibre8 pcalibre">sin_port</code> field is a 16-bit port number, and the <code id="P700049702700000000000000004683E" data-uri="chapter11.xhtml#P700049702700000000000000004683E" class="pcalibre1 calibre8 pcalibre">sin_addr</code> field contains a 32-bit IP address. The IP address and port number are always stored in network (big-endian) byte order.</p>
<p id="P700049702700000000000000004683F" data-uri="chapter11.xhtml#P700049702700000000000000004683F" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046840" data-uri="chapter11.xhtml#P7000497027000000000000000046840" class="pcalibre1 calibre8 pcalibre">connect, bind</code>, and <code id="P7000497027000000000000000046841" data-uri="chapter11.xhtml#P7000497027000000000000000046841" class="pcalibre1 calibre8 pcalibre">accept</code> functions require a pointer to a protocol-specific socket address structure. The problem faced by the designers of the sockets interface was how to define these functions to accept any kind of socket address structure. Today, we would use the generic <code id="P7000497027000000000000000046842" data-uri="chapter11.xhtml#P7000497027000000000000000046842" class="pcalibre1 calibre8 pcalibre">void</code> * pointer, which did not exist in C at that time. Their solution was to define sockets functions to expect a pointer to a generic <code id="P7000497027000000000000000046843" data-uri="chapter11.xhtml#P7000497027000000000000000046843" class="pcalibre1 calibre8 pcalibre">sockaddr</code> structure (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007CCE"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.13</span></a>) and then require applications to cast any pointers to protocol-specific structures to this generic structure. To simplify our code examples, we follow Stevens's lead and define the following type:</p>
<pre id="P7000497027000000000000000046844" data-uri="chapter11.xhtml#P7000497027000000000000000046844" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046845" data-uri="chapter11.xhtml#P7000497027000000000000000046845" class="calibre10 pcalibre pcalibre1">typedef struct sockaddr SA;</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046846" data-uri="chapter11.xhtml#P7000497027000000000000000046846"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007CE3" title="934" data-uri="chapter11.xhtml#P7000497027000000000000000007CE3" epub:type="pagebreak"></span>We then use this type whenever we need to cast a <code id="P7000497027000000000000000046847" data-uri="chapter11.xhtml#P7000497027000000000000000046847" class="pcalibre1 calibre8 pcalibre">sockaddr_in</code> structure to a generic <code id="P7000497027000000000000000046848" data-uri="chapter11.xhtml#P7000497027000000000000000046848" class="pcalibre1 calibre8 pcalibre">sockaddr</code> structure.</p>
</section>
<section id="P7000497027000000000000000007CE6" data-uri="chapter11.xhtml#P7000497027000000000000000007CE6" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046849" data-uri="chapter11.xhtml#P7000497027000000000000000046849" epub:type="title"><span class="pcalibre label pcalibre1">11.4.2 </span>The <code id="P700049702700000000000000004684A" data-uri="chapter11.xhtml#P700049702700000000000000004684A" class="pcalibre1 calibre8 pcalibre">socket</code> Function</h1></header>
<p id="P700049702700000000000000004684B" data-uri="chapter11.xhtml#P700049702700000000000000004684B" class="pcalibre1 pcalibre calibre2">Clients and servers use the <code id="P700049702700000000000000004684C" data-uri="chapter11.xhtml#P700049702700000000000000004684C" class="pcalibre1 calibre8 pcalibre">socket</code> function to create a <i class="calibre5 pcalibre pcalibre1">socket descriptor</i>.</p>
<pre id="P700049702700000000000000004684D" data-uri="chapter11.xhtml#P700049702700000000000000004684D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004684E" data-uri="chapter11.xhtml#P700049702700000000000000004684E" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int socket(int domain, int type, int protocol);
				Returns: nonnegative descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004684F" data-uri="chapter11.xhtml#P700049702700000000000000004684F">If we wanted the socket to be the end point for a connection, then we could call socket with the following hardcoded arguments:</p>
<pre id="P7000497027000000000000000046850" data-uri="chapter11.xhtml#P7000497027000000000000000046850" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046851" data-uri="chapter11.xhtml#P7000497027000000000000000046851" class="calibre10 pcalibre pcalibre1">clientfd = Socket(AF_INET, SOCK_STREAM, 0);</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046852" data-uri="chapter11.xhtml#P7000497027000000000000000046852">where AF_INET indicates that we are using 32-bit IP addresses and SOCK_STREAM indicates that the socket will be an end point for a connection. However, the best practice is to use the <code id="P7000497027000000000000000046853" data-uri="chapter11.xhtml#P7000497027000000000000000046853" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> function (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007D50"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">11.4.7</span></a>) to generate these parameters automatically, so that the code is protocol-independent. We will show you how to use <code id="P7000497027000000000000000046854" data-uri="chapter11.xhtml#P7000497027000000000000000046854" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> with the <code id="P7000497027000000000000000046855" data-uri="chapter11.xhtml#P7000497027000000000000000046855" class="pcalibre1 calibre8 pcalibre">socket</code> function in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007E0B"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">11.4.8</span></a>.</p>
<p id="P7000497027000000000000000046856" data-uri="chapter11.xhtml#P7000497027000000000000000046856" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046857" data-uri="chapter11.xhtml#P7000497027000000000000000046857" class="pcalibre1 calibre8 pcalibre">clientfd</code> descriptor returned by <code id="P7000497027000000000000000046858" data-uri="chapter11.xhtml#P7000497027000000000000000046858" class="pcalibre1 calibre8 pcalibre">socket</code> is only partially opened and cannot yet be used for reading and writing. How we finish opening the socket depends on whether we are a client or a server. The next section describes how we finish opening the socket if we are a client.</p>
</section>
<section id="P7000497027000000000000000007CF7" data-uri="chapter11.xhtml#P7000497027000000000000000007CF7" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046859" data-uri="chapter11.xhtml#P7000497027000000000000000046859" epub:type="title"><span class="pcalibre label pcalibre1">11.4.3 </span>The <code id="P700049702700000000000000004685A" data-uri="chapter11.xhtml#P700049702700000000000000004685A" class="pcalibre1 calibre8 pcalibre">connect</code> Function</h1></header>
<p id="P700049702700000000000000004685B" data-uri="chapter11.xhtml#P700049702700000000000000004685B" class="pcalibre1 pcalibre calibre2">A client establishes a connection with a server by calling the <code id="P700049702700000000000000004685C" data-uri="chapter11.xhtml#P700049702700000000000000004685C" class="pcalibre1 calibre8 pcalibre">connect</code> function.</p>
<pre id="P700049702700000000000000004685D" data-uri="chapter11.xhtml#P700049702700000000000000004685D" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004685E" data-uri="chapter11.xhtml#P700049702700000000000000004685E" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/socket.h&gt;
int connect(int clientfd, const struct sockaddr *addr,
			socklen_t addrlen);
							Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004685F" data-uri="chapter11.xhtml#P700049702700000000000000004685F">The <code id="P7000497027000000000000000046860" data-uri="chapter11.xhtml#P7000497027000000000000000046860" class="pcalibre1 calibre8 pcalibre">connect</code> function attempts to establish an Internet connection with the server at socket address <code id="P7000497027000000000000000046861" data-uri="chapter11.xhtml#P7000497027000000000000000046861" class="pcalibre1 calibre8 pcalibre">addr</code>, where <code id="P7000497027000000000000000046862" data-uri="chapter11.xhtml#P7000497027000000000000000046862" class="pcalibre1 calibre8 pcalibre">addrlen</code> is <code id="P7000497027000000000000000046863" data-uri="chapter11.xhtml#P7000497027000000000000000046863" class="pcalibre1 calibre8 pcalibre">sizeof(sockaddr_in)</code>. The <code id="P7000497027000000000000000046864" data-uri="chapter11.xhtml#P7000497027000000000000000046864" class="pcalibre1 calibre8 pcalibre">connect</code> function blocks until either the connection is successfully established or an error occurs. If successful, the <code id="P7000497027000000000000000046865" data-uri="chapter11.xhtml#P7000497027000000000000000046865" class="pcalibre1 calibre8 pcalibre">clientfd</code> descriptor is now ready for reading and writing, and the resulting connection is characterized by the socket pair</p>
<pre id="P7000497027000000000000000046866" data-uri="chapter11.xhtml#P7000497027000000000000000046866" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046867" data-uri="chapter11.xhtml#P7000497027000000000000000046867" class="calibre10 pcalibre pcalibre1">(x:y, addr.sin_addr:addr.sin_port)</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046868" data-uri="chapter11.xhtml#P7000497027000000000000000046868"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007D08" title="935" data-uri="chapter11.xhtml#P7000497027000000000000000007D08" epub:type="pagebreak"></span>where <code id="P7000497027000000000000000046869" data-uri="chapter11.xhtml#P7000497027000000000000000046869" class="pcalibre1 calibre8 pcalibre">x</code> is the client's IP address and <code id="P700049702700000000000000004686A" data-uri="chapter11.xhtml#P700049702700000000000000004686A" class="pcalibre1 calibre8 pcalibre">y</code> is the ephemeral port that uniquely identifies the client process on the client host. As with <code id="P700049702700000000000000004686B" data-uri="chapter11.xhtml#P700049702700000000000000004686B" class="pcalibre1 calibre8 pcalibre">socket</code>, the best practice is to use <code id="P700049702700000000000000004686C" data-uri="chapter11.xhtml#P700049702700000000000000004686C" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> to supply the arguments to <code id="P700049702700000000000000004686D" data-uri="chapter11.xhtml#P700049702700000000000000004686D" class="pcalibre1 calibre8 pcalibre">connect</code> (see <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007E0B"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">11.4.8</span></a>).</p>
</section>
<section id="P7000497027000000000000000007D0E" data-uri="chapter11.xhtml#P7000497027000000000000000007D0E" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004686E" data-uri="chapter11.xhtml#P700049702700000000000000004686E" epub:type="title"><span class="pcalibre label pcalibre1">11.4.4 </span>The <code id="P700049702700000000000000004686F" data-uri="chapter11.xhtml#P700049702700000000000000004686F" class="pcalibre1 calibre8 pcalibre">bind</code> Function</h1></header>
<p id="P7000497027000000000000000046870" data-uri="chapter11.xhtml#P7000497027000000000000000046870" class="pcalibre1 pcalibre calibre2">The remaining sockets functions—<code id="P7000497027000000000000000046871" data-uri="chapter11.xhtml#P7000497027000000000000000046871" class="pcalibre1 calibre8 pcalibre">bind, listen</code>, and <code id="P7000497027000000000000000046872" data-uri="chapter11.xhtml#P7000497027000000000000000046872" class="pcalibre1 calibre8 pcalibre">accept</code>—are used by servers to establish connections with clients.</p>
<pre id="P7000497027000000000000000046873" data-uri="chapter11.xhtml#P7000497027000000000000000046873" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046874" data-uri="chapter11.xhtml#P7000497027000000000000000046874" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/socket.h&gt;
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
				Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046875" data-uri="chapter11.xhtml#P7000497027000000000000000046875">The <code id="P7000497027000000000000000046876" data-uri="chapter11.xhtml#P7000497027000000000000000046876" class="pcalibre1 calibre8 pcalibre">bind</code> function asks the kernel to associate the server's socket address in <code id="P7000497027000000000000000046877" data-uri="chapter11.xhtml#P7000497027000000000000000046877" class="pcalibre1 calibre8 pcalibre">addr</code> with the socket descriptor <code id="P7000497027000000000000000046878" data-uri="chapter11.xhtml#P7000497027000000000000000046878" class="pcalibre1 calibre8 pcalibre">sockfd</code>. The <code id="P7000497027000000000000000046879" data-uri="chapter11.xhtml#P7000497027000000000000000046879" class="pcalibre1 calibre8 pcalibre">addrlen</code> argument is <code id="P700049702700000000000000004687A" data-uri="chapter11.xhtml#P700049702700000000000000004687A" class="pcalibre1 calibre8 pcalibre">sizeof(sockaddr_in)</code>. As with <code id="P700049702700000000000000004687B" data-uri="chapter11.xhtml#P700049702700000000000000004687B" class="pcalibre1 calibre8 pcalibre">socket</code> and <code id="P700049702700000000000000004687C" data-uri="chapter11.xhtml#P700049702700000000000000004687C" class="pcalibre1 calibre8 pcalibre">connect</code>, the best practice is to use <code id="P700049702700000000000000004687D" data-uri="chapter11.xhtml#P700049702700000000000000004687D" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> to supply the arguments to <code id="P700049702700000000000000004687E" data-uri="chapter11.xhtml#P700049702700000000000000004687E" class="pcalibre1 calibre8 pcalibre">bind</code> (see <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007E0B"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">11.4.8</span></a>).</p>
</section>
<section id="P7000497027000000000000000007D20" data-uri="chapter11.xhtml#P7000497027000000000000000007D20" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P700049702700000000000000004687F" data-uri="chapter11.xhtml#P700049702700000000000000004687F" epub:type="title"><span class="pcalibre label pcalibre1">11.4.5 </span>The <code id="P7000497027000000000000000046880" data-uri="chapter11.xhtml#P7000497027000000000000000046880" class="pcalibre1 calibre8 pcalibre">listen</code> Function</h1></header>
<p id="P7000497027000000000000000046881" data-uri="chapter11.xhtml#P7000497027000000000000000046881" class="pcalibre1 pcalibre calibre2">Clients are active entities that initiate connection requests. Servers are passive entities that wait for connection requests from clients. By default, the kernel assumes that a descriptor created by the <code id="P7000497027000000000000000046882" data-uri="chapter11.xhtml#P7000497027000000000000000046882" class="pcalibre1 calibre8 pcalibre">socket</code> function corresponds to an <i class="calibre5 pcalibre pcalibre1">active socket</i> that will live on the client end of a connection. A server calls the <code id="P7000497027000000000000000046883" data-uri="chapter11.xhtml#P7000497027000000000000000046883" class="pcalibre1 calibre8 pcalibre">listen</code> function to tell the kernel that the descriptor will be used by a server instead of a client.</p>
<pre id="P7000497027000000000000000046884" data-uri="chapter11.xhtml#P7000497027000000000000000046884" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046885" data-uri="chapter11.xhtml#P7000497027000000000000000046885" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/socket.h&gt;
int listen(int sockfd, int backlog);
				Returns: 0 if OK, −1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046886" data-uri="chapter11.xhtml#P7000497027000000000000000046886">The <code id="P7000497027000000000000000046887" data-uri="chapter11.xhtml#P7000497027000000000000000046887" class="pcalibre1 calibre8 pcalibre">listen</code> function converts <code id="P7000497027000000000000000046888" data-uri="chapter11.xhtml#P7000497027000000000000000046888" class="pcalibre1 calibre8 pcalibre">sockfd</code> from an active socket to a <i class="calibre5 pcalibre pcalibre1">listening socket</i> that can accept connection requests from clients. The <code id="P7000497027000000000000000046889" data-uri="chapter11.xhtml#P7000497027000000000000000046889" class="pcalibre1 calibre8 pcalibre">backlog</code> argument is a hint about the number of outstanding connection requests that the kernel should queue up before it starts to refuse requests. The exact meaning of the <code id="P700049702700000000000000004688A" data-uri="chapter11.xhtml#P700049702700000000000000004688A" class="pcalibre1 calibre8 pcalibre">backlog</code> argument requires an understanding of TCP/IP that is beyond our scope. We will typically set it to a large value, such as 1,024.</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007D2D" data-uri="chapter11.xhtml#P7000497027000000000000000007D2D">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007D2E" title="936" data-uri="chapter11.xhtml#P7000497027000000000000000007D2E" epub:type="pagebreak"></span>
<img alt="A diagram illustrates three roles of the listening and connected descriptors." id="P700049702700000000000000004688B" data-uri="P700049702700000000000000000B7C6" src="../images/p936-1.png" class="calibre326 pcalibre pcalibre1"/>
<figcaption id="P700049702700000000000000004688C" data-uri="chapter11.xhtml#P700049702700000000000000004688C" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004688D" data-uri="chapter11.xhtml#P700049702700000000000000004688D" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">11.14 </span>The roles of the listening and connected descriptors.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026BFB" data-uri="chapter11.xhtml#P7000497027000000000000000026BFB">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P700049702700000000000000004688E" data-uri="chapter11.xhtml#P700049702700000000000000004688E" class="pcalibre1 pcalibre calibre2">The three steps are summarized below.</p>
<ol id="P700049702700000000000000004688F" data-uri="chapter11.xhtml#P700049702700000000000000004688F" class="pcalibre1 pcalibre calibre45">
<li id="P7000497027000000000000000046890" data-uri="chapter11.xhtml#P7000497027000000000000000046890" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046891" data-uri="chapter11.xhtml#P7000497027000000000000000046891" class="pcalibre calibre3 pcalibre1">Server blocks in accept, waiting for connection request on listening descriptor listenfd (Client shown with clientfd and server with listenfd(3))</p></li>
<li id="P7000497027000000000000000046892" data-uri="chapter11.xhtml#P7000497027000000000000000046892" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046893" data-uri="chapter11.xhtml#P7000497027000000000000000046893" class="pcalibre calibre3 pcalibre1">Client makes connection request by calling and blocking in connect. (Connection request from client to listen(3) on server)</p></li>
<li id="P7000497027000000000000000046894" data-uri="chapter11.xhtml#P7000497027000000000000000046894" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046895" data-uri="chapter11.xhtml#P7000497027000000000000000046895" class="pcalibre calibre3 pcalibre1">Server returns connfd from accept. Client returns from connect. Connection is now established between clientfd and connfd. (Connection between clientfd and connfd(4) on server)</p></li>
</ol>
</details>
</figcaption>
</figure>
</section>
<section id="P7000497027000000000000000007D32" data-uri="chapter11.xhtml#P7000497027000000000000000007D32" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046896" data-uri="chapter11.xhtml#P7000497027000000000000000046896" epub:type="title"><span class="pcalibre label pcalibre1">11.4.6 </span>The <code id="P7000497027000000000000000046897" data-uri="chapter11.xhtml#P7000497027000000000000000046897" class="pcalibre1 calibre8 pcalibre">accept</code> Function</h1></header>
<p id="P7000497027000000000000000046898" data-uri="chapter11.xhtml#P7000497027000000000000000046898" class="pcalibre1 pcalibre calibre2">Servers wait for connection requests from clients by calling the <code id="P7000497027000000000000000046899" data-uri="chapter11.xhtml#P7000497027000000000000000046899" class="pcalibre1 calibre8 pcalibre">accept</code> function.</p>
<pre id="P700049702700000000000000004689A" data-uri="chapter11.xhtml#P700049702700000000000000004689A" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004689B" data-uri="chapter11.xhtml#P700049702700000000000000004689B" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/socket.h&gt;
int accept(int listenfd, struct sockaddr *addr, int *addrlen);
				Returns: nonnegative connected descriptor if OK, −1 on error
</code></pre>
<p id="P700049702700000000000000004689C" data-uri="chapter11.xhtml#P700049702700000000000000004689C" class="pcalibre1 pcalibre calibre2">The <code id="P700049702700000000000000004689D" data-uri="chapter11.xhtml#P700049702700000000000000004689D" class="pcalibre1 calibre8 pcalibre">accept</code> function waits for a connection request from a client to arrive on the listening descriptor <code id="P700049702700000000000000004689E" data-uri="chapter11.xhtml#P700049702700000000000000004689E" class="pcalibre1 calibre8 pcalibre">listenfd</code>, then fills in the client's socket address in <code id="P700049702700000000000000004689F" data-uri="chapter11.xhtml#P700049702700000000000000004689F" class="pcalibre1 calibre8 pcalibre">addr</code>, and returns a <i class="calibre5 pcalibre pcalibre1">connected descriptor</i> that can be used to communicate with the client using Unix I/O functions.</p>
<p id="P70004970270000000000000000468A0" data-uri="chapter11.xhtml#P70004970270000000000000000468A0" class="pcalibre1 pcalibre calibre2">The distinction between a listening descriptor and a connected descriptor confuses many students. The listening descriptor serves as an end point for client connection requests. It is typically created once and exists for the lifetime of the server. The connected descriptor is the end point of the connection that is established between the client and the server. It is created each time the server accepts a connection request and exists only as long as it takes the server to service a client.</p>
<p id="P70004970270000000000000000468A1" data-uri="chapter11.xhtml#P70004970270000000000000000468A1" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007D2D"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.14</span></a> outlines the roles of the listening and connected descriptors. In step 1, the server calls <code id="P70004970270000000000000000468A2" data-uri="chapter11.xhtml#P70004970270000000000000000468A2" class="pcalibre1 calibre8 pcalibre">accept</code>, which waits for a connection request to arrive on the listening descriptor, which for concreteness we will assume is descriptor 3. Recall that descriptors 0−2 are reserved for the standard files.</p>
<p id="P70004970270000000000000000468A3" data-uri="chapter11.xhtml#P70004970270000000000000000468A3" class="pcalibre1 pcalibre calibre2">In step 2, the client calls the <code id="P70004970270000000000000000468A4" data-uri="chapter11.xhtml#P70004970270000000000000000468A4" class="pcalibre1 calibre8 pcalibre">connect</code> function, which sends a connection request to <code id="P70004970270000000000000000468A5" data-uri="chapter11.xhtml#P70004970270000000000000000468A5" class="pcalibre1 calibre8 pcalibre">listenfd</code>. In step 3, the <code id="P70004970270000000000000000468A6" data-uri="chapter11.xhtml#P70004970270000000000000000468A6" class="pcalibre1 calibre8 pcalibre">accept</code> function opens a new connected descriptor <code id="P70004970270000000000000000468A7" data-uri="chapter11.xhtml#P70004970270000000000000000468A7" class="pcalibre1 calibre8 pcalibre">connfd</code> (which we will assume is descriptor 4), establishes the connection between <code id="P70004970270000000000000000468A8" data-uri="chapter11.xhtml#P70004970270000000000000000468A8" class="pcalibre1 calibre8 pcalibre">clientfd</code> and <code id="P70004970270000000000000000468A9" data-uri="chapter11.xhtml#P70004970270000000000000000468A9" class="pcalibre1 calibre8 pcalibre">connfd</code>, and then returns <code id="P70004970270000000000000000468AA" data-uri="chapter11.xhtml#P70004970270000000000000000468AA" class="pcalibre1 calibre8 pcalibre">connfd</code> to the application. The</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000007D48" data-uri="chapter11.xhtml#P7000497027000000000000000007D48"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P70004970270000000000000000468AB" data-uri="chapter11.xhtml#P70004970270000000000000000468AB" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007D4A" title="937" data-uri="chapter11.xhtml#P7000497027000000000000000007D4A" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Why the distinction between listening and connected descriptors?</h1></header>
<p id="P70004970270000000000000000468AC" data-uri="chapter11.xhtml#P70004970270000000000000000468AC" class="pcalibre calibre3 pcalibre1">You might wonder why the sockets interface makes a distinction between listening and connected descriptors. At first glance, it appears to be an unnecessary complication. However, distinguishing between the two turns out to be quite useful, because it allows us to build concurrent servers that can process many client connections simultaneously. For example, each time a connection request arrives on the listening descriptor, we might fork a new process that communicates with the client over its connected descriptor. You'll learn more about concurrent servers in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">12</span></a>.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000468AD" data-uri="chapter11.xhtml#P70004970270000000000000000468AD">client also returns from the <code id="P70004970270000000000000000468AE" data-uri="chapter11.xhtml#P70004970270000000000000000468AE" class="pcalibre1 calibre8 pcalibre">connect</code>, and from this point, the client and server can pass data back and forth by reading and writing <code id="P70004970270000000000000000468AF" data-uri="chapter11.xhtml#P70004970270000000000000000468AF" class="pcalibre1 calibre8 pcalibre">clientfd</code> and <code id="P70004970270000000000000000468B0" data-uri="chapter11.xhtml#P70004970270000000000000000468B0" class="pcalibre1 calibre8 pcalibre">connfd</code>, respectively.</p>
</section>
<section id="P7000497027000000000000000007D50" data-uri="chapter11.xhtml#P7000497027000000000000000007D50" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000468B1" data-uri="chapter11.xhtml#P70004970270000000000000000468B1" epub:type="title"><span class="pcalibre label pcalibre1">11.4.7 </span>Host and Service Conversion</h1></header>
<p id="P70004970270000000000000000468B2" data-uri="chapter11.xhtml#P70004970270000000000000000468B2" class="pcalibre1 pcalibre calibre2">Linux provides some powerful functions, called <code id="P70004970270000000000000000468B3" data-uri="chapter11.xhtml#P70004970270000000000000000468B3" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> and <code id="P70004970270000000000000000468B4" data-uri="chapter11.xhtml#P70004970270000000000000000468B4" class="pcalibre1 calibre8 pcalibre">getnameinfo</code>, for converting back and forth between binary socket address structures and the string representations of hostnames, host addresses, service names, and port numbers. When used in conjunction with the sockets interface, they allow us to write network programs that are independent of any particular version of the IP protocol.</p>
<section id="P7000497027000000000000000007D55" data-uri="chapter11.xhtml#P7000497027000000000000000007D55" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P70004970270000000000000000468B5" data-uri="chapter11.xhtml#P70004970270000000000000000468B5" epub:type="title">The <code id="P70004970270000000000000000468B6" data-uri="chapter11.xhtml#P70004970270000000000000000468B6" class="calibre55 pcalibre pcalibre1">getaddrinfo</code> Function</h1></header>
<p id="P70004970270000000000000000468B7" data-uri="chapter11.xhtml#P70004970270000000000000000468B7" class="pcalibre1 pcalibre calibre2">The <code id="P70004970270000000000000000468B8" data-uri="chapter11.xhtml#P70004970270000000000000000468B8" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> function converts string representations of hostnames, host addresses, service names, and port numbers into socket address structures. It is the modern replacement for the obsolete <code id="P70004970270000000000000000468B9" data-uri="chapter11.xhtml#P70004970270000000000000000468B9" class="pcalibre1 calibre8 pcalibre">gethostbyname</code> and <code id="P70004970270000000000000000468BA" data-uri="chapter11.xhtml#P70004970270000000000000000468BA" class="pcalibre1 calibre8 pcalibre">getservbyname</code> functions. Unlike these functions, it is reentrant (see <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000008577.xhtml#P70004970270000000000000000085BA"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">12.7.2</span></a>) and works with any protocol.</p>
<pre id="P70004970270000000000000000468BB" data-uri="chapter11.xhtml#P70004970270000000000000000468BB" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000468BC" data-uri="chapter11.xhtml#P70004970270000000000000000468BC" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
int getaddrinfo(const char *host, const char *service,
			const struct addrinfo *hints,
			struct addrinfo **result);
					Returns: 0 if OK, nonzero error code on error
void freeaddrinfo(struct addrinfo *result);
				Returns: nothing
const char *gai_strerror(int errcode);
				Returns: error message
</code></pre>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007D5E" data-uri="chapter11.xhtml#P7000497027000000000000000007D5E">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007D5F" title="938" data-uri="chapter11.xhtml#P7000497027000000000000000007D5F" epub:type="pagebreak"></span>
<img alt="A diagram shows lists of data structure returned by getaddrinfo." id="P70004970270000000000000000468BD" data-uri="P700049702700000000000000000B7C7" src="../images/p938-1.png" class="pcalibre1 calibre327 pcalibre"/>
<figcaption id="P70004970270000000000000000468BE" data-uri="chapter11.xhtml#P70004970270000000000000000468BE" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000468BF" data-uri="chapter11.xhtml#P70004970270000000000000000468BF" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.15 </span>Data structure returned by <code id="P70004970270000000000000000468C0" data-uri="chapter11.xhtml#P70004970270000000000000000468C0" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code>.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000026C2F" data-uri="chapter11.xhtml#P7000497027000000000000000026C2F">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P70004970270000000000000000468C1" data-uri="chapter11.xhtml#P70004970270000000000000000468C1" class="pcalibre1 pcalibre calibre2">A diagram shows a result leading to a list of addrinfo structs, leading to others as follows:</p>
<ul id="P70004970270000000000000000468C2" data-uri="chapter11.xhtml#P70004970270000000000000000468C2" class="pcalibre calibre31 pcalibre1">
<li id="P70004970270000000000000000468C3" data-uri="chapter11.xhtml#P70004970270000000000000000468C3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468C4" data-uri="chapter11.xhtml#P70004970270000000000000000468C4" class="pcalibre calibre3 pcalibre1">Ai_canonname, to cell under result</p></li>
<li id="P70004970270000000000000000468C5" data-uri="chapter11.xhtml#P70004970270000000000000000468C5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468C6" data-uri="chapter11.xhtml#P70004970270000000000000000468C6" class="pcalibre calibre3 pcalibre1">Ai_addr, to socket address struct</p></li>
<li id="P70004970270000000000000000468C7" data-uri="chapter11.xhtml#P70004970270000000000000000468C7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468C8" data-uri="chapter11.xhtml#P70004970270000000000000000468C8" class="pcalibre calibre3 pcalibre1">Ai_next, to next list:</p>
<ul id="P70004970270000000000000000468C9" data-uri="chapter11.xhtml#P70004970270000000000000000468C9" class="pcalibre calibre39 pcalibre1">
<li id="P70004970270000000000000000468CA" data-uri="chapter11.xhtml#P70004970270000000000000000468CA" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468CB" data-uri="chapter11.xhtml#P70004970270000000000000000468CB" class="pcalibre calibre3 pcalibre1">NULL</p></li>
<li id="P70004970270000000000000000468CC" data-uri="chapter11.xhtml#P70004970270000000000000000468CC" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468CD" data-uri="chapter11.xhtml#P70004970270000000000000000468CD" class="pcalibre calibre3 pcalibre1">Ai_addr, to socket address struct</p></li>
<li id="P70004970270000000000000000468CE" data-uri="chapter11.xhtml#P70004970270000000000000000468CE" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468CF" data-uri="chapter11.xhtml#P70004970270000000000000000468CF" class="pcalibre calibre3 pcalibre1">Ai_next, to next list:</p>
<ul id="P70004970270000000000000000468D0" data-uri="chapter11.xhtml#P70004970270000000000000000468D0" class="calibre112 pcalibre pcalibre1">
<li id="P70004970270000000000000000468D1" data-uri="chapter11.xhtml#P70004970270000000000000000468D1" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468D2" data-uri="chapter11.xhtml#P70004970270000000000000000468D2" class="pcalibre calibre3 pcalibre1">NULL</p></li>
<li id="P70004970270000000000000000468D3" data-uri="chapter11.xhtml#P70004970270000000000000000468D3" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468D4" data-uri="chapter11.xhtml#P70004970270000000000000000468D4" class="pcalibre calibre3 pcalibre1">Ai_addr, to socket address struct</p></li>
<li id="P70004970270000000000000000468D5" data-uri="chapter11.xhtml#P70004970270000000000000000468D5" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468D6" data-uri="chapter11.xhtml#P70004970270000000000000000468D6" class="pcalibre calibre3 pcalibre1">NULL</p></li>
</ul>
</li></ul>
</li></ul>
</details>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000468D7" data-uri="chapter11.xhtml#P70004970270000000000000000468D7">Given <code id="P70004970270000000000000000468D8" data-uri="chapter11.xhtml#P70004970270000000000000000468D8" class="pcalibre1 calibre8 pcalibre">host</code> and <code id="P70004970270000000000000000468D9" data-uri="chapter11.xhtml#P70004970270000000000000000468D9" class="pcalibre1 calibre8 pcalibre">service</code> (the two components of a socket address), <code id="P70004970270000000000000000468DA" data-uri="chapter11.xhtml#P70004970270000000000000000468DA" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> returns a <code id="P70004970270000000000000000468DB" data-uri="chapter11.xhtml#P70004970270000000000000000468DB" class="pcalibre1 calibre8 pcalibre">result</code> that points to a linked list of <code id="P70004970270000000000000000468DC" data-uri="chapter11.xhtml#P70004970270000000000000000468DC" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structures, each of which points to a socket address structure that corresponds to <code id="P70004970270000000000000000468DD" data-uri="chapter11.xhtml#P70004970270000000000000000468DD" class="pcalibre1 calibre8 pcalibre">host</code> and <code id="P70004970270000000000000000468DE" data-uri="chapter11.xhtml#P70004970270000000000000000468DE" class="pcalibre1 calibre8 pcalibre">service</code> (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007D5E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.15</span></a>).</p>
<p id="P70004970270000000000000000468DF" data-uri="chapter11.xhtml#P70004970270000000000000000468DF" class="pcalibre1 pcalibre calibre2">After a client calls <code id="P70004970270000000000000000468E0" data-uri="chapter11.xhtml#P70004970270000000000000000468E0" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code>, it walks this list, trying each socket address in turn until the calls to <code id="P70004970270000000000000000468E1" data-uri="chapter11.xhtml#P70004970270000000000000000468E1" class="pcalibre1 calibre8 pcalibre">socket</code> and <code id="P70004970270000000000000000468E2" data-uri="chapter11.xhtml#P70004970270000000000000000468E2" class="pcalibre1 calibre8 pcalibre">connect</code> succeed and the connection is established. Similarly, a server tries each socket address on the list until the calls to <code id="P70004970270000000000000000468E3" data-uri="chapter11.xhtml#P70004970270000000000000000468E3" class="pcalibre1 calibre8 pcalibre">socket</code> and <code id="P70004970270000000000000000468E4" data-uri="chapter11.xhtml#P70004970270000000000000000468E4" class="pcalibre1 calibre8 pcalibre">bind</code> succeed and the descriptor is bound to a valid socket address. To avoid memory leaks, the application must eventually free the list by calling <code id="P70004970270000000000000000468E5" data-uri="chapter11.xhtml#P70004970270000000000000000468E5" class="pcalibre1 calibre8 pcalibre">freeaddrinfo</code>. If <code id="P70004970270000000000000000468E6" data-uri="chapter11.xhtml#P70004970270000000000000000468E6" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> returns a nonzero error code, the application can call <code id="P70004970270000000000000000468E7" data-uri="chapter11.xhtml#P70004970270000000000000000468E7" class="pcalibre1 calibre8 pcalibre">gai_strerror</code> to convert the code to a message string.</p>
<p id="P70004970270000000000000000468E8" data-uri="chapter11.xhtml#P70004970270000000000000000468E8" class="pcalibre1 pcalibre calibre2">The <code id="P70004970270000000000000000468E9" data-uri="chapter11.xhtml#P70004970270000000000000000468E9" class="pcalibre1 calibre8 pcalibre">host</code> argument to <code id="P70004970270000000000000000468EA" data-uri="chapter11.xhtml#P70004970270000000000000000468EA" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> can be either a domain name or a numeric address (e.g., a dotted-decimal IP address). The <code id="P70004970270000000000000000468EB" data-uri="chapter11.xhtml#P70004970270000000000000000468EB" class="pcalibre1 calibre8 pcalibre">service</code> argument can be either a service name <code id="P70004970270000000000000000468EC" data-uri="chapter11.xhtml#P70004970270000000000000000468EC" class="pcalibre1 calibre8 pcalibre">(e.g., http)</code> or a decimal port number. If we are not interested in converting the hostname to an address, we can set <code id="P70004970270000000000000000468ED" data-uri="chapter11.xhtml#P70004970270000000000000000468ED" class="pcalibre1 calibre8 pcalibre">host</code> to NULL. The same holds for <code id="P70004970270000000000000000468EE" data-uri="chapter11.xhtml#P70004970270000000000000000468EE" class="pcalibre1 calibre8 pcalibre">service</code>. However, at least one of them must be specified.</p>
<p id="P70004970270000000000000000468EF" data-uri="chapter11.xhtml#P70004970270000000000000000468EF" class="pcalibre1 pcalibre calibre2">The optional <code id="P70004970270000000000000000468F0" data-uri="chapter11.xhtml#P70004970270000000000000000468F0" class="pcalibre1 calibre8 pcalibre">hints</code> argument is an <code id="P70004970270000000000000000468F1" data-uri="chapter11.xhtml#P70004970270000000000000000468F1" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structure (<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007D88"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.16</span></a>) that provides finer control over the list of socket addresses that <code id="P70004970270000000000000000468F2" data-uri="chapter11.xhtml#P70004970270000000000000000468F2" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> returns. When passed as a hints argument, only the <code id="P70004970270000000000000000468F3" data-uri="chapter11.xhtml#P70004970270000000000000000468F3" class="pcalibre1 calibre8 pcalibre">ai_family, ai_socktype, ai_protocol</code>, and <code id="P70004970270000000000000000468F4" data-uri="chapter11.xhtml#P70004970270000000000000000468F4" class="pcalibre1 calibre8 pcalibre">ai_flags</code> fields can be set. The other fields must be set to zero (or NULL). In practice, we use <code id="P70004970270000000000000000468F5" data-uri="chapter11.xhtml#P70004970270000000000000000468F5" class="pcalibre1 calibre8 pcalibre">memset</code> to zero the entire structure and then set a few selected fields:</p>
<ul id="P70004970270000000000000000468F6" data-uri="chapter11.xhtml#P70004970270000000000000000468F6" class="calibre28 pcalibre pcalibre1">
<li id="P70004970270000000000000000468F7" data-uri="chapter11.xhtml#P70004970270000000000000000468F7" class="calibre12 pcalibre pcalibre1"><p id="P70004970270000000000000000468F8" data-uri="chapter11.xhtml#P70004970270000000000000000468F8" class="pcalibre calibre3 pcalibre1">By default, <code id="P70004970270000000000000000468F9" data-uri="chapter11.xhtml#P70004970270000000000000000468F9" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> can return both IPv4 and IPv6 socket addresses. Setting <code id="P70004970270000000000000000468FA" data-uri="chapter11.xhtml#P70004970270000000000000000468FA" class="pcalibre1 calibre8 pcalibre">ai_family</code> to AF_INET restricts the list to IPv4 addresses. Setting it to AF_INET6 restricts the list to IPv6 addresses.</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007D88" data-uri="chapter11.xhtml#P7000497027000000000000000007D88">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007D89" title="939" data-uri="chapter11.xhtml#P7000497027000000000000000007D89" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000468FB" data-uri="chapter11.xhtml#P70004970270000000000000000468FB" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000468FC" data-uri="chapter11.xhtml#P70004970270000000000000000468FC" class="calibre10 pcalibre pcalibre1">
struct addrinfo {
	int		ai_flags;	/* Hints argument flags */
	int		ai_family;	/* First arg to socket function */
	int		ai_socktype;	/* Second arg to socket function */
	int		ai_protocol;	/* Third arg to socket function */
	char		*ai_canonname;	/* Canonical hostname */
	size_t		ai_addrlen;	/* Size of ai_addr struct */
	struct sockaddr	*ai_addr;	/* Ptr to socket address structure */
struct addrinfo		*ai_next;	/* Ptr to next item in linked list */
};
</code></pre>
<figcaption id="P70004970270000000000000000468FD" data-uri="chapter11.xhtml#P70004970270000000000000000468FD" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000468FE" data-uri="chapter11.xhtml#P70004970270000000000000000468FE" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.16 </span>The <code id="P70004970270000000000000000468FF" data-uri="chapter11.xhtml#P70004970270000000000000000468FF" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structure used by <code id="P7000497027000000000000000046900" data-uri="chapter11.xhtml#P7000497027000000000000000046900" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code>.</h1></header>
</figcaption>
</figure></li>
<li id="P7000497027000000000000000046901" data-uri="chapter11.xhtml#P7000497027000000000000000046901" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046902" data-uri="chapter11.xhtml#P7000497027000000000000000046902" class="pcalibre calibre3 pcalibre1">By default, for each unique address associated with host, the <code id="P7000497027000000000000000046903" data-uri="chapter11.xhtml#P7000497027000000000000000046903" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> function can return up to three <code id="P7000497027000000000000000046904" data-uri="chapter11.xhtml#P7000497027000000000000000046904" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structures, each with a different <code id="P7000497027000000000000000046905" data-uri="chapter11.xhtml#P7000497027000000000000000046905" class="pcalibre1 calibre8 pcalibre">ai_socktype</code> field: one for connections, one for datagrams (not covered), and one for raw sockets (not covered). Setting <code id="P7000497027000000000000000046906" data-uri="chapter11.xhtml#P7000497027000000000000000046906" class="pcalibre1 calibre8 pcalibre">ai_socktype</code> to SOCK_STREAM restricts the list to at most one <code id="P7000497027000000000000000046907" data-uri="chapter11.xhtml#P7000497027000000000000000046907" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structure for each unique address, one whose socket address can be used as the end point of a connection. This is the desired behavior for all of our example programs.</p></li>
<li id="P7000497027000000000000000046908" data-uri="chapter11.xhtml#P7000497027000000000000000046908" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046909" data-uri="chapter11.xhtml#P7000497027000000000000000046909" class="pcalibre calibre3 pcalibre1">The <code id="P700049702700000000000000004690A" data-uri="chapter11.xhtml#P700049702700000000000000004690A" class="pcalibre1 calibre8 pcalibre">ai_flags</code> field is a bit mask that further modifies the default behavior. You create it by <span class="smallcaps pcalibre pcalibre1">or</span>ing combinations of various values. Here are some that we find useful:</p>
<ul class="ul_none1 pcalibre pcalibre1" id="P700049702700000000000000004690B" data-uri="chapter11.xhtml#P700049702700000000000000004690B">
<li id="P700049702700000000000000004690C" data-uri="chapter11.xhtml#P700049702700000000000000004690C" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004690D" data-uri="chapter11.xhtml#P700049702700000000000000004690D" class="calibre13 pcalibre pcalibre1">AI_ADDRCONFIG. This flag is recommended if you are using connections <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3E5">[34]</a>. It asks <code id="P700049702700000000000000004690E" data-uri="chapter11.xhtml#P700049702700000000000000004690E" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> to return IPv4 addresses only if the local host is configured for IPv4. Similarly for IPv6.</p></li>
<li id="P700049702700000000000000004690F" data-uri="chapter11.xhtml#P700049702700000000000000004690F" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046910" data-uri="chapter11.xhtml#P7000497027000000000000000046910" class="calibre13 pcalibre pcalibre1">AI_CANONNAME. By default, the <code id="P7000497027000000000000000046911" data-uri="chapter11.xhtml#P7000497027000000000000000046911" class="pcalibre1 calibre8 pcalibre">ai_canonname</code> field is NULL. If this flag is set, it instructs <code id="P7000497027000000000000000046912" data-uri="chapter11.xhtml#P7000497027000000000000000046912" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> to point the <code id="P7000497027000000000000000046913" data-uri="chapter11.xhtml#P7000497027000000000000000046913" class="pcalibre1 calibre8 pcalibre">ai_canonname</code> field in the first <code id="P7000497027000000000000000046914" data-uri="chapter11.xhtml#P7000497027000000000000000046914" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structure in the list to the canonical (official) name of <code id="P7000497027000000000000000046915" data-uri="chapter11.xhtml#P7000497027000000000000000046915" class="pcalibre1 calibre8 pcalibre">host</code> (see <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007D5E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.15</span></a>).</p></li>
<li id="P7000497027000000000000000046916" data-uri="chapter11.xhtml#P7000497027000000000000000046916" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046917" data-uri="chapter11.xhtml#P7000497027000000000000000046917" class="calibre13 pcalibre pcalibre1">AI_NUMERICSERV. By default, the <code id="P7000497027000000000000000046918" data-uri="chapter11.xhtml#P7000497027000000000000000046918" class="pcalibre1 calibre8 pcalibre">service</code> argument can be a service name or a port number. This flag forces the <code id="P7000497027000000000000000046919" data-uri="chapter11.xhtml#P7000497027000000000000000046919" class="pcalibre1 calibre8 pcalibre">service</code> argument to be a port number.</p></li>
<li id="P700049702700000000000000004691A" data-uri="chapter11.xhtml#P700049702700000000000000004691A" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004691B" data-uri="chapter11.xhtml#P700049702700000000000000004691B" class="calibre13 pcalibre pcalibre1">AI_PASSIVE. By default, <code id="P700049702700000000000000004691C" data-uri="chapter11.xhtml#P700049702700000000000000004691C" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> returns socket addresses that can be used by clients as active sockets in calls to <code id="P700049702700000000000000004691D" data-uri="chapter11.xhtml#P700049702700000000000000004691D" class="pcalibre1 calibre8 pcalibre">connect</code>. This flag instructs it to return socket addresses that can be used by servers as listening sockets. In this case, the <code id="P700049702700000000000000004691E" data-uri="chapter11.xhtml#P700049702700000000000000004691E" class="pcalibre1 calibre8 pcalibre">host</code> argument should be NULL. The address field in the resulting socket address structure(s) will be the <i class="calibre5 pcalibre pcalibre1">wildcard address</i>, which tells the kernel that this server will accept requests to any of the IP addresses for this host. This is the desired behavior for all of our example servers.</p></li>
</ul></li>
</ul>
<p id="P700049702700000000000000004691F" data-uri="chapter11.xhtml#P700049702700000000000000004691F" class="pcalibre1 pcalibre calibre2"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007DAF" title="940" data-uri="chapter11.xhtml#P7000497027000000000000000007DAF" epub:type="pagebreak"></span>When <code id="P7000497027000000000000000046920" data-uri="chapter11.xhtml#P7000497027000000000000000046920" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> creates an <code id="P7000497027000000000000000046921" data-uri="chapter11.xhtml#P7000497027000000000000000046921" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structure in the output list, it fills in each field except for <code id="P7000497027000000000000000046922" data-uri="chapter11.xhtml#P7000497027000000000000000046922" class="pcalibre1 calibre8 pcalibre">ai_flags</code>. The <code id="P7000497027000000000000000046923" data-uri="chapter11.xhtml#P7000497027000000000000000046923" class="pcalibre1 calibre8 pcalibre">ai_addr</code> field points to a socket address structure, the <code id="P7000497027000000000000000046924" data-uri="chapter11.xhtml#P7000497027000000000000000046924" class="pcalibre1 calibre8 pcalibre">ai_addrlen</code> field gives the size of this socket address structure, and the <code id="P7000497027000000000000000046925" data-uri="chapter11.xhtml#P7000497027000000000000000046925" class="pcalibre1 calibre8 pcalibre">ai_next</code> field points to the next <code id="P7000497027000000000000000046926" data-uri="chapter11.xhtml#P7000497027000000000000000046926" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structure in the list. The other fields describe various attributes of the socket address.</p>
<p id="P7000497027000000000000000046927" data-uri="chapter11.xhtml#P7000497027000000000000000046927" class="pcalibre1 pcalibre calibre2">One of the elegant aspects of <code id="P7000497027000000000000000046928" data-uri="chapter11.xhtml#P7000497027000000000000000046928" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> is that the fields in an <code id="P7000497027000000000000000046929" data-uri="chapter11.xhtml#P7000497027000000000000000046929" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structure are opaque, in the sense that they can be passed directly to the functions in the sockets interface without any further manipulation by the application code. For example, <code id="P700049702700000000000000004692A" data-uri="chapter11.xhtml#P700049702700000000000000004692A" class="pcalibre1 calibre8 pcalibre">ai_family, ai_socktype</code>, and <code id="P700049702700000000000000004692B" data-uri="chapter11.xhtml#P700049702700000000000000004692B" class="pcalibre1 calibre8 pcalibre">ai_protocol</code> can be passed directly to socket. Similarly, <code id="P700049702700000000000000004692C" data-uri="chapter11.xhtml#P700049702700000000000000004692C" class="pcalibre1 calibre8 pcalibre">ai_addr</code> and <code id="P700049702700000000000000004692D" data-uri="chapter11.xhtml#P700049702700000000000000004692D" class="pcalibre1 calibre8 pcalibre">ai_addrlen</code> can be passed directly to <code id="P700049702700000000000000004692E" data-uri="chapter11.xhtml#P700049702700000000000000004692E" class="pcalibre1 calibre8 pcalibre">connect</code> and <code id="P700049702700000000000000004692F" data-uri="chapter11.xhtml#P700049702700000000000000004692F" class="pcalibre1 calibre8 pcalibre">bind</code>. This powerful property allows us to write clients and servers that are independent of any particular version of the IP protocol.</p>
</section>
<section id="P7000497027000000000000000007DC0" data-uri="chapter11.xhtml#P7000497027000000000000000007DC0" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P7000497027000000000000000046930" data-uri="chapter11.xhtml#P7000497027000000000000000046930" epub:type="title">The <code id="P7000497027000000000000000046931" data-uri="chapter11.xhtml#P7000497027000000000000000046931" class="calibre55 pcalibre pcalibre1">getnameinfo</code> Function</h1></header>
<p id="P7000497027000000000000000046932" data-uri="chapter11.xhtml#P7000497027000000000000000046932" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046933" data-uri="chapter11.xhtml#P7000497027000000000000000046933" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> function is the inverse of <code id="P7000497027000000000000000046934" data-uri="chapter11.xhtml#P7000497027000000000000000046934" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code>. It converts a socket address structure to the corresponding host and service name strings. It is the modern replacement for the obsolete <code id="P7000497027000000000000000046935" data-uri="chapter11.xhtml#P7000497027000000000000000046935" class="pcalibre1 calibre8 pcalibre">gethostbyaddr</code> and <code id="P7000497027000000000000000046936" data-uri="chapter11.xhtml#P7000497027000000000000000046936" class="pcalibre1 calibre8 pcalibre">getservbyport</code> functions, and unlike those functions, it is reentrant and protocol-independent.</p>
<pre id="P7000497027000000000000000046937" data-uri="chapter11.xhtml#P7000497027000000000000000046937" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046938" data-uri="chapter11.xhtml#P7000497027000000000000000046938" class="calibre10 pcalibre pcalibre1">
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
int getnameinfo(const struct sockaddr *sa, socklen_t salen,
				char *host, size_t hostlen,
				char *service, size_t servlen, int flags);
									Returns: 0 if OK, nonzero error code on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046939" data-uri="chapter11.xhtml#P7000497027000000000000000046939">The <code id="P700049702700000000000000004693A" data-uri="chapter11.xhtml#P700049702700000000000000004693A" class="pcalibre1 calibre8 pcalibre">sa</code> argument points to a socket address structure of size <code id="P700049702700000000000000004693B" data-uri="chapter11.xhtml#P700049702700000000000000004693B" class="pcalibre1 calibre8 pcalibre">salen</code> bytes, <code id="P700049702700000000000000004693C" data-uri="chapter11.xhtml#P700049702700000000000000004693C" class="pcalibre1 calibre8 pcalibre">host</code> to a buffer of size <code id="P700049702700000000000000004693D" data-uri="chapter11.xhtml#P700049702700000000000000004693D" class="pcalibre1 calibre8 pcalibre">hostlen</code> bytes, and <code id="P700049702700000000000000004693E" data-uri="chapter11.xhtml#P700049702700000000000000004693E" class="pcalibre1 calibre8 pcalibre">service</code> to a buffer of size <code id="P700049702700000000000000004693F" data-uri="chapter11.xhtml#P700049702700000000000000004693F" class="pcalibre1 calibre8 pcalibre">servlen</code> bytes. The <code id="P7000497027000000000000000046940" data-uri="chapter11.xhtml#P7000497027000000000000000046940" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> function converts the socket address structure <code id="P7000497027000000000000000046941" data-uri="chapter11.xhtml#P7000497027000000000000000046941" class="pcalibre1 calibre8 pcalibre">sa</code> to the corresponding <code id="P7000497027000000000000000046942" data-uri="chapter11.xhtml#P7000497027000000000000000046942" class="pcalibre1 calibre8 pcalibre">host</code> and <code id="P7000497027000000000000000046943" data-uri="chapter11.xhtml#P7000497027000000000000000046943" class="pcalibre1 calibre8 pcalibre">service</code> name strings and copies them to the <code id="P7000497027000000000000000046944" data-uri="chapter11.xhtml#P7000497027000000000000000046944" class="pcalibre1 calibre8 pcalibre">host</code> and <code id="P7000497027000000000000000046945" data-uri="chapter11.xhtml#P7000497027000000000000000046945" class="pcalibre1 calibre8 pcalibre">service</code> buffers. If <code id="P7000497027000000000000000046946" data-uri="chapter11.xhtml#P7000497027000000000000000046946" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> returns a nonzero error code, the application can convert it to a string by calling <code id="P7000497027000000000000000046947" data-uri="chapter11.xhtml#P7000497027000000000000000046947" class="pcalibre1 calibre8 pcalibre">gai_strerror</code>.</p>
<p id="P7000497027000000000000000046948" data-uri="chapter11.xhtml#P7000497027000000000000000046948" class="pcalibre1 pcalibre calibre2">If we don't want the hostname, we can <code id="P7000497027000000000000000046949" data-uri="chapter11.xhtml#P7000497027000000000000000046949" class="pcalibre1 calibre8 pcalibre">set host</code> to NULL and <code id="P700049702700000000000000004694A" data-uri="chapter11.xhtml#P700049702700000000000000004694A" class="pcalibre1 calibre8 pcalibre">hostlen</code> to zero. The same holds for the service fields. However, one or the other must be set.</p>
<p id="P700049702700000000000000004694B" data-uri="chapter11.xhtml#P700049702700000000000000004694B" class="pcalibre1 pcalibre calibre2">The <code id="P700049702700000000000000004694C" data-uri="chapter11.xhtml#P700049702700000000000000004694C" class="pcalibre1 calibre8 pcalibre">flags</code> argument is a bit mask that modifies the default behavior. You create it by <span class="smallcaps pcalibre pcalibre1">or</span>ing combinations of various values. Here are a couple of useful ones:</p>
<ul class="pcalibre ul_none pcalibre1" id="P700049702700000000000000004694D" data-uri="chapter11.xhtml#P700049702700000000000000004694D">
<li id="P700049702700000000000000004694E" data-uri="chapter11.xhtml#P700049702700000000000000004694E" class="calibre12 pcalibre pcalibre1"><p id="P700049702700000000000000004694F" data-uri="chapter11.xhtml#P700049702700000000000000004694F" class="calibre13 pcalibre pcalibre1">NI_NUMERICHOST. By default, <code id="P7000497027000000000000000046950" data-uri="chapter11.xhtml#P7000497027000000000000000046950" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> tries to return a domain name in <code id="P7000497027000000000000000046951" data-uri="chapter11.xhtml#P7000497027000000000000000046951" class="pcalibre1 calibre8 pcalibre">host</code>. Setting this flag will cause it to return a numeric address string instead.</p></li>
<li id="P7000497027000000000000000046952" data-uri="chapter11.xhtml#P7000497027000000000000000046952" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000046953" data-uri="chapter11.xhtml#P7000497027000000000000000046953" class="calibre13 pcalibre pcalibre1">NI_NUMERICSERV. By default, <code id="P7000497027000000000000000046954" data-uri="chapter11.xhtml#P7000497027000000000000000046954" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> will look in <code id="P7000497027000000000000000046955" data-uri="chapter11.xhtml#P7000497027000000000000000046955" class="pcalibre1 calibre8 pcalibre">/etc/services</code> and if possible, return a service name instead of a port number. Setting this flag forces it to skip the lookup and simply return the port number.</p></li>
</ul>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007DE7" data-uri="chapter11.xhtml#P7000497027000000000000000007DE7">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007DE8" title="941" data-uri="chapter11.xhtml#P7000497027000000000000000007DE8" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046956" data-uri="chapter11.xhtml#P7000497027000000000000000046956" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046957" data-uri="chapter11.xhtml#P7000497027000000000000000046957" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	
3	int main(int argc, char **argv)
4	{
5		struct addrinfo *p, *listp, hints;
6		char buf[MAXLINE];
7		int rc, flags;
8	
9		if (argc != 2) {
10			fprintf(stderr, "usage: %s &lt;domain name&gt;\n", argv[0]);
11			exit(0);
12		}
13	
14		/* Get a list of addrinfo records */
15		memset(&amp;hints, 0, sizeof(struct addrinfo));
16		hints.ai_family = AF_INET; /* IPv4 only */
17		hints.ai_socktype = SOCK_STREAM; /* Connections only */
18		if ((rc = getaddrinfo(argv[1], NULL, &amp;hints, &amp;listp)) != 0) {
19			fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(rc));
20			exit(1);
21	}
22	
23		/* Walk the list and display each IP address */
24		flags = NI_NUMERICHOST; /* Display address string instead of domain name */
25		for (p = listp; p; p = p-&gt;ai_next) {
26			Getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, NULL, 0, flags);
27			printf("%s\n", buf);
28		}
29	
30		/* Clean up */
31		Freeaddrinfo(listp);
32	
33		exit(0);
34	}
</code></pre>
<figcaption id="P7000497027000000000000000046958" data-uri="chapter11.xhtml#P7000497027000000000000000046958" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000046959" data-uri="chapter11.xhtml#P7000497027000000000000000046959" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.17 </span>H<span class="smallcaps1 pcalibre pcalibre1">ostinfo</span> displays the mapping of a domain name to its associated IP addresses.</h1></header>
</figcaption>
</figure>
<p id="P700049702700000000000000004695A" data-uri="chapter11.xhtml#P700049702700000000000000004695A" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007DE7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.17</span></a> shows a simple program, called <span class="smallcaps pcalibre pcalibre1">hostinfo</span>, that uses <code id="P700049702700000000000000004695B" data-uri="chapter11.xhtml#P700049702700000000000000004695B" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> and <code id="P700049702700000000000000004695C" data-uri="chapter11.xhtml#P700049702700000000000000004695C" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> to display the mapping of a domain name to its associated IP addresses. It is similar to the <span class="smallcaps pcalibre pcalibre1">nslookup </span>program from <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007BFE.xhtml#P7000497027000000000000000007C6B"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">11.3.2</span></a>.</p>
<p id="P700049702700000000000000004695D" data-uri="chapter11.xhtml#P700049702700000000000000004695D" class="pcalibre1 pcalibre calibre2">First, we initialize the <code id="P700049702700000000000000004695E" data-uri="chapter11.xhtml#P700049702700000000000000004695E" class="pcalibre1 calibre8 pcalibre">hints</code> structure so that <code id="P700049702700000000000000004695F" data-uri="chapter11.xhtml#P700049702700000000000000004695F" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> returns the addresses we want. In this case, we are looking for 32-bit IP addresses (line 16) <span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007DF3" title="942" data-uri="chapter11.xhtml#P7000497027000000000000000007DF3" epub:type="pagebreak"></span>that can be used as end points of connections (line 17). Since we are only asking <code id="P7000497027000000000000000046960" data-uri="chapter11.xhtml#P7000497027000000000000000046960" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> to convert domain names, we call it with a NULL <code id="P7000497027000000000000000046961" data-uri="chapter11.xhtml#P7000497027000000000000000046961" class="pcalibre1 calibre8 pcalibre">service</code> argument.</p>
<p id="P7000497027000000000000000046962" data-uri="chapter11.xhtml#P7000497027000000000000000046962" class="pcalibre1 pcalibre calibre2">After the call to <code id="P7000497027000000000000000046963" data-uri="chapter11.xhtml#P7000497027000000000000000046963" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code>, we walk the list of <code id="P7000497027000000000000000046964" data-uri="chapter11.xhtml#P7000497027000000000000000046964" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structures, using <code id="P7000497027000000000000000046965" data-uri="chapter11.xhtml#P7000497027000000000000000046965" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> to convert each socket address to a dotted-decimal address string. After walking the list, we are careful to free it by calling <code id="P7000497027000000000000000046966" data-uri="chapter11.xhtml#P7000497027000000000000000046966" class="pcalibre1 calibre8 pcalibre">freeaddrinfo</code> (although for this simple program it is not strictly necessary).</p>
<p id="P7000497027000000000000000046967" data-uri="chapter11.xhtml#P7000497027000000000000000046967" class="pcalibre1 pcalibre calibre2">When we run <span class="smallcaps pcalibre pcalibre1">hostinfo</span>, we see that <code id="P7000497027000000000000000046968" data-uri="chapter11.xhtml#P7000497027000000000000000046968" class="pcalibre1 calibre8 pcalibre"><a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="http://twitter.com">twitter.com</a></code> maps to four IP addresses, which is what we saw using <span class="smallcaps pcalibre pcalibre1">nslookup </span>in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000007BFE.xhtml#P7000497027000000000000000007C6B"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">11.3.2</span></a>.</p>
<pre id="P7000497027000000000000000046969" data-uri="chapter11.xhtml#P7000497027000000000000000046969" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004696A" data-uri="chapter11.xhtml#P700049702700000000000000004696A" class="calibre10 pcalibre pcalibre1">
linux&gt; <i class="calibre5 pcalibre pcalibre1">./hostinfo twitter.com</i>
199.16.156.102
199.16.156.230
199.16.156.6
199.16.156.70
</code></pre>
<section id="P7000497027000000000000000007DFF" data-uri="chapter11.xhtml#P7000497027000000000000000007DFF" epub:type="practice" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title10 pcalibre pcalibre1" id="P700049702700000000000000004696B" data-uri="chapter11.xhtml#P700049702700000000000000004696B" epub:type="title"><span class="pcalibre label pcalibre1">Practice Problem </span><span class="pcalibre label pcalibre1">11.4 </span>(solution page <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" epub:type="pagebreak" href="fileP7000497027000000000000000008021.xhtml#P7000497027000000000000000008049">968</a>)</h1></header>
<ol class="practicelist pcalibre pcalibre1" id="P700049702700000000000000004696C" data-uri="chapter11.xhtml#P700049702700000000000000004696C">
<li class="general-problem pcalibre pcalibre1" id="P700049702700000000000000004696D" data-uri="chapter11.xhtml#P700049702700000000000000004696D">
<div class="edition pcalibre pcalibre1" id="P700049702700000000000000004696E" data-uri="chapter11.xhtml#P700049702700000000000000004696E"><p id="P700049702700000000000000004696F" data-uri="chapter11.xhtml#P700049702700000000000000004696F" class="pcalibre calibre3 pcalibre1">The <code id="P7000497027000000000000000046970" data-uri="chapter11.xhtml#P7000497027000000000000000046970" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> and <code id="P7000497027000000000000000046971" data-uri="chapter11.xhtml#P7000497027000000000000000046971" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> functions subsume the functionality of <code id="P7000497027000000000000000046972" data-uri="chapter11.xhtml#P7000497027000000000000000046972" class="pcalibre1 calibre8 pcalibre">inet_pton</code> and <code id="P7000497027000000000000000046973" data-uri="chapter11.xhtml#P7000497027000000000000000046973" class="pcalibre1 calibre8 pcalibre">inet_ntop</code>, respectively, and they provide a higher-level of abstraction that is independent of any particular address format. To convince yourself how handy this is, write a version of <span class="smallcaps pcalibre pcalibre1">hostinfo </span>(<a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007DE7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.17</span></a>) that uses <code id="P7000497027000000000000000046974" data-uri="chapter11.xhtml#P7000497027000000000000000046974" class="pcalibre1 calibre8 pcalibre">inet_ntop</code> instead of <code id="P7000497027000000000000000046975" data-uri="chapter11.xhtml#P7000497027000000000000000046975" class="pcalibre1 calibre8 pcalibre">getnameinfo</code> to convert each socket address to a dotted-decimal address string.</p></div></li>
</ol>
</section>
</section>
</section>
<section id="P7000497027000000000000000007E0B" data-uri="chapter11.xhtml#P7000497027000000000000000007E0B" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P7000497027000000000000000046976" data-uri="chapter11.xhtml#P7000497027000000000000000046976" epub:type="title"><span class="pcalibre label pcalibre1">11.4.8 </span>Helper Functions for the Sockets Interface</h1></header>
<p id="P7000497027000000000000000046977" data-uri="chapter11.xhtml#P7000497027000000000000000046977" class="pcalibre1 pcalibre calibre2">The <code id="P7000497027000000000000000046978" data-uri="chapter11.xhtml#P7000497027000000000000000046978" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> function and the sockets interface can seem somewhat daunting when you first learn about them. We find it convenient to wrap them with higher-level helper functions, called <code id="P7000497027000000000000000046979" data-uri="chapter11.xhtml#P7000497027000000000000000046979" class="pcalibre1 calibre8 pcalibre">open_clientfd</code> and <code id="P700049702700000000000000004697A" data-uri="chapter11.xhtml#P700049702700000000000000004697A" class="pcalibre1 calibre8 pcalibre">open_listenfd</code>, that clients and servers can use when they want to communicate with each other.</p>
<section id="P7000497027000000000000000007E11" data-uri="chapter11.xhtml#P7000497027000000000000000007E11" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004697B" data-uri="chapter11.xhtml#P700049702700000000000000004697B" epub:type="title">The <code id="P700049702700000000000000004697C" data-uri="chapter11.xhtml#P700049702700000000000000004697C" class="calibre55 pcalibre pcalibre1">open_clientfd</code> Function</h1></header>
<p id="P700049702700000000000000004697D" data-uri="chapter11.xhtml#P700049702700000000000000004697D" class="pcalibre1 pcalibre calibre2">A client establishes a connection with a server by calling <code id="P700049702700000000000000004697E" data-uri="chapter11.xhtml#P700049702700000000000000004697E" class="pcalibre1 calibre8 pcalibre">open_clientfd</code>.</p>
<pre id="P700049702700000000000000004697F" data-uri="chapter11.xhtml#P700049702700000000000000004697F" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046980" data-uri="chapter11.xhtml#P7000497027000000000000000046980" class="calibre10 pcalibre pcalibre1">
#include "csapp.h"
int open_clientfd(char *hostname, char *port);
Returns: descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000046981" data-uri="chapter11.xhtml#P7000497027000000000000000046981">The <code id="P7000497027000000000000000046982" data-uri="chapter11.xhtml#P7000497027000000000000000046982" class="pcalibre1 calibre8 pcalibre">open_clientfd</code> function establishes a connection with a server running on host <code id="P7000497027000000000000000046983" data-uri="chapter11.xhtml#P7000497027000000000000000046983" class="pcalibre1 calibre8 pcalibre">hostname</code> and listening for connection requests on port number port. It returns an open socket descriptor that is ready for input and output using the Unix I/O functions. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007E1F"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.18</span></a> shows the code for <code id="P7000497027000000000000000046984" data-uri="chapter11.xhtml#P7000497027000000000000000046984" class="pcalibre1 calibre8 pcalibre">open_clientfd.</code></p>
<p id="P7000497027000000000000000046985" data-uri="chapter11.xhtml#P7000497027000000000000000046985" class="pcalibre1 pcalibre calibre2">We call <code id="P7000497027000000000000000046986" data-uri="chapter11.xhtml#P7000497027000000000000000046986" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code>, which returns a list of <code id="P7000497027000000000000000046987" data-uri="chapter11.xhtml#P7000497027000000000000000046987" class="pcalibre1 calibre8 pcalibre">addrinfo</code> structures, each of which points to a socket address structure that is suitable for establishing a connection</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007E1F" data-uri="chapter11.xhtml#P7000497027000000000000000007E1F">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007E20" title="943" data-uri="chapter11.xhtml#P7000497027000000000000000007E20" epub:type="pagebreak"></span>
<pre id="P7000497027000000000000000046988" data-uri="chapter11.xhtml#P7000497027000000000000000046988" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000046989" data-uri="chapter11.xhtml#P7000497027000000000000000046989" class="calibre10 pcalibre pcalibre1">
1	int open_clientfd(char *hostname, char *port) {
2		int clientfd;
3		struct addrinfo hints, *listp, *p;
4	
5		/* Get a list of potential server addresses */
6		memset(&amp;hints, 0, sizeof(struct addrinfo));
7		hints.ai_socktype = SOCK_STREAM; /* Open a connection */
8		hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */
9		hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */
10		Getaddrinfo(hostname, port, &amp;hints, &amp;listp);
11	
12		/* Walk the list for one that we can successfully connect to */
13		for (p = listp; p; p = p-&gt;ai_next) {
14			/* Create a socket descriptor */
15			if ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0)
16				continue; /* Socket failed, try the next */
17	
18			/* Connect to the server */
19			if (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != −1)
20				break; /* Success */
21			Close(clientfd); /* Connect failed, try another */
22		}
23	
24		/* Clean up */
25		Freeaddrinfo(listp);
26		if (!p) /* All connects failed */
27			return −1;
28		else	/* The last connect succeeded */
29		return clientfd;
30	}
</code></pre>
<figcaption id="P700049702700000000000000004698A" data-uri="chapter11.xhtml#P700049702700000000000000004698A" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P700049702700000000000000004698B" data-uri="chapter11.xhtml#P700049702700000000000000004698B" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.18 </span><code id="P700049702700000000000000004698C" data-uri="chapter11.xhtml#P700049702700000000000000004698C" class="pcalibre1 calibre8 pcalibre">open_clientfd</code>: Helper function that establishes a connection with a server.</h1></header>
<div class="caption pcalibre pcalibre1" id="P700049702700000000000000004698D" data-uri="chapter11.xhtml#P700049702700000000000000004698D"><p id="P700049702700000000000000004698E" data-uri="chapter11.xhtml#P700049702700000000000000004698E" class="pcalibre calibre3 pcalibre1">It is reentrant and protocol-independent.</p></div></figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000004698F" data-uri="chapter11.xhtml#P700049702700000000000000004698F">with a server running on <code id="P7000497027000000000000000046990" data-uri="chapter11.xhtml#P7000497027000000000000000046990" class="pcalibre1 calibre8 pcalibre">hostname</code> and listening on <code id="P7000497027000000000000000046991" data-uri="chapter11.xhtml#P7000497027000000000000000046991" class="pcalibre1 calibre8 pcalibre">port</code>. We then walk the list, trying each list entry in turn, until the calls to <code id="P7000497027000000000000000046992" data-uri="chapter11.xhtml#P7000497027000000000000000046992" class="pcalibre1 calibre8 pcalibre">socket</code> and <code id="P7000497027000000000000000046993" data-uri="chapter11.xhtml#P7000497027000000000000000046993" class="pcalibre1 calibre8 pcalibre">connect</code> succeed. If the <code id="P7000497027000000000000000046994" data-uri="chapter11.xhtml#P7000497027000000000000000046994" class="pcalibre1 calibre8 pcalibre">connect</code> fails, we are careful to close the socket descriptor before trying the next entry. If the <code id="P7000497027000000000000000046995" data-uri="chapter11.xhtml#P7000497027000000000000000046995" class="pcalibre1 calibre8 pcalibre">connect</code> succeeds, we free the list memory and return the socket descriptor to the client, which can immediately begin using Unix I/O to communicate with the server.</p>
<p id="P7000497027000000000000000046996" data-uri="chapter11.xhtml#P7000497027000000000000000046996" class="pcalibre1 pcalibre calibre2">Notice how there is no dependence on any particular version of IP anywhere in the code. The arguments to <code id="P7000497027000000000000000046997" data-uri="chapter11.xhtml#P7000497027000000000000000046997" class="pcalibre1 calibre8 pcalibre">socket</code> and <code id="P7000497027000000000000000046998" data-uri="chapter11.xhtml#P7000497027000000000000000046998" class="pcalibre1 calibre8 pcalibre">connect</code> are generated for us automatically by <code id="P7000497027000000000000000046999" data-uri="chapter11.xhtml#P7000497027000000000000000046999" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code>, which allows our code to be clean and portable.</p>
</section>
<section id="P7000497027000000000000000007E33" data-uri="chapter11.xhtml#P7000497027000000000000000007E33" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="title5 pcalibre pcalibre1" id="P700049702700000000000000004699A" data-uri="chapter11.xhtml#P700049702700000000000000004699A" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007E35" title="944" data-uri="chapter11.xhtml#P7000497027000000000000000007E35" epub:type="pagebreak"></span>The <code id="P700049702700000000000000004699B" data-uri="chapter11.xhtml#P700049702700000000000000004699B" class="calibre55 pcalibre pcalibre1">open_listenfd</code> Function</h1></header>
<p id="P700049702700000000000000004699C" data-uri="chapter11.xhtml#P700049702700000000000000004699C" class="pcalibre1 pcalibre calibre2">A server creates a listening descriptor that is ready to receive connection requests by calling the <code id="P700049702700000000000000004699D" data-uri="chapter11.xhtml#P700049702700000000000000004699D" class="pcalibre1 calibre8 pcalibre">open_listenfd</code> function.</p>
<pre id="P700049702700000000000000004699E" data-uri="chapter11.xhtml#P700049702700000000000000004699E" class="calibre9 pcalibre pcalibre1"><code id="P700049702700000000000000004699F" data-uri="chapter11.xhtml#P700049702700000000000000004699F" class="calibre10 pcalibre pcalibre1">
#include "csapp.h"
int open_listenfd(char *port);
Returns: descriptor if OK, −1 on error
</code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000469A0" data-uri="chapter11.xhtml#P70004970270000000000000000469A0">The <code id="P70004970270000000000000000469A1" data-uri="chapter11.xhtml#P70004970270000000000000000469A1" class="pcalibre1 calibre8 pcalibre">open_listenfd</code> function returns a listening descriptor that is ready to receive connection requests on port <code id="P70004970270000000000000000469A2" data-uri="chapter11.xhtml#P70004970270000000000000000469A2" class="pcalibre1 calibre8 pcalibre">port</code>. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007E55"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.19</span></a> shows the code for <code id="P70004970270000000000000000469A3" data-uri="chapter11.xhtml#P70004970270000000000000000469A3" class="pcalibre1 calibre8 pcalibre">open_listenfd</code>.</p>
<p id="P70004970270000000000000000469A4" data-uri="chapter11.xhtml#P70004970270000000000000000469A4" class="pcalibre1 pcalibre calibre2">The style is similar to <code id="P70004970270000000000000000469A5" data-uri="chapter11.xhtml#P70004970270000000000000000469A5" class="pcalibre1 calibre8 pcalibre">open_clientfd</code>. We call <code id="P70004970270000000000000000469A6" data-uri="chapter11.xhtml#P70004970270000000000000000469A6" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> and then walk the resulting list until the calls to <code id="P70004970270000000000000000469A7" data-uri="chapter11.xhtml#P70004970270000000000000000469A7" class="pcalibre1 calibre8 pcalibre">socket</code> and <code id="P70004970270000000000000000469A8" data-uri="chapter11.xhtml#P70004970270000000000000000469A8" class="pcalibre1 calibre8 pcalibre">bind</code> succeed. Note that in line 20 we use the <code id="P70004970270000000000000000469A9" data-uri="chapter11.xhtml#P70004970270000000000000000469A9" class="pcalibre1 calibre8 pcalibre">setsockopt</code> function (not described here) to configure the server so that it can be terminated, be restarted, and begin accepting connection requests immediately. By default, a restarted server will deny connection requests from clients for approximately 30 seconds, which seriously hinders debugging.</p>
<p id="P70004970270000000000000000469AA" data-uri="chapter11.xhtml#P70004970270000000000000000469AA" class="pcalibre1 pcalibre calibre2">Since we have called <code id="P70004970270000000000000000469AB" data-uri="chapter11.xhtml#P70004970270000000000000000469AB" class="pcalibre1 calibre8 pcalibre">getaddrinfo</code> with the AI_PASSIVE flag and a NULL <code id="P70004970270000000000000000469AC" data-uri="chapter11.xhtml#P70004970270000000000000000469AC" class="pcalibre1 calibre8 pcalibre">host</code> argument, the address field in each socket address structure is set to the wildcard address, which tells the kernel that this server will accept requests to any of the IP addresses for this host.</p>
<p id="P70004970270000000000000000469AD" data-uri="chapter11.xhtml#P70004970270000000000000000469AD" class="pcalibre1 pcalibre calibre2">Finally, we call the <code id="P70004970270000000000000000469AE" data-uri="chapter11.xhtml#P70004970270000000000000000469AE" class="pcalibre1 calibre8 pcalibre">listen</code> function to convert <code id="P70004970270000000000000000469AF" data-uri="chapter11.xhtml#P70004970270000000000000000469AF" class="pcalibre1 calibre8 pcalibre">listenfd</code> to a listening descriptor and return it to the caller. If the <code id="P70004970270000000000000000469B0" data-uri="chapter11.xhtml#P70004970270000000000000000469B0" class="pcalibre1 calibre8 pcalibre">listen</code> fails, we are careful to avoid a memory leak by closing the descriptor before returning.</p>
</section>
</section>
<section id="P7000497027000000000000000007E4C" data-uri="chapter11.xhtml#P7000497027000000000000000007E4C" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title1 pcalibre1" id="P70004970270000000000000000469B1" data-uri="chapter11.xhtml#P70004970270000000000000000469B1" epub:type="title"><span class="pcalibre label pcalibre1">11.4.9 </span>Example Echo Client and Server</h1></header>
<p id="P70004970270000000000000000469B2" data-uri="chapter11.xhtml#P70004970270000000000000000469B2" class="pcalibre1 pcalibre calibre2">The best way to learn the sockets interface is to study example code. <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007E5E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.20</span></a> shows the code for an echo client. After establishing a connection with the server, the client enters a loop that repeatedly reads a text line from standard input, sends the text line to the server, reads the echo line from the server, and prints the result to standard output. The loop terminates when <code id="P70004970270000000000000000469B3" data-uri="chapter11.xhtml#P70004970270000000000000000469B3" class="pcalibre1 calibre8 pcalibre">fgets</code> encounters EOF on standard input, either because the user typed Ctrl+D at the keyboard or because it has exhausted the text lines in a redirected input file.</p>
<p id="P70004970270000000000000000469B4" data-uri="chapter11.xhtml#P70004970270000000000000000469B4" class="pcalibre1 pcalibre calibre2">After the loop terminates, the client closes the descriptor. This results in an EOF notification being sent to the server, which it detects when it receives a return code of zero from its <code id="P70004970270000000000000000469B5" data-uri="chapter11.xhtml#P70004970270000000000000000469B5" class="pcalibre1 calibre8 pcalibre">rio_readlineb</code> function. After closing its descriptor, the client terminates. Since the client's kernel automatically closes all open descriptors when a process terminates, the <code id="P70004970270000000000000000469B6" data-uri="chapter11.xhtml#P70004970270000000000000000469B6" class="pcalibre1 calibre8 pcalibre">close</code> in line 24 is not necessary. However, it is good programming practice to explicitly close any descriptors that you have opened.</p>
<p id="P70004970270000000000000000469B7" data-uri="chapter11.xhtml#P70004970270000000000000000469B7" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007E72"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.21</span></a> shows the main routine for the echo server. After opening the listening descriptor, it enters an infinite loop. Each iteration waits for a connection request from a client, prints the domain name and port of the connected client, and then calls the <code id="P70004970270000000000000000469B8" data-uri="chapter11.xhtml#P70004970270000000000000000469B8" class="pcalibre1 calibre8 pcalibre">echo</code> function that services the client. After the echo routine returns,</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007E55" data-uri="chapter11.xhtml#P7000497027000000000000000007E55">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007E56" title="945" data-uri="chapter11.xhtml#P7000497027000000000000000007E56" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000469B9" data-uri="chapter11.xhtml#P70004970270000000000000000469B9" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000469BA" data-uri="chapter11.xhtml#P70004970270000000000000000469BA" class="calibre10 pcalibre pcalibre1">
1	int open_listenfd(char *port)
2	{
3		struct addrinfo hints, *listp, *p;
4		int listenfd, optval=1;
5	
6		/* Get a list of potential server addresses */
7		memset(&amp;hints, 0, sizeof(struct addrinfo));
8		hints.ai_socktype = SOCK_STREAM;				/* Accept connections */
9		hints.ai_flags = AI_PASSIVE	|		AI_ADDRCONFIG;	/* ... on any IP address */
10		hints.ai_flags |= AI_NUMERICSERV;				/* ... using port number */
11		Getaddrinfo(NULL, port, &amp;hints, &amp;listp);
12	
13		/* Walk the list for one that we can bind to */
14		for (p = listp; p; p = p-&gt;ai_next) {
15			/* Create a socket descriptor */
16			if ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0)
17				continue; /* Socket failed, try the next */
18	
19			/* Eliminates "Address already in use" error from bind */
20			Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
21					(const void *)&amp;optval , sizeof(int));
22	
23			/* Bind the descriptor to the address */
24			if (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == 0)
25				break; /* Success */
26			Close(listenfd); /* Bind failed, try the next */
27		}
28	
29		/* Clean up */
30		Freeaddrinfo(listp);
31		if (!p) /* No address worked */
32			return -1;
33	
34		/* Make it a listening socket ready to accept connection requests */
35		if (listen(listenfd, LISTENQ) &lt; 0) {
36			Close(listenfd);
37			return −1;
38		}
39		return listenfd;
40	}
</code></pre>
<figcaption id="P70004970270000000000000000469BB" data-uri="chapter11.xhtml#P70004970270000000000000000469BB" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000469BC" data-uri="chapter11.xhtml#P70004970270000000000000000469BC" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.19 </span><code id="P70004970270000000000000000469BD" data-uri="chapter11.xhtml#P70004970270000000000000000469BD" class="pcalibre1 calibre8 pcalibre">open_listenfd</code>: Helper function that opens and returns a listening descriptor.</h1></header>
<div class="caption pcalibre pcalibre1" id="P70004970270000000000000000469BE" data-uri="chapter11.xhtml#P70004970270000000000000000469BE"><p id="P70004970270000000000000000469BF" data-uri="chapter11.xhtml#P70004970270000000000000000469BF" class="pcalibre calibre3 pcalibre1">It is reentrant and protocol-independent.</p></div></figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007E5E" data-uri="chapter11.xhtml#P7000497027000000000000000007E5E">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007E5F" title="946" data-uri="chapter11.xhtml#P7000497027000000000000000007E5F" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000469C0" data-uri="chapter11.xhtml#P70004970270000000000000000469C0" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000469C1" data-uri="chapter11.xhtml#P70004970270000000000000000469C1" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	
3	int main(int argc, char **argv)
4	{
5		int clientfd;
6		char *host, *port, buf[MAXLINE];
7		rio_t rio;
8
9		if (argc != 3) {
10			fprintf(stderr, "usage: %s &lt;host&gt; &lt;port&gt;\n", argv[0]);
11			exit(0);
12		}
13		host = argv[1];
14		port = argv[2];
15	
16		clientfd = Open_clientfd(host, port);
17		Rio_readinitb(,&amp;rio, clientfd);
18	
19		while (Fgets(buf, MAXLINE, stdin) != NULL) {
20			Rio_writen(clientfd, buf, strlen(buf));
21			Rio_readlineb(&amp;rio, buf, MAXLINE);
22			Fputs(buf, stdout);
23		}
24		Close(clientfd);
25		exit(0);
26	}
</code></pre>
<figcaption id="P70004970270000000000000000469C2" data-uri="chapter11.xhtml#P70004970270000000000000000469C2" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000469C3" data-uri="chapter11.xhtml#P70004970270000000000000000469C3" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">11.20 </span>Echo client main routine.</h1></header>
</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P70004970270000000000000000469C4" data-uri="chapter11.xhtml#P70004970270000000000000000469C4">the main routine closes the connected descriptor. Once the client and server have closed their respective descriptors, the connection is terminated.</p>
<p id="P70004970270000000000000000469C5" data-uri="chapter11.xhtml#P70004970270000000000000000469C5" class="pcalibre1 pcalibre calibre2">The <code id="P70004970270000000000000000469C6" data-uri="chapter11.xhtml#P70004970270000000000000000469C6" class="pcalibre1 calibre8 pcalibre">clientaddr</code> variable in line 9 is a socket address structure that is passed to <code id="P70004970270000000000000000469C7" data-uri="chapter11.xhtml#P70004970270000000000000000469C7" class="pcalibre1 calibre8 pcalibre">accept</code>. Before <code id="P70004970270000000000000000469C8" data-uri="chapter11.xhtml#P70004970270000000000000000469C8" class="pcalibre1 calibre8 pcalibre">accept</code> returns, it fills in <code id="P70004970270000000000000000469C9" data-uri="chapter11.xhtml#P70004970270000000000000000469C9" class="pcalibre1 calibre8 pcalibre">clientaddr</code> with the socket address of the client on the other end of the connection. Notice how we declare <code id="P70004970270000000000000000469CA" data-uri="chapter11.xhtml#P70004970270000000000000000469CA" class="pcalibre1 calibre8 pcalibre">clientaddr</code> as type struct <code id="P70004970270000000000000000469CB" data-uri="chapter11.xhtml#P70004970270000000000000000469CB" class="pcalibre1 calibre8 pcalibre">sockaddr_storage</code> rather than struct <code id="P70004970270000000000000000469CC" data-uri="chapter11.xhtml#P70004970270000000000000000469CC" class="pcalibre1 calibre8 pcalibre">sockaddr_in</code>. By definition, the <code id="P70004970270000000000000000469CD" data-uri="chapter11.xhtml#P70004970270000000000000000469CD" class="pcalibre1 calibre8 pcalibre">sockaddr_storage</code> structure is large enough to hold any type of socket address, which keeps the code protocol-independent.</p>
<p id="P70004970270000000000000000469CE" data-uri="chapter11.xhtml#P70004970270000000000000000469CE" class="pcalibre1 pcalibre calibre2">Notice that our simple echo server can only handle one client at a time. A server of this type that iterates through clients, one at a time, is called an <i class="calibre5 pcalibre pcalibre1">iterative server</i>. In <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000008060.xhtml#P7000497027000000000000000008060"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">12</span></a>, we will learn how to build more sophisticated <i class="calibre5 pcalibre pcalibre1">concurrent servers</i> that can handle multiple clients simultaneously.</p>
<p id="P70004970270000000000000000469CF" data-uri="chapter11.xhtml#P70004970270000000000000000469CF" class="pcalibre1 pcalibre calibre2">Finally, <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P7000497027000000000000000007E78"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">11.22</span></a> shows the code for the <code id="P70004970270000000000000000469D0" data-uri="chapter11.xhtml#P70004970270000000000000000469D0" class="pcalibre1 calibre8 pcalibre">echo</code> routine, which repeatedly reads and writes lines of text until the <code id="P70004970270000000000000000469D1" data-uri="chapter11.xhtml#P70004970270000000000000000469D1" class="pcalibre1 calibre8 pcalibre">rio_readlineb</code> function encounters EOF in line 10.</p>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007E72" data-uri="chapter11.xhtml#P7000497027000000000000000007E72">
<span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007E73" title="947" data-uri="chapter11.xhtml#P7000497027000000000000000007E73" epub:type="pagebreak"></span>
<pre id="P70004970270000000000000000469D2" data-uri="chapter11.xhtml#P70004970270000000000000000469D2" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000469D3" data-uri="chapter11.xhtml#P70004970270000000000000000469D3" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	
3	void echo(int connfd);
4	
5	int main(int argc, char **argv)
6	{
7		int listenfd, connfd;
8		socklen_t clientlen;
9		struct sockaddr_storage clientaddr; /* Enough space for any address */
10		char client_hostname[MAXLINE], client_port[MAXLINE];
11	
12		if (argc != 2) {
13			fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]);
14			exit(0);
15		}
16	
17		listenfd = Open_listenfd(argv[1]);
18		while (1) {
19			clientlen = sizeof(struct sockaddr_storage);
20			connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);
21			Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, MAXLINE,
22				client_port, MAXLINE, 0);
23			printf("Connected to (%s, %s)\n", client_hostname, client_port);
24			echo(connfd);
25			Close(connfd);
26		}
27		exit(0);
28	}
</code></pre>
<figcaption id="P70004970270000000000000000469D4" data-uri="chapter11.xhtml#P70004970270000000000000000469D4" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000469D5" data-uri="chapter11.xhtml#P70004970270000000000000000469D5" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">11.21 </span>Iterative echo server main routine.</h1></header>
</figcaption>
</figure>
<figure class="pcalibre5 figure pcalibre" id="P7000497027000000000000000007E78" data-uri="chapter11.xhtml#P7000497027000000000000000007E78">
<pre id="P70004970270000000000000000469D6" data-uri="chapter11.xhtml#P70004970270000000000000000469D6" class="calibre9 pcalibre pcalibre1"><code id="P70004970270000000000000000469D7" data-uri="chapter11.xhtml#P70004970270000000000000000469D7" class="calibre10 pcalibre pcalibre1">
1	#include "csapp.h"
2	
3	void echo(int connfd)
4	{
5		size_t n;
6		char buf[MAXLINE];
7		rio_t rio; 8
9		Rio_readinitb(&amp;rio, connfd);
10		while((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
11			printf("server received %d bytes\n", (int)n);
12			Rio_writen(connfd, buf, n);
13		}
14	}
</code></pre>
<figcaption id="P70004970270000000000000000469D8" data-uri="chapter11.xhtml#P70004970270000000000000000469D8" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P70004970270000000000000000469D9" data-uri="chapter11.xhtml#P70004970270000000000000000469D9" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="pcalibre label pcalibre1">11.22 </span><code id="P70004970270000000000000000469DA" data-uri="chapter11.xhtml#P70004970270000000000000000469DA" class="pcalibre1 calibre8 pcalibre">echo</code> function that reads and echoes text lines.</h1></header>
</figcaption>
</figure>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000007E7E" data-uri="chapter11.xhtml#P7000497027000000000000000007E7E"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P70004970270000000000000000469DB" data-uri="chapter11.xhtml#P70004970270000000000000000469DB" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000007E80" title="948" data-uri="chapter11.xhtml#P7000497027000000000000000007E80" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>What does EOF on a connection mean?</h1></header>
<p id="P70004970270000000000000000469DC" data-uri="chapter11.xhtml#P70004970270000000000000000469DC" class="pcalibre calibre3 pcalibre1">The idea of EOF is often confusing to students, especially in the context of Internet connections. First, we need to understand that there is no such thing as an EOF character. Rather, EOF is a condition that is detected by the kernel. An application finds out about the EOF condition when it receives a zero return code from the read function. For disk files, EOF occurs when the current file position exceeds the file length. For Internet connections, EOF occurs when a process closes its end of the connection. The process at the other end of the connection detects the EOF when it attempts to read past the last byte in the stream.</p>
</aside>
</section>
</section></body></html>
