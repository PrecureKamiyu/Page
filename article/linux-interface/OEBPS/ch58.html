<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 58. Sockets: Fundamentals of TCP/IP Networks</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch57.html" title="Chapter 57. Sockets: UNIX Domain"/><link rel="next" href="ch59.html" title="Chapter 59. Sockets: Internet Domains"/></head><body><section class="chapter" title="Chapter 58. Sockets: Fundamentals of TCP/IP Networks" epub:type="chapter" id="sockets_colon_fundamentals_of_tcp_solidu"><div class="titlepage"><div><div><h2 class="title">Chapter 58. Sockets: Fundamentals of TCP/IP Networks</h2></div></div></div><p>This chapter provides an introduction to computer networking concepts and the TCP/IP
            networking protocols. An understanding of these topics is necessary to make effective
            use of Internet domain sockets, which are described in the next chapter.<a id="IDX-CHP-58-7464" class="indexterm"/></p><p>Starting in this chapter, we begin mentioning various <span class="emphasis"><em>Request for
                Comments</em></span> (RFC) documents. Each of the networking protocols discussed in
            this book is formally described in an RFC. We provide further information about RFCs, as
            well as a list of RFCs of particular relevance to the material covered in this book, in
            Section 58.7.</p><div class="sect1" title="Internets"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="internets">Internets</h2></div></div></div><p>An <span class="emphasis"><em>internetwork</em></span> or, more commonly,
                    <span class="emphasis"><em>internet</em></span> (with a lowercase <span class="emphasis"><em>i</em></span>),
                connects different computer networks, allowing hosts on all of the networks to
                communicate with one another. In other words, an internet is a network of computer
                networks. The term <span class="emphasis"><em>subnetwork</em></span>, or <span class="emphasis"><em>subnet</em></span>,
                is used to refer to one of the networks composing an internet. An internet aims to
                hide the details of different physical networks in order to present a unified
                network architecture to all hosts on the connected networks. This means, for
                example, that a single address format is used to identify all hosts in the
                    internet.<a id="IDX-CHP-58-7465" class="indexterm"/><a id="IDX-CHP-58-7466" class="indexterm"/><a id="IDX-CHP-58-7467" class="indexterm"/><a id="IDX-CHP-58-7468" class="indexterm"/></p><p>Although various internetworking protocols have been devised, TCP/IP has become
                the dominant protocol suite, supplanting even the proprietary networking protocols
                that were formerly common on local and wide area networks. The term
                    <span class="emphasis"><em>Internet</em></span> (with an uppercase <span class="emphasis"><em>I</em></span>) is used
                to refer to the TCP/IP internet that connects millions of computers globally.</p><p>The first widespread implementation of TCP/IP appeared with 4.2BSD in 1983.
                Several implementations of TCP/IP are derived directly from the BSD code; other
                implementations, including the Linux implementation, are written from scratch,
                taking the operation of the BSD code as a reference standard defining the operation
                of TCP/IP.<a id="IDX-CHP-58-7469" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>TCP/IP grew out of a project sponsored by the US Department of Defense
                    Advanced Research Projects Agency (ARPA, later DARPA, with the
                        <span class="emphasis"><em>D</em></span> for Defense) to devise a computer networking
                    architecture to be used in the ARPANET, an early wide area network. During the
                    1970s, a new family of protocols was designed for the ARPANET. Accurately, these
                    protocols are known as the DARPA Internet protocol suite, but more usually they
                    are known as the TCP/IP protocol suite, or simply TCP/IP.<a id="IDX-CHP-58-7470" class="indexterm"/></p><p>The web page <a class="ulink" href="http://www.isoc.org/internet/history/brief.shtml" target="_top">http://www.isoc.org/internet/history/brief.shtml</a>
                    provides a brief history of the Internet and TCP/IP.</p></div><p><a class="xref" href="ch58.html#an_internet_using_a_router_to_connect_tw" title="Figure 58-1. An internet using a router to connect two networks">Figure 58-1</a> shows a simple
                internet. In this diagram, the machine <code class="literal">tekapo</code> is
                an example of a <span class="emphasis"><em>router</em></span>, a computer whose function is to connect
                one subnetwork to another, transferring data between them. As well as understanding
                the internet protocol being used, a router must also understand the (possibly)
                different data-link-layer protocols used on each of the subnets that it
                    connects.<a id="IDX-CHP-58-7471" class="indexterm"/></p><p>A router has multiple network interfaces, one for each of the subnets to which it
                is connected. The more general term <span class="emphasis"><em>multihomed host</em></span> is used for
                any host—not necessarily a router—with multiple network interfaces. (Another way of
                describing a router is to say that it is a multihomed host that forwards packets
                from one subnet to another.) A multihomed host has a different network address for
                each of its interfaces (i.e., a different address on each of the subnets to which it
                is connected).<a id="IDX-CHP-58-7472" class="indexterm"/></p><div class="figure"><a id="an_internet_using_a_router_to_connect_tw"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject58_d1e148141"/><img src="figs/web/58-1_SOCKNW-internet-scale90.png.jpg" alt="An internet using a router to connect two networks"/></div></div><div class="figure-title">Figure 58-1. An internet using a router to connect two networks</div></div></div><div class="sect1" title="Networking Protocols and Layers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="networking_protocols_and_layers">Networking Protocols and Layers</h2></div></div></div><p>A <span class="emphasis"><em>networking protocol</em></span> is a set of rules defining how
                information is to be transmitted across a network. Networking protocols are
                generally organized as a series of <span class="emphasis"><em>layers</em></span>, with each layer
                building on the layer below it to add features that are made available to higher
                    layers.<a id="IDX-CHP-58-7473" class="indexterm"/><a id="IDX-CHP-58-7474" class="indexterm"/><a id="IDX-CHP-58-7475" class="indexterm"/><a id="IDX-CHP-58-7476" class="indexterm"/><a id="IDX-CHP-58-7477" class="indexterm"/><a id="IDX-CHP-58-7478" class="indexterm"/><a id="IDX-CHP-58-7479" class="indexterm"/><a id="IDX-CHP-58-7480" class="indexterm"/><a id="IDX-CHP-58-7481" class="indexterm"/><a id="IDX-CHP-58-7482" class="indexterm"/><a id="IDX-CHP-58-7483" class="indexterm"/><a id="IDX-CHP-58-7484" class="indexterm"/><a id="IDX-CHP-58-7485" class="indexterm"/><a id="IDX-CHP-58-7486" class="indexterm"/><a id="IDX-CHP-58-7487" class="indexterm"/><a id="IDX-CHP-58-7488" class="indexterm"/><a id="IDX-CHP-58-7489" class="indexterm"/><a id="IDX-CHP-58-7490" class="indexterm"/></p><p>The <span class="emphasis"><em>TCP/IP protocol suite</em></span> is a layered networking protocol
                    (<a class="xref" href="ch58.html#protocols_in_the_tcp_solidus_ip_suite" title="Figure 58-2. Protocols in the TCP/IP suite">Figure 58-2</a>). It includes the
                    <span class="emphasis"><em>Internet Protocol</em></span> (IP) and various protocols layered above
                it. (The code that implements these various layers is commonly referred to as a
                    <span class="emphasis"><em>protocol stack</em></span>.) The name TCP/IP derives from the fact that
                the <span class="emphasis"><em>Transmission Control Protocol</em></span> (TCP) is the most heavily
                used transport-layer protocol.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>We have omitted a range of other TCP/IP protocols from <a class="xref" href="ch58.html#protocols_in_the_tcp_solidus_ip_suite" title="Figure 58-2. Protocols in the TCP/IP suite">Figure 58-2</a> because they are not
                    relevant to this chapter. The <span class="emphasis"><em>Address Resolution Protocol</em></span>
                    (ARP) is concerned with mapping Internet addresses to hardware (e.g., Ethernet)
                    addresses. The <span class="emphasis"><em>Internet Control Message Protocol</em></span> (ICMP) is
                    used to convey error and control information across the network. (ICMP is used
                    by the <span class="emphasis"><em>ping</em></span> program, which is frequently employed to check
                    whether a particular host is alive and visible on a TCP/IP network, and by
                        <span class="emphasis"><em>traceroute</em></span>, which traces the path of an IP packet
                    through the network.) The <span class="emphasis"><em>Internet Group Management
                        Protocol</em></span> (IGMP) is used by hosts and routers that support
                    multicasting of IP datagrams.</p></div><div class="figure"><a id="protocols_in_the_tcp_solidus_ip_suite"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject58_d1e148271"/><img src="figs/web/58-2_SOCKNW-IP-protocols.png.jpg" alt="Protocols in the TCP/IP suite"/></div></div><div class="figure-title">Figure 58-2. Protocols in the TCP/IP suite</div></div><p>One of the notions that lends great power and flexibility to protocol layering is
                    <span class="emphasis"><em>transparency</em></span>—each protocol layer shields higher layers from
                the operation and complexity of lower layers. Thus, for example, an application
                making use of TCP only needs to use the standard sockets API and to know that it is
                employing a reliable, byte-stream transport service. It doesn’t need to understand
                the details of the operation of TCP. (When we look at socket options in <a class="xref" href="ch61.html#socket_options" title="Socket Options">Socket Options</a>, we’ll see that this doesn’t always strictly hold
                true; occasionally, an application does need to know some of the details of the
                operation of the underlying transport protocol.) Nor does the application need to
                know the details of the operation of IP or of the data-link layer. From the point of
                view of the applications, it is as though they are communicating directly with each
                other via the sockets API, as shown in <a class="xref" href="ch58.html#layered_communication_via_the_tcp_solidu" title="Figure 58-3. Layered communication via the TCP/IP protocols">Figure 58-3</a>, where the dashed
                horizontal lines represent the virtual communication paths between corresponding
                application, TCP, and IP entities on the two hosts.<a id="IDX-CHP-58-7491" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="encapsulation"/></div></div></div><div class="sect3" title="Encapsulation"><div class="titlepage"><div><div><h4 class="title" id="encapsulation-id1">Encapsulation</h4></div></div></div><p>Encapsulation is an important principle of a layered networking protocol.
                            <a class="xref" href="ch58.html#encapsulation_within_the_tcp_solidus_ip" title="Figure 58-4. Encapsulation within the TCP/IP protocol layers">Figure 58-4</a> shows an
                        example of encapsulation in the TCP/IP protocol layers. The key idea of
                        encapsulation is that the information (e.g., application data, a TCP
                        segment, or an IP datagram) passed from a higher layer to a lower layer is
                        treated as opaque data by the lower layer. In other words, the lower layer
                        makes no attempt to interpret information sent from the upper layer, but
                        merely places that information inside whatever type of packet is used in the
                        lower layer and adds its own layer-specific header before passing the packet
                        down to the next lower layer. When data is passed up from a lower layer to a
                        higher layer, a converse unpacking process takes place.<a id="IDX-CHP-58-7492" class="indexterm"/><a id="IDX-CHP-58-7493" class="indexterm"/><a id="IDX-CHP-58-7494" class="indexterm"/><a id="IDX-CHP-58-7495" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>We don’t show it in <a class="xref" href="ch58.html#encapsulation_within_the_tcp_solidus_ip" title="Figure 58-4. Encapsulation within the TCP/IP protocol layers">Figure 58-4</a>, but the concept
                            of encapsulation also extends down into the data-link layer, where IP
                            datagrams are encapsulated inside network frames. Encapsulation may also
                            extend up into the application layer, where the application may perform
                            its own packaging of data.</p></div></div></div></div><div class="sect1" title="The Data-Link Layer"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_data-link_layer">The Data-Link Layer</h2></div></div></div><p>The lowest layer in <a class="xref" href="ch58.html#protocols_in_the_tcp_solidus_ip_suite" title="Figure 58-2. Protocols in the TCP/IP suite">Figure 58-2</a> is the
                    <span class="emphasis"><em>data-link layer</em></span>, which consists of the device driver and
                the hardware interface (network card) to the underlying physical medium (e.g., a
                telephone line, a coaxial cable, or a fiber-optic cable). The data-link layer is
                concerned with transferring data across a physical link in a network.</p><p>To transfer data, the data-link layer encapsulates datagrams from the network
                layer into units called <span class="emphasis"><em>frames</em></span>. In addition to the data to be
                transmitted, each frame includes a header containing, for example, the destination
                address and frame size. The data-link layer transmits the frames across the physical
                link and handles acknowledgements from the receiver. (Not all data-link layers use
                acknowledgements.) This layer may perform error detection, retransmission, and flow
                control. Some data-link layers also split large network packets into multiple frames
                and reassemble them at the receiver.</p><p>From an application-programming point of view, we can generally ignore the
                data-link layer, since all communication details are handled in the driver and
                hardware.</p><p>One characteristic of the data-link layer that is important for our discussion of
                IP is the <span class="emphasis"><em>maximum transmission unit</em></span> (MTU). A data-link layer’s
                MTU is the upper limit that the layer places on the size of a frame. Different
                data-link layers have different MTUs.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The command <span class="emphasis"><em>netstat -i</em></span> displays a list of the system’s
                    network interfaces, along with their MTUs.</p></div><div class="figure"><a id="layered_communication_via_the_tcp_solidu"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject58_d1e148347"/><img src="figs/web/58-3_SOCKNW-IP-layers.png.jpg" alt="Layered communication via the TCP/IP protocols"/></div></div><div class="figure-title">Figure 58-3. Layered communication via the TCP/IP protocols</div></div><div class="figure"><a id="encapsulation_within_the_tcp_solidus_ip"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject58_d1e148355"/><img src="figs/web/58-4_SOCKNW-encapsulation.png.jpg" alt="Encapsulation within the TCP/IP protocol layers"/></div></div><div class="figure-title">Figure 58-4. Encapsulation within the TCP/IP protocol layers</div></div></div><div class="sect1" title="The Network Layer: IP"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_network_layer_colon_ip">The Network Layer: IP</h2></div></div></div><p>Above the data-link layer is the <span class="emphasis"><em>network layer</em></span>, which is
                concerned with delivering packets (data) from the source host to the destination
                host. This layer performs a variety of tasks, including:<a id="IDX-CHP-58-7496" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>breaking data into fragments small enough for transmission via the
                        data-link layer (if necessary);</p></li><li class="listitem"><p>routing data across the internet; and</p></li><li class="listitem"><p>providing services to the transport layer.</p></li></ul></div><p>In the TCP/IP protocol suite, the principal protocol in the network layer is IP.
                The version of IP that appeared in the 4.2BSD implementation was IP version 4
                (IPv4). In the early 1990s, a revised version of IP was devised: IP version 6
                (IPv6). The most notable difference between the two versions is that IPv4 identifies
                subnets and hosts using 32-bit addresses, while IPv6 uses 128-bit addresses, thus
                providing a much larger range of addresses to be assigned to hosts. Although IPv4 is
                still the predominant version of IP in use on the Internet, in coming years, it
                should be supplanted by IPv6. Both IPv4 and IPv6 support the higher UDP and TCP
                transport-layer protocols (as well as many other protocols).<a id="IDX-CHP-58-7497" class="indexterm"/><a id="IDX-CHP-58-7498" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although a 32-bit address space theoretically permits billions of IPv4 network
                    addresses to be assigned, the manner in which addresses were structured and
                    allocated meant that the practical number of available addresses was far lower.
                    The possible exhaustion of the IPv4 address space was one of the primary
                    motivations for the creation of IPv6.</p><p>A short history of IPv6 can be found at <a class="ulink" href="http://www.laynetworks.com/IPv6.htm" target="_top">http://www.laynetworks.com/IPv6.htm</a>.</p><p>The existence of IPv4 and IPv6 begs the question, “What about IPv5?” There
                    never was an IPv5 as such. Each IP datagram header includes a 4-bit version
                    number field (thus, IPv4 datagrams always have the number 4 in this field), and
                    the version number 5 was assigned to an experimental protocol,
                        <span class="emphasis"><em>Internet Stream Protocol</em></span>. (Version 2 of this protocol,
                    abbreviated as ST-II, is described in RFC 1819.) Initially conceived in the
                    1970s, this connection-oriented protocol was designed to support voice and video
                    transmission, and distributed simulation. Since the IP datagram version number 5
                    was already assigned, the successor to IPv4 was assigned the version number
                        6.<a id="IDX-CHP-58-7499" class="indexterm"/><a id="IDX-CHP-58-7500" class="indexterm"/><a id="IDX-CHP-58-7501" class="indexterm"/></p></div><p><a class="xref" href="ch58.html#protocols_in_the_tcp_solidus_ip_suite" title="Figure 58-2. Protocols in the TCP/IP suite">Figure 58-2</a> shows a
                    <span class="emphasis"><em>raw</em></span> socket type (<code class="literal">SOCK_RAW</code>), which allows an application to communicate directly with
                the IP layer. We don’t describe the use of raw sockets, since most applications
                employ sockets over one of the transport-layer protocols (TCP or UDP). Raw sockets
                are described in <a class="xref" href="ch28.html" title="Chapter 28. Process Creation and Program Execution in More Detail">Chapter 28</a> of
                [Stevens et al., 2004]. One instructive example of the use of raw sockets is the
                    <span class="emphasis"><em>sendip</em></span> program (<a class="ulink" href="http://www.earth.li/projectpurple/progs/sendip.html" target="_top">http://www.earth.li/projectpurple/progs/sendip.html</a>), which is a
                command-line-driven tool that allows the construction and transmission of IP
                datagrams with arbitrary contents (including options to construct UDP datagrams and
                TCP segments).<a id="IDX-CHP-58-7502" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="ip_transmits_datagrams"/></div></div></div><div class="sect3" title="IP transmits datagrams"><div class="titlepage"><div><div><h4 class="title" id="ip_transmits_datagrams-id1">IP transmits datagrams</h4></div></div></div><p>IP transmits data in the form of datagrams (packets). Each datagram sent
                        between two hosts travels independently across the network, possibly taking
                        a different route. An IP datagram includes a header, which ranges in size
                        from 20 to 60 bytes. The header contains the address of the target host, so
                        that the datagram can be routed through the network to its destination, and
                        also includes the originating address of the packet, so that the receiving
                        host knows the origin of the datagram.<a id="IDX-CHP-58-7503" class="indexterm"/><a id="IDX-CHP-58-7504" class="indexterm"/><a id="IDX-CHP-58-7505" class="indexterm"/><a id="IDX-CHP-58-7506" class="indexterm"/><a id="IDX-CHP-58-7507" class="indexterm"/><a id="IDX-CHP-58-7508" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>It is possible for a sending host to spoof the originating address of
                            a packet, and this forms the basis of a TCP denial-of-service attack
                            known as SYN-flooding. [Lemon, 2002] describes the details of this
                            attack and the measures used by modern TCP implementations to deal with
                                it.<a id="IDX-CHP-58-7509" class="indexterm"/></p></div><p>An IP implementation may place an upper limit on the size of datagrams
                        that it supports. All IP implementations must permit datagrams at least as
                        large as the limit specified by IP’s <span class="emphasis"><em>minimum reassembly buffer
                            size</em></span>. In IPv4, this limit is 576 bytes; in IPv6, it is 1500
                            bytes.<a id="IDX-CHP-58-7510" class="indexterm"/></p></div><div class="sect3" title="IP is connectionless and unreliable"><div class="titlepage"><div><div><h4 class="title" id="ip_is_connectionless_and_unreliable">IP is connectionless and unreliable</h4></div></div></div><p>IP is described as a <span class="emphasis"><em>connectionless</em></span> protocol, since
                        it doesn’t provide the notion of a virtual circuit connecting two hosts. IP
                        is also an <span class="emphasis"><em>unreliable</em></span> protocol: it makes a “best
                        effort” to transmit datagrams from the sender to the receiver, but doesn’t
                        guarantee that packets will arrive in the order they were transmitted, that
                        they won’t be duplicated, or even that they will arrive at all. Nor does IP
                        provide error recovery (packets with header errors are silently discarded).
                        Reliability must be provided either by using a reliable transport-layer
                        protocol (e.g., TCP) or within the application itself.<a id="IDX-CHP-58-7511" class="indexterm"/><a id="IDX-CHP-58-7512" class="indexterm"/><a id="IDX-CHP-58-7513" class="indexterm"/><a id="IDX-CHP-58-7514" class="indexterm"/><a id="IDX-CHP-58-7515" class="indexterm"/><a id="IDX-CHP-58-7516" class="indexterm"/><a id="IDX-CHP-58-7517" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>IPv4 provides a checksum for the IP header, which allows the detection
                            of errors in the header, but doesn’t provide any error detection for the
                            data transmitted within the packet. IPv6 doesn’t provide a checksum in
                            the IP header, relying on higher-layer protocols to provide error
                            checking and reliability as required. (UDP checksums are optional with
                            IPv4, but generally enabled; UDP checksums are mandatory with IPv6. TCP
                            checksums are mandatory with both IPv4 and IPv6.)<a id="IDX-CHP-58-7518" class="indexterm"/></p><p>Duplication of IP datagrams may occur because of techniques employed
                            by some data-link layers to ensure reliability or when IP datagrams are
                            tunneled through some non-TCP/IP network that employs
                            retransmission.</p></div></div><div class="sect3" title="IP may fragment datagrams"><div class="titlepage"><div><div><h4 class="title" id="ip_may_fragment_datagrams">IP may fragment datagrams</h4></div></div></div><p>IPv4 datagrams can be up to 65,535 bytes. By default, IPv6 allows
                        datagrams of up to 65,575 bytes (40 bytes for the header, 65,535 bytes for
                        data), and provides an option for larger datagrams (so-called
                            <span class="emphasis"><em>jumbograms</em></span>).</p><p>We noted earlier that most data-link layers impose an upper limit (the
                        MTU) on the size of data frames. For example, this upper limit is 1500 bytes
                        on the commonly used Ethernet network architecture (i.e., much smaller than
                        the maximum size of an IP datagram). IP also defines the notion of the
                            <span class="emphasis"><em>path MTU</em></span>. This is the minimum MTU on all of the
                        data-link layers traversed on the route from the source to the destination.
                        (In practice, the Ethernet MTU is often the minimum MTU in a
                            path.)<a id="IDX-CHP-58-7519" class="indexterm"/></p><p>When an IP datagram is larger than the MTU, IP fragments (breaks up) the
                        datagram into suitably sized units for transmission across the network.
                        These fragments are then reassembled at the final destination to re-create
                        the original datagram.</p><p>(Each IP fragment is itself an IP datagram that contains an offset field
                        giving the location of that fragment within the original datagram.)</p><p>IP fragmentation occurs transparently to higher protocol layers, but
                        nevertheless is generally considered undesirable ([Kent &amp; Mogul,
                        1987]). The problem is that, because IP doesn’t perform retransmission, and
                        a datagram can be reassembled at the destination only if all fragments
                        arrive, the entire datagram is unusable if any fragment is lost or contains
                        transmission errors. In some cases, this can lead to significant rates of
                        data loss (for higher protocol layers that don’t perform retransmission,
                        such as UDP) or degraded transfer rates (for higher protocol layers that do
                        perform retransmission, such as TCP). Modern TCP implementations employ
                        algorithms (<span class="emphasis"><em>path MTU discovery</em></span>) to determine the MTU of
                        a path between hosts, and accordingly break up the data they pass to IP, so
                        that IP is not asked to transmit datagrams that exceed this size. UDP
                        provides no such mechanism, and we consider how UDP-based applications can
                        deal with the possibility of IP fragmentation in <a class="xref" href="ch58.html#user_datagram_protocol_open_parenthesis" title="User Datagram Protocol (UDP)">User Datagram Protocol (UDP)</a>.</p></div></div></div><div class="sect1" title="IP Addresses"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ip_addresses">IP Addresses</h2></div></div></div><p>An IP address consists of two parts: a network ID, which specifies the network on
                which a host resides, and a host ID, which identifies the host within that
                    network.<a id="IDX-CHP-58-7520" class="indexterm"/><a id="IDX-CHP-58-7521" class="indexterm"/><a id="IDX-CHP-58-7522" class="indexterm"/><a id="IDX-CHP-58-7523" class="indexterm"/><a id="IDX-CHP-58-7524" class="indexterm"/><a id="IDX-CHP-58-7525" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="ipv4_addresses"/></div></div></div><div class="sect3" title="IPv4 addresses"><div class="titlepage"><div><div><h4 class="title" id="ipv4_addresses-id1">IPv4 addresses</h4></div></div></div><p>An IPv4 address consists of 32 bits (<a class="xref" href="ch58.html#an_ipv4_network_address_and_correspondin" title="Figure 58-5. An IPv4 network address and corresponding network mask">Figure 58-5</a>). When expressed in
                        human-readable form, these addresses are normally written in
                            <span class="emphasis"><em>dotted-decimal notation</em></span>, with the 4 bytes of the
                        address being written as decimal numbers separated by dots, as in
                        204.152.189.116.</p><div class="figure"><a id="an_ipv4_network_address_and_correspondin"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject58_d1e148603"/><img src="figs/web/58-5_SOCKNW-IPv4-address-scale90.png" alt="An IPv4 network address and corresponding network mask"/></div></div><div class="figure-title">Figure 58-5. An IPv4 network address and corresponding network mask</div></div><p>When an organization applies for a range of IPv4 addresses for its hosts,
                        it receives a 32-bit network address and a corresponding 32-bit
                            <span class="emphasis"><em>network mask</em></span>. In binary form, this mask consists of
                        a sequence of 1s in the leftmost bits, followed by a sequence of 0s to fill
                        out the remainder of the mask. The 1s indicate which part of the address
                        contains the assigned network ID, while the 0s indicate which part of the
                        address is available to the organization to assign as unique host IDs on its
                        network. The size of the network ID part of the mask is determined when the
                        address is assigned. Since the network ID component always occupies the
                        leftmost part of the mask, the following notation is sufficient to specify
                        the range of assigned addresses:<a id="IDX-CHP-58-7526" class="indexterm"/></p><a id="I_programlisting58_d1e148616"/><pre class="programlisting">204.152.189.0/24</pre><p>The <code class="literal">/24</code> indicates that the network ID
                        part of the assigned address consists of the leftmost 24 bits, with the
                        remaining 8 bits specifying the host ID. Alternatively, we could say that
                        the network mask in this case is <code class="literal">255.255.255.0</code> in dotted-decimal notation.</p><p>An organization holding this address can assign 254 unique Internet
                        addresses to its computers—<code class="literal">204.152.189.1</code>
                        through <code class="literal">204.152.189.254</code>. Two addresses
                        can’t be assigned. One of these is the address whose host ID is all 0 bits,
                        which is used to identify the network itself. The other is the address whose
                        host ID is all 1 bits—<code class="literal">204.152.189.255</code> in
                        this example—which is the <span class="emphasis"><em>subnet broadcast
                            address</em></span>.<a id="IDX-CHP-58-7527" class="indexterm"/></p><p>Certain IPv4 addresses have special meanings. The special address <code class="literal">127.0.0.1</code> is normally defined as the
                            <span class="emphasis"><em>loopback address</em></span>, and is conventionally assigned
                        the hostname <code class="literal">localhost</code>. (Any address on
                        the network <code class="literal">127.0.0.0/8</code> can be designated
                        as the IPv4 loopback address, but <code class="literal">127.0.0.1</code> is the usual choice.) A datagram sent to this
                        address never actually reaches the network, but instead automatically loops
                        back to become input to the sending host. Using this address is convenient
                        for testing client and server programs on the same host. For use in a C
                        program, the integer constant <code class="literal">INADDR_LOOPBACK</code> is defined for this address.<a id="IDX-CHP-58-7528" class="indexterm"/><a id="IDX-CHP-58-7529" class="indexterm"/></p><p>The constant <code class="literal">INADDR_ANY</code> is the
                        so-called IPv4 <span class="emphasis"><em>wildcard address</em></span>. The wildcard IP
                        address is useful for applications that bind Internet domain sockets on
                        multihomed hosts. If an application on a multihomed host binds a socket to
                        just one of its host’s IP addresses, then that socket can receive only UDP
                        datagrams or TCP connection requests sent to that IP address. However, we
                        normally want an application on a multihomed host to be able to receive
                        datagrams or connection requests that specify any of the host’s IP
                        addresses, and binding the socket to the wildcard IP address makes this
                        possible. SUSv3 doesn’t specify any particular value for <code class="literal">INADDR_ANY</code>, but most implementations define it
                        as <code class="literal">0.0.0.0</code> (all zeros).<a id="IDX-CHP-58-7530" class="indexterm"/><a id="IDX-CHP-58-7531" class="indexterm"/></p><p>Typically, IPv4 addresses are <span class="emphasis"><em>subnetted</em></span>. Subnetting
                        divides the host ID part of an IPv4 address into two parts: a subnet ID and
                        a host ID (<a class="xref" href="ch58.html#ipv4_subnetting" title="Figure 58-6. IPv4 subnetting">Figure 58-6</a>). (The choice of how the bits
                        of the host ID are divided is made by the local network administrator.) The
                        rationale for subnetting is that an organization often doesn’t attach all of
                        its hosts to a single network. Instead, the organization may operate a set
                        of subnetworks (an “internal internetwork”), with each subnetwork being
                        identified by the combination of the network ID plus the subnet ID. This
                        combination is usually referred to as the <span class="emphasis"><em>extended network
                            ID</em></span>. Within a subnet, the subnet mask serves the same role as
                        described earlier for the network mask, and we can use a similar notation to
                        indicate the range of addresses assigned to a particular subnet.<a id="IDX-CHP-58-7532" class="indexterm"/><a id="IDX-CHP-58-7533" class="indexterm"/></p><p>For example, suppose that our assigned network ID is <code class="literal">204.152.189.0/24</code>, and we choose to subnet this
                        address range by splitting the 8 bits of the host ID into a 4-bit subnet ID
                        and a 4-bit host ID. Under this scheme, the subnet mask would consist of 28
                        leading ones, followed by 4 zeros, and the subnet with the ID of 1 would be
                        designated as <code class="literal">204.152.189.16/28</code>.</p><div class="figure"><a id="ipv4_subnetting"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject58_d1e148722"/><img src="figs/web/58-6_SOCKNW-IPv4-address-subnet.png.jpg" alt="IPv4 subnetting"/></div></div><div class="figure-title">Figure 58-6. IPv4 subnetting</div></div></div><div class="sect3" title="IPv6 addresses"><div class="titlepage"><div><div><h4 class="title" id="ipv6_addresses">IPv6 addresses</h4></div></div></div><p>The principles of IPv6 addresses are similar to IPv4 addresses. The key
                        difference is that IPv6 addresses consist of 128 bits, and the first few
                        bits of the address are a <span class="emphasis"><em>format prefix</em></span>, indicating the
                        address type. (We won’t go into the details of these address types; see
                            <a class="xref" href="apa.html" title="Appendix A. Tracing System Calls">Appendix A</a> of [Stevens et al., 2004] and RFC
                        3513 for details.)<a id="IDX-CHP-58-7534" class="indexterm"/></p><p>IPv6 addresses are typically written as a series of 16-bit hexadecimal
                        numbers separated by colons, as in the following:</p><a id="I_programlisting58_d1e148744"/><pre class="programlisting">F000:0:0:0:0:0:A:1</pre><p>IPv6 addresses often include a sequence of zeros and, as a notational
                        convenience, two colons (<code class="literal">::</code>) can be
                        employed to indicate such a sequence. Thus, the above address can be
                        rewritten as:</p><a id="I_programlisting58_d1e148751"/><pre class="programlisting">F000::A:1</pre><p>Only one instance of the double-colon notation can appear in an IPv6
                        address; more than one instance would be ambiguous.</p><p>IPv6 also provides equivalents of the IPv4’s loopback address (127 zeros,
                        followed by a one, thus ::1) and wildcard address (all zeros, written as
                        either 0::0 or ::).<a id="IDX-CHP-58-7535" class="indexterm"/><a id="IDX-CHP-58-7536" class="indexterm"/></p><p>In order to allow IPv6 applications to communicate with hosts supporting
                        only IPv4, IPv6 provides so-called <span class="emphasis"><em>IPv4-mapped IPv6
                            addresses</em></span>. The format of these addresses is shown in <a class="xref" href="ch58.html#format_of_an_ipv4-mapped_ipv6_address" title="Figure 58-7. Format of an IPv4-mapped IPv6 address">Figure 58-7</a>.</p><div class="figure"><a id="format_of_an_ipv4-mapped_ipv6_address"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject58_d1e148777"/><img src="figs/web/58-7_SOCKNW-IPv4-mapped-IPv6-scale90.png.jpg" alt="Format of an IPv4-mapped IPv6 address"/></div></div><div class="figure-title">Figure 58-7. Format of an IPv4-mapped IPv6 address</div></div><p>When writing an IPv4-mapped IPv6 address, the IPv4 part of the address
                        (i.e., the last 4 bytes) is written in IPv4 dotted-decimal notation. Thus,
                        the IPv4-mapped IPv6 address equivalent to <code class="literal">204.152.189.116</code> is <code class="literal">::FFFF:204.152.189.116</code>.<a id="IDX-CHP-58-7537" class="indexterm"/></p></div></div></div><div class="sect1" title="The Transport Layer"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_transport_layer">The Transport Layer</h2></div></div></div><p>There are two widely used transport-layer protocols in the TCP/IP suite:<a id="IDX-CHP-58-7538" class="indexterm"/><a id="IDX-CHP-58-7539" class="indexterm"/><a id="IDX-CHP-58-7540" class="indexterm"/><a id="IDX-CHP-58-7541" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>User Datagram Protocol</em></span> (UDP) is the protocol used for
                        datagram sockets.</p></li><li class="listitem"><p><span class="emphasis"><em>Transmission Control Protocol</em></span> (TCP) is the protocol
                        used for stream sockets.</p></li></ul></div><p>Before considering these protocols, we first need to describe port numbers, a
                concept used by both protocols.</p><div class="sect2" title="Port Numbers"><div class="titlepage"><div><div><h3 class="title" id="port_numbers">Port Numbers</h3></div></div></div><p>The task of the transport protocol is to provide an end-to-end communication
                    service to applications residing on different hosts (or sometimes on the same
                    host). In order to do this, the transport layer requires a method of
                    differentiating the applications on a host. In TCP and UDP, this differentiation
                    is provided by a 16-bit <span class="emphasis"><em>port number</em></span>.<a id="IDX-CHP-58-7542" class="indexterm"/><a id="IDX-CHP-58-7543" class="indexterm"/></p><div class="sect3" title="Well-known, registered, and privileged ports"><div class="titlepage"><div><div><h4 class="title" id="well-known_comma_registered_comma_and_pr">Well-known, registered, and privileged ports</h4></div></div></div><p>Some <span class="emphasis"><em>well-known port numbers</em></span> are permanently assigned
                        to specific applications (also known as <span class="emphasis"><em>services</em></span>). For
                        example, the <span class="emphasis"><em>ssh</em></span> (secure shell) daemon uses the
                        well-known port 22, and HTTP (the protocol used for communication between
                        web servers and browsers) uses the well-known port 80. Well-known ports are
                        assigned numbers in the range 0 to 1023 by a central authority, the Internet
                        Assigned Numbers Authority (IANA, <a class="ulink" href="http://www.iana.org/" target="_top">http://www.iana.org/</a>).
                        Assignment of a well-known port number is contingent on an approved network
                        specification (typically in the form of an RFC).<a id="IDX-CHP-58-7544" class="indexterm"/><a id="IDX-CHP-58-7545" class="indexterm"/><a id="IDX-CHP-58-7546" class="indexterm"/></p><p>IANA also records <span class="emphasis"><em>registered ports</em></span>, which are
                        allocated to application developers on a less stringent basis (which also
                        means that an implementation doesn’t need to guarantee the availability of
                        these ports for their registered purpose). The range of IANA registered
                        ports is 1024 to 41951. (Not all port numbers in this range are
                        registered.)</p><p>The up-to-date list of IANA well-known and registered port assignments can
                        be obtained online at <a class="ulink" href="http://www.iana.org/assignments/port-numbers" target="_top">http://www.iana.org/assignments/port-numbers</a>.</p><p>In most TCP/IP implementations (including Linux), the port numbers in the
                        range 0 to 1023 are also <span class="emphasis"><em>privileged</em></span>, meaning that only
                        privileged (<code class="literal">CAP_NET_BIND_SERVICE</code>)
                        processes may bind to these ports. This prevents a normal user from
                        implementing a malicious application that, for example, spoofs as
                            <span class="emphasis"><em>ssh</em></span> in order to obtain passwords. (Sometimes,
                        privileged ports are referred to as <span class="emphasis"><em>reserved</em></span>
                        ports.)</p><p>Although TCP and UDP ports with the same number are distinct entities, the
                        same well-known port number is usually assigned to a service under both TCP
                        and UDP, even if, as is often the case, that service is available under only
                        one of these protocols. This convention avoids confusion of port numbers
                        across the two protocols.</p></div><div class="sect3" title="Ephemeral ports"><div class="titlepage"><div><div><h4 class="title" id="ephemeral_ports">Ephemeral ports</h4></div></div></div><p>If an application doesn’t select a particular port (i.e., in sockets
                        terminology, it doesn’t <span class="emphasis"><em>bind()</em></span> its socket to a
                        particular port), then TCP and UDP assign a unique <span class="emphasis"><em>ephemeral
                            port</em></span> (i.e., short-lived) number to the socket. In this case,
                        the application—typically a client—doesn’t care which port number it uses,
                        but assigning a port is necessary so that the transport-layer protocols can
                        identify the communication endpoints. It also has the result that the peer
                        application at the other end of the communication channel knows how to
                        communicate with this application. TCP and UDP also assign an ephemeral port
                        number if we bind a socket to port 0.<a id="IDX-CHP-58-7547" class="indexterm"/><a id="IDX-CHP-58-7548" class="indexterm"/><a id="IDX-CHP-58-7549" class="indexterm"/><a id="IDX-CHP-58-7550" class="indexterm"/><a id="IDX-CHP-58-7551" class="indexterm"/><a id="IDX-CHP-58-7552" class="indexterm"/><a id="IDX-CHP-58-7553" class="indexterm"/><a id="IDX-CHP-58-7554" class="indexterm"/></p><p>IANA specifies the ports in the range 49152 to 65535 as
                            <span class="emphasis"><em>dynamic</em></span> or <span class="emphasis"><em>private</em></span>, with the
                        intention that these ports can be used by local applications and assigned as
                        ephemeral ports. However, various implementations allocate ephemeral ports
                        from different ranges. On Linux, the range is defined by (and can be
                        modified via) two numbers contained in the file <code class="literal">/proc/sys/net/ipv4/ip_local_port_range</code>.</p></div></div><div class="sect2" title="User Datagram Protocol (UDP)"><div class="titlepage"><div><div><h3 class="title" id="user_datagram_protocol_open_parenthesis">User Datagram Protocol (UDP)</h3></div></div></div><p>UDP adds just two features to IP: port numbers and a data checksum to allow
                    the detection of errors in the transmitted data.<a id="IDX-CHP-58-7555" class="indexterm"/></p><p>Like IP, UDP is connectionless. Since it adds no reliability to IP, UDP is
                    likewise unreliable. If an application layered on top of UDP requires
                    reliability, then this must be implemented within the application. Despite this
                    unreliability, we may sometimes prefer to use UDP instead of TCP, for the
                    reasons detailed in <a class="xref" href="ch61.html#tcp_versus_udp" title="TCP Versus UDP">TCP Versus UDP</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The checksums used by both UDP and TCP are just 16 bits long, and are
                        simple “add-up” checksums that can fail to detect certain classes of errors.
                        Consequently, they do not provide extremely strong error detection. Busy
                        Internet servers typically see an average of one undetected transmission
                        error every few days ([Stone &amp; Partridge, 2000]). Applications that
                        need stronger assurances of data integrity can use the Secure Sockets Layer
                        (SSL) protocol, which provides not only secure communication, but also much
                        more rigorous detection of errors. Alternatively, an application could
                        implement its own error-control scheme.<a id="IDX-CHP-58-7556" class="indexterm"/></p></div><div class="sect3" title="Selecting a UDP datagram size to avoid IP fragmentation"><div class="titlepage"><div><div><h4 class="title" id="selecting_a_udp_datagram_size_to_avoid_i">Selecting a UDP datagram size to avoid IP fragmentation</h4></div></div></div><p>In <a class="xref" href="ch58.html#the_network_layer_colon_ip" title="The Network Layer: IP">The Network Layer: IP</a>, we described the IP
                        fragmentation mechanism, and noted that it is usually best to avoid IP
                        fragmentation. While TCP contains mechanisms for avoiding IP fragmentation,
                        UDP does not. With UDP, we can easily cause IP fragmentation by transmitting
                        a datagram that exceeds the MTU of the local data link.<a id="IDX-CHP-58-7558" class="indexterm"/><a id="IDX-CHP-58-7559" class="indexterm"/><a id="IDX-CHP-58-7560" class="indexterm"/><a id="IDX-CHP-58-7561" class="indexterm"/><a id="IDX-CHP-58-7562" class="indexterm"/><a id="IDX-CHP-58-7563" class="indexterm"/><a id="IDX-CHP-58-7564" class="indexterm"/><a id="IDX-CHP-58-7557" class="indexterm"/></p><p>A UDP-based application generally doesn’t know the MTU of the path between
                        the source and destination hosts. UDP-based applications that aim to avoid
                        IP fragmentation typically adopt a conservative approach, which is to ensure
                        that the transmitted IP datagram is less than the IPv4 minimum reassembly
                        buffer size of 576 bytes. (This value is likely to be lower than the path
                        MTU.) From these 576 bytes, 8 bytes are required by UDP’s own header, and an
                        additional minimum of 20 bytes are required for the IP header, leaving 548
                        bytes for the UDP datagram itself. In practice, many UDP-based applications
                        opt for a still lower limit of 512 bytes for their datagrams ([Stevens,
                        1994]).</p></div></div><div class="sect2" title="Transmission Control Protocol (TCP)"><div class="titlepage"><div><div><h3 class="title" id="transmission_control_protocol_open_paren">Transmission Control Protocol (TCP)</h3></div></div></div><p>TCP provides a reliable, connection-oriented, bidirectional, byte-stream
                    communication channel between two endpoints (i.e., applications), as shown in
                        <a class="xref" href="ch58.html#connected_tcp_sockets" title="Figure 58-8. Connected TCP sockets">Figure 58-8</a>. In order to provide these features,
                    TCP must perform the tasks described in this section. (A detailed description of
                    all of these features can be found in [Stevens, 1994].)</p><div class="figure"><a id="connected_tcp_sockets"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject58_d1e149029"/><img src="figs/web/58-8_SOCKNW-TCP-connected.png.jpg" alt="Connected TCP sockets"/></div></div><div class="figure-title">Figure 58-8. Connected TCP sockets</div></div><p>We use the term <span class="emphasis"><em>TCP endpoint</em></span> to denote the information
                    maintained by the kernel for one end of a TCP connection. (Often, we abbreviate
                    this term further, for example, writing just “a TCP,” to mean “a TCP endpoint,”
                    or “the client TCP” to mean “the TCP endpoint maintained for the client
                    application.”) This information includes the send and receive buffers for this
                    end of the connection, as well as state information that is maintained in order
                    to synchronize the operation of the two connected endpoints. (We describe this
                    state information in further detail when we consider the TCP state transition
                    diagram in <a class="xref" href="ch61.html#tcp_state_machine_and_state_transition_d" title="TCP State Machine and State Transition Diagram">TCP State Machine and State Transition Diagram</a>.) In the
                    remainder of this book, we use the terms <span class="emphasis"><em>receiving TCP</em></span> and
                        <span class="emphasis"><em>sending TCP</em></span> to denote the TCP endpoints maintained for
                    the receiving and sending applications on either end of a stream socket
                    connection that is being used to transmit data in a particular
                        direction.<a id="IDX-CHP-58-7565" class="indexterm"/><a id="IDX-CHP-58-7566" class="indexterm"/><a id="IDX-CHP-58-7567" class="indexterm"/><a id="IDX-CHP-58-7568" class="indexterm"/><a id="IDX-CHP-58-7569" class="indexterm"/></p><div class="sect3" title="Connection establishment"><div class="titlepage"><div><div><h4 class="title" id="connection_establishment">Connection establishment</h4></div></div></div><p>Before communication can commence, TCP establishes a communication channel
                        between the two endpoints. During connection establishment, the sender and
                        receiver can exchange options to advertise parameters for the
                            connection.<a id="IDX-CHP-58-7570" class="indexterm"/><a id="IDX-CHP-58-7571" class="indexterm"/></p></div><div class="sect3" title="Packaging of data in segments"><div class="titlepage"><div><div><h4 class="title" id="packaging_of_data_in_segments">Packaging of data in segments</h4></div></div></div><p>Data is broken into segments, each of which contains a checksum to allow
                        the detection of end-to-end transmission errors. Each segment is transmitted
                        in a single IP datagram.<a id="IDX-CHP-58-7572" class="indexterm"/></p></div><div class="sect3" title="Acknowledgements, retransmissions, and timeouts"><div class="titlepage"><div><div><h4 class="title" id="acknowledgements_comma_retransmissions_c">Acknowledgements, retransmissions, and timeouts</h4></div></div></div><p>When a TCP segment arrives at its destination without errors, the
                        receiving TCP sends a positive acknowledgement to the sender, informing it
                        of the successfully delivered data. If a segment arrives with errors, then
                        it is discarded, and no acknowledgement is sent. To handle the possibility
                        of segments that never arrive or are discarded, the sender starts a timer
                        when each segment is transmitted. If an acknowledgement is not received
                        before the timer expires, the segment is retransmitted.<a id="IDX-CHP-58-7573" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since the time taken to transmit a segment and receive its
                            acknowledgement varies according to the range of the network and the
                            current traffic loading, TCP employs an algorithm to dynamically adjust
                            the size of the retransmission timeout (RTO).<a id="IDX-CHP-58-7574" class="indexterm"/><a id="IDX-CHP-58-7575" class="indexterm"/></p><p>The receiving TCP may not send acknowledgements immediately, but
                            instead wait for a fraction of a second to see if the acknowledgement
                            can be piggybacked inside any response that the receiver may send
                            straight back to the sender. (Every TCP segment includes an
                            acknowledgement field, allowing for such piggybacking.) The aim of this
                            technique, called <span class="emphasis"><em>delayed ACK</em></span>, is to save sending a
                            TCP segment, thus decreasing the number of packets in the network and
                            decreasing the load on the sending and receiving hosts.<a id="IDX-CHP-58-7576" class="indexterm"/><a id="IDX-CHP-58-7577" class="indexterm"/></p></div></div><div class="sect3" title="Sequencing"><div class="titlepage"><div><div><h4 class="title" id="sequencing">Sequencing</h4></div></div></div><p>Each byte that is transmitted over a TCP connection is assigned a logical
                        sequence number. This number indicates the position of that byte in the data
                        stream for the connection. (Each of the two streams in the connection has
                        its own sequence numbering.) When a TCP segment is transmitted, it includes
                        a field containing the sequence number of the first byte in the
                            segment.<a id="IDX-CHP-58-7578" class="indexterm"/></p><p>Attaching sequence numbers to each segment serves a variety of
                        purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The sequence number allows TCP segments to be assembled in the
                                correct order at the destination, and then passed as a byte stream
                                to the application layer. (At any moment, multiple TCP segments may
                                be in transit between sender and receiver, and these segments may
                                arrive out of order.)</p></li><li class="listitem"><p>The acknowledgement message passed from the receiver back to the
                                sender can use the sequence number to identify which TCP segment was
                                received.</p></li><li class="listitem"><p>The receiver can use the sequence number to eliminate duplicate
                                segments. Such duplicates may occur either because of the
                                duplication of IP datagrams or because of TCP’s own retransmission
                                algorithm, which could retransmit a successfully delivered segment
                                if the acknowledgement for that segment was lost or was not received
                                in a timely fashion.</p></li></ul></div><p>The initial sequence number (ISN) for a stream doesn’t start at 0.
                        Instead, it is generated via an algorithm that increases the ISN assigned to
                        successive TCP connections (to prevent the possibility of old segments from
                        a previous incarnation of the connection being confused with segments for
                        this connection). This algorithm is also designed to make guessing the ISN
                        difficult. The sequence number is a 32-bit value that is wrapped around to 0
                        when the maximum value is reached.<a id="IDX-CHP-58-7579" class="indexterm"/></p></div><div class="sect3" title="Flow control"><div class="titlepage"><div><div><h4 class="title" id="flow_control">Flow control</h4></div></div></div><p>Flow control prevents a fast sender from overwhelming a slow receiver. To
                        implement flow control, the receiving TCP maintains a buffer for incoming
                        data. (Each TCP advertises the size of this buffer during connection
                        establishment.) Data accumulates in this buffer as it is received from the
                        sending TCP, and is removed as the application reads data. With each
                        acknowledgement, the receiver advises the sender of how much space is
                        available in its incoming data buffer (i.e., how many bytes the sender can
                        transmit). The TCP flow-control algorithm employs a so-called
                            <span class="emphasis"><em>sliding window</em></span> algorithm, which allows
                        unacknowledged segments containing a total of up <span class="emphasis"><em>N</em></span> (the
                        offered window size) bytes to be in transit between the sender and receiver.
                        If a receiving TCP’s incoming data buffer fills completely, then the window
                        is said to be closed, and the sending TCP stops transmitting.<a id="IDX-CHP-58-7580" class="indexterm"/><a id="IDX-CHP-58-7581" class="indexterm"/><a id="IDX-CHP-58-7582" class="indexterm"/><a id="IDX-CHP-58-7583" class="indexterm"/><a id="IDX-CHP-58-7584" class="indexterm"/><a id="IDX-CHP-58-7585" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The receiver can override the default size for the incoming data
                            buffer using the <code class="literal">SO_RCVBUF</code> socket
                            option (see the <span class="emphasis"><em>socket(7)</em></span> manual page).</p></div></div><div class="sect3" title="Congestion control: slow-start and congestion-avoidance algorithms"><div class="titlepage"><div><div><h4 class="title" id="congestion_control_colon_slow-start_and">Congestion control: slow-start and congestion-avoidance
                        algorithms</h4></div></div></div><p>TCP’s congestion-control algorithms are designed to prevent a fast sender
                        from overwhelming a network. If a sending TCP transmits packets faster than
                        they can be relayed by an intervening router, that router will start
                        dropping packets. This could lead to high rates of packet loss and,
                        consequently, serious performance degradation, if the sending TCP kept
                        retransmitting these dropped segments at the same rate. TCP’s
                        congestion-control algorithms are important in two circumstances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>After connection establishment</em></span>: At this time
                                (or when transmission resumes on a connection that has been idle for
                                some time), the sender could start by immediately injecting as many
                                segments into the network as would be permitted by the window size
                                advertised by the receiver. (In fact, this is what was done in early
                                TCP implementations.) The problem here is that if the network can’t
                                handle this flood of segments, the sender risks overwhelming the
                                network immediately.</p></li><li class="listitem"><p><span class="emphasis"><em>When congestion is detected</em></span>: If the sending
                                TCP detects that congestion is occurring, then it must reduce its
                                transmission rate. TCP detects that congestion is occurring based on
                                the assumption that segment loss because of transmission errors is
                                very low; thus, if a packet is lost, the cause is assumed to be
                                congestion.</p></li></ul></div><p>TCP’s congestion-control strategy employs two algorithms in combination:
                        slow start and congestion avoidance.</p><p>The <span class="emphasis"><em>slow-start</em></span> algorithm causes the sending TCP to
                        initially transmit segments at a slow rate, but allows it to exponentially
                        increase the rate as these segments are acknowledged by the receiving TCP.
                        Slow start attempts to prevent a fast TCP sender from overwhelming a
                        network. However, if unrestrained, slow start’s exponential increase in the
                        transmission rate could mean that the sender would soon overwhelm the
                        network. TCP’s <span class="emphasis"><em>congestion-avoidance</em></span> algorithm prevents
                        this, by placing a governor on the rate increase.</p><p>With congestion avoidance, at the beginning of a connection, the sending
                        TCP starts with a small <span class="emphasis"><em>congestion window</em></span>, which limits
                        the amount of unacknowledged data that it can transmit. As the sender
                        receives acknowledgements from the peer TCP, the congestion window initially
                        grows exponentially. However, once the congestion window reaches a certain
                        threshold believed to be close to the transmission capacity of the network,
                        its growth becomes linear, rather than exponential. (An estimate of the
                        capacity of the network is derived from a calculation based on the
                        transmission rate that was in operation when congestion was detected, or is
                        set at a fixed value after initial establishment of the connection.) At all
                        times, the quantity of data that the sending TCP will transmit remains
                        additionally constrained by the receiving TCP’s advertised window and the
                        local TCP’s send buffer.</p><p>In combination, the slow-start and congestion-avoidance algorithms allow
                        the sender to rapidly raise its transmission speed up to the available
                        capacity of the network, without overshooting that capacity. The effect of
                        these algorithms is to allow data transmission to quickly reach a state of
                        equilibrium, where the sender transmits packets at the same rate as it
                        receives acknowledgements from the receiver.</p></div></div></div><div class="sect1" title="Requests for Comments (RFCs)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="requests_for_comments_open_parenthesis_r">Requests for Comments (RFCs)</h2></div></div></div><p>Each of the Internet protocols that we discuss in this book is defined in an RFC
                document—a formal protocol specification. RFCs are published by the <span class="emphasis"><em>RFC
                    Editor</em></span> (<a class="ulink" href="http://www.rfc-editor.org/" target="_top">http://www.rfc-editor.org/</a>), which is funded
                by the <span class="emphasis"><em>Internet Society</em></span> (<a class="ulink" href="http://www.isoc.org/" target="_top">http://www.isoc.org/</a>).
                RFCs that describe Internet standards are developed under the auspices of the
                    <span class="emphasis"><em>Internet Engineering Task Force</em></span> (IETF, <a class="ulink" href="http://www.ietf.org/" target="_top">http://www.ietf.org/</a>), a community of network designers, operators,
                vendors, and researchers concerned with the evolution and smooth operation of the
                Internet. Membership of the IETF is open to any interested individual.<a id="IDX-CHP-58-7586" class="indexterm"/><a id="IDX-CHP-58-7587" class="indexterm"/><a id="IDX-CHP-58-7588" class="indexterm"/><a id="IDX-CHP-58-7589" class="indexterm"/><a id="IDX-CHP-58-7590" class="indexterm"/><a id="IDX-CHP-58-7591" class="indexterm"/><a id="IDX-CHP-58-7592" class="indexterm"/><a id="IDX-CHP-58-7593" class="indexterm"/><a id="IDX-CHP-58-7594" class="indexterm"/><a id="IDX-CHP-58-7595" class="indexterm"/><a id="IDX-CHP-58-7596" class="indexterm"/></p><p>The following RFCs are of particular relevance to the material covered in this
                book:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>RFC 791, <span class="emphasis"><em>Internet Protocol</em></span>. J. Postel (ed.),
                            1981.<a id="IDX-CHP-58-7597" class="indexterm"/></p></li><li class="listitem"><p>RFC 950, <span class="emphasis"><em>Internet Standard Subnetting Procedure</em></span>. J.
                        Mogul and J. Postel, 1985.<a id="IDX-CHP-58-7598" class="indexterm"/></p></li><li class="listitem"><p>RFC 793, <span class="emphasis"><em>Transmission Control Protocol</em></span>. J. Postel
                        (ed.), 1981.<a id="IDX-CHP-58-7599" class="indexterm"/></p></li><li class="listitem"><p>RFC 768, <span class="emphasis"><em>User Datagram Protocol</em></span>. J. Postel (ed.),
                            1980.<a id="IDX-CHP-58-7600" class="indexterm"/></p></li><li class="listitem"><p>RFC 1122, <span class="emphasis"><em>Requirements for Internet Hosts—Communication
                            Layers</em></span>. R. Braden (ed.), 1989.<a id="IDX-CHP-58-7601" class="indexterm"/></p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>RFC 1122 extends (and corrects) various earlier RFCs describing the TCP/IP
                    protocols. It is one of a pair of RFCs that are often simply known as the
                        <span class="emphasis"><em>Host Requirements RFCs</em></span>. The other member of the pair is
                    RFC 1123, which covers application-layer protocols such as
                        <span class="emphasis"><em>telnet</em></span>, FTP, and SMTP.<a id="IDX-CHP-58-7602" class="indexterm"/></p></div><p>Among the RFCs that describe IPv6 are the following:<a id="IDX-CHP-58-7603" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>RFC 2460, <span class="emphasis"><em>Internet Protocol</em></span>, <span class="emphasis"><em>Version
                            6</em></span>. S. Deering and R. Hinden, 1998.<a id="IDX-CHP-58-7604" class="indexterm"/></p></li><li class="listitem"><p>RFC 4291, <span class="emphasis"><em>IP Version 6 Addressing Architecture</em></span>. R.
                        Hinden and S. Deering, 2006.</p></li><li class="listitem"><p>RFC 3493, <span class="emphasis"><em>Basic Socket Interface Extensions for IPv6</em></span>.
                        R. Gilligan, S. Thomson, J. Bound, J. McCann, and W. Stevens,
                            2003.<a id="IDX-CHP-58-7605" class="indexterm"/><a id="IDX-CHP-58-7606" class="indexterm"/><a id="IDX-CHP-58-7607" class="indexterm"/><a id="IDX-CHP-58-7608" class="indexterm"/></p></li><li class="listitem"><p>RFC 3542, <span class="emphasis"><em>Advanced Sockets API for IPv6</em></span>. W. Stevens,
                        M. Thomas, E. Nordmark, and T. Jinmei, 2003.<a id="IDX-CHP-58-7609" class="indexterm"/></p></li></ul></div><p>A number of RFCs and papers provide improvements and extensions to the original
                TCP specification, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Congestion Avoidance and Control</em></span>. V. Jacobsen, 1988.
                        This was the initial paper describing the congestion-control and slow-start
                        algorithms for TCP. Originally published in <span class="emphasis"><em>Proceedings of SIGCOMM
                            ’88</em></span>, a slightly revised version is available at <a class="ulink" href="ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z" target="_top">ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z</a>. This paper is
                        largely superseded by some of the following RFCs.</p></li><li class="listitem"><p>RFC 1323, <span class="emphasis"><em>TCP Extensions for High Performance</em></span>. V.
                        Jacobson, R. Braden, and D. Borman, 1992.<a id="IDX-CHP-58-7610" class="indexterm"/></p></li><li class="listitem"><p>RFC 2018, <span class="emphasis"><em>TCP Selective Acknowledgment Options</em></span>. M.
                        Mathis, J. Mahdavi, S. Floyd, and A. Romanow, 1996.<a id="IDX-CHP-58-7611" class="indexterm"/></p></li><li class="listitem"><p>RFC 2581, <span class="emphasis"><em>TCP Congestion Control</em></span>. M. Allman, V.
                        Paxson, and W. Stevens, 1999.<a id="IDX-CHP-58-7612" class="indexterm"/></p></li><li class="listitem"><p>RFC 2861, <span class="emphasis"><em>TCP Congestion Window Validation</em></span>. M.
                        Handley, J. Padhye, and S. Floyd, 2000.<a id="IDX-CHP-58-7613" class="indexterm"/></p></li><li class="listitem"><p>RFC 2883, <span class="emphasis"><em>An Extension to the Selective Acknowledgement (SACK)
                            Option for TCP</em></span>. S. Floyd, J. Mahdavi, M. Mathis, and M.
                        Podolsky, 2000.<a id="IDX-CHP-58-7614" class="indexterm"/></p></li><li class="listitem"><p>RFC 2988, <span class="emphasis"><em>Computing TCP’s Retransmission Timer</em></span>. V.
                        Paxson and M. Allman, 2000.<a id="IDX-CHP-58-7615" class="indexterm"/></p></li><li class="listitem"><p>RFC 3168, <span class="emphasis"><em>The Addition of Explicit Congestion Notification (ECN)
                            to IP</em></span>. K. Ramakrishnan, S. Floyd, and D. Black,
                            2001.<a id="IDX-CHP-58-7616" class="indexterm"/></p></li><li class="listitem"><p>RFC 3390, <span class="emphasis"><em>Increasing TCP’s Initial Window</em></span>. M. Allman,
                        S. Floyd, and C. Partridge, 2002.<a id="IDX-CHP-58-7617" class="indexterm"/></p></li></ul></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id57">Summary</h2></div></div></div><p>TCP/IP is a layered networking protocol suite. At the bottom layer of the TCP/IP
                protocol stack is the IP network-layer protocol. IP transmits data in the form of
                datagrams. IP is connectionless, meaning that datagrams transmitted between source
                and destination hosts may take different routes across the network. IP is
                unreliable, in that it provides no guarantee that datagrams will arrive in order or
                unduplicated, or even arrive at all. If reliability is required, then it must be
                provided via the use of a reliable higher-layer protocol (e.g., TCP), or within an
                application.</p><p>The original version of IP is IPv4. In the early 1990s, a new version of IP, IPv6,
                was devised. The most notable difference between IPv4 and IPv6 is that IPv4 uses 32
                bits to represent a host address, while IPv6 uses 128 bits, thus allowing for a much
                larger number of hosts on the world-wide Internet. Currently, IPv4 remains the most
                widely used version of IP, although in coming years, it is likely to be supplanted
                by IPv6.</p><p>Various transport-layer protocols are layered on top of IP, of which the most
                widely used are UDP and TCP. UDP is an unreliable datagram protocol. TCP is a
                reliable, connection-oriented, byte-stream protocol. TCP handles all of the details
                of connection establishment and termination. TCP also packages data into segments
                for transmission by IP, and provides sequence numbering for these segments so that
                they can be acknowledged and assembled in the correct order by the receiver. In
                addition, TCP provides flow control, to prevent a fast sender from overwhelming a
                slow receiver, and congestion control, to prevent a fast sender from overwhelming
                the network.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id79"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id80">Further information</h4></div></div></div><p>Refer to the sources of further information listed in <a class="xref" href="ch59.html#further_information-id81" title="Further Information">Further Information</a>.</p></div></div></div></section></body></html>
