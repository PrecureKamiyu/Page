<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>15.3 Dynamic (Hardware-based) Relocation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part142.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part144.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 6pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">15.3 Dynamic (Hardware-based) Relocation</p><p style="padding-top: 4pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">To gain some understanding of hardware-based address translation, we’ll first discuss its first incarnation. Introduced in the first time-sharing machines of the late 1950’s is a simple idea referred to as <b>base and bounds </b>(the technique is also referred to as <b>dynamic relocation</b>; we’ll use both terms interchangeably) [SS74].</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Specifically, we’ll need two hardware registers within each CPU: one is called the <b>base </b>register, and the other the <b>bounds </b>(sometimes called a <b>limit </b>register). This base-and-bounds pair is going to allow us to place the address space anywhere we’d like in physical memory, and do so while ensuring that the process can only access its own address space.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">In this setup, each program is written and compiled as if it is loaded at address zero. However, when a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value. In the example above, the OS decides to load the process at physical address 32 KB and thus sets the base register to this value.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Interesting things start to happen when the process is running. Now, when any memory reference is generated by the process, it is <b>translated </b>by the processor in the following manner:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">physical address = virtual address + base</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 70pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>S<span class="s45">OFTWARE</span>-<span class="s45">BASED </span>R<span class="s45">ELOCATION</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In the early days, before hardware support arose, some systems per- formed a crude form of relocation purely via software methods. The basic technique is referred to as <b>static relocation</b>, in which a piece of soft- ware known as the <b>loader </b>takes an executable that is about to be run and rewrites its addresses to the desired offset in physical memory.</p><p style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">For example, if an instruction was a load from address 1000 into a reg- ister (e.g., <span class="s41">movl 1000, %eax</span>), and the address space of the program was loaded starting at address 3000 (and not 0, as the program thinks), the loader would rewrite the instruction to offset each address by 3000 (e.g., <span class="s41">movl 4000, %eax</span>). In this way, a simple static relocation of the process’s address space is achieved.</p><p style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">However, static relocation has numerous problems. First and most im- portantly, it does not provide protection, as processes can generate bad addresses and thus illegally access other process’s or even OS memory; in general, hardware support is likely needed for true protection [WL+93]. A smaller negative is that once placed, it is difficult to later relocate an address space to another location [M65].</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Each memory reference generated by the process is a <b>virtual address</b>; the hardware in turn adds the contents of the base register to this address and the result is a <b>physical address </b>that can be issued to the memory system.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To understand this better, let’s trace through what happens when a single instruction is executed. Specifically, let’s look at one instruction from our earlier sequence:</p><p class="s38" style="padding-top: 6pt;padding-left: 73pt;text-indent: 0pt;text-align: left;">128: movl 0x0(%ebx), %eax</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The program counter (PC) is set to 128; when the hardware needs to fetch this instruction, it first adds the value to the the base register value of 32 KB (32768) to get a physical address of 32896; the hardware then fetches the instruction from that physical address. Next, the processor begins executing the instruction. At some point, the process then issues the load from virtual address 15 KB, which the processor takes and again adds to the base register (32 KB), getting the final physical address of 47 KB and thus the desired contents.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Transforming a virtual address into a physical address is exactly the technique we refer to as <b>address translation</b>; that is, the hardware takes a virtual address the process thinks it is referencing and transforms it into a physical address which is where the data actually resides. Because this relocation of the address happens at runtime, and because we can move address spaces even after the process has started running, the technique is often referred to as <b>dynamic relocation </b>[M65].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 55pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: H<span class="s7">ARDWARE</span>-<span class="s7">BASED </span>D<span class="s7">YNAMIC </span>R<span class="s7">ELOCATION</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">With dynamic relocation, we can see how a little hardware goes a long way. Namely, a <b>base </b>register is used to transform virtual addresses (gen- erated by the program) into physical addresses. A <b>bounds </b>(or <b>limit</b>) reg- ister ensures that such addresses are within the confines of the address space. Together, they combine to provide a simple and efficient virtual- ization of memory.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Now you might be asking: what happened to that bounds (limit) reg- ister? After all, isn’t this supposed to be the base-and-bounds approach? Indeed, it is. And as you might have guessed, the bounds register is there to help with protection. Specifically, the processor will first check that the memory reference is <i>within bounds </i>to make sure it is legal; in the sim- ple example above, the bounds register would always be set to 16 KB. If a process generates a virtual address that is greater than the bounds, or one that is negative, the CPU will raise an exception, and the process will likely be terminated. The point of the bounds is thus to make sure that all addresses generated by the process are legal and within the “bounds” of the process.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">We should note that the base and bounds registers are hardware struc- tures kept on the chip (one pair per CPU). Sometimes people call the part of the processor that helps with address translation the <b>memory management unit (MMU)</b>; as we develop more sophisticated memory- management techniques, we will be adding more circuitry to the MMU.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A small aside about bound registers, which can be defined in one of two ways. In one way (as above), it holds the <i>size </i>of the address space, and thus the hardware checks the virtual address against it first before adding the base. In the second way, it holds the <i>physical address </i>of the end of the address space, and thus the hardware first adds the base and then makes sure the address is within bounds. Both methods are logically equivalent; for simplicity, we’ll usually assume that the bounds register holds the size of the address space.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part144.htm">Example Translations</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part142.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part144.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
