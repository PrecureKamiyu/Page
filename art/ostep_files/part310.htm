<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>30.2 The Producer/Consumer (Bound Buffer) Problem</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part309.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part311.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">30.2 The Producer/Consumer (Bound Buffer) Problem</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">The next synchronization problem we will confront in this chapter is known as the <b>producer/consumer </b>problem, or sometimes as the <b>bounded buffer </b>problem, which was first posed by Dijkstra [D72]. Indeed, it was this very producer/consumer problem that led Dijkstra and his co-workers to invent the generalized semaphore (which can be used as either a lock or a condition variable) [D01]; we will learn more about semaphores later.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">Imagine one or more producer threads and one or more consumer threads. Producers produce data items and wish to place them in a buffer; consumers grab data items out of the buffer consume them in some way. This arrangement occurs in many real systems. For example, in a multi-threaded web server, a producer puts HTTP requests into a work queue (i.e., the bounded buffer); consumer threads take requests out of</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">this queue and process them.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">A bounded buffer is also used when you pipe the output of one pro- gram into another, e.g., <span class="s41">grep foo file.txt | wc -l</span>. This example runs two processes concurrently; <span class="s41">grep </span>writes lines from <span class="s41">file.txt </span>with the string <span class="s41">foo </span>in them to what it thinks is standard output; the U<span class="s7">NIX </span>shell redirects the output to what is called a U<span class="s7">NIX </span>pipe (created by the <b>pipe </b>system call). The other end of this pipe is connected to the stan- dard input of the process <span class="s41">wc</span>, which simply counts the number of lines in the input stream and prints out the result. Thus, the <span class="s41">grep </span>process is the producer; the <span class="s41">wc </span>process is the consumer; between them is an in-kernel bounded buffer; you, in this example, are just the happy user.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">int buffer;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2  <span class="s38">int count = 0; // initially, empty</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">3</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4  <span class="s38">void put(int value) {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5    <span class="s38">assert(count == 0);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6    <span class="s38">count = 1;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7    <span class="s38">buffer = value;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">9</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">10  <span class="s38">int get() {</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">11    <span class="s38">assert(count == 1);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">12    <span class="s38">count = 0;</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">13    <span class="s38">return buffer;</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">14  <span class="s38">}</span></p><p style="padding-top: 5pt;padding-left: 112pt;text-indent: 0pt;text-align: left;">Figure 30.4: <b>The Put and Get Routines (Version 1)</b></p><p class="s38" style="padding-top: 5pt;padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">1  </span>void <span class="s39">*</span>producer(void <span class="s39">*</span>arg) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">2    <span class="s38">int i;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3    <span class="s38">int loops = (int) arg;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4     <span class="s38">for (i = 0; i &lt; loops; i++) {</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5       <span class="s38">put(i);</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6    <span class="s38">}</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">8</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">9  </span>void <span class="s39">*</span>consumer(void <span class="s39">*</span>arg) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;">10    <span class="s38">int i;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11    <span class="s38">while (1) {</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">12       <span class="s38">int tmp = get();</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">13       <span class="s38">printf(&quot;%d\n&quot;, tmp);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">14    <span class="s38">}</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">15  <span class="s38">}</span></p><p style="padding-left: 54pt;text-indent: 0pt;line-height: 10pt;text-align: center;">Figure 30.5: <b>Producer/Consumer Threads (Version 1)</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Because the bounded buffer is a shared resource, we must of course require synchronized access to it, lest<span class="s35">1</span> a race condition arise. To begin to understand this problem better, let us examine some actual code.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The first thing we need is a shared buffer, into which a producer puts data, and out of which a consumer takes data. Let’s just use a single integer for simplicity (you can certainly imagine placing a pointer to a data structure into this slot instead), and the two inner routines to put a value into the shared buffer, and to get a value out of the buffer. See Figure <span style=" color: #00AEEF;">30.4 </span>for details.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">Pretty simple, no? The <span class="s41">put() </span>routine assumes the buffer is empty (and checks this with an assertion), and then simply puts a value into the shared buffer and marks it full by setting <span class="s41">count </span>to 1. The <span class="s41">get() </span>routine does the opposite, setting the buffer to empty (i.e., setting <span class="s41">count </span>to 0) and returning the value. Don’t worry that this shared buffer has just a single entry; later, we’ll generalize it to a queue that can hold multiple entries, which will be even more fun than it sounds.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Now we need to write some routines that know when it is OK to access the buffer to either put data into it or get data out of it. The conditions for</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="154" height="1" alt="image" src="Image_388.png"/></span></p><p class="s11" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">1<span class="s12">This is where we drop some serious Old English on you, and the subjunctive form.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:21.6598pt" cellspacing="0"><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">1</p></td><td style="width:197pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 6pt;text-align: left;">cond_t cond;</p></td><td style="width:25pt" colspan="2" rowspan="6"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">2</p></td><td style="width:197pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 8pt;text-align: left;">mutex_t mutex;</p></td></tr><tr style="height:7pt"><td style="width:13pt"><p class="s135" style="padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">3</p></td><td style="width:197pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">4</p></td><td style="width:197pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 7pt;text-align: left;">void <span class="s136">*</span>producer(void <span class="s136">*</span>arg) {</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">5</p></td><td style="width:197pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 6pt;text-align: left;">int i;</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">6</p></td><td style="width:197pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 7pt;text-align: left;">for (i = 0; i &lt; loops; i++) {</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">7</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">Pthread_mutex_lock(&amp;mutex);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">p1</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">8</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">if (count == 1)</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">p2</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 4pt;text-indent: 0pt;line-height: 6pt;text-align: left;">9</p></td><td style="width:197pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">Pthread_cond_wait(&amp;cond, &amp;mutex);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">p3</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">10</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">put(i);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">p4</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">11</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">Pthread_cond_signal(&amp;cond);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">p5</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">12</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">Pthread_mutex_unlock(&amp;mutex);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">p6</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">13</p></td><td style="width:197pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 7pt;text-align: left;">}</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">14</p></td><td style="width:197pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 8pt;text-align: left;">}</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:7pt"><td style="width:13pt"><p class="s135" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">15</p></td><td style="width:197pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:9pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">16</p></td><td style="width:197pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 7pt;text-align: left;">void <span class="s136">*</span>consumer(void <span class="s136">*</span>arg) {</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">17</p></td><td style="width:197pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 6pt;text-align: left;">int i;</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">18</p></td><td style="width:197pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 7pt;text-align: left;">for (i = 0; i &lt; loops; i++) {</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">19</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">Pthread_mutex_lock(&amp;mutex);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">c1</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">20</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">if (count == 0)</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">c2</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">21</p></td><td style="width:197pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">Pthread_cond_wait(&amp;cond, &amp;mutex);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">c3</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">22</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">int tmp = get();</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">c4</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">23</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">Pthread_cond_signal(&amp;cond);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">c5</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">24</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">Pthread_mutex_unlock(&amp;mutex);</p></td><td style="width:12pt"><p class="s42" style="padding-right: 1pt;text-indent: 0pt;line-height: 7pt;text-align: right;">//</p></td><td style="width:13pt"><p class="s42" style="padding-right: 2pt;text-indent: 0pt;line-height: 7pt;text-align: right;">c6</p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">25</p></td><td style="width:197pt"><p class="s42" style="padding-left: 39pt;text-indent: 0pt;line-height: 7pt;text-align: left;">printf(&quot;%d\n&quot;, tmp);</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">26</p></td><td style="width:197pt"><p class="s42" style="padding-left: 22pt;text-indent: 0pt;line-height: 7pt;text-align: left;">}</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:8pt"><td style="width:13pt"><p class="s135" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 5pt;text-align: left;">27</p></td><td style="width:197pt"><p class="s42" style="padding-left: 5pt;text-indent: 0pt;line-height: 6pt;text-align: left;">}</p></td><td style="width:12pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:13pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">Figure 30.6: <b>Producer/Consumer: Single CV and If Statement</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">this should be obvious: only put data into the buffer when <span class="s41">count </span>is zero (i.e., when the buffer is empty), and only get data from the buffer when <span class="s41">count </span>is one (i.e., when the buffer is full). If we write the synchronization code such that a producer puts data into a full buffer, or a consumer gets data from an empty one, we have done something wrong (and in this code, an assertion will fire).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">This work is going to be done by two types of threads, one set of which we’ll call the <b>producer </b>threads, and the other set which we’ll call <b>con- sumer </b>threads. Figure <span style=" color: #00AEEF;">30.5 </span>shows the code for a producer that puts an integer into the shared buffer <span class="s41">loops </span>number of times, and a consumer that gets the data out of that shared buffer (forever), each time printing out the data item it pulled from the shared buffer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part311.htm">A Broken Solution</a><a class="toc0" href="part312.htm">Better, But Still Broken: While, Not If</a><a class="toc0" href="part313.htm">The Single Buffer Producer/Consumer Solution</a><a class="toc0" href="part314.htm">The Final Producer/Consumer Solution</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part309.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part311.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
