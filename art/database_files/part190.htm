<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>9.8   Application Security</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part189.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part191.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">9.8   <span style=" color: #00AEEF;">Application Security</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Application security has to deal with several security threats and issues beyond those handled by <span class="s44">SQL </span>authorization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">The ﬁrst point where security has to be enforced is in the application. To do so, applications must authenticate users and ensure that users are only allowed to carry out authorized tasks.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">There are many ways in which an application’s security can be compromised, even if the database system is itself secure, due to badly written application code. In this section, we ﬁrst describe several security loopholes that can permit hackers to carry out actions that bypass the authentication and authorization checks carried out by the application, and we explain how to prevent such loopholes. Later in the section, we describe techniques for secure authentication, and for ﬁne-grained authorization. We then describe audit trails that can help in recovering from unauthorized access and from erroneous updates. We conclude the section by describing issues in data privacy.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">9.8.1 SQL Injection</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In <span class="s64">SQL </span><span class="s84">injection </span>attacks, the attacker manages to get an application to execute an <span class="s44">SQL </span>query created by the attacker. In Section 5.1.1.5, we saw an example of an <span class="s44">SQL </span>injection vulnerability if user inputs are concatenated directly with an <span class="s44">SQL </span>query and submitted to the database. As another example of <span class="s44">SQL </span>injection vulnerability, consider the form source text shown in Figure 9.3. Suppose the corresponding servlet shown in Figure</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">9.7 creates an <span class="s44">SQL </span>query string using the following Java expression:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 63pt;text-indent: 0pt;text-align: center;">String query = “select * from student where name like ’%”</p><p class="s185" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;text-align: center;">+ <span class="s49">name </span>+ <span class="s49">“%’ ”</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="p">where </span>name <span class="p">is a variable containing the string input by the user, and then executes the query on the database. A malicious attacker using the web form can then type a string such as “ </span>’; <span class="s186">&lt;</span>some <span class="s157">SQL </span>statement<span class="s186">&gt;</span>;–– <span class="p">”, where </span><span class="s186">&lt;</span>some <span class="s157">SQL </span>statement<span class="s186">&gt; </span><span class="p">denotes any</span></p><p class="s42" style="padding-left: 88pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">SQL <span class="s43">statement that the attacker desires, in place of a valid student name. The servlet</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">would then execute the following string.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 102pt;text-indent: 0pt;text-align: left;">select* from student where name like &#39;%&#39;; <span class="s186">&lt;</span>some SQL statement<span class="s186">&gt;</span>;– – %’</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">The quote inserted by the attacker closes the string, the following semicolon terminates the query, and the following text inserted by the attacker gets interpreted as a second <span class="s44">SQL </span>query, while the closing quote has been commented out. Thus, the malicious user has managed to insert an arbitrary <span class="s44">SQL </span>statement that is executed by the application. The statement can cause signiﬁcant damage, since it can perform any action on the database, bypassing all security measures implemented in the application code.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As discussed in Section 5.1.1.5, to avoid such attacks, it is best to use prepared statements to execute <span class="s44">SQL </span>queries. When setting a parameter of a prepared query, <span class="s44">JDBC </span>automatically adds escape characters so that the user-supplied quote would no longer be able to terminate the string. Equivalently, a function that adds such escape</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">characters could be applied on input strings before they are concatenated with the <span class="s44">SQL</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">query, instead of using prepared statements.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Another source of <span class="s44">SQL</span>-injection risk comes from applications that create queries dynamically, based on selection conditions and ordering attributes speciﬁed in a form. For example, an application may allow a user to specify what attribute should be used for sorting the results of a query. An appropriate <span class="s44">SQL </span>query is constructed, based on the attribute speciﬁed. Suppose the application takes the attribute name from a form, in the variable <span class="s49">orderAttribute</span>, and creates a query string such as the following:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s49" style="padding-left: 162pt;text-indent: 0pt;text-align: left;">String query = “select * from takes order by ” + orderAttribute;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A malicious user can send an arbitrary string in place of a meaningful <span class="s49">orderAt- tribute </span>value, even if the <span class="s44">HTML </span>form used to get the input tried to restrict the allowed values by providing a menu. To avoid this kind of <span class="s44">SQL </span>injection, the application should ensure that the <span class="s49">orderAttribute </span>variable value is one of the allowed values (in our ex- ample, attribute names) before appending it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">9.8.2 Cross-Site Scripting and Request Forgery</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">A web site that allows users to enter text, such as a comment or a name, and then stores it and later displays it to other users, is potentially vulnerable to a kind of attack called a <span class="s63">cross-site scripting </span>(<span class="s64">XSS</span>) attack. In such an attack, a malicious user enters code written in a client-side scripting language such as JavaScript or Flash instead of entering a valid name or comment. When a diﬀerent user views the entered text, the browser executes the script, which can carry out actions such as sending private cookie information back to the malicious user or even executing an action on a diﬀerent web server that the user may be logged into.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For example, suppose the user happens to be logged into her bank account at the time the script executes. The script could send cookie information related to the bank account login back to the malicious user, who could use the information to connect to the bank’s web server, fooling it into believing that the connection is from the original user. Or the script could access appropriate pages on the bank’s web site, with appro- priately set parameters, to execute a money transfer. In fact, this particular problem can occur even without scripting by simply using a line of code such as</p><p class="s186" style="padding-top: 9pt;padding-left: 126pt;text-indent: 0pt;line-height: 16pt;text-align: left;">&lt;<span class="s49">img src=</span></p><p class="s49" style="padding-left: 146pt;text-indent: 0pt;line-height: 16pt;text-align: left;">&quot;https://mybank.com/transfermoney?amount=1000&amp;toaccount=14523&quot;<span class="s186">&gt;</span></p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">assuming that the <span class="s44">URL </span><span class="s49">mybank.com/transfermoney </span>accepts the speciﬁed parameters and carries out a money transfer. This latter kind of vulnerability is also called <span class="s63">cross-site request forgery </span>or <span class="s64">XSRF </span>(sometimes also called <span class="s64">CSRF</span>).</p><p class="s42" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">XSS <span class="s43">can be done in other ways, such as luringa user into visiting a web site that has malicious scripts embedded in its pages. There are other more complex kinds of </span>XSS</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">and <span class="s44">XSRF </span>attacks, which we shall not get into here. To protect against such attacks, two things need to be done:</p><p class="s46" style="padding-top: 7pt;padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s39">• </span>Prevent your web site from being used to launch <span class="s47">XSS </span>or <span class="s47">XSRF </span>attacks.</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">The simplest technique is to disallow any <span class="s44">HTML </span>tags whatsoever in text input by users. There are functions that detect or strip all such tags. These functions can be used to prevent <span class="s44">HTML </span>tags, and as a result, any scripts, from being displayed to other users. In some cases <span class="s44">HTML </span>formatting is useful, and in that case functions that parse the text and allow limited <span class="s44">HTML </span>constructs but disallow other dangerous constructs can be used instead; these must be designed carefully, since something as innocuous as an image include could potentially be dangerous in case there is a bug in the image display software that can be exploited.</p><p class="s46" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s39">• </span>Protect your web site from <span class="s47">XSS </span>or <span class="s47">XSRF </span>attacks launched from other sites.</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">If the user has logged into your web site and visits a diﬀerent web site vulnerable to <span class="s44">XSS</span>, the malicious code executing on the user’s browser could execute actions on your web site or pass session information related to your web site back to the malicious user, who could try to exploit it. This cannot be prevented altogether, but you can take a few steps to minimize the risk.</p><p class="s51" style="padding-top: 9pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: justify;"><span class="s50">° </span>The <span class="s52">HTTP </span>protocol allows a server to check the <span class="s63">referer </span><span class="p">of a page access, that is, the </span><span class="s44">URL </span><span class="p">of the page that had the link that the user clicked on to initiate the</span></p><p style="padding-left: 122pt;text-indent: 0pt;text-align: justify;">page access. By checking that the referer is valid, for example, that the referer <span class="s44">URL </span>is a page on the same web site, <span class="s44">XSS </span>attacks that originated on a diﬀerent web page accessed by the user can be prevented.</p><p class="s51" style="padding-top: 8pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: justify;"><span class="s50">° </span>Instead of using only the cookie to identify a session, the session could also be restricted to the <span class="s52">IP </span>address from which it was originally authenticated. As a</p><p style="padding-left: 122pt;text-indent: 0pt;text-align: justify;">result, even if a malicious user gets a cookie, he may not be able to log in from a diﬀerent computer.</p><p class="s50" style="padding-top: 6pt;padding-left: 113pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">° <span class="s51">Never use a </span><span class="s49">GET </span><span class="p">method to perform any updates. This prevents attacks using</span></p><p style="padding-left: 122pt;text-indent: 0pt;line-height: 73%;text-align: justify;"><span class="s186">&lt;</span><span class="s49">img src ..</span><span class="s186">&gt; </span>such as the one we saw earlier. In fact, the <span class="s44">HTTP </span>standard speciﬁes that <span class="s49">GET </span>methods should not perform any updates.</p><p class="s50" style="padding-top: 6pt;padding-left: 113pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">° <span class="s51">If you use a web application framework like Django, make sure to use the</span></p><p class="s42" style="padding-left: 122pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">XSRF<span class="s43">/</span>CSRF <span class="s43">protection mechanisms provided by the framework.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">9.8.3 Password Leakage</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Another problem that application developers must deal with is storing passwords in clear text in the application code. For example, programs such as <span class="s44">JSP </span>scripts often contain passwords in clear text. If such scripts are stored in a directory accessible by a web server, an external user may be able to access the source code of the script and get access to the password for the database account used by the application. To avoid such problems, many application servers provide mechanisms to store passwords in</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">encrypted form, which the server decrypts before passing it on to the database. Such a feature removes the need for storing passwords as clear text in application programs. However, if the decryption key is also vulnerable to being exposed, this approach is not fully eﬀective.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As another measure against compromised database passwords, many database sys- tems allow access to the database to be restricted to a given set of internet addresses, typically, the machines running the application servers. Attempts to connect to the database from other internet addresses are rejected. Thus, unless the malicious user is able to log into the application server, she cannot do any damage even if she gains access to the database password.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">9.8.4 Application-Level Authentication</p><p class="s63" style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Authentication <span class="p">refers to the task of verifying the identity of a person/software connect- ing to an application. The simplest form of authentication consists of a secret password that must be presented when a user connects to the application. Unfortunately, pass- words are easily compromised, for example, by guessing, or by sniﬃng of packets on the network if the passwords are not sent encrypted. More robust schemes are needed for critical applications, such as online bank accounts. Encryption is the basis for more robust authentication schemes. Authentication through encryption is addressed in Sec- tion 9.9.3.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">Many applications use <span class="s63">two-factor authentication</span>, where two independent <i>factors </i>(i.e., pieces of information or processes) are used to identify a user. The two factors should not share a common vulnerability; for example, if a system merely required two passwords, both could be vulnerable to leakage in the same manner (by network sniﬃng, or by a virus on the computer used by the user, for example). While biometrics such as ﬁngerprints or iris scanners can be used in situations where a user is physically present at the point of authentication, they are not very meaningful across a network. Passwords are used as the ﬁrst factor in most such two-factor authentication schemes. Smart cards or other encryption devices connected through the <span class="s44">USB </span>inter- face, which can be used for authentication based on encryption techniques (see Section</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">9.9.3), are widely used as second factors.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">One-time password devices, which generate a new pseudo-random number (say) every minute are also widely used as a second factor. Each user is given one of these devices and must enter the number displayed by the device at the time of authenti- cation, along with the password, to authenticate himself. Each device generates a dif- ferent sequence of pseudo-random numbers. The application server can generate the same sequence of pseudo-random numbers as the device given to the user, stopping at the number that would be displayed at the time of authentication, and verify that the numbers match. This scheme requires that the clock in the device and at the server are synchronized reasonably closely.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Yet another second-factor approach is to send an <span class="s44">SMS </span>with a (randomly generated) one-time password to the user’s phone (whose number is registered earlier) whenever</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">the user wishes to log in to the application. The user must possess a phone with that number to receive the <span class="s44">SMS </span>and then enter the one-time password, along with her regular password, to be authenticated.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">It is worth noting that even with two-factor authentication, users may still be vulner- able to <span class="s63">man-in-the-middle attacks</span>. In such attacks, a user attempting to connect to the application is diverted to a fake web site, which accepts the password (including second factor passwords) from the user and uses it immediately to authenticate to the original application. The <span class="s44">HTTPS </span>protocol, described in Section 9.9.3.2, is used to authenticate the web site to the user (so the user does not connect to a fake site believing it to be the intended site). The <span class="s44">HTTPS </span>protocol also encrypts data and prevents man-in-the-middle attacks.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When users access multiple web sites, it is often annoying for a user to have to authenticate herself to each site separately, often with diﬀerent passwords on each site. There are systems that allow the user to authenticate herself to one central authenti- cation service, and other web sites and applications can authenticate the user through the central authentication service; the same password can then be used to access mul- tiple sites. The <span class="s44">LDAP </span>protocol is widely used to implement such a central point of authentication for applications within a single organization; organizations implement an <span class="s44">LDAP </span>server containing user names and password information, and applications use the <span class="s44">LDAP </span>server to authenticate users.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">In addition to authenticating users, a central authentication service can provide other services, for example, providing information about the user such as name, email, and address information, to the application. This obviates the need to enter this infor- mation separately in each application. <span class="s44">LDAP </span>can be used for this task, as described in Section 25.5.2. Other directory systems such Microsoft’s Active Directories also provide mechanisms for authenticating users as well as for providing user information. A <span class="s63">single sign-on </span>system further allows the user to be authenticated once, and mul- tiple applications can then verify the user’s identity through an authentication service without requiring reauthentication. In other words, once a user is logged in at one site, he does not have to enter his user name and password at other sites that use the same single sign-on service. Such single sign-on mechanisms have long been used in network authentication protocols such as Kerberos, and implementations are now available for</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">web applications.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s63">Security Assertion Markup Language </span>(<span class="s64">SAML</span><a href="mailto:joe@yale.edu" class="s87" target="_blank">) is a protocol for exchanging authentication and authorization information between diﬀerent security domains, to provide cross-organization single sign-on. For example, suppose an application needs to provide access to all students from a particular university, say Yale. The university can set up a web-based service that carries out authentication. Suppose a user connects to the application with a username such as “joe@yale.edu”.</a> The application, instead of directly authenticating a user, diverts the user to Yale University’s authentication ser- vice, which authenticates the user and then tells the application who the user is and</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">may provide some additional information such as the category of the user (student or instructor) or other relevant information. The user’s password and other authentication factors are never revealed to the application, and the user need not register explicitly with the application. However, the application must trust the university’s authentica- tion service when authenticating a user.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <span class="s63">OpenID </span>protocol is an alternative for single sign-on across organizations, which works in a manner similar to <span class="s44">SAML</span>. The <span class="s63">OAuth </span>protocol is another protocol that allows users to authorize access to certain resources, via sharing of an authoriza- tion token.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">9.8.5 Application-Level Authorization</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Although the <span class="s44">SQL </span>standard supports a fairly ﬂexible system of authorization based on roles (described in Section 4.7), the <span class="s44">SQL </span>authorization model plays a very limited role in managing user authorizations in a typical application. For instance, suppose you want all students to be able to see their own grades, but not the grades of anyone else. Such authorization cannot be speciﬁed in <span class="s44">SQL </span>for at least two reasons:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: -16pt;text-align: justify;"><span class="s63">1.  </span><b>Lack of end-user information</b>. With the growth in the web, database accesses come primarily from web application servers. The end users typically do not have indi- vidual user identiﬁers on the database itself, and indeed there may only be a single user identiﬁer in the database corresponding to all users of an application server. Thus, authorization speciﬁcation in <span class="s44">SQL </span>cannot be used in the above scenario.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2299.png"/></span></p><p style="padding-left: 145pt;text-indent: 17pt;text-align: justify;">It is possible for an application server to authenticate end users and then pass the authentication information on to the database. In this section we will assume that the function <i>syscontext.user id</i>() returns the identiﬁer of the application user on whose behalf a query is being executed. <span class="s76">6</span></p><p style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: right;"><span class="s63">2. </span><b>Lack of ﬁne-grained authorization</b>. Authorization must be at the level of individual tuples if we are to authorize students to see only their own grades. Such autho- rization is not possible in the current <span class="s44">SQL </span>standard, which permits authorization only on an entire relation or view, or on speciﬁed attributes of relations or views.</p><p style="padding-left: 145pt;text-indent: 17pt;text-align: justify;">We could try to get around this limitation by creating for each student a view on the <i>takes </i>relation that shows only that student’s grades. While this would work in principle, it would be extremely cumbersome since we would have to create one such view for every single student enrolled in the university, which is completely impractical.<span class="s76">7</span></p><p style="padding-left: 163pt;text-indent: 0pt;text-align: justify;">An alternative is to create a view of the form</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2300.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2301.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="3" height="1" alt="image" src="Image_2302.png"/></span></p><p class="s78" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><span class="s77">6</span>In Oracle, a <span class="s153">JDBC </span>connection using Oracle’s <span class="s153">JDBC </span>drivers can set the end user identiﬁer using the method <span class="s184">OracleConnection.setClientIdentifier(userId)</span><span class="s80">, and an </span><span class="s161">SQL </span><span class="s80">query can use the function </span><span class="s184">sys context(&#39;USERENV&#39;, &#39;CLIENT IDENTIFIER&#39;) </span><span class="s80">to retrieve the user identiﬁer.</span></p><p class="s77" style="padding-left: 119pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">7<span class="s78">Database systems are designed to manage large relations but to manage schema information such as views in a way</span></p><p class="s80" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">that assumes smaller data volumes so as to enhance overall performance.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-top: 4pt;padding-left: 212pt;text-indent: 0pt;text-align: left;">create view <i>studentTakes </i>as select <span class="p">*</span></p><p class="s46" style="padding-left: 212pt;text-indent: 0pt;text-align: left;">from <i>takes</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2303.png"/></span></p><p style="padding-left: 212pt;text-indent: 0pt;text-align: left;"><b>where </b><i>takes</i>.<span class="s69">ID</span>= <i>syscontext.user id</i>()</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 113pt;text-indent: 0pt;text-align: justify;">Users are then given authorization to this view, rather than to the underlying <i>takes </i>relation. However, queries executed on behalf of students must now be written on the view <i>studentTakes</i>, rather than on the original <i>takes </i>relation, whereas queries executed on behalf of instructors may need to use a diﬀerent view. The task of developing applications becomes more complex as a result.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The task of authorization is often typically carried out entirely in the application, bypassing the authorization facilities of <span class="s44">SQL</span>. At the application level, users are autho- rized to access speciﬁc interfaces, and they may further be restricted to view or update certain data items only.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">While carrying out authorization in the application gives a great deal of ﬂexibility to application developers, there are problems, too.</p><p class="s39" style="padding-top: 9pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The code for checking authorization becomes intermixed with the rest of the ap- plication code.</span></p><p class="s40" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>Implementing authorization through application code, rather than specifying it declaratively in <span class="s41">SQL</span>, makes it hard to ensure the absence of loopholes. Because of an oversight, one of the application programs may not check for authorization, allowing unauthorized users access to conﬁdential data.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Verifying that all application programs make all required authorization checks involves reading through all the application-server code, a formidable task in a large system. In other words, applications have a very large “surface area,” making the task of protecting the application signiﬁcantly harder. And in fact, security loopholes have been found in a variety of real-life applications.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In contrast, if a database directly supported ﬁne-grained authorization, authoriza- tion policies could be speciﬁed and enforced at the <span class="s44">SQL </span>level, which has a much smaller surface area. Even if some of the application interfaces inadvertently omit required authorization checks, the <span class="s44">SQL</span>-level authorization could prevent unauthorized actions from being executed.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Some database systems provide mechanisms for row-level authorization as we saw in Section 4.7.7. For example, the Oracle <span class="s63">Virtual Private Database </span>(<span class="s64">VPD</span>) allows a sys- tem administrator to associate a function with a relation; the function returns a predi- cate that must be added to any query that uses the relation (diﬀerent functions can be deﬁned for relations that are being updated). For example, using our syntax for retriev- ing application user identiﬁers, the function for the <i>takes </i>relation can return a predicate such as:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2304.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2305.png"/></span></p><p style="padding-top: 4pt;padding-left: 250pt;text-indent: 0pt;text-align: left;"><span class="s69">ID </span>= <i>sys context.user id</i>()</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2306.png"/></span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">This predicate is added to the <b>where </b>clause of every query that uses the <i>takes </i>relation. As a result (assuming that the application program sets the <i>user id </i>value to the student’s <span class="s69">ID</span>), each student can see only the tuples corresponding to courses that she took.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As we discussed in Section 4.7.7, a potential pitfall with adding a predicate as described above is that it may change the meaning of a query. For example, if a user wrote a query to ﬁnd the average grade over all courses, she would end up getting the average of <i>her </i>grades, not all grades. Although the system would give the “right” answer for the rewritten query, that answer would not correspond to the query the user may have thought she was submitting.</p><p class="s42" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">P<span class="s43">ostgre</span>SQL <span class="s43">and Microsoft </span>SQL S<span class="s43">erver oﬀer row-level authorization support with similar functionality to Oracle </span>VPD<span class="s43">. More information on Oracle </span>VPD <span class="s43">and </span>P<span class="s43">ostgre</span>SQL <span class="s43">and </span>SQL S<span class="s43">erver row-level authorization may be found in their respective system manu- als available online.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">9.8.6 Audit Trails</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">An <span class="s63">audit trail </span>is a log of all changes (inserts, deletes, and updates) to the application data, along with information such as which user performed the change and when the change was performed. If application security is breached, or even if security was not breached, but some update was carried out erroneously, an audit trail can (a) help ﬁnd out what happened, and who may have carried out the actions, and (b) aid in ﬁxing the damage caused by the security breach or erroneous update.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For example, if a student’s grade is found to be incorrect, the audit log can be examined to locate when and how the grade was updated, as well as to ﬁnd which user carried out the updates. The university could then also use the audit trail to trace all the updates performed by this user in order to ﬁnd other incorrect or fraudulent updates, and then correct them.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Audit trails can also be used to detect security breaches where a user’s account is compromised and accessed by an intruder. For example, each time a user logs in, she may be informed about all updates in the audit trail that were done from that login in the recent past; if the user sees an update that she did not carry out, it is likely the account has been compromised.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">It is possible to create a database-level audit trail by deﬁning appropriate triggers on relation updates (using system-deﬁned variables that identify the user name and time). However, many database systems provide built-in mechanisms to create audit trails that are much more convenient to use. Details of how to create audit trails vary across database systems, and you should refer to the database-system manuals for details.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Database-level audit trails are usually insuﬃcient for applications, since they are usually unable to track who was the end user of the application. Further, updates are recorded at a low level, in terms of updates to tuples of a relation, rather than at a higher level, in terms of the business logic. Applications, therefore, usually create a</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">higher-level audit trail, recording, for example, what action was carried out, by whom, when, and from which <span class="s44">IP </span>address the request originated.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A related issue is that of protecting the audit trail itself from being modiﬁed or deleted by users who breach application security. One possible solution is to copy the audit trail to a diﬀerent machine, to which the intruder would not have access, with each record in the trail copied as soon as it is generated. A more robust solution is to use blockchain techniques, which are described in Chapter 26; blockchain techniques store logs in multiple machines and use a hashing mechanism that makes it very diﬃcult for an intruder to modify or delete data without being detected.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">9.8.7 Privacy</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">In a world where an increasing amount of personal data are available online, people are increasingly worried about the privacy of their data. For example, most people would want their personal medical data to be kept private and not revealed publicly. However, the medical data must be made available to doctors and emergency medical technicians who treat the patient. Many countries have laws on privacy of such data that deﬁne when and to whom the data may be revealed. Violation of privacy law can result in criminal penalties in some countries. Applications that access such private data must be built carefully, keeping the privacy laws in mind.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">On the other hand, aggregated private data can play an important role in many tasks such as detecting drug side eﬀects, or in detecting the spread of epidemics. How to make such data available to researchers carrying out such tasks without compromising the privacy of individuals is an important real-world problem. As an example, suppose a hospital hides the name of the patient but provides a researcher with the date of birth and the postal code of the patient (both of which may be useful to the researcher). Just these two pieces of information can be used to uniquely identify the patient in many cases (using information from an external database), compromising his privacy. In this particular situation, one solution would be to give the year of birth but not the date of birth, along with the address, which may suﬃce for the researcher. This would not provide enough information to uniquely identify most individuals.<span class="s76">8</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As another example, web sites often collect personal data such as address, tele- phone, email, and credit-card information. Such information may be required to carry outa transaction such as purchasing an item froma store. However, the customer may not want the information to be made available to other organizations, or may want part of the information (such as credit-card numbers) to be erased after some period of time as a way to prevent it from falling into unauthorized hands in the event of a security breach. Many web sites allow customers to specify their privacy preferences, and those web sites must then ensure that these preferences are respected.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2307.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">8<span class="s78">For extremely old people, who are relatively rare, even the year of birth plus postal code may be enough to uniquely identify the individual, so a range of values, such as 90 years or older, may be provided instead of the actual age for people older than 90 years.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part189.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part191.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
