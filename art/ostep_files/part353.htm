<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>33.1 The Basic Idea: An Event Loop</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part352.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part354.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">33.1 The Basic Idea: An Event Loop</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The basic approach we’ll use, as stated above, is called <b>event-based concurrency</b>. The approach is quite simple: you simply wait for some- thing (i.e., an “event”) to occur; when it does, you check what type of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: center;">373</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">event it is and do the small amount of work it requires (which may in- clude issuing I/O requests, or scheduling other events for future han- dling, etc.). That’s it!</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Before getting into the details, let’s first examine what a canonical event-based server looks like. Such applications are based around a sim- ple construct known as the <b>event loop</b>. Pseudocode for an event loop looks like this:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">while (1) {</p><p class="s38" style="padding-left: 85pt;text-indent: 0pt;text-align: left;">events = getEvents(); for (e in events)</p><p class="s38" style="padding-left: 102pt;text-indent: 0pt;text-align: left;">processEvent(e);</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">It’s really that simple. The main loop simply waits for something to do (by calling <span class="s41">getEvents() </span>in the code above) and then, for each event re- turned, processes them, one at a time; the code that processes each event is known as an <b>event handler</b>. Importantly, when a handler processes an event, it is the only activity taking place in the system; thus, deciding which event to handle next is equivalent to scheduling. This explicit con- trol over scheduling is one of the fundamental advantages of the event- based approach.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">But this discussion leaves us with a bigger question: how exactly does an event-based server determine which events are taking place, in par- ticular with regards to network and disk I/O? Specifically, how can an event server tell if a message has arrived for it?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part352.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part354.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
