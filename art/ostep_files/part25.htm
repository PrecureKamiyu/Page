<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2.5 Design Goals</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part24.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part26.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 16pt;text-indent: 0pt;text-align: left;">2.5 Design Goals</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">So now you have some idea of what an OS actually does: it takes phys- ical <b>resources</b>, such as a CPU, memory, or disk, and <b>virtualizes </b>them. It handles tough and tricky issues related to <b>concurrency</b>. And it stores files <b>persistently</b>, thus making them safe over the long-term. Given that we want to build such a system, we want to have some goals in mind to help focus our design and implementation and make trade-offs as necessary; finding the right set of trade-offs is a key to building systems.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One of the most basic goals is to build up some <b>abstractions </b>in order to make the system convenient and easy to use. Abstractions are fun- damental to everything we do in computer science. Abstraction makes it possible to write a large program by dividing it into small and under- standable pieces, to write such a program in a high-level language like</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">C<span class="s35">9</span> without thinking about assembly, to write code in assembly without thinking about logic gates, and to build a processor out of gates without thinking too much about transistors. Abstraction is so fundamental that sometimes we forget its importance, but we won’t here; thus, in each sec- tion, we’ll discuss some of the major abstractions that have developed over time, giving you a way to think about pieces of the OS.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One goal in designing and implementing an operating system is to provide high <b>performance</b>; another way to say this is our goal is to <b>mini- mize the overheads </b>of the OS. Virtualization and making the system easy to use are well worth it, but not at any cost; thus, we must strive to pro- vide virtualization and other OS features without excessive overheads. These overheads arise in a number of forms: extra time (more instruc- tions) and extra space (in memory or on disk). We’ll seek solutions that minimize one or the other or both, if possible. Perfection, however, is not always attainable, something we will learn to notice and (where appro- priate) tolerate.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Another goal will be to provide <b>protection </b>between applications, as well as between the OS and applications. Because we wish to allow many programs to run at the same time, we want to make sure that the malicious or accidental bad behavior of one does not harm others; we certainly don’t want an application to be able to harm the OS itself (as that would affect <i>all </i>programs running on the system). Protection is at the heart of one of the main principles underlying an operating system, which is that of <b>isolation</b>; isolating processes from one another is the key to protection and thus underlies much of what an OS must do.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The operating system must also run non-stop; when it fails, <i>all </i>appli- cations running on the system fail as well. Because of this dependence, operating systems often strive to provide a high degree of <b>reliability</b>. As operating systems grow evermore complex (sometimes containing mil- lions of lines of code), building a reliable operating system is quite a chal-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 5pt;padding-left: 41pt;text-indent: 13pt;line-height: 92%;text-align: left;">9<span class="s12">Some of you might object to calling C a high-level language. Remember this is an OS course, though, where we’re simply happy not to have to code in assembly all the time!</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">lenge – and indeed, much of the on-going research in the field (including some of our own work [BS+09, SS+10]) focuses on this exact problem.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Other goals make sense: <b>energy-efficiency </b>is important in our increas- ingly green world; <b>security </b>(an extension of protection, really) against malicious applications is critical, especially in these highly-networked times; <b>mobility </b>is increasingly important as OSes are run on smaller and smaller devices. Depending in how the system is used, the OS will have different goals and thus likely be implemented in at least slightly differ- ent ways. However, as we will see, many of the principles we will present on how to build operating systems are useful in the range of different de- vices.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part24.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part26.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
