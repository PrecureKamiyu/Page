<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>22.5 Using History: LRU</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part228.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part230.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">22.5 Using History: LRU</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Unfortunately, any policy as simple as FIFO or Random is likely to have a common problem: it might kick out an important page, one that is about to be referenced again. FIFO kicks out the page that was first brought in; if this happens to be a page with important code or data structures upon it, it gets thrown out anyhow, even though it will soon be paged back in. Thus, FIFO, Random, and similar policies are not likely to approach optimal; something smarter is needed.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As we did with scheduling policy, to improve our guess at the future, we once again lean on the past and use <i>history </i>as our guide. For example, if a program has accessed a page in the near past, it is likely to access it again in the near future.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One type of historical information a page-replacement policy could use is <b>frequency</b>; if a page has been accessed many times, perhaps it should not be replaced as it clearly has some value. A more commonly- used property of a page is its <b>recency </b>of access; the more recently a page has been accessed, perhaps the more likely it will be accessed again.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">This family of policies is based on what people refer to as the <b>prin- ciple of locality </b>[D70], which basically is just an observation about pro- grams and their behavior. What this principle says, quite simply, is that programs tend to access certain code sequences (e.g., in a loop) and data structures (e.g., an array accessed by the loop) quite frequently; we should thus try to use history to figure out which pages are important, and keep those pages in memory when it comes to eviction time.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: left;">And thus, a family of simple historically-based algorithms are born. The <b>Least-Frequently-Used </b>(<b>LFU</b>) policy replaces the least-frequently- used page when an eviction must take place. Similarly, the <b>Least-Recently- Used </b>(<b>LRU</b>) policy replaces the least-recently-used page. These algo- rithms are easy to remember: once you know the name, you know exactly what it does, which is an excellent property for a name.</p><p style="padding-left: 52pt;text-indent: 0pt;line-height: 10pt;text-align: left;">To better understand LRU, let’s examine how LRU does on our exam-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 95pt;text-indent: 0pt;line-height: 11pt;text-align: left;">A<span class="s7">SIDE</span>: <b>T</b><span class="s45">YPES OF </span><b>L</b><span class="s45">OCALITY</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">There are two types of locality that programs tend to exhibit. The first is known as <b>spatial locality</b>, which states that if a page <span class="s43">P </span>is accessed, it is likely the pages around it (say <span class="s43">P </span><span class="s4">− </span><span class="s44">1 </span>or <span class="s43">P </span><span class="s44">+ 1</span>) will also likely be accessed. The second is <b>temporal locality</b>, which states that pages that have been accessed in the near past are likely to be accessed again in the near future. The assumption of the presence of these types of locality plays a large role in the caching hierarchies of hardware systems, which deploy many levels of instruction, data, and address-translation caching to help programs run fast when such locality exists.</p><p style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Of course, the <b>principle of locality</b>, as it is often called, is no hard-and- fast rule that all programs must obey. Indeed, some programs access memory (or disk) in rather random fashion and don’t exhibit much or any locality in their access streams. Thus, while locality is a good thing to keep in mind while designing caches of any kind (hardware or software), it does not <i>guarantee </i>success. Rather, it is a heuristic that often proves useful in the design of computer systems.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">ple reference stream. Table <span style=" color: #00AEEF;">22.4 </span>shows the results. From the table, you can see how LRU can use history to do better than stateless policies such as Random or FIFO. In the example, LRU evicts page 2 when it first has to replace a page, because 0 and 1 have been accessed more recently. It then replaces page 0 because 1 and 3 have been accessed more recently. In both cases, LRU’s decision, based on history, turns out to be correct, and the next references are thus hits. Thus, in our simple example, LRU does as well as possible, matching optimal in its performance.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We should also note that the opposites of these algorithms exist: <b>Most- Frequently-Used </b>(<b>MFU</b>) and <b>Most-Recently-Used </b>(<b>MRU</b>). In most cases (not all!), these policies do not work well, as they ignore the locality most programs exhibit instead of embracing it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part228.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part230.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
