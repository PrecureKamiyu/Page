<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 45. Introduction to System V IPC</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch44.html" title="Chapter 44. Pipes and FIFOs"/><link rel="next" href="ch46.html" title="Chapter 46. System V Message Queues"/></head><body><section class="chapter" title="Chapter 45. Introduction to System V IPC" epub:type="chapter" id="introduction_to_system_v_ipc"><div class="titlepage"><div><div><h2 class="title">Chapter 45. Introduction to System V IPC</h2></div></div></div><p>System V IPC is the label used to refer to three different mechanisms for interprocess
                communication:<a id="IDX-CHP-45-6195" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Message queues</em></span> can be used to pass messages between
                    processes. Message queues are somewhat like pipes, but differ in two important
                    respects. First, message boundaries are preserved, so that readers and writers
                    communicate in units of messages, rather than via an undelimited byte stream.
                    Second, each message includes an integer <span class="emphasis"><em>type</em></span> field, and it
                    is possible to select messages by type, rather than reading them in the order in
                    which they were written.</p></li><li class="listitem"><p><span class="emphasis"><em>Semaphores</em></span> permit multiple processes to synchronize their
                    actions. A semaphore is a kernel-maintained integer value that is visible to all
                    processes that have the necessary permissions. A process indicates to its peers
                    that it is performing some action by making an appropriate modification to the
                    value of the semaphore.</p></li><li class="listitem"><p><span class="emphasis"><em>Shared memory</em></span> enables multiple processes to share the
                    same region (called a <span class="emphasis"><em>segment</em></span>) of memory (i.e., the same
                    page frames are mapped into the virtual memory of multiple processes). Since
                    access to user-space memory is a fast operation, shared memory is one of the
                    quickest methods of IPC: once one process has updated the shared memory, the
                    change is immediately visible to other processes sharing the same
                    segment.</p></li></ul></div><p>Although these three IPC mechanisms are quite diverse in function, there are good
            reasons for discussing them together. One reason is that they were developed together,
            first appearing in the late 1970s in Columbus UNIX. This was a Bell-internal UNIX
            implementation used for database and transaction-processing systems for telephone
            company record keeping and administration. Around 1983, these IPC mechanisms made their
            way into mainstream UNIX by appearing in System V—hence the appellation System V
                IPC.<a id="IDX-CHP-45-6196" class="indexterm"/></p><p>A more significant reason for discussing the System V IPC mechanisms together is that
            their programming interfaces share a number of common characteristics, so that many of
            the same concepts apply to all of these mechanisms.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Because System V IPC is required by SUSv3 for XSI conformance, it is sometimes
                alternatively labeled <span class="emphasis"><em>XSI IPC</em></span>.<a id="IDX-CHP-45-6197" class="indexterm"/></p></div><p>This chapter provides an overview of the System V IPC mechanisms and details those
            features that are common to all three mechanisms. The three mechanisms are then
            discussed individually in the following chapters.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>System V IPC is a kernel option that is configured via the CONFIG_SYSVIPC
                option.</p></div><div class="sect1" title="API Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="api_overview">API Overview</h2></div></div></div><p><a class="xref" href="ch45.html#summary_of_programming_interfaces_for_sy" title="Table 45-1. Summary of programming interfaces for System V IPC objects">Table 45-1</a> summarizes the header
                files and system calls used for working with System V IPC objects.<a id="IDX-CHP-45-6198" class="indexterm"/><a id="IDX-CHP-45-6199" class="indexterm"/><a id="IDX-CHP-45-6200" class="indexterm"/><a id="IDX-CHP-45-6201" class="indexterm"/><a id="IDX-CHP-45-6202" class="indexterm"/></p><p>Some implementations require the inclusion of <code class="literal">&lt;sys/types.h&gt;</code> before including the header files shown
                in <a class="xref" href="ch45.html#summary_of_programming_interfaces_for_sy" title="Table 45-1. Summary of programming interfaces for System V IPC objects">Table 45-1</a>. Some older UNIX
                implementations may also require the inclusion of <code class="literal">&lt;sys/ipc.h&gt;</code>. (No versions of the Single UNIX
                Specification required these header files.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On most hardware architectures on which Linux is implemented, a single system
                    call (<span class="emphasis"><em>ipc(2)</em></span>) acts as the entry point to the kernel for all
                    System V IPC operations, and all of the calls listed in <a class="xref" href="ch45.html#summary_of_programming_interfaces_for_sy" title="Table 45-1. Summary of programming interfaces for System V IPC objects">Table 45-1</a> are actually
                    implemented as library functions layered on top of this system call. (Two
                    exceptions to this arrangement are Alpha and IA-64, where the functions listed
                    in the table really are implemented as individual system calls.) This somewhat
                    unusual approach is an artifact of the initial implementation of System V IPC as
                    a loadable kernel module. Although they are actually library functions on most
                    Linux architectures, throughout this chapter, we’ll refer to the functions in
                        <a class="xref" href="ch45.html#summary_of_programming_interfaces_for_sy" title="Table 45-1. Summary of programming interfaces for System V IPC objects">Table 45-1</a> as system calls.
                    Only implementers of C libraries need to use <span class="emphasis"><em>ipc(2)</em></span>; any
                    other use in applications is not portable.</p></div><div class="table"><a id="summary_of_programming_interfaces_for_sy"/><div class="table-title">Table 45-1. Summary of programming interfaces for System V IPC objects</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Interface</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Message queues</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Semaphores</p>
                            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                <p>Shared memory</p>
                            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Header file</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">&lt;sys/msg.h&gt;</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">&lt;sys/sem.h&gt;</code>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <code class="literal">&lt;sys/shm.h&gt;</code>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Associated data structure</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>msqid_ds</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>semid_ds</em></span>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>shmid_ds</em></span>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Create/open object</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>msgget()</em></span>
                                    <a id="IDX-CHP-45-6203" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>semget()</em></span>
                                    <a id="IDX-CHP-45-6204" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p><span class="emphasis"><em>shmget()</em></span> +
                                        <span class="emphasis"><em>shmat()</em></span><a id="IDX-CHP-45-6206" class="indexterm"/><a id="IDX-CHP-45-6205" class="indexterm"/></p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Close object</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>(none)</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>(none)</p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>shmdt()</em></span>
                                    <a id="IDX-CHP-45-6207" class="indexterm"/>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>Control operations</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>msgctl()</em></span>
                                    <a id="IDX-CHP-45-6208" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>semctl()</em></span>
                                    <a id="IDX-CHP-45-6209" class="indexterm"/>
                                </p>
                            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                <p>
                                    <span class="emphasis"><em>shmctl()</em></span>
                                    <a id="IDX-CHP-45-6210" class="indexterm"/>
                                </p>
                            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p>Performing IPC</p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p><span class="emphasis"><em>msgsnd()</em></span>—write message
                                        <span class="emphasis"><em>msgrcv()</em></span>—read message<a id="IDX-CHP-45-6211" class="indexterm"/><a id="IDX-CHP-45-6212" class="indexterm"/></p>
                            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                <p><span class="emphasis"><em>semop()</em></span>—test/adjust semaphore<a id="IDX-CHP-45-6213" class="indexterm"/></p>
                            </td><td style="text-align: left; vertical-align: top; ">
                                <p>access memory in shared region</p>
                            </td></tr></tbody></table></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="creating_and_opening_a_system_v_ipc"/></div></div></div><div class="sect3" title="Creating and opening a System V IPC object"><div class="titlepage"><div><div><h4 class="title" id="creating_and_opening_a_system_v_ipc-id1">Creating and opening a System V IPC object</h4></div></div></div><p>Each System V IPC mechanism has an associated <span class="emphasis"><em>get</em></span>
                        system call (<span class="emphasis"><em>msgget()</em></span>, <span class="emphasis"><em>semget()</em></span>,
                        or <span class="emphasis"><em>shmget()</em></span>), which is analogous to the
                            <span class="emphasis"><em>open()</em></span> system call used for files. Given an integer
                            <span class="emphasis"><em>key</em></span> (analogous to a filename), the
                            <span class="emphasis"><em>get</em></span> call either:<a id="IDX-CHP-45-6214" class="indexterm"/><a id="IDX-CHP-45-6215" class="indexterm"/><a id="IDX-CHP-45-6216" class="indexterm"/><a id="IDX-CHP-45-6217" class="indexterm"/><a id="IDX-CHP-45-6218" class="indexterm"/><a id="IDX-CHP-45-6219" class="indexterm"/><a id="IDX-CHP-45-6220" class="indexterm"/><a id="IDX-CHP-45-6221" class="indexterm"/><a id="IDX-CHP-45-6222" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>creates a new IPC object with the given key and returns a unique
                                identifier for that object; or<a id="IDX-CHP-45-6223" class="indexterm"/></p></li><li class="listitem"><p>returns the identifier of an existing IPC object with the given
                                key.</p></li></ul></div><p>We’ll (loosely) term the second use <span class="emphasis"><em>opening</em></span> an
                        existing IPC object. In this case, all that the <span class="emphasis"><em>get</em></span>
                        call is doing is converting one number (the key) into another number (the
                        identifier).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In the context of System V IPC, the <span class="emphasis"><em>object</em></span>
                            doesn’t carry any of the connotations associated with object-oriented
                            programming. The term merely serves to distinguish the System V IPC
                            mechanisms from files. Although there are several analogies between
                            files and System V IPC objects, the use of IPC objects differs in
                            several important respects from the standard UNIX file I/O model, and
                            this is a source of some complications when using the System V IPC
                            mechanisms.</p></div><p>An IPC <span class="emphasis"><em>identifier</em></span> is analogous to a file descriptor
                        in that it is used in all subsequent system calls to refer to the IPC
                        object. There is, however, an important semantic difference. Whereas a file
                        descriptor is a process attribute, an IPC identifier is a property of the
                        object itself and is visible system-wide. All processes accessing the same
                        object use the same identifier. This means that if we know an IPC object
                        already exists, we can skip the <span class="emphasis"><em>get</em></span> call, provided we
                        have some other means of knowing the identifier of the object. For example,
                        the process that created the object might write the identifier to a file
                        that can then be read by other processes.</p><p>The following example shows how to create a System V message queue:</p><a id="I_programlisting45_d1e120107"/><pre class="programlisting">id = msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR);
if (id == -1)
    errExit("msgget");</pre><p>As with all of the <span class="emphasis"><em>get</em></span> calls, the key is the first
                        argument, and the identifier is returned as the function result. We specify
                        the permissions to be placed on the new object as part of the final
                            (<span class="emphasis"><em>flags</em></span>) argument to the <span class="emphasis"><em>get</em></span>
                        call, using the same bit-mask constants as are used for files (<a class="xref" href="ch15.html#constants_for_file_permission_bits" title="Table 15-4. Constants for file permission bits">Table 15-4</a>, in <a class="xref" href="ch15.html#permissions_on_regular_files" title="Permissions on Regular Files">Permissions on Regular Files</a>). In the above example,
                        permission is granted to just the owner of the object to read and write
                        messages on the queue.</p><p>The process umask (<a class="xref" href="ch15.html#the_process_file_mode_creation_mask_colo" title="The Process File Mode Creation Mask: umask()">The Process File Mode Creation Mask: <span class="emphasis"><em>umask()</em></span></a>) is not applied to
                        the permissions placed on a newly created IPC object.<a id="IDX-CHP-45-6224" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Several UNIX implementations define the following bit-mask constants
                            for IPC permissions: <code class="literal">MSG_R, MSG_W, SEM_R,
                                SEM_A, SHM_R</code>, and <code class="literal">SHM_W</code>. These correspond to owner (user) read and write
                            permissions for each IPC mechanism. To get the corresponding group and
                            other permission bit masks, these constants can be right-shifted 3 and 6
                            bits. These constants are not specified by SUSv3, which employs the same
                            bit masks as are used for files, and are not defined in
                                <span class="emphasis"><em>glibc</em></span> headers.</p></div><p>Each process that wants to access the same IPC object performs a
                            <span class="emphasis"><em>get</em></span> call specifying the same key in order to obtain
                        the same identifier for that object. We consider how to choose a key for an
                        application in Section 45.2.</p><p>If no IPC object corresponding to the given key currently exists, and
                            <code class="literal">IPC_CREAT</code> (analogous to the
                            <span class="emphasis"><em>open()</em></span>
                        <code class="literal">O_CREAT</code> flag) was specified as part of
                        the <span class="emphasis"><em>flags</em></span> argument, then the <span class="emphasis"><em>get</em></span>
                        call creates a new IPC object. If no corresponding IPC object currently
                        exists, and <code class="literal">IPC_CREAT</code> was not specified
                        (and the key was not specified as <code class="literal">IPC_PRIVATE</code>, described in <a class="xref" href="ch45.html#ipc_keys" title="IPC Keys">IPC Keys</a>), then
                        the <span class="emphasis"><em>get</em></span> call fails with the error <code class="literal">ENOENT</code>.</p><p>A process can guarantee that it is the one creating an IPC object by
                        specifying the <code class="literal">IPC_EXCL</code> flag (analogous
                        to the <span class="emphasis"><em>open()</em></span>
                        <code class="literal">O_EXCL</code> flag). If <code class="literal">IPC_EXCL</code> is specified and the IPC object corresponding to the
                        given key already exists, then the <span class="emphasis"><em>get</em></span> call fails with
                        the error <code class="literal">EEXIST</code>.</p></div><div class="sect3" title="IPC object deletion and object persistence"><div class="titlepage"><div><div><h4 class="title" id="ipc_object_deletion_and_object_persisten">IPC object deletion and object persistence</h4></div></div></div><p>The ctl system call (<span class="emphasis"><em>msgctl(), semctl(), shmctl()</em></span>)
                        for each System V IPC mechanism performs a range of <span class="emphasis"><em>control
                            operations</em></span> for the object. Many of these operations are
                        specific to the IPC mechanism, but a few are generic to all IPC mechanisms.
                        An example of a generic control operation is <code class="literal">IPC_RMID</code>, which is used to delete an object. For example, we
                        can use the following call to delete a shared memory object:<a id="IDX-CHP-45-6226" class="indexterm"/><a id="IDX-CHP-45-6227" class="indexterm"/><a id="IDX-CHP-45-6228" class="indexterm"/><a id="IDX-CHP-45-6229" class="indexterm"/><a id="IDX-CHP-45-6230" class="indexterm"/><a id="IDX-CHP-45-6225" class="indexterm"/><a id="IDX-CHP-45-6231" class="indexterm"/></p><a id="I_programlisting45_d1e120256"/><pre class="programlisting">if (shmctl(id, IPC_RMID, NULL) == -1)
    errExit("shmctl");</pre><p>For message queues and semaphores, deletion of the IPC object is
                        immediate, and any information contained within the object is destroyed,
                        regardless of whether any other process is still using the object. (This is
                        one of a number of points where the operation of System IPC objects is not
                        analogous to files. In <a class="xref" href="ch18.html#creating_and_removing_open_parenthesis_h" title="Creating and Removing (Hard) Links: link() and unlink()">Creating and Removing (Hard) Links: <span class="emphasis"><em>link</em></span>() and
                    <span class="emphasis"><em>unlink</em></span>()</a>, we saw that if we
                        remove the last link to a file, then the file is actually removed only after
                        all open file descriptors referring to it have been closed.)</p><p>Deletion of shared memory objects occurs differently. Following the
                            <span class="emphasis"><em>shmctl(id, IPC_RMID, NULL)</em></span> call, the shared memory
                        segment is removed only after all processes using the segment detach it
                        (using <span class="emphasis"><em>shmdt()</em></span>). (This is much closer to the situation
                        with file deletion.)</p><p>System V IPC objects have kernel persistence. Once created, an object
                        continues to exist until it is explicitly deleted or the system is shut
                        down. This property of System V IPC objects can be advantageous. It is
                        possible for a process to create an object, modify its state, and then exit,
                        leaving the object to be accessed by some process that is started at a later
                        time. It can also be disadvantageous for the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There are system-imposed limits on the number of IPC objects of
                                each type. If we fail to remove unused objects, we may eventually
                                encounter application errors as a result of reaching these
                                limits.</p></li><li class="listitem"><p>When deleting a message queue or semaphore object, a multiprocess
                                application may not be able to easily determine which will be the
                                last process requiring access to the object, and thus when the
                                object can be safely deleted. The problem is that these objects are
                                    <span class="emphasis"><em>connectionless</em></span>—the kernel doesn’t keep a
                                record of which processes have the object open. (This disadvantage
                                doesn’t apply for shared memory segments, because of their different
                                deletion semantics, described above.)<a id="IDX-CHP-45-6232" class="indexterm"/></p></li></ul></div></div></div></div><div class="sect1" title="IPC Keys"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ipc_keys">IPC Keys</h2></div></div></div><p>System V IPC keys are integer values represented using the data type
                    <span class="emphasis"><em>key_t</em></span>. The IPC <span class="emphasis"><em>get</em></span> calls translate a
                key into the corresponding integer IPC identifier. These calls guarantee that if we
                create a new IPC object, then that object will have a unique identifier, and that if
                we specify the key of an existing object, then we’ll always obtain the (same)
                identifier for that object. (Internally, the kernel maintains data structures
                mapping keys to identifiers for each IPC mechanism, as described in Section
                    45.5.)<a id="IDX-CHP-45-6233" class="indexterm"/></p><p>So, how do we provide a unique key—one that guarantees that we won’t accidentally
                obtain the identifier of an existing IPC object used by some other application?
                There are three possibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Randomly choose some integer key value, which is typically placed in a
                        header file included by all programs using the IPC object. The difficulty
                        with this approach is that we may accidentally choose a value used by
                        another application.</p></li><li class="listitem"><p>Specify the <code class="literal">IPC_PRIVATE</code> constant as the
                            <span class="emphasis"><em>key</em></span> value to the <span class="emphasis"><em>get</em></span> call when
                        creating the IPC object, which always results in the creation of a new IPC
                        object that is guaranteed to have a unique key.<a id="IDX-CHP-45-6234" class="indexterm"/></p></li><li class="listitem"><p>Employ the <span class="emphasis"><em>ftok()</em></span> function to generate a (likely
                        unique) key.<a id="IDX-CHP-45-6235" class="indexterm"/></p></li></ul></div><p>Using either <code class="literal">IPC_PRIVATE</code> or
                    <span class="emphasis"><em>ftok()</em></span> is the usual technique.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="generating_a_unique_key_with_ipc"/></div></div></div><div class="sect3" title="Generating a unique key with IPC_PRIVATE"><div class="titlepage"><div><div><h4 class="title" id="generating_a_unique_key_with_ipc-id1">Generating a unique key with <code class="literal">IPC_PRIVATE</code></h4></div></div></div><p>When creating a new IPC object, the key may be specified as <code class="literal">IPC_PRIVATE</code>, as follows:<a id="IDX-CHP-45-6236" class="indexterm"/><a id="IDX-CHP-45-6237" class="indexterm"/><a id="IDX-CHP-45-6238" class="indexterm"/><a id="IDX-CHP-45-6239" class="indexterm"/></p><a id="I_programlisting45_d1e120380"/><pre class="programlisting">id = msgget(IPC_PRIVATE, S_IRUSR | S_IWUSR);</pre><p>In this case, it is not necessary to specify the <code class="literal">IPC_CREAT</code> or <code class="literal">IPC_EXCL</code>
                        flags.</p><p>This technique is especially useful in multiprocess applications where the
                        parent process creates the IPC object prior to performing a
                            <span class="emphasis"><em>fork()</em></span>, with the result that the child inherits the
                        identifier of the IPC object. We can also use this technique in
                        client-server applications (i.e., those involving unrelated processes), but
                        the clients must have a means of obtaining the identifiers of the IPC
                        objects created by the server (and vice versa). For example, after creating
                        an IPC object, the server could then write its identifier to a file that can
                        be read by the clients.</p></div><div class="sect3" title="Generating a unique key with ftok()"><div class="titlepage"><div><div><h4 class="title" id="generating_a_unique_key_with_ftok_open_p">Generating a unique key with <span class="emphasis"><em>ftok()</em></span></h4></div></div></div><p>The <span class="emphasis"><em>ftok()</em></span> (<span class="emphasis"><em>file to key</em></span>)
                        function returns a key value suitable for use in a subsequent call to one of
                        the System V IPC <span class="emphasis"><em>get</em></span> system calls.</p><a id="I_programlisting45_d1e120411"/><pre class="programlisting">#include &lt;sys/ipc.h&gt;

key_t <strong class="userinput"><code>ftok</code></strong>(char *<span class="emphasis"><em>pathname</em></span>, int <span class="emphasis"><em>proj</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns integer key on success, or -1 on error</p></div><p>This key value is generated from the supplied
                            <span class="emphasis"><em>pathname</em></span> and <span class="emphasis"><em>proj</em></span> value using
                        an implementation-defined algorithm. SUSv3 makes the following
                        requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Only the least significant 8 bits of <span class="emphasis"><em>proj</em></span> are
                                employed by the algorithm.</p></li><li class="listitem"><p>The application must ensure that the <span class="emphasis"><em>pathname</em></span>
                                refers to an existing file to which <span class="emphasis"><em>stat()</em></span> can
                                be applied (otherwise, <span class="emphasis"><em>ftok()</em></span> returns
                                -1).</p></li><li class="listitem"><p>If different pathnames (links) referring to the same file (i.e.,
                                i-node) are supplied to <span class="emphasis"><em>ftok()</em></span> with the same
                                    <span class="emphasis"><em>proj</em></span> value, the same key value must be
                                returned.</p></li></ul></div><p>To put things another way, <span class="emphasis"><em>ftok()</em></span> uses the i-node
                        number rather than the name of the file to generate the key value. (Because
                        the <span class="emphasis"><em>ftok()</em></span> algorithm depends on the i-node number, the
                        file should not be removed and re-created during the life of the
                        application, since it is likely that the file will be re-created with a
                        different i-node number.) The purpose of the <span class="emphasis"><em>proj</em></span> value
                        is simply to allow us to generate multiple keys from the same file, which is
                        useful when an application needs to create multiple IPC objects of the same
                        type. Historically, the <span class="emphasis"><em>proj</em></span> argument was of type
                            <span class="emphasis"><em>char</em></span>, and it is often specified as such in calls to
                            <span class="emphasis"><em>ftok()</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 leaves the behavior of <span class="emphasis"><em>ftok()</em></span> unspecified
                            if <span class="emphasis"><em>proj</em></span> is 0. Under AIX 5.1,
                                <span class="emphasis"><em>ftok()</em></span> returns -1 if <span class="emphasis"><em>proj</em></span>
                            is specified as 0. On Linux, this value has no special meaning.
                            Nevertheless, portable applications should avoid specifying
                                <span class="emphasis"><em>proj</em></span> as 0; this still leaves a choice of 255
                            other values.</p></div><p>Normally, the <span class="emphasis"><em>pathname</em></span> given to
                            <span class="emphasis"><em>ftok()</em></span> refers to one of the files or directories
                        that forms part of, or is created by, the application, and cooperating
                        processes pass the same <span class="emphasis"><em>pathname</em></span> to
                            <span class="emphasis"><em>ftok()</em></span>.</p><p>On Linux, the key returned by <span class="emphasis"><em>ftok()</em></span> is a 32-bit
                        value, created by taking the least significant 8 bits from the
                            <span class="emphasis"><em>proj</em></span> argument, the least significant 8 bits of the
                        device number (i.e., the minor device number) of the device containing the
                        file system in which the file resides, and the least significant 16 bits of
                        the i-node number of the file referred to by <span class="emphasis"><em>pathname</em></span>.
                        (The last two pieces of information are obtained by calling
                            <span class="emphasis"><em>stat()</em></span> on <span class="emphasis"><em>pathname</em></span>.)</p><p>The <span class="emphasis"><em>glibc ftok()</em></span> algorithm is similar to that
                        employed on other UNIX implementations, and suffers a similar limitation:
                        there is a (very small) possibility that two different files could yield the
                        same key value. This can occur because there is a chance that the least
                        significant bits of an i-node number could be the same for two files on
                        different file systems, coupled with the possibility that two different disk
                        devices (on a system with multiple disk controllers) could have the same
                        minor device number. However, in practice, the possibility of colliding key
                        values for different applications is small enough that the use of
                            <span class="emphasis"><em>ftok()</em></span> for key generation is a viable
                        technique.</p><p>A typical usage of <span class="emphasis"><em>ftok()</em></span> is the following:</p><a id="I_programlisting45_d1e120545"/><pre class="programlisting">key_t key;
int id;

key = ftok("/mydir/myfile", 'x');
if (key == -1)
    errExit("ftok");
id = msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR);
if (id == -1)
    errExit("msgget");</pre></div></div></div><div class="sect1" title="Associated Data Structure and Object Permissions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="associated_data_structure_and_object_per">Associated Data Structure and Object Permissions</h2></div></div></div><p>The kernel maintains an associated data structure for each instance of a System V
                IPC object. The form of this data structure varies according to the IPC mechanism
                (message queue, semaphore, or shared memory) and is defined in the corresponding
                header file for the IPC mechanism (see <a class="xref" href="ch45.html#summary_of_programming_interfaces_for_sy" title="Table 45-1. Summary of programming interfaces for System V IPC objects">Table 45-1</a>). We discuss
                mechanism-specific details of each of these data structures in the following
                    chapters.<a id="IDX-CHP-45-6240" class="indexterm"/><a id="IDX-CHP-45-6241" class="indexterm"/><a id="IDX-CHP-45-6242" class="indexterm"/><a id="IDX-CHP-45-6243" class="indexterm"/><a id="IDX-CHP-45-6244" class="indexterm"/><a id="IDX-CHP-45-6245" class="indexterm"/><a id="IDX-CHP-45-6246" class="indexterm"/><a id="IDX-CHP-45-6247" class="indexterm"/><a id="IDX-CHP-45-6248" class="indexterm"/><a id="IDX-CHP-45-6249" class="indexterm"/><a id="IDX-CHP-45-6250" class="indexterm"/><a id="IDX-CHP-45-6251" class="indexterm"/><a id="IDX-CHP-45-6252" class="indexterm"/><a id="IDX-CHP-45-6253" class="indexterm"/><a id="IDX-CHP-45-6254" class="indexterm"/><a id="IDX-CHP-45-6255" class="indexterm"/></p><p>The associated data structure for an IPC object is initialized when the object is
                created via the appropriate <span class="emphasis"><em>get</em></span> system call. Once the object
                has been created, a program can obtain a copy of this data structure using the
                appropriate <span class="emphasis"><em>ctl</em></span> system call, by specifying an operation type of
                    <code class="literal">IPC_STAT</code>. Conversely, some parts of the data
                structure can be modified using the <code class="literal">IPC_SET</code>
                operation.</p><p>As well as data specific to the type of IPC object, the associated data structure
                for all three IPC mechanisms includes a substructure, <span class="emphasis"><em>ipc_perm</em></span>,
                that holds information used to determine permissions granted on the
                    object:<a id="IDX-CHP-45-6256" class="indexterm"/></p><a id="I_programlisting45_d1e120672"/><pre class="programlisting">struct ipc_perm {
    key_t          __key;           /* Key, as supplied to 'get' call */
    uid_t          uid;             /* Owner's user ID */
    gid_t          gid;             /* Owner's group ID */
    uid_t          cuid;            /* Creator's user ID */
    gid_t          cgid;            /* Creator's group ID */
    unsigned short mode;            /* Permissions */
    unsigned short __seq;           /* Sequence number */
};</pre><p>SUSv3 mandates all of the <span class="emphasis"><em>ipc_perm</em></span> fields shown here, except
                    <span class="emphasis"><em>__key</em></span> and <span class="emphasis"><em>__seq</em></span>. However, most UNIX
                implementations provide some version of these fields.</p><p>The <span class="emphasis"><em>uid</em></span> and <span class="emphasis"><em>gid</em></span> fields specify the
                ownership of the IPC object. The <span class="emphasis"><em>cuid</em></span> and
                    <span class="emphasis"><em>cgid</em></span> fields hold the user and group IDs of the process that
                created the object. Initially, the corresponding user and creator ID fields have the
                same values, which are taken from the effective IDs of the calling processes. The
                creator IDs are immutable, but the owner IDs can be changed via the <code class="literal">IPC_SET</code> operation. The following code demonstrates how
                to change the uid field for a shared memory segment (the associated data structure
                is of type <span class="emphasis"><em>shmid_ds</em></span>):</p><a id="I_programlisting45_d1e120706"/><pre class="programlisting">struct shmid_ds shmds;

if (shmctl(id, IPC_STAT, &amp;shmds) == -1)     /* Fetch from kernel */
    errExit("shmctl");
shmds.shm_perm.uid = newuid;                /* Change owner UID */
if (shmctl(id, IPC_SET, &amp;shmds) == -1)      /* Update kernel copy */
    errExit("shmctl");</pre><p>The <span class="emphasis"><em>mode</em></span> field of the <span class="emphasis"><em>ipc_perm</em></span>
                substructure holds the permissions mask for the IPC object. These permissions are
                initialized using the lower 9 bits of the <span class="emphasis"><em>flags</em></span> specified in
                the <span class="emphasis"><em>get</em></span> system call used to create the object, but can be
                changed subsequently using the <code class="literal">IPC_SET</code>
                operation.</p><p>As with files, permissions are broken into three
                    categories—<span class="emphasis"><em>owner</em></span> (also known as <span class="emphasis"><em>user</em></span>),
                    <span class="emphasis"><em>group</em></span>, and <span class="emphasis"><em>other</em></span>—and it is possible to
                specify different permissions for each category. There are, however, some notable
                differences from the scheme used for files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Only read and write permissions are meaningful for IPC objects. (For
                        semaphores, write permission is commonly referred to as
                            <span class="emphasis"><em>alter</em></span> permission.) Execute permission is
                        meaningless, and is ignored when performing most access checks.</p></li><li class="listitem"><p>Permission checks are made according to a process’s effective user ID,
                        effective group IDs, and supplementary group IDs. (This contrasts with
                        file-system permission checks on Linux, which are performed using the
                        process’s file-system IDs, as described in Section 9.5.)</p></li></ul></div><p>The precise rules governing the permissions a process is granted on an IPC object
                are as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>If the process is privileged (<code class="literal">CAP_IPC_OWNER</code>), then all permissions are granted on the IPC
                        object.</p></li><li class="listitem"><p>If the effective user ID of the process matches either the owner or the
                        creator user ID of the IPC object, then the process is granted the
                        permissions defined for the <span class="emphasis"><em>owner</em></span>
                            (<span class="emphasis"><em>user</em></span>) of the object.</p></li><li class="listitem"><p>If the effective group ID or any of the supplementary group IDs of the
                        process match either the owner group ID or the creator group ID of the IPC
                        object, then the process is granted the <span class="emphasis"><em>group</em></span>
                        permissions defined for the object.</p></li><li class="listitem"><p>Otherwise, the process is granted the permissions defined for
                            <span class="emphasis"><em>other</em></span>.</p></li></ol></div><div class="note" title="Note"><h3 class="title">Note</h3><p>In the kernel code, the above tests are constructed so that the test to see
                    whether a process is privileged is performed only if the process is not granted
                    the permissions it needs via one of the other tests. This is done to avoid
                    unnecessarily setting the <code class="literal">ASU</code> process
                    accounting flag, which indicates that the process made use of superuser
                    privileges (<a class="xref" href="ch28.html#process_accounting" title="Process Accounting">Process Accounting</a>).</p><p>Note that neither the use of the <code class="literal">IPC_PRIVATE</code> key value nor the presence of <code class="literal">IPC_EXCL</code> flag has any bearing on which processes
                    may access an IPC object; such access is determined solely by the ownership and
                    permissions of the object.</p></div><p>How read and write permissions are interpreted for an object, and whether they are
                required, depend on the type of object and on the operation being performed.</p><p>When a <span class="emphasis"><em>get</em></span> call is performed to obtain the identifier of an
                existing IPC object, an initial permission check is made to ascertain whether the
                permissions specified in the <span class="emphasis"><em>flags</em></span> argument are compatible with
                those on the existing object. If not, then the <span class="emphasis"><em>get</em></span> call fails
                with the error <code class="literal">EACCES</code>. (Except as otherwise
                noted, this error code is also returned when permissions are denied in each of the
                cases listed below.) To illustrate, consider the example of two different users in
                the same group, with one user creating a message queue using the following
                call:</p><a id="I_programlisting45_d1e120812"/><pre class="programlisting">msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP);
                        /* rw-r----- */</pre><p>An attempt by the second user to obtain an identifier for this message queue using
                the following call would fail, since the user is not permitted write access to the
                message queue:</p><a id="I_programlisting45_d1e120816"/><pre class="programlisting">msgget(key, S_IRUSR | S_IWUSR);</pre><p>The second user could bypass this check by specifying 0 for the second argument of
                the <span class="emphasis"><em>msgget()</em></span> call, in which case an error would occur only when
                the program attempted an operation requiring write permission on the IPC object
                (e.g., writing a message with <span class="emphasis"><em>msgsnd()</em></span>).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>get</em></span> call represents the one case where execute
                    permission is not ignored. Even though it has no meaning for IPC objects, if
                    execute permission is requested in a <span class="emphasis"><em>get</em></span> call for an
                    existing object, then a check is made to see if that permission is
                    granted.</p></div><p>The permissions required for other common operations are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To retrieve information from the object (e.g., to read a message from a
                        message queue, obtain the value of a semaphore, or attach a shared memory
                        segment for read access) requires read permission.</p></li><li class="listitem"><p>To update information within the object (e.g., to write a message to a
                        message queue, change the value of a semaphore, or attach a shared memory
                        segment for write access) requires write permission.</p></li><li class="listitem"><p>To obtain a copy of the associated data structure for an IPC object (the
                            <code class="literal">IPC_STAT</code>
                        <span class="emphasis"><em>ctl</em></span> operation) requires read permission.</p></li><li class="listitem"><p>To remove an IPC object (the <code class="literal">IPC_RMID</code>
                        <span class="emphasis"><em>ctl</em></span> operation) or change its associated data structure
                        (the <code class="literal">IPC_SET</code>
                        <span class="emphasis"><em>ctl</em></span> operation) requires neither read nor write
                        permission. Rather, the calling process must either be privileged (<code class="literal">CAP_SYS_ADMIN</code>) or have an effective user ID
                        matching either the owner user ID or the creator user ID of the object
                        (otherwise, the error <code class="literal">EPERM</code>
                        results).</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>It is possible to set the permissions on an IPC object so that the owner or
                    creator can no longer use <code class="literal">IPC_STAT</code> to obtain
                    the associated data structure containing the object permissions (which means
                    that the object won’t be displayed by the <span class="emphasis"><em>ipcs(1)</em></span> command
                    described in <a class="xref" href="ch45.html#the_ipcs_and_ipcrm_commands" title="The ipcs and ipcrm Commands">The <span class="emphasis"><em>ipcs</em></span> and <span class="emphasis"><em>ipcrm</em></span> Commands</a>), although <code class="literal">IPC_SET</code> can still be used to change them.</p></div><p>Various other mechanism-specific operations require read or write permission, or
                the <code class="literal">CAP_IPC_OWNER</code> capability. We note the
                required permissions in the following chapters as the operations are
                    described.<a id="IDX-CHP-45-6257" class="indexterm"/></p></div><div class="sect1" title="IPC Identifiers and Client-Server Applications"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ipc_identifiers_and_client-server_applic">IPC Identifiers and Client-Server Applications</h2></div></div></div><p>In client-server applications, the server typically creates the System V IPC
                objects, while the client simply accesses them. In other words, the server performs
                an IPC <span class="emphasis"><em>get</em></span> call specifying the flag <code class="literal">IPC_CREAT</code>, while the client omits this flag in its
                    <span class="emphasis"><em>get</em></span> call.<a id="IDX-CHP-45-6258" class="indexterm"/><a id="IDX-CHP-45-6259" class="indexterm"/><a id="IDX-CHP-45-6260" class="indexterm"/><a id="IDX-CHP-45-6261" class="indexterm"/><a id="IDX-CHP-45-6262" class="indexterm"/><a id="IDX-CHP-45-6263" class="indexterm"/><a id="IDX-CHP-45-6264" class="indexterm"/><a id="IDX-CHP-45-6265" class="indexterm"/></p><p>Suppose a client engages in an extended dialogue with a server, with multiple IPC
                operations being performed by each process (e.g., multiple messages exchanged, a
                sequence of semaphore operations, or multiple updates to shared memory). What
                happens if the server process crashes or is deliberately halted and then restarted?
                At this point, it would make no sense to blindly reuse the existing IPC object
                created by the previous server process, since the new server process has no
                knowledge of the historical information associated with the current state of the IPC
                object. (For example, there may be a secondary request within a message queue that
                was sent by a client in response to an earlier message from the old server
                process.)</p><p>In such a scenario, the only option for the server may be to abandon all existing
                clients, delete the IPC objects created by the previous server process, and create
                new instances of the IPC objects. A newly started server handles the possibility
                that a previous instance of the server terminated prematurely by first trying to
                create an IPC object by specifying both the <code class="literal">IPC_CREAT</code> and the <code class="literal">IPC_EXCL</code> flags
                within the <span class="emphasis"><em>get</em></span> call. If the <span class="emphasis"><em>get</em></span> call fails
                because an object with the specified key already exists, then the server assumes the
                object was created by an old server process; it therefore uses the <code class="literal">IPC_RMID</code>
                <span class="emphasis"><em>ctl</em></span> operation to delete the object, and once more performs a
                get call to create the object. (This may be combined with other steps to ensure that
                another server process is not currently running, such as those described in Section
                55.6.) For a message queue, these steps might appear as shown in <a class="xref" href="ch45.html#cleanup_of_ipc_objects_within_a_server" title="Example 45-1. Cleanup of IPC objects within a server">Example 45-1</a>.</p><div class="example"><a id="cleanup_of_ipc_objects_within_a_server"/><div class="example-title">Example 45-1. Cleanup of IPC objects within a server</div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>svipc/svmsg_demo_server.c</code></strong>
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;sys/stat.h&gt;
#include "tlpi_hdr.h"

#define KEY_FILE "/some-path/some-file"
                                /* Should be an existing file or one
                                   that this program creates */

int
main(int argc, char *argv[])
{
    int msqid;
    key_t key;
    const int MQ_PERMS = S_IRUSR | S_IWUSR | S_IWGRP;   /* rw--w---- */

    /* Optional code here to check if another server process is
       already running */

    /* Generate the key for the message queue */

    key = ftok(KEY_FILE, 1);
    if (key == -1)
        errExit("ftok");

    /* While msgget() fails, try creating the queue exclusively */

    while ((msqid = msgget(key, IPC_CREAT | IPC_EXCL | MQ_PERMS)) == -1) {
        if (errno == EEXIST) {          /* MQ with the same key already
                                           exists - remove it and try again */
            msqid = msgget(key, 0);
            if (msqid == -1)
                errExit("msgget() failed to retrieve old queue ID");
            if (msgctl(msqid, IPC_RMID, NULL) == -1)
                errExit("msgget() failed to delete old queue");
            printf("Removed old message queue (id=%d)\n", msqid);

        } else {                        /* Some other error --&gt; give up */
            errExit("msgget() failed");
        }
    }

    /* Upon loop exit, we've successfully created the message queue,
       and we can then carry on to do other work... */

    exit(EXIT_SUCCESS);
}
     <strong class="userinput"><code>svipc/svmsg_demo_server.c</code></strong></pre></div></div><p>Even if a restarted server re-created the IPC objects, there still would be a
                potential problem if supplying the same key to the <span class="emphasis"><em>get</em></span> call
                always generated the same identifier whenever a new IPC object was created. Consider
                the solution just outlined from the point of view of the client. If the IPC objects
                re-created by the server use the same identifiers, then the client would have no way
                of becoming aware that the server has been restarted and that the IPC objects don’t
                contain the expected historical information.<a id="IDX-CHP-45-6266" class="indexterm"/></p><p>To solve this problem, the kernel employs an algorithm (described in the next
                section) that normally ensures that when a new IPC object is created, the object’s
                identifier will be different, even when the same key is supplied. Consequently, any
                clients of the old server process that attempt to use the old identifier will
                receive an error from the relevant IPC system call.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Solutions such as that shown in <a class="xref" href="ch45.html#cleanup_of_ipc_objects_within_a_server" title="Example 45-1. Cleanup of IPC objects within a server">Example 45-1</a> don’t completely solve
                    the problem of identifying a server restart when using System V shared memory,
                    since a shared memory object is deleted only when all processes have detached it
                    from their virtual address space. However, shared memory objects are typically
                    used in conjunction with System V semaphores, which <span class="emphasis"><em>are</em></span>
                    immediately deleted in response to an <code class="literal">IPC_RMID</code> operation. This means that a client process will become
                    aware of a server restart when it tries to access the deleted semaphore
                    object.</p></div></div><div class="sect1" title="Algorithm Employed by System V IPC get Calls"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="algorithm_employed_by_system_v_ipc_get_c">Algorithm Employed by System V IPC <span class="emphasis"><em>get</em></span> Calls</h2></div></div></div><p><a class="xref" href="ch45.html#kernel_data_structures_used_to_represent" title="Figure 45-1. Kernel data structures used to represent System V IPC (semaphore) objects">Figure 45-1</a> shows some of the
                structures used internally by the kernel to represent information about System V IPC
                objects (in this case semaphores, but the details are similar for other IPC
                mechanisms), including the fields used to calculate IPC keys. For each IPC mechanism
                (shared memory, message queue, or semaphore), the kernel maintains an associated
                    <span class="emphasis"><em>ipc_ids</em></span> structure that records various global information
                about all instances of that IPC mechanism. This information includes a dynamically
                sized array of pointers, <span class="emphasis"><em>entries</em></span>, to the associated data
                structure for each object instance (<span class="emphasis"><em>semid_ds</em></span> structures in the
                case of semaphores). The current size of the <span class="emphasis"><em>entries</em></span> array is
                recorded in the <span class="emphasis"><em>size</em></span> field, with the
                    <span class="emphasis"><em>max_id</em></span> field holding the index of the highest currently
                in-use element.<a id="IDX-CHP-45-6267" class="indexterm"/><a id="IDX-CHP-45-6268" class="indexterm"/><a id="IDX-CHP-45-6269" class="indexterm"/><a id="IDX-CHP-45-6270" class="indexterm"/><a id="IDX-CHP-45-6271" class="indexterm"/><a id="IDX-CHP-45-6272" class="indexterm"/></p><div class="figure"><a id="kernel_data_structures_used_to_represent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject45_d1e121083"/><img src="figs/web/45-1_SVIPC-data-structures.png.jpg" alt="Kernel data structures used to represent System V IPC (semaphore) objects"/></div></div><div class="figure-title">Figure 45-1. Kernel data structures used to represent System V IPC (semaphore)
                    objects</div></div><p>When an IPC <span class="emphasis"><em>get</em></span> call is made, the algorithm used on Linux
                (other systems use similar algorithms) is approximately as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The list of associated data structures (pointed to by elements of the
                            <span class="emphasis"><em>entries</em></span> array) is searched for one whose
                            <span class="emphasis"><em>key</em></span> field matches that specified in the
                            <span class="emphasis"><em>get</em></span> call.</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>If no match is found, and <code class="literal">IPC_CREAT</code> was not specified, then the error <code class="literal">ENOENT</code> is returned.</p></li><li class="listitem"><p>If a match is found, but both <code class="literal">IPC_CREAT</code> and <code class="literal">IPC_EXCL</code> were specified, then the error <code class="literal">EEXIST</code> is returned.</p></li><li class="listitem"><p>Otherwise, if a match is found, then the following step is
                                skipped.</p></li></ol></div></li><li class="listitem"><p>If no match was found, and <code class="literal">IPC_CREAT</code>
                        was specified, then a new mechanism-specific associated data structure
                            (<span class="emphasis"><em>semid_ds</em></span> in <a class="xref" href="ch45.html#kernel_data_structures_used_to_represent" title="Figure 45-1. Kernel data structures used to represent System V IPC (semaphore) objects">Figure 45-1</a>) is allocated and
                        initialized. This also involves updating various fields of the
                            <span class="emphasis"><em>ipc_ids</em></span> structure, and may involve resizing the
                            <span class="emphasis"><em>entries</em></span> array. A pointer to the new structure is
                        placed in the first free element of <span class="emphasis"><em>entries</em></span>. Two
                        substeps are included as part of this initialization:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>The <span class="emphasis"><em>key</em></span> value supplied in the
                                    <span class="emphasis"><em>get</em></span> call is copied into the
                                    <span class="emphasis"><em>xxx_perm.__key</em></span> field of the newly allocated
                                structure.</p></li><li class="listitem"><p>The current value of the <span class="emphasis"><em>seq</em></span> field of the
                                    <span class="emphasis"><em>ipc_ids</em></span> structure is copied into the
                                    <span class="emphasis"><em>xxx_perm.__seq</em></span> field of the associated data
                                structure, and the <span class="emphasis"><em>seq</em></span> field is incremented by
                                one.</p></li></ol></div></li><li class="listitem"><p>The identifier for the IPC object is calculated using the following
                        formula:</p><a id="I_programlisting45_d1e121183"/><pre class="programlisting">identifier = index + xxx_perm.__seq * SEQ_MULTIPLIER</pre></li></ol></div><p>In the formula used to calculate the IPC identifier, <span class="emphasis"><em>index</em></span> is
                the index of this object instance within the <span class="emphasis"><em>entries</em></span> array, and
                    <code class="literal">SEQ_MULTIPLIER</code> is a constant defined with the
                value 32,768 (<code class="literal">IPCMNI</code> in the kernel source file
                    <code class="literal">include/linux/ipc.h</code>). For example, in <a class="xref" href="ch45.html#kernel_data_structures_used_to_represent" title="Figure 45-1. Kernel data structures used to represent System V IPC (semaphore) objects">Figure 45-1</a>, the identifier generated
                for the semaphore with the <span class="emphasis"><em>key</em></span> value <code class="literal">0x4b079002</code> would be (2 + 5 * 32,768) = 163,842.</p><p>Note the following points about the algorithm employed by the
                    <span class="emphasis"><em>get</em></span> calls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Even if a new IPC object is created with the same key, it will almost
                        certainly have a different identifier, since the identifier is calculated
                        based on the <span class="emphasis"><em>seq</em></span> value saved in the associated data
                        structure, and this value is incremented by one during the creation of each
                        object of this type.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>The algorithm employed within the kernel wraps the <span class="emphasis"><em>seq</em></span>
                    value back to 0 when it reaches the value <code class="literal">(INT_MAX /
                        IPCMNI)</code>—that is, 2,147,483,647 / 32,768 = 65,535. Thus, a new IPC
                    object could have the same identifier as a previous object if 65,535 objects are
                    created in the interim and the new object reuses the same element in the
                        <span class="emphasis"><em>entries</em></span> array as the previous object (i.e., this
                    element must also have been freed in the interim). However, the chances of this
                    occurring are small.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The algorithm generates a distinct set of identifier values for each index
                        of the <span class="emphasis"><em>entries</em></span> array.</p></li><li class="listitem"><p>Since the constant <code class="literal">IPCMNI</code> defines an
                        upper limit on the number of System V objects of each type, the algorithm
                        guarantees that each existing IPC object has a unique identifier.</p></li><li class="listitem"><p>Given an identifier value, the corresponding index into the
                            <span class="emphasis"><em>entries</em></span> array can be quickly calculated using this
                        equation:</p></li></ul></div><a id="I_programlisting45_d1e121254"/><pre class="programlisting">index = identifier % SEQ_MULTIPLIER</pre><p>Being able to rapidly perform this calculation is necessary for the efficient
                operation of those IPC system calls that are supplied with the identifier of an IPC
                object (i.e., those calls in <a class="xref" href="ch45.html#summary_of_programming_interfaces_for_sy" title="Table 45-1. Summary of programming interfaces for System V IPC objects">Table 45-1</a> other than the
                    <span class="emphasis"><em>get</em></span> calls).</p><p>In passing, it is worth noting that two different errors can result if a process
                makes an IPC system call (e.g., <span class="emphasis"><em>msgctl()</em></span>,
                    <span class="emphasis"><em>semop()</em></span>, or <span class="emphasis"><em>shmat()</em></span>) that specifies an
                identifier that doesn’t correspond to an existing object. If the corresponding index
                of <span class="emphasis"><em>entries</em></span> is empty, the error <code class="literal">EINVAL</code> results. If the index points to an associated data structure,
                but the sequence number stored in that structure doesn’t yield the same identifier
                value, then it is assumed that an old object pointed to by this array index has been
                deleted and the index reused. This scenario is diagnosed with the error <code class="literal">EIDRM</code>.</p></div><div class="sect1" title="The ipcs and ipcrm Commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_ipcs_and_ipcrm_commands">The <span class="emphasis"><em>ipcs</em></span> and <span class="emphasis"><em>ipcrm</em></span> Commands</h2></div></div></div><p>The <span class="emphasis"><em>ipcs</em></span> and <span class="emphasis"><em>ipcrm</em></span> commands are the
                System V IPC analogs of the <span class="emphasis"><em>ls</em></span> and <span class="emphasis"><em>rm</em></span> file
                commands. Using <span class="emphasis"><em>ipcs</em></span>, we can obtain information about IPC
                objects on the system. By default, <span class="emphasis"><em>ipcs</em></span> displays all objects,
                as in the following example:</p><a id="I_programlisting45_d1e121315"/><pre class="programlisting">$ <strong class="userinput"><code>ipcs</code></strong>

------ Shared Memory Segments --------
key        shmid     owner     perms    bytes    nattch   status
0x6d0731db 262147    mtk       600      8192      2

------ Semaphore Arrays --------
key        semid     owner     perms    nsems
0x6107c0b8 0         cecilia   660      6
0x6107c0b6 32769     britta    660      1

------ Message Queues --------
key        msqid     owner     perms    used-bytes  messages
0x71075958 229376    cecilia   620      12          2</pre><p>On Linux, <span class="emphasis"><em>ipcs(1)</em></span> displays information only about IPC objects
                for which we have read permission, regardless of whether we own the objects. On some
                UNIX implementations, <span class="emphasis"><em>ipcs</em></span> shows the same behavior as on Linux.
                However, on other implementations, <span class="emphasis"><em>ipcs</em></span> displays all objects
                regardless of whether read permission is granted to the user.</p><p>By default, for each object, <span class="emphasis"><em>ipcs</em></span> displays the key, the
                identifier, the owner, and the permissions (expressed as an octal number), followed
                by information specific to the object:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For shared memory, <span class="emphasis"><em>ipcs</em></span> displays the size of the
                        shared memory region, the number of processes that currently have the shared
                        memory region attached to their virtual address space, and status flags. The
                        status flags indicate whether the region has been locked into RAM to prevent
                        swapping (<a class="xref" href="ch48.html#shared_memory_control_operations" title="Shared Memory Control Operations">Shared Memory Control Operations</a>) and whether
                        the region has been marked to be destroyed when all processes have detached
                        it.</p></li><li class="listitem"><p>For semaphores, <span class="emphasis"><em>ipcs</em></span> displays the size of the
                        semaphore set.</p></li><li class="listitem"><p>For message queues, <span class="emphasis"><em>ipcs</em></span> displays the total number of
                        bytes of data and the number of messages in the queue.</p></li></ul></div><p>The <span class="emphasis"><em>ipcs(1)</em></span> manual page documents various options for
                displaying other information about IPC objects.</p><p>The <span class="emphasis"><em>ipcrm</em></span> command deletes an IPC object. The general form of
                this command is one of the following:<a id="IDX-CHP-45-6273" class="indexterm"/></p><a id="I_programlisting45_d1e121372"/><pre class="programlisting">$ <strong class="userinput"><code>ipcrm -</code></strong><strong class="userinput"><code><em class="replaceable"><code>X key</code></em></code></strong>
$ <strong class="userinput"><code>ipcrm -</code></strong><strong class="userinput"><code><em class="replaceable"><code>x id</code></em></code></strong></pre><p>In the above, we either specify <span class="emphasis"><em>key</em></span> as an IPC object key or
                    <span class="emphasis"><em>id</em></span> as an IPC object identifier, and the letter
                    <span class="emphasis"><em>x</em></span> is replaced by an uppercase or lowercase
                    <span class="emphasis"><em>q</em></span> (for message queues), <span class="emphasis"><em>s</em></span> (for
                semaphores), or <span class="emphasis"><em>m</em></span> (for shared memory). Thus, we could use the
                following command to delete the semaphore set with the identifier 65538:</p><a id="I_programlisting45_d1e121406"/><pre class="programlisting">$ <strong class="userinput"><code>ipcrm -s 65538</code></strong></pre></div><div class="sect1" title="Obtaining a List of All IPC Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="obtaining_a_list_of_all_ipc_objects">Obtaining a List of All IPC Objects</h2></div></div></div><p>Linux provides two nonstandard methods of obtaining a list of all IPC objects on
                the system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>files within the <code class="literal">/proc/sysvipc</code>
                        directory that list all IPC objects; and</p></li><li class="listitem"><p>the use of Linux-specific <span class="emphasis"><em>ctl</em></span> calls.</p></li></ul></div><p>We describe the files in <code class="literal">/proc/sysvipc</code>
                directory here, and defer discussion of the <span class="emphasis"><em>ctl</em></span> calls until
                    <a class="xref" href="ch46.html#displaying_all_message_queues_on_the_sys" title="Displaying All Message Queues on the System">Displaying All Message Queues on the System</a>, where we provide an
                example program that lists all System V message queues on the system.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some other UNIX implementations have their own nonstandard methods of
                    obtaining a list of all IPC identifiers; for example, Solaris provides the
                        <span class="emphasis"><em>msgids()</em></span>, <span class="emphasis"><em>semids()</em></span>, and
                        <span class="emphasis"><em>shmids()</em></span> system calls for this purpose.</p></div><p>Three read-only files in the <code class="literal">/proc/sysvipc</code>
                directory provide the same information as can be obtained via
                    <span class="emphasis"><em>ipcs</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">/proc/sysvipc/msg</code> lists all messages
                        queues and their attributes.</p></li><li class="listitem"><p><code class="literal">/proc/sysvipc/sem</code> lists all semaphore
                        sets and their attributes.</p></li><li class="listitem"><p><code class="literal">/proc/sysvipc/shm</code> lists all shared
                        memory segments and their attributes.</p></li></ul></div><p>Unlike the <span class="emphasis"><em>ipcs</em></span> command, these files always show all objects
                of the corresponding type, regardless of whether read permission is available on the
                objects.</p><p>An example of the contents of <code class="literal">/proc/sysvipc/sem</code>
                is the following (with some white space removed to fit this example on the
                page):</p><a id="I_programlisting45_d1e121484"/><pre class="programlisting">$ <strong class="userinput"><code>cat /proc/sysvipc/sem</code></strong>
key     semid perms   nsems   uid   gid   cuid  cgid     otime        ctime
  0  16646144   600       4  1000   100   1000   100         0   1010166460</pre><p>The three <code class="literal">/proc/sysvipc</code> files provide a
                (nonportable) method for programs and scripts to walk through a list of all of the
                existing IPC objects of a given type.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The best that we can achieve by way of a portable approach to obtaining a list
                    of all IPC objects of a given type is to parse the output of
                        <span class="emphasis"><em>ipcs(1)</em></span>.</p></div></div><div class="sect1" title="IPC Limits"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ipc_limits">IPC Limits</h2></div></div></div><p>Since System V IPC objects consume system resources, the kernel places various
                limits on each class of IPC object in order to prevent resources from being
                exhausted. The methods for placing limits on System V IPC objects are not specified
                by SUSv3, but most UNIX implementations (including Linux) follow a similar framework
                for the types of limits that may be placed. As we cover each System V IPC mechanism
                in the following chapters, we discuss the associated limits and note differences
                from other UNIX implementations.<a id="IDX-CHP-45-6274" class="indexterm"/><a id="IDX-CHP-45-6275" class="indexterm"/><a id="IDX-CHP-45-6276" class="indexterm"/><a id="IDX-CHP-45-6277" class="indexterm"/></p><p>Although the types of limits that can be placed on each class of IPC object are
                generally similar across various UNIX implementations, the methods of viewing and
                changing these limits are not. The methods described in the following chapters are
                Linux-specific (they generally involve the use of files in the <code class="literal">/proc/sys/kernel</code> directory); things are done
                differently on other implementations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, the <span class="emphasis"><em>ipcs -l</em></span> command can be used to list the
                    limits on each of the IPC mechanisms. Programs can employ the Linux-specific
                        <code class="literal">IPC_INFO</code>
                    <span class="emphasis"><em>ctl</em></span> operation to retrieve the same information.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id44">Summary</h2></div></div></div><p>System V IPC is the name given to three IPC mechanisms that first appeared widely
                in System V, and have subsequently been ported to most UNIX implementations and
                incorporated into various standards. The three IPC mechanisms are message queues,
                which allow processes to exchange messages; semaphores, which allow processes to
                synchronize access to shared resources; and shared memory, which allows two or more
                processes to share the same pages of memory.<a id="IDX-CHP-45-6278" class="indexterm"/><a id="IDX-CHP-45-6279" class="indexterm"/><a id="IDX-CHP-45-6280" class="indexterm"/><a id="IDX-CHP-45-6281" class="indexterm"/></p><p>The three IPC mechanisms have many similarities in their APIs and semantics. For
                each IPC mechanism, a <span class="emphasis"><em>get</em></span> system call creates or opens an
                object. Given an integer <span class="emphasis"><em>key</em></span>, the <span class="emphasis"><em>get</em></span>
                calls return an integer <span class="emphasis"><em>identifier</em></span> used to refer to the object
                in subsequent system calls. Each IPC mechanism also has a corresponding a
                    <span class="emphasis"><em>ctl</em></span> call that is used to delete an object and to retrieve
                and modify various attributes (e.g., ownership and permissions) in an object’s
                associated data structure.</p><p>The algorithm used to generate identifiers for new IPC objects is designed to
                minimize the possibility of the same identifier being (immediately) reused if an
                object is deleted, even if the same key is used to create a new object. This enables
                client-server applications to function correctly—a restarted server process is able
                to detect and remove IPC objects created by its predecessor, and this action
                invalidates the identifiers held by any clients of the previous server
                process.</p><p>The <span class="emphasis"><em>ipcs</em></span> command lists the System V IPC objects that
                currently exist on the system. The <span class="emphasis"><em>ipcrm</em></span> command is used to
                remove System IPC objects.</p><p>On Linux, files in the <code class="literal">/proc/sysvipc</code> directory
                can be used to obtain information about all of the System V IPC objects on the
                system.</p><p>Each IPC mechanism has an associated set of limits that can be used to avoid
                exhaustion of system resources by preventing the creation of an arbitrary number of
                IPC objects. Various files under the <code class="literal">/proc/sys/kernel</code> directory can be used to view and modify these
                limits.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id61"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id62">Further information</h4></div></div></div><p>Information about the implementation of System V IPC on Linux can be found
                        in [Maxwell, 1999] and [Bovet &amp; Cesati, 2005]. [Goodheart &amp;
                        Cox, 1994] describes the implementation of System V IPC for System V Release
                        4.</p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id30">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Write a program to verify that the algorithm employed by
                            <span class="emphasis"><em>ftok()</em></span> uses the file’s i-node number, minor device
                        number, and <span class="emphasis"><em>proj</em></span> value, as described in Section 45.2.
                        (It is sufficient to print all of these values, as well as the return value
                        from <span class="emphasis"><em>ftok()</em></span>, in hexadecimal, and inspect the results
                        for a few examples.)<a id="IDX-CHP-45-6282" class="indexterm"/><a id="IDX-CHP-45-6283" class="indexterm"/></p></li><li class="listitem"><p>Implement <span class="emphasis"><em>ftok()</em></span>.</p></li><li class="listitem"><p>Verify (by experiment) the statements made in <a class="xref" href="ch45.html#algorithm_employed_by_system_v_ipc_get_c" title="Algorithm Employed by System V IPC get Calls">Algorithm Employed by System V IPC <span class="emphasis"><em>get</em></span> Calls</a> about the algorithm
                        used to generate System V IPC identifiers.</p></li></ol></div></div></section></body></html>
