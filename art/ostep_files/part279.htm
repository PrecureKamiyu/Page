<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Locks</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part278.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part280.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 2pt;padding-left: 38pt;text-indent: 0pt;text-align: right;">Locks</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">From the introduction to concurrency, we saw one of the fundamental problems in concurrent programming: we would like to execute a series of instructions atomically, but due to the presence of interrupts on a single processor (or multiple threads executing on multiple processors concur- rently), we couldn’t. In this chapter, we thus attack this problem directly, with the introduction of something referred to as a <b>lock</b>. Programmers annotate source code with locks, putting them around critical sections, and thus ensure that any such critical section executes as if it were a sin- gle atomic instruction.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part280.htm">28.1 Locks: The Basic Idea</a><a class="toc0" href="part281.htm">28.2 Pthread Locks</a><a class="toc0" href="part282.htm">28.3 Building A Lock</a><a class="toc0" href="part283.htm">28.4 Evaluating Locks</a><a class="toc0" href="part284.htm">28.5 Controlling Interrupts</a><a class="toc0" href="part285.htm">28.6 Test And Set (Atomic Exchange)</a><a class="toc0" href="part286.htm">28.7 Building A Working Spin Lock</a><a class="toc0" href="part287.htm">28.8 Evaluating Spin Locks</a><a class="toc0" href="part288.htm">28.9 Compare-And-Swap</a><a class="toc0" href="part289.htm">28.10 Load-Linked and Store-Conditional</a><a class="toc0" href="part290.htm">28.11 Fetch-And-Add</a><a class="toc0" href="part291.htm">28.12 Summary: So Much Spinning</a><a class="toc0" href="part292.htm">28.13 A Simple Approach: Just Yield, Baby</a><a class="toc0" href="part293.htm">28.14 Using Queues: Sleeping Instead Of Spinning</a><a class="toc0" href="part294.htm">28.15 Different OS, Different Support</a><a class="toc0" href="part295.htm">28.16 Two-Phase Locks</a><a class="toc0" href="part296.htm">28.17 Summary</a><a class="toc0" href="part297.htm">References</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part278.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part280.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
