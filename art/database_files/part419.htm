<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>23.2  Commit Protocols</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part418.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part420.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">23.2  <span style=" color: #00AEEF;">Commit Protocols</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">If we are to ensure atomicity, all the nodes in which a transaction <i>T </i>executed must agree on the ﬁnal outcome of the execution. <i>T </i>must either commit at all nodes, or it must abort at all nodes. To ensure this property, the transaction coordinator of <i>T </i>must execute a commit protocol.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Among the simplest and most widely used commit protocols is the <span class="s63">two-phase com- mit protocol </span>(<span class="s64">2PC</span>), which is described in Section 23.2.1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">23.2.1 Two-Phase Commit</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">We ﬁrst describe how the two-phase commit protocol (<span class="s44">2PC</span>) operates during normal operation, then describe how it handles failures and ﬁnally how it carries out recovery and concurrency control.</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 87%;text-align: justify;">Consider a transaction <i>T </i>initiated at node <i>N</i><span class="s97">i</span>, where the transaction coordinator is <i>C</i><span class="s97">i</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">23.2.1.1 The Commit Protocol</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">When <i>T </i>completes its execution— that is, when all the nodes at which <i>T </i>has executed inform <i>C</i><span class="s145">i </span>that <i>T </i>has completed — <i>C</i><span class="s145">i </span>starts the <span class="s44">2PC </span>protocol.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 139pt;text-indent: -16pt;line-height: 70%;text-align: justify;"><span class="s39">• </span><b>Phase 1</b>. <i>C</i><span class="s97">i </span>adds the record <span class="s83">&lt;</span><span class="s49">prepare </span><i>T</i><span class="s83">&gt; </span>to the log and forces the log onto stable storage. It then sends a <span class="s49">prepare </span><i>T </i>message to all nodes at which <i>T </i>executed.</p><p style="padding-top: 1pt;padding-left: 139pt;text-indent: 0pt;line-height: 92%;text-align: justify;">On receiving such a message, the transaction manager at that node determines whether it is willing to commit its portion of <i>T </i>. If the answer is no, it adds a record <span class="s83">&lt;</span><span class="s49">no </span><i>T</i><span class="s83">&gt; </span>to the log and then responds by sending an <span class="s49">abort </span><i>T </i>message to</p><p class="s13" style="padding-left: 139pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">C<span class="s97">i</span><span class="p">. If the answer is yes, it adds a record </span><span class="s83">&lt;</span><span class="s49">ready </span>T<span class="s83">&gt; </span><span class="p">to the log and forces the log</span></p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">(with all the log records corresponding to <i>T </i>) onto stable storage. The transaction</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">manager then replies with a <span class="s49">ready </span><i>T </i>message to <i>C</i><span class="s97">i</span>.</p><p style="padding-top: 2pt;padding-left: 139pt;text-indent: -16pt;line-height: 92%;text-align: justify;"><span class="s39">• </span><b>Phase 2</b>. When <i>C</i><span class="s97">i </span>receives <span class="s49">ready </span>responses to the <span class="s49">prepare </span><i>T </i>message from all the nodes, or when it receives an <span class="s49">abort </span><i>T </i>message from at least one participant node, <i>C</i><span class="s97">i </span>can determine whether the transaction <i>T </i>can be committed or aborted. Transaction <i>T </i>can be committed if <i>C</i><span class="s97">i </span>received a <span class="s49">ready </span><i>T </i>message from all the</p><p class="s83" style="padding-left: 139pt;text-indent: 0pt;line-height: 76%;text-align: justify;"><span class="p">participating nodes. Otherwise, transaction </span><span class="s13">T </span><span class="p">must be aborted. Depending on the verdict, either a record </span>&lt;<span class="s49">commit </span><span class="s13">T</span>&gt; <span class="p">or a record </span>&lt;<span class="s49">abort </span><span class="s13">T</span>&gt; <span class="p">is added to the log and the log is forced onto stable storage. At this point, the fate of the transaction</span></p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">has been sealed.</p><p style="padding-left: 154pt;text-indent: 0pt;text-align: justify;">Following this point, the coordinator sends either a <span class="s49">commit </span><i>T </i>or an <span class="s49">abort </span><i>T</i></p><p class="s83" style="padding-top: 2pt;padding-left: 139pt;text-indent: 0pt;line-height: 76%;text-align: justify;"><span class="p">message to all participating nodes. When a node receives that message, it records the result (either </span>&lt;<span class="s49">commit </span><span class="s13">T</span>&gt; <span class="p">or </span>&lt;<span class="s49">abort </span><span class="s13">T</span>&gt;<span class="p">) in its log, and correspondingly either commits or aborts the transaction.</span></p><p style="padding-top: 1pt;padding-left: 139pt;text-indent: 15pt;text-align: justify;">Since nodes may fail, the coordinator cannot wait indeﬁnitely for responses from all the nodes. Instead, when a prespeciﬁed interval of time has elapsed since the <span class="s49">prepare </span><i>T </i>message was sent out, if any node has not responded to the coor- dinator, the coordinator can decide to abort the transaction; the steps described for aborting the transaction must be followed, just as if a node had sent an <span class="s49">abort </span>message for the transaction.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Figure 23.2 shows an instance of successful execution of <span class="s44">2PC </span>for a transaction <i>T </i>, with two nodes, <i>N</i><span class="s98">1</span> and <i>N</i><span class="s98">2</span>, that are both willing to commit transaction <i>T </i>. If any of the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="281" height="454" alt="image" src="Image_3261.png"/></span></p><p class="s506" style="text-indent: 0pt;line-height: 10pt;text-align: left;">Force log record</p><p class="s507" style="padding-left: 8pt;text-indent: 0pt;text-align: left;">&lt; ready <span class="s508">T </span>&gt;</p><p class="s506" style="text-indent: 0pt;text-align: left;">Send message</p><p class="s507" style="padding-left: 15pt;text-indent: 0pt;text-align: left;">ready <span class="s508">T</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s506" style="text-indent: 0pt;line-height: 10pt;text-align: left;">Force log record</p><p class="s507" style="padding-left: 8pt;text-indent: 0pt;text-align: left;">&lt; commit <span class="s508">T </span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s506" style="padding-top: 1pt;padding-left: 19pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Node N<span class="s509">2</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s506" style="padding-top: 1pt;padding-left: 20pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Node N<span class="s509">1</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s506" style="padding-top: 1pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">Coordinator</p><p style="text-indent: 0pt;text-align: left;"/><p class="s506" style="padding-top: 4pt;padding-left: 102pt;text-indent: 0pt;text-align: left;">Force log record</p><p class="s507" style="padding-left: 109pt;text-indent: 0pt;text-align: left;">&lt; prepare <span class="s508">T </span>&gt;</p><p class="s506" style="padding-left: 102pt;text-indent: 0pt;text-align: left;">Send message</p><p class="s507" style="padding-left: 115pt;text-indent: 0pt;text-align: left;">prepare <span class="s508">T</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s506" style="padding-top: 4pt;padding-left: 381pt;text-indent: 0pt;text-align: left;">Force log record</p><p class="s507" style="padding-left: 390pt;text-indent: 0pt;text-align: left;">&lt; ready <span class="s508">T </span>&gt;</p><p class="s506" style="padding-left: 381pt;text-indent: 0pt;text-align: left;">Send message</p><p class="s507" style="padding-left: 395pt;text-indent: 0pt;text-align: left;">ready <span class="s508">T</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s506" style="padding-top: 4pt;padding-left: 102pt;text-indent: 0pt;text-align: left;">Force log record</p><p class="s507" style="padding-left: 111pt;text-indent: 0pt;text-align: left;">&lt; commit <span class="s508">T </span>&gt;</p><p class="s506" style="padding-left: 102pt;text-indent: 0pt;text-align: left;">Send message</p><p class="s507" style="padding-left: 118pt;text-indent: 0pt;text-align: left;">commit <span class="s508">T</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s506" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Force log record</p><p class="s507" style="padding-left: 119pt;text-indent: 0pt;text-align: right;">&lt; commit <span class="s508">T </span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s74" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;"><span class="s73">Figure 23.2 </span>Successful execution of <span class="s157">2PC</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">nodes sends a <span class="s49">no </span><i>T </i>message, the coordinator will send an <span class="s49">abort </span><i>T </i>message to all the nodes, which will then abort the transaction.</p><p style="padding-top: 2pt;padding-left: 88pt;text-indent: 17pt;line-height: 76%;text-align: justify;">A node at which <i>T </i>executed can unconditionally abort <i>T </i>at any time before it sends the message <span class="s49">ready </span><i>T </i>to the coordinator. Once the <span class="s83">&lt;</span><span class="s49">ready </span><i>T</i><span class="s83">&gt; </span>log record is written, the transaction <i>T </i>is said to be in the <span class="s63">ready state </span>at the node. The <span class="s49">ready </span><i>T </i>message</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">is, in eﬀect, a promise by a node to follow the coordinator’s order to commit <i>T </i>or to abort <i>T </i>. To make such a promise, the needed information must ﬁrst be stored in stable storage. Otherwise, if the node crashes after sending <span class="s49">ready </span><i>T </i>, it may be unable to make good on its promise. Further, locks acquired by the transaction must continue to be held until the transaction completes, even if there is an intervening node failure, as we shall see in Section 23.2.1.3.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 119pt;text-indent: 17pt;line-height: 94%;text-align: justify;">Since unanimity is required to commit a transaction, the fate of <i>T </i>is sealed as soon as at least one node responds <span class="s49">abort </span><i>T </i>. Since the coordinator node <i>N</i><span class="s97">i </span>is one of the nodes at which <i>T </i>executed, the coordinator can decide unilaterally to abort <i>T </i>. The</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">ﬁnal verdict regarding <i>T </i>is determined at the time that the coordinator writes that verdict (commit or abort) to the log and forces that verdict to stable storage.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In some implementations of the <span class="s44">2PC </span>protocol, a node sends an <span class="s49">acknowledge </span><i>T </i>message to the coordinator at the end of the second phase of the protocol. When the coordinator receives the <span class="s49">acknowledge </span><i>T </i>message from all the nodes, it adds the record</p><p class="s83" style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 70%;text-align: justify;">&lt;<span class="s49">complete </span><span class="s13">T</span>&gt; <span class="p">to the log. Until this step, the coordinator cannot forget about the commit or abort decision on </span><span class="s13">T </span><span class="p">, since a node may ask for the decision. (A node that</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">has not received a <span class="s49">commit </span>or <span class="s49">abort </span>for transaction <i>T </i>, perhaps due to a network failure or temporary node failure, may send such a request to the coordinator.) After this step, the coordinator can discard information about transaction <i>T </i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">23.2.1.2 Handling of Failures</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The <span class="s44">2PC </span>protocol responds in diﬀerent ways to various types of failure:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Failure of a participating node</b>. If the coordinator <i>C</i><span class="s145">i </span>detects that a node has failed, it takes these actions: If the node fails before responding with a <span class="s49">ready </span><i>T </i>message to <i>C</i><span class="s97">i</span>, the coordinator assumes that it responded with an <span class="s49">abort </span><i>T </i>message. If the node fails after the coordinator has received the <span class="s49">ready </span><i>T </i>message from the node, the coordinator executes the rest of the commit protocol in the normal fashion,</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">ignoring the failure of the node.</p><p style="padding-top: 1pt;padding-left: 139pt;text-indent: 14pt;line-height: 87%;text-align: justify;">When a participating node <i>N</i><span class="s97">k </span>recovers from a failure, it must examine its log to determine the fate of those transactions that were in the midst of execution</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">when the failure occurred. Let <i>T </i>be one such transaction. We consider each of the possible cases:</p><p class="s83" style="padding-top: 3pt;padding-left: 145pt;text-indent: 0pt;line-height: 19pt;text-align: justify;"><span class="s50">° </span><span class="s51">The log contains a </span>&lt;<span class="s49">commit </span><span class="s13">T</span>&gt; <span class="p">record. In this case, the node executes</span></p><p style="padding-left: 153pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="s49">redo</span>(<i>T </i>).</p><p class="s83" style="padding-top: 3pt;padding-left: 145pt;text-indent: 0pt;line-height: 19pt;text-align: justify;"><span class="s50">° </span><span class="s51">The log contains an </span>&lt;<span class="s49">abort </span><span class="s13">T</span>&gt; <span class="p">record. In this case, the node executes</span></p><p style="padding-left: 153pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="s49">undo</span>(<i>T </i>).</p><p style="padding-top: 6pt;padding-left: 153pt;text-indent: -8pt;line-height: 78%;text-align: justify;"><span class="s50">° </span><span class="s51">The log contains a </span><span class="s83">&lt;</span><span class="s49">ready </span><i>T</i><span class="s83">&gt; </span>record. In this case, the node must consult <i>C</i><span class="s97">i </span>to determine the fate of <i>T </i>. If <i>C</i><span class="s97">i </span>is up, it notiﬁes <i>N</i><span class="s97">k </span>regarding whether <i>T </i>committed or aborted. In the former case, it executes <span class="s49">redo</span>(<i>T </i>); in the latter case, it executes</p><p style="padding-left: 153pt;text-indent: 0pt;line-height: 94%;text-align: justify;"><span class="s49">undo</span>(<i>T </i>). If <i>C</i><span class="s97">i </span>is down, <i>N</i><span class="s97">k </span>must try to ﬁnd the fate of <i>T </i>from other nodes. It does so by sending a <span class="s49">querystatus </span><i>T </i>message to all the nodes in the system. On receiving such a message, a node must consult its log to determine whether</p><p class="s13" style="padding-top: 1pt;padding-left: 153pt;text-indent: 0pt;line-height: 91%;text-align: justify;">T <span class="p">has executed there, and if </span>T <span class="p">has, whether </span>T <span class="p">committed or aborted. It then notiﬁes </span>N<span class="s97">k </span><span class="p">about this outcome. If no node has the appropriate information (i.e., whether </span>T <span class="p">committed or aborted), then </span>N<span class="s97">k </span><span class="p">can neither abort nor commit </span>T <span class="p">. The decision concerning </span>T <span class="p">is postponed until </span>N<span class="s97">k </span><span class="p">can obtain the needed</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 122pt;text-indent: 0pt;line-height: 93%;text-align: justify;">information. Thus, <i>N</i><span class="s145">k </span>must periodically resend the <span class="s49">querystatus </span>message to the other nodes. It continues to do so until a node that contains the needed information has recovered. Note that the node at which <i>C</i><span class="s97">i </span>resides always has the needed information.</p><p style="padding-top: 7pt;padding-left: 122pt;text-indent: -8pt;line-height: 83%;text-align: justify;"><span class="s50">° </span><span class="s51">The log contains no control records (</span><span class="s49">abort, commit, ready</span>) concerning <i>T </i>. Thus, we know that <i>N</i><span class="s97">k </span>failed before responding to the <span class="s49">prepare </span><i>T </i>message from <i>C</i><span class="s97">i</span>. Since the failure of <i>N</i><span class="s97">k </span>precludes the sending of such a response, by our algorithm <i>C</i><span class="s97">i </span>must abort <i>T </i>. Hence, <i>N</i><span class="s97">k </span>must execute <span class="s49">undo</span>(<i>T </i>).</p><p style="padding-top: 8pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Failure of the coordinator</b>. If the coordinator fails in the midst of the execution of the commit protocol for transaction <i>T </i>, then the participating nodes must decide the fate of <i>T </i>. We shall see that, in certain cases, the participating nodes cannot decide whether to commit or abort <i>T </i>, and therefore these nodes must wait for the recovery of the failed coordinator.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s83" style="padding-left: 122pt;text-indent: -8pt;line-height: 70%;text-align: justify;"><span class="s50">° </span><span class="s51">If an active node contains a </span>&lt;<span class="s49">commit </span><span class="s13">T</span>&gt; <span class="p">record in its log, then </span><span class="s13">T </span><span class="p">must be committed.</span></p><p class="s83" style="padding-top: 8pt;padding-left: 122pt;text-indent: -8pt;line-height: 70%;text-align: justify;"><span class="s50">° </span><span class="s51">If an active node contains an </span>&lt;<span class="s49">abort </span><span class="s13">T</span>&gt; <span class="p">record in its log, then </span><span class="s13">T </span><span class="p">must be aborted.</span></p><p class="s13" style="padding-top: 7pt;padding-left: 122pt;text-indent: -8pt;line-height: 72%;text-align: justify;"><span class="s50">° </span><span class="s51">If some active node does </span>not <span class="p">contain a </span><span class="s83">&lt;</span><span class="s49">ready </span>T<span class="s83">&gt; </span><span class="p">record in its log, then the failed coordinator </span>C<span class="s145">i </span><span class="p">cannot have decided to commit </span>T <span class="p">, because a node that does not have a </span><span class="s83">&lt;</span><span class="s49">ready </span>T<span class="s83">&gt; </span><span class="p">record in its log cannot have sent a </span><span class="s49">ready </span>T <span class="p">mes- sage to </span>C<span class="s97">i</span><span class="p">. However, the coordinator may have decided to abort </span>T <span class="p">, but not to</span></p><p style="padding-left: 122pt;text-indent: 0pt;line-height: 80%;text-align: justify;">commit <i>T </i>. Rather than wait for <i>C</i><span class="s97">i </span>to recover, it is preferable to abort <i>T </i>.</p><p class="s83" style="padding-top: 6pt;padding-left: 122pt;text-indent: -8pt;line-height: 63%;text-align: justify;"><span class="s50">° </span><span class="s51">If none of the preceding cases holds, then all active nodes must have a </span>&lt;<span class="s49">ready </span><span class="s13">T</span>&gt; <span class="p">record in their logs, but no additional control records (such as </span>&lt;<span class="s49">abort </span><span class="s13">T</span>&gt; <span class="p">or </span>&lt;<span class="s49">commit </span><span class="s13">T</span>&gt;<span class="p">). Since the coordinator has failed, it is impossible to determine whether a decision has been made, and if one has, what that decision is, until</span></p><p style="padding-top: 2pt;padding-left: 137pt;text-indent: -15pt;line-height: 87%;text-align: justify;">the coordinator recovers. Thus, the active nodes must wait for <i>C</i><span class="s97">i </span>to recover. Since the fate of <i>T </i>remains in doubt, <i>T </i>may continue to hold system re-</p><p style="padding-left: 122pt;text-indent: 0pt;text-align: justify;">sources. For example, if locking is used, <i>T </i>may hold locks on data at active nodes. Such a situation is undesirable, because it may be hours or days before <i>C</i><span class="s145">i </span>is again active. During this time, other transactions may be forced to wait for <i>T </i>. As a result, data items may be unavailable not only on the failed node (<i>C</i><span class="s97">i</span>), but on active nodes as well. This situation is called the <span class="s63">blocking problem</span>,</p><p style="padding-left: 122pt;text-indent: 0pt;line-height: 80%;text-align: justify;">because <i>T </i>is blocked pending the recovery of node <i>C</i><span class="s97">i</span>.</p><p class="s39" style="padding-top: 9pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s46">Network partition</span><span class="p">. When a network partition occurs, two possibilities exist:</span></p><p class="s63" style="padding-top: 13pt;padding-left: 133pt;text-indent: -11pt;text-align: left;">1. <span class="p">The coordinator and all its participants remain in one partition. In this case, the failure has no eﬀect on the commit protocol.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-top: 4pt;padding-left: 165pt;text-indent: -11pt;text-align: justify;">2. <span class="p">The coordinator and its participants belong to several partitions. From the viewpoint of the nodes in one of the partitions, it appears that the nodes in other partitions have failed. Nodes that are not in the partition containing the coordinator simply execute the protocol to deal with the failure of the coordinator. The coordinator and the nodes that are in the same partition as the coordinator follow the usual commit protocol, assuming that the nodes in the other partitions have failed.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">Thus, the major disadvantage of the <span class="s44">2PC </span>protocol is that coordinator failure may result in blocking, where a decision either to commit or to abort <i>T </i>may have to be postponed until <i>C</i><span class="s97">i </span>recovers. We discuss how to remove this limitation shortly, in Section 23.2.2.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">23.2.1.3 Recovery and Concurrency Control</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">When a failed node restarts, we can perform recovery by using, for example, the recov- ery algorithm described in Section 19.4. To deal with distributed commit protocols, the recovery procedure must treat <span class="s63">in-doubt transactions </span>specially; in-doubt transactions are</p><p class="s83" style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 65%;text-align: justify;"><span class="p">transactions for which a </span>&lt;<span class="s49">ready </span><span class="s13">T</span>&gt; <span class="p">log record is found, but neither a </span>&lt;<span class="s49">commit </span><span class="s13">T</span>&gt; <span class="p">log record nor an </span>&lt;<span class="s49">abort </span><span class="s13">T</span>&gt; <span class="p">log record is found. The recovering node must determine the commit–abort status of such transactions by contacting other nodes, as described</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">in Section 23.2.1.2.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If recovery is done as just described, however, normal transaction processing at the node cannot begin until all in-doubt transactions have been committed or rolled back. Finding the status of in-doubt transactions can be slow, since multiple nodes may have to be contacted. Further, if the coordinator has failed, and no other node has information about the commit–abort status of an incomplete transaction, recovery potentially could become blocked if <span class="s44">2PC </span>is used. As a result, the node performing restart recovery may remain unusable for a long period.</p><p class="s83" style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 92%;text-align: justify;"><span class="p">To circumvent this problem, recovery algorithms typically provide support for not- ing lock information in the log. (We are assuming here that locking is used for con- currency control.) Instead of writing a </span>&lt;<span class="s49">ready </span><span class="s13">T</span>&gt; <span class="p">log record, the algorithm writes a</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;"><span class="s83">&lt;</span><span class="s49">ready </span>T <span class="p">, </span>L <span class="s83">&gt; </span><span class="p">log record, where </span>L <span class="p">is a list of all write locks held by the transaction</span></p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">T <span class="p">when the log record is written. At recovery time, after performing local recovery ac-</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 17pt;text-align: justify;">tions, for every in-doubt transaction <i>T </i>, all the write locks noted in the <span class="s83">&lt;</span><span class="s49">ready </span><i>T </i>, <i>L </i><span class="s83">&gt;</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">log record (read from the log) are reacquired.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">After lock reacquisition is complete for all in-doubt transactions, transaction pro- cessing can start at the node, even before the commit–abort status of the in-doubt transactions is determined. The commit or rollback of in-doubt transactions proceeds concurrently with the execution of new transactions. Thus, node recovery is faster and never gets blocked. Note that new transactions that have a lock conﬂict with any write locks held by in-doubt transactions will be unable to make progress until the conﬂicting in-doubt transactions have been committed or rolled back.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">23.2.2 Avoiding Blocking During Commit</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The blocking problem of <span class="s44">2PC </span>is a serious concern for system designers, since the failure of a coordinator node could lead to blocking of a transaction that has acquired locks on a frequently used data item, which in turn prevents other transactions that need to acquire a conﬂicting lock from completing their execution.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">By involving multiple nodes in the commit decision step of <span class="s44">2PC</span>, it is possible to avoid blocking as long as a majority of the nodes involved in the commit decision are alive and can communicate with each other. This is done by using the idea of fault- tolerant distributed consensus. Details of distributed consensus are discussed in detail later, in Section 23.8, but we outline the problem and sketch a solution approach below.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The <span class="s63">distributed consensus problem </span>is as follows: A set of <i>n </i>nodes need to agree on a decision; in this case, whether or not to commit a particular transaction. The inputs to make the decision are provided to all the nodes, and then each node votes on the decision; in the case of <span class="s44">2PC</span>, the decision is on whether or not to commit a transaction. The key goal of protocols for achieving distributed consensus is that the decision should be made in such a way that all nodes will “learn” the same value for the decision (i.e., all nodes will learn that the transaction is to be committed, or all nodes will learn that the transaction is to be aborted), even if some nodes fail during the execution of the protocol, or there are network partitions. Further, the distributed consensus protocol should not block, as long as a majority of the nodes participating remain alive and can communicate with each other.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">There are several protocols for distributed consensus, two of which are widely used today (Paxos and Raft). We study distributed consensus in Section 23.8. A key idea behind these protocols is the idea of a vote, which succeeds only if a majority of the participating nodes agree on a particular decision.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Given an implementation of distributed consensus, the blocking problem due to coordinator failure can be avoided as follows: Instead of the coordinator locally decid- ing to commit or abort a transaction, it initiates the distributed consensus protocol, requesting that the value “committed” or “aborted” be assigned to the transaction <i>T </i>. The request is sent to all the nodes participating in the distributed consensus, and the consensus protocol is then executed by those nodes. Since the protocol is fault tolerant, it will succeed even if some nodes fail, as long as a majority of the nodes are up and remain connected. The transaction can be declared committed by the coordinator only after the consensus protocol completes successfully.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">There are two possible failure scenarios:</p><p class="s39" style="padding-top: 7pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s13">The coordinator fails at any stage before informing all participating nodes of the com- mit or abort status of a transaction T.</span></p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">In this case, a new coordinator is chosen (we will see how to do so in Section 23.7). The new coordinator checks with the nodes participating in the distributed consensus to see if a decision was made, and if so informs the <span class="s44">2PC </span>participants</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;">of the decision. A majority of the nodes participating in consensus must respond, to check if a decision was made or not; the protocol will not block as long as the failed/disconnected nodes are in a minority.</p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">If no decision was made earlier for transaction <i>T </i>, the new coordinator again checks with the <span class="s44">2PC </span>participants to check if they are ready to commit or wish to abort the transaction, and follows the usual coordinator protocol based on their responses. As before, if no response is received from a participant, the new coor- dinator may choose to abort <i>T </i>.</p><p class="s39" style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;line-height: 15pt;text-align: left;">• <span class="s13">The distributed consensus protocol fails to reach a decision.</span></p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">Failure of the protocol can occur due to the failure of some participating nodes. It could also occur because of conﬂicting requests, none of which gets a majority of “votes” during the consensus protocol. For <span class="s44">2PC</span>, the request normally comes from a single coordinator, so such a conﬂict is unlikely. However, conﬂicting requests can arise in rare cases if a coordinator fails after sending out a commit message, but its commit message is delivered late; meanwhile, a new <span class="s44">2PC </span>coordinator makes an abort decision since it could not reach some participating nodes. Even with such a conﬂict, the distributed consensus protocol guarantees that only one of the commit or abort requests can succeed, even in the presence of failures. But if some nodes are down, and neither the commit nor the abort request gets a majority vote from nodes participating in the distributed consensus, it is possible for the protocol to fail to reach a decision.</p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">Regardless of the reason, if the distributed consensus protocol fails to reach a decision, the new coordinator just re-initiates the protocol.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that in the event of a network partition, a node that gets disconnected from the majority of the nodes participating in consensus may not learn about a decision, even if a decision was successfully made. Thus, transactions running at such a node may be blocked.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Failure of <span class="s44">2PC </span>participants could make data unavailable, in the absence of repli- cation. Distributed consensus can also be used to keep replicas of a data item in a consistent state, as we explain later in Section 23.8.4.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The idea of distributed consensus to make <span class="s44">2PC </span>nonblocking was proposed in the 1980s; it is used, for example, in the Google Spanner distributed database system.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The <span class="s63">three-phase commit </span>(<span class="s64">3PC</span>) protocol is an extension of the two-phase commit protocol that avoids the blocking problem under certain assumptions. One variant of the protocol avoids blocking as long as network partitions do not occur, but it may lead to inconsistent decisions in the event of a network partition. Extensions of the protocol that work safely under network partitioning were developed subsequently. The idea behind these extensions is similar to the majority voting idea of distributed consensus, but the protocols are speciﬁcally tailored for the task of atomic commit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">23.2.3 Alternative Models of Transaction Processing</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">With two-phase commit, participating nodes agree to let the coordinator decide the fate of a transaction, and are forced to wait for the decision of the coordinator, while holding locks on updated data items. While such loss of autonomy may be acceptable within an organization, no organization would be willing to force its computers to wait, potentially for a long time, while a computer at another organization makes the deci- sion.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In this section, we describe how to use <i>persistent messaging </i>to avoid the problem of distributed commit. To understand persistent messaging, consider how one might transfer funds between two diﬀerent banks, each with its own computer. One approach is to have a transaction span the two nodes and use two-phase commit to ensure atomic- ity. However, the transaction may have to update the total bank balance, and blocking could have a serious impact on all other transactions at each bank, since almost all transactions at the bank would update the total bank balance.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In contrast, consider how funds transfer by a bank check occurs. The bank ﬁrst deducts the amount of the check from the available balance and prints out a check. The check is then physically transferred to the other bank where it is deposited. After verifying the check, the bank increases the local balance by the amount of the check. The check constitutes a message sent between the two banks. So that funds are not lost or incorrectly increased, the check must not be lost and must not be duplicated and deposited more than once. When the bank computers are connected by a network, persistent messages provide the same service as the check (but much faster).</p><p class="s63" style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Persistent messages <span class="p">are messages that are guaranteed to be delivered to the re- cipient exactly once (neither less nor more), regardless of failures, if the transaction sending the message commits, and are guaranteed to not be delivered if the transac- tion aborts. Database recovery techniques are used to implement persistent messaging on top of the normal network channels, as we shall see shortly. In contrast, regular messages may be lost or may even be delivered multiple times in some situations.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Error handling is more complicated with persistent messaging than with two-phase commit. For instance, if the account where the check is to be deposited has been closed, the check must be sent back to the originating account and credited back there. Both nodes must, therefore, be provided with error-handling code, along with code to han- dle the persistent messages. In contrast, with two-phase commit, the error would be detected by the transaction, which would then never deduct the amount in the ﬁrst place.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The types of exception conditions that may arise depend on the application, so it is not possible for the database system to handle exceptions automatically. The applica- tion programs that send and receive persistent messages must include code to handle exception conditions and bring the system back to a consistent state. For instance, it is not acceptable to just lose the money being transferred if the receiving account has been closed; the money must be credited back to the originating account, and if that is not possible for some reason, humans must be alerted to resolve the situation manually.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:125.562pt" cellspacing="0"><tr style="height:15pt"><td style="width:160pt;border-top-style:solid;border-top-width:1pt;border-top-color:#656668;border-left-style:solid;border-left-width:1pt;border-left-color:#656668;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#656668;border-right-style:solid;border-right-width:1pt;border-right-color:#656668" colspan="2" bgcolor="#D4EFFC"><p class="s510" style="padding-top: 2pt;padding-left: 16pt;text-indent: 0pt;text-align: left;">Atomic Transaction at Sending Node</p></td></tr><tr style="height:23pt"><td style="width:160pt;border-top-style:solid;border-top-width:1pt;border-top-color:#656668;border-left-style:solid;border-left-width:1pt;border-left-color:#656668;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#656668;border-right-style:solid;border-right-width:1pt;border-right-color:#656668" colspan="2"><p class="s511" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">Perform database updates</p><p class="s511" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">Write message to <i>messages_to_send </i>relation</p></td></tr><tr style="height:13pt"><td style="width:67pt;border-top-style:solid;border-top-width:1pt;border-top-color:#656668;border-right-style:solid;border-right-width:1pt;border-right-color:#414143"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:93pt;border-top-style:solid;border-top-width:1pt;border-top-color:#656668;border-left-style:solid;border-left-width:1pt;border-left-color:#414143"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:10pt"><td style="width:49pt;border-right-style:solid;border-right-width:1pt;border-right-color:#414143"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:111pt;border-left-style:solid;border-left-width:1pt;border-left-color:#414143"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 135pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="4" height="4" alt="image" src="Image_3262.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 135pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="4" height="4" alt="image" src="Image_3263.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 135pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="4" height="4" alt="image" src="Image_3264.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 135pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="4" height="4" alt="image" src="Image_3265.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="217" height="88" alt="image" src="Image_3266.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s513" style="padding-top: 6pt;padding-left: 18pt;text-indent: 0pt;text-align: left;">messages_to_send</p><p style="text-indent: 0pt;text-align: left;"/><p class="s506" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Message Delivery Process</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="253" height="247" alt="image" src="Image_3267.png"/></span></p><p class="s513" style="text-indent: 0pt;line-height: 9pt;text-align: left;">received _messages</p><p style="text-indent: 0pt;text-align: left;"/><p class="s514" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">Monitor <i>messages_to_send </i>relation Send any new messages to recipient Also periodically resend old messages</p><p class="s514" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">When Acknowledgment received from recipient, for a message, delete message</p><p style="text-indent: 0pt;text-align: left;"/><p class="s514" style="padding-top: 2pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">On receiving message, execute transaction to add message to <i>received_messages </i>relation,</p><p class="s514" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">if not already present</p><p class="s514" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">After transaction commits, send Acknowledgement</p><p style="text-indent: 0pt;text-align: left;"/><p class="s506" style="padding-top: 1pt;padding-left: 37pt;text-indent: 0pt;text-align: left;">Message Receiving Process</p><p style="text-indent: 0pt;text-align: left;"/><p class="s514" style="padding-top: 1pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">Process any unprocessed message in</p><p class="s250" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">received_messages</p><p class="s514" style="padding-left: 14pt;text-indent: 0pt;text-align: left;">Mark message as processed</p><p style="text-indent: 0pt;text-align: left;"/><p class="s506" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Atomic Transaction at Receiving Node</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="4" alt="image" src="Image_3268.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="4" alt="image" src="Image_3269.png"/></span></p><p class="s73" style="padding-top: 4pt;padding-left: 187pt;text-indent: 0pt;text-align: left;">Figure 23.3 <span class="s74">Implementation of persistent messaging.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">There are many applications where the beneﬁt of eliminating blocking is well worth the extra eﬀort to implement systems that use persistent messages. In fact, few organi- zations would agree to support two-phase commit for transactions originating outside the organization, since failures could result in blocking of access to local data. Persis- tent messaging therefore plays an important role in carrying out transactions that cross organizational boundaries.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We now consider the <span class="s63">implementation </span>of persistent messaging. Persistent messag- ing can be implemented on top of an unreliable messaging infrastructure, which may lose messages or deliver them multiple times. Figure 23.3 shows a summary of the implementation, which is described in detail next.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3270.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3271.png"/></span></p><p style="padding-top: 2pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Sending node protocol</b>. When a transaction wishes to send a persistent message, it writes a record containing the message in a special relation <i>messages to send</i>, instead of directly sending out the message. The message is also given a unique message identiﬁer. Note that this relation acts as a message <i>outbox</i>.</p><p style="padding-left: 139pt;text-indent: 15pt;text-align: justify;">A <i>message delivery process </i>monitors the relation, and when a new message is found, it sends the message to its destination. The usual database concurrency- control mechanisms ensure that the system process reads the message only after the transaction that wrote the message commits; if the transaction aborts, the usual recovery mechanism would delete the message from the relation.</p><p style="padding-left: 139pt;text-indent: 14pt;text-align: justify;">The message delivery process deletes a message from the relation only after it receives an acknowledgment from the destination node. If it receives no acknowl- edgment from the destination node, after some time it sends the message again. It repeats this until an acknowledgment is received. In case of permanent failures,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: 0pt;text-align: justify;">the system will decide, after some period of time, that the message is undeliver- able. Exception handling code provided by the application is then invoked to deal with the failure.</p><p style="padding-left: 107pt;text-indent: 13pt;text-align: justify;">Writing the message to a relation and processing it only after the transaction has committed ensures that the message will be delivered if and only if the transaction commits. Repeatedly sending it guarantees it will be delivered even if there are (temporary) system or network failures.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3272.png"/></span></p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Receiving node protocol</b>. When a node receives a persistent message, it runs a trans- action that adds the message to a special <i>received messages </i>relation, provided it is not already present in the relation (the unique message identiﬁer allows duplicates to be detected). The relation has an attribute to indicate if the message has been processed, which is set to false when the message is inserted in the relation. Note that this relation acts as a message <i>inbox</i>.</p><p style="padding-left: 107pt;text-indent: 15pt;text-align: right;">After the transaction commits, or if the message was already present in the relation, the receiving node sends an acknowledgment back to the sending node. Note that sending the acknowledgment before the transaction commits is not safe, since a system failure may then result in loss of the message. Checking whether the message has been received earlier is essential to avoid multiple de-</p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">liveries of the message.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3273.png"/></span></p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Processing of message</b>. Received messages must be processed to carry out the ac- tions speciﬁed in the message. A process at the receiving node monitors the <i>re- ceived messages </i>relation to check for messages that have not been processed. When it ﬁnds such a message, the message is processed, and as part of the same transac- tion that processes the message, the processed ﬂag is set to true. This ensures that a message is processed exactly once after it is received.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3274.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3275.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_3276.png"/></span></p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>Deletion of old messages</b>. In many messaging systems, it is possible for messages to get delayed arbitrarily, although such delays are very unlikely. Therefore, to be safe, the message must never be deleted from the <i>received messages </i>relation. Deleting it could result in a duplicate delivery not being detected. But as a result, the <i>received messages </i>relation may grow indeﬁnitely. To deal with this problem, each message is given a timestamp, and if the timestamp of a received message is older than some cutoﬀ, the message is discarded. All messages recorded in the <i>received messages </i>relation that are older than the cutoﬀ can be deleted.</p><p class="s13" style="padding-top: 8pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Workflows <span class="p">provide a general model of distributed transaction processing involving multiple nodes and possibly human processing of certain steps, and they are supported by application software used by enterprises. For instance, as we saw in Section 9.6.1, when a bank receives a loan application, there are many steps it must take, including contacting external credit-checking agencies, before approving or rejecting a loan appli- cation. The steps, together, form a workﬂow. Persistent messaging forms the underlying basis for supporting workﬂows in a distributed environment.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part418.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part420.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
