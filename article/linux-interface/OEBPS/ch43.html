<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 43. Interprocess Communication Overview</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch42.html" title="Chapter 42. Advanced Features of Shared Libraries"/><link rel="next" href="ch44.html" title="Chapter 44. Pipes and FIFOs"/></head><body><section class="chapter" title="Chapter 43. Interprocess Communication Overview" epub:type="chapter" id="interprocess_communication_overview"><div class="titlepage"><div><div><h2 class="title">Chapter 43. Interprocess Communication Overview</h2></div></div></div><p>This chapter presents a brief overview of the facilities that processes and threads
            can use to communicate with one another and to synchronize their actions. The following
            chapters provide more details about these facilities.</p><div class="sect1" title="A Taxonomy of IPC Facilities"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_taxonomy_of_ipc_facilities">A Taxonomy of IPC Facilities</h2></div></div></div><p><a class="xref" href="ch43.html#a_taxonomy_of_unix_ipc_facilities" title="Figure 43-1. A taxonomy of UNIX IPC facilities">Figure 43-1</a> summarizes the rich variety of
                UNIX communication and synchronization facilities, dividing them into three broad
                functional categories:<a id="IDX-CHP-43-6027" class="indexterm"/><a id="IDX-CHP-43-6028" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Communication</em></span>: These facilities are concerned with
                        exchanging data between processes.</p></li><li class="listitem"><p><span class="emphasis"><em>Synchronization</em></span>: These facilities are concerned with
                        synchronizing the actions of processes or threads.</p></li><li class="listitem"><p><span class="emphasis"><em>Signals</em></span>: Although signals are intended primarily for
                        other purposes, they can be used as a synchronization technique in certain
                        circumstances. More rarely, signals can be used as a communication
                        technique: the signal number itself is a form of information, and realtime
                        signals can be accompanied by associated data (an integer or a pointer).
                        Signals are described in detail in <a class="xref" href="ch20.html" title="Chapter 20. Signals: Fundamental Concepts">Chapter 20</a> to <a class="xref" href="ch22.html" title="Chapter 22. Signals: Advanced Features">Chapter 22</a>.</p></li></ul></div><p>Although some of these facilities are concerned with synchronization, the general
                term <span class="emphasis"><em>interprocess communication</em></span> (IPC) is often used to describe
                them all.</p><div class="figure"><a id="a_taxonomy_of_unix_ipc_facilities"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject43_d1e115257"/><img src="figs/web/43-1_IPC-taxonomy.png.jpg" alt="A taxonomy of UNIX IPC facilities"/></div></div><div class="figure-title">Figure 43-1. A taxonomy of UNIX IPC facilities</div></div><p>As <a class="xref" href="ch43.html#a_taxonomy_of_unix_ipc_facilities" title="Figure 43-1. A taxonomy of UNIX IPC facilities">Figure 43-1</a> illustrates, often several
                facilities provide similar IPC functionality. There are a couple of reasons for
                this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Similar facilities evolved on different UNIX variants, and later came to
                        be ported to other UNIX systems. For example, FIFOs were developed on System
                        V, while (stream) sockets were developed on BSD.</p></li><li class="listitem"><p>New facilities have been developed to address design deficiencies in
                        similar earlier facilities. For example, the POSIX IPC facilities (message
                        queues, semaphores, and shared memory) were designed as an improvement on
                        the older System V IPC facilities.</p></li></ul></div><p>In some cases, facilities that are grouped together in <a class="xref" href="ch43.html#a_taxonomy_of_unix_ipc_facilities" title="Figure 43-1. A taxonomy of UNIX IPC facilities">Figure 43-1</a> actually provide significantly
                different functionality. For example, stream sockets can be used to communicate over
                a network, while FIFOs can be used only for communication between processes on the
                same machine.</p></div><div class="sect1" title="Communication Facilities"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="communication_facilities">Communication Facilities</h2></div></div></div><p>The various communication facilities shown in <a class="xref" href="ch43.html#a_taxonomy_of_unix_ipc_facilities" title="Figure 43-1. A taxonomy of UNIX IPC facilities">Figure 43-1</a> allow processes to exchange data
                with one another. (These facilities can also be used to exchange data between the
                threads of a single process, but this is seldom necessary, since threads can
                exchange information via shared global variables.)<a id="IDX-CHP-43-6029" class="indexterm"/><a id="IDX-CHP-43-6030" class="indexterm"/></p><p>We can break the communication facilities into two categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Data-transfer facilities</em></span>: The key factor
                        distinguishing these facilities is the notion of writing and reading. In
                        order to communicate, one process writes data to the IPC facility, and
                        another process reads the data. These facilities require two data transfers
                        between user memory and kernel memory: one transfer from user memory to
                        kernel memory during writing, and another transfer from kernel memory to
                        user memory during reading. (<a class="xref" href="ch43.html#exchanging_data_between_two_processes_us" title="Figure 43-2. Exchanging data between two processes using a pipe">Figure 43-2</a> shows this
                        situation for a pipe.)</p></li><li class="listitem"><p><span class="emphasis"><em>Shared memory</em></span>: Shared memory allows processes to
                        exchange information by placing it in a region of memory that is shared
                        between the processes. (The kernel accomplishes this by making page-table
                        entries in each process point to the same pages of RAM, as shown in <a class="xref" href="ch49.html#two_processes_with_a_shared_mapping_of_t" title="Figure 49-2. Two processes with a shared mapping of the same region of a file">Figure 49-2</a>, in <a class="xref" href="ch49.html#memory-mapped_i_solidus_o" title="Memory-mapped I/O">Memory-mapped I/O</a>.) A process can make data
                        available to other processes by placing it in the shared memory region.
                        Because communication doesn’t require system calls or data transfer between
                        user memory and kernel memory, shared memory can provide very fast
                        communication.</p></li></ul></div><div class="figure"><a id="exchanging_data_between_two_processes_us"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject43_d1e115315"/><img src="figs/web/43-2_IPC-pipe-scale90.png.jpg" alt="Exchanging data between two processes using a pipe"/></div></div><div class="figure-title">Figure 43-2. Exchanging data between two processes using a pipe</div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="data_transfer"/></div></div></div><div class="sect3" title="Data transfer"><div class="titlepage"><div><div><h4 class="title" id="data_transfer-id1">Data transfer</h4></div></div></div><p>We can further break data-transfer facilities into the following
                        subcategories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Byte stream</em></span>: The data exchanged via pipes,
                                FIFOs, and datagram sockets is an undelimited byte stream. Each read
                                operation may read an arbitrary number of bytes from the IPC
                                facility, regardless of the size of blocks written by the writer.
                                This model mirrors the traditional UNIX “file as a sequence of
                                bytes” model.<a id="IDX-CHP-43-6031" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Message</em></span>: The data exchanged via System V
                                message queues, POSIX message queues, and datagram sockets takes the
                                form of delimited messages. Each read operation reads a whole
                                message, as written by the writer process. It is not possible to
                                read part of a message, leaving the remainder on the IPC facility;
                                nor is it possible to read multiple messages in a single read
                                operation.</p></li><li class="listitem"><p><span class="emphasis"><em>Pseudoterminals</em></span>: A pseudoterminal is a
                                communication facility intended for use in specialized situations.
                                We provide details in <a class="xref" href="ch64.html" title="Chapter 64. Pseudoterminals">Chapter 64</a>.</p></li></ul></div><p>A few general features distinguish data-transfer facilities from shared
                            memory:<a id="IDX-CHP-43-6032" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Although a data-transfer facility may have multiple readers, reads
                                are destructive. A read operation consumes data, and that data is
                                not available to any other process.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">MSG_PEEK</code> flag can be
                                    used to perform a nondestructive read from a socket (<a class="xref" href="ch61.html#socket-specific_i_solidus_o_system_calls" title="Socket-Specific I/O System Calls: recv() and send()">Socket-Specific I/O System Calls: <span class="emphasis"><em>recv()</em></span> and
                    <span class="emphasis"><em>send()</em></span></a>). UDP
                                    (Internet domain datagram) sockets allow a single message to be
                                    broadcast or multicast to multiple recipients (<a class="xref" href="ch61.html#tcp_versus_udp" title="TCP Versus UDP">TCP Versus UDP</a>).</p></div></li><li class="listitem"><p>Synchronization between the reader and writer processes is
                                automatic. If a reader attempts to fetch data from a data-transfer
                                facility that currently has no data, then (by default) the read
                                operation will block until some process writes data to the
                                facility.</p></li></ul></div></div><div class="sect3" title="Shared memory"><div class="titlepage"><div><div><h4 class="title" id="shared_memory">Shared memory</h4></div></div></div><p>Most modern UNIX systems provide three flavors of shared memory: System V
                        shared memory, POSIX shared memory, and memory mappings. We consider the
                        differences between them when describing the facilities in later chapters
                        (see <a class="xref" href="ch54.html#comparisons_between_shared_memory_apis" title="Comparisons Between Shared Memory APIs">Comparisons Between Shared Memory APIs</a> in
                        particular).</p><p>Note the following general points about shared memory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Although shared memory provides fast communication, this speed
                                advantage is offset by the need to synchronize operations on the
                                shared memory. For example, one process should not attempt to access
                                a data structure in the shared memory while another process is
                                updating it. A semaphore is the usual synchronization method used
                                with shared memory.</p></li><li class="listitem"><p>Data placed in shared memory is visible to all of the processes
                                that share that memory. (This contrasts with the destructive read
                                semantics described above for data-transfer facilities.)</p></li></ul></div></div></div></div><div class="sect1" title="Synchronization Facilities"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="synchronization_facilities">Synchronization Facilities</h2></div></div></div><p>The synchronization facilities shown in <a class="xref" href="ch43.html#a_taxonomy_of_unix_ipc_facilities" title="Figure 43-1. A taxonomy of UNIX IPC facilities">Figure 43-1</a> allow processes to coordinate
                their actions. Synchronization allows processes to avoid doing things such as
                simultaneously updating a shared memory region or the same part of a file. Without
                synchronization, such simultaneous updates could cause an application to produce
                incorrect results.<a id="IDX-CHP-43-6033" class="indexterm"/><a id="IDX-CHP-43-6034" class="indexterm"/><a id="IDX-CHP-43-6035" class="indexterm"/></p><p>UNIX systems provide the following synchronization facilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Semaphores</em></span>: A semaphore is a kernel-maintained
                        integer whose value is never permitted to fall below 0. A process can
                        decrease or increase the value of a semaphore. If an attempt is made to
                        decrease the value of the semaphore below 0, then the kernel blocks the
                        operation until the semaphore’s value increases to a level that permits the
                        operation to be performed. (Alternatively, the process can request a
                        nonblocking operation; then, instead of blocking, the kernel causes the
                        operation to return immediately with an error indicating that the operation
                        can’t be performed immediately.) The meaning of a semaphore is determined by
                        the application. A process decrements a semaphore (from, say, 1 to 0) in
                        order to reserve exclusive access to some shared resource, and after
                        completing work on the resource, increments the semaphore so that the shared
                        resource is released for use by some other process. The use of a binary
                        semaphore—a semaphore whose value is limited to 0 or 1—is common. However,
                        an application that deals with multiple instances of a shared resource would
                        employ a semaphore whose maximum value equals the number of shared
                        resources. Linux provides both System V semaphores and POSIX semaphores,
                        which have essentially similar functionality.<a id="IDX-CHP-43-6036" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>File locks</em></span>: File locks are a synchronization method
                        explicitly designed to coordinate the actions of multiple processes
                        operating on the same file. They can also be used to coordinate access to
                        other shared resources. File locks come in two flavors: read (shared) locks
                        and write (exclusive) locks. Any number of processes can hold a read lock on
                        the same file (or region of a file). However, when one process holds a write
                        lock on a file (or file region), other processes are prevented from holding
                        either read or write locks on that file (or file region). Linux provides
                        file-locking facilities via the <span class="emphasis"><em>flock()</em></span> and
                            <span class="emphasis"><em>fcntl()</em></span> system calls. The
                            <span class="emphasis"><em>flock()</em></span> system call provides a simple locking
                        mechanism, allowing processes to place a shared or an exclusive lock on an
                        entire file. Because of its limited functionality,
                            <span class="emphasis"><em>flock()</em></span> locking facility is rarely used nowadays.
                        The <span class="emphasis"><em>fcntl()</em></span> system call provides record locking,
                        allowing processes to place multiple read and write locks on different
                        regions of the same file.</p></li><li class="listitem"><p><span class="emphasis"><em>Mutexes and condition variables</em></span>: These
                        synchronization facilities are normally used with POSIX threads, as
                        described in <a class="xref" href="ch30.html" title="Chapter 30. Threads: Thread Synchronization">Chapter 30</a>.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Some UNIX implementations, including Linux systems with a
                        <span class="emphasis"><em>glibc</em></span> that provides the NPTL threading implementation,
                    also allow mutexes and condition variables to be shared between processes. SUSv3
                    permits, but doesn’t require, an implementation to support process-shared
                    mutexes and condition variables. They are not available on all UNIX systems, and
                    so are not commonly employed for process synchronization.</p></div><p>When performing interprocess synchronization, our choice of facility is typically
                determined by the functional requirements. When coordinating access to a file, file
                record locking is usually the best choice. Semaphores are often the better choice
                for coordinating access to other types of shared resource.</p><p>Communication facilities can also be used for synchronization. For example, in
                    <a class="xref" href="ch44.html#pipes_as_a_method_of_process_synchroniza" title="Pipes as a Method of Process Synchronization">Pipes as a Method of Process Synchronization</a>, we show how a pipe
                can be used to synchronize the actions of a parent process with its children. More
                generally, any of the data-transfer facilities can be used for synchronization, with
                the synchronization operation taking the form of exchanging messages via the
                facility.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since kernel 2.6.22, Linux provides an additional, nonstandard synchronization
                    mechanism via the <span class="emphasis"><em>eventfd()</em></span> system call. This system call
                    creates an <span class="emphasis"><em>eventfd</em></span> object that has an associated 8-byte
                    unsigned integer maintained by the kernel. The system call returns a file
                    descriptor that refers to the object. Writing an integer to this file descriptor
                    adds that integer to the object’s value. A <span class="emphasis"><em>read()</em></span> from the
                    file descriptor blocks if the object’s value is 0. If the object has a nonzero
                    value, a <span class="emphasis"><em>read()</em></span> returns that value and resets it to 0. In
                    addition, <span class="emphasis"><em>poll()</em></span>, <span class="emphasis"><em>select()</em></span>, or
                        <span class="emphasis"><em>epoll</em></span> can be used to test if the object has a nonzero
                    value; if it does, the file descriptor indicates as being readable. An
                    application that wishes to use an <span class="emphasis"><em>eventfd</em></span> object for
                    synchronization must first create the object using
                        <span class="emphasis"><em>eventfd()</em></span>, and then call <span class="emphasis"><em>fork()</em></span> to
                    create related processes that inherit file descriptors referring to the object.
                    For further details, see the <span class="emphasis"><em>eventfd(2)</em></span> manual
                        page.<a id="IDX-CHP-43-6037" class="indexterm"/></p></div></div><div class="sect1" title="Comparing IPC Facilities"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="comparing_ipc_facilities">Comparing IPC Facilities</h2></div></div></div><p>When it comes to IPC, we face a range of choices that can at first seem
                bewildering. In later chapters that describe each IPC facility, we include sections
                that compare each facility against other similar facilities. In the following pages,
                we consider a number of general points that may determine the choice of IPC
                    facility.<a id="IDX-CHP-43-6038" class="indexterm"/><a id="IDX-CHP-43-6039" class="indexterm"/><a id="IDX-CHP-43-6040" class="indexterm"/><a id="IDX-CHP-43-6041" class="indexterm"/><a id="IDX-CHP-43-6042" class="indexterm"/><a id="IDX-CHP-43-6043" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="ipc_object_identification_and_handles"/></div></div></div><div class="sect3" title="IPC object identification and handles for open objects"><div class="titlepage"><div><div><h4 class="title" id="ipc_object_identification_and_handles-id1">IPC object identification and handles for open objects</h4></div></div></div><p>In order to access an IPC object, a process must have some means of
                        identifying the object, and once the object has been “opened,” the process
                        must use some type of handle to refer to the open object. <a class="xref" href="ch43.html#identifiers_and_handles_for_various_type" title="Table 43-1. Identifiers and handles for various types of IPC facilities">Table 43-1</a> summarizes these
                        properties for the various types of IPC facilities.</p><div class="table"><a id="identifiers_and_handles_for_various_type"/><div class="table-title">Table 43-1. Identifiers and handles for various types of IPC facilities</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Facility type</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Name used to identify object</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                        <p>Handle used to refer to object in programs</p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Pipe</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>no name</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>file descriptor</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>FIFO<a id="IDX-CHP-43-6044" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>file descriptor</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>UNIX domain socket<a id="IDX-CHP-43-6045" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>file descriptor</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Internet domain socket<a id="IDX-CHP-43-6046" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>IP address + port number</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>file descriptor</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V message queue<a id="IDX-CHP-43-6047" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V IPC key</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>System V IPC identifier</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V semaphore<a id="IDX-CHP-43-6048" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V IPC key</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>System V IPC identifier</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V shared memory<a id="IDX-CHP-43-6049" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V IPC key</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>System V IPC identifier</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX message queue<a id="IDX-CHP-43-6050" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX IPC pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>mqd_t</em></span> (message queue
                                            descriptor)</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX named semaphore<a id="IDX-CHP-43-6051" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX IPC pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>sem_t *</em></span> (semaphore
                                            pointer)</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX unnamed semaphore<a id="IDX-CHP-43-6052" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>no name</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>sem_t *</em></span> (semaphore
                                            pointer)</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX shared memory<a id="IDX-CHP-43-6053" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX IPC pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>file descriptor</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Anonymous mapping</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>no name</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>none</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Memory-mapped file</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>file descriptor</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>flock()</em></span> lock</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>file descriptor</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>fcntl()</em></span> lock</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p>pathname</p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>file descriptor</p>
                                    </td></tr></tbody></table></div></div></div><div class="sect3" title="Functionality"><div class="titlepage"><div><div><h4 class="title" id="functionality">Functionality</h4></div></div></div><p>There are functional differences between the various IPC facilities that
                        can be relevant in determining which facility to use. We begin by
                        summarizing the differences between data-transfer facilities and shared
                            memory:<a id="IDX-CHP-43-6054" class="indexterm"/><a id="IDX-CHP-43-6055" class="indexterm"/><a id="IDX-CHP-43-6056" class="indexterm"/><a id="IDX-CHP-43-6057" class="indexterm"/><a id="IDX-CHP-43-6058" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Data-transfer facilities involve read and write operations, with
                                transferred data being consumable by just one reader process. Flow
                                control between writer and reader, as well as synchronization (so
                                that a reader is blocked when trying to read data from a facility
                                that is currently empty) is automatically handled by the kernel.
                                This model fits well with many application designs.</p></li><li class="listitem"><p>Other application designs more naturally suit a shared-memory
                                model. Shared memory allows one process to make data visible to any
                                number of other processes sharing the same memory region.
                                Communication “operations” are simple—a process can access data in
                                shared memory in the same manner as it accesses any other memory in
                                its virtual address space. On the other hand, the need to handle
                                synchronization (and perhaps flow control) can add to the complexity
                                of a shared-memory design. This model fits well with application
                                designs that need to maintain shared state (e.g., a shared data
                                structure).</p></li></ul></div><p>With respect to the various data-transfer facilities, the following points
                        are worth noting:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Some data-transfer facilities transfer data as a byte stream
                                (pipes, FIFOs, and stream sockets); others are message-oriented
                                (message queues and datagram sockets). Which approach is preferable
                                depends on the application. (An application can also impose a
                                message-oriented model on a byte-stream facility, by using delimiter
                                characters, fixed-length messages, or message headers that encode
                                the length of the total message; see Section 44.8.)</p></li><li class="listitem"><p>A distinctive feature of System V and POSIX message queues,
                                compared with other data-transfer facilities, is the ability to
                                assign a numeric type or priority to a message, so that messages can
                                be delivered in a different order from that in which they were
                                sent.</p></li><li class="listitem"><p>Pipes, FIFOs, and sockets are implemented using file descriptors.
                                These IPC facilities all support a range of alternative I/O models
                                that we describe in <a class="xref" href="ch63.html" title="Chapter 63. Alternative I/O Models">Chapter 63</a>: I/O multiplexing (the <span class="emphasis"><em>select()</em></span> and
                                    <span class="emphasis"><em>poll()</em></span> system calls), signal-driven I/O,
                                and the Linux-specific <span class="emphasis"><em>epoll</em></span> API. The primary
                                benefit of these techniques is that they allow an application to
                                simultaneously monitor multiple file descriptors to see whether I/O
                                is possible on any of them. By contrast, System V message queues
                                don’t employ file descriptors and don’t support these
                                techniques.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, POSIX message queues are also implemented using file
                            descriptors and support the alternative I/O techniques described above.
                            However, this behavior is not specified in SUSv3, and is not supported
                            on most other implementations.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>POSIX message queues provide a notification facility that can send
                                a signal to a process, or instantiate a new thread, when a message
                                arrives on a previously empty queue.</p></li><li class="listitem"><p>UNIX domain sockets provide a feature that allows a file
                                descriptor to be passed from one process to another. This allows one
                                process to open a file and make it available to another process that
                                otherwise might not be able to access the file. We briefly describe
                                this feature in <a class="xref" href="ch61.html#passing_file_descriptors" title="Passing File Descriptors">Passing File Descriptors</a>.<a id="IDX-CHP-43-6059" class="indexterm"/></p></li><li class="listitem"><p>UDP (Internet domain datagram) sockets allow a sender to broadcast
                                or multicast a message to multiple recipients. We briefly describe
                                this feature in <a class="xref" href="ch61.html#tcp_versus_udp" title="TCP Versus UDP">TCP Versus UDP</a>.</p></li></ul></div><p>With respect to process-synchronization facilities, the following points
                        are worth noting:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Record locks placed using <span class="emphasis"><em>fcntl()</em></span> are
                                considered to be owned by the process placing the lock. The kernel
                                uses this ownership property to detect deadlocks (situations where
                                two or more processes are holding locks that block each other’s
                                further lock requests). If a deadlock situation occurs, the kernel
                                denies the lock request of one of the processes, returning an error
                                from the <span class="emphasis"><em>fcntl()</em></span> call to indicate that a
                                deadlock occurred. System V and POSIX semaphores don’t have an
                                ownership property; no deadlock detection occurs for
                                semaphores.</p></li><li class="listitem"><p>Record locks placed using <span class="emphasis"><em>fcntl()</em></span> are
                                automatically released when the process that owns the locks
                                terminates. System V semaphores provide a similar feature in the
                                form of an “undo” feature, but this feature is not reliable in all
                                circumstances (<a class="xref" href="ch47.html#semaphore_undo_values" title="Semaphore Undo Values">Semaphore Undo Values</a>). POSIX
                                semaphores don’t provide an analog of this feature.</p></li></ul></div></div><div class="sect3" title="Network communication"><div class="titlepage"><div><div><h4 class="title" id="network_communication">Network communication</h4></div></div></div><p>Of all of the IPC methods shown in <a class="xref" href="ch43.html#a_taxonomy_of_unix_ipc_facilities" title="Figure 43-1. A taxonomy of UNIX IPC facilities">Figure 43-1</a>, only sockets permit
                        processes to communicate over a network. Sockets are generally used in one
                        of two domains: the UNIX domain, which allows communication between
                        processes on the same system, and the <span class="emphasis"><em>Internet</em></span> domain,
                        which allows communication between processes on different hosts connected
                        via a TCP/IP network. Often, only minor changes are required to convert a
                        program that uses UNIX domain sockets into one that uses Internet domain
                        sockets, so an application that is built using UNIX domain sockets can be
                        made network-capable with relatively little effort.<a id="IDX-CHP-43-6060" class="indexterm"/><a id="IDX-CHP-43-6061" class="indexterm"/></p></div><div class="sect3" title="Portability"><div class="titlepage"><div><div><h4 class="title" id="portability">Portability</h4></div></div></div><p>Modern UNIX implementations support most of the IPC facilities shown in
                            <a class="xref" href="ch43.html#a_taxonomy_of_unix_ipc_facilities" title="Figure 43-1. A taxonomy of UNIX IPC facilities">Figure 43-1</a>. However, the POSIX
                        IPC facilities (message queues, semaphores, and shared memory) are not quite
                        as widely available as their System V IPC counterparts, especially on older
                        UNIX systems. (An implementation of POSIX message queues and full support
                        for POSIX semaphores have appeared on Linux only in the
                            2.6.<span class="emphasis"><em>x</em></span> kernel series.) Therefore, from a portability
                        point of view, System V IPC may be preferable to POSIX IPC.<a id="IDX-CHP-43-6062" class="indexterm"/><a id="IDX-CHP-43-6063" class="indexterm"/></p></div><div class="sect3" title="System V IPC design issues"><div class="titlepage"><div><div><h4 class="title" id="system_v_ipc_design_issues">System V IPC design issues</h4></div></div></div><p>The System V IPC facilities were designed independently of the traditional
                        UNIX I/O model, and consequently suffer a few peculiarities that make their
                        programming interfaces more complicated to use. The corresponding POSIX IPC
                        facilities were designed to address these problems. The following points are
                        of particular note:<a id="IDX-CHP-43-6064" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The System V IPC facilities are connectionless. These facilities
                                provide no notion of a handle (like a file descriptor) referring to
                                an open IPC object. In later chapters, we’ll sometimes talk of
                                “opening” a System V IPC object, but this is really just shorthand
                                to describe the process of obtaining a handle to refer to the
                                object. The kernel does not record the process as having “opened”
                                the object (unlike other types of IPC objects). This means that the
                                kernel can’t maintain a reference count of the number of processes
                                that are currently using an object. Consequently, it can require
                                additional programming effort for an application to be able to know
                                when an object can safely be deleted.</p></li><li class="listitem"><p>The programming interfaces for the System V IPC facilities are
                                inconsistent with the traditional UNIX I/O model (they use integer
                                key values and IPC identifiers instead of pathnames and file
                                descriptors). The programming interfaces are also overly complex.
                                This last point applies particularly to System V semaphores (refer
                                to <a class="xref" href="ch47.html#disadvantages_of_system_v_semaphores" title="Disadvantages of System V Semaphores">Disadvantages of System V Semaphores</a> and <a class="xref" href="ch53.html#comparisons_with_other_synchronization_t" title="Comparisons with Other Synchronization Techniques">Comparisons with Other Synchronization Techniques</a>).</p></li></ul></div><p>By contrast, the kernel counts open references for POSIX IPC objects. This
                        simplifies decisions about when an object can be deleted. Furthermore, the
                        POSIX IPC facilities provide an interface that is simpler and more
                        consistent with the traditional UNIX model.</p></div><div class="sect3" title="Accessibility"><div class="titlepage"><div><div><h4 class="title" id="accessibility">Accessibility</h4></div></div></div><p>The second column of <a class="xref" href="ch43.html#accessibility_and_persistence_for_variou" title="Table 43-2. Accessibility and persistence for various types of IPC facilities">Table 43-2</a> summarizes an
                        important characteristic of each type of IPC object: the permissions scheme
                        that governs which processes can access the object. The following list adds
                        some details on the various schemes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For some IPC facilities (e.g., FIFOs and sockets), object names
                                live in the file system, and accessibility is determined according
                                to the associated file permissions mask, which specifies permissions
                                for owner, group, and other (<a class="xref" href="ch15.html#file_permissions" title="File Permissions">File Permissions</a>).
                                Although System V IPC objects don’t reside in the file system, each
                                object has an associated permissions mask whose semantics are
                                similar to those for files.</p></li><li class="listitem"><p>A few IPC facilities (pipes, anonymous memory mappings) are marked
                                as being accessible only by related processes. Here,
                                    <span class="emphasis"><em>related</em></span> means related via
                                    <span class="emphasis"><em>fork()</em></span>. In order for two processes to
                                access the object, one of them must create the object and then call
                                    <span class="emphasis"><em>fork()</em></span>. As a consequence of the
                                    <span class="emphasis"><em>fork()</em></span>, the child process inherits a handle
                                referring to the object, allowing both processes to share the
                                object.</p></li><li class="listitem"><p>The accessibility of a POSIX unnamed semaphore is determined by
                                the accessibility of the shared memory region containing the
                                semaphore.</p></li><li class="listitem"><p>In order to place a lock on a file, a process must have a file
                                descriptor referring to the file (i.e., in practice, it must have
                                permission to open the file).</p></li><li class="listitem"><p>There are no restrictions on accessing (i.e., connecting or
                                sending a datagram to) an Internet domain socket. If necessary,
                                access control must be implemented within the application.</p></li></ul></div><div class="table"><a id="accessibility_and_persistence_for_variou"/><div class="table-title">Table 43-2. Accessibility and persistence for various types of IPC
                            facilities</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Facility type</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Accessibility</p>
                                    </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                        <p>Persistence</p>
                                    </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Pipe</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>only by related processes</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>process</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>FIFO<a id="IDX-CHP-43-6065" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>process</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>UNIX domain socket<a id="IDX-CHP-43-6066" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>process</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Internet domain socket<a id="IDX-CHP-43-6067" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>by any process</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>process</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V message queue<a id="IDX-CHP-43-6068" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>kernel</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V semaphore<a id="IDX-CHP-43-6069" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>kernel</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>System V shared memory<a id="IDX-CHP-43-6070" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>kernel</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX message queue<a id="IDX-CHP-43-6071" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>kernel</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX named semaphore<a id="IDX-CHP-43-6072" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>kernel</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX unnamed semaphore<a id="IDX-CHP-43-6073" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions of underlying memory</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>depends</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>POSIX shared memory<a id="IDX-CHP-43-6074" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>kernel</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Anonymous mapping</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>only by related processes</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>process</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>Memory-mapped file</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p>permissions mask</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>file system</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>flock()</em></span> file lock<a id="IDX-CHP-43-6075" class="indexterm"/></p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>open()</em></span> of file</p>
                                    </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                        <p>process</p>
                                    </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>fcntl()</em></span> file lock</p>
                                    </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                        <p><span class="emphasis"><em>open()</em></span> of file</p>
                                    </td><td style="text-align: left; vertical-align: top; ">
                                        <p>process</p>
                                    </td></tr></tbody></table></div></div></div><div class="sect3" title="Persistence"><div class="titlepage"><div><div><h4 class="title" id="persistence">Persistence</h4></div></div></div><p>The term <span class="emphasis"><em>persistence</em></span> refers to the lifetime of an IPC
                        object. (Refer to the third column of <a class="xref" href="ch43.html#accessibility_and_persistence_for_variou" title="Table 43-2. Accessibility and persistence for various types of IPC facilities">Table 43-2</a>.) We can
                        distinguish three types of persistence:<a id="IDX-CHP-43-6077" class="indexterm"/><a id="IDX-CHP-43-6078" class="indexterm"/><a id="IDX-CHP-43-6079" class="indexterm"/><a id="IDX-CHP-43-6080" class="indexterm"/><a id="IDX-CHP-43-6076" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Process persistence</em></span>: A process-persistent IPC
                                object remains in existence only as long as it is held open by at
                                least one process. If the object is closed by all processes, then
                                all kernel resources associated with the object are freed, and any
                                unread data is destroyed. Pipes, FIFOs, and sockets are examples of
                                IPC facilities with process persistence.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The persistence of a FIFO’s data is not the same as the
                                    persistence of its name. A FIFO has a name in the file system
                                    that persists even after all file descriptors referring to the
                                    FIFO have been closed.</p></div></li><li class="listitem"><p><span class="emphasis"><em>Kernel persistence</em></span>: A kernel-persistent IPC
                                object exists until either it is explicitly deleted or the system is
                                shut down. The lifetime of the object is independent of whether any
                                process holds the object open. This means that, for example, one
                                process can create an object, write data to it, and then close it
                                (or terminate). At a later point, another process can open the
                                object and read the data. Examples of facilities with kernel
                                persistence are System V IPC and POSIX IPC. We exploit this property
                                in the example programs that we present when describing these
                                facilities in later chapters: for each facility, we implement
                                separate programs that create an object, delete an object, and
                                perform communication or synchronization.</p></li><li class="listitem"><p><span class="emphasis"><em>File-system persistence</em></span>: An IPC object with
                                file-system persistence retains its information even when the system
                                is rebooted. The object exists until it is explicitly deleted. The
                                only type of IPC object that demonstrates file-system persistence is
                                shared memory based on a memory-mapped file.</p></li></ul></div></div><div class="sect3" title="Performance"><div class="titlepage"><div><div><h4 class="title" id="performance">Performance</h4></div></div></div><p>In some circumstances, different IPC facilities may show notable
                        differences in performance. However, in later chapters, we generally refrain
                        from making performance comparisons, for the following reasons:<a id="IDX-CHP-43-6081" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The performance of an IPC facility may not be a significant factor
                                in the overall performance of an application, and it may not be the
                                only factor in determining the choice of an IPC facility.</p></li><li class="listitem"><p>The relative performance of the various IPC facilities may vary
                                across UNIX implementations or between different versions of the
                                Linux kernel.</p></li><li class="listitem"><p>Most importantly, the performance of an IPC facility will vary
                                depending on the precise manner and environment in which it is used.
                                Relevant factors include the size of the data units exchanged in
                                each IPC operation, the amount of unread data that may be
                                outstanding on the IPC facility, whether or not a process context
                                switch is required for each unit of data exchanged, and other load
                                on the system.</p></li></ul></div><p>If IPC performance is crucial, there is no substitute for
                        application-specific benchmarks run under an environment that matches the
                        target system. To this end, it may be worth writing an abstract software
                        layer that hides details of the IPC facility from the application and then
                        testing performance when different IPC facilities are substituted underneath
                        the abstract layer.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id42">Summary</h2></div></div></div><p>In this chapter, we provided an overview of various facilities that processes (and
                threads) can use to communicate with one another and to synchronize their
                actions.</p><p>Among the communication facilities provided on Linux are pipes, FIFOs, sockets,
                message queues, and shared memory. Synchronization facilities provided on Linux
                include semaphores and file locks.</p><p>In many cases, we have a choice of several possible techniques for communication
                and synchronization when performing a given task. In the course of this chapter, we
                compared the different techniques in various ways, with the aim of highlighting some
                differences that may influence the choice of one technique over another.</p><p>In the following chapters, we go into each of the communication and
                synchronization facilities in much more detail.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id28">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Write a program that measures the bandwidth provided by pipes. As
                        command-line arguments, the program should accept the number of data blocks
                        to be sent and the size of each data block. After creating a pipe, the
                        program splits into two process: a child that writes the data blocks to the
                        pipe as fast as possible, and a parent that reads the data blocks. After all
                        data has been read, the parent should print the elapsed time required and
                        the bandwidth (bytes transferred per second). Measure the bandwidth for
                        different data block sizes.</p></li><li class="listitem"><p>Repeat the preceding exercise for System V message queues, POSIX message
                        queues, UNIX domain stream sockets, and UNIX domain datagram sockets. Use
                        these programs to compare the relative performance of the various IPC
                        facilities on Linux. If you have access to other UNIX implementations,
                        perform the same comparisons on those systems.</p></li></ol></div></div></section></body></html>
