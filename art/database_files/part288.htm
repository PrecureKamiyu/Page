<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>15.9  Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part287.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part289.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">15.9  <span style=" color: #00AEEF;">Summary</span></p><p class="s39" style="padding-top: 9pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The ﬁrst action that the system must perform on a query is to translate the query into its internal form, which (for relational database systems) is usually based on the relational algebra. In the process of generating the internal form of the query, the parser checks the syntax of the user’s query, veriﬁes that the relation names appearing in the query are names of relations in the database, and so on. If the query was expressed in terms of a view, the parser replaces all references to the view name with the relational-algebra expression to compute the view.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Given a query, there are generally a variety of methods for computing the answer. It is the responsibility of the query optimizer to transform the query as entered by the user into an equivalent query that can be computed more eﬃciently. Chapter 16 covers query optimization.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">We can process simple selection operations by performing a linear scan or by making use of indices. We can handle complex selections by computing unions and intersections of the results of simple selections.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: justify;">• <span class="s40">We can sort relations larger than memory by the external sort– merge algorithm.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Queries involving a natural join may be processed in several ways, depending on the availability of indices and the form of physical storage for the relations.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s50" style="padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: left;">° <span class="s51">If the join result is almost as large as the Cartesian product of the two relations, a </span><span class="s13">block nested-loop </span><span class="p">join strategy may be advantageous.</span></p><p class="s50" style="padding-top: 6pt;padding-left: 113pt;text-indent: 0pt;text-align: left;">° <span class="s51">If indices are available, the </span><span class="s13">indexed nested-loop </span><span class="p">join can be used.</span></p><p class="s64" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Review Terms  <span class="s164">735</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s50" style="padding-top: 6pt;padding-left: 153pt;text-indent: -8pt;line-height: 76%;text-align: left;">° <span class="s51">If the relations are sorted, a </span><span class="s13">merge join </span><span class="p">may be desirable. It may be advantageous to sort a relation prior to join computation (so as to allow use of the merge-join</span></p><p style="padding-left: 153pt;text-indent: 0pt;text-align: left;">strategy).</p><p class="s50" style="padding-top: 8pt;padding-left: 153pt;text-indent: -8pt;line-height: 77%;text-align: justify;">° <span class="s51">The </span><span class="s13">hash-join </span><span class="p">algorithm partitions the relations into several pieces, such that each piece of one of the relations ﬁts in memory. The partitioning is carried</span></p><p style="padding-left: 153pt;text-indent: 0pt;text-align: justify;">out with a hash function on the join attributes so that corresponding pairs of partitions can be joined independently.</p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Duplicate elimination, projection, set operations (union, intersection, and diﬀer- ence), and aggregation can be done by sorting or by hashing.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: justify;">• <span class="s40">Outer-join operations can be implemented by simple extensions of join algorithms.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Hashing and sorting are dual, in the sense that any operation such as duplicate elimination, projection, aggregation, join, and outer join that can be implemented by hashing can also be implemented by sorting, and vice versa; that is, any opera- tion that can be implemented by sorting can also be implemented by hashing.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">An expression can be evaluated by means of materialization, where the system computes the result of each subexpression and stores it on disk and then uses it to compute the result of the parent expression.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Pipelining helps to avoid writing the results of many subexpressions to disk by using the results in the parent expression even as they are being generated.</span></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part287.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part289.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
