<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Segmentation</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part149.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part151.htm">下一个 &gt;</a></p><p class="s8" style="padding-top: 3pt;padding-left: 240pt;text-indent: 0pt;text-align: left;">Segmentation</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">So far we have been putting the entire address space of each process in memory. With the base and bounds registers, the OS can easily relocate processes to different parts of physical memory. However, you might have noticed something interesting about these address spaces of ours: there is a big chunk of “free” space right in the middle, between the stack and the heap.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As you can imagine from Figure <span style=" color: #00AEEF;">16.1</span>, although the space between the stack and heap is not being used by the process, it is still taking up phys- ical memory when we relocate the entire address space somewhere in physical memory; thus, the simple approach of using a base and bounds register pair to virtualize memory is wasteful. It also makes it quite hard to run a program when the entire address space doesn’t fit into memory; thus, base and bounds is not as flexible as we would like. And thus:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;">T<span class="s7">HE </span>C<span class="s7">RUX</span>: H<span class="s7">OW </span>T<span class="s7">O </span>S<span class="s7">UPPORT </span>A L<span class="s7">ARGE </span>A<span class="s7">DDRESS </span>S<span class="s7">PACE</span></p><p style="padding-left: 9pt;text-indent: 11pt;line-height: 89%;text-align: justify;">How do we support a large address space with (potentially) a lot of free space between the stack and the heap? Note that in our examples, with tiny (pretend) address spaces, the waste doesn’t seem too bad. Imag- ine, however, a 32-bit address space (4 GB in size); a typical program will only use megabytes of memory, but still would demand that the entire address space be resident in memory.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part151.htm">16.1 Segmentation: Generalized Base/Bounds</a><a class="toc0" href="part152.htm">16.2 Which Segment Are We Referring To?</a><a class="toc0" href="part153.htm">16.3 What About The Stack?</a><a class="toc1" href="part154.htm">Table 16.2: Segment Registers (With Negative-Growth Support)</a><a class="toc0" href="part155.htm">16.4 Support for Sharing</a><a class="toc0" href="part156.htm">16.5 Fine-grained vs. Coarse-grained Segmentation</a><a class="toc0" href="part157.htm">16.6 OS Support</a><a class="toc0" href="part158.htm">16.7 Summary</a><a class="toc0" href="part159.htm">References</a><a class="toc0" href="part160.htm">Homework</a><a class="toc1" href="part161.htm">Questions</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part149.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part151.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
