<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>16.5  Materialized Views</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part299.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part301.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">16.5  <span style=" color: #00AEEF;">Materialized Views</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">When a view is deﬁned, normally the database stores only the query deﬁning the view. In contrast, a <span class="s63">materialized view </span>is a view whose contents are computed and stored. Materialized views constitute redundant data, in that their contents can be inferred from the view deﬁnition and the rest of the database contents. However, it is much cheaper in many cases to read the contents of a materialized view than to compute the contents of the view by executing the query deﬁning the view.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">Materialized views are important for improving performance in some applications.</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Consider this view, which gives the total salary in each department:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2945.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2946.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2947.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2948.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2949.png"/></span></p><p style="padding-left: 143pt;text-indent: 0pt;text-align: left;"><b>create view </b><i>department total salary</i>(<i>dept name</i>, <i>total salary</i>) <b>as select </b><i>dept name</i>, <b>sum </b>(<i>salary</i>)</p><p class="s46" style="padding-left: 143pt;text-indent: 0pt;text-align: left;">from <i>instructor</i></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2950.png"/></span></p><p class="s46" style="padding-left: 143pt;text-indent: 0pt;text-align: left;">group by <i>dept name</i><span class="p">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">Suppose the total salary amount at a department is required frequently. Computing the view requires reading every <i>instructor </i>tuple pertaining to a department and summing up the salary amounts, which can be time-consuming. In contrast, if the view deﬁnition of the total salary amount were materialized, the total salary amount could be found by looking up a single tuple in the materialized view.<span class="s76">5</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_2951.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">5<span class="s78">The diﬀerence may not be all that large for a medium-sized university, but in other settings the diﬀerence can be very large. For example, if the materialized view computed total sales of each product, from a sales relation with tens</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">16.5.1 View Maintenance</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">A problem with materialized views is that they must be kept up-to-date when the data used in the view deﬁnition changes. For instance, if the <i>salary </i>value of an instructor is updated, the materialized view will become inconsistent with the underlying data, and it must be updated. The task of keeping a materialized view up-to-date with the underlying data is known as <span class="s63">view maintenance</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Views can be maintained by manually written code: That is, every piece of code that updates the <i>salary </i>value can be modiﬁed to also update the total salary amount for the corresponding department. However, this approach is error prone, since it is easy to miss some places where the <i>salary </i>is updated, and the materialized view will then no longer match the underlying data.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Another option for maintaining materialized views is to deﬁne triggers on insert, delete, and update of each relation in the view deﬁnition. The triggers must modify the contents of the materialized view, to take into account the change that caused the trigger to ﬁre. A simplistic way of doing so is to completely recompute the materialized view on every update.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A better option is to modify only the aﬀected parts of the materialized view, which is known as <span class="s63">incremental view maintenance</span>. We describe how to perform incremental view maintenance in Section 16.5.2.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Modern database systems provide more direct support for incremental view main- tenance. Database-system programmers no longer need to deﬁne triggers for view main- tenance. Instead, once a view is declared to be materialized, the database system com- putes the contents of the view and incrementally updates the contents when the under- lying data change.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Most database systems perform <span class="s63">immediate view maintenance</span>; that is, incremental view maintenance is performed as soon as an update occurs, as part of the updat- ing transaction. Some database systems also support <span class="s63">deferred view maintenance</span>, where view maintenance is deferred to a later time; for example, updates may be collected throughout a day, and materialized views may be updated at night. This approach re- duces the overhead on update transactions. However, materialized views with deferred view maintenance may not be consistent with the underlying relations on which they are deﬁned.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">16.5.2 Incremental View Maintenance</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">To understand how to maintain materialized views incrementally, we start oﬀ by con- sidering individual operations, and then we see how to handle a complete expression.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The changes to a relation that can cause a materialized view to become out-of-date are inserts, deletes, and updates. To simplify our description, we replace updates to a tuple by deletion of the tuple followed by insertion of the updated tuple. Thus, we need</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="96" height="1" alt="image" src="Image_2952.png"/></span></p><p class="s80" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">of millions of tuples, the diﬀerence between computing the aggregate from the underlying data and looking up the materialized view can be many orders of magnitude.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">to consider only inserts and deletes. The changes (inserts and deletes) to a relation or expression are referred to as its <span class="s63">diﬀerential</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">16.5.2.1 Join Operation</p><p class="s13" style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;line-height: 79%;text-align: justify;"><span class="p">Consider the materialized view </span>v <span class="s15">= </span>r <span class="s86">⋈ </span>s<span class="p">. Suppose we modify </span>r <span class="p">by inserting a set of tuples denoted by </span>i<span class="s97">r </span><span class="p">. If the old value of </span>r <span class="p">is denoted by </span>r <span class="s238">old</span><span class="p">, and the new value of </span>r <span class="p">by </span>r <span class="s238">new</span><span class="p">, </span>r <span class="s238">new</span> <span class="s15">= </span>r <span class="s238">old</span> <span class="s15">∪ </span>i<span class="s145">r </span><span class="p">. Now, the old value of the view, </span>v <span class="s238">old</span><span class="p">, is given by </span>r <span class="s238">old</span> <span class="s86">⋈ </span>s<span class="p">, and the new value </span>v <span class="s238">new</span> <span class="p">is given by </span>r <span class="s238">new</span> <span class="s86">⋈ </span>s<span class="p">. We can rewrite </span>r <span class="s238">new</span> <span class="s86">⋈ </span>s <span class="p">as (</span>r <span class="s238">old</span> <span class="s15">∪ </span>i<span class="s145">r </span><span class="p">) </span><span class="s86">⋈ </span>s<span class="p">, which we can again rewrite as (</span>r <span class="s238">old</span> <span class="s86">⋈ </span>s<span class="p">) </span><span class="s15">∪ </span><span class="p">(</span>i<span class="s97">r </span><span class="s86">⋈ </span>s<span class="p">). In other words:</span></p><p class="s13" style="padding-top: 8pt;padding-left: 63pt;text-indent: 0pt;text-align: center;">v <span class="s238">new</span> <span class="s15">= </span>v <span class="s238">old</span> <span class="s15">∪ </span><span class="p">(</span>i<span class="s97">r </span><span class="s86">⋈ </span>s<span class="p">)</span></p><p class="s13" style="padding-top: 8pt;padding-left: 88pt;text-indent: 0pt;line-height: 93%;text-align: justify;"><span class="p">Thus, to update the materialized view </span>v<span class="p">, we simply need to add the tuples </span>i<span class="s97">r </span><span class="s86">⋈ </span>s <span class="p">to the old contents of the materialized view. Inserts to </span>s <span class="p">are handled in an exactly symmetric fashion.</span></p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 90%;text-align: justify;">Now suppose <i>r </i>is modiﬁed by deleting a set of tuples denoted by <i>d</i><span class="s145">r </span>. Using the same reasoning as above, we get:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 88pt;text-indent: 140pt;line-height: 158%;text-align: left;">v <span class="s238">new</span> <span class="s15">= </span>v <span class="s238">old</span> <span class="s15">− </span><span class="p">(</span>d<span class="s97">r </span><span class="s86">⋈ </span>s<span class="p">) Deletes on </span>s <span class="p">are handled in an exactly symmetric fashion.</span></p><p class="s183" style="padding-top: 10pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">16.5.2.2 Selection and Projection Operations</p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;line-height: 90%;text-align: left;">Consider a view <i>v </i><span class="s15">= σ</span><span class="s137">θ</span>(<i>r</i>). If we modify <i>r </i>by inserting a set of tuples <i>i</i><span class="s145">r </span>, the new value of <i>v </i>can be computed as:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 63pt;text-indent: 0pt;text-align: center;">v <span class="s417">new </span><span class="s15">= </span>v <span class="s417">old </span><span class="s15">∪ σ</span><span class="s418">θ</span><span class="p">(</span>i<span class="s97">r </span><span class="p">)</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;line-height: 87%;text-align: left;">Similarly, if <i>r </i>is modiﬁed by deleting a set of tuples <i>d</i><span class="s97">r </span>, the new value of <i>v </i>can be com- puted as:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 63pt;text-indent: 0pt;text-align: center;">v <span class="s417">new </span><span class="s15">= </span>v <span class="s417">old </span><span class="s15">− σ</span><span class="s419">θ</span><span class="p">(</span>d<span class="s145">r </span><span class="p">)</span></p><p style="padding-top: 10pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Projection is a more diﬃcult operation with which to deal. Consider a materialized view <i>v </i><span class="s15">= Π</span><i>A</i>(<i>r</i>). Suppose the relation <i>r </i>is on the schema <i>R </i><span class="s15">= </span>(<i>A</i>, <i>B</i>), and <i>r </i>contains two tuples (<i>a</i>, 2) and (<i>a</i>, 3). Then, <span class="s15">Π</span><i>A</i>(<i>r</i>) has a single tuple (<i>a</i>). If we delete the tuple (<i>a</i>, 2) from <i>r</i>, we cannot delete the tuple (<i>a</i>) from <span class="s15">Π</span><i>A</i>(<i>r</i>): If we did so, the result would be an empty relation, whereas in reality <span class="s15">Π</span><i>A</i>(<i>r</i>) still has a single tuple (<i>a</i>). The reason is that the same tuple (<i>a</i>) is derived in two ways, and deleting one tuple from <i>r </i>removes only one of the ways of deriving (<i>a</i>); the other is still present.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">This reason also gives us the intuition for a solution: For each tuple in a projection such as <span class="s15">Π</span><i>A</i>(<i>r</i>), we will keep a count of how many times it was derived.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 7pt;padding-left: 119pt;text-indent: 17pt;line-height: 68%;text-align: justify;"><span class="p">When a set of tuples </span>d<span class="s145">r </span><span class="p">is deleted from </span>r<span class="p">, for each tuple </span>t <span class="p">in </span>d<span class="s145">r </span><span class="p">we do the following: Let </span>t<span class="s83">.</span>A <span class="p">denote the projection of </span>t <span class="p">on the attribute </span>A<span class="p">. We ﬁnd (</span>t<span class="s83">.</span>A<span class="p">) in the materialized view and decrease the count stored with it by 1. If the count becomes 0, (</span>t<span class="s83">.</span>A<span class="p">) is deleted from the materialized view.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 119pt;text-indent: 17pt;line-height: 68%;text-align: justify;"><span class="p">Handling insertions is relatively straightforward. When a set of tuples </span>i<span class="s97">r </span><span class="p">is inserted into </span>r<span class="p">, for each tuple </span>t <span class="p">in </span>i<span class="s145">r </span><span class="p">we do the following: If (</span>t<span class="s83">.</span>A<span class="p">) is already present in the ma- terialized view, we increase the count stored with it by 1. If not, we add (</span>t<span class="s83">.</span>A<span class="p">) to the materialized view, with the count set to 1.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">16.5.2.3 Aggregation Operations</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Aggregation operations proceed somewhat like projections. The aggregate operations in <span class="s44">SQL </span>are <b>count, sum, avg, min, </b>and <b>max</b>:</p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>count</b>: Consider a materialized view <i>v </i><span class="s15">= </span><i>G</i><span class="s15">γ</span><i>count</i><span class="s98">(</span><i>B</i><span class="s98">)</span>(<i>r</i>), which computes the count of the attribute <i>B</i>, after grouping <i>r </i>by attribute <i>G</i>.</p><p class="s13" style="padding-top: 2pt;padding-left: 139pt;text-indent: 13pt;line-height: 68%;text-align: justify;"><span class="p">When a set of tuples </span>i<span class="s97">r </span><span class="p">is inserted into </span>r<span class="p">, for each tuple </span>t <span class="p">in </span>i<span class="s97">r </span><span class="p">we do the following: We look for the group </span>t<span class="s83">.</span>G <span class="p">in the materialized view. If it is not present, we add (</span>t<span class="s83">.</span>G<span class="p">, 1) to the materialized view. If the group </span>t<span class="s83">.</span>G <span class="p">is present, we add 1 to the count of the group.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 139pt;text-indent: 15pt;line-height: 72%;text-align: justify;"><span class="p">When a set of tuples </span>d<span class="s145">r </span><span class="p">is deleted from </span>r<span class="p">, for each tuple </span>t <span class="p">in </span>d<span class="s145">r </span><span class="p">we do the following: We look for the group </span>t<span class="s83">.</span>G <span class="p">in the materialized view and subtract 1 from the count for the group. If the count becomes 0, we delete the tuple for the group</span></p><p class="s13" style="padding-left: 139pt;text-indent: 0pt;line-height: 19pt;text-align: justify;">t<span class="s83">.</span>G <span class="p">from the materialized view.</span></p><p class="s123" style="padding-left: 123pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="s39">• </span><b>sum</b><span class="p">: Consider a materialized view </span><span class="s13">v </span><span class="s15">= </span>G<span class="s15">γ</span>sum<span class="s98">(</span>B<span class="s98">)</span><span class="p">(</span><span class="s13">r</span><span class="p">).</span></p><p class="s13" style="padding-top: 2pt;padding-left: 139pt;text-indent: 0pt;line-height: 65%;text-align: justify;"><span class="p">When a set of tuples </span>i<span class="s97">r </span><span class="p">is inserted into </span>r<span class="p">, for each tuple </span>t <span class="p">in </span>i<span class="s97">r </span><span class="p">we do the following: We look for the group </span>t<span class="s83">.</span>G <span class="p">in the materialized view. If it is not present, we add (</span>t<span class="s83">.</span>G<span class="p">, </span>t<span class="s83">.</span>B<span class="p">) to the materialized view; in addition, we store a count of 1 associated with (</span>t<span class="s83">.</span>G<span class="p">, </span>t<span class="s83">.</span>B<span class="p">), just as we did for projection. If the group </span>t<span class="s83">.</span>G <span class="p">is present, we add the value of </span>t<span class="s83">.</span>B <span class="p">to the aggregate value for the group and add 1 to the count of the group.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 139pt;text-indent: 15pt;line-height: 74%;text-align: justify;"><span class="p">When a set of tuples </span>d<span class="s145">r </span><span class="p">is deleted from </span>r<span class="p">, for each tuple </span>t <span class="p">in </span>d<span class="s145">r </span><span class="p">we do the following: We look for the group </span>t<span class="s83">.</span>G <span class="p">in the materialized view and subtract </span>t<span class="s83">.</span>B <span class="p">from the aggregate value for the group. We also subtract 1 from the count for the group, and if the count becomes 0, we delete the tuple for the group </span>t<span class="s83">.</span>G <span class="p">from the materialized view.</span></p><p style="padding-top: 1pt;padding-left: 139pt;text-indent: 15pt;text-align: justify;">Without keeping the extra count value, we would not be able to distinguish a case where the sum for a group is 0 from the case where the last tuple in a group is deleted.</p><p class="s123" style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;line-height: 15pt;text-align: justify;"><span class="s39">• </span><b>avg</b><span class="p">: Consider a materialized view </span><span class="s13">v </span><span class="s15">= </span>G<span class="s15">γ</span>avg<span class="s98">(</span>B<span class="s98">)</span><span class="p">(</span><span class="s13">r</span><span class="p">).</span></p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">Directly updating the average on an insert or delete is not possible, since it depends not only on the old average and the tuple being inserted/deleted, but also on the number of tuples in the group.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: 15pt;text-align: justify;">Instead, to handle the case of <b>avg</b>, we maintain the <b>sum </b>and <b>count </b>aggregate values as described earlier and compute the average as the sum divided by the count.</p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><b>min, max</b>: Consider a materialized view <i>v </i><span class="s15">= </span><i>G</i><span class="s15">γ</span><i>min</i><span class="s98">(</span><i>B</i><span class="s98">)</span>(<i>r</i>). (The case of <b>max </b>is exactly equivalent.)</p><p style="padding-left: 107pt;text-indent: 15pt;text-align: justify;">Handling insertions on <i>r </i>is straightforward, similar to the case of <b>sum</b>. Main- taining the aggregate values <b>min </b>and <b>max </b>on deletions may be more expensive. For example, if the tuple <i>t </i>corresponding to the minimum value for a group is deleted from <i>r</i>, we have to look at the other tuples of <i>r </i>that are in the same group to ﬁnd the new minimum value. It is a good idea to create an ordered index on (<i>G</i>, <i>B</i>) since it would help us to ﬁnd the new minimum value for a group very eﬃciently.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s183" style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">16.5.2.4 Other Operations</p><p class="s13" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><span class="p">The set operation </span>intersection <span class="p">is maintained as follows: Given materialized view </span>v <span class="s15">= </span>r <span class="s15">∩ </span>s<span class="p">, when a tuple is inserted in </span>r <span class="p">we check if it is present in </span>s<span class="p">, and if so we add it to </span>v<span class="p">. If a tuple is deleted from </span>r<span class="p">, we delete it from the intersection if it is present. The other set operations, </span>union <span class="p">and </span>set diﬀerence<span class="p">, are handled in a similar fashion; we leave details to you.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Outer joins are handled in much the same way as joins, but with some extra work. In the case of deletion from <i>r </i>we have to handle tuples in <i>s </i>that no longer match any tuple in <i>r</i>. In the case of insertion to <i>r</i>, we have to handle tuples in <i>s </i>that did not match any tuple in <i>r</i>. Again we leave details to you.</p><p class="s183" style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">16.5.2.5 Handling Expressions</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: right;">So far we have seen how to update incrementally the result of a single operation. To handle an entire expression, we can derive expressions for computing the incremental change to the result of each subexpression, starting from the smallest subexpressions. For example, suppose we wish to incrementally update a materialized view <i>E</i><span class="s98">1</span> <span class="s86">⋈ </span><i>E</i><span class="s98">2</span> when a set of tuples <i>i</i><span class="s145">r </span>is inserted into relation <i>r</i>. Let us assume <i>r </i>is used in <i>E</i><span class="s98">1</span> alone.</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 89%;text-align: left;"><span class="p">Suppose the set of tuples to be inserted into </span>E<span class="s98">1</span><span class="p"> is given by expression </span>D<span class="s98">1</span><span class="p">. Then the expression </span>D<span class="s130">1 </span><span class="s86">⋈ </span>E<span class="s130">2 </span><span class="s94">gives the set of tuples to be inserted into </span>E<span class="s130">1 </span><span class="s86">⋈ </span>E<span class="s130">2</span><span class="s94">.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: left;">See the online bibliographical notes for further details on incremental view main-</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">tenance with expressions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">16.5.3 Query Optimization and Materialized Views</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">Query optimization can be performed by treating materialized views just like regular relations. However, materialized views oﬀer further opportunities for optimization:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;">• <span class="s40">Rewriting queries to use materialized views:</span></p><p class="s13" style="padding-left: 87pt;text-indent: 0pt;line-height: 14pt;text-align: right;"><span class="p">Suppose a materialized view </span>v <span class="s15">= </span>r <span class="s86">⋈ </span>s <span class="p">is available, and a user submits a query</span></p><p class="s13" style="padding-left: 87pt;text-indent: 0pt;line-height: 15pt;text-align: right;">r <span class="s86">⋈ </span>s <span class="s86">⋈ </span>t<span class="p">. Rewriting the query as </span>v <span class="s86">⋈ </span>t <span class="p">may provide a more eﬃcient query plan</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;"><a name="bookmark341">than optimizing the query as submitted. Thus, it is the job of the query optimizer to recognize when a materialized view can be used to speed up a query.</a><a name="bookmark361">&zwnj;</a></p><p class="s39" style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">• <span class="s40">Replacing a use of a materialized view with the view deﬁnition:</span></p><p class="s13" style="padding-left: 139pt;text-indent: 15pt;line-height: 91%;text-align: justify;"><span class="p">Suppose a materialized view </span>v <span class="s15">= </span>r <span class="s86">⋈ </span>s <span class="p">is available, but without any index on it, and a user submits a query </span><span class="s15">σ</span><span class="s123">A</span><span class="s137">=</span><span class="s98">10</span><span class="p">(</span>v<span class="p">). Suppose also that </span>s <span class="p">has an index on the common attribute </span>B<span class="p">, and </span>r <span class="p">has an index on attribute </span>A<span class="p">. The best plan for this query may be to replace </span>v <span class="p">with </span>r <span class="s86">⋈ </span>s<span class="p">, which can lead to the query plan </span><span class="s15">σ</span><span class="s123">A</span><span class="s137">=</span><span class="s98">10</span><span class="p">(</span>r<span class="p">) </span><span class="s86">⋈ </span>s<span class="p">; the</span></p><p class="s13" style="padding-left: 139pt;text-indent: 0pt;line-height: 70%;text-align: justify;"><span class="p">selection and join can be performed eﬃciently by using the indices on </span>r<span class="s83">.</span>A <span class="p">and </span>s<span class="s83">.</span>B<span class="p">, respectively. In contrast, evaluating the selection directly on </span>v <span class="p">may require a full</span></p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">scan of <i>v</i>, which may be more expensive.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">The online bibliographical notes give pointers to research showing how to perform query optimization eﬃciently with materialized views.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">16.5.4 Materialized View and Index Selection</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Another related optimization problem is that of <span class="s63">materialized view selection</span>, namely, “What is the best set of views to materialize?” This decision must be made on the basis of the system <span class="s63">workload</span>, which is a sequence of queries and updates that reﬂects the typical load on the system. One simple criterion would be to select a set of materialized views that minimizes the overall execution time of the workload of queries and updates, including the time taken to maintain the materialized views. Database administrators usually modify this criterion to take into account the importance of diﬀerent queries and updates: Fast response may be required for some queries and updates, but a slow response may be acceptable for others.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: right;">Indices are just like materialized views, in that they too are derived data, can speed up queries, and may slow down updates. Thus, the problem of <span class="s63">index selection </span>is closely related to that of materialized view selection, although it is simpler. We examine index and materialized view selection in more detail in Section 25.1.4.1 and Section 25.1.4.2. Most database systems provide tools to help the database administrator with index and materialized view selection. These tools examine the history of queries and updates and suggest indices and views to be materialized. The Microsoft <span class="s44">SQL </span>Server Database Tuning Assistant, the <span class="s44">IBM DB2 </span>Design Advisor, and the Oracle <span class="s44">SQL </span>Tuning Wizard</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">are examples of such tools.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part299.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part301.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
