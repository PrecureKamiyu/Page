<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:mml="http://www.w3.org/1998/Math/MathML" lang="EN" xml:lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="default-style"/><title>The Art of Multiprocessor Programming</title><link href="Elsevier_eBook.css" rel="stylesheet" type="text/css"/><link href="math.css" rel="stylesheet" type="text/css"/><link href="media.css" media="only screen" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4f1c4a5b-a3e2-48ff-98f3-ff17812cd57a" name="Adept.expected.resource"/></head><body><section epub:type="chapter" role="doc-chapter"><div aria-label="Page 265" epub:type="pagebreak" id="page_265" role="doc-pagebreak"/><div id="CN"><a id="c0010tit1"/></div><header><hgroup><h1 class="chaptitle" id="c0010tit">Chapter 12: Counting, sorting, and distributed coordination</h1></hgroup><section epub:type="preamble"><div class="abstract"><h2 class="h1hd" id="ab0010"><a id="st0010"/>Abstract</h2><p class="abspara">This chapter covers several useful patterns for distributed coordination: combining, counting, diffraction, and sampling. Some of these techniques are deterministic; others use randomization. We cover two basic structures underlying these patterns, trees and combinatorial networks. Although these techniques support a high degree of parallelism with high throughput, they can also increase latency for uncontended execution.</p></div></section><section id="ks0010"><h3 class="h2hd" id="st0015">Keywords</h3><p class="keywords">software combining; combining trees; balancing network; counting networks; sorting networks; diffracting trees; distributed coordination</p></section></header><section><h2 class="h1hd" id="s0010"><a id="st0020"/>12.1 Introduction</h2><p class="textfl" id="p0010">This chapter shows how some important problems that seem inherently sequential can be made highly parallel by “spreading out” coordination tasks among multiple parties. What does this spreading out buy us?</p><p class="text" id="p0015">To answer this question, we need to understand how to measure the performance of a concurrent data structure. There are two measures that come to mind: <i>latency</i>, the time it takes an individual method call to complete, and <i>throughput</i>, the overall rate at which method calls complete. For example, real-time applications might care more about latency, and databases might care more about throughput.</p><p class="text" id="p0020">In Chapter <a href="B9780124159501000215.xhtml">11</a>, we saw how to apply distributed coordination to the <img alt="Image" height="9" src="images/B9780124159501000227/fx001.jpg" width="153"/> class. Here, we cover several useful patterns for distributed coordination: combining, counting, diffraction, and sampling. Some are deterministic, while others use randomization. We also cover two basic structures underlying these patterns: trees and combinatorial networks. Interestingly, for some data structures based on distributed coordination, high throughput does not necessarily mean low latency.</p></section><section><h2 class="h1hd" id="s0015"><a id="st0025"/>12.2 Shared counting</h2><p class="textfl" id="p0025">We recall from Chapter <a href="B9780124159501000203.xhtml">10</a> that a <i>pool</i> is a collection of items that provides <img alt="Image" height="11" src="images/B9780124159501000227/fx002.jpg" width="18"/>() and <img alt="Image" height="11" src="images/B9780124159501000227/fx003.jpg" width="19"/>() methods to insert and remove items (<a href="B9780124159501000203.xhtml">Fig. 10.1</a>). Familiar classes such as stacks and queues can be viewed as pools that provide additional fairness guarantees.</p><p class="text" id="p0030">One way to implement a pool is to use coarse-grained locking, perhaps making both <img alt="Image" height="11" src="images/B9780124159501000227/fx002.jpg" width="18"/>() and <img alt="Image" height="11" src="images/B9780124159501000227/fx003.jpg" width="19"/>() <img alt="Image" height="11" src="images/B9780124159501000227/fx004.jpg" width="79"/> methods. The problem, of course, is that coarse-grained locking is heavy-handed: The lock creates both a <i>sequential bottleneck</i>, forcing all method calls to synchronize, and a <i>hotspot</i>, a source of memory contention. We would prefer to have <img alt="Image" height="9" src="images/B9780124159501000227/fx005.jpg" width="23"/> method calls work in parallel, with less synchronization and lower contention.</p><p class="text" id="p0035">Let us consider the following alternative: The pool's items reside in a cyclic array, where each array entry contains either an item or <i>null</i>. We route threads through two counters. Threads calling <img alt="Image" height="11" src="images/B9780124159501000227/fx002.jpg" width="18"/>() increment one counter to choose an array index into which the new item should be placed. (If that entry is full, the thread waits until it becomes empty.) Similarly, threads calling <img alt="Image" height="11" src="images/B9780124159501000227/fx003.jpg" width="19"/>() increment another counter <span aria-label="Page 266" epub:type="pagebreak" id="page_266" role="doc-pagebreak"/>to choose an array index from which the new item should be removed. (If that entry is empty, the thread waits until it becomes full.)</p><p class="text" id="p0040">This approach replaces one bottleneck, the lock, with two, the counters. Naturally, two bottlenecks are better than one (think about that claim for a second). We now explore the idea that shared counters need not be bottlenecks, and can be effectively parallelized. We face two challenges:</p><div><ol><li class="numlist" id="o0010">1.  We must avoid <i>memory contention</i>, where too many threads try to access the same memory location, stressing the underlying communication network and cache-coherence protocols.</li><li class="numlist" id="o0015">2.  We must achieve real parallelism. Is incrementing a counter an inherently sequential operation, or is it possible for <i>n</i> threads to increment a counter faster than it takes one thread to increment a counter <i>n</i> times?</li></ol></div><p class="textfl"> We now look at several ways to build highly parallel counters through data structures that coordinate the distribution of counter indices.</p></section><section><h2 class="h1hd" id="s0020"><a id="st0030"/>12.3 Software combining</h2><p class="textfl" id="p0055">Here is a linearizable shared-counter class using a pattern called <i>software combining</i>. A <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> is a binary tree of <i>nodes</i>, where each node contains bookkeeping information. The counter's value is stored at the root. Each thread is assigned a leaf, and at most two threads share a leaf, so if there are <i>p</i> physical processors, then there are <span class="hiddenClass"><mml:math><mml:mo stretchy="true">⌈</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌉</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si1.png" style="vertical-align:middle" width="39"/></span> leaves; the number of leaves in a combining tree is its <i>width</i>. To increment the counter, a thread starts at its leaf, and works its way up the tree to the root. If two threads reach a node at approximately the same time, then they <i>combine</i> their increments by adding them together. One thread, the <i>active</i> thread, propagates their combined increments up the tree, while the other, the <i>passive</i> thread, waits for the active thread to complete their combined work. A thread may be active at one level and become passive at a higher level.</p><p class="text" id="p0060">For example, suppose threads <i>A</i> and <i>B</i> share a leaf node. They start at the same time, and their increments are combined at their shared leaf. The first one, say, <i>B</i>, actively continues up to the next level, with the mission of adding 2 to the counter value, while the second, <i>A</i>, passively waits for <i>B</i> to return from the root with an acknowledgment that <i>A</i>'s increment has occurred. At the next level in the tree, <i>B</i> may combine with another thread <i>C</i>, and advance with the renewed intention of adding 3 to the counter value.</p><p class="text" id="p0065">When a thread reaches the root, it adds the sum of its combined increments to the counter's current value. The thread then moves back down the tree, notifying each waiting thread that the increments are now complete.</p><p class="text" id="p0070">Combining trees have an inherent disadvantage with respect to locks: Each increment has a higher latency, that is, the time it takes an individual method call to complete. With a lock, a <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>() call takes <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si2.png" style="vertical-align:middle" width="34"/></span> time, while with a <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/>, it takes <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si3.png" style="vertical-align:middle" width="59"/></span> time. Nevertheless, a <span aria-label="Page 267" epub:type="pagebreak" id="page_267" role="doc-pagebreak"/><img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> is attractive because it promises far better throughput, that is, the overall rate at which method calls complete. For example, using a queue lock, <i>p</i> <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>() calls complete in <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si4.png" style="vertical-align:middle" width="36"/></span> time, at best, while using a <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/>, under ideal conditions where all threads move up the tree together, <i>p</i> <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>() calls complete in <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si3.png" style="vertical-align:middle" width="59"/></span> time, an exponential improvement. Of course, the actual performance is often less than ideal, a subject examined in detail later on. Still, the <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> class, like other techniques we consider later, is intended to benefit throughput, not latency.</p><p class="text" id="p0075">Combining trees can be adapted to apply any associative and commutative function, not just increment, to the value maintained by the tree.</p><section><h3 class="h2hd" id="s0025"><a id="st0035"/>12.3.1 Overview</h3><p class="textfl" id="p0080">Although the idea behind a <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> is simple, the implementation is not. To keep the overall (simple) structure from being submerged in (not-so-simple) detail, we split the data structure into two classes: the <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> class manages navigation within the tree, moving up and down the tree as needed, while the <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class manages each visit to a node. As you go through the algorithm's description, it may be helpful to consult <a href="#f0020" id="cf0015">Fig. 12.3</a>, which shows an example <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> execution.</p><p class="text" id="p0085">This algorithm uses two kinds of synchronization. Short-term synchronization is provided by synchronized methods of the <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class. Each method locks the node for the duration of the call to ensure that it can read and write node fields without interference from other threads. The algorithm also requires excluding threads from a node for durations longer than a single method call. Such long-term synchronization is provided by a Boolean <img alt="Image" height="9" src="images/B9780124159501000227/fx009.jpg" width="38"/> field. When this field is <i>true</i>, no other thread is allowed to access the node.</p><p class="text" id="p0090">The fields of the <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class are shown in <a href="#f0010" id="cf0020">Fig. 12.1</a>. Every node has a <i>combining status</i> (field <img alt="Image" height="9" src="images/B9780124159501000227/fx010.jpg" width="45"/>), which defines what stage of combining concurrent requests a node is in. The possible values for the combining status, and their associated meanings, are:</p><div><ul><li class="bulllist" id="u0010">•  <img alt="Image" height="9" src="images/B9780124159501000227/fx011.jpg" width="24"/>: This node is not in use.</li><li class="bulllist" id="u0015">•  <img alt="Image" height="9" src="images/B9780124159501000227/fx012.jpg" width="31"/>: One active thread has visited this node, and will return to check whether another passive thread has left a value with which to combine.</li><li class="bulllist" id="u0020">•  <img alt="Image" height="9" src="images/B9780124159501000227/fx013.jpg" width="39"/>: A second thread has visited this node and stored a value in the node's <img alt="Image" height="9" src="images/B9780124159501000227/fx014.jpg" width="32"/> field to be combined with the active thread's value, but the combined operation is not yet complete.</li><li class="bulllist" id="u0025">•  <img alt="Image" height="9" src="images/B9780124159501000227/fx015.jpg" width="38"/>: Both threads' operations have been combined and completed, and the second thread's result has been stored in the node's <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> field.</li><li class="bulllist" id="u0030">•  <img alt="Image" height="9" src="images/B9780124159501000227/fx017.jpg" width="25"/>: This value is a special case to indicate that the node is the root, and must be treated specially.</li></ul></div><p class="textfl"/><div class="pageavoid"><figure class="fig" id="f0010"><img alt="Image" height="290" src="images/B9780124159501000227/gr001.jpg" width="321"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.1</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class: the constructors and fields.</div></figcaption></figure></div><p class="text" id="p0120">The <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> class has a field <img alt="Image" height="9" src="images/B9780124159501000227/fx018.jpg" width="25"/>, which is an array of <i>w</i> leaves, where <i>w</i> is the width of the combining tree. Thread <i>i</i> is assigned to <img alt="Image" height="13" src="images/B9780124159501000227/fx019.jpg" width="56"/>, so a combining tree for <i>p</i> threads has width <span class="hiddenClass"><mml:math><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌉</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si5.png" style="vertical-align:middle" width="71"/></span>.</p><p class="text" id="p0125"><span aria-label="Page 268" epub:type="pagebreak" id="page_268" role="doc-pagebreak"/><a href="#f0015" id="cf0025">Fig. 12.2</a> shows the <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> class constructor. To construct a <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> of width <i>w</i>, we create an array of <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> objects of length <span class="hiddenClass"><mml:math><mml:mn>2</mml:mn><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si6.png" style="vertical-align:middle" width="48"/></span>. The root is <img alt="Image" height="9" src="images/B9780124159501000227/fx020.jpg" width="25"/>[0], and for <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mn>2</mml:mn><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si7.png" style="vertical-align:middle" width="100"/></span>, the parent of <img alt="Image" height="9" src="images/B9780124159501000227/fx020.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si8.png" style="vertical-align:middle" width="17"/></span> is <img alt="Image" height="9" src="images/B9780124159501000227/fx020.jpg" width="25"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si9.png" style="vertical-align:middle" width="71"/></span>. The leaf nodes are the last <i>w</i> nodes in the array. The initial combining state is <img alt="Image" height="9" src="images/B9780124159501000227/fx017.jpg" width="25"/> for the root, and <img alt="Image" height="9" src="images/B9780124159501000227/fx011.jpg" width="24"/> for every other node.</p><div class="pageavoid"><figure class="fig" id="f0015"><img alt="Image" height="175" src="images/B9780124159501000227/gr002.jpg" width="284"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.2</span> The <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> class: constructor.</div></figcaption></figure></div><p class="text" id="p0130">The <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/>'s <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>() method, shown in <a href="#f0025" id="cf0030">Fig. 12.4</a>, has four phases. In the <i>precombining phase</i> (lines 16–20), it moves up the tree, applying <img alt="Image" height="11" src="images/B9780124159501000227/fx021.jpg" width="65"/>() to each node. The <img alt="Image" height="11" src="images/B9780124159501000227/fx021.jpg" width="65"/>() method returns <span aria-label="Page 269" epub:type="pagebreak" id="page_269" role="doc-pagebreak"/>a Boolean indicating whether the thread was the first to arrive at the node. If so, the <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>() method continues moving up the tree. The <img alt="Image" height="11" src="images/B9780124159501000227/fx022.jpg" width="25"/> variable is set to the last node visited, which is either the first node at which the thread arrived second, or the root. Parts (a) and (b) of <a href="#f0020" id="cf0035">Fig. 12.3</a> show a precombining <span aria-label="Page 270" epub:type="pagebreak" id="page_270" role="doc-pagebreak"/>phase example. Thread <i>A</i>, which is fastest, stops at the root, while <i>B</i> stops in the middle-level node where it arrived after <i>A</i>, and <i>C</i> stops at the leaf where it arrived after <i>B</i>.</p><div class="pageavoid"><figure class="fig" id="f0020"><img alt="Image" height="595" src="images/B9780124159501000227/gr003.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.3</span> The concurrent traversal of a width 8 combining tree by five threads. The structure is initialized with all nodes unlocked, the root node having the <img alt="Image" height="9" src="images/B9780124159501000227/fx010.jpg" width="45"/> <img alt="Image" height="9" src="images/B9780124159501000227/fx017.jpg" width="25"/> and all other nodes having the <img alt="Image" height="9" src="images/B9780124159501000227/fx010.jpg" width="45"/> <img alt="Image" height="9" src="images/B9780124159501000227/fx011.jpg" width="24"/>.</div></figcaption></figure></div><p class="text" id="p0135"><a href="#f0030" id="cf0040">Fig. 12.5</a> shows <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/>'s <img alt="Image" height="11" src="images/B9780124159501000227/fx021.jpg" width="65"/>() method. The thread waits until the locked field is <i>false</i> (line 20), and then proceeds based on the node's combining status (line 21):</p><div><ul><li class="bulllist" id="u0035">•  <img alt="Image" height="9" src="images/B9780124159501000227/fx011.jpg" width="24"/>: The thread sets the node's status to <img alt="Image" height="9" src="images/B9780124159501000227/fx012.jpg" width="31"/> to indicate that it will return to look for a value for combining. If it finds such a value, it proceeds as the active thread, and the thread that provided that value is passive. The call then returns <i>true</i>, instructing the thread to move up the tree.</li><li class="bulllist" id="u0040">•  <img alt="Image" height="9" src="images/B9780124159501000227/fx012.jpg" width="31"/>: An earlier thread has recently visited this node, and will return to look for a value to combine. The thread stops moving up the tree (by returning <i>false</i>), and starts the next phase, computing the value to combine. Before <img alt="Image" height="11" src="images/B9780124159501000227/fx021.jpg" width="65"/>() returns, the thread places a long-term lock on the node (by setting <img alt="Image" height="9" src="images/B9780124159501000227/fx009.jpg" width="38"/> to <i>true</i>) to prevent the earlier visiting thread from proceeding without combining with the thread's value. <span aria-label="Page 271" epub:type="pagebreak" id="page_271" role="doc-pagebreak"/></li><li class="bulllist" id="u0045">•  <img alt="Image" height="9" src="images/B9780124159501000227/fx017.jpg" width="25"/>: If the thread has reached the root node, it instructs the thread to start the next phase.</li></ul></div><p class="textfl"> (Line 31 is a <i>default</i> case that is executed if an unexpected status is encountered.)</p><p class="text" id="p0155"/><div class="boxg1" id="enun0010"><p class="b1num">Pragma 12.3.1 </p><div><p class="b1textfl" id="p0160">It is good programming practice always to provide an arm for every possible enumeration value, even if we know it cannot happen. If we are wrong, the program is easier to debug, and if we are right, the program may later be changed even by someone who does not know as much as we do. Always program defensively.</p></div></div><p class="textfl"/><p class="text" id="p0165">In the <i>combining phase</i> (<a href="#f0025" id="cf0045">Fig. 12.4</a>, lines 21–26), the thread revisits the nodes it visited in the precombining phase, combining its value with values left by other threads. It stops when it arrives at the node <img alt="Image" height="11" src="images/B9780124159501000227/fx022.jpg" width="25"/>, where the precombining phase ended. We push the nodes we visit onto a stack so that we can traverse them later in reverse order.</p><div class="pageavoid"><figure class="fig" id="f0025"><img alt="Image" height="389" src="images/B9780124159501000227/gr004.jpg" width="375"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.4</span> The <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> class: the <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>() method.</div></figcaption></figure></div><p class="text" id="p0170">The <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class's <img alt="Image" height="9" src="images/B9780124159501000227/fx025.jpg" width="45"/>() method, shown in <a href="#f0035" id="cf0050">Fig. 12.6</a>, adds any values left by a recently arrived passive process to the values combined so far. As before, the thread first waits until the <img alt="Image" height="9" src="images/B9780124159501000227/fx009.jpg" width="38"/> field is <i>false</i>. It then sets the long-term lock on the node, to ensure that late-arriving threads do not attempt to combine with it. If the status is <img alt="Image" height="9" src="images/B9780124159501000227/fx013.jpg" width="39"/>, it adds the other thread's value to the accumulated value; otherwise it returns the value unchanged. In part (c) of <a href="#f0020" id="cf0055">Fig. 12.3</a>, thread <i>A</i> starts ascending the tree in the combining phase. It reaches <span aria-label="Page 272" epub:type="pagebreak" id="page_272" role="doc-pagebreak"/>the second-level node locked by thread <i>B</i> and waits. In part (d), <i>B</i> releases the lock on the second-level node, and <i>A</i> locks the node and, seeing that the node's combining state is <img alt="Image" height="9" src="images/B9780124159501000227/fx013.jpg" width="39"/>, moves to the root with the combined value 3, the sum of the <img alt="Image" height="9" src="images/B9780124159501000227/fx023.jpg" width="65"/> and <img alt="Image" height="9" src="images/B9780124159501000227/fx024.jpg" width="72"/> fields written by <i>A</i> and <i>B</i>, respectively.</p><p class="text" id="p0175">At the start of the <i>operation phase</i> (line 28), the thread has combined all method calls from lower-level nodes; it now examines the node where it stopped at the end of the precombining phase (<a href="#f0040" id="cf0060">Fig. 12.7</a>). If the node is the root, as in part (d) of <a href="#f0020" id="cf0065">Fig. 12.3</a>, then the thread, in this case <i>A</i>, carries out the combined <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>() operations: It adds its accumulated value (3 in the example) to the <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> and returns the <img alt="Image" height="11" src="images/B9780124159501000227/fx026.jpg" width="32"/> value. Otherwise, the thread had set the long-term lock on this node at the end of its precombining phase (<a href="#f0030" id="cf0070">Fig. 12.5</a>, line 26), so it deposits its value as the <img alt="Image" height="9" src="images/B9780124159501000227/fx024.jpg" width="72"/>, unlocks the node, notifies any blocked thread, and waits for the other thread to return a result after propagating the combined operations toward the root. For example, this is the sequence of actions taken by thread <i>B</i> in parts (c) and (d) of <a href="#f0020" id="cf0075">Fig. 12.3</a>. In this case, the other thread will have set the long-term lock, and left it set so that a thread arriving later will wait until the thread has retrieved the result. Thus, the thread must release the long-term lock and notify any blocked thread.</p><div class="pageavoid"><figure class="fig" id="f0030"><img alt="Image" height="257" src="images/B9780124159501000227/gr005.jpg" width="427"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.5</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class: the precombining phase.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0035"><img alt="Image" height="208" src="images/B9780124159501000227/gr006.jpg" width="433"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.6</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class: the combining phase. This method applies addition to <img alt="Image" height="9" src="images/B9780124159501000227/fx023.jpg" width="65"/> and <img alt="Image" height="9" src="images/B9780124159501000227/fx024.jpg" width="72"/>, but any other commutative operation would work just as well.</div></figcaption></figure></div><div class="pageavoid"><figure class="fig" id="f0040"><img alt="Image" height="307" src="images/B9780124159501000227/gr007.jpg" width="367"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.7</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class: applying the operation.</div></figcaption></figure></div><p class="text" id="p0180">When the result arrives, <i>A</i> enters the <i>distribution phase</i>, propagating the result down the tree. In this phase (lines 29–34), the thread moves down the tree, releasing locks and informing passive partners of the values they should report to their own passive partners or to the caller (at the lowest level). The <img alt="Image" height="9" src="images/B9780124159501000227/fx027.jpg" width="66"/> method is shown in <a href="#f0045" id="cf0080">Fig. 12.8</a>. If the state of the node is <img alt="Image" height="9" src="images/B9780124159501000227/fx012.jpg" width="31"/>, no thread combines with the distributing thread, and it can reset the node to its initial state by releasing the lock and setting the state to <img alt="Image" height="9" src="images/B9780124159501000227/fx011.jpg" width="24"/>. If, on the other hand, the state is <img alt="Image" height="9" src="images/B9780124159501000227/fx013.jpg" width="39"/>, the distributing thread updates the result to be the sum of the <img alt="Image" height="11" src="images/B9780124159501000227/fx026.jpg" width="32"/> value brought from higher up the tree, and the <img alt="Image" height="9" src="images/B9780124159501000227/fx012.jpg" width="31"/> value. This reflects <span aria-label="Page 273" epub:type="pagebreak" id="page_273" role="doc-pagebreak"/>a situation in which the active thread at the node managed to perform its increment before the passive one. The passive thread waiting to get a value reads the <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> once the distributing thread sets the status to <img alt="Image" height="9" src="images/B9780124159501000227/fx015.jpg" width="38"/>. For example, in part (e) of <a href="#f0020" id="cf0085">Fig. 12.3</a>, <span aria-label="Page 274" epub:type="pagebreak" id="page_274" role="doc-pagebreak"/>the active thread <i>A</i> executes its distribution phase in the middle-level node, setting the <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> to 5, changing the state to <img alt="Image" height="9" src="images/B9780124159501000227/fx015.jpg" width="38"/>, and descending down to the leaf, returning the value 4 as its output. The passive thread <i>B</i> awakes and sees that the middle-level node's state has changed, and reads result 5.</p><div class="pageavoid"><figure class="fig" id="f0045"><img alt="Image" height="241" src="images/B9780124159501000227/gr008.jpg" width="367"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.8</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx008.jpg" width="25"/> class: the distribution phase.</div></figcaption></figure></div></section><section><h3 class="h2hd" id="s0030"><a id="st0040"/>12.3.2 An extended example</h3><p class="textfl" id="p0185"><a href="#f0020" id="cf0090">Fig. 12.3</a> describes the various phases of a <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> execution. There are five threads, labeled <i>A</i> through <i>E</i>. Each node has six fields, as shown in <a href="#f0010" id="cf0095">Fig. 12.1</a>. Initially, all nodes are unlocked and all but the root are in an <img alt="Image" height="9" src="images/B9780124159501000227/fx011.jpg" width="24"/> combining state. The counter value in the initial state in part (a) is 3, the result of an earlier computation.</p><p class="text" id="p0190">In part (a), to perform a <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>(), threads <i>A</i> and <i>B</i> start the precombining phase. <i>A</i> ascends the tree, changing the nodes it visits from <img alt="Image" height="9" src="images/B9780124159501000227/fx011.jpg" width="24"/> to <img alt="Image" height="9" src="images/B9780124159501000227/fx012.jpg" width="31"/>, indicating that it will be the active thread in combining the values up the tree. Thread <i>B</i> is the active thread at its leaf node, but has not yet arrived at the second-level node shared with <i>A</i>.</p><p class="text" id="p0195">In part (b), <i>B</i> arrives at the second-level node and stops, changing it from <img alt="Image" height="9" src="images/B9780124159501000227/fx012.jpg" width="31"/> to <img alt="Image" height="9" src="images/B9780124159501000227/fx013.jpg" width="39"/>, indicating that it will collect its combined values and wait here for <i>A</i> to proceed with them to the root. <i>B</i> locks the node (changing the <img alt="Image" height="9" src="images/B9780124159501000227/fx009.jpg" width="38"/> field from <i>false</i> to <i>true</i>), preventing <i>A</i> from proceeding with the combining phase without <i>B</i>'s combined value. But <i>B</i> has not combined the values. Before it does so, <i>C</i> starts precombining, arrives at the leaf node, stops, and changes its state to <img alt="Image" height="9" src="images/B9780124159501000227/fx013.jpg" width="39"/>. It also locks the node to prevent <i>B</i> from ascending without its input to the combining phase. Similarly, <i>D</i> starts precombining and successfully reaches the root node. Neither <i>A</i> nor <i>D</i> changes the root node state, and in fact it never changes. They simply mark it as the node where they stopped precombining.</p><p class="text" id="p0200">In part (c), <i>A</i> starts up the tree in the combining phase. It locks the leaf so that any later thread will not be able to proceed in its precombining phase, and will wait until <i>A</i> completes its combining and distribution phases. It reaches the second-level node, locked by <i>B</i>, and waits. In the meantime, <i>C</i> starts combining, but since it stopped at the leaf node, it executes the <img alt="Image" height="9" src="images/B9780124159501000227/fx028.jpg" width="12"/>() method on this node, setting <img alt="Image" height="9" src="images/B9780124159501000227/fx024.jpg" width="72"/> to 1 and then releasing the lock. When <i>B</i> starts its combining phase, the leaf node is unlocked and marked <img alt="Image" height="9" src="images/B9780124159501000227/fx013.jpg" width="39"/>, so <i>B</i> writes 1 to <img alt="Image" height="9" src="images/B9780124159501000227/fx023.jpg" width="65"/> and ascends to the second-level node with a combined value of 2, the result of adding the <img alt="Image" height="9" src="images/B9780124159501000227/fx023.jpg" width="65"/> and <img alt="Image" height="9" src="images/B9780124159501000227/fx024.jpg" width="72"/> fields.</p><p class="text" id="p0205">When it reaches the second-level node, the one at which it stopped in the precombining phase, it calls the <img alt="Image" height="9" src="images/B9780124159501000227/fx028.jpg" width="12"/>() method on this node, setting <img alt="Image" height="9" src="images/B9780124159501000227/fx024.jpg" width="72"/> to 2. <i>A</i> must wait until it releases the lock. Meanwhile, in the right-hand side of the tree, <i>D</i> executes its combining phase, locking nodes as it ascends. Because it meets no other threads with which to combine, it reads 3 in the <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> field in the root and updates it to 4. Thread <i>E</i> then starts precombining, but is late in meeting <i>D</i>. It cannot continue precombining as long as <i>D</i> locks the second-level node.</p><p class="text" id="p0210">In part (d), <i>B</i> releases the lock on the second-level node, and <i>A</i>, seeing that the node is in state <img alt="Image" height="9" src="images/B9780124159501000227/fx013.jpg" width="39"/>, locks the node and moves to the root with the combined value 3, the sum of the <img alt="Image" height="9" src="images/B9780124159501000227/fx023.jpg" width="65"/> and <span aria-label="Page 275" epub:type="pagebreak" id="page_275" role="doc-pagebreak"/><img alt="Image" height="9" src="images/B9780124159501000227/fx024.jpg" width="72"/> fields written, respectively, by <i>A</i> and <i>B</i>. <i>A</i> is delayed while <i>D</i> completes updating the root. Once <i>D</i> is done, <i>A</i> reads 4 in the root's <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> field and updates it to 7. <i>D</i> descends the tree (by popping its local <img alt="Image" height="9" src="images/B9780124159501000227/fx029.jpg" width="32"/>), releasing the locks, and returning the value 3 that it originally read in the root's <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> field. <i>E</i> now continues its ascent in the precombining phase.</p><p class="text" id="p0215">Finally, in part (e), <i>A</i> executes its distribution phase. It returns to the second-level node, setting <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> to 5, changing the state to <img alt="Image" height="9" src="images/B9780124159501000227/fx015.jpg" width="38"/>, and descending to the leaf, returning the value 4 as its output. <i>B</i> awakens and sees the state of the middle-level node has changed, reads 5 as the <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/>, and descends to its leaf where it sets the <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> field to 6 and the state to <img alt="Image" height="9" src="images/B9780124159501000227/fx030.jpg" width="38"/>. <i>B</i> then returns 5 as its output. Finally, <i>C</i> awakens and observes that the leaf node state has changed, reads 6 as the <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/>, which it returns as its output value. Threads <i>A</i> through <i>D</i> return values 3 to 6, which fit the root's <img alt="Image" height="9" src="images/B9780124159501000227/fx016.jpg" width="38"/> field value of 7. The linearization order of the <img alt="Image" height="11" src="images/B9780124159501000227/fx007.jpg" width="99"/>() method calls by the different threads is determined by their order in the tree during the precombining phase.</p></section><section><h3 class="h2hd" id="s0035"><a id="st0045"/>12.3.3 Performance and robustness</h3><p class="textfl" id="p0220">Like all the algorithms described in this chapter, <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/>'s throughput depends in complex ways on the characteristics of both the application and the underlying architecture. Nevertheless, it is worthwhile to review, in qualitative terms, some experimental results from the literature. Readers interested in detailed experimental results (mostly for obsolete architectures) may consult the chapter notes.</p><p class="text" id="p0225">As a thought experiment, a <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> should provide high throughput under ideal circumstances when each thread can combine its increment with another's. But it may provide poor throughput under worst-case circumstances, where many threads arrive late at a locked node, missing the chance to combine, and are forced to wait for the earlier request to ascend and descend the tree.</p><p class="text" id="p0230">In practice, experimental evidence supports this informal analysis. The higher the contention, the greater the observed rate of combining, and the greater the observed speedup. Worse is better. Combining trees are less attractive when concurrency is low. The combining rate decreases rapidly as the arrival rate of increment requests is reduced. Throughput is sensitive to the arrival rate of requests.</p><p class="text" id="p0235">Because combining increases throughput and failure to combine does not, it makes sense for a request arriving at a node to wait for a reasonable duration for another thread to arrive with an increment with which to combine. Not surprisingly, it makes sense to wait for a short time when the contention is low, and longer when contention is high. When contention is sufficiently high, unbounded waiting works very well.</p><p class="text" id="p0240">An algorithm is <i>robust</i> if it performs well in the presence of large fluctuations in request arrival times. The literature suggests that the <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> algorithm with a fixed waiting time is not robust, because high variance in request arrival rates seems to reduce the combining rate.<span aria-label="Page 276" epub:type="pagebreak" id="page_276" role="doc-pagebreak"/></p></section></section><section><h2 class="h1hd" id="s0040"><a id="st0050"/>12.4 Quiescently consistent pools and counters</h2><p class="textfl" id="p0245"/><p class="quote" id="sp0165"><i>First shalt thou take out the Holy Pin. Then shalt thou count to three, no more, no less. Three shall be the number thou shalt count, and the number of the counting shall be three…. Once the number three, being the third number, be reached, then lobbest thou thy Holy Hand Grenade of Antioch towards thy foe, who, being naughty in my sight, shall snuff it.</i></p><p class="quote" id="sp0170"><i>From</i> Monty Python and the Holy Grail<i>.</i></p><p class="textfl"/><p class="text" id="p0250">Not all applications require linearizable counting. Indeed, counter-based <img alt="Image" height="9" src="images/B9780124159501000227/fx005.jpg" width="23"/> implementations require only quiescently consistent<sup><a epub:type="noteref" href="#fn001" id="cf0100" role="doc-noteref">1</a></sup> counting: All that matters is that the counters produce no duplicates and no omissions. It is enough that for every item placed by a <img alt="Image" height="11" src="images/B9780124159501000227/fx002.jpg" width="18"/>() in an array entry, another thread eventually executes a <img alt="Image" height="11" src="images/B9780124159501000227/fx003.jpg" width="19"/>() that accesses that entry, eventually matching <img alt="Image" height="11" src="images/B9780124159501000227/fx002.jpg" width="18"/>() and <img alt="Image" height="11" src="images/B9780124159501000227/fx003.jpg" width="19"/>() calls. (Wraparound may still cause multiple <img alt="Image" height="11" src="images/B9780124159501000227/fx002.jpg" width="18"/>() calls or <img alt="Image" height="11" src="images/B9780124159501000227/fx003.jpg" width="19"/>() calls to compete for the same array entry.)</p></section><section><h2 class="h1hd" id="s0045"><a id="st0055"/>12.5 Counting networks</h2><p class="textfl" id="p0255">Students of tango know that the partners must be tightly coordinated: If they do not move together, the dance does not work, no matter how skilled the dancers may be as individuals. In the same way, combining trees must be tightly coordinated: If requests do not arrive together, the algorithm does not work efficiently, no matter how fast the individual processes.</p><p class="text" id="p0260">We now consider <i>counting networks</i>, which look less like tango and more like a rave: each participant moves at its own pace, but collectively the counter delivers a quiescently consistent set of indices with high throughput.</p><p class="text" id="p0265">Let us imagine that we replace the combining tree's single counter with multiple counters, each of which distributes a subset of indices (see <a href="#f0050" id="cf0105">Fig. 12.9</a>). We allocate <i>w</i> counters (in the figure, <span class="hiddenClass"><mml:math><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si10.png" style="vertical-align:middle" width="41"/></span>), each of which distributes a set of unique indices modulo <i>w</i> (in the figure, for example, the second counter distributes <span class="hiddenClass"><mml:math><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>i</mml:mi><mml:mo>⋅</mml:mo><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si11.png" style="vertical-align:middle" width="132"/></span> for increasing <i>i</i>). The challenge is how to distribute the threads among the counters so that there are no duplications or omissions, and how to do so in a distributed and loosely coordinated way.</p><div class="pageavoid"><figure class="fig" id="f0050"><img alt="Image" height="128" src="images/B9780124159501000227/gr009.jpg" width="496"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.9</span> A quiescently consistent shared counter based on <span class="hiddenClass"><mml:math><mml:mtext mathvariant="italic">w</mml:mtext><mml:mspace width="0.25em"/><mml:mtext mathvariant="sans-serif">=</mml:mtext><mml:mspace width="0.25em"/><mml:mtext mathvariant="sans-serif">4</mml:mtext></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si12.png" style="vertical-align:middle" width="39"/></span> counters preceded by a counting network. Threads traverse the counting network to choose which counters to access.</div></figcaption></figure></div><section><h3 class="h2hd" id="s0050"><a id="st0060"/>12.5.1 Networks that count</h3><p class="textfl" id="p0270">A <i>balancer</i> is a simple switch with two input wires and two output wires, called the <i>top</i> and <i>bottom</i> wires (or sometimes the <i>north</i> and <i>south</i> wires). Tokens arrive on the balancer's input wires at arbitrary times, and emerge on their output wires, at some later time. A balancer can be viewed as a toggle: given a stream of input tokens, it sends one token to the top output wire, and the next to the <span aria-label="Page 277" epub:type="pagebreak" id="page_277" role="doc-pagebreak"/>bottom, and so on, effectively balancing the number of tokens between the two wires (see <a href="#f0055" id="cf0110">Fig. 12.10</a>). More precisely, a balancer has two states: <i>up</i> and <i>down</i>. If the state is <i>up</i>, the next token exits on the top wire; otherwise it exits on the bottom wire.</p><div class="pageavoid"><figure class="fig" id="f0055"><img alt="Image" height="48" src="images/B9780124159501000227/gr010.jpg" width="341"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.10</span> A balancer. Tokens arrive at arbitrary times on arbitrary input lines and are redirected to ensure that when all tokens have exited the balancer, there is at most one more token on the top wire than on the bottom one.</div></figcaption></figure></div><p class="text" id="p0275">We use <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si13.png" style="vertical-align:middle" width="17"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si14.png" style="vertical-align:middle" width="16"/></span> to denote the number of tokens that respectively arrive on a balancer's top and bottom input wires, and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si15.png" style="vertical-align:middle" width="16"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si16.png" style="vertical-align:middle" width="15"/></span> to denote the number that exit on the top and bottom output wires. For brevity, we also use <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si17.png" style="vertical-align:middle" width="14"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si18.png" style="vertical-align:middle" width="13"/></span> to denote the wires themselves. A balancer never creates tokens; at all times,</p><p class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⩾</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="17" src="images/B9780124159501000227/si19.png" width="165"/><a id="deq1"/></p></div><p class="textfl"> A balancer is said to be <i>quiescent</i> if every token that arrived on an input wire has emerged on an output wire:</p><p class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="17" src="images/B9780124159501000227/si20.png" width="165"/><a id="deq2"/></p></div><p class="textfl"> A <i>balancing network</i> is constructed by connecting some balancers' output wires to other balancers' input wires. A balancing network of width <i>w</i> has input wires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si21.png" style="vertical-align:middle" width="107"/></span> (not connected to output wires of balancers), and <i>w</i> output wires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si22.png" style="vertical-align:middle" width="106"/></span> (similarly unconnected). The balancing network's <i>depth</i> is the maximum number of balancers one can traverse starting from any input wire. We consider only balancing networks of finite depth (meaning the wires do not form a loop). Like balancers, balancing networks do not create tokens:</p><p class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>⩾</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="31" src="images/B9780124159501000227/si23.png" width="136"/><a id="deq3"/></p></div><p class="textfl"><span aria-label="Page 278" epub:type="pagebreak" id="page_278" role="doc-pagebreak"/> (We often drop indices from summations when we sum over every element in a sequence.) A balancing network is <i>quiescent</i> if every token that arrived on an input wire has emerged on an output wire:</p><p class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="31" src="images/B9780124159501000227/si24.png" width="136"/><a id="deq4"/></p></div><p class="textfl"/><p class="text" id="p0280">So far, we have described balancing networks as if they were switches in a network. On a shared-memory multiprocessor, however, a balancing network can be implemented as an object in memory. Each balancer is an object, whose wires are references from one balancer to another. Each thread repeatedly traverses the object, starting on some input wire, and emerging at some output wire, effectively shepherding a token through the network.</p><p class="text" id="p0285">Some balancing networks have interesting properties. The network shown in <a href="#f0060" id="cf0115">Fig. 12.11</a> has four input wires and four output wires. Initially, all balancers are <i>up</i>. We can check for ourselves that if any number of tokens enter the network, in any order, on any set of input wires, then they emerge in a regular pattern on the output wires. Informally, no matter how token arrivals are distributed among the input wires, the output distribution is balanced across the output wires, where the top output wires are filled first. If the number of tokens <i>n</i> is a multiple of four (the network width), then the same number of tokens emerges from each wire. If there is one excess token, it emerges on output wire 0; if there are two, they emerge on output wires 0 and 1, and so on. In general, if</p><p class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="31" src="images/B9780124159501000227/si25.png" width="98"/><a id="deq5"/></p></div><p class="textfl"> then, when the network is quiescent,</p><p class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="true">⌉</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="19" src="images/B9780124159501000227/si26.png" width="162"/><a id="deq6"/></p></div><p class="textfl"><span aria-label="Page 279" epub:type="pagebreak" id="page_279" role="doc-pagebreak"/> We call this property the <i>step property</i>.</p><div class="pageavoid"><figure class="fig" id="f0060"><img alt="Image" height="149" src="images/B9780124159501000227/gr011.jpg" width="483"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.11</span> A sequential execution of a <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[4] counting network. Each vertical line represents a balancer, and each balancer's two input and output wires are the horizontal lines it connects to at the dots. In this sequential execution, tokens pass through the network, one completely after the other in the order specified by the numbers on the tokens. We track every token as it passes through the balancers on the way to an output wire. For example, token number 3 enters on wire 2, goes down to wire 3, and ends up on wire 2. Note how the step property is maintained in every balancer, and also in the network as a whole.</div></figcaption></figure></div><p class="text" id="p0290">A balancing network that satisfies the step property is called a <i>counting network</i> because it can easily be adapted to count the number of tokens that have traversed the network. Counting is done, as we described earlier in <a href="#f0050" id="cf0120">Fig. 12.9</a>, by adding a local counter to each output wire <i>i</i>, so that tokens emerging on that wire are assigned consecutive numbers <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si27.png" style="vertical-align:middle" width="254"/></span>.</p><p class="text" id="p0295">The step property can be defined in a number of equivalent ways.</p><p class="text" id="p0300"/><div class="boxg1" id="enun0015"><p class="b1num">Lemma 12.5.1 </p><div><p class="b1textfl" id="p0305">If <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si28.png" style="vertical-align:middle" width="83"/></span> is a sequence of nonnegative integers, the following statements are all equivalent:</p><div><ol><li class="b1numlist" id="o0020">1.  For any <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si29.png" style="vertical-align:middle" width="34"/></span>, <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⩽</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si30.png" style="vertical-align:middle" width="102"/></span>.</li><li class="b1numlist" id="o0025">2.  Either <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si31.png" style="vertical-align:middle" width="48"/></span> for all <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si32.png" style="vertical-align:middle" width="22"/></span>, or there exists some <i>c</i> such that for any <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>c</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si33.png" style="vertical-align:middle" width="34"/></span> and <span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo>⩾</mml:mo><mml:mi>c</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si34.png" style="vertical-align:middle" width="36"/></span>, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si35.png" style="vertical-align:middle" width="75"/></span>.</li><li class="b1numlist" id="o0030">3.  If <span class="hiddenClass"><mml:math><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000227/si36.png" style="vertical-align:middle" width="65"/></span>, then <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:mo stretchy="true">⌉</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000227/si37.png" style="vertical-align:middle" width="75"/></span>.</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/></section><section><h3 class="h2hd" id="s0055"><a id="st0065"/>12.5.2 The bitonic counting network</h3><p class="textfl" id="p0325">In this section, we describe the <i>bitonic counting network</i>, which generalizes the counting network of <a href="#f0060" id="cf0125">Fig. 12.11</a> to a counting network whose width is any power of 2. We give an inductive construction.</p><p class="text" id="p0330">When describing counting networks, we do not care about when tokens arrive, we care only that, when the network is quiescent, the numbers of tokens exiting on the output wires satisfy the step property. Define a width-<i>w</i> sequence of inputs or outputs <span class="hiddenClass"><mml:math><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si38.png" style="vertical-align:middle" width="112"/></span> to be a collection of tokens, partitioned into <i>w</i> subsets <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si17.png" style="vertical-align:middle" width="14"/></span>. The <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si17.png" style="vertical-align:middle" width="14"/></span> are the input tokens that arrive or leave on wire <i>i</i>. As before, we also use <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si17.png" style="vertical-align:middle" width="14"/></span> to denote the size of the set <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si17.png" style="vertical-align:middle" width="14"/></span>.</p><p class="text" id="p0335">We first define the <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network, which has two input sequences, <i>x</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si40.png" style="vertical-align:middle" width="15"/></span>, of width <i>k</i>, and a single output sequence <i>y</i> of width 2<i>k</i>. It guarantees that in any quiescent state, if <i>x</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si40.png" style="vertical-align:middle" width="15"/></span> both satisfy the step property, then so does <i>y</i>. The <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network is defined inductively, as illustrated in <a href="#f0065" id="cf0130">Fig. 12.12</a> for <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si41.png" style="vertical-align:middle" width="38"/></span>. For <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si42.png" style="vertical-align:middle" width="36"/></span>, the <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network is a single balancer. For <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si43.png" style="vertical-align:middle" width="36"/></span>, we construct the <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network with input sequences <i>x</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si40.png" style="vertical-align:middle" width="15"/></span> from two <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> networks and <i>k</i> balancers as follows: Using a <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> network, we merge the even subsequence <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si45.png" style="vertical-align:middle" width="105"/></span> of <i>x</i> with the odd subsequence <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si46.png" style="vertical-align:middle" width="104"/></span> of <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si40.png" style="vertical-align:middle" width="15"/></span> (that is, the sequence <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si47.png" style="vertical-align:middle" width="169"/></span> is the input to the <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> network), while with a second <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> network, we merge the odd subsequence of <i>x</i> with the even subsequence of <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si40.png" style="vertical-align:middle" width="15"/></span>. We call the outputs of these two <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> networks <i>z</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si48.png" style="vertical-align:middle" width="14"/></span>. The final stage of the network combines <i>z</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si48.png" style="vertical-align:middle" width="14"/></span> by sending each pair of wires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si49.png" style="vertical-align:middle" width="13"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si50.png" style="vertical-align:middle" width="14"/></span> into a balancer whose outputs yield <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si51.png" style="vertical-align:middle" width="19"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si52.png" style="vertical-align:middle" width="35"/></span>.</p><div class="pageavoid"><figure class="fig" id="f0065"><img alt="Image" height="110" src="images/B9780124159501000227/gr012.jpg" width="448"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.12</span> On the left-hand side, we see the logical structure of a <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[8] network, into which feed two <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[4] networks, as depicted in <a href="#f0060" id="cf0010">Fig. 12.11</a>. The gray <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[4] network has as inputs the even wires coming out of the top <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[4] network and the odd ones from the lower <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[4] network. In the lower <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[4] the situation is reversed. Once the wires exit the two <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[4] networks, each pair of identically numbered wires is combined by a balancer. On the right-hand side, we see the physical layout of a <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[8] network. The different balancers are color-coded to match the logical structure in the left-hand figure.</div></figcaption></figure></div><p class="text" id="p0340">The <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network consists of <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si53.png" style="vertical-align:middle" width="41"/></span> layers of <i>k</i> balancers each. It provides the step property for its outputs only when its two input sequences also have the step property, which we ensure by filtering the inputs through smaller balancing networks.</p><p class="text" id="p0345"><span aria-label="Page 280" epub:type="pagebreak" id="page_280" role="doc-pagebreak"/>The <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network is constructed by passing the outputs from two <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> networks into a <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network, where the induction is grounded in the <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[2] network consisting of a single balancer, as depicted in <a href="#f0070" id="cf0135">Fig. 12.13</a>. This construction gives us a network consisting of <span class="hiddenClass"><mml:math><mml:mo stretchy="true">(</mml:mo><mml:mfrac linethickness="0"><mml:mrow><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="true">)</mml:mo></mml:math></span><span><img alt="Image" height="29" src="images/B9780124159501000227/si54.png" style="vertical-align:middle" width="66"/></span> layers, each consisting of <i>k</i> balancers.</p><div class="pageavoid"><figure class="fig" id="f0070"><img alt="Image" height="143" src="images/B9780124159501000227/gr013.jpg" width="361"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.13</span> The recursive structure of a <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[2<i>k</i>] counting network. Two <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[<i>k</i>] counting networks feed into a <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[2<i>k</i>] balancing network.</div></figcaption></figure></div><section><h4 class="h3hd" id="s0060"><a id="st0070"/>12.5.2.1 A software bitonic counting network</h4><p class="textfl" id="p0350">So far, we have described counting networks as if they were switches in a network. On a shared-memory multiprocessor, however, a balancing network can be implemented as an object in memory. Each balancer is an object whose wires are references from one balancer to another. Each thread repeatedly traverses the object, starting on some input wire and emerging at some output wire, effectively shepherding a token through the network. Here, we show how to implement a <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network as a shared-memory data structure.</p><p class="text" id="p0355"><span aria-label="Page 281" epub:type="pagebreak" id="page_281" role="doc-pagebreak"/>The <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/> class (<a href="#f0075" id="cf0140">Fig. 12.14</a>) has a single Boolean field: <img alt="Image" height="11" src="images/B9780124159501000227/fx032.jpg" width="38"/>. The synchronized <img alt="Image" height="8" src="images/B9780124159501000227/fx033.jpg" width="52"/>() method complements the <img alt="Image" height="11" src="images/B9780124159501000227/fx032.jpg" width="38"/> field and returns an output wire, either 0 or 1. The <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/> class's <img alt="Image" height="8" src="images/B9780124159501000227/fx033.jpg" width="52"/>() method does not need an argument because the wire on which a token exits a balancer does not depend on the wire on which it enters.</p><div class="pageavoid"><figure class="fig" id="f0075"><img alt="Image" height="224" src="images/B9780124159501000227/gr014.jpg" width="248"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.14</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/> class: a <img alt="Image" height="11" src="images/B9780124159501000227/fx004.jpg" width="79"/> implementation.</div></figcaption></figure></div><p class="text" id="p0360">The <img alt="Image" height="11" src="images/B9780124159501000227/fx034.jpg" width="39"/> class (<a href="#f0080" id="cf0145">Fig. 12.15</a>) has three fields: The <img alt="Image" height="9" src="images/B9780124159501000227/fx035.jpg" width="32"/> field must be a power of 2, <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[] is a two-element array of half-width <img alt="Image" height="11" src="images/B9780124159501000227/fx034.jpg" width="39"/> objects (empty if the network has width 2), and <img alt="Image" height="11" src="images/B9780124159501000227/fx037.jpg" width="32"/>[] is an array of <img alt="Image" height="13" src="images/B9780124159501000227/fx038.jpg" width="46"/> balancers implementing the final network layer. The class provides a <img alt="Image" height="8" src="images/B9780124159501000227/fx033.jpg" width="52"/>(<i>i</i>) method, where <i>i</i> is the wire on which the token enters. (For merger networks, unlike balancers, a token's path depends on its input wire.) If the input wire is one of the first <img alt="Image" height="13" src="images/B9780124159501000227/fx038.jpg" width="46"/>, then the token is sent to <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[0] if <i>i</i> is even and to <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[1] if <i>i</i> is odd. Otherwise, it is sent to <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[0] if <i>i</i> is odd and to <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[1] if <i>i</i> is even. No matter which half-width merger network it traverses, a token that emerges on wire <i>i</i> is fed to the balancer at <img alt="Image" height="11" src="images/B9780124159501000227/fx037.jpg" width="32"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si8.png" style="vertical-align:middle" width="17"/></span>.</p><div class="pageavoid"><figure class="fig" id="f0080"><img alt="Image" height="372" src="images/B9780124159501000227/gr015.jpg" width="428"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.15</span> The <img alt="Image" height="11" src="images/B9780124159501000227/fx034.jpg" width="39"/> class.</div></figcaption></figure></div><p class="text" id="p0365">The <img alt="Image" height="9" src="images/B9780124159501000227/fx039.jpg" width="45"/> class (<a href="#f0085" id="cf0150">Fig. 12.16</a>) also has three fields: <img alt="Image" height="9" src="images/B9780124159501000227/fx035.jpg" width="32"/> must be a power of 2, <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[] is a two-element array of half-width <img alt="Image" height="9" src="images/B9780124159501000227/fx039.jpg" width="45"/> objects (uninitialized if the network has width 2), and <img alt="Image" height="9" src="images/B9780124159501000227/fx040.jpg" width="39"/> is a full-width <img alt="Image" height="11" src="images/B9780124159501000227/fx034.jpg" width="39"/> object. The class provides a <img alt="Image" height="8" src="images/B9780124159501000227/fx033.jpg" width="52"/>(<i>i</i>) method, where <i>i</i> is the token's input wire. If the input wire is one of the first <img alt="Image" height="13" src="images/B9780124159501000227/fx038.jpg" width="46"/>, then it is sent through <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[0], otherwise through <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[1]. A token that emerges from the half-merger subnetwork on wire <i>i</i> then traverses the final merger network from input wire <i>i</i> if it passed through <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[0], or from input wire <i>i</i>+<img alt="Image" height="13" src="images/B9780124159501000227/fx038.jpg" width="46"/> if it passed through <img alt="Image" height="9" src="images/B9780124159501000227/fx036.jpg" width="25"/>[1].</p><div class="pageavoid"><figure class="fig" id="f0085"><img alt="Image" height="323" src="images/B9780124159501000227/gr016.jpg" width="446"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.16</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx039.jpg" width="45"/> class.</div></figcaption></figure></div><p class="text" id="p0370">Note that the <img alt="Image" height="9" src="images/B9780124159501000227/fx039.jpg" width="45"/> class uses a simple synchronized <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/> implementation, but if the <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/> implementation were lock-free (or wait-free), the network implementation as a whole would be lock-free (or wait-free).<span aria-label="Page 282" epub:type="pagebreak" id="page_282" role="doc-pagebreak"/></p></section><section><h4 class="h3hd" id="s0065"><a id="st0075"/>12.5.2.2 Proof of correctness</h4><p class="textfl" id="p0375">We now show that <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> is a counting network. The proof proceeds as a progression of arguments about the token sequences passing through the network. Before examining the network itself, here are some simple lemmas about sequences with the step property. </p><div class="boxg1" id="enun0020"><p class="b1num">Lemma 12.5.2 </p><div><p class="b1textfl" id="p0380">If a sequence has the step property, then so do all its subsequences.</p></div></div><p class="textfl"/><p class="text" id="p0385"/><div class="boxg1" id="enun0025"><p class="b1num">Lemma 12.5.3 </p><div><p class="b1textfl" id="p0390">For even <i>k</i>, if <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si56.png" style="vertical-align:middle" width="81"/></span> has the step property, then its even and odd subsequences satisfy</p><p class="hiddenClass"><mml:math><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="true">⌉</mml:mo></mml:mrow><mml:mrow><mml:mspace width="2.00em"/><mml:mtext>and</mml:mtext><mml:mspace width="0.25em"/><mml:mspace width="2.00em"/></mml:mrow><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌊</mml:mo><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="true">⌋</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="75" src="images/B9780124159501000227/si57.png" width="511"/><a id="deq7"/></p></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p0395"/><div class="boxg1" id="enun0030"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0400">Either <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si58.png" style="vertical-align:middle" width="74"/></span> for <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si59.png" style="vertical-align:middle" width="78"/></span>, or by <a href="#enun0015" id="cf0155">Lemma 12.5.1</a>, there exists a unique <i>j</i> such that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>j</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si60.png" style="vertical-align:middle" width="105"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si58.png" style="vertical-align:middle" width="74"/></span> for all <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si61.png" style="vertical-align:middle" width="34"/></span>, <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si59.png" style="vertical-align:middle" width="78"/></span>. In the first case, <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000227/si62.png" style="vertical-align:middle" width="180"/></span>, and in the second case, <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌉</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="20" src="images/B9780124159501000227/si63.png" style="vertical-align:middle" width="121"/></span> and <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌊</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌋</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="20" src="images/B9780124159501000227/si64.png" style="vertical-align:middle" width="137"/></span>.  □</p></div></div><p class="textfl"/><p class="text" id="p0405"><span aria-label="Page 283" epub:type="pagebreak" id="page_283" role="doc-pagebreak"/></p><div class="boxg1" id="enun0035"><p class="b1num">Lemma 12.5.4 </p><div><p class="b1textfl" id="p0410">Let <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si56.png" style="vertical-align:middle" width="81"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si65.png" style="vertical-align:middle" width="80"/></span> be arbitrary sequences having the step property. If <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000227/si66.png" style="vertical-align:middle" width="84"/></span>, then <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si67.png" style="vertical-align:middle" width="47"/></span> for all <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si68.png" style="vertical-align:middle" width="62"/></span>.</p></div></div><p class="textfl"/><p class="text" id="p0415"/><div class="boxg1" id="enun0040"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0420">Let <span class="hiddenClass"><mml:math><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000227/si69.png" style="vertical-align:middle" width="116"/></span>. By <a href="#enun0015" id="cf0160">Lemma 12.5.1</a>, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfrac><mml:mo stretchy="true">⌉</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000227/si70.png" style="vertical-align:middle" width="109"/></span>. □</p></div></div><p class="textfl"/><p class="text" id="p0425"/><div class="boxg1" id="enun0045"><p class="b1num">Lemma 12.5.5 </p><div><p class="b1textfl" id="p0430">Let <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si56.png" style="vertical-align:middle" width="81"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si65.png" style="vertical-align:middle" width="80"/></span> be arbitrary sequences having the step property. If <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000227/si71.png" style="vertical-align:middle" width="111"/></span>, then there exists a unique <i>j</i>, <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si72.png" style="vertical-align:middle" width="65"/></span>, such that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si73.png" style="vertical-align:middle" width="78"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si67.png" style="vertical-align:middle" width="47"/></span> for <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si61.png" style="vertical-align:middle" width="34"/></span>, <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si68.png" style="vertical-align:middle" width="62"/></span>.</p></div></div><p class="textfl"/><p class="text" id="p0435"/><div class="boxg1" id="enun0050"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0440">Let <span class="hiddenClass"><mml:math><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000227/si74.png" style="vertical-align:middle" width="143"/></span>. By <a href="#enun0015" id="cf0165">Lemma 12.5.1</a>, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfrac><mml:mo stretchy="true">⌉</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="21" src="images/B9780124159501000227/si75.png" style="vertical-align:middle" width="76"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfrac><mml:mo stretchy="true">⌉</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="29" src="images/B9780124159501000227/si76.png" style="vertical-align:middle" width="93"/></span>. These two terms agree for all <i>i</i>, <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si68.png" style="vertical-align:middle" width="62"/></span>, except for the unique <i>i</i> such that <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.25em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si77.png" style="vertical-align:middle" width="121"/></span>. □</p></div></div><p class="textfl"/><p class="text" id="p0445">We now show that the <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network preserves the step property.</p><p class="text" id="p0450"/><div class="boxg1" id="enun0055"><p class="b1num">Lemma 12.5.6 </p><div><p class="b1textfl" id="p0455">If <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> is quiescent (where <i>k</i> is a power of 2) and its inputs <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si56.png" style="vertical-align:middle" width="81"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si78.png" style="vertical-align:middle" width="81"/></span> both have the step property, then its output <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si79.png" style="vertical-align:middle" width="86"/></span> also has the step property.</p></div></div><p class="textfl"/><p class="text" id="p0460"/><div class="boxg1" id="enun0060"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0465">We argue by induction on <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si80.png" style="vertical-align:middle" width="33"/></span>. It may be worthwhile to consult <a href="#f0090" id="cf0170">Fig. 12.17</a>, which shows an example of the proof structure for a <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[8] network.</p><div class="pageavoid"><figure class="fig" id="f0090"><img alt="Image" height="195" src="images/B9780124159501000227/gr017.jpg" width="497"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.17</span> The inductive proof that a <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[8] network correctly merges two width-4 sequences <i>x</i> and <i>x</i>' that have the step property into a single width-8 sequence <i>y</i> that has the step property. The odd and even width-2 subsequences of <i>x</i> and <i>x</i>' all have the step property. Moreover, the difference in the number of tokens between the even sequence from one and the odd sequence from the other is at most 1 (in this example, 11 and 12 tokens, respectively). It follows from the induction hypothesis that the outputs <i>z</i> and <i>z</i>' of the two <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[4] networks have the step property, with at most 1 extra token in one of them. This extra token must fall on a specific numbered wire (wire 3 in this case) leading into the same balancer. In this figure, these tokens are darkened. They are passed to the southern-most balancer, and the extra token is pushed north, ensuring the final output has the step property.</div></figcaption></figure></div><p class="b1text" id="p0470">If <span class="hiddenClass"><mml:math><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si81.png" style="vertical-align:middle" width="46"/></span>, <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> is just a balancer, and its outputs are guaranteed to have the step property by the definition of a balancer.</p><p class="b1text" id="p0475"><span aria-label="Page 284" epub:type="pagebreak" id="page_284" role="doc-pagebreak"/>If <span class="hiddenClass"><mml:math><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si82.png" style="vertical-align:middle" width="46"/></span>, let <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si83.png" style="vertical-align:middle" width="80"/></span> be the outputs of the first <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> subnetwork, which merges the even subsequence of <i>x</i> with the odd subsequence of <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si40.png" style="vertical-align:middle" width="15"/></span>, and let <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si84.png" style="vertical-align:middle" width="80"/></span> be the outputs of the second <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> subnetwork. Since <i>x</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si40.png" style="vertical-align:middle" width="15"/></span> have the step property by assumption, so do their even and odd subsequences (<a href="#enun0020" id="cf0175">Lemma 12.5.2</a>), and hence so do <i>z</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si48.png" style="vertical-align:middle" width="14"/></span> (induction hypothesis). Furthermore, <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌉</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mrow><mml:mo stretchy="true">⌊</mml:mo><mml:mo>∑</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌋</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="20" src="images/B9780124159501000227/si85.png" style="vertical-align:middle" width="197"/></span> and <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo stretchy="true">⌊</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌋</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mrow><mml:mo stretchy="true">⌈</mml:mo><mml:mo>∑</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌉</mml:mo></mml:mrow></mml:math></span><span><img alt="Image" height="20" src="images/B9780124159501000227/si86.png" style="vertical-align:middle" width="197"/></span> (<a href="#enun0025" id="cf0180">Lemma 12.5.3</a>). A straightforward case analysis shows that <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000227/si87.png" style="vertical-align:middle" width="32"/></span> and <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si88.png" style="vertical-align:middle" width="32"/></span> can differ by at most 1.</p><p class="b1text" id="p0480">We claim that <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>⩽</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si30.png" style="vertical-align:middle" width="102"/></span> for any <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>j</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si29.png" style="vertical-align:middle" width="34"/></span>. If <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∑</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si89.png" style="vertical-align:middle" width="82"/></span>, then <a href="#enun0035" id="cf0185">Lemma 12.5.4</a> implies that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si90.png" style="vertical-align:middle" width="45"/></span> for <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si59.png" style="vertical-align:middle" width="78"/></span>. After the final layer of balancers,</p><p class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="true">⌊</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌋</mml:mo></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="true">⌊</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="true">⌋</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="16" src="images/B9780124159501000227/si91.png" width="222"/><a id="deq8"/></p></div><p class="b1textfl"> and the result follows because <i>z</i> has the step property.</p><p class="b1text" id="p0485">Similarly, if <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="16" src="images/B9780124159501000227/si87.png" style="vertical-align:middle" width="32"/></span> and <span class="hiddenClass"><mml:math><mml:mo>∑</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si88.png" style="vertical-align:middle" width="32"/></span> differ by one, <a href="#enun0045" id="cf0190">Lemma 12.5.5</a> implies that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si90.png" style="vertical-align:middle" width="45"/></span> for <span class="hiddenClass"><mml:math><mml:mn>0</mml:mn><mml:mo>⩽</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si59.png" style="vertical-align:middle" width="78"/></span>, except for a unique <i>ℓ</i> such that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si92.png" style="vertical-align:middle" width="15"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si93.png" style="vertical-align:middle" width="15"/></span> differ by one. Let <span class="hiddenClass"><mml:math><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi mathvariant="normal">min</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si94.png" style="vertical-align:middle" width="102"/></span>, and thus, <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">max</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si95.png" style="vertical-align:middle" width="130"/></span>. From the step property for <i>z</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si48.png" style="vertical-align:middle" width="14"/></span>, we have <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si96.png" style="vertical-align:middle" width="100"/></span> for all <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>ℓ</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si97.png" style="vertical-align:middle" width="34"/></span>, and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si98.png" style="vertical-align:middle" width="74"/></span> for all <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mi>ℓ</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si99.png" style="vertical-align:middle" width="34"/></span>. Since <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si92.png" style="vertical-align:middle" width="15"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si93.png" style="vertical-align:middle" width="15"/></span> are joined by a balancer with outputs <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>ℓ</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si100.png" style="vertical-align:middle" width="21"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>ℓ</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si101.png" style="vertical-align:middle" width="36"/></span>, it follows that <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>ℓ</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si102.png" style="vertical-align:middle" width="76"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>ℓ</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si103.png" style="vertical-align:middle" width="65"/></span>. Similarly, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si49.png" style="vertical-align:middle" width="13"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="18" src="images/B9780124159501000227/si50.png" style="vertical-align:middle" width="14"/></span> for <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>ℓ</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si104.png" style="vertical-align:middle" width="34"/></span> are joined by the same balancer. Thus, for any <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>ℓ</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si97.png" style="vertical-align:middle" width="34"/></span>, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si105.png" style="vertical-align:middle" width="128"/></span> and for any <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mi>ℓ</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si99.png" style="vertical-align:middle" width="34"/></span>, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>x</mml:mi></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si106.png" style="vertical-align:middle" width="102"/></span>. The step property follows by choosing <span class="hiddenClass"><mml:math><mml:mi>c</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn><mml:mi>ℓ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="13" src="images/B9780124159501000227/si107.png" style="vertical-align:middle" width="70"/></span> and applying <a href="#enun0015" id="cf0195">Lemma 12.5.1</a>.  □</p></div></div><p class="textfl"/><p class="text" id="p0490"><span aria-label="Page 285" epub:type="pagebreak" id="page_285" role="doc-pagebreak"/>The proof of the following theorem is now immediate. </p><div class="boxg1" id="enun0065"><p class="b1num">Theorem 12.5.7 </p><div><p class="b1textfl" id="p0495">In any quiescent state, the outputs of <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> have the step property.</p></div></div><p class="textfl"/></section><section><h4 class="h3hd" id="s0070"><a id="st0080"/>12.5.2.3 A periodic counting network</h4><p class="textfl" id="p0500">In this section, we show that the Bitonic network is not the only counting network with depth <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000227/si108.png" style="vertical-align:middle" width="67"/></span>. We introduce a new counting network with the remarkable property that it is <i>periodic</i>, consisting of a sequence of identical subnetworks, as depicted in <a href="#f0095" id="cf0200">Fig. 12.18</a>. We define the network <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> as follows: When <i>k</i> is equal to 2, the <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> network consists of a single balancer. The <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network for larger <i>k</i> is constructed recursively. We start with two <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> networks <i>A</i> and <i>B</i>. Given an input sequence <i>x</i>, the input to <i>A</i> is <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si109.png" style="vertical-align:middle" width="20"/></span>, and the input to <i>B</i> is <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si110.png" style="vertical-align:middle" width="20"/></span>. Let <i>y</i> be the output sequence for the two subnetworks, where <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000227/si111.png" style="vertical-align:middle" width="19"/></span> is the output sequence for <i>A</i> and <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000227/si112.png" style="vertical-align:middle" width="19"/></span> the output sequence for <i>B</i>. The final stage of the network combines each <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="19" src="images/B9780124159501000227/si113.png" style="vertical-align:middle" width="19"/></span> and <span class="hiddenClass"><mml:math><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:msubsup></mml:math></span><span><img alt="Image" height="19" src="images/B9780124159501000227/si114.png" style="vertical-align:middle" width="19"/></span> in a single balancer, yielding final outputs <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si115.png" style="vertical-align:middle" width="20"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si116.png" style="vertical-align:middle" width="35"/></span>.</p><div class="pageavoid"><figure class="fig" id="f0095"><img alt="Image" height="177" src="images/B9780124159501000227/gr018.jpg" width="335"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.18</span> A <span class="small-caps">Periodic</span><span style="display:inline-block; width: 0.20em;"/>[8] counting network constructed from three identical <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/>[8] networks.</div></figcaption></figure></div><p class="text" id="p0505"><a href="#f0100" id="cf0205">Fig. 12.19</a> describes the recursive construction of a <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/>[8] network. The <span class="small-caps">Periodic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network consists of <span aria-label="Page 286" epub:type="pagebreak" id="page_286" role="doc-pagebreak"/><span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si53.png" style="vertical-align:middle" width="41"/></span> <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> networks joined so that the <i>i</i>th output wire of one is the <i>i</i>th wire of the next. <a href="#f0095" id="cf0210">Fig. 12.18</a> is a <span class="small-caps">Periodic</span><span style="display:inline-block; width: 0.20em;"/>[8] counting network.<sup><a epub:type="noteref" href="#fn002" id="cf0215" role="doc-noteref">2</a></sup></p><div class="pageavoid"><figure class="fig" id="f0100"><img alt="Image" height="110" src="images/B9780124159501000227/gr019.jpg" width="446"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.19</span> The left-hand side illustrates a <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/>[8] network, into which feed two <span class="small-caps">Periodic</span><span style="display:inline-block; width: 0.20em;"/>[4] networks. The right-hand illustrates the physical layout of a <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/>[8] network. The balancers are color-coded to match the logical structure in the left-hand figure.</div></figcaption></figure></div></section><section><h4 class="h3hd" id="s0075"><a id="st0085"/>12.5.2.4 A software periodic counting network</h4><p class="textfl" id="p0510">Here is how to implement the periodic network in software. We reuse the <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/> class in <a href="#f0075" id="cf0220">Fig. 12.14</a>. A single layer of a <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network is implemented by the <span class="small-caps">Layer</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network (<a href="#f0105" id="cf0225">Fig. 12.20</a>). A <span class="small-caps">Layer</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network joins input wires <i>i</i> and <span class="hiddenClass"><mml:math><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si117.png" style="vertical-align:middle" width="64"/></span> to the same balancer.</p><div class="pageavoid"><figure class="fig" id="f0105"><img alt="Image" height="438" src="images/B9780124159501000227/gr020.jpg" width="325"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.20</span> The <img alt="Image" height="11" src="images/B9780124159501000227/fx041.jpg" width="32"/> network.</div></figcaption></figure></div><p class="text" id="p0515">In the <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> class (<a href="#f0110" id="cf0230">Fig. 12.21</a>), after the token emerges from the initial <span class="small-caps">Layer</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network, it passes through one of two half-width <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si118.png" style="vertical-align:middle" width="39"/></span> networks (called <i>north</i> and <i>south</i>).</p><div class="pageavoid"><figure class="fig" id="f0110"><img alt="Image" height="421" src="images/B9780124159501000227/gr021.jpg" width="403"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.21</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx042.jpg" width="32"/> network.</div></figcaption></figure></div><p class="text" id="p0520"><span aria-label="Page 287" epub:type="pagebreak" id="page_287" role="doc-pagebreak"/>The <span class="small-caps">Periodic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network (<a href="#f0115" id="cf0235">Fig. 12.22</a>) is implemented as an array of <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si119.png" style="vertical-align:middle" width="37"/></span> <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> networks. Each token traverses each block in sequence, where the output wire taken on each block is the input wire for its successor. (The chapter notes cite the proof that the <span class="small-caps">Periodic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> is a counting network.)</p><div class="pageavoid"><figure class="fig" id="f0115"><img alt="Image" height="356" src="images/B9780124159501000227/gr022.jpg" width="254"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.22</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx043.jpg" width="51"/> network.</div></figcaption></figure></div></section></section><section><h3 class="h2hd" id="s0080"><a id="st0090"/>12.5.3 Performance and pipelining</h3><p class="textfl" id="p0525">How does counting network throughput vary as a function of the number of threads and the network width? For a fixed network width, throughput rises with the number of threads up to a point, and then the network <i>saturates</i>, and throughput remains constant or declines. To understand these results, let us think of a counting network as a pipeline.</p><p class="text" id="p0530"/><div><ul><li class="bulllist" id="u0050">•  If the number of tokens concurrently traversing the network is less than the number of balancers, then the pipeline is partly empty, and throughput suffers. <span aria-label="Page 288" epub:type="pagebreak" id="page_288" role="doc-pagebreak"/></li><li class="bulllist" id="u0055">•  If the number of concurrent tokens is greater than the number of balancers, then the pipeline becomes clogged because too many tokens arrive at each balancer at the same time, resulting in per-balancer contention.</li><li class="bulllist" id="u0060">•  Throughput is maximized when the number of tokens is roughly equal to the number of balancers.</li></ul></div><p class="textfl"> If an application needs a counting network, then the best network size to choose is one that ensures that the number of tokens traversing the balancer at any time is roughly equal to the number of balancers.</p></section></section><section><h2 class="h1hd" id="s0085"><a id="st0095"/>12.6 Diffracting trees</h2><p class="textfl" id="p0550">Counting networks provide a high degree of pipelining, so throughput is largely independent of network depth. Latency, however, does depend on network depth. Of the counting networks we have seen, the most shallow has depth <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">Θ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000227/si120.png" style="vertical-align:middle" width="68"/></span>. Can we design a logarithmic-depth counting network? The good news is yes, such networks exist, but the bad news is that for all known constructions, the constant factors involved render these constructions impractical.</p><p class="text" id="p0555"><span aria-label="Page 289" epub:type="pagebreak" id="page_289" role="doc-pagebreak"/>Here is an alternative approach: Consider a set of balancers with a single input wire and two output wires, with the top and bottom labeled 0 and 1, respectively. The <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network (depicted in <a href="#f0120" id="cf0240">Fig. 12.23</a>) is a binary tree structured as follows: Let <i>w</i> be a power of two, and define <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> inductively. When <i>k</i> is equal to 1, <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> consists of a single balancer with output wires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si15.png" style="vertical-align:middle" width="16"/></span> and <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si16.png" style="vertical-align:middle" width="15"/></span>. For <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si43.png" style="vertical-align:middle" width="36"/></span>, construct <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> from two <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> trees and one additional balancer. Make the input wire <i>x</i> of the single balancer the root of the tree and connect each of its output wires to the input wire of a tree of width <i>k</i>. Redesignate output wires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si121.png" style="vertical-align:middle" width="103"/></span> of the <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> subtree extending from the “0” output wire as the even output wires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si122.png" style="vertical-align:middle" width="110"/></span> of the final <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network and the wires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si121.png" style="vertical-align:middle" width="103"/></span> of the <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> subtree extending from the balancer's “1” output wire as the odd output wires <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si123.png" style="vertical-align:middle" width="109"/></span> of the final <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network.</p><div class="pageavoid"><figure class="fig" id="f0120"><img alt="Image" height="186" src="images/B9780124159501000227/gr023.jpg" width="233"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.23</span> The <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/>[8] class: a tree that counts. Note how the network maintains the step property.</div></figcaption></figure></div><p class="text" id="p0560">To understand why the <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> network has the step property in a quiescent state, let us assume inductively that a quiescent <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> has the step property. The root balancer passes at most one token more to the <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> subtree on its “0” (top) wire than on its“1” (bottom) wire. The tokens exiting the top <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> subtree have a step property differing from that of the bottom subtree at most one wire <i>j</i> among their <i>k</i> output wires. The <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> outputs are a perfect shuffle of the wires leaving the two subtrees, and it follows that the two step-shaped token sequences of width <i>k</i> form a new step of width 2<i>k</i>, where the possible single excess token appears at the higher of the two wires <i>j</i>, that is, the one from the top <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> tree.</p><p class="text" id="p0565">The <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network may be a counting network, but is it a <i>good</i> counting network? The good news is that it has shallow depth: While a <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network has depth <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000227/si124.png" style="vertical-align:middle" width="44"/></span>, the <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network depth is just <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si119.png" style="vertical-align:middle" width="37"/></span>. The bad news is contention: Every token that enters the network passes through the same root balancer, causing that balancer to become a bottleneck. In general, the higher the balancer in the tree, the higher the contention.</p><p class="text" id="p0570">We can reduce contention by exploiting a simple observation similar to one we made about the <img alt="Image" height="9" src="images/B9780124159501000227/fx001.jpg" width="153"/> of Chapter <a href="B9780124159501000215.xhtml">11</a>: <span aria-label="Page 290" epub:type="pagebreak" id="page_290" role="doc-pagebreak"/></p><p class="quote" id="sp0175"><i>If an</i> even <i>number of tokens pass through a balancer, the outputs are evenly balanced on the top and bottom wires, but the balancer's state remains unchanged.</i></p><p class="textfl"/><p class="text" id="p0575">The basic idea behind <i>diffracting trees</i> is to place a "prism" at each balancer, an out-of-band mechanism similar to the <img alt="Image" height="11" src="images/B9780124159501000227/fx044.jpg" width="106"/>, which enables tokens (threads) accessing a stack to exchange items. The prism allows tokens to pair off at random array locations and agree to diffract in different directions, that is, to exit on different wires without traversing the balancer's toggle bit or changing its state. A token traverses the balancer's toggle bit only if it is unable to pair off with another token within a reasonable period of time. If it did not manage to diffract, the token toggles the bit to determine which way to go. It follows that we can avoid excessive contention at balancers if the prism can pair off enough tokens without introducing too much contention.</p><p class="text" id="p0580">A <img alt="Image" height="9" src="images/B9780124159501000227/fx045.jpg" width="32"/> is an array of <img alt="Image" height="11" src="images/B9780124159501000227/fx046.jpg" width="119"/> objects, like the <img alt="Image" height="11" src="images/B9780124159501000227/fx044.jpg" width="106"/>. An <img alt="Image" height="11" src="images/B9780124159501000227/fx047.jpg" width="79"/> object permits two threads to exchange <img alt="Image" height="9" src="images/B9780124159501000227/fx048.jpg" width="5"/> values. If thread <i>A</i> calls the object's <img alt="Image" height="11" src="images/B9780124159501000227/fx049.jpg" width="52"/>() method with argument <i>a</i>, and <i>B</i> calls it with argument <i>b</i>, then <i>A</i>'s call returns <i>b</i> and <i>B</i>'s call returns <i>a</i>. The first thread to arrive is blocked until the second arrives. The call includes a timeout argument allowing a thread to proceed if it is unable to exchange a value within a reasonable duration.</p><p class="text" id="p0585">Before thread <i>A</i> visits the balancer's toggle bit, it visits the associated <img alt="Image" height="9" src="images/B9780124159501000227/fx045.jpg" width="32"/>. In the <img alt="Image" height="9" src="images/B9780124159501000227/fx045.jpg" width="32"/>, it picks an array entry at random, and calls that slot's <img alt="Image" height="11" src="images/B9780124159501000227/fx049.jpg" width="52"/>() method, providing its own thread ID as an exchange value. If it succeeds in exchanging IDs with another thread, then the thread with the lower ID exits on wire 0, and the one with the higher ID on wire 1.</p><p class="text" id="p0590"><a href="#f0125" id="cf0245">Fig. 12.24</a> shows a <img alt="Image" height="9" src="images/B9780124159501000227/fx045.jpg" width="32"/> implementation. The constructor takes as an argument the capacity of the prism (the maximal number of distinct <span aria-label="Page 291" epub:type="pagebreak" id="page_291" role="doc-pagebreak"/>exchangers). The <img alt="Image" height="9" src="images/B9780124159501000227/fx045.jpg" width="32"/> class provides a single method, <img alt="Image" height="9" src="images/B9780124159501000227/fx050.jpg" width="32"/>(), that chooses the random exchanger entry. The <img alt="Image" height="9" src="images/B9780124159501000227/fx050.jpg" width="32"/>() call returns <i>true</i> if the caller should exit on the top wire, <i>false</i> if the bottom wire, and it throws a <img alt="Image" height="11" src="images/B9780124159501000227/fx051.jpg" width="106"/> if the timeout expires without exchanging a value. The caller acquires its thread ID (line 11), chooses a random entry in the array (line 12), and tries to exchange its own ID with its partner's (line 13). If it succeeds, it returns a Boolean value, and if it times out, it rethrows <img alt="Image" height="11" src="images/B9780124159501000227/fx051.jpg" width="106"/>.</p><div class="pageavoid"><figure class="fig" id="f0125"><img alt="Image" height="234" src="images/B9780124159501000227/gr024.jpg" width="428"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.24</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx045.jpg" width="32"/> class.</div></figcaption></figure></div><p class="text" id="p0595">A <img alt="Image" height="11" src="images/B9780124159501000227/fx052.jpg" width="126"/> (<a href="#f0130" id="cf0250">Fig. 12.25</a>), like a regular <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/>, provides<span style="display:inline-block; width: 0.20em;"/>a<span style="display:inline-block; width: 0.20em;"/><img alt="Image" height="8" src="images/B9780124159501000227/fx033.jpg" width="52"/>() method whose return value alternates between 0 and 1. This class has two fields: <img alt="Image" height="11" src="images/B9780124159501000227/fx054.jpg" width="32"/> is a <img alt="Image" height="9" src="images/B9780124159501000227/fx045.jpg" width="32"/>, and <img alt="Image" height="11" src="images/B9780124159501000227/fx032.jpg" width="38"/> is a <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/>. When a thread calls <img alt="Image" height="8" src="images/B9780124159501000227/fx033.jpg" width="52"/>(), it tries to find a partner through the <img alt="Image" height="11" src="images/B9780124159501000227/fx054.jpg" width="32"/>. If it succeeds, then the partners return with distinct values, without creating contention at the <img alt="Image" height="11" src="images/B9780124159501000227/fx032.jpg" width="38"/> (line 11). Otherwise, if the thread is unable to find a partner, it traverses (line 16) the <img alt="Image" height="11" src="images/B9780124159501000227/fx032.jpg" width="38"/> (implemented as a balancer).</p><div class="pageavoid"><figure class="fig" id="f0130"><img alt="Image" height="306" src="images/B9780124159501000227/gr025.jpg" width="285"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.25</span> The <img alt="Image" height="11" src="images/B9780124159501000227/fx052.jpg" width="126"/> class: If the caller pairs up with a concurrent caller through the prism, it does not need to traverse the balancer.</div></figcaption></figure></div><p class="text" id="p0600">The <img alt="Image" height="11" src="images/B9780124159501000227/fx053.jpg" width="99"/> class (<a href="#f0135" id="cf0255">Fig. 12.26</a>) has two fields. The <img alt="Image" height="9" src="images/B9780124159501000227/fx055.jpg" width="32"/> array is a two-element array of child trees. The <img alt="Image" height="8" src="images/B9780124159501000227/fx056.jpg" width="25"/> field is a <img alt="Image" height="11" src="images/B9780124159501000227/fx052.jpg" width="126"/> that alternates between forwarding calls to the left or right subtree. Each <img alt="Image" height="11" src="images/B9780124159501000227/fx052.jpg" width="126"/> has a capacity, which is actually the capacity of its internal prism. Initially this capacity is the size of the tree, and the capacity shrinks by half at each level.</p><div class="pageavoid"><figure class="fig" id="f0135"><img alt="Image" height="356" src="images/B9780124159501000227/gr026.jpg" width="325"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.26</span> The <img alt="Image" height="11" src="images/B9780124159501000227/fx053.jpg" width="99"/> class: fields, constructor, and <img alt="Image" height="8" src="images/B9780124159501000227/fx033.jpg" width="52"/>() method.</div></figcaption></figure></div><p class="text" id="p0605">As with the <img alt="Image" height="9" src="images/B9780124159501000227/fx001.jpg" width="153"/>, <img alt="Image" height="11" src="images/B9780124159501000227/fx053.jpg" width="99"/> performance depends on two parameters: prism capacities and timeouts. If the prisms are too big, threads miss one another, causing excessive contention at the balancer. If the prisms are too small, then too many threads concurrently <span aria-label="Page 292" epub:type="pagebreak" id="page_292" role="doc-pagebreak"/>access each exchanger in a prism, resulting in excessive contention at the exchangers. If prism timeouts are too short, threads miss one another, and if they are too long, threads may be delayed unnecessarily. There are no hard-and-fast rules for choosing these values, since the optimal values depend on the load and the characteristics of the underlying multiprocessor architecture.</p><p class="text" id="p0610">Nevertheless, experimental evidence suggests that it is sometimes possible to choose these values to outperform both the <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> and <img alt="Image" height="11" src="images/B9780124159501000227/fx057.jpg" width="100"/> classes. Here are some heuristics that work well in practice: Because balancers higher in the tree have more contention, we use larger prisms near the top of the tree, and add the ability to dynamically shrink and grow the random range chosen. The best timeout interval choice depends on the load: If only a few threads are accessing the tree, then time spent waiting is mostly wasted, while if there are many threads, then time spent waiting pays off. Adaptive schemes are promising: lengthen the timeout while threads succeed in pairing off, and shorten it otherwise.<span aria-label="Page 293" epub:type="pagebreak" id="page_293" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0090"><a id="st0100"/>12.7 Parallel sorting</h2><p class="textfl" id="p0615">Sorting is one of the most important computational tasks, dating back to Hollerith's tabulating machine in the 19th century, through the first electronic computer systems in the 1940s, and culminating today, when a high fraction of programs use sorting in some form or another. As most computer science undergraduates learn early on, the choice of sorting algorithm depends crucially on the number of items being sorted, the numerical properties of their keys, and whether the items reside in memory or in an external storage device. Parallel sorting algorithms can be classified in the same way.</p><p class="text" id="p0620">We present two classes of sorting algorithms: <i>sorting networks</i>, which typically work well for small in-memory data sets, and <i>sample sorting algorithms</i>, which work well for large data sets in external memory. In our presentation, we sacrifice performance for simplicity. More complex techniques are cited in the chapter notes.</p></section><section><h2 class="h1hd" id="s0095"><a id="st0105"/>12.8 Sorting networks</h2><p class="textfl" id="p0625">In much the same way that a counting network is a network of <i>balancers</i>, a sorting network is a network of <i>comparators</i>.<sup><a epub:type="noteref" href="#fn003" id="cf0260" role="doc-noteref">3</a></sup> A comparator is a computing element with two input wires and two output wires, called the <i>top</i> and <i>bottom</i> wires. It receives two numbers on its input wires, and forwards the larger to its top wire and the smaller to its bottom wire. A comparator, unlike a balancer, is <i>synchronous</i>: It outputs values only when both inputs have arrived (see <a href="#f0140" id="cf0265">Fig. 12.27</a>).</p><div class="pageavoid"><figure class="fig" id="f0140"><img alt="Image" height="48" src="images/B9780124159501000227/gr027.jpg" width="288"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.27</span> A comparator.</div></figcaption></figure></div><p class="text" id="p0630">A <i>comparison network</i>, like a balancing network, is an acyclic network of comparators. An input value is placed on each of its <i>w</i> input lines. These values pass through each layer of comparators synchronously, finally leaving together on the network output wires.</p><p class="text" id="p0635">A comparison network with input values <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="9" src="images/B9780124159501000227/si17.png" style="vertical-align:middle" width="14"/></span> and output values <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si18.png" style="vertical-align:middle" width="13"/></span>, <span class="hiddenClass"><mml:math><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>…</mml:mo><mml:mi>w</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si125.png" style="vertical-align:middle" width="105"/></span>, each on wire <i>i</i>, is a valid <i>sorting network</i> if its output values are the input values sorted in descending order, that is, <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⩾</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si126.png" style="vertical-align:middle" width="61"/></span>.</p><p class="text" id="p0640">The following classic theorem simplifies the process of proving that a given network sorts.</p><p class="text" id="p0645"/><div class="boxg1" id="enun0070"><p class="b1num">Theorem 12.8.1 </p><p class="b1title">0-1 Principle</p><div><p class="b1textfl" id="p0650">If a sorting network sorts every input sequence of 0 s and 1 s, then it sorts any sequence of input values. <span aria-label="Page 294" epub:type="pagebreak" id="page_294" role="doc-pagebreak"/></p></div></div><p class="textfl"/><section><h3 class="h2hd" id="s0100"><a id="st0115"/>12.8.1 Designing a sorting network</h3><p class="textfl" id="p0655">There is no need to design sorting networks, because we can recycle counting network layouts. A balancing network and a comparison network are <i>isomorphic</i> if one can be constructed from the other by replacing balancers with comparators, or vice versa.</p><p class="text" id="p0660"/><div class="boxg1" id="enun0075"><p class="b1num">Theorem 12.8.2 </p><div><p class="b1textfl" id="p0665">If a balancing network counts, then its isomorphic comparison network sorts.</p></div></div><p class="textfl"/><p class="text" id="p0670"/><div class="boxg1" id="enun0080"><p class="b1num">Proof </p><div><p class="b1textfl" id="p0675">We construct a mapping from steps in the comparison network to steps in the isomorphic balancing network transitions. By <a href="#enun0070" id="cf0270">Theorem 12.8.1</a>, a comparison network which sorts all sequences of 0 s and 1 s is a sorting network. Take any arbitrary sequence of 0 s and 1 s as inputs to the comparison network, and for the balancing network, place a token on each 1 input wire and no token on each 0 input wire. If we run both networks in lockstep, the balancing network simulates the comparison network.</p><p class="b1text" id="p0680">The proof is by induction on the depth of the network. For level 0 the claim holds by construction. Assuming it holds for wires of a given level <i>k</i>, let us prove it holds for level <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si127.png" style="vertical-align:middle" width="36"/></span>. On every comparator where two 1 s meet in the comparison network, two tokens meet in the balancing network, so one 1 leaves on each wire in the comparison network on level <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si127.png" style="vertical-align:middle" width="36"/></span>, and one token leaves on each wire in the balancing network on level <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si127.png" style="vertical-align:middle" width="36"/></span>. On every comparator where two 0 s meet in the comparison network, no tokens meet in the balancing network, so a 0 leaves on each level <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si127.png" style="vertical-align:middle" width="36"/></span> wire in the comparison network, and no tokens leave in the balancing network. On every comparator where a 0 and 1 meet in the comparison network, the 1 leaves on the north (upper) wire and the 1 on the south (lower) wire on level <span class="hiddenClass"><mml:math><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si127.png" style="vertical-align:middle" width="36"/></span>, while in the balancing network the token leaves on the north wire, and no token leaves on the south wire.</p><p class="b1text" id="p0685">If the balancing network is a counting network, that is, it has the step property on its output level wires, then the comparison network must have sorted the input sequence of 0 s and 1 s. □</p></div></div><p class="textfl"> The converse is false: not all sorting networks are counting networks. We leave it as an exercise to verify that the <span class="small-caps">OddEven</span> network in <a href="#f0145" id="cf0275">Fig. 12.28</a> is a sorting network but not a counting network.</p><div class="pageavoid"><figure class="fig" id="f0145"><img alt="Image" height="220" src="images/B9780124159501000227/gr028.jpg" width="422"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.28</span> The <span class="small-caps">OddEven</span> sorting network.</div></figcaption></figure></div><p class="text" id="p0690"/><div class="boxg1" id="enun0085"><p class="b1num">Corollary 12.8.3 </p><div><p class="b1textfl" id="p0695">Comparison networks isomorphic to <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[] and <span class="small-caps">Periodic</span><span style="display:inline-block; width: 0.20em;"/>[] networks are sorting networks.</p></div></div><p class="textfl"/><p class="text" id="p0700">Sorting a set of size <i>w</i> by comparisons requires <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">Ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si128.png" style="vertical-align:middle" width="76"/></span> comparisons. A sorting network with <i>w</i> input wires has at most <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si129.png" style="vertical-align:middle" width="38"/></span> comparators in each level, so its depth can be no smaller than <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">Ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si130.png" style="vertical-align:middle" width="61"/></span>. </p><div class="boxg1" id="enun0090"><p class="b1num">Corollary 12.8.4 </p><div><p class="b1textfl" id="p0705">The depth of any counting network is at least <span class="hiddenClass"><mml:math><mml:mi mathvariant="normal">Ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si130.png" style="vertical-align:middle" width="61"/></span>. <span aria-label="Page 295" epub:type="pagebreak" id="page_295" role="doc-pagebreak"/></p></div></div><p class="textfl"/><section><h4 class="h3hd" id="s0105"><a id="st0120"/>12.8.1.1 A bitonic sorting algorithm</h4><p class="textfl" id="p0710">We can represent any width-<i>w</i> sorting network, such as <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span>, as a collection of <i>d</i> layers of up to <span class="hiddenClass"><mml:math><mml:mi>w</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si131.png" style="vertical-align:middle" width="29"/></span> balancers each. We can represent a sorting network layout as a table, where each entry is a pair that describes which two wires meet at that balancer at that layer. (For example, in the <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/>[4] network of <a href="#f0060" id="cf0280">Fig. 12.11</a>, wires 0 and 1 meet at the first balancer in the first layer, and wires 0 and 3 meet at the first balancer of the second layer.) Let us assume, for simplicity, that we are given an unbounded table <img alt="Image" height="9" src="images/B9780124159501000227/fx058.jpg" width="79"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si132.png" style="vertical-align:middle" width="56"/></span>, where each array entry contains the index of the associated north (<span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>0</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si133.png" style="vertical-align:middle" width="38"/></span>) or south (<span class="hiddenClass"><mml:math><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si134.png" style="vertical-align:middle" width="36"/></span>) input wire to balancer <i>i</i> at depth <i>d</i>.</p><p class="text" id="p0715">An <i>in-place</i> array-based sorting algorithm takes as input an array of items to be sorted (here we assume these items have unique integer keys) and returns the same array with the items sorted by key. Here is how we implement <img alt="Image" height="9" src="images/B9780124159501000227/fx059.jpg" width="72"/>, an in-place array-based sorting algorithm based on a bitonic sorting network. Let us assume that we wish to sort an array of <span class="hiddenClass"><mml:math><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mi>p</mml:mi><mml:mo>⋅</mml:mo><mml:mi>s</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si135.png" style="vertical-align:middle" width="49"/></span> elements, where <i>p</i> is the number of threads (and typically also the maximal number of available processors on which the threads run) and <span class="hiddenClass"><mml:math><mml:mi>p</mml:mi><mml:mo>⋅</mml:mo><mml:mi>s</mml:mi></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si136.png" style="vertical-align:middle" width="29"/></span> is a power of 2. The network has <span class="hiddenClass"><mml:math><mml:mi>p</mml:mi><mml:mo>⋅</mml:mo><mml:mi>s</mml:mi></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si136.png" style="vertical-align:middle" width="29"/></span> comparators at every layer.</p><p class="text" id="p0720">Each of the <i>p</i> threads emulates the work of <i>s</i> comparators. Unlike counting networks, which act like uncoordinated raves, sorting networks are synchronous: All inputs to a comparator must arrive before it can compute the outputs. The algorithm proceeds in rounds. In each round, a thread performs <i>s</i> comparisons in a layer of the network, switching the array entries of items if necessary, so that they are properly ordered. In each network layer, the comparators join different wires, so no two threads attempt to exchange the items of the same entry, avoiding the need to synchronize operations at any given layer.</p><p class="text" id="p0725">To ensure that the comparisons of a given round (layer) are complete before proceeding to the next one, we use a synchronization construct called a <img alt="Image" height="9" src="images/B9780124159501000227/fx060.jpg" width="46"/> (studied in more detail in Chapter <a href="B9780124159501000288.xhtml">18</a>). A <span aria-label="Page 296" epub:type="pagebreak" id="page_296" role="doc-pagebreak"/>barrier for <i>p</i> threads provides an <img alt="Image" height="9" src="images/B9780124159501000227/fx061.jpg" width="32"/>() method, whose call does not return until all <i>p</i> threads have called <img alt="Image" height="9" src="images/B9780124159501000227/fx061.jpg" width="32"/>(). The <img alt="Image" height="9" src="images/B9780124159501000227/fx059.jpg" width="72"/> implementation appears in <a href="#f0150" id="cf0285">Fig. 12.29</a>. Each thread proceeds through the layers of the network round by round. In each round, it awaits the arrival of the other threads (line 12), ensuring that the <img alt="Image" height="9" src="images/B9780124159501000227/fx062.jpg" width="31"/> array contains the prior round's results. It then emulates the behavior of <i>s</i> balancers at that layer by comparing the items at the array positions corresponding to the comparator's wires, and exchanging them if their keys are out of order (lines 14–19).</p><div class="pageavoid"><figure class="fig" id="f0150"><img alt="Image" height="372" src="images/B9780124159501000227/gr029.jpg" width="365"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.29</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx059.jpg" width="72"/> class.</div></figcaption></figure></div><p class="text" id="p0730">The <img alt="Image" height="9" src="images/B9780124159501000227/fx059.jpg" width="72"/> takes <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:msup><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>⁡</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000227/si137.png" style="vertical-align:middle" width="75"/></span> time for <i>p</i> threads running on <i>p</i> processors, which, if <i>s</i> is constant, is <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>⁡</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000227/si138.png" style="vertical-align:middle" width="66"/></span> time.</p></section></section></section><section><h2 class="h1hd" id="s0110"><a id="st0125"/>12.9 Sample sorting</h2><p class="textfl" id="p0735">The <img alt="Image" height="9" src="images/B9780124159501000227/fx059.jpg" width="72"/> is appropriate for small data sets that reside in memory. For larger data sets (where <i>n</i>, the number of items, is much larger than <i>p</i>, the number of threads), especially ones that reside on out-of-memory storage devices, we need a different approach. Because accessing a data item is expensive, we must maintain as much locality of reference as possible, <span aria-label="Page 297" epub:type="pagebreak" id="page_297" role="doc-pagebreak"/>so having a single thread sort items sequentially is cost-effective. A parallel sort like <img alt="Image" height="9" src="images/B9780124159501000227/fx059.jpg" width="72"/>, where an item is accessed by multiple threads, is simply too expensive.</p><p class="text" id="p0740">We attempt to minimize the number of threads that access a given item through randomization. This use of randomness differs from that in the <img alt="Image" height="11" src="images/B9780124159501000227/fx053.jpg" width="99"/>, where it was used to distribute memory accesses. Here we use randomness to guess the distribution of items in the data set to be sorted.</p><p class="text" id="p0745">Since the data set to be sorted is large, we split it into buckets, throwing into each bucket the items that have keys within a given range. Each thread then sorts the items in one of the buckets using a sequential sorting algorithm, and the result is a sorted set (when viewed in the appropriate bucket order). This algorithm is a generalization of the well-known <i>quicksort</i> algorithm, but instead of having a single <i>splitter</i> key to divide the items into two subsets, we have <span class="hiddenClass"><mml:math><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si139.png" style="vertical-align:middle" width="37"/></span> splitter keys that split the input set into <i>p</i> subsets.</p><p class="text" id="p0750">The algorithm for <i>n</i> items and <i>p</i> threads involves three phases:</p><div><ol><li class="numlist" id="o0035">1.  Threads choose <span class="hiddenClass"><mml:math><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si139.png" style="vertical-align:middle" width="37"/></span> splitter keys to partition the data set into <i>p</i> buckets. The splitters are published so all threads can read them.</li><li class="numlist" id="o0040">2.  Each thread sequentially processes <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si140.png" style="vertical-align:middle" width="29"/></span> items, moving each item to its bucket, where the appropriate bucket is determined by performing a binary search with the item's key among the splitter keys.</li><li class="numlist" id="o0045">3.  Each thread sequentially sorts the items in its bucket.</li></ol></div><p class="textfl"> Barriers between the phases ensure that all threads have completed one phase before the next starts.</p><p class="text" id="p0770">Before we consider the first phase, we look at the second and third phases.</p><p class="text" id="p0775">The second phase's time complexity is <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si141.png" style="vertical-align:middle" width="75"/></span>, consisting of reading each item from memory, disk, or tape, followed by a binary search among <i>p</i> splitters cached locally, and finally adding the item into the appropriate bucket. The buckets into which the items are moved could be in memory, on disk, or on tape, so the dominating cost is that of the <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si140.png" style="vertical-align:middle" width="29"/></span> accesses to the stored data items.</p><p class="text" id="p0780">Let <i>b</i> be the number of items in a bucket. The time complexity of the third phase for a given thread is <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si142.png" style="vertical-align:middle" width="67"/></span>, to sort the items using a sequential version of, say, <i>quicksort</i>.<sup><a epub:type="noteref" href="#fn004" id="cf0290" role="doc-noteref">4</a></sup> This part has the highest cost because it consists of read and write phases that access relatively slow memory, such as disk or tape.</p><p class="text" id="p0785">The time complexity of the algorithm is dominated by the thread with the most items in its bucket in the third phase. It is therefore important to choose the splitters to be as evenly distributed as possible, so each bucket receives approximately <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si140.png" style="vertical-align:middle" width="29"/></span> items in the second phase.</p><p class="text" id="p0790">The key to choosing good splitters is to have each thread pick a set of <i>sample</i> splitters that represent its own <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si140.png" style="vertical-align:middle" width="29"/></span> size data set, and choose the final <span class="hiddenClass"><mml:math><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si139.png" style="vertical-align:middle" width="37"/></span> splitters from among all the sample splitter sets of all threads. Each thread selects uniformly at random <i>s</i> keys from its <span aria-label="Page 298" epub:type="pagebreak" id="page_298" role="doc-pagebreak"/>data set of size <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si140.png" style="vertical-align:middle" width="29"/></span>. (In practice, it suffices to choose <i>s</i> to be 32 or 64 keys.) Each thread then participates in running the parallel <img alt="Image" height="9" src="images/B9780124159501000227/fx059.jpg" width="72"/> (<a href="#f0150" id="cf0295">Fig. 12.29</a>) on the <span class="hiddenClass"><mml:math><mml:mi>s</mml:mi><mml:mo>⋅</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si143.png" style="vertical-align:middle" width="30"/></span> sample keys selected by the <i>p</i> threads. Finally, each thread reads the <span class="hiddenClass"><mml:math><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si139.png" style="vertical-align:middle" width="37"/></span> splitter keys in positions <span class="hiddenClass"><mml:math><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>s</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si144.png" style="vertical-align:middle" width="122"/></span> in the sorted set of splitters, and uses these as the splitters in the second phase. This choice of <i>s</i> samples, and the later choice of the final splitters from the sorted set of all samples, reduces the effects of an uneven key distribution among the <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si140.png" style="vertical-align:middle" width="29"/></span> size data sets accessed by the threads.</p><p class="text" id="p0795">For example, a sample sort algorithm could choose to have each thread pick <span class="hiddenClass"><mml:math><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si139.png" style="vertical-align:middle" width="37"/></span> splitters for its second phase from within its own <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si140.png" style="vertical-align:middle" width="29"/></span> size data set, without ever communicating with other threads. The problem with this approach is that if the distribution of the data is uneven, the size of the buckets may differ greatly, and performance would suffer. For example, if the number of items in the largest bucket is doubled, so is the worst-case time complexity of the sorting algorithm.</p><p class="text" id="p0800">The first phase's complexity is <i>s</i> (a constant) to perform the random sampling, and <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>⁡</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="17" src="images/B9780124159501000227/si138.png" style="vertical-align:middle" width="66"/></span> for the parallel Bitonic sort. The overall time complexity of sample sort with a good splitter set (where every bucket gets <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si145.png" style="vertical-align:middle" width="52"/></span> of the items) is</p><p class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>⁡</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="25" src="images/B9780124159501000227/si146.png" width="453"/><a id="deq9"/></p></div><p class="textfl"> which overall is <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si147.png" style="vertical-align:middle" width="125"/></span>.</p></section><section><h2 class="h1hd" id="s0115"><a id="st0130"/>12.10 Distributed coordination</h2><p class="textfl" id="p0805">This chapter covered several distributed coordination patterns. Some, such as combining trees, sorting networks, and sample sorting, have high parallelism and low overhead. All these algorithms contain synchronization bottlenecks, that is, points in the computation where threads must wait to rendezvous with others. In combining trees, threads must synchronize to combine; when sorting, threads synchronize at barriers.</p><p class="text" id="p0810">In other schemes, such as counting networks and diffracting trees, threads never wait for one another. (Although we implement balancers using <img alt="Image" height="11" src="images/B9780124159501000227/fx004.jpg" width="79"/> methods, they could be implemented in a lock-free manner using <img alt="Image" height="12" src="images/B9780124159501000227/fx063.jpg" width="97"/>.) Here, the distributed structures pass information from one thread to another, and while a rendezvous could prove advantageous (as in the <img alt="Image" height="9" src="images/B9780124159501000227/fx045.jpg" width="32"/> array), it is not necessary.</p><p class="text" id="p0815">Randomization, which is useful in many places, helps to distribute work evenly. For diffracting trees, randomization distributes work over multiple memory locations, reducing the chance that too many threads simultaneously access the same location. For sample sort, randomization helps distribute work evenly among buckets, which threads later sort in parallel.</p><p class="text" id="p0820">Finally, we saw that pipelining can ensure that some data structures can have high throughput, even though they have high latency.</p><p class="text" id="p0825">Although we focus on shared-memory multiprocessors, it is worth mentioning that the distributed algorithms and structures considered in this chapter <span aria-label="Page 299" epub:type="pagebreak" id="page_299" role="doc-pagebreak"/>also work in message passing architectures. The message passing model might be implemented directly in hardware, as in a network of processors, or it could be provided on top of a shared-memory architecture through a software layer such as MPI.</p><p class="text" id="p0830">In shared-memory architectures, switches (such as combining tree nodes or balancers) are naturally implemented as shared-memory counters. In message passing architectures, switches are naturally implemented as processor-local data structures, where wires that link one processor to another also link one switch to another. When a processor receives a message, it atomically updates its local data structure and forwards messages to the processors managing other switches.</p></section><section><h2 class="h1hd" id="s0120"><a id="st0135"/>12.11 Chapter notes</h2><p class="textfl" id="p0835">The idea behind combining trees is due to Allan Gottlieb, Ralph Grishman, Clyde Kruskal, Kevin McAuliffe, Larry Rudolph, and Marc Snir <a epub:type="noteref" href="#br0265" id="cf0300" role="doc-noteref">[53]</a>. The software <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> presented here is adapted from an algorithm by PenChung Yew, Nian-Feng Tzeng, and Duncan Lawrie <a epub:type="noteref" href="#br0840" id="cf0305" role="doc-noteref">[168]</a> with modifications by Maurice Herlihy, Beng-Hong Lim, and Nir Shavit <a epub:type="noteref" href="#br0355" id="cf0310" role="doc-noteref">[71]</a>, all based on an original proposal by James Goodman, Mary Vernon, and Philip Woest <a epub:type="noteref" href="#br0255" id="cf0315" role="doc-noteref">[51]</a>.</p><p class="text" id="p0840">Counting networks were invented by Jim Aspnes, Maurice Herlihy, and Nir Shavit <a epub:type="noteref" href="#br0070" id="cf0320" role="doc-noteref">[14]</a>. Counting networks are related to <i>sorting networks</i>, including the groundbreaking Bitonic network of Kenneth Batcher <a epub:type="noteref" href="#br0080" id="cf0325" role="doc-noteref">[16]</a>, and the periodic network of Martin Dowd, Yehoshua Perl, Larry Rudolph, and Mike Saks <a epub:type="noteref" href="#br0200" id="cf0330" role="doc-noteref">[40]</a>. Miklós Ajtai, János Komlós, and Endre Szemerédi discovered the AKS sorting network, an <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si148.png" style="vertical-align:middle" width="61"/></span> depth sorting network <a epub:type="noteref" href="#br0040" id="cf0335" role="doc-noteref">[8]</a>. (This asymptotic expression hides large constants that make networks based on AKS impractical.)</p><p class="text" id="p0845">Mike Klugerman and Greg Plaxton <a epub:type="noteref" href="#br0465" id="cs0010" role="doc-noteref">[93</a>,<a epub:type="noteref" href="#br0470" role="doc-noteref">94]</a> were the first to provide an AKS-based counting network construction with <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si148.png" style="vertical-align:middle" width="61"/></span> depth. The 0-1 principle for sorting networks is by Donald Knuth <a epub:type="noteref" href="#br0475" id="cf0340" role="doc-noteref">[95]</a>. A similar set of rules for balancing networks is provided by Costas Busch and Marios Mavronicolas <a epub:type="noteref" href="#br0130" id="cf0345" role="doc-noteref">[26]</a>. Diffracting trees were invented by Nir Shavit and Asaph Zemach <a epub:type="noteref" href="#br0790" id="cf0350" role="doc-noteref">[158]</a>.</p><p class="text" id="p0850">Sample sorting was suggested by John Reif and Leslie Valiant <a epub:type="noteref" href="#br0740" id="cf0355" role="doc-noteref">[148]</a> and by Huang and Chow <a epub:type="noteref" href="#br0400" id="cf0360" role="doc-noteref">[80]</a>. The sequential Quicksort algorithm to which all sample sorting algorithms relate is due to Tony Hoare <a epub:type="noteref" href="#br0380" id="cf0365" role="doc-noteref">[76]</a>. There are numerous parallel radix sort algorithms in the literature such as the one by Daniel Jiménez-González, Joseph Larriba-Pey, and Juan Navarro <a epub:type="noteref" href="#br0455" id="cf0370" role="doc-noteref">[91]</a> or the one by Shin-Jae Lee, Minsoo Jeon, Dongseung Kim, and Andrew Sohn <a epub:type="noteref" href="#br0555" id="cf0375" role="doc-noteref">[111]</a>.</p><p class="text" id="p0855"><i>Monty Python and the Holy Grail</i> was written by Graham Chapman, John Cleese, Terry Gilliam, Eric Idle, Terry Jones, and Michael Palin and codirected by Terry Gilliam and Terry Jones <a epub:type="noteref" href="#br0140" id="cf0380" role="doc-noteref">[28]</a>.<span aria-label="Page 300" epub:type="pagebreak" id="page_300" role="doc-pagebreak"/></p></section><section><h2 class="h1hd" id="s0125"><a id="st0140"/>12.12 Exercises</h2><p class="textfl" id="p0860"/><div class="boxg1" id="enun0095"><p class="b1num">Exercise 12.1 </p><div><p class="b1textfl" id="p0865">Prove <a href="#enun0015" id="cf0385">Lemma 12.5.1</a>.</p></div></div><p class="textfl"/><p class="text" id="p0870"/><div class="boxg1" id="enun0100"><p class="b1num">Exercise 12.2 </p><div><p class="b1textfl" id="p0875">Implement a <i>trinary</i> <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/>, that is, one that allows up to three threads coming from three subtrees to combine at a given node. Can you estimate the advantages and disadvantages of such a tree when compared with a <i>binary</i> combining tree?</p></div></div><p class="textfl"/><p class="text" id="p0880"/><div class="boxg1" id="enun0105"><p class="b1num">Exercise 12.3 </p><div><p class="b1textfl" id="p0885">Implement a <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> using <img alt="Image" height="11" src="images/B9780124159501000227/fx064.jpg" width="59"/> objects to perform the coordination among threads ascending and descending the tree. What are the possible disadvantages of your construction when compared to the <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/> class presented in Section <a href="#s0020" id="cf0390">12.3</a>?</p></div></div><p class="textfl"/><p class="text" id="p0890"/><div class="boxg1" id="enun0110"><p class="b1num">Exercise 12.4 </p><div><p class="b1textfl" id="p0895">Implement the cyclic array-based shared pool described in Section <a href="#s0015" id="cf0395">12.2</a> using two simple counters and a <img alt="Image" height="9" src="images/B9780124159501000227/fx065.jpg" width="86"/> per array entry.</p></div></div><p class="textfl"/><p class="text" id="p0900"/><div class="boxg1" id="enun0115"><p class="b1num">Exercise 12.5 </p><div><p class="b1textfl" id="p0905">Provide an efficient lock-free implementation of a <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/>.</p></div></div><p class="textfl"/><p class="text" id="p0910"/><div class="boxg1" id="enun0120"><p class="b1num">Exercise 12.6 </p><div><p class="b1textfl" id="p0915">(Hard) Provide an efficient wait-free implementation of a <img alt="Image" height="9" src="images/B9780124159501000227/fx031.jpg" width="52"/> (i.e., not by using the universal construction).</p></div></div><p class="textfl"/><p class="text" id="p0920"/><div class="boxg1" id="enun0125"><p class="b1num">Exercise 12.7 </p><div><p class="b1textfl" id="p0925">Prove that the <span class="small-caps">Tree</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> balancing network constructed in Section <a href="#s0085" id="cf0400">12.6</a> is a counting network, that is, that in any quiescent state, the sequences of tokens on its output wires have the step property.</p></div></div><p class="textfl"/><p class="text" id="p0930"/><div class="boxg1" id="enun0130"><p class="b1num">Exercise 12.8 </p><div><p class="b1textfl" id="p0935">Let <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">B</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si149.png" style="vertical-align:middle" width="14"/></span> be a width-<i>w</i> balancing network of depth <i>d</i> in a quiescent state <i>s</i>. Let <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si150.png" style="vertical-align:middle" width="45"/></span>. Prove that if <i>n</i> tokens enter the network on the same wire, pass through the network, and exit, then <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">B</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si149.png" style="vertical-align:middle" width="14"/></span> will have the same state after the tokens exit as it did before they entered.</p></div></div><p class="textfl"/><p class="text" id="p0940"/><div class="boxg1" id="enun0135"><p class="b1num">Exercise 12.9 </p><div><p class="b1textfl" id="p0945">Let <i>X</i> and <i>Y</i> be <i>k</i>-smooth sequences of length <i>w</i>. A <i>matching</i> layer of balancers for <i>X</i> and <i>Y</i> is one where each element of <i>X</i> is joined by a balancer to an element of <i>Y</i> in a one-to-one correspondence.</p><p class="b1text" id="p0950">Prove that if <i>X</i> and <i>Y</i> are each <i>k</i>-smooth and <i>Z</i> is the result of matching <i>X</i> and <i>Y</i>, then <i>Z</i> is <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si151.png" style="vertical-align:middle" width="48"/></span>-smooth.</p></div></div><p class="textfl"/><p class="text" id="p0955"/><div class="boxg1" id="enun0140"><p class="b1num">Exercise 12.10 </p><div><p class="b1textfl" id="p0960">Consider a <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si44.png" style="vertical-align:middle" width="20"/></span> network in which each balancer has been initialized to an arbitrary state (either <i>up</i> or <i>down</i>). Show that no matter what the input distribution is, the output distribution is <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si152.png" style="vertical-align:middle" width="44"/></span>-smooth.</p><p class="b1text" id="p0965">Hint: You may use the claim in Exercise <a href="#enun0135" id="cf0405">12.9</a>.</p></div></div><p class="textfl"/><p class="text" id="p0970"/><div class="boxg1" id="enun0145"><p class="b1num">Exercise 12.11 </p><div><p class="b1textfl" id="p0975">A <i>smoothing network</i> is a balancing network that ensures that in any quiescent state, the output sequence is 1-smooth.</p><p class="b1text" id="p0980">Counting networks are smoothing networks, but not vice versa.</p><p class="b1text" id="p0985">A Boolean sorting network is one in which all inputs are guaranteed to be Boolean. Define a <i>pseudosorting balancing network</i> to be a balancing network with a layout isomorphic to a Boolean sorting network.</p><p class="b1text" id="p0990"><span aria-label="Page 301" epub:type="pagebreak" id="page_301" role="doc-pagebreak"/>Let <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">N</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si153.png" style="vertical-align:middle" width="19"/></span> be the balancing network constructed by taking a smoothing network <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">S</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si154.png" style="vertical-align:middle" width="14"/></span> of width <i>w</i>, taking a pseudosorting balancing network <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">P</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si155.png" style="vertical-align:middle" width="15"/></span> also of width <i>w</i>, and joining the <i>i</i>th output wire of <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">S</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si154.png" style="vertical-align:middle" width="14"/></span> to the <i>i</i>th input wire of <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">P</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si155.png" style="vertical-align:middle" width="15"/></span>.</p><p class="b1text" id="p0995">Show that <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">N</mml:mi></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si153.png" style="vertical-align:middle" width="19"/></span> is a counting network.</p></div></div><p class="textfl"/><p class="text" id="p1000"/><div class="boxg1" id="enun0150"><p class="b1num">Exercise 12.12 </p><div><p class="b1textfl" id="p1005">A <i>3-balancer</i> is a balancer with three input lines and three output lines. Like its 2-line relative, its output sequences have the step property in any quiescent state. Construct a depth-3 counting network with six input and output lines from 2-balancers and 3-balancers. Explain why it works.</p></div></div><p class="textfl"/><p class="text" id="p1010"/><div class="boxg1" id="enun0155"><p class="b1num">Exercise 12.13 </p><div><p class="b1textfl" id="p1015">Suggest ways to modify the <img alt="Image" height="9" src="images/B9780124159501000227/fx059.jpg" width="72"/> class so that it will sort an input array of width <i>w</i>, where <i>w</i> is not a power of 2.</p></div></div><p class="textfl"/><p class="text" id="p1020"/><div class="boxg1" id="enun0160"><p class="b1num">Exercise 12.14 </p><div><p class="b1textfl" id="p1025">Consider the following <i>w</i>-thread counting algorithm. Each thread first uses a bitonic counting network of width <i>w</i> to take a counter value <i>v</i>. It then goes through a <i>waiting filter</i>, in which each thread waits for threads with lower values to catch up.</p><p class="b1text" id="p1030">The waiting filter is an array <img alt="Image" height="9" src="images/B9780124159501000227/fx066.jpg" width="39"/>[] of <i>w</i> Boolean values. Define the phase function</p><p class="hiddenClass"><mml:math><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="badbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">⌊</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">/</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">⌋</mml:mo><mml:mspace width="0.25em"/><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mn>2</mml:mn><mml:mo>.</mml:mo></mml:math></p><div class="showClass"><p class="fig"><img alt="Image" height="19" src="images/B9780124159501000227/si156.png" width="212"/><a id="deq10"/></p></div><p class="b1textfl"> A thread that exits with value <i>v</i> spins on <img alt="Image" height="9" src="images/B9780124159501000227/fx066.jpg" width="39"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.25em"/><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si157.png" style="vertical-align:middle" width="104"/></span> until that value is set to <span class="hiddenClass"><mml:math><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si158.png" style="vertical-align:middle" width="60"/></span>. The thread responds by setting <img alt="Image" height="9" src="images/B9780124159501000227/fx066.jpg" width="39"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>v</mml:mi><mml:mspace width="0.25em"/><mml:mrow><mml:mi mathvariant="normal">mod</mml:mi></mml:mrow><mml:mspace width="0.25em"/><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si159.png" style="vertical-align:middle" width="69"/></span> to <span class="hiddenClass"><mml:math><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si160.png" style="vertical-align:middle" width="33"/></span>, and then returns <i>v</i>.</p><div><ol><li class="b1numlist" id="o0050">1.  Explain why this counter implementation is linearizable.</li><li class="b1numlist" id="o0055">2.  An exercise here shows that any linearizable counting network has depth at least <i>w</i>. Explain why the <img alt="Image" height="9" src="images/B9780124159501000227/fx066.jpg" width="39"/>[] construction does not contradict this claim.</li><li class="b1numlist" id="o0060">3.  On a bus-based multiprocessor, would this <img alt="Image" height="9" src="images/B9780124159501000227/fx066.jpg" width="39"/>[] construction have better throughput than a single variable protected by a spin lock? Explain.</li></ol></div><p class="b1textfl"/></div></div><p class="textfl"/><p class="text" id="p1050"/><div class="boxg1" id="enun0165"><p class="b1num">Exercise 12.15 </p><div><p class="b1textfl" id="p1055">If a sequence <span class="hiddenClass"><mml:math><mml:mi>X</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si161.png" style="vertical-align:middle" width="108"/></span> is <i>k</i>-smooth, then the result of passing <i>X</i> through a balancing network is <i>k</i>-smooth.</p></div></div><p class="textfl"/><p class="text" id="p1060"/><div class="boxg1" id="enun0170"><p class="b1num">Exercise 12.16 </p><div><p class="b1textfl" id="p1065">Prove that the <span class="small-caps">Bitonic</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si55.png" style="vertical-align:middle" width="24"/></span> network has depth <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>2</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si162.png" style="vertical-align:middle" width="137"/></span> and uses <span class="hiddenClass"><mml:math><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="badbreak" linebreakstyle="after">+</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mn>4</mml:mn></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si163.png" style="vertical-align:middle" width="152"/></span> balancers.</p></div></div><p class="textfl"/><p class="text" id="p1070"/><div class="boxg1" id="enun0175"><p class="b1num">Exercise 12.17 </p><div><p class="b1textfl" id="p1075">Show that the <img alt="Image" height="9" src="images/B9780124159501000227/fx067.jpg" width="45"/> network in <a href="#f0145" id="cf0410">Fig. 12.28</a> is a sorting network but not a counting network.</p></div></div><p class="textfl"/><p class="text" id="p1080"/><div class="boxg1" id="enun0180"><p class="b1num">Exercise 12.18 </p><div><p class="b1textfl" id="p1085">Can counting networks do anything besides increments? Consider a new kind of token, called an <i>antitoken</i>, which we use for decrements. Recall that when a token visits a balancer, it executes <img alt="Image" height="11" src="images/B9780124159501000227/fx068.jpg" width="106"/>(): It atomically reads the toggle value and complements it, and then departs on the output wire indicated by the old toggle value. Instead, an antitoken complements the toggle value, and then departs on the output wire indicated by the new toggle value. Informally, an antitoken “cancels” the effect of the most recent token on the balancer's toggle state, and vice versa.</p><p class="b1text" id="p1090"><span aria-label="Page 302" epub:type="pagebreak" id="page_302" role="doc-pagebreak"/>Instead of simply balancing the number of tokens that emerge on each wire, we assign a <i>weight</i> of +1 to each token and −1 to each antitoken. We generalize the step property to require that the sums of the weights of the tokens and antitokens that emerge on each wire have the step property. We call this property the <i>weighted step property</i>.</p><p class="b1text" id="p1095"><a href="#f0155" id="cf0415">Fig. 12.30</a> shows an <img alt="Image" height="9" src="images/B9780124159501000227/fx069.jpg" width="79"/>() method that moves an antitoken though a balancer. (Other networks would need different <img alt="Image" height="9" src="images/B9780124159501000227/fx069.jpg" width="79"/>() methods.)</p><div class="pageavoid"><figure class="fig" id="f0155"><img alt="Image" height="175" src="images/B9780124159501000227/gr030.jpg" width="273"/><br/><figcaption><div class="figleg" title="figure"><span class="fignum">Figure 12.30</span> The <img alt="Image" height="9" src="images/B9780124159501000227/fx069.jpg" width="79"/>() method.</div></figcaption></figure></div><p class="b1text" id="p1100">Let <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">B</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si149.png" style="vertical-align:middle" width="14"/></span> be a width-<i>w</i> balancing network of depth <i>d</i> in a quiescent state <i>s</i>. Let <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si150.png" style="vertical-align:middle" width="45"/></span>. Show that if <i>n</i> tokens enter the network on the same wire, pass through the network, and exit, then <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">B</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si149.png" style="vertical-align:middle" width="14"/></span> will have the same state after the tokens exit as it did before they entered.</p></div></div><p class="textfl"/><p class="text" id="p1105"/><div class="boxg1" id="enun0185"><p class="b1num">Exercise 12.19 </p><div><p class="b1textfl" id="p1110">Let <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">B</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si149.png" style="vertical-align:middle" width="14"/></span> be a balancing network in a quiescent state <i>s</i>, and suppose a token enters on wire <i>i</i> and passes through the network, leaving the network in state <span class="hiddenClass"><mml:math><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si164.png" style="vertical-align:middle" width="13"/></span>. Show that if an antitoken now enters on wire <i>i</i> and passes through the network, then the network goes back to state <i>s</i>.</p></div></div><p class="textfl"/><p class="text" id="p1115"/><div class="boxg1" id="enun0190"><p class="b1num">Exercise 12.20 </p><div><p class="b1textfl" id="p1120">Show that if balancing network <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">B</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si149.png" style="vertical-align:middle" width="14"/></span> is a counting network for tokens alone, then it is also a balancing network for tokens and antitokens.</p></div></div><p class="textfl"/><p class="text" id="p1125"/><div class="boxg1" id="enun0195"><p class="b1num">Exercise 12.21 </p><div><p class="b1textfl" id="p1130">A <i>switching network</i> is a directed graph, where edges are called <i>wires</i> and nodes are called <i>switches</i>. Each thread shepherds a <i>token</i> through the network. Switches and tokens are allowed to have internal states. A token arrives at a switch via an input wire. In one atomic step, the switch absorbs the token, changes its state and possibly the token's state, and emits the token on an output wire. Here, for simplicity, switches have two input and output wires. Note that switching networks are more powerful than balancing networks, since switches can have arbitrary state (instead of a single bit) and tokens also have state.</p><p class="b1text" id="p1135">An <i>adding network</i> is a switching network that allows threads to add (or subtract) arbitrary values.<span aria-label="Page 303" epub:type="pagebreak" id="page_303" role="doc-pagebreak"/></p><p class="b1text" id="p1140">We say that a token is <i>in front of</i> a switch if it is on one of the switch's input wires. Start with the network in a quiescent state <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si165.png" style="vertical-align:middle" width="17"/></span>, where the next token to run will take value 0. Imagine we have one token <i>t</i> of weight <i>a</i> and <i>n</i>–1 tokens <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si166.png" style="vertical-align:middle" width="75"/></span> all of weight <i>b</i>, where <span class="hiddenClass"><mml:math><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mi>a</mml:mi></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si167.png" style="vertical-align:middle" width="38"/></span>, each on a distinct input wire. Denote by <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">S</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si154.png" style="vertical-align:middle" width="14"/></span> the set of switches that <i>t</i> traverses if it traverses the network by starting in <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="10" src="images/B9780124159501000227/si165.png" style="vertical-align:middle" width="17"/></span>.</p><p class="b1text" id="p1145">Prove that if we run the <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="12" src="images/B9780124159501000227/si166.png" style="vertical-align:middle" width="75"/></span> one at a time though the network, we can halt each <span class="hiddenClass"><mml:math><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si169.png" style="vertical-align:middle" width="11"/></span> in front of a switch of <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">S</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si154.png" style="vertical-align:middle" width="14"/></span>.</p><p class="b1text" id="p1150">At the end of this construction, <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si170.png" style="vertical-align:middle" width="37"/></span> tokens are in front of switches of <span class="hiddenClass"><mml:math><mml:mi mathvariant="script">S</mml:mi></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si154.png" style="vertical-align:middle" width="14"/></span>. Since switches have two input wires, it follows that <i>t</i>'s path through the network encompasses at least <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si170.png" style="vertical-align:middle" width="37"/></span> switches, so any adding network must have depth at least <span class="hiddenClass"><mml:math><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>1</mml:mn></mml:math></span><span><img alt="Image" height="11" src="images/B9780124159501000227/si170.png" style="vertical-align:middle" width="37"/></span>, where <i>n</i> is the maximum number of concurrent tokens. This bound is discouraging because it implies that the size of the network depends on the number of threads (also true for <img alt="Image" height="11" src="images/B9780124159501000227/fx006.jpg" width="86"/>s, but not counting networks), and that the network has inherently high latency.</p></div></div><p class="textfl"/><p class="text" id="p1155"/><div class="boxg1" id="enun0200"><p class="b1num">Exercise 12.22 </p><div><p class="b1textfl" id="p1160">Extend the proof of <a href="#enun0195" id="cf0420">Exercise 12.21</a> to show that a <i>linearizable</i> counting network has depth at least <i>n</i>.</p></div></div><p class="textfl"/></section><footer><section epub:type="bibliography" role="doc-bibliography"><div id="bl0610"><h2 class="reftitle" id="st0145">Bibliography</h2><p class="reflist" epub:type="biblioentry footnote" id="br0040" role="doc-biblioentry">[8] M. Ajtai, J. Komlós, E. Szemerédi,  An <span class="hiddenClass"><mml:math><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></span><span><img alt="Image" height="14" src="images/B9780124159501000227/si171.png" style="vertical-align:middle" width="68"/></span> sorting network,   <i>Proc. of the 15th Annual ACM Symposium on Theory of Computing</i>.  1983:1–9.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0070" role="doc-biblioentry">[14] James Aspnes, Maurice Herlihy, Nir Shavit,  Counting networks,   <cite><i>Journal of the ACM</i></cite> 1994;41(5):1020–1048.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0080" role="doc-biblioentry">[16] K. Batcher,  Sorting networks and their applications,   <i>Proceedings of AFIPS Joint Computer Conference</i>.  1968:307–314.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0130" role="doc-biblioentry">[26] Costas Busch, Marios Mavronicolas,  A combinatorial treatment of balancing networks,   <cite><i>Journal of the ACM</i></cite> 1996;43(5):794–839.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0140" role="doc-biblioentry">[28] Graham Chapman, John Cleese, Terry Gilliam, Eric Idle, Terry Jones, Michael Palin,  <i>Monty Phyton and the Holy Grail</i>.  1975.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0200" role="doc-biblioentry">[40] Martin Dowd, Yehoshua Perl, Larry Rudolph, Michael Saks,  The periodic balanced sorting network,   <cite><i>Journal of the ACM</i></cite> 1989;36(4):738–757.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0255" role="doc-biblioentry">[51] James R. Goodman, Mary K. Vernon, Philip J. Woest,  Efficient synchronization primitives for large-scale cache-coherent multiprocessors,   <i>Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems</i>.  ACM Press; 1989:64–75.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0265" role="doc-biblioentry">[53] A. Gottlieb, R. Grishman, C.P. Kruskal, K.P. McAuliffe, L. Rudolph, M. Snir,  The NYU ultracomputer - designing an MIMD parallel computer,   <cite><i>IEEE Transactions on Computers</i></cite> February 1984;C-32(2):175–189.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0355" role="doc-biblioentry">[71] Maurice Herlihy, Beng-Hong Lim, Nir Shavit,  Scalable concurrent counting,   <cite><i>ACM Transactions on Computer Systems</i></cite> 1995;13(4):343–364.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0380" role="doc-biblioentry">[76] C.A.R. Hoare,  “Algorithm 63: partition,” “Algorithm 64: quicksort,” and “Algorithm 65: find”,   <cite><i>Communications of the ACM</i></cite> 1961;4(7):321–322.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0400" role="doc-biblioentry">[80] J.S. Huang, Y.C. Chow,  Parallel sorting and data partitioning by sampling,   <i>Proceedings of the IEEE Computer Society's Seventh International Computer Software and Applications Conference</i>.  1983:627–631.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0455" role="doc-biblioentry">[91] D. Jimenez-Gonzalez, J.J. Navarro, J.-L. Lirriba-Pey,  Cc-radix: a cache conscious sorting based on radix sort,   <i>Proc. of the 11th Euromicro Conference on Parallel, Distributed and Network-Based Processing</i>.  2003:101–108.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0465" role="doc-biblioentry">[93] M.R. Klugerman,  <i>Small-depth counting networks and related topics</i>. [Technical Report MIT/LCS/TR-643] MIT Laboratory for Computer Science; 1994.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0470" role="doc-biblioentry">[94] Michael Klugerman, C. Greg Plaxton,  Small-depth counting networks,   <i>STOC '92: Proceedings of the Twenty-Fourth Annual ACM Symposium on Theory of Computing</i>.  New York, NY, USA: ACM Press; 1992:417–428.</p><p class="reflist1" epub:type="biblioentry footnote" id="br0475" role="doc-biblioentry">[95] D. Knuth,  <i>The Art of Computer Programming: Fundamental Algorithms, vol. 3</i>.  Addison-Wesley; 1973.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0555" role="doc-biblioentry">[111] Shin-Jae Lee, Minsoo Jeon, Dongseung Kim, Andrew Sohn,  Partitioned parallel radix sort,   <cite><i>Journal of Parallel and Distributed Computing</i></cite> 2002;62(4):656–668.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0740" role="doc-biblioentry">[148] John H. Reif, Leslie G. Valiant,  A logarithmic time sort for linear size networks,   <cite><i>Journal of the ACM</i></cite> 1987;34(1):60–76.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0790" role="doc-biblioentry">[158] Nir Shavit, Asaph Zemach,  Diffracting trees,   <cite><i>ACM Transactions on Computer Systems</i></cite> 1996;14(4):385–428.</p><p class="reflist2" epub:type="biblioentry footnote" id="br0840" role="doc-biblioentry">[168] P. Yew, N. Tzeng, D. Lawrie,  Distributing hot-spot addressing in large-scale multiprocessors,   <cite><i>IEEE Transactions on Computers</i></cite> April 1987;C-36(4):388–395.</p></div></section><section epub:type="rearnotes"><div class="ftnote"><hr/><p class="ftnote1" epub:type="footnote" id="fn001" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0100" role="doc-noteref">1 </a></sup> <a id="np0010"/>“See Chapter <a href="B9780124159501000124.xhtml">3</a> for a detailed definition of quiescent consistency.”</p><p class="ftnote1" epub:type="footnote" id="fn002" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0215" role="doc-noteref">2 </a></sup> <a id="np0015"/>“While the <span class="small-caps">Block</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> and <span class="small-caps">Merger</span><span style="display:inline-block; width: 0.20em;"/><span class="hiddenClass"><mml:math><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:math></span><span><img alt="Image" height="15" src="images/B9780124159501000227/si39.png" style="vertical-align:middle" width="28"/></span> networks may look the same, they are not: There is no permutation of wires that yields one from the other.”</p><p class="ftnote1" epub:type="footnote" id="fn003" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0260" role="doc-noteref">3 </a></sup> <a id="np0020"/>“Historically sorting networks predate counting networks by several decades.”</p><p class="ftnote1" epub:type="footnote" id="fn004" role="doc-footnote"><sup><a epub:type="noteref" href="#cf0290" role="doc-noteref">4 </a></sup> <a id="np0025"/>“If the item's key size is known and fixed, one could use algorithms like <i>Radixsort</i>.”</p></div></section></footer></section></body></html>