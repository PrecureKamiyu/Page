<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>2.5 Summary </title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P7000497027000000000000000001479" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P700049702700000000000000003F78B" data-uri="chapter02.xhtml#P700049702700000000000000003F78B" epub:type="title"><span class="pcalibre label pcalibre1">2.5 </span><span class="pcalibre label pcalibre1">Summary </span></h1></header>
<p id="P700049702700000000000000003F78C" data-uri="chapter02.xhtml#P700049702700000000000000003F78C" class="pcalibre1 pcalibre calibre2">Computers encode information as bits, generally organized as sequences of bytes. Different encodings are used for representing integers, real numbers, and character strings. Different models of computers use different conventions for encoding numbers and for ordering the bytes within multi-byte data.</p>
<p id="P700049702700000000000000003F78D" data-uri="chapter02.xhtml#P700049702700000000000000003F78D" class="pcalibre1 pcalibre calibre2">The C language is designed to accommodate a wide range of different implementations in terms of word sizes and numeric encodings. Machines with 64-bit word sizes have become increasingly common, replacing the 32-bit machines that dominated the market for around 30 years. Because 64-bit machines can also run programs compiled for 32-bit machines, we have focused on the distinction between 32-and 64-bit programs, rather than machines. The advantage of 64-bit programs is that they can go beyond the 4 GB address limitation of 32-bit programs.</p>
<p id="P700049702700000000000000003F78E" data-uri="chapter02.xhtml#P700049702700000000000000003F78E" class="pcalibre1 pcalibre calibre2">Most machines encode signed numbers using a two's-complement representation and encode floating-point numbers using IEEE Standard 754. Understanding these encodings at the bit level, as well as understanding the mathematical characteristics of the arithmetic operations, is important for writing programs that operate correctly over the full range of numeric values.</p>
<p id="P700049702700000000000000003F78F" data-uri="chapter02.xhtml#P700049702700000000000000003F78F" class="pcalibre1 pcalibre calibre2">When casting between signed and unsigned integers of the same size, most C implementations follow the convention that the underlying bit pattern does not change. On a two's-complement machine, this behavior is characterized by functions <i class="calibre5 pcalibre pcalibre1">T2U<sub class="pcalibre1 calibre47 pcalibre">w</sub></i> and <i class="calibre5 pcalibre pcalibre1">U2T<sub class="pcalibre1 calibre47 pcalibre">w</sub></i>, for a <var class="calibre5 pcalibre pcalibre1">w</var>-bit value. The implicit casting of C gives results that many programmers do not anticipate, often leading to program bugs.</p>
<p id="P700049702700000000000000003F790" data-uri="chapter02.xhtml#P700049702700000000000000003F790" class="pcalibre1 pcalibre calibre2">Due to the finite lengths of the encodings, computer arithmetic has properties quite different from conventional integer and real arithmetic. The finite length can cause numbers to overflow, when they exceed the range of the representation. Floating-point values can also underflow, when they are so close to 0.0 that they are changed to zero.</p>
<p id="P700049702700000000000000003F791" data-uri="chapter02.xhtml#P700049702700000000000000003F791" class="pcalibre1 pcalibre calibre2">The finite integer arithmetic implemented by C, as well as most other programming languages, has some peculiar properties compared to true integer arithmetic. For example, the expression <code id="P700049702700000000000000003F792" data-uri="chapter02.xhtml#P700049702700000000000000003F792" class="pcalibre1 calibre8 pcalibre">x*x</code> can evaluate to a negative number due to overflow. Nonetheless, both unsigned and two's-complement arithmetic satisfy many of the other properties of integer arithmetic, including associativity, commutativity, and distributivity. This allows compilers to do many optimizations. For example, in replacing the expression <code id="P700049702700000000000000003F793" data-uri="chapter02.xhtml#P700049702700000000000000003F793" class="pcalibre1 calibre8 pcalibre">7*x</code> by <code id="P700049702700000000000000003F794" data-uri="chapter02.xhtml#P700049702700000000000000003F794" class="pcalibre1 calibre8 pcalibre">(x&lt;&lt;3)–x</code>, we make use of the associative, commutative, and distributive properties, along with the relationship between shifting and multiplying by powers of 2.</p>
<p id="P700049702700000000000000003F795" data-uri="chapter02.xhtml#P700049702700000000000000003F795" class="pcalibre1 pcalibre calibre2">We have seen several clever ways to exploit combinations of bit-level operations and arithmetic operations. For example, we saw that with two's-complement arithmetic, <code id="P700049702700000000000000003F796" data-uri="chapter02.xhtml#P700049702700000000000000003F796" class="pcalibre1 calibre8 pcalibre">~x+1</code> is equivalent to <code id="P700049702700000000000000003F797" data-uri="chapter02.xhtml#P700049702700000000000000003F797" class="pcalibre1 calibre8 pcalibre">–x</code>. As another example, suppose we want a bit</p>
<aside class="sidebar pcalibre5 pcalibre" id="P7000497027000000000000000001487" data-uri="chapter02.xhtml#P7000497027000000000000000001487"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P700049702700000000000000003F798" data-uri="chapter02.xhtml#P700049702700000000000000003F798" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P7000497027000000000000000001489" title="127" data-uri="chapter02.xhtml#P7000497027000000000000000001489" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>Ariane 5: The high cost of floating-point overflow</h1></header>
<p id="P700049702700000000000000003F799" data-uri="chapter02.xhtml#P700049702700000000000000003F799" class="calibre13 pcalibre pcalibre1">Converting large floating-point numbers to integers is a common source of programming errors. Such an error had disastrous consequences for the maiden voyage of the Ariane 5 rocket, on June 4, 1996. Just 37 seconds after liftoff, the rocket veered off its flight path, broke up, and exploded. Communication satellites valued at $500 million were on board the rocket.</p>
<p id="P700049702700000000000000003F79A" data-uri="chapter02.xhtml#P700049702700000000000000003F79A" class="calibre13 pcalibre pcalibre1">A later investigation [<a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B435">73</a>, <a class="ulink pcalibre pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000B39D.xhtml#P700049702700000000000000000B3E3">33</a>] showed that the computer controlling the inertial navigation system had sent invalid data to the computer controlling the engine nozzles. Instead of sending flight control information, it had sent a diagnostic bit pattern indicating that an overflow had occurred during the conversion of a 64-bit floating-point number to a 16-bit signed integer.</p>
<p id="P700049702700000000000000003F79B" data-uri="chapter02.xhtml#P700049702700000000000000003F79B" class="pcalibre calibre3 pcalibre1">The value that overflowed measured the horizontal velocity of the rocket, which could be more than five times higher than that achieved by the earlier Ariane 4 rocket. In the design of the Ariane 4 software, they had carefully analyzed the numeric values and determined that the horizontal velocity would never overflow a 16-bit number. Unfortunately, they simply reused this part of the software in the Ariane 5 without checking the assumptions on which it had been based.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P700049702700000000000000003F79C" data-uri="chapter02.xhtml#P700049702700000000000000003F79C">pattern of the form [0, ... , 0, 1, ..., 1], consisting of <var class="calibre5 pcalibre pcalibre1">w</var> – <var class="calibre5 pcalibre pcalibre1">k</var> zeros followed by <var class="calibre5 pcalibre pcalibre1">k</var> ones. Such bit patterns are useful for masking operations. This pattern can be generated by the C expression <code id="P700049702700000000000000003F79D" data-uri="chapter02.xhtml#P700049702700000000000000003F79D" class="pcalibre1 calibre8 pcalibre">(1&lt;&lt;k)–1</code>, exploiting the property that the desired bit pattern has numeric value 2<sup class="calibre51 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">k</var></sup> – 1. For example, the expression <code id="P700049702700000000000000003F79E" data-uri="chapter02.xhtml#P700049702700000000000000003F79E" class="pcalibre1 calibre8 pcalibre">(1&lt;&lt;8)–1</code> will generate the bit pattern <code id="P700049702700000000000000003F79F" data-uri="chapter02.xhtml#P700049702700000000000000003F79F" class="pcalibre1 calibre8 pcalibre">0xFF</code>.</p>
<p id="P700049702700000000000000003F7A0" data-uri="chapter02.xhtml#P700049702700000000000000003F7A0" class="pcalibre1 pcalibre calibre2">Floating-point representations approximate real numbers by encoding numbers of the form <var class="calibre5 pcalibre pcalibre1">x</var> × 2<sup class="calibre51 pcalibre pcalibre1"><var class="calibre5 pcalibre pcalibre1">y</var></sup>. IEEE Standard 754 provides for several different precisions, with the most common being single (32 bits) and double (64 bits). IEEE floating point also has representations for special values representing plus and minus infinity, as well as not-a-number.</p>
<p id="P700049702700000000000000003F7A1" data-uri="chapter02.xhtml#P700049702700000000000000003F7A1" class="pcalibre1 pcalibre calibre2">Floating-point arithmetic must be used very carefully, because it has only limited range and precision, and because it does not obey common mathematical properties such as associativity.</p>
</section></body></html>
