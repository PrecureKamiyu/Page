<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 33. Threads: Further Details</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch32.html" title="Chapter 32. Threads: Thread Cancellation"/><link rel="next" href="ch34.html" title="Chapter 34. Process Groups, Sessions, and Job Control"/></head><body><section class="chapter" title="Chapter 33. Threads: Further Details" epub:type="chapter" id="threads_colon_further_details"><div class="titlepage"><div><div><h2 class="title">Chapter 33. Threads: Further Details</h2></div></div></div><p>This chapter provides further details on various aspects of POSIX threads. We discuss
            the interaction of threads with aspects of the traditional UNIX API—in particular,
            signals and the process control primitives (<span class="emphasis"><em>fork()</em></span>,
                <span class="emphasis"><em>exec()</em></span>, and <span class="emphasis"><em>_exit()</em></span>). We also provide an
            overview of the two POSIX threads implementations available on Linux—LinuxThreads and
            NPTL—and note where each of these implementations deviates from the SUSv3 specification
            of Pthreads.</p><div class="sect1" title="Thread Stacks"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="thread_stacks">Thread Stacks</h2></div></div></div><p>Each thread has its own stack whose size is fixed when the thread is created. On
                Linux/x86-32, for all threads other than the main thread, the default size of the
                per-thread stack is 2 MB. (On some 64-bit architectures, the default size is higher;
                for example, it is 32 MB on IA-64.) The main thread has a much larger space for
                stack growth (refer to <a class="xref" href="ch29.html#four_threads_executing_in_a_process_open" title="Figure 29-1. Four threads executing in a process (Linux/x86-32)">Figure 29-1</a>,
                in <a class="xref" href="ch29.html#background_details_of_the_pthreads_api" title="Background Details of the Pthreads API">Background Details of the Pthreads API</a>).<a id="IDX-CHP-33-4810" class="indexterm"/></p><p>Occasionally, it is useful to change the size of a thread’s stack. The
                    <span class="emphasis"><em>pthread_attr_setstacksize()</em></span> function sets a thread
                attribute (<a class="xref" href="ch29.html#thread_attributes" title="Thread Attributes">Thread Attributes</a>) that determines the size of the
                stack in threads created using the thread attributes object. The related
                    <span class="emphasis"><em>pthread_attr_setstack()</em></span> function can be used to control
                both the size and the location of the stack, but setting the location of a stack can
                decrease application portability. The manual pages provide details of these
                    functions.<a id="IDX-CHP-33-4811" class="indexterm"/></p><p>One reason to change the size of per-thread stacks is to allow for larger stacks
                for threads that allocate large automatic variables or make nested function calls of
                great depth (perhaps because of recursion). Alternatively, an application may want
                to reduce the size of per-thread stacks to allow for a greater number of threads
                within a process. For example, on x86-32, where the user-accessible virtual address
                space is 3 GB, the default stack size of 2 MB means that we can create a maximum of
                around 1500 threads. (The precise maximum depends on how much virtual memory is
                consumed by the text and data segments, shared libraries, and so on.) The minimum
                stack that can be employed on a particular architecture can be determined by calling
                    <span class="emphasis"><em>sysconf(_SC_THREAD_STACK_MIN)</em></span>. For the NPTL implementation
                on Linux/x86-32, this call returns the value 16,384.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Under the NPTL threading implementation, if the stack size resource limit
                        (<code class="literal">RLIMIT_STACK</code>) is set to anything other
                    than <span class="emphasis"><em>unlimited</em></span>, then it is used as the default stack size
                    when creating new threads. This limit must be set <span class="emphasis"><em>before</em></span>
                    the program is executed, typically by using the <span class="emphasis"><em>ulimit -s</em></span>
                    shell built-in command (<span class="emphasis"><em>limit stacksize</em></span> in the C shell)
                    before executing the program. It is not sufficient to use
                        <span class="emphasis"><em>setrlimit()</em></span> within the main program to set the limit,
                    because NPTL makes its determination of the default stack size during the
                    run-time initialization that occurs before <span class="emphasis"><em>main()</em></span> is
                    invoked.</p></div></div><div class="sect1" title="Threads and Signals"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="threads_and_signals">Threads and Signals</h2></div></div></div><p>The UNIX signal model was designed with the UNIX process model in mind, and
                predated the arrival of Pthreads by a couple of decades. As a result, there are some
                significant conflicts between the signal and thread models. These conflicts arose
                primarily from the need to maintain the traditional signal semantics for
                single-threaded processes (i.e., the signal semantics of traditional programs should
                not be changed by Pthreads), while at the same time developing a signal model that
                would be usable within a multithreaded process.<a id="IDX-CHP-33-4812" class="indexterm"/><a id="IDX-CHP-33-4813" class="indexterm"/><a id="IDX-CHP-33-4814" class="indexterm"/><a id="IDX-CHP-33-4815" class="indexterm"/><a id="IDX-CHP-33-4816" class="indexterm"/><a id="IDX-CHP-33-4817" class="indexterm"/></p><p>The differences between the signal and thread models mean that combining signals
                and threads is complex, and should be avoided whenever possible. Nevertheless,
                sometimes we must deal with signals in a threaded program. In this section, we
                discuss the interactions between threads and signals, and describe various functions
                that are useful in threaded programs that deal with signals.</p><div class="sect2" title="How the UNIX Signal Model Maps to Threads"><div class="titlepage"><div><div><h3 class="title" id="how_the_unix_signal_model_maps_to_thread">How the UNIX Signal Model Maps to Threads</h3></div></div></div><p>To understand how UNIX signals map to the Pthreads model, we need to know
                    which aspects of the signal model are process-wide (i.e., are shared by all of
                    the threads in the process) as opposed to those aspects that are specific to
                    individual threads within the process. The following list summarizes the key
                        points:<a id="IDX-CHP-33-4818" class="indexterm"/><a id="IDX-CHP-33-4819" class="indexterm"/><a id="IDX-CHP-33-4820" class="indexterm"/><a id="IDX-CHP-33-4821" class="indexterm"/><a id="IDX-CHP-33-4822" class="indexterm"/><a id="IDX-CHP-33-4823" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Signal actions are process-wide. If any unhandled signal whose default
                            action is <span class="emphasis"><em>stop</em></span> or <span class="emphasis"><em>terminate</em></span> is
                            delivered to any thread in a process, then all of the threads in the
                            process are stopped or terminated.</p></li><li class="listitem"><p>Signal dispositions are process-wide; all threads in a process share
                            the same disposition for each signal. If one thread uses
                                <span class="emphasis"><em>sigaction()</em></span> to establish a handler for, say,
                                <code class="literal">SIGINT</code>, then that handler may be
                            invoked from any thread to which the <code class="literal">SIGINT</code> is delivered. Similarly, if one thread sets the
                            disposition of a signal to <span class="emphasis"><em>ignore</em></span>, then that signal
                            is ignored by all threads.</p></li><li class="listitem"><p>A signal may be directed to either the process as a whole or to a
                            specific thread. A signal is thread-directed if:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>it is generated as the direct result of the execution of a
                                    specific hardware instruction within the context of the thread
                                    (i.e., the hardware exceptions described in <a class="xref" href="ch22.html#hardware-generated_signals" title="Hardware-Generated Signals">Hardware-Generated Signals</a>: <code class="literal">SIGBUS</code>, <code class="literal">SIGFPE</code>, <code class="literal">SIGILL</code>, and <code class="literal">SIGSEGV</code>);</p></li><li class="listitem"><p>it is a <code class="literal">SIGPIPE</code> signal
                                    generated when the thread tried to write to a broken pipe;
                                        or<a id="IDX-CHP-33-4824" class="indexterm"/></p></li><li class="listitem"><p>it is sent using <span class="emphasis"><em>pthread_kill()</em></span> or
                                        <span class="emphasis"><em>pthread_sigqueue()</em></span>, which are functions
                                    (described in <a class="xref" href="ch33.html#sending_a_signal_to_a_thread" title="Sending a Signal to a Thread">Sending a Signal to a Thread</a>)
                                    that allow one thread to send a signal to another thread within
                                    the same process.<a id="IDX-CHP-33-4825" class="indexterm"/><a id="IDX-CHP-33-4826" class="indexterm"/></p></li></ul></div><p>All signals generated by other mechanisms are process-directed.
                            Examples are signals sent from another process using
                                <span class="emphasis"><em>kill()</em></span> or <span class="emphasis"><em>sigqueue()</em></span>;
                            signals such as <code class="literal">SIGINT</code> and <code class="literal">SIGTSTP</code>, generated when the user types one
                            of the terminal special characters that generate a signal; and signals
                            generated for software events such as the resizing of a terminal window
                                (<code class="literal">SIGWINCH</code>) or the expiration of a
                            timer (e.g., <code class="literal">SIGALRM</code>).</p></li><li class="listitem"><p>When a signal is delivered to a multithreaded process that has
                            established a signal handler, the kernel arbitrarily selects one thread
                            in the process to which to deliver the signal and invokes the handler in
                            that thread. This behavior is consistent with maintaining the
                            traditional signal semantics. It would not make sense for a process to
                            perform the signal handling actions multiple times in response to a
                            single signal.</p></li><li class="listitem"><p>The signal mask is per-thread. (There is no notion of a process-wide
                            signal mask that governs all threads in a multithreaded process.)
                            Threads can independently block or unblock different signals using
                                <span class="emphasis"><em>pthread_sigmask()</em></span>, a new function defined by
                            the Pthreads API. By manipulating the per-thread signal masks, an
                            application can control which thread(s) may handle a signal that is
                            directed to the whole process.<a id="IDX-CHP-33-4827" class="indexterm"/><a id="IDX-CHP-33-4828" class="indexterm"/><a id="IDX-CHP-33-4829" class="indexterm"/><a id="IDX-CHP-33-4830" class="indexterm"/><a id="IDX-CHP-33-4831" class="indexterm"/></p></li><li class="listitem"><p>The kernel maintains a record of the signals that are pending for the
                            process as a whole, as well as a record of the signals that are pending
                            for each thread. A call to <span class="emphasis"><em>sigpending()</em></span> returns the
                            union of the set of signals that are pending for the process and those
                            that are pending for the calling thread. In a newly created thread, the
                            per-thread set of pending signals is initially empty. A thread-directed
                            signal can be delivered only to the target thread. If the thread is
                            blocking the signal, it will remain pending until the thread unblocks
                            the signal (or terminates).<a id="IDX-CHP-33-4832" class="indexterm"/><a id="IDX-CHP-33-4833" class="indexterm"/></p></li><li class="listitem"><p>If a signal handler interrupts a call to
                                <span class="emphasis"><em>pthread_mutex_lock()</em></span>, then the call is always
                            automatically restarted. If a signal handler interrupts a call to
                                <span class="emphasis"><em>pthread_cond_wait()</em></span>, then the call either is
                            restarted automatically (this is what Linux does) or returns 0,
                            indicating a spurious wake-up (in which case a well-designed application
                            will recheck the corresponding predicate and restart the call, as
                            described in <a class="xref" href="ch30.html#testing_a_condition_variable_number_symb" title="Testing a Condition Variable’s Predicate">Testing a Condition Variable’s Predicate</a>). SUSv3 requires these two functions to behave as described
                                here.<a id="IDX-CHP-33-4834" class="indexterm"/><a id="IDX-CHP-33-4835" class="indexterm"/></p></li><li class="listitem"><p>The alternate signal stack is per-thread (refer to the description of
                                <span class="emphasis"><em>sigaltstack()</em></span> in <a class="xref" href="ch21.html#handling_a_signal_on_an_alternate_stack" title="Handling a Signal on an Alternate Stack: sigaltstack()">Handling a Signal on an Alternate Stack:
                <span class="emphasis"><em>sigaltstack()</em></span></a>). A newly
                            created thread doesn’t inherit the alternate signal stack from its
                                creator.<a id="IDX-CHP-33-4836" class="indexterm"/></p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>More precisely, SUSv3 specifies that there is a separate alternate signal
                        stack for each kernel scheduling entity (KSE). On a system with a 1:1
                        threading implementation, as on Linux, there is one KSE per thread (see
                            <a class="xref" href="ch33.html#thread_implementation_models" title="Thread Implementation Models">Thread Implementation Models</a>).</p></div></div><div class="sect2" title="Manipulating the Thread Signal Mask"><div class="titlepage"><div><div><h3 class="title" id="manipulating_the_thread_signal_mask">Manipulating the Thread Signal Mask</h3></div></div></div><p>When a new thread is created, it inherits a copy of the signal mask of the
                    thread that created it. A thread can use <span class="emphasis"><em>pthread_sigmask()</em></span>
                    to change its signal mask, to retrieve the existing mask, or both.<a id="IDX-CHP-33-4837" class="indexterm"/><a id="IDX-CHP-33-4838" class="indexterm"/><a id="IDX-CHP-33-4839" class="indexterm"/><a id="IDX-CHP-33-4840" class="indexterm"/><a id="IDX-CHP-33-4841" class="indexterm"/><a id="IDX-CHP-33-4842" class="indexterm"/><a id="IDX-CHP-33-4843" class="indexterm"/><a id="IDX-CHP-33-4844" class="indexterm"/></p><a id="I_programlisting33_d1e91335"/><pre class="programlisting">#include &lt;signal.h&gt;

int <strong class="userinput"><code>pthread_sigmask</code></strong>(int <span class="emphasis"><em>how</em></span>, const sigset_t *<span class="emphasis"><em>set</em></span>, sigset_t *<span class="emphasis"><em>oldset</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><p>Other than the fact that it operates on the thread signal mask, the use of
                        <span class="emphasis"><em>pthread_sigmask()</em></span> is the same as the use of
                        <span class="emphasis"><em>sigprocmask()</em></span> (<a class="xref" href="ch20.html#the_signal_mask_open_parenthesis_blockin" title="The Signal Mask (Blocking Signal Delivery)">The Signal Mask (Blocking Signal Delivery)</a>).<a id="IDX-CHP-33-4845" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>SUSv3 notes that the use of <span class="emphasis"><em>sigprocmask()</em></span> within a
                        multithreaded program is unspecified. We can’t portably employ
                            <span class="emphasis"><em>sigprocmask()</em></span> in a multithreaded program. In
                        practice, <span class="emphasis"><em>sigprocmask()</em></span> and
                            <span class="emphasis"><em>pthread_sigmask()</em></span> are identical on many
                        implementations, including Linux.</p></div></div><div class="sect2" title="Sending a Signal to a Thread"><div class="titlepage"><div><div><h3 class="title" id="sending_a_signal_to_a_thread">Sending a Signal to a Thread</h3></div></div></div><p>The <span class="emphasis"><em>pthread_kill()</em></span> function sends the signal
                        <span class="emphasis"><em>sig</em></span> to another thread in the same process. The target
                    thread is identified by the argument <span class="emphasis"><em>thread</em></span>.<a id="IDX-CHP-33-4846" class="indexterm"/></p><a id="I_programlisting33_d1e91399"/><pre class="programlisting">#include &lt;signal.h&gt;

int <strong class="userinput"><code>pthread_kill</code></strong>(pthread_t <span class="emphasis"><em>thread</em></span>, int <span class="emphasis"><em>sig</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><p>Because a thread ID is guaranteed to be unique only within a process (see
                        <a class="xref" href="ch29.html#thread_ids" title="Thread IDs">Thread IDs</a>), we can’t use
                        <span class="emphasis"><em>pthread_kill()</em></span> to send a signal to a thread in another
                    process.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>pthread_kill()</em></span> function is implemented using the
                        Linux-specific <span class="emphasis"><em>tgkill(tgid, tid, sig)</em></span> system call,
                        which sends the signal <span class="emphasis"><em>sig</em></span> to the thread identified by
                            <span class="emphasis"><em>tid</em></span> (a kernel thread ID of the type returned by
                            <span class="emphasis"><em>gettid()</em></span>) within the thread group identified by
                            <span class="emphasis"><em>tgid</em></span>. See the <span class="emphasis"><em>tgkill(2)</em></span> manual
                        page for further details.</p></div><p>The Linux-specific <span class="emphasis"><em>pthread_sigqueue()</em></span> function combines
                    the functionality of <span class="emphasis"><em>pthread_kill()</em></span> and
                        <span class="emphasis"><em>sigqueue()</em></span> (<a class="xref" href="ch22.html#limits_on_the_number_of_queued_real-id1" title="Limits on the number of queued realtime signals">Limits on the number of queued realtime signals</a>): it sends a signal with
                    accompanying data to another thread in the same process.</p><a id="I_programlisting33_d1e91458"/><pre class="programlisting">#define _GNU_SOURCE@
#include &lt;signal.h&gt;

int <strong class="userinput"><code>pthread_sigqueue</code></strong>(pthread_t <span class="emphasis"><em>thread</em></span>, int <span class="emphasis"><em>sig</em></span>, const union sigval <span class="emphasis"><em>value</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><p>As with <span class="emphasis"><em>pthread_kill()</em></span>, <span class="emphasis"><em>sig</em></span>
                    specifies the signal to be sent, and <span class="emphasis"><em>thread</em></span> identifies the
                    target thread. The <span class="emphasis"><em>value</em></span> argument specifies the data to
                    accompany the signal, and is used in the same way as the equivalent argument of
                        <span class="emphasis"><em>sigqueue()</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>pthread_sigqueue()</em></span> function was added to
                            <span class="emphasis"><em>glibc</em></span> in version 2.11 and requires support from the
                        kernel. This support is provided by the
                            <span class="emphasis"><em>rt_tgsigqueueinfo()</em></span> system call, which was added in
                        Linux 2.6.31.<a id="IDX-CHP-33-4847" class="indexterm"/><a id="IDX-CHP-33-4848" class="indexterm"/></p></div></div><div class="sect2" title="Dealing with Asynchronous Signals Sanely"><div class="titlepage"><div><div><h3 class="title" id="dealing_with_asynchronous_signals_sanely">Dealing with Asynchronous Signals Sanely</h3></div></div></div><p>In <a class="xref" href="ch20.html" title="Chapter 20. Signals: Fundamental Concepts">Chapter 20</a> to <a class="xref" href="ch22.html" title="Chapter 22. Signals: Advanced Features">Chapter 22</a>, we discussed various
                    factors—such as reentrancy issues, the need to restart interrupted system calls,
                    and avoiding race conditions—that can make it complex to deal with
                    asynchronously generated signals via signal handlers. Furthermore, none of the
                    functions in the Pthreads API is among the set of async-signal-safe functions
                    that we can safely call from within a signal handler (<a class="xref" href="ch21.html#reentrant_and_async-signal-safe_function" title="Reentrant and Async-Signal-Safe Functions">Reentrant and Async-Signal-Safe Functions</a>). For these reasons,
                    multithreaded programs that must deal with asynchronously generated signals
                    generally should not use a signal handler as the mechanism to receive
                    notification of signal delivery. Instead, the preferred approach is the
                        following:<a id="IDX-CHP-33-4849" class="indexterm"/><a id="IDX-CHP-33-4850" class="indexterm"/><a id="IDX-CHP-33-4851" class="indexterm"/><a id="IDX-CHP-33-4852" class="indexterm"/><a id="IDX-CHP-33-4853" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>All threads block all of the asynchronous signals that the process
                            might receive. The simplest way to do this is to block the signals in
                            the main thread before any other threads are created. Each subsequently
                            created thread will inherit a copy of the main thread’s signal
                            mask.</p></li><li class="listitem"><p>Create a single dedicated thread that accepts incoming signals using
                                <span class="emphasis"><em>sigwaitinfo()</em></span>,
                                <span class="emphasis"><em>sigtimedwait()</em></span>, or
                                <span class="emphasis"><em>sigwait()</em></span>. We described
                                <span class="emphasis"><em>sigwaitinfo()</em></span> and
                                <span class="emphasis"><em>sigtimedwait()</em></span> in <a class="xref" href="ch22.html#synchronously_waiting_for_a_signal" title="Synchronously Waiting for a Signal">Synchronously Waiting for a Signal</a>. We describe
                                <span class="emphasis"><em>sigwait()</em></span> below.<a id="IDX-CHP-33-4854" class="indexterm"/></p></li></ul></div><p>The advantage of this approach is that asynchronously generated signals are
                    received synchronously. As it accepts incoming signals, the dedicated thread can
                    safely modify shared variables (under mutex control) and call
                    non-async-signal-safe functions. It can also signal condition variables, and
                    employ other thread and process communication and synchronization
                    mechanisms.</p><p>The <span class="emphasis"><em>sigwait()</em></span> function waits for the delivery of one of
                    the signals in the signal set pointed to by <span class="emphasis"><em>set</em></span>, accepts
                    that signal, and returns it in <span class="emphasis"><em>sig</em></span>.</p><a id="I_programlisting33_d1e91598"/><pre class="programlisting">#include &lt;signal.h&gt;

int <strong class="userinput"><code>sigwait</code></strong>(const sigset_t *<span class="emphasis"><em>set</em></span>, int *<span class="emphasis"><em>sig</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or a positive error number on error</p></div><p>The operation of <span class="emphasis"><em>sigwait()</em></span> is the same as
                        <span class="emphasis"><em>sigwaitinfo()</em></span>, except that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>instead of returning a <span class="emphasis"><em>siginfo_t</em></span> structure
                            describing the signal, <span class="emphasis"><em>sigwait()</em></span> returns just the
                            signal number; and</p></li><li class="listitem"><p>the return value is consistent with other thread-related functions
                            (rather than the 0 or -1 returned by traditional UNIX system
                            calls).</p></li></ul></div><p>If multiple threads are waiting for the same signal with
                        <span class="emphasis"><em>sigwait()</em></span>, only one of the threads will actually accept
                    the signal when it arrives. Which of the threads this will be is
                    indeterminate.</p></div></div><div class="sect1" title="Threads and Process Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="threads_and_process_control">Threads and Process Control</h2></div></div></div><p>Like the signals mechanism, <span class="emphasis"><em>exec()</em></span>,
                    <span class="emphasis"><em>fork()</em></span>, and <span class="emphasis"><em>exit()</em></span> predate the
                Pthreads API. In the following paragraphs, we note some details concerning the use
                of these system calls in threaded programs.<a id="IDX-CHP-33-4855" class="indexterm"/><a id="IDX-CHP-33-4856" class="indexterm"/><a id="IDX-CHP-33-4857" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="threads_and_exec_open_parenthesis"/></div></div></div><div class="sect3" title="Threads and exec()"><div class="titlepage"><div><div><h4 class="title" id="threads_and_exec_open_parenthesis-id1">Threads and <span class="emphasis"><em>exec()</em></span></h4></div></div></div><p>When any thread calls one of the <span class="emphasis"><em>exec()</em></span> functions,
                        the calling program is completely replaced. All threads, except the one that
                        called <span class="emphasis"><em>exec()</em></span>, vanish immediately. None of the threads
                        executes destructors for thread-specific data or calls cleanup handlers. All
                        of the (process-private) mutexes and condition variables belonging to the
                        process also disappear. After an <span class="emphasis"><em>exec()</em></span>, the thread ID
                        of the remaining thread is unspecified.</p></div><div class="sect3" title="Threads and fork()"><div class="titlepage"><div><div><h4 class="title" id="threads_and_fork_open_parenthesis_close">Threads and <span class="emphasis"><em>fork()</em></span></h4></div></div></div><p>When a multithreaded process calls <span class="emphasis"><em>fork()</em></span>, only the
                        calling thread is replicated in the child process. (The ID of the thread in
                        the child is the same as the ID of the thread that called
                            <span class="emphasis"><em>fork()</em></span> in the parent.) All of the other threads
                        vanish in the child; no thread-specific data destructors or cleanup handlers
                        are executed for those threads. This can lead to various problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Although only the calling thread is replicated in the child, the
                                states of global variables, as well as all Pthreads objects such as
                                mutexes and condition variables, are preserved in the child. (This
                                is so because these Pthreads objects are allocated within the
                                parent’s memory, and the child gets a duplicate of that memory.)
                                This can lead to tricky scenarios. For example, suppose that another
                                thread had locked a mutex at the time of the
                                    <span class="emphasis"><em>fork()</em></span> and is part-way through updating a
                                global data structure. In this case, the thread in the child would
                                not be able to unlock the mutex (since it is not the mutex owner)
                                and would block if it tried to acquire the mutex. Furthermore, the
                                child’s copy of the global data structure is probably in an
                                inconsistent state, because the thread that was updating it vanished
                                part-way through the update.<a id="IDX-CHP-33-4858" class="indexterm"/></p></li><li class="listitem"><p>Since destructors for thread-specific data and cleanup handlers
                                are not called, a <span class="emphasis"><em>fork()</em></span> in a multithreaded
                                program can cause memory leaks in the child. Furthermore, the
                                thread-specific data items created by other threads are likely to be
                                inaccessible to the thread in the new child, since it doesn’t have
                                pointers referring to these items.</p></li></ul></div><p>Because of these problems, the usual recommendation is that the only use
                        of <span class="emphasis"><em>fork()</em></span> in a multithreaded process should be one that
                        is followed by an immediate <span class="emphasis"><em>exec()</em></span>. The
                            <span class="emphasis"><em>exec()</em></span> causes all of the Pthreads objects in the
                        child process to disappear as the new program overwrites the memory of the
                        process.</p><p>For programs that must use a <span class="emphasis"><em>fork()</em></span> that is not
                        followed by an <span class="emphasis"><em>exec()</em></span>, the Pthreads API provides a
                        mechanism for defining <span class="emphasis"><em>fork handlers</em></span>. Fork handlers are
                        established using a <span class="emphasis"><em>pthread_atfork()</em></span> call of the
                        following form:<a id="IDX-CHP-33-4859" class="indexterm"/></p><a id="I_programlisting33_d1e91751"/><pre class="programlisting">pthread_atfork(prepare_func, parent_func, child_func);</pre><p>Each <span class="emphasis"><em>pthread_atfork()</em></span> call adds
                            <span class="emphasis"><em>prepare_func</em></span> to a list of functions that will be
                        automatically executed (in reverse order of registration) before the new
                        child process is created when <span class="emphasis"><em>fork()</em></span> is called.
                        Similarly, <span class="emphasis"><em>parent_func</em></span> and
                            <span class="emphasis"><em>child_func</em></span> are added to a list functions that will
                        be called automatically (in order of registration), in, respectively, the
                        parent and child process, just before <span class="emphasis"><em>fork()</em></span>
                        returns.</p><p>Fork handlers are sometimes useful for library code that makes use of
                        threads. In the absence of fork handlers, there would be no way for the
                        library to deal with applications that naively make use of the library and
                        call <span class="emphasis"><em>fork()</em></span>, unaware that the library has created some
                        threads.</p><p>The child produced by <span class="emphasis"><em>fork()</em></span> inherits fork handlers
                        from the thread that called <span class="emphasis"><em>fork()</em></span>. During an
                            <span class="emphasis"><em>exec()</em></span>, fork handlers are not preserved (they can’t
                        be, since the code of the handlers is overwritten during the
                            <span class="emphasis"><em>exec()</em></span>).</p><p>Further details on fork handlers, and examples of their use, can be found
                        in [Butenhof, 1996].</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux, fork handlers are not called if a program using the NPTL
                            threading library calls <span class="emphasis"><em>vfork()</em></span>. However, in a
                            program using LinuxThreads, fork handlers are called in this
                                case.<a id="IDX-CHP-33-4860" class="indexterm"/></p></div></div><div class="sect3" title="Threads and exit()"><div class="titlepage"><div><div><h4 class="title" id="threads_and_exit_open_parenthesis_close">Threads and <span class="emphasis"><em>exit()</em></span></h4></div></div></div><p>If any thread calls <span class="emphasis"><em>exit()</em></span> or, equivalently, the main
                        thread does a <code class="literal">return</code>, all threads
                        immediately vanish; no thread-specific data destructors or cleanup handlers
                        are executed.<a id="IDX-CHP-33-4861" class="indexterm"/><a id="IDX-CHP-33-4862" class="indexterm"/><a id="IDX-CHP-33-4863" class="indexterm"/><a id="IDX-CHP-33-4864" class="indexterm"/><a id="IDX-CHP-33-4865" class="indexterm"/><a id="IDX-CHP-33-4866" class="indexterm"/><a id="IDX-CHP-33-4867" class="indexterm"/></p></div></div></div><div class="sect1" title="Thread Implementation Models"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="thread_implementation_models">Thread Implementation Models</h2></div></div></div><p>In this section, we go into some theory, briefly considering three different
                models for implementing a threading API. This provides useful background for <a class="xref" href="ch33.html#linux_implementations_of_posix_threads" title="Linux Implementations of POSIX Threads">Linux Implementations of POSIX Threads</a>, where we consider the Linux
                threading implementations. The differences between these implementation models hinge
                on how threads are mapped onto <span class="emphasis"><em>kernel scheduling entities</em></span>
                (KSEs), which are the units to which the kernel allocates the CPU and other system
                resources. (In traditional UNIX implementations that predate threads, the term
                    <span class="emphasis"><em>kernel scheduling entity</em></span> is synonymous with the term
                    <span class="emphasis"><em>process</em></span>.)<a id="IDX-CHP-33-4868" class="indexterm"/></p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="many-to-one_open_parenthesis_m_colon"/></div></div></div><div class="sect3" title="Many-to-one (M:1) implementations (user-level threads)"><div class="titlepage"><div><div><h4 class="title" id="many-to-one_open_parenthesis_m_colon-id1">Many-to-one (M:1) implementations (user-level threads)</h4></div></div></div><p>In M:1 threading implementations, all of the details of thread creation,
                        scheduling, and synchronization (mutex locking, waiting on condition
                        variables, and so on) are handled entirely within the process by a
                        user-space threading library. The kernel knows nothing about the existence
                        of multiple threads within the process.</p><p>M:1 implementations have a few advantages. The greatest advantage is that
                        many threading operations—for example, creating and terminating a thread,
                        context switching between threads, and mutex and condition variable
                        operations—are fast, since a switch to kernel mode is not required.
                        Furthermore, since kernel support for the threading library is not required,
                        an M:1 implementation can be relatively easily ported from one system to
                        another.</p><p>However, M:1 implementations suffer from some serious
                        disadvantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When a thread makes a system call such as
                                    <span class="emphasis"><em>read()</em></span>, control passes from the user-space
                                threading library to the kernel. This means that if the
                                    <span class="emphasis"><em>read()</em></span> call blocks, then all threads in the
                                process are blocked.</p></li><li class="listitem"><p>The kernel can’t schedule the threads of a process. Since the
                                kernel is unaware of the existence of multiple threads within the
                                process, it can’t schedule the separate threads to different
                                processors on multiprocessor hardware. Nor is it possible to
                                meaningfully assign a thread in one process a higher priority than a
                                thread in another process, since the scheduling of the threads is
                                handled entirely within the process.</p></li></ul></div></div><div class="sect3" title="One-to-one (1:1) implementations (kernel-level threads)"><div class="titlepage"><div><div><h4 class="title" id="one-to-one_open_parenthesis_1_colon_1_cl">One-to-one (1:1) implementations (kernel-level threads)</h4></div></div></div><p>In a 1:1 threading implementation, each thread maps onto a separate KSE.
                        The kernel handles each thread’s scheduling separately. Thread
                        synchronization operations are implemented using system calls into the
                            kernel.<a id="IDX-CHP-33-4869" class="indexterm"/></p><p>1:1 implementations eliminate the disadvantages suffered by M:1
                        implementations. A blocking system call does not cause all of the threads in
                        a process to block, and the kernel can schedule the threads of a process
                        onto different CPUs on multiprocessor hardware.</p><p>However, operations such as thread creation, context switching, and
                        synchronization are slower on a 1:1 implementations, since a switch into
                        kernel mode is required. Furthermore, the overhead required to maintain a
                        separate KSE for each of the threads in an application that contains a large
                        number of threads may place a significant load on the kernel scheduler,
                        degrading overall system performance.</p><p>Despite these disadvantages, a 1:1 implementation is usually preferred
                        over an M:1 implementation. Both of the Linux threading
                        implementations—LinuxThreads and NPTL—employ the 1:1 model.<a id="IDX-CHP-33-4870" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>During the development of NPTL, significant effort went into rewriting
                            the kernel scheduler and devising a threading implementation that would
                            allow the efficient execution of multithreaded processes containing many
                            thousands of threads. Subsequent testing showed that this goal was
                            achieved.</p></div></div><div class="sect3" title="Many-to-many (M:N) implementations (two-level model)"><div class="titlepage"><div><div><h4 class="title" id="many-to-many_open_parenthesis_m_colon_n">Many-to-many (M:N) implementations (two-level model)</h4></div></div></div><p>M:N implementations aim to combine the advantages of the 1:1 and M:1
                        models, while eliminating their disadvantages.</p><p>In the M:N model, each process can have multiple associated KSEs, and
                        several threads may map to each KSE. This design permits the kernel to
                        distribute the threads of an application across multiple CPUs, while
                        eliminating the possible scaling problems associated with applications that
                        employ large numbers of threads.</p><p>The most significant disadvantage of the M:N model is complexity. The task
                        of thread scheduling is shared between the kernel and the user-space
                        threading library, which must cooperate and communicate information with one
                        another. Managing signals according to the requirements of SUSv3 is also
                        complex under an M:N implementation.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>An M:N implementation was initially considered for the NPTL threading
                            implementation, but rejected as requiring changes to the kernel that
                            were too wide ranging and perhaps unnecessary, given the ability of the
                            Linux scheduler to scale well, even when dealing with large numbers of
                            KSEs.</p></div></div></div></div><div class="sect1" title="Linux Implementations of POSIX Threads"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="linux_implementations_of_posix_threads">Linux Implementations of POSIX Threads</h2></div></div></div><p>Linux has two main implementations of the Pthreads API:<a id="IDX-CHP-33-4871" class="indexterm"/><a id="IDX-CHP-33-4872" class="indexterm"/><a id="IDX-CHP-33-4873" class="indexterm"/><a id="IDX-CHP-33-4874" class="indexterm"/><a id="IDX-CHP-33-4875" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>LinuxThreads</em></span>: This is the original Linux threading
                        implementation, developed by Xavier Leroy.<a id="IDX-CHP-33-4876" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>NPTL (Native POSIX Threads Library)</em></span>: This is the
                        modern Linux threading implementation, developed by Ulrich Drepper and Ingo
                        Molnar as a successor to LinuxThreads. NPTL provides performance that is
                        superior to LinuxThreads, and it adheres more closely to the SUSv3
                        specification for Pthreads. Support for NPTL required changes to the kernel,
                        and these changes appeared in Linux 2.6.<a id="IDX-CHP-33-4877" class="indexterm"/></p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>For a while, it appeared that the successor to LinuxThreads would be another
                    implementation, called Next Generation POSIX Threads (NGPT), a threading
                    implementation developed at IBM. NGPT employed an M:N design and performed
                    significantly better than LinuxThreads. However, the NPTL developers decided to
                    pursue a new implementation. This approach was justified—the 1:1-design NPTL was
                    shown to perform better than NGPT. Following the release of NPTL, development of
                    NGPT was discontinued.<a id="IDX-CHP-33-4878" class="indexterm"/></p></div><p>In the following sections, we consider further details of these two
                implementations, and note the points where they deviate from the SUSv3 requirements
                for Pthreads.</p><p>At this point, it is worth emphasizing that the LinuxThreads implementation is now
                obsolete; it is not supported in <span class="emphasis"><em>glibc</em></span> 2.4 and later. All new
                thread library development occurs only in NPTL.</p><div class="sect2" title="LinuxThreads"><div class="titlepage"><div><div><h3 class="title" id="linuxthreads">LinuxThreads</h3></div></div></div><p>For many years, LinuxThreads was the main threading implementation on Linux,
                    and it was sufficient for implementing a variety of threaded applications. The
                    essentials of the LinuxThreads implementation are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Threads are created using a <span class="emphasis"><em>clone()</em></span> call that
                            specifies the following flags:</p><a id="I_programlisting33_d1e91987"/><pre class="programlisting">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</pre><p>This means that LinuxThreads threads share virtual memory, file
                            descriptors, file system-related information (umask, root directory, and
                            current working directory), and signal dispositions. However, threads
                            don’t share process IDs and parent process IDs.</p></li><li class="listitem"><p>In addition to the threads created by the application, LinuxThreads
                            creates an additional “manager” thread that handles thread creation and
                            termination.</p></li><li class="listitem"><p>The implementation uses signals for its internal operation. With
                            kernels that support realtime signals (Linux 2.2 and later), the first
                            three realtime signals are used. With older kernels, <code class="literal">SIGUSR1</code> and <code class="literal">SIGUSR2</code> are used. Applications can’t use these signals.
                            (The use of signals results in high latency for various thread
                            synchronization operations.)</p></li></ul></div><div class="sect3" title="LinuxThreads deviations from specified behavior"><div class="titlepage"><div><div><h4 class="title" id="linuxthreads_deviations_from_specified_b">LinuxThreads deviations from specified behavior</h4></div></div></div><p>LinuxThreads doesn’t conform to the SUSv3 specification for Pthreads on a
                        number of points. (The LinuxThreads implementation was constrained by the
                        kernel features available at the time that it was developed; it was as
                        conformant as practicable within those constraints.) The following list
                        summarizes the nonconformances:<a id="IDX-CHP-33-4879" class="indexterm"/><a id="IDX-CHP-33-4880" class="indexterm"/><a id="IDX-CHP-33-4881" class="indexterm"/><a id="IDX-CHP-33-4882" class="indexterm"/><a id="IDX-CHP-33-4883" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Calls to <span class="emphasis"><em>getpid()</em></span> return a different value in
                                each of the threads of a process. Calls to
                                    <span class="emphasis"><em>getppid()</em></span> reflect the fact that every
                                thread other than the main thread is created by the process’s
                                manager thread (i.e., <span class="emphasis"><em>getppid()</em></span> returns the
                                process ID of the manager thread). Calls to
                                    <span class="emphasis"><em>getppid()</em></span> in the other threads should
                                return the same value as a call to <span class="emphasis"><em>getppid()</em></span> in
                                the main thread.<a id="IDX-CHP-33-4884" class="indexterm"/><a id="IDX-CHP-33-4885" class="indexterm"/></p></li><li class="listitem"><p>If one thread creates a child using <span class="emphasis"><em>fork()</em></span>,
                                then any other thread should be able to obtain the termination
                                status of that child using <span class="emphasis"><em>wait()</em></span> (or similar).
                                However, this is not so; only the thread that created the child
                                process can <span class="emphasis"><em>wait()</em></span> for it.<a id="IDX-CHP-33-4886" class="indexterm"/><a id="IDX-CHP-33-4887" class="indexterm"/></p></li><li class="listitem"><p>If a thread calls <span class="emphasis"><em>exec()</em></span>, then, as required
                                by SUSv3, all other threads are terminated. However, if the
                                    <span class="emphasis"><em>exec()</em></span> is done from any thread other than
                                the main thread, then the resulting process will have the same
                                process ID as the calling thread—that is, a process ID that is
                                different from the main thread’s process ID. According to SUSv3, the
                                process ID should be the same as that of the main thread.<a id="IDX-CHP-33-4888" class="indexterm"/></p></li><li class="listitem"><p>Threads don’t share credentials (user and group IDs). When a
                                multithreaded process is executing a set-user-ID program, this can
                                lead to scenarios in which one thread can’t send a signal to another
                                thread using <span class="emphasis"><em>pthread_kill()</em></span>, because the
                                credentials of the two threads have been changed in such a way that
                                the sending thread no longer has permission to signal the target
                                thread (refer to <a class="xref" href="ch20.html#permissions_required_for_an_unprivileged" title="Figure 20-2. Permissions required for an unprivileged process to send a signal">Figure 20-2</a>, in <a class="xref" href="ch20.html#checking_for_the_existence_of_a_process" title="Checking for the Existence of a Process">Checking for the Existence of a Process</a>).
                                Furthermore, since the LinuxThreads implementation uses signals
                                internally, various Pthreads operations can fail or hang if a thread
                                changes its credentials.<a id="IDX-CHP-33-4889" class="indexterm"/><a id="IDX-CHP-33-4890" class="indexterm"/></p></li><li class="listitem"><p>Various aspects of the SUSv3 specification for the interaction
                                between threads and signals are not honored:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A signal that is sent to a process using
                                            <span class="emphasis"><em>kill()</em></span> or
                                            <span class="emphasis"><em>sigqueue()</em></span> should be delivered to,
                                        and handled by, an arbitrary thread in the target process
                                        that is not blocking the signal. However, since LinuxThreads
                                        threads have different process IDs, a signal can be targeted
                                        only at a specific thread. If that thread is blocking the
                                        signal, it remains pending, even if there are other threads
                                        that are not blocking the signal.</p></li><li class="listitem"><p>LinuxThreads doesn’t support the notion of signals that
                                        are pending for a process as whole; only per-thread pending
                                        signals are supported.</p></li><li class="listitem"><p>If a signal is directed at a process group that contains a
                                        multithreaded application, then the signal will be handled
                                        by all threads in the application (i.e., all threads that
                                        have established a signal handler), rather than by a single
                                        (arbitrary) thread. Such a signal may, for example, be
                                        generated by typing one of the terminal characters that
                                        generates a job-control signal for the foreground process
                                        group.</p></li><li class="listitem"><p>The alternate signal stack settings (established by
                                            <span class="emphasis"><em>sigaltstack()</em></span>) are per-thread.
                                        However, because a new thread wrongly inherits its alternate
                                        signal stack settings from the caller of
                                            <span class="emphasis"><em>pthread_create()</em></span>, the two threads
                                        share an alternate signal stack. SUSv3 requires that a new
                                        thread should start with no alternate signal stack defined.
                                        The consequence of this LinuxThreads nonconformance is that
                                        if two threads happen to simultaneously handle different
                                        signals on their shared alternate signal stacks at the same
                                        time, chaos is likely to result (e.g., a program crash).
                                        This problem may be very hard to reproduce and debug, since
                                        its occurrence depends on the probably rare event that the
                                        two signals are handled at the same time.<a id="IDX-CHP-33-4891" class="indexterm"/><a id="IDX-CHP-33-4892" class="indexterm"/><a id="IDX-CHP-33-4893" class="indexterm"/><a id="IDX-CHP-33-4894" class="indexterm"/><a id="IDX-CHP-33-4895" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In a program using LinuxThreads, a new thread could
                                            make a call to <span class="emphasis"><em>sigaltstack()</em></span> to
                                            ensure that it uses a different alternate signal stack
                                            from the thread that created it (or no stack at all).
                                            However, portable programs (and library functions that
                                            create threads) won’t know to do this, since it is not a
                                            requirement on other implementations. Furthermore, even
                                            if we employ this technique, there is still a possible
                                            race condition: the new thread could receive and handle
                                            a signal on the alternate stack before it has a chance
                                            to call <span class="emphasis"><em>sigaltstack()</em></span>.</p></div></li></ul></div></li><li class="listitem"><p>Threads don’t share a common session ID and process group ID. The
                                    <span class="emphasis"><em>setsid()</em></span> and <span class="emphasis"><em>setpgid()</em></span>
                                system calls can’t be used to change the session or process group
                                membership of a multithreaded process.<a id="IDX-CHP-33-4896" class="indexterm"/><a id="IDX-CHP-33-4897" class="indexterm"/></p></li><li class="listitem"><p>Record locks established using <span class="emphasis"><em>fcntl()</em></span> are
                                not shared. Overlapping lock requests of the same type are not
                                merged.</p></li><li class="listitem"><p>Threads don’t share resource limits. SUSv3 specifies that resource
                                limits are process-wide attributes.</p></li><li class="listitem"><p>The CPU time returned by <span class="emphasis"><em>times()</em></span> and the
                                resource usage information returned by
                                    <span class="emphasis"><em>getrusage()</em></span> are per-thread. These system
                                calls should return process-wide totals.<a id="IDX-CHP-33-4898" class="indexterm"/><a id="IDX-CHP-33-4899" class="indexterm"/></p></li><li class="listitem"><p>Some versions of <span class="emphasis"><em>ps(1)</em></span> show all of the
                                threads in a process (including the manager thread) as separate
                                items with distinct process IDs.</p></li><li class="listitem"><p>Threads don’t share nice value set by
                                    <span class="emphasis"><em>setpriority()</em></span>.<a id="IDX-CHP-33-4900" class="indexterm"/></p></li><li class="listitem"><p>Interval timers created using <span class="emphasis"><em>setitimer()</em></span> are
                                not shared between the threads.<a id="IDX-CHP-33-4901" class="indexterm"/></p></li><li class="listitem"><p>Threads don’t share System V semaphore undo
                                    (<span class="emphasis"><em>semadj</em></span>) values.</p></li></ul></div></div><div class="sect3" title="Other problems with LinuxThreads"><div class="titlepage"><div><div><h4 class="title" id="other_problems_with_linuxthreads">Other problems with LinuxThreads</h4></div></div></div><p>In addition to the above deviations from SUSv3, the LinuxThreads
                        implementation has the following problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the manager thread is killed, then the remaining threads must
                                be manually cleaned up.</p></li><li class="listitem"><p>A core dump of a multithreaded program may not include all of the
                                threads of the process (or even the one that triggered the core
                                dump).</p></li><li class="listitem"><p>The nonstandard <span class="emphasis"><em>ioctl()</em></span>
                                <code class="literal">TIOCNOTTY</code> operation can remove
                                the process’s association with a controlling terminal only when
                                called from the main thread.</p></li></ul></div></div></div><div class="sect2" title="NPTL"><div class="titlepage"><div><div><h3 class="title" id="nptl">NPTL</h3></div></div></div><p>NPTL was designed to address most of the shortcomings of LinuxThreads. In
                        particular:<a id="IDX-CHP-33-4902" class="indexterm"/><a id="IDX-CHP-33-4903" class="indexterm"/><a id="IDX-CHP-33-4904" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>NPTL provides much closer conformance to the SUSv3 specification for
                            Pthreads.</p></li><li class="listitem"><p>Applications that employ large numbers of threads scale much better
                            under NPTL than under LinuxThreads.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>NPTL allows an application to create large numbers of threads. The
                                NPTL implementers were able to run test programs that created
                                100,000 threads. With LinuxThreads, the practical limit on the
                                number of threads is a few thousand. (Admittedly, very few
                                applications need such large numbers of threads.)</p></div></li></ul></div><p>Work on implementing NPTL began in 2002 and progressed over the next year or
                    so. In parallel, various changes were made within the Linux kernel to
                    accommodate the requirements of NPTL. The changes that appeared in the Linux 2.6
                    kernel to support NPTL included the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>refinements to the implementation of thread groups (<a class="xref" href="ch28.html#example_program-id39" title="Example program">Example program</a>);</p></li><li class="listitem"><p>the addition of futexes as a synchronization mechanism (futexes are a
                            generic mechanism that was designed not just for NPTL);</p></li><li class="listitem"><p>the addition of new system calls
                                (<span class="emphasis"><em>get_thread_area()</em></span> and
                                <span class="emphasis"><em>set_thread_area()</em></span>) to support thread-local
                                storage;<a id="IDX-CHP-33-4905" class="indexterm"/><a id="IDX-CHP-33-4906" class="indexterm"/></p></li><li class="listitem"><p>support for threaded core dumps and debugging of multithreaded
                            processes;</p></li><li class="listitem"><p>modifications to support management of signals in a manner consistent
                            with the Pthreads model;</p></li><li class="listitem"><p>the addition of a new <span class="emphasis"><em>exit_group()</em></span> system call to
                            terminate all of the threads in a process (starting with
                                <span class="emphasis"><em>glibc</em></span> 2.3, <span class="emphasis"><em>_exit()</em></span>—and
                            thus also the <span class="emphasis"><em>exit()</em></span> library function—is aliased as
                            a wrapper that invokes <span class="emphasis"><em>exit_group()</em></span>, while a call
                            to <span class="emphasis"><em>pthread_exit()</em></span> invokes the true
                                <span class="emphasis"><em>_exit()</em></span> system call in the kernel, which
                            terminates just the calling thread);<a id="IDX-CHP-33-4907" class="indexterm"/><a id="IDX-CHP-33-4908" class="indexterm"/><a id="IDX-CHP-33-4909" class="indexterm"/></p></li><li class="listitem"><p>a rewrite of the kernel scheduler to allow efficient scheduling of
                            very large numbers (i.e., thousands) of KSEs;</p></li><li class="listitem"><p>improved performance for the kernel’s process termination code;
                            and</p></li><li class="listitem"><p>extensions to the <span class="emphasis"><em>clone()</em></span> system call (<a class="xref" href="ch28.html#the_clone_open_parenthesis_close_parenth" title="The clone() System Call">The <span class="emphasis"><em>clone()</em></span> System Call</a>).</p></li></ul></div><p>The essentials of the NPTL implementation are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Threads are created using a <span class="emphasis"><em>clone()</em></span> call that
                            specifies the following flags:</p><a id="I_programlisting33_d1e92391"/><pre class="programlisting">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND |
CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID |
CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</pre><p>NPTL threads share all of the information that LinuxThreads threads
                            share, and more. The <code class="literal">CLONE_THREAD</code>
                            flag means that a thread is placed in the same thread group as its
                            creator and shares the same process ID and parent process ID. The
                                <code class="literal">CLONE_SYSVSEM</code> flag means that a
                            thread shares System V semaphore undo values with its creator.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>When we use <span class="emphasis"><em>ps(1)</em></span> to list a multithreaded
                                process running under NPTL, we see just a single line of output. To
                                see information about the threads within a process, we can use the
                                    <span class="emphasis"><em>ps -L</em></span> option.</p></div></li><li class="listitem"><p>The implementation makes internal use of the first two realtime
                            signals. Applications can’t use these signals.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>One of these signals is used to implement thread cancellation. The
                                other signal is used as part of a technique that ensures that all of
                                the threads in a process have the same user and group IDs. This
                                technique is required because, at the kernel level, threads have
                                distinct user and group credentials. Therefore, the NPTL
                                implementation does some work in the wrapper function for each
                                system call that changes user and group IDs
                                    (<span class="emphasis"><em>setuid()</em></span>,
                                <span class="emphasis"><em>setresuid()</em></span>, and so on, and their group
                                analogs) that causes the IDs to be changed in all of the threads of
                                the process.</p></div></li><li class="listitem"><p>Unlike LinuxThreads, NPTL doesn’t use manager threads.</p></li></ul></div><div class="sect3" title="NPTL standards conformance"><div class="titlepage"><div><div><h4 class="title" id="nptl_standards_conformance">NPTL standards conformance</h4></div></div></div><p>These changes mean that NPTL achieves much closer SUSv3 conformance than
                        LinuxThreads. At the time of writing, the following nonconformance
                            remains:<a id="IDX-CHP-33-4910" class="indexterm"/><a id="IDX-CHP-33-4911" class="indexterm"/><a id="IDX-CHP-33-4912" class="indexterm"/><a id="IDX-CHP-33-4913" class="indexterm"/><a id="IDX-CHP-33-4914" class="indexterm"/><a id="IDX-CHP-33-4915" class="indexterm"/><a id="IDX-CHP-33-4916" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Threads don’t share a nice value.</p></li></ul></div><p>There are some additional NPTL nonconformances in earlier
                            2.6.<span class="emphasis"><em>x</em></span> kernels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In kernels before 2.6.16, the alternate signal stack was
                                per-thread, but a new thread wrongly inherited alternate signal
                                stack settings (established by <span class="emphasis"><em>sigaltstack()</em></span>)
                                from the caller of <span class="emphasis"><em>pthread_create()</em></span>, with the
                                consequence that the two threads shared an alternate signal
                                    stack.<a id="IDX-CHP-33-4917" class="indexterm"/><a id="IDX-CHP-33-4918" class="indexterm"/></p></li><li class="listitem"><p>In kernels before 2.6.16, only a thread group leader (i.e., the
                                main thread) could start a new session by calling
                                    <span class="emphasis"><em>setsid()</em></span>.<a id="IDX-CHP-33-4919" class="indexterm"/></p></li><li class="listitem"><p>In kernels before 2.6.16, only a thread group leader could use
                                    <span class="emphasis"><em>setpgid()</em></span> to make the host process a
                                process group leader.<a id="IDX-CHP-33-4920" class="indexterm"/></p></li><li class="listitem"><p>In kernels prior to 2.6.12, interval timers created using
                                    <span class="emphasis"><em>setitimer()</em></span> were not shared between the
                                threads of a process.<a id="IDX-CHP-33-4921" class="indexterm"/></p></li><li class="listitem"><p>In kernels prior to 2.6.10, resource limit settings were not
                                shared between the threads of a process.</p></li><li class="listitem"><p>In kernels prior to 2.6.9, the CPU time returned by
                                    <span class="emphasis"><em>times()</em></span> and the resource usage information
                                returned by <span class="emphasis"><em>getrusage()</em></span> were
                                    per-thread.<a id="IDX-CHP-33-4922" class="indexterm"/><a id="IDX-CHP-33-4923" class="indexterm"/></p></li></ul></div><p>NPTL was designed to be ABI-compatible with LinuxThreads. This means that
                        programs that were linked against a GNU C library providing LinuxThreads
                        don’t need to be relinked in order to use NPTL. However, some behaviors may
                        change when the program is run with NPTL, primarily because NPTL adheres
                        more closely to the SUSv3 specification for Pthreads.</p></div></div><div class="sect2" title="Which Threading Implementation?"><div class="titlepage"><div><div><h3 class="title" id="which_threading_implementation_question">Which Threading Implementation?</h3></div></div></div><p>Some Linux distributions ship with a GNU C library that provides both
                    LinuxThreads and NPTL, with the default being determined by the dynamic linker
                    according to the underlying kernel on which the system is running. (These
                    distributions are by now historical because, since version 2.4,
                        <span class="emphasis"><em>glibc</em></span> no longer provides LinuxThreads.) Therefore, we
                    may sometimes need to answer the following questions:<a id="IDX-CHP-33-4924" class="indexterm"/><a id="IDX-CHP-33-4925" class="indexterm"/><a id="IDX-CHP-33-4926" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Which threading implementation is available in a particular Linux
                            distribution?</p></li><li class="listitem"><p>On a Linux distribution that provides both LinuxThreads and NPTL,
                            which implementation is used by default, and how can we explicitly
                            select the implementation that is used by a program?</p></li></ul></div><div class="sect3" title="Discovering the threading implementation"><div class="titlepage"><div><div><h4 class="title" id="discovering_the_threading_implementation">Discovering the threading implementation</h4></div></div></div><p>We can use a few techniques to discover the threading implementation that
                        is available on a particular system, or to discover the default
                        implementation that will be employed when a program is run on a system that
                        provides both threading implementations.</p><p>On a system providing <span class="emphasis"><em>glibc</em></span> version 2.3.2 or later,
                        we can use the following command to discover which threading implementation
                        the system provides, or, if it provides both implementation, then which one
                        is used by default:</p><a id="I_programlisting33_d1e92584"/><pre class="programlisting">$ <strong class="userinput"><code>getconf GNU_LIBPTHREAD_VERSION</code></strong></pre><p>On a system where NPTL is the only or the default implementation, this
                        will display a string such as the following:</p><a id="I_programlisting33_d1e92590"/><pre class="programlisting">NPTL 2.3.4</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Since <span class="emphasis"><em>glibc</em></span> 2.3.2, a program can obtain similar
                            information by using <span class="emphasis"><em>confstr(3)</em></span> to retrieve the
                            value of the <span class="emphasis"><em>glibc</em></span>-specific <code class="literal">_CS_GNU_LIBPTHREAD_VERSION</code> configuration
                            variable.</p></div><p>On systems with older GNU C libraries, we must do a little more work.
                        First, the following command can be used to show the pathname of the GNU C
                        library that is used when we run a program (here, we use the example of the
                        standard <span class="emphasis"><em>ls</em></span> program, which resides at <code class="literal">/bin/ls</code>):</p><a id="I_programlisting33_d1e92615"/><pre class="programlisting">$ <strong class="userinput"><code>ldd /bin/ls | grep libc.so</code></strong>
        libc.so.6 =&gt; /lib/tls/libc.so.6 (0x40050000)</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>We say a little more about the <span class="emphasis"><em>ldd</em></span> (list dynamic
                            dependencies) program in Section 41.5.</p></div><p>The pathname of the GNU C library is shown after the <code class="literal">=&gt;</code>. If we execute this pathname as a
                        command, then <span class="emphasis"><em>glibc</em></span> displays a range of information
                        about itself. We can <span class="emphasis"><em>grep</em></span> though this information to
                        select the line that displays the threading implementation:</p><a id="I_programlisting33_d1e92638"/><pre class="programlisting">$ <strong class="userinput"><code>/lib/tls/libc.so.6 | egrep -i 'threads|nptl'</code></strong>
        Native POSIX Threads Library by Ulrich Drepper et al</pre><p>We include <span class="emphasis"><em>nptl</em></span> in the <span class="emphasis"><em>egrep</em></span>
                        regular expression because some <span class="emphasis"><em>glibc</em></span> releases
                        containing NPTL instead display a string like this:</p><a id="I_programlisting33_d1e92654"/><pre class="programlisting">NPTL 0.61 by Ulrich Drepper</pre><p>Since the <span class="emphasis"><em>glibc</em></span> pathname may vary from one Linux
                        distribution to another, we can employ shell command substitution to produce
                        a command line that will display the threading implementation in use on any
                        Linux system, as follows:</p><a id="I_programlisting33_d1e92661"/><pre class="programlisting">$ <strong class="userinput"><code>$(ldd /bin/ls | grep libc.so | awk '{print $3}') | egrep -i 'threads|nptl'</code></strong>
        Native POSIX Threads Library by Ulrich Drepper et al</pre></div><div class="sect3" title="Selecting the threading implementation used by a program"><div class="titlepage"><div><div><h4 class="title" id="selecting_the_threading_implementation_u">Selecting the threading implementation used by a program</h4></div></div></div><p>On a Linux system that provides both NPTL and LinuxThreads, it is
                        sometimes useful to be able to explicitly control which threading
                        implementation is used. The most common example of this requirement is when
                        we have an older program that depends on some (probably nonstandard)
                        behavior of LinuxThreads, so that we want to force the program to run with
                        that threading implementation, instead of the default NPTL.<a id="IDX-CHP-33-4927" class="indexterm"/><a id="IDX-CHP-33-4928" class="indexterm"/></p><p>For this purpose, we can employ a special environment variable understood
                        by the dynamic linker: <code class="literal">LD_ASSUME_KERNEL</code>.
                        As its name suggests, this environment variable tells the dynamic linker to
                        operate as though it is running on top of a particular Linux kernel version.
                        By specifying a kernel version that doesn’t provide support for NPTL (e.g.,
                            <code class="literal">2.2.5</code>), we can ensure that
                        LinuxThreads is used. Thus, we could run a multithreaded program with
                        LinuxThreads using the following command:</p><a id="I_programlisting33_d1e92687"/><pre class="programlisting">$ <strong class="userinput"><code>LD_ASSUME_KERNEL=2.2.5 ./prog</code></strong></pre><p>When we combine this environment variable setting with the command that we
                        described earlier to show the threading implementation that is used, we see
                        something like the following:</p><a id="I_programlisting33_d1e92693"/><pre class="programlisting">$ <strong class="userinput"><code>export LD_ASSUME_KERNEL=2.2.5</code></strong>
$ <strong class="userinput"><code>$(ldd /bin/ls | grep libc.so | awk '{print $3}') | egrep -i 'threads|nptl'</code></strong>
        linuxthreads-0.10 by Xavier Leroy</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>The range of kernel version numbers that can be specified in <code class="literal">LD_ASSUME_KERNEL</code> is subject to some
                            limits. In several common distributions that supply both NPTL and
                            LinuxThreads, specifying the version number as 2.2.5 is sufficient to
                            ensure the use of LinuxThreads. For a fuller description of the use of
                            this environment variable, see <a class="ulink" href="http://people.redhat.com/drepper/assumekernel.html" target="_top">http://people.redhat.com/drepper/assumekernel.html</a>.</p></div></div></div></div><div class="sect1" title="Advanced Features of the Pthreads API"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="advanced_features_of_the_pthreads_api">Advanced Features of the Pthreads API</h2></div></div></div><p>Some advanced features of the Pthreads API include the following:<a id="IDX-CHP-33-4929" class="indexterm"/><a id="IDX-CHP-33-4930" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Realtime scheduling</em></span>: We can set realtime scheduling
                        policies and priorities for threads. This is similar to the process realtime
                        scheduling system calls described in Section 35.3.</p></li><li class="listitem"><p><span class="emphasis"><em>Process shared mutexes and condition variables</em></span>: SUSv3
                        specifies an option to allow mutexes and condition variables to be shared
                        between processes (rather than just among the threads of a single process).
                        In this case, the condition variable or mutex must be located in a region of
                        memory shared between the processes. NPTL supports this feature.</p></li><li class="listitem"><p><span class="emphasis"><em>Advanced thread-synchronization primitives</em></span>: These
                        facilities include barriers, read-write locks, and spin locks.</p></li></ul></div><p>Further details on all of these features can be found in [Butenhof, 1996].</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id32">Summary</h2></div></div></div><p>Threads don’t mix well with signals; multithreaded application designs should
                avoid the use of signals whenever possible. If a multithreaded application must deal
                with asynchronous signals, usually the cleanest way to do so is to block signals in
                all threads, and have a single dedicated thread that accepts incoming signals using
                    <span class="emphasis"><em>sigwait()</em></span> (or similar). This thread can then safely perform
                tasks such as modifying shared variables (under mutex control) and calling
                non-async-signal-safe functions.</p><p>Two threading implementations are commonly available on Linux: LinuxThreads and
                NPTL. LinuxThreads has been available on Linux for many years, but there are a
                number of points where it doesn’t conform to the requirements of SUSv3 and it is now
                obsolete. The more recent NPTL implementation provides closer SUSv3 conformance and
                superior performance, and is the implementation provided in modern Linux
                distributions.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id43"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id44">Further information</h4></div></div></div><p>Refer to the sources of further information listed in <a class="xref" href="ch29.html#summary-id28" title="Summary">Summary</a>.</p><p>The author of LinuxThreads documented the implementation in a web page
                        that can be found at <a class="ulink" href="http://pauillac.inria.fr/~xleroy/linuxthreads/" target="_top">http://pauillac.inria.fr/~xleroy/linuxthreads/</a>. The NPTL
                        implementation is described by its implementers in a (now somewhat
                        out-of-date) paper that is available online at <a class="ulink" href="http://people.redhat.com/drepper/nptl-design.pdf" target="_top">http://people.redhat.com/drepper/nptl-design.pdf</a>.</p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercises-id21">Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Write a program to demonstrate that different threads in the same process
                        can have different sets of pending signals, as returned by
                            <span class="emphasis"><em>sigpending()</em></span>. You can do this by using
                            <span class="emphasis"><em>pthread_kill()</em></span> to send different signals to two
                        different threads that have blocked these signals, and then have each of the
                        threads call <span class="emphasis"><em>sigpending()</em></span> and display information about
                        pending signals. (You may find the functions in <a class="xref" href="ch20.html#functions_for_displaying_signal_sets" title="Example 20-4. Functions for displaying signal sets">Example 20-4</a> useful.)</p></li><li class="listitem"><p>Suppose that a thread creates a child using <span class="emphasis"><em>fork()</em></span>.
                        When the child terminates, is it guaranteed that the resulting <code class="literal">SIGCHLD</code> signal will be delivered to the thread
                        that called <span class="emphasis"><em>fork()</em></span> (as opposed to some other thread in
                        the process)?<a id="IDX-CHP-33-4931" class="indexterm"/></p></li></ol></div></div></section></body></html>
