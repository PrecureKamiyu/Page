<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>The Multi-Level Index</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part439.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part441.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 68pt;text-indent: 0pt;text-align: justify;">The Multi-Level Index</p><p style="padding-top: 4pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">To support bigger files, file system designers have had to introduce dif- ferent structures within inodes. One common idea is to have a special pointer known as an <b>indirect pointer</b>. Instead of pointing to a block that contains user data, it points to a block that contains more pointers, each of which point to user data. Thus, an inode may have some fixed number of direct pointers (e.g., 12), and a single indirect pointer. If a file grows large enough, an indirect block is allocated (from the data-block region of the disk), and the inode’s slot for an indirect pointer is set to point to it. Assuming that a block is 4KB and 4-byte disk addresses, that adds another 1024 pointers; the file can grow to be <span class="s44">(12 + 1024) </span><span class="s4">· </span><span class="s44">4</span><span class="s43">K </span>or 4144KB.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 62pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: C<span class="s7">ONSIDER </span>E<span class="s7">XTENT</span>-<span class="s7">BASED </span>A<span class="s7">PPROACHES</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">A different approach is to use <b>extents </b>instead of pointers. An extent is simply a disk pointer plus a length (in blocks); thus, instead of requiring a pointer for every block of a file, all one needs is a pointer and a length to specify the on-disk location of a file. Just a single extent is limiting, as one may have trouble finding a contiguous chunk of on-disk free space when allocating a file. Thus, extent-based file systems often allow for more than one extent, thus giving more freedom to the file system during file allocation.</p><p style="padding-top: 3pt;padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In comparing the two approaches, pointer-based approaches are the most flexible but use a large amount of metadata per file (particularly for large files). Extent-based approaches are less flexible but more compact; in par- ticular, they work well when there is enough free space on the disk and files can be laid out contiguously (which is the goal for virtually any file allocation policy anyhow).</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Not surprisingly, in such an approach, you might want to support even larger files. To do so, just add another pointer to the inode: the <b>dou- ble indirect pointer</b>. This pointer refers to a block that contains pointers to indirect blocks, each of which contain pointers to data blocks. A dou- ble indirect block thus adds the possibility to grow files with an additional <span class="s44">1024 </span><span class="s4">· </span><span class="s44">1024 </span>or 1-million 4KB blocks, in other words supporting files that are over 4GB in size. You may want even more, though, and we bet you know where this is headed: the <b>triple indirect pointer</b>.</p><p class="s44" style="padding-left: 41pt;text-indent: 11pt;line-height: 91%;text-align: justify;"><span class="p">Overall, this imbalanced tree is referred to as the </span><span class="s27">multi-level index </span><span class="p">ap- proach to pointing to file blocks. Let’s examine an example with twelve direct pointers, as well as both a single and a double indirect block. As- suming a block size of 4 KB, and 4-byte pointers, this structure can accom- modate a file of just over 4 GB in size (i.e., </span>(12 + 1024 + 1024<span class="s101">2</span>) <span class="s4">× </span>4 <span class="s43">KB</span><span class="p">). Can you figure out how big of a file can be handled with the addition of a triple-indirect block? (hint: pretty big)</span></p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Many file systems use a multi-level index, including commonly-used file systems such as Linux ext2 [P09] and ext3, NetApp’s WAFL, as well as the original U<span class="s7">NIX </span>file system. Other file systems, including SGI XFS and Linux ext4, use <b>extents </b>instead of simple pointers; see the earlier aside for details on how extent-based schemes work (they are akin to segments in the discussion of virtual memory).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">You might be wondering: why use an imbalanced tree like this? Why not a different approach? Well, as it turns out, many researchers have studied file systems and how they are used, and virtually every time they find certain “truths” that hold across the decades. One such finding is that <i>most files are small</i>. This imbalanced design reflects such a reality; if most files are indeed small, it makes sense to optimize for this case. Thus, with a small number of direct pointers (12 is a typical number), an inode</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="408" height="387" alt="image" src="Image_590.png"/></span></p><p class="s27" style="padding-left: 54pt;text-indent: 0pt;line-height: 11pt;text-align: center;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>L<span class="s45">INKED</span>-<span class="s45">BASED </span>A<span class="s45">PPROACHES</span></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Another simpler approach in designing inodes is to use a <b>linked list</b>. Thus, inside an inode, instead of having multiple pointers, you just need one, to point to the first block of the file. To handle larger files, add an- other pointer at the end of that data block, and so on, and thus you can support large files.</p><p style="padding-top: 2pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">As you might have guessed, linked file allocation performs poorly for some workloads; think about reading the last block of a file, for example, or just doing random access. Thus, to make linked allocation work better, some systems will keep an in-memory table of link information, instead of storing the next pointers with the data blocks themselves. The table is indexed by the address of a data block <span class="s43">D</span>; the content of an entry is simply <span class="s43">D</span>’s next pointer, i.e., the address of the next block in a file which follows <span class="s43">D</span>. A null-value could be there too (indicating an end-of-file), or some other marker to indicate that a particular block is free. Having such a table of next pointers makes it so that a linked allocation scheme can effectively do random file accesses, simply by first scanning through the (in memory) table to find the desired block, and then accessing (on disk) it directly.</p><p style="padding-top: 2pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Does such a table sound familiar? What we have described is the basic structure of what is known as the <b>file allocation table</b>, or <b>FAT </b>file system. Yes, this classic old Windows file system, before NTFS [C94], is based on a simple linked-based allocation scheme. There are other differences from a standard U<span class="s7">NIX </span>file system too; for example, there are no inodes per se, but rather directory entries which store metadata about a file and refer directly to the first block of said file, which makes creating hard links impossible. See Brouwer [B02] for more of the inelegant details.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">can directly point to 48 KB of data, needing one (or more) indirect blocks for larger files. See Agrawal et. al [A+07] for a recent study; Table <span style=" color: #00AEEF;">40.2 </span>summarizes those results.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Of course, in the space of inode design, many other possibilities ex- ist; after all, the inode is just a data structure, and any data structure that stores the relevant information, and can query it effectively, is sufficient. As file system software is readily changed, you should be willing to ex- plore different designs should workloads or technologies change.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="64" alt="image" src="Image_591.png"/></span></p><p class="s36" style="padding-top: 3pt;padding-left: 75pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Most files are small        <span class="s12">Roughly 2K is the most common size</span></p><p class="s36" style="padding-left: 75pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Average file size is growing    <span class="s12">Almost 200K is the average</span></p><p class="s36" style="padding-left: 75pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Most bytes are stored in large files  <span class="s12">A few big files use most of the space</span></p><p class="s36" style="padding-left: 75pt;text-indent: 0pt;line-height: 8pt;text-align: left;">File systems contains lots of files  <span class="s12">Almost 100K on average</span></p><p class="s36" style="padding-left: 75pt;text-indent: 0pt;line-height: 8pt;text-align: left;">File systems are roughly half full  <span class="s12">Even as disks grow, file systems remain ˜50% full</span></p><p class="s36" style="padding-left: 75pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Directories are typically small   <span class="s12">Many have few entries; most have 20 or fewer</span></p><p style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: center;">Table 40.2: <b>File System Measurement Summary</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part439.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part441.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
