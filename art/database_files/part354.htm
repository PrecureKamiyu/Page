<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.8  Early Lock Release and Logical Undo Operations</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part353.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part355.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">19.8  <span style=" color: #00AEEF;">Early Lock Release and Logical Undo Operations</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Any index used in processing a transaction, such as a B<span class="s181">+</span>-tree, can be treated as normal data, but to increase concurrency, we can use the B<span class="s181">+</span>-tree concurrency-control algo- rithm described in Section 18.10.2 to allow locks to be released early, in a non-two-phase manner. As a result of early lock release, it is possible that a value in a B<span class="s181">+</span>-tree node is updated by one transaction <i>T</i><span class="s98">1</span>, which inserts an entry (<i>V </i>1, <i>R</i>1), and subsequently by another transaction <i>T</i><span class="s98">2</span>, which inserts an entry (<i>V </i>2, <i>R</i>2) in the same node, moving the entry (<i>V </i>1, <i>R</i>1) even before <i>T</i><span class="s98">1</span> completes execution.<span class="s76">4</span> At this point, we cannot undo transaction <i>T</i><span class="s98">1</span> by replacing the contents of the node with the old value prior to <i>T</i><span class="s98">1</span> per- forming its insert, since that would also undo the insert performed by <i>T</i><span class="s98">2</span>; transaction <i>T</i><span class="s98">2</span> may still commit (or may have already committed). In this example, the only way to undo the eﬀect of insertion of (<i>V </i>1, <i>R</i>1) is to execute a corresponding delete operation. In the rest of this section, we see how to extend the recovery algorithm of Section</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">19.4 to support early lock release.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">19.8.1 Logical Operations</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The insertion and deletion operations are examples of a class of operations that require logical undo operations since they release locks early; we call such operations <span class="s63">logical operations</span>. Such early lock release is important not only for indices, but also for oper- ations on other system data structures that are accessed and updated very frequently; examples include data structures that track the blocks containing records of a relation, the free space in a block, and the free blocks in a database. If locks were not released early after performing operations on such data structures, transactions would tend to run serially, aﬀecting system performance.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The theory of conﬂict serializability has been extended to operations, based on what operations conﬂict with what other operations. For example, two insert opera- tions on a B<span class="s181">+</span>-tree do not conﬂict if they insert diﬀerent key values, even if they both update overlapping areas of the same index page. However, insert and delete opera- tions conﬂict with other insert and delete operations, as well as with read operations, if they use the same key value. See the bibliographical notes for references to more information on this topic.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Operations acquire <i>lower-level locks </i>while they execute but release them when they complete; the corresponding transaction must however retain a <i>higher-level lock </i>in a</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_3067.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">4<span class="s78">Recall that an entry consists of a key value and a record identiﬁer, or a key value and a record in the case of the leaf level of a B</span><span class="s310">+</span><span class="s80">-tree ﬁle organization.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">two-phase manner to prevent concurrent transactions from executing conﬂicting ac- tions. For example, while an insert operation is being performed on a B<span class="s181">+</span>-tree page, a short-term lock is obtained on the page, allowing entries in the page to be shifted during the insert; the short-term lock is released as soon as the page has been updated. Such early lock release allows a second insert to execute on the same page. However, each transaction must obtain a lock on the key values being inserted or deleted and retain it in a two-phase manner, to prevent a concurrent transaction from executing a conﬂicting read, insert, or delete operation on the same key value.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Once the lower-level lock is released, the operation cannot be undone by using the old values of updated data items and must instead be undone by executing a compen- sating operation; such an operation is called a <span class="s63">logical undo operation</span>. It is important that the lower-level locks acquired during an operation are suﬃcient to perform a sub- sequent logical undo of the operation, for reasons explained later in Section 19.8.4.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">19.8.2 Logical Undo Log Records</p><p style="padding-top: 8pt;padding-left: 88pt;text-indent: 0pt;line-height: 79%;text-align: justify;">To allow logical undo of operations, before an operation is performed to modify an index, the transaction creates a log record <span class="s83">&lt;</span><i>T</i><span class="s145">i</span>, <i>O</i><span class="s145">j </span>, <span class="s49">operation-begin</span><span class="s83">&gt;</span>, where <i>O</i><span class="s145">j </span>is a unique identiﬁer for the operation instance.<span class="s76">5</span> While the system is executing the oper-</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">ation, it creates update log records in the normal fashion for all updates performed by the operation. Thus, the usual old-value and new-value information is written out as usual for each update performed by the operation; the old-value information is re- quired in case the transaction needs to be rolled back before the operation completes.</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">When the operation ﬁnishes, it writes an <span class="s49">operation-end </span>log record of the form <span class="s83">&lt;</span><i>T</i><span class="s145">i</span>, <i>O</i><span class="s145">j </span>,</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="s49">operation-end</span>, <i>U</i><span class="s83">&gt;</span>, where the <i>U </i>denotes undo information.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">For example, if the operation inserted an entry in a B<span class="s181">+</span>-tree, the undo information</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;"><i>U </i>would indicate that a deletion operation is to be performed and would identify the B<span class="s181">+</span>-tree and what entry to delete from the tree. Such logging of information about op- erations is called <span class="s63">logical logging</span>. In contrast, logging of old-value and new-value infor- mation is called <span class="s63">physical logging</span>, and the corresponding log records are called <span class="s63">physical log records</span>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Note that in the above scheme, logical logging is used only for undo, not for redo; redo operations are performed exclusively using physical log record. This is because the state of the database after a system failure may reﬂect some updates of an operation and not other operations, depending on what buﬀer blocks had been written to disk before the failure. Data structures such as B<span class="s181">+</span>-trees would not be in a consistent state, and neither logical redo nor logical undo operations can be performed on an inconsistent data structure. To perform logical redo or undo, the database state on disk must be <span class="s63">operation consistent</span>, that is, it should not have partial eﬀects of any operation. However, as we shall see, the physical redo processing in the redo phase of the recovery scheme, along with undo processing using physical log records, ensures that the parts of the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="95" height="1" alt="image" src="Image_3068.png"/></span></p><p class="s77" style="padding-top: 3pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">5<span class="s78">The position in the log of the </span><span class="s184">operation-begin </span><span class="s80">log record can be used as the unique identiﬁer.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">database accessed by a logical undo operation are in an operation consistent state before the logical undo operation is performed.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">An operation is said to be <span class="s63">idempotent </span>if executing it several times in a row gives the same result as executing it once. Operations such as inserting an entry into a B<span class="s181">+</span>-tree may not be idempotent, and the recovery algorithm must therefore make sure that an operation that has already been performed is not performed again. On the other hand, a physical log record is idempotent, since the corresponding data item would have the same value regardless of whether the logged update is executed one or multiple times.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">19.8.3 Transaction Rollback with Logical Undo</p><p style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;line-height: 90%;text-align: justify;">When rolling back a transaction <i>T</i><span class="s145">i</span>, the log is scanned backwards, and log records corresponding to <i>T</i><span class="s97">i </span>are processed as follows:</p><p class="s63" style="padding-top: 12pt;padding-left: 145pt;text-indent: -16pt;text-align: justify;">1. <span class="p">Physical log records encountered during the scan are handled as described earlier, except those that are skipped as described shortly. Incomplete logical operations are undone using the physical log records generated by the operation.</span></p><p style="padding-top: 7pt;padding-left: 145pt;text-indent: -17pt;line-height: 83%;text-align: justify;"><span class="s63">2. </span>Completed logical operations, identiﬁed by <span class="s49">operation-end </span>records, are rolled back diﬀerently. Whenever the system ﬁnds a log record <span class="s83">&lt;</span><i>T</i><span class="s97">i</span>, <i>O</i><span class="s97">j </span>, <span class="s49">operation-end</span>,</p><p class="s13" style="padding-left: 145pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">U<span class="s83">&gt;</span><span class="p">, it takes special actions:</span></p><p style="padding-top: 5pt;padding-left: 170pt;text-indent: -15pt;text-align: justify;">a. It rolls back the operation by using the undo information <i>U </i>in the log record. It logs the updates performed during the rollback of the operation just like updates performed when the operation was ﬁrst executed.</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: right;">At the end of the operation rollback, instead of generating a log record</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 16pt;text-align: right;"><span class="s83">&lt;</span><i>T</i><span class="s97">i</span>, <i>O</i><span class="s97">j </span>, <span class="s49">operation-end</span>, <i>U</i><span class="s83">&gt;</span>, the database system generates a log record</p><p style="padding-left: 170pt;text-indent: 0pt;line-height: 17pt;text-align: justify;"><span class="s83">&lt;</span><i>T</i><span class="s97">i</span>, <i>O</i><span class="s97">j </span>, <span class="s49">operation-abort</span><span class="s83">&gt;</span>.</p><p style="padding-top: 2pt;padding-left: 170pt;text-indent: -16pt;line-height: 76%;text-align: justify;">b. As the backward scan of the log continues, the system skips all log records of transaction <i>T</i><span class="s97">i </span>until it ﬁnds the log record <span class="s83">&lt;</span><i>T</i><span class="s97">i</span>, <i>O</i><span class="s97">j </span>, <span class="s49">operation-begin</span><span class="s83">&gt;</span>. After it ﬁnds the <span class="s49">operation-begin </span>log record, it processes log records of</p><p style="padding-left: 170pt;text-indent: 0pt;text-align: justify;">transaction <i>T</i><span class="s97">i </span>in the normal manner again.</p><p style="padding-top: 8pt;padding-left: 145pt;text-indent: 0pt;text-align: justify;">Observe that the system logs physical undo information for the updates per- formed during rollback, instead of using redo-only compensation log records. This is because a crash may occur while a logical undo is in progress, and on re- covery the system has to complete the logical undo; to do so, restart recovery will undo the partial eﬀects of the earlier undo, using the physical undo information, and then perform the logical undo again.</p><p style="padding-left: 145pt;text-indent: 14pt;text-align: justify;">Observe also that skipping over physical log records when the <span class="s49">operation-end </span>log record is found during rollback ensures that the old values in the physical log record are not used for rollback once the operation completes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;line-height: 61%;text-align: justify;"><span class="s63">3. </span>If the system ﬁnds a record <span class="s83">&lt;</span><i>T</i><span class="s145">i</span>, <i>O</i><span class="s145">j </span>, <span class="s49">operation-abort</span><span class="s83">&gt;</span>, it skips all preceding re- cords (including the <span class="s49">operation-end </span>record for <i>O</i><span class="s145">j </span>) until it ﬁnds the record <span class="s83">&lt;</span><i>T</i><span class="s145">i</span>, <i>O</i><span class="s145">j </span>, <span class="s49">operation-begin</span><span class="s83">&gt;</span>.</p><p style="padding-left: 128pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">An <span class="s49">operation-abort </span>log record would be found only if a transaction that is</p><p style="padding-left: 113pt;text-indent: 0pt;text-align: justify;">being rolled back had been partially rolled back earlier. Recall that logical op- erations may not be idempotent, and hence a logical undo operation must not be performed multiple times. These preceding log records must be skipped to prevent multiple rollback of the same operation in case there had been a crash during an earlier rollback and the transaction had already been partly rolled back.</p><p class="s83" style="padding-top: 8pt;padding-left: 113pt;text-indent: -17pt;line-height: 61%;text-align: justify;"><span class="s63">4. </span><span class="p">As before, when the </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">start</span>&gt; <span class="p">log record has been found, the transaction roll- back is complete, and the system adds a record </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt; <span class="p">to the log.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">If a failure occurs while a logical operation is in progress, the <span class="s49">operation-end </span>log record for the operation will not be found when the transaction is rolled back. However, for every update performed by the operation, undo information—in the form of the old value in the physical log records—is available in the log. The physical log records will be used to roll back the incomplete operation.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Now suppose an operation undo was in progress when the system crash occurred, which could happen if a transaction was being rolled back when the crash occurred.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="1" alt="image" src="Image_3069.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="289" height="238" alt="image" src="Image_3070.png"/></span></p><p class="s449" style="padding-top: 6pt;padding-left: 310pt;text-indent: 0pt;text-align: center;">If T<span class="s453">0</span> aborts before operation O<span class="s453">1</span> ends, undo of update to C will be physical</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s449" style="padding-left: 136pt;text-indent: 0pt;line-height: 10pt;text-align: center;">T<span class="s453">0</span></p><p class="s449" style="padding-left: 137pt;text-indent: 0pt;text-align: center;">decides to abort</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s275" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">Beginning of log</p><p style="text-indent: 0pt;text-align: left;"><span><img width="113" height="225" alt="image" src="Image_3071.png"/></span></p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span> start&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, B, 2000, 2050&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, O<span class="s453">1</span>, operation-begin&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, C, 700, 600&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, O<span class="s453">1</span>, operation-end, (C, +100)&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">1</span> start&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, O<span class="s453">2</span>, operation-begin&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">1</span>, C, 600, 400&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">1</span>, O<span class="s453">2</span>, operation-end, (C, +200)&gt;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="294" height="55" alt="image" src="Image_3072.png"/></span></p><p class="s449" style="padding-top: 12pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, C, 400, 500&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, O<span class="s453">1</span>, operation-abort&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, B, 2000&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">0</span>, abort&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;T<span class="s453">1</span>, commit&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s449" style="padding-left: 33pt;text-indent: 0pt;text-align: center;">T<span class="s453">0</span> has completed operation O<span class="s453">1</span> on C, releases lower-level lock; physical undo cannot be done anymore, logical undo will add 100 to C</p><p class="s449" style="padding-top: 9pt;padding-left: 4pt;text-indent: 0pt;text-align: center;">T<span class="s453">1</span> can update C since T<span class="s453">0</span> has released lower-level lock on C</p><p class="s449" style="padding-top: 10pt;padding-left: 4pt;text-indent: 0pt;text-align: center;">T<span class="s453">1</span> releases lower-level lock on C</p><p class="s449" style="padding-top: 5pt;padding-left: 8pt;text-indent: 0pt;text-align: center;">Logical undo of O<span class="s453">1</span> adds 100 on C</p><p class="s449" style="padding-top: 5pt;padding-left: 53pt;text-indent: 0pt;text-align: left;">O<span class="s453">1</span> undo complete</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 19.7 <span class="s74">Transaction rollback with logical undo operations.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Then the physical log records written during operation undo would be found, and the partial operation undo would itself be undone using these physical log records. Con- tinuing in the backward scan of the log, the original operation’s <span class="s49">operation-end </span>record would then be found, and the operation undo would be executed again. Rolling back the partial eﬀects of the earlier undo operation using the physical log records brings the database to a consistent state, allowing the logical undo operation to be executed again.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Figure 19.7 shows an example of a log generated by two transactions, which add or subtract a value from a data item. Early lock release on the data item <i>C </i>by transaction <i>T</i><span class="s98">0</span> after operation <i>O</i><span class="s98">1</span> completes allows transaction <i>T</i><span class="s98">1</span> to update the data item using <i>O</i><span class="s98">2</span>, even before <i>T</i><span class="s98">0</span> completes, but necessitates logical undo. The logical undo operation needs to add or subtract a value from the data item instead of restoring an old value to the data item.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">The annotations on the ﬁgure indicate that before an operation completes, rollback can perform physical undo; after the operation completes and releases lower-level locks, the undo must be performed by subtracting or adding a value, instead of restoring the old value. In the example in the ﬁgure, <i>T</i><span class="s98">0</span> rolls back operation <i>O</i><span class="s98">1</span> by adding 100 to <i>C</i>; on the other hand, for data item <i>B</i>, which was not subject to early lock release, undo is performed physically. Observe that <i>T</i><span class="s98">1</span>, which had performed an update on <i>C</i>, commits, and its update <i>O</i><span class="s98">2</span>, which added 200 to <i>C </i>and was performed before the undo of <i>O</i><span class="s98">1</span>, has persisted even though <i>O</i><span class="s98">1</span> has been undone.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Figure 19.8 shows an example of recovery from a crash with logical undo logging. In this example, operation <i>T</i><span class="s98">1</span> was active and executing operation <i>O</i><span class="s98">4</span> at the time of checkpoint. In the redo pass, the actions of <i>O</i><span class="s98">4</span> that are after the checkpoint log record are redone. At the time of crash, operation <i>O</i><span class="s98">5</span> was being executed by <i>T</i><span class="s98">2</span>, but the oper- ation was not complete. The undo-list contains <i>T</i><span class="s98">1</span> and <i>T</i><span class="s98">2</span> at the end of the redo pass. During the undo pass, the undo of operation <i>O</i><span class="s98">5</span> is carried out using the old value in the physical log record, setting <i>C </i>to 400; this operation is logged using a redo-only log</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">record. The <span class="s49">start </span>record of <i>T</i><span class="s98">2</span> is encountered next, resulting in the addition of <span class="s83">&lt;</span><i>T</i><span class="s98">2</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 14pt;text-align: justify;"><span class="s49">abort</span><span class="s83">&gt; </span>to the log and removal of <i>T</i><span class="s98">2</span> from undo-list.</p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">The next log record encountered is the <span class="s49">operation-end </span>record of <i>O</i><span class="s98">4</span>; logical undo</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">is performed for this operation by adding 300 to <i>C</i>, which is logged physically, and an <span class="s49">operation-abort </span>log record is added for <i>O</i><span class="s98">4</span>. The physical log records that were part of <i>O</i><span class="s98">4</span> are skipped until the <span class="s49">operation-begin </span>log record for <i>O</i><span class="s98">4</span> is encountered. In this example, there are no other intervening log records, but in general log records from other transactions may be found before we reach the <span class="s49">operation-begin </span>log record; such log records should of course not be skipped (unless they are part of a completed operation for the corresponding transaction and the algorithm skips those records). After the <span class="s49">operation-begin </span>log record is found for <i>O</i><span class="s98">4</span>, a physical log record is found for <i>T</i><span class="s98">1</span>, which is rolled back physically. Finally the <span class="s49">start </span>log record for <i>T</i><span class="s98">1</span> is found; this</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 70%;text-align: justify;">results in <span class="s83">&lt; </span><i>T</i><span class="s98">1</span> <span class="s49">abort</span><span class="s83">&gt; </span>being added to the log and <i>T</i><span class="s98">1</span> being deleted from undo-list. At this point undo-list is empty, and the undo phase is complete.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s315" style="padding-left: 100pt;text-indent: -1pt;text-align: justify;">End of log at crash!</p><p class="s315" style="padding-top: 6pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">Beginning of log</p><p style="text-indent: 0pt;text-align: left;"><span><img width="120" height="323" alt="image" src="Image_3073.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="8" height="98" alt="image" src="Image_3074.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="126" height="233" alt="image" src="Image_3075.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="77" alt="image" src="Image_3076.png"/></span></p><p class="s446" style="padding-top: 1pt;text-indent: 0pt;text-align: center;">Start log records found for all transactions in undo list</p><p style="text-indent: 0pt;text-align: left;"/><p class="s315" style="padding-top: 1pt;text-indent: 0pt;text-align: left;">Redo Pass</p><p style="text-indent: 0pt;text-align: left;"/><p class="s454" style="padding-top: 2pt;padding-left: 31pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s455">0</span> <span class="s446">start&gt;</span></p><p class="s446" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>0</i>, B, 2000, 2050&gt;</p><p class="s454" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s455">0</span> <span class="s446">commit&gt;</span></p><p class="s454" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s455">1</span> <span class="s446">start&gt;</span></p><p class="s446" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>1</i>, B, 2050, 2100&gt;</p><p class="s446" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>1</i>, O<i>4</i>, operation-begin&gt;</p><p class="s446" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;checkpoint {<i>T</i><i>1</i>}&gt;</p><p class="s446" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>1</i>, C, 700, 400&gt;</p><p class="s446" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>1</i>, O<i>4</i>, operation-end (C, +300)&gt;</p><p class="s454" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s455">2</span> <span class="s446">start&gt;</span></p><p class="s446" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>2</i>, O<i>5</i>, operation-begin&gt;</p><p class="s446" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;line-height: 11pt;text-align: left;">&lt;<i>T</i><i>2</i>, C, 400, 300&gt;</p><p class="s446" style="padding-left: 166pt;text-indent: 0pt;line-height: 11pt;text-align: left;">Undo list: <i>T</i><i>1</i>, <i>T</i><i>2</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s315" style="padding-top: 11pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">Undo Pass</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s446" style="padding-left: 136pt;text-indent: 0pt;text-align: center;">Records added during recovery</p><p class="s446" style="padding-top: 2pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>2</i>, C, 400&gt;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="321" height="93" alt="image" src="Image_3077.png"/></span></p><p class="s454" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s455">2</span> <span class="s446">abort&gt;</span></p><p class="s446" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>1</i>, C, 400, 700&gt;</p><p class="s446" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>1</i>, O<i>4</i>, operation-abort&gt;</p><p class="s446" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>1</i>, B, 2050&gt;</p><p class="s454" style="padding-top: 1pt;padding-left: 27pt;text-indent: 0pt;text-align: left;"><span class="s446">&lt;</span>T<span class="s455">1</span> <span class="s446">abort&gt;</span></p><p class="s446" style="padding-top: 7pt;padding-left: 35pt;text-indent: -8pt;text-align: left;">Update of C was part of O<i>5</i>, undone physically during recovery since</p><p class="s446" style="padding-left: 18pt;text-indent: 42pt;line-height: 256%;text-align: left;">O<i>5</i><i> </i>did not complete Logical undo of O<i>4</i><i> </i>adds 300 to C</p><p class="s73" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 19.8 <span class="s74">Failure recovery actions with logical undo operations.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">19.8.4 Concurrency Issues in Logical Undo</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">As mentioned earlier, it is important that the lower-level locks acquired during an op- eration are suﬃcient to perform a subsequent logical undo of the operation; otherwise concurrent operations that execute during normal processing may cause problems in the undo phase. For example, suppose the logical undo of operation <i>O</i><span class="s98">1</span> of transaction <i>T</i><span class="s98">1</span> can conﬂict at the data item level with a concurrent operation <i>O</i><span class="s98">2</span> of transaction <i>T</i><span class="s98">2</span>, and <i>O</i><span class="s98">1</span> completes while <i>O</i><span class="s98">2</span> does not. Assume also that neither transaction had commit- ted when the system crashed. The physical update log records of <i>O</i><span class="s98">2</span> may appear before and after the <span class="s49">operation-end </span>record for <i>O</i><span class="s98">1</span>, and during recovery updates done during the logical undo of <i>O</i><span class="s98">1</span> may get fully or partially overwritten by old values during the physical undo of <i>O</i><span class="s98">2</span>. This problem cannot occur if <i>O</i><span class="s98">1</span> had obtained all the lower-level locks required for the logical undo of <i>O</i><span class="s98">1</span>, since then there cannot be such a concurrent <i>O</i><span class="s130">2</span><span class="s94">.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">If both the original operation and its logical undo operation access a single page</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">(such operations are called physiological operations and are discussed in Section 19.9), the locking requirement above is met easily. Otherwise the details of the speciﬁc opera- tion need to be considered when deciding on what lower-level locks need to be obtained. For example, update operations on a B<span class="s181">+</span>-tree could obtain a short-term lock on the root,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;"><a name="bookmark403">to ensure that operations execute serially. See the bibliographical notes for references on B</a><span class="s181">+</span>-tree concurrency control and recovery exploiting logical undo logging. See the bibliographical notes also for references to an alternative approach, called multilevel recovery, which relaxes this locking requirement.<a name="bookmark443">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part353.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part355.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
