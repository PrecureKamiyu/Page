<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.3 Who Handles The TLB Miss?</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part192.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part194.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">19.3 Who Handles The TLB Miss?</p><p style="padding-top: 3pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One question that we must answer: who handles a TLB miss? Two an- swers are possible: the hardware, or the software (OS). In the olden days, the hardware had complex instruction sets (sometimes called <b>CISC</b>, for complex-instruction set computers) and the people who built the hard- ware didn’t much trust those sneaky OS people. Thus, the hardware would handle the TLB miss entirely. To do this, the hardware has to know exactly <i>where </i>the page tables are located in memory (via a <b>page- table base register</b>, used in Line 11 in Figure <span style=" color: #00AEEF;">19.1</span>), as well as their <i>exact format</i>; on a miss, the hardware would “walk” the page table, find the cor- rect page-table entry and extract the desired translation, update the TLB with the translation, and retry the instruction. An example of an “older” architecture that has <b>hardware-managed TLBs </b>is the Intel x86 architec- ture, which uses a fixed <b>multi-level page table </b>(see the next chapter for details); the current page table is pointed to by the CR3 register [I09].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">1  <span class="s38">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2  <span class="s38">(Success, TlbEntry) = TLB_Lookup(VPN)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">if (Success == True) // TLB Hit</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">4    <span class="s38">if (CanAccess(TlbEntry.ProtectBits) == True)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">5       <span class="s38">Offset  = VirtualAddress &amp; OFFSET_MASK</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">6       <span class="s38">PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7       <span class="s38">Register = AccessMemory(PhysAddr)</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8    <span class="s38">else</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">9       <span class="s38">RaiseException(PROTECTION_FAULT)</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10  <span class="s38">else       // TLB Miss</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11    <span class="s38">RaiseException(TLB_MISS)</span></p><p style="padding-top: 5pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">Figure 19.3: <b>TLB Control Flow Algorithm (OS Handled)</b></p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: right;">More modern architectures (e.g., MIPS R10k [H93] or Sun’s SPARC v9 [WG00], both <b>RISC </b>or reduced-instruction set computers) have what is known as a <b>software-managed TLB</b>. On a TLB miss, the hardware sim- ply raises an exception (line 11 in Figure <span style=" color: #00AEEF;">19.3</span>), which pauses the current instruction stream, raises the privilege level to kernel mode, and jumps to a <b>trap handler</b>. As you might guess, this trap handler is code within the OS that is written with the express purpose of handling TLB misses. When run, the code will lookup the translation in the page table, use spe- cial “privileged” instructions to update the TLB, and return from the trap; at this point, the hardware retries the instruction (resulting in a TLB hit). Let’s discuss a couple of important details. First, the return-from-trap instruction needs to be a little different than the return-from-trap we saw before when servicing a system call. In the latter case, the return-from- trap should resume execution at the instruction <i>after </i>the trap into the OS, just as a return from a procedure call returns to the instruction imme- diately following the call into the procedure. In the former case, when returning from a TLB miss-handling trap, the hardware must resume ex- ecution at the instruction that <i>caused </i>the trap; this retry thus lets the in- struction run again, this time resulting in a TLB hit. Thus, depending on how a trap or exception was caused, the hardware must save a different PC when trapping into the OS, in order to resume properly when the time</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">to do so arrives.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Second, when running the TLB miss-handling code, the OS needs to be extra careful not to cause an infinite chain of TLB misses to occur. Many solutions exist; for example, you could keep TLB miss handlers in physi- cal memory (where they are <b>unmapped </b>and not subject to address trans- lation), or reserve some entries in the TLB for permanently-valid transla- tions and use some of those permanent translation slots for the handler code itself; these <b>wired </b>translations always hit in the TLB.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The primary advantage of the software-managed approach is <i>flexibil- ity</i>: the OS can use any data structure it wants to implement the page table, without necessitating hardware change. Another advantage is <i>sim- plicity</i>; as you can see in the TLB control flow (line 11 in Figure <span style=" color: #00AEEF;">19.3</span>, in contrast to lines 11–19 in Figure <span style=" color: #00AEEF;">19.1</span>), the hardware doesn’t have to do much on a miss; it raises an exception, and the OS TLB miss handler does the rest.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="408" height="422" alt="image" src="Image_254.png"/></span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 11pt;text-align: center;">A<span class="s7">SIDE</span>: <b>RISC </b><span class="s45">VS</span><b>. CISC</b></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In the 1980’s, a great battle took place in the computer architecture com- munity. On one side was the <b>CISC </b>camp, which stood for <b>Complex Instruction Set Computing</b>; on the other side was <b>RISC</b>, for <b>Reduced Instruction Set Computing </b>[PS81]. The RISC side was spear-headed by David Patterson at Berkeley and John Hennessy at Stanford (who are also co-authors of some famous books [HP06]), although later John Cocke was recognized with a Turing award for his earliest work on RISC [CM00].</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">CISC instruction sets tend to have a lot of instructions in them, and each instruction is relatively powerful. For example, you might see a string copy, which takes two pointers and a length and copies bytes from source to destination. The idea behind CISC was that instructions should be high-level primitives, to make the assembly language itself easier to use, and to make code more compact.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">RISC instruction sets are exactly the opposite. A key observation behind RISC is that instruction sets are really compiler targets, and all compil- ers really want are a few simple primitives that they can use to gener- ate high-performance code. Thus, RISC proponents argued, let’s rip out as much from the hardware as possible (especially the microcode), and make what’s left simple, uniform, and fast.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">In the early days, RISC chips made a huge impact, as they were noticeably faster [BC91]; many papers were written; a few companies were formed (e.g., MIPS and Sun). However, as time progressed, CISC manufacturers such as Intel incorporated many RISC techniques into the core of their processors, for example by adding early pipeline stages that transformed complex instructions into micro-instructions which could then be pro- cessed in a RISC-like manner. These innovations, plus a growing number of transistors on each chip, allowed CISC to remain competitive. The end result is that the debate died down, and today both types of processors can be made to run fast.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part192.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part194.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
