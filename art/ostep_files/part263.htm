<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>26.2 Why It Gets Worse: Shared Data</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part262.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part264.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">26.2 Why It Gets Worse: Shared Data</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">The simple thread example we showed above was useful in showing how threads are created and how they can run in different orders depend- ing on how the scheduler decides to run them. What it doesn’t show you, though, is how threads interact when they access shared data.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let us imagine a simple example where two threads wish to update a global shared variable. The code we’ll study is in Figure <span style=" color: #00AEEF;">26.3</span>.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_314.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_315.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_316.png"/></span></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Here are a few notes about the code. First, as Stevens suggests [SR05], we wrap the thread creation and join routines to simply exit on failure; for a program as simple as this one, we want to at least notice an error occurred (if it did), but not do anything very smart about it (e.g., just exit). Thus, <span class="s41">Pthread create() </span>simply calls <span class="s41">pthread create() </span>and makes sure the return code is 0; if it isn’t, <span class="s41">Pthread create() </span>just prints a message and exits.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Second, instead of using two separate function bodies for the worker threads, we just use a single piece of code, and pass the thread an argu- ment (in this case, a string) so we can have each thread print a different letter before its messages.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">Finally, and most importantly, we can now look at what each worker is trying to do: add a number to the shared variable <span class="s41">counter</span>, and do so 10 million times (1e7) in a loop. Thus, the desired final result is: 20,000,000.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">We now compile and run the program, to see how it behaves. Some- times, everything works how we might expect:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; gcc -o main main.c -Wall -pthread prompt&gt; ./main</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">main: begin (counter = 0) A: begin</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">B: begin A: done B: done</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">main: done with both (counter = 20000000)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Unfortunately, when we run this code, even on a single processor, we don’t necessarily get the desired result. Sometimes, we get:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; ./main</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">main: begin (counter = 0) A: begin</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">B: begin A: done B: done</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;line-height: 8pt;text-align: left;">main: done with both (counter = 19345221)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let’s try it one more time, just to see if we’ve gone crazy. After all, aren’t computers supposed to produce <b>deterministic </b>results, as you have been taught?! Perhaps your professors have been lying to you? <i>(gasp)</i></p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">prompt&gt; ./main</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">main: begin (counter = 0) A: begin</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">B: begin A: done B: done</p><p class="s38" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">main: done with both (counter = 19221041)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Not only is each run wrong, but also yields a <i>different </i>result! A big question remains: why does this happen?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 82pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: K<span class="s7">NOW </span>A<span class="s7">ND </span>U<span class="s7">SE </span>Y<span class="s7">OUR </span>T<span class="s7">OOLS</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">You should always learn new tools that help you write, debug, and un- derstand computer systems. Here, we use a neat tool called a <b>disassem- bler. </b>When you run a disassembler on an executable, it shows you what assembly instructions make up the program. For example, if we wish to understand the low-level code to update a counter (as in our example), we run <span class="s41">objdump </span>(Linux) to see the assembly code:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-left: 9pt;text-indent: 0pt;text-align: justify;">prompt&gt; objdump -d main</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 88%;text-align: justify;">Doing so produces a long listing of all the instructions in the program, neatly labeled (particularly if you compiled with the <span class="s41">-g </span>flag), which in- cludes symbol information in the program. The <span class="s41">objdump </span>program is just one of many tools you should learn how to use; a debugger like <span class="s41">gdb</span>, memory profilers like <span class="s41">valgrind </span>or <span class="s41">purify</span>, and of course the compiler itself are others that you should spend time to learn more about; the better you are at using your tools, the better systems you’ll be able to build.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part262.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part264.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
