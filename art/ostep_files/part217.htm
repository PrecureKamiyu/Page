<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>21.2 The Present Bit</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part216.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part218.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">21.2 The Present Bit</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Now that we have some space on the disk, we need to add some ma- chinery higher up in the system in order to support swapping pages to and from the disk. Let us assume, for simplicity, that we have a system with a hardware-managed TLB.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Recall first what happens on a memory reference. The running pro- cess generates virtual memory references (for instruction fetches, or data accesses), and, in this case, the hardware translates them into physical addresses before fetching the desired data from memory.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: right;">Remember that the hardware first extracts the VPN from the virtual address, checks the TLB for a match (a <b>TLB hit</b>), and if a hit, produces the resulting physical address and fetches it from memory. This is hopefully the common case, as it is fast (requiring no additional memory accesses). If the VPN is not found in the TLB (i.e., a <b>TLB miss</b>), the hardware locates the page table in memory (using the <b>page table base register</b>) and looks up the <b>page table entry (PTE) </b>for this page using the VPN as an index. If the page is valid and present in physical memory, the hardware extracts the PFN from the PTE, installs it in the TLB, and retries</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">the instruction, this time generating a TLB hit; so far, so good.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">If we wish to allow pages to be swapped to disk, however, we must add even more machinery. Specifically, when the hardware looks in the PTE, it may find that the page is <i>not present </i>in physical memory. The way the hardware (or the OS, in a software-managed TLB approach) deter- mines this is through a new piece of information in each page-table entry, known as the <b>present bit</b>. If the present bit is set to one, it means the page is present in physical memory and everything proceeds as above; if it is set to zero, the page is <i>not </i>in memory but rather on disk somewhere. The act of accessing a page that is not in physical memory is commonly referred to as a <b>page fault</b>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>S<span class="s45">WAPPING </span>T<span class="s45">ERMINOLOGY </span>A<span class="s45">ND </span>O<span class="s45">THER </span>T<span class="s45">HINGS</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Terminology in virtual memory systems can be a little confusing and vari- able across machines and operating systems. For example, a <b>page fault </b>more generally could refer to any reference to a page table that generates a fault of some kind: this could include the type of fault we are discussing here, i.e., a page-not-present fault, but sometimes can refer to illegal mem- ory accesses. Indeed, it is odd that we call what is definitely a legal access (to a page mapped into the virtual address space of a process, but simply not in physical memory at the time) a “fault” at all; really, it should be called a <b>page miss</b>. But often, when people say a program is “page fault- ing”, they mean that it is accessing parts of its virtual address space that the OS has swapped out to disk.</p><p style="padding-top: 2pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">We suspect the reason that this behavior became known as a “fault” re- lates to the machinery in the operating system to handle it. When some- thing unusual happens, i.e., when something the hardware doesn’t know how to handle occurs, the hardware simply transfers control to the OS, hoping it can make things better. In this case, a page that a process wants to access is missing from memory; the hardware does the only thing it can, which is raise an exception, and the OS takes over from there. As this is identical to what happens when a process does something illegal, it is perhaps not surprising that we term the activity a “fault.”</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Upon a page fault, the OS is invoked to service the page fault. A partic- ular piece of code, known as a <b>page-fault handler</b>, runs, and must service the page fault, as we now describe.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part216.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part218.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
