<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Broken Solution</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part328.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part330.htm">下一个 &gt;</a></p><p class="s32" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">Broken Solution</p><p style="padding-top: 5pt;padding-left: 68pt;text-indent: 0pt;line-height: 88%;text-align: left;">We attempt our first solution to the problem. Assume we initialize each semaphore (in the <span class="s41">forks </span>array) to a value of 1. Assume also that each philosopher knows its own number (<span class="s41">p</span>). We can thus write the <span class="s41">getforks() </span>and <span class="s41">putforks() </span>routine as shown in Figure <span style=" color: #00AEEF;">31.11</span>.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The intuition behind this (broken) solution is as follows. To acquire the forks, we simply grab a “lock” on each one: first the one on the left, and then the one on the right. When we are done eating, we release them. Simple, no? Unfortunately, in this case, simple means broken. Can you see the problem that arises? Think about it.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The problem is <b>deadlock</b>. If each philosopher happens to grab the fork on their left before any philosopher can grab the fork on their right, each will be stuck holding one fork and waiting for another, forever. Specifi- cally, philosopher 0 grabs fork 0, philosopher 1 grabs fork 1, philosopher</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">2 grabs fork 2, philosopher 3 grabs fork 3, and philosopher 4 grabs fork 4; all the forks are acquired, and all the philosophers are stuck waiting for a fork that another philosopher possesses. We’ll study deadlock in more detail soon; for now, it is safe to say that this is not a working solution.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part328.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part330.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
