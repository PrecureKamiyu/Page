<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1200645" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_77"><span class="bold">18. Debugging</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1200800"> </div>
<p class="calibre_2">One factor that differentiates kernel development from user-space development is the hardship associated with debugging. It is difficult, relative to user-space, to debug the kernel. To complicate the matter, the stakes are much higher. A fault in the kernel can bring down the whole system.</p><div class="calibre_3"> </div>
<p class="calibre_2">Success in debugging the kernel—and ultimately, success in kernel development as a whole—is largely a function of your experience and understanding of the operating system. Sure, looks and charm help, too, but to successfully debug kernel issues, you need to understand the kernel. This chapter looks at approaches to debugging the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1201595"> </div>
<h3 class="calibre_21"><span class="bold">Getting Started</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Kernel debugging is often a long, head-scratching endeavor. Some bugs have perplexed the entire kernel development community for months. Fortunately, for every one of these laborious issues, there are many simple bugs with an equally simple fix. With luck, all your bugs will remain simple and trivial. You will not know that, however, until you start investigating. For that, you need</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A bug. It might sound silly, but you need a well-defined and specific bug. It helps if it is reliably reproducible (at least for someone), but unfortunately bugs are not always well behaved or well defined.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• A kernel version on which the bug exists. Knowing where the bug <em class="calibre4">first</em> appeared is even better. If you do not yet know that, this chapter can teach you a trick for quickly determining it.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Knowledge of the associated kernel code or luck. Debugging the kernel is tricky, and the more you understand the surrounding code, the better.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">Most of this chapter’s techniques presume that you can reliably reproduce the bug. Your success in debugging relies on your ability to duplicate the problem. If you cannot, fixing the bug is limited to conceptualizing the problem and finding a flaw in the code. This does often happen, but chances of success are obviously much larger if you can reproduce the problem.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1203375"></a>It might seem strange that there are bugs that someone cannot reproduce. In user-space programs, bugs are quite often a straightforward affair. For example, <em class="calibre4">doing</em> foo <em class="calibre4">makes my application dump core</em>. Bugs in the kernel are often much less clear. The interactions between the kernel, user-space, and hardware are often quite delicate. Race conditions might rear their ugly heads only once in a million iterations of an algorithm. Poorly designed or even miscompiled code can result in acceptable performances on some systems but terrible performances on others. It is common for some specific configuration, on some random machine, under some odd workload, to trigger a bug otherwise unseen. The more information you have when tackling a bug, the better. Many times, if you can reliably reproduce the bug, you are more than halfway home.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1204279"> </div>
<h3 class="calibre_21"><span class="bold">Bugs in the Kernel</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Bugs in the kernel vary widely. They occur for myriad reasons and manifest themselves in just as many forms. Bugs range from clearly incorrect code (for example, not storing the correct value in the proper place) to synchronization errors (not properly locking a shared variable) to incorrectly managing hardware (sending the wrong operation to the wrong control register). They manifest themselves as everything from poor performance to incorrect behavior to corrupt data to a deadlocked system.</p><div class="calibre_3"> </div>
<p class="calibre_2">Often, it is a long chain of events that leads from the error in the code to the error witnessed by the user. For example, a shared structure without a reference count might cause a race condition. Without proper accounting, one process might free the structure whereas another process still wants to use it. Later on, the second process may attempt to use the no longer existent structure through a now invalid pointer. This might result in a <code class="calibre6"><span class="calibre7">NULL</span></code> pointer dereference, reading of garbage data, or nothing bad at all (if the data was not yet overwritten). The <code class="calibre6"><span class="calibre7">NULL</span></code> pointer dereference causes an oops, whereas the garbage data leads to corruption (and then bad behavior or an oops). The user reports the oops or incorrect behavior. The kernel developer must then work backward from the error and see that the data was accessed after it was freed, there was a race, and the fix is to add proper reference counting on the shared structure.</p><div class="calibre_3"> </div>
<p class="calibre_2">Debugging the kernel might sound difficult, but in reality, the kernel is not unlike any other large software project. The kernel does have unique issues, such as timing constraints and race conditions, which are a consequence of allowing multiple threads of execution inside the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1206342"> </div>
<h3 class="calibre_21"><span class="bold">Debugging by Printing</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The kernel print function <code class="calibre6"><span class="calibre7">printk()</span></code> behaves almost identically to the C library <code class="calibre6"><span class="calibre7">printf()</span></code> function. Indeed, throughout this book we have made use of few real differences. For most intentions, this is fine; <code class="calibre6"><span class="calibre7">printk()</span></code> is simply the name of the kernel’s formatted print function. It does have some special features, however.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1206946"> </div>
<h4 class="calibre_27"><span class="calibre3">Robustness</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1207058"> </div>
<p class="calibre_2">One property of <code class="calibre6"><span class="calibre7">printk()</span></code> easily taken for granted is its robustness. The <code class="calibre6"><span class="calibre7">printk()</span></code> function is callable from just about <em class="calibre4">anywhere</em> in the kernel at <em class="calibre4">any time</em>. It can be called from interrupt or process context. It can be called while any lock is held. It can be called simultaneously on multiple processors, yet it does not require the caller to hold a lock.</p><div class="calibre_3"> </div>
<p class="calibre_2">It is a resilient function. This is important because the usefulness of <code class="calibre6"><span class="calibre7">printk()</span></code> rests on the fact that it is always there and always works.</p><div class="calibre_3"> </div>
<p class="calibre_2">A chink in the armor of <code class="calibre6"><span class="calibre7">printk()</span></code>’s robustness does exist. It is unusable before a certain point in the kernel boot process, prior to console initialization. Indeed, if the console is not initialized, where is the output supposed to go? This is normally not an issue, unless you debug issues early in the boot process (for example, in <code class="calibre6"><span class="calibre7">setup_arch()</span></code>, which performs architecture-specific initialization). Such debugging is a challenge to begin with, and the absence of any sort of print method only compounds the problem.</p><div class="calibre_3"> </div>
<p class="calibre_2">There is some hope, but not a lot. Hardcore architecture hackers use the hardware that does work (say, a serial port) to communicate with the outside world. This is not fun for most people. The solution is a <code class="calibre6"><span class="calibre7">printk()</span></code> variant that can output to the console early in the boot process: <code class="calibre6"><span class="calibre7">early_printk()</span></code>. The behavior is the same as <code class="calibre6"><span class="calibre7">printk()</span></code>, only the name and its capability to work earlier are changed. This is not a portable solution, however, because not all supported architectures have such a method implemented. It might be your best hope, however, if the architecture you use does implement it—most, including x86, do.</p><div class="calibre_3"> </div>
<p class="calibre_2">Unless you need to write to the console early in the boot process, you can rely on <code class="calibre6"><span class="calibre7">printk()</span></code> to always work.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1209448"> </div>
<h4 class="calibre_27"><span class="calibre3">Loglevels</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The major difference in usage between <code class="calibre6"><span class="calibre7">printk()</span></code> and <code class="calibre6"><span class="calibre7">printf()</span></code> is the capability of the former to specify a <em class="calibre4">loglevel</em>. The kernel uses the loglevel to decide whether to print the message to the console. The kernel displays all messages with a loglevel below a specified value on the console.</p><div class="calibre_3"> </div>
<p class="calibre_2">You specify a loglevel like this:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">printk(KERN_WARNING "This is a warning!\n");<br class="calibre1"/>printk(KERN_DEBUG "This is a debug notice!\n");<br class="calibre1"/>printk("I did not specify a loglevel!\n");</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">KERN_WARNING</span></code> and <code class="calibre6"><span class="calibre7">KERN_DEBUG</span></code> strings are simple defines found in <code class="calibre6"><span class="calibre7">&lt;linux/kernel.h&gt;</span></code>. They expand to a string such as “<code class="calibre6"><span class="calibre7">&lt;4&gt;</span></code>” or “<code class="calibre6"><span class="calibre7">&lt;7&gt;</span></code>” that is concatenated onto the front of the <code class="calibre6"><span class="calibre7">printk()</span></code> message. The kernel then decides which messages to print on the console based on this specified loglevel and the current console loglevel, <code class="calibre6"><span class="calibre7">console_loglevel</span></code>. <a href="#filepos1211120">Table 18.1</a> is a full listing of the available loglevels.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1211069"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1211120"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 18.1. Available Loglevels</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00245.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">If you do not specify a loglevel, it defaults to <code class="calibre6"><span class="calibre7">DEFAULT_MESSAGE_LOGLEVEL</span></code>, which is currently <code class="calibre6"><span class="calibre7">KERN_WARNING</span></code>. Because this value might change, you should always specify a loglevel for your messages.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel defines the most important loglevel, <code class="calibre6"><span class="calibre7">KERN_EMERG</span></code>, as <code class="calibre6"><span class="calibre7">&lt;0&gt;</span></code>, and it defines <code class="calibre6"><span class="calibre7">KERN_DEBUG</span></code>, the least critical loglevel, as <code class="calibre6"><span class="calibre7">&lt;7&gt;</span></code>. For example, after the preprocessor is done, the previous examples resemble the following:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">printk("&lt;4&gt;This is a warning!\n");<br class="calibre1"/>printk("&lt;7&gt;This is a debug notice!\n");<br class="calibre1"/>printk("&lt;4&gt;did not specify a loglevel!\n");</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The avenue that you take with your <code class="calibre6"><span class="calibre7">printk()</span></code> loglevels is up to you. Of course, normal messages that you intend to keep around should have the appropriate loglevel. But the debugging messages you sprinkle everywhere when trying to get a handle on a problem—admit it, we all do it and it works—can have any loglevel you want. One option is to leave your default console loglevel where it is and make all your debugging messages <code class="calibre6"><span class="calibre7">KERN_CRIT</span></code> or so. Conversely, you can make the debugging messages <code class="calibre6"><span class="calibre7">KERN_DEBUG</span></code> and change your console loglevel. Each has pros and cons; you decide.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1213129"> </div>
<h4 class="calibre_27"><span class="calibre3">The Log Buffer</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Kernel messages are stored in a circular buffer of size <code class="calibre6"><span class="calibre7">LOG_BUF_LEN</span></code>. This size is configurable at compile time via the <code class="calibre6"><span class="calibre7">CONFIG_LOG_BUF_SHIFT</span></code> option. The default for a uniprocessor machine is 16KB. In other words, the kernel can simultaneously store 16KB of kernel messages. If the message queue is at this maximum and another call to <code class="calibre6"><span class="calibre7">printk()</span></code> is made, the new message overwrites the oldest one. The log buffer is called <em class="calibre4">circular</em> because the reading and writing occur in a circular pattern.</p><div class="calibre_3"> </div>
<p class="calibre_2">Using a circular buffer has multiple advantages. Because it is easy to simultaneously write to and read from a circular buffer, even interrupt context can easily use <code class="calibre6"><span class="calibre7">printk()</span></code>. <a id="filepos1214109"></a>Furthermore, it makes log maintenance easy. If there are too many messages, new messages simply overwrite the older ones. If there is a problem that results in the generation of many messages, the log simply overwrites itself in lieu of uncontrollably consuming memory. The lone disadvantage of a circular buffer—the possibility of losing messages—is a small price to pay for the simplicity and robustness it affords.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1214589"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">syslogd</span></code> and <code class="calibre6"><span class="calibre7">klogd</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">On a standard Linux system, the user-space <code class="calibre6"><span class="calibre7">klogd</span></code> daemon retrieves the kernel messages from the log buffer and feeds them into the system log file via the <code class="calibre6"><span class="calibre7">syslogd</span></code> daemon. To read the log, the <code class="calibre6"><span class="calibre7">klogd</span></code> program can either read the <code class="calibre6"><span class="calibre7">/proc/kmsg</span></code> file or call the <code class="calibre6"><span class="calibre7">syslog()</span></code> system call. By default, it uses the <code class="calibre6"><span class="calibre7">/proc</span></code> approach. In either case, <code class="calibre6"><span class="calibre7">klogd</span></code> blocks until there are new kernel messages to read. It then wakes up, reads any new messages, and processes them. By default, it sends the messages to the <code class="calibre6"><span class="calibre7">syslogd</span></code> daemon.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">syslogd</span></code> daemon appends all the messages it receives to a file, which is by default <code class="calibre6"><span class="calibre7">/var/log/messages</span></code>. It is configurable via <code class="calibre6"><span class="calibre7">/etc/syslog.conf</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">You can have <code class="calibre6"><span class="calibre7">klogd</span></code> change the console loglevel when it loads by specifying the <code class="calibre6"><span class="calibre7">-c</span></code> flag when you start it.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1216144"> </div>
<h4 class="calibre_27"><span class="calibre3">Transposing <code class="calibre6"><span class="calibre7">printf()</span></code> and <code class="calibre6"><span class="calibre7">printk()</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">When you first start developing kernel code, you most likely will often transpose <code class="calibre6"><span class="calibre7">printf()</span></code> for <code class="calibre6"><span class="calibre7">printk()</span></code>. This transposition is only natural, as you cannot deny years of repetition using <code class="calibre6"><span class="calibre7">printf()</span></code> in user-space development. With luck, this mistake will not last long because the repeated linker errors will eventually grow rather annoying.</p><div class="calibre_3"> </div>
<p class="calibre_2">Someday, you might find yourself accidentally using <code class="calibre6"><span class="calibre7">printk()</span></code> instead of <code class="calibre6"><span class="calibre7">printf()</span></code> in your user-space code. When that day comes, you can say you are a true kernel hacker.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1217131"> </div>
<h3 class="calibre_21"><span class="bold">Oops</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">An <em class="calibre4">oops</em> is the usual way a kernel communicates to the user that something bad happened. Because the kernel is the supervisor of the entire system, it cannot simply fix itself or kill itself as it can when user-space goes awry. Instead, the kernel issues an oops. This involves printing an error message to the console, dumping the contents of the registers, and providing a back trace. A failure in the kernel is hard to manage, so the kernel must jump through many hoops to issue the oops and clean up after itself. Often, after an oops the kernel is in an inconsistent state. For example, the kernel could have been in the middle of processing important data when the oops occurred. It might have held a lock or been in the middle of talking to hardware. The kernel must gracefully back out of its current context and try to resume control of the system. In many cases, this is not possible. If the oops occurred in interrupt context, the kernel cannot continue and it panics. A panic results in an instant halt of the system. If the oops occurred in the idle task (pid zero) or the init task (pid one), the result is also a panic because the kernel cannot continue without these important processes. If the oops occurs in any other process, however, the kernel kills the process and tries to continue executing.</p><div class="calibre_3"> </div>
<p class="calibre_2">An oops might occur for multiple reasons, including a memory access violation or an illegal instruction. As a kernel developer, you will often deal with (and undoubtedly cause) oopses.</p><div class="calibre_3"> </div>
<p class="calibre_2">What follows is an oops example from a PPC machine, in the timer handler of the tulip network interface card:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00246.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">PC users might marvel at the number of registers (a whopping 32!). An oops on x86-32, which you might be more familiar with, is a little simpler. The important information, however, is identical for all the architectures: the contents of the registers and the back trace.</p><div class="calibre_3"> </div>
<p class="calibre_2">The back trace shows the exact function call chain leading up to the problem. In this case, you can see exactly what happened: The machine was idle and executing the idle loop, <code class="calibre6"><span class="calibre7">cpu_idle()</span></code>, which calls <code class="calibre6"><span class="calibre7">default_idle()</span></code> in a loop. The timer interrupt occurred, which resulted in the processing of timers. A timer handler, the <code class="calibre6"><span class="calibre7">tulip_timer()</span></code> function, was executed, which performed a <code class="calibre6"><span class="calibre7">NULL</span></code> pointer dereference. You can even use the offsets (those numbers such as <em class="calibre4">0x128/0x1c4</em> to the right of the functions) to find exactly the offending line.</p><div class="calibre_3"> </div>
<p class="calibre_2">The register contents can be equally useful, although less commonly so. With a decoded copy of the function in assembly, the register values help you re-create the exact events leading to the problem. Seeing an unexpected value in a register might shine some light on the root of the issue. In this case, you can see which registers held <code class="calibre6"><span class="calibre7">NULL</span></code> (a value <a id="filepos1220538"></a>of all zeros) and discover which variable in the function had the unexpected value. In situations such as this, the problem is often a race—in this case, between the timer and some other part of this network card. Debugging a race condition is always a challenge.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1220858"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">ksymoops</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The previous oops is said to be <em class="calibre4">decoded</em> because the memory addresses are translated into the functions they represent. An undecoded version of the previous oops is shown here:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00247.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The addresses in the back trace need to be converted into symbolic names. This is done via the <code class="calibre6"><span class="calibre7">ksymoops</span></code> command in conjunction with the <code class="calibre6"><span class="calibre7">System.map</span></code> generated during kernel compile. If you use modules, you also need some module information. <code class="calibre6"><span class="calibre7">ksymoops</span></code> tries to figure out most of this information, so you can usually invoke it via</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">ksymoops saved_oops.txt</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The program then spits out a decoded version of the oops. If the default information <code class="calibre6"><span class="calibre7">ksymoops</span></code> uses is unacceptable, or you want to provide alternative locations for the information, the program understands various options. <code class="calibre6"><span class="calibre7">ksymoops</span></code>’ manual page has a lot of information that you should read before using it. The <code class="calibre6"><span class="calibre7">ksymoops</span></code> program most likely came with your distribution.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1222465"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">kallsyms</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Thankfully, dealing with <code class="calibre6"><span class="calibre7">ksymoops</span></code> is no longer a requirement. This is a big deal, because although developers might have had little problem using it, end users often mismatched <code class="calibre6"><span class="calibre7">System.map</span></code> files or failed to decode oopses altogether.</p><div class="calibre_3"> </div>
<p class="calibre_2">The 2.5 development kernel introduced the <code class="calibre6"><span class="calibre7">kallsyms</span></code> feature, which is enabled via the <code class="calibre6"><span class="calibre7">CONFIG_KALLSYMS</span></code> configuration option. This option stores in the kernel the symbolic name of function addresses mapped into the kernel image so that the kernel can print decoded back traces. Consequently, decoding oopses no longer requires <code class="calibre6"><span class="calibre7">System.map</span></code> or <code class="calibre6"><span class="calibre7">ksymoops</span></code>. On the downside, the size of the kernel increases a bit because the address-to-symbol mappings must reside in permanently mapped kernel memory. It is worth the memory use, however, during not only development but also deployment. The configuration option <code class="calibre6"><span class="calibre7">CONFIG_KALLSYMS_ALL</span></code> additionally stores the symbolic name of all symbols, not only functions. This is generally needed only by specialized debuggers. <a id="filepos1223891"></a>The <code class="calibre6"><span class="calibre7">CONFIG_KALLSYMS_EXTRA_PASS</span></code> option causes the kernel build process to make a second pass over the kernel’s object code. It is useful only when debugging <code class="calibre6"><span class="calibre7">kallsyms</span></code> itself.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1224190"> </div>
<h3 class="calibre_21"><span class="bold">Kernel Debugging Options</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Multiple configure options that you can set during compile to aid in debugging and testing kernel code are available. These options are in the Kernel Hacking menu of the Kernel Configuration Editor. They all depend on <code class="calibre6"><span class="calibre7">CONFIG_DEBUG_KERNEL</span></code>. When hacking on the kernel, consider enabling as many of these options as practical.</p><div class="calibre_3"> </div>
<p class="calibre_2">Some of the options are rather useful, enabling slab layer debugging, high-memory debugging, I/O mapping debugging, spin-lock debugging, and stack-overflow checking. One of the most useful settings, however, is sleep-inside-spinlock checking, which actually does much more.</p><div class="calibre_3"> </div>
<p class="calibre_2">Starting with 2.5, the kernel has an excellent infrastructure for detecting all sorts of atomicity violations. Recall from <a href="index_split_018.html#filepos575425">Chapter 9</a>, “An Introduction to Kernel Synchronization,” that <em class="calibre4">atomic</em> refers to something’s capability to execute without division; the code completes without interruption or it does not complete at all. Code that holds a spin lock or has disabled kernel preemption is atomic. Code cannot sleep while atomic—sleeping while holding a lock is a recipe for deadlock.</p><div class="calibre_3"> </div>
<p class="calibre_2">Thanks to kernel preemption, the kernel has a central atomicity counter. The kernel can be set such that if a task sleeps while atomic, or even does something that <em class="calibre4">might</em> sleep, the kernel prints a warning and provides a back trace. Potential bugs that are detectable include calling <code class="calibre6"><span class="calibre7">schedule()</span></code> while holding a lock, issuing a blocking memory allocation while holding a lock, or sleeping while holding a reference to per-CPU data. This debugging infrastructure catches a lot of bugs and is highly recommended.</p><div class="calibre_3"> </div>
<p class="calibre_2">The following options make the best use of this feature:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">CONFIG_PREEMPT=y<br class="calibre1"/>CONFIG_DEBUG_KERNEL=y<br class="calibre1"/>CONFIG_KALLSYMS=y<br class="calibre1"/>CONFIG_DEBUG_SPINLOCK_SLEEP=y</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1226556"> </div>
<h3 class="calibre_21"><span class="bold">Asserting Bugs and Dumping Information</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">A number of kernel routines make it easy to flag bugs, provide assertions, and dump information. Two of the most common are <code class="calibre6"><span class="calibre7">BUG()</span></code> and <code class="calibre6"><span class="calibre7">BUG_ON()</span></code>. When called, they cause an oops, which results in a stack trace and an error message dumped to the kernel. Why these statements cause an oops is architecture-dependent. Most architectures define <code class="calibre6"><span class="calibre7">BUG()</span></code> and <code class="calibre6"><span class="calibre7">BUG_ON()</span></code> as illegal instructions, which result in the desired oops. You normally use these routines as assertions, to flag situations that should not happen:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">if (bad_thing)<br class="calibre1"/>        BUG();</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos1227570"></a>Or even better</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">BUG_ON(bad_thing);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Most kernel developers believe that <code class="calibre6"><span class="calibre7">BUG_ON()</span></code> is easier to read and more self-documenting compared to <code class="calibre6"><span class="calibre7">BUG()</span></code>. Also, <code class="calibre6"><span class="calibre7">BUG_ON()</span></code> wraps its assertion in an <code class="calibre6"><span class="calibre7">unlikely()</span></code> statement. Do note that some developers have discussed the idea of having an option to compile <code class="calibre6"><span class="calibre7">BUG_ON()</span></code> statements away, saving space in embedded kernels. This means that your assertion inside a <code class="calibre6"><span class="calibre7">BUG_ON()</span></code> should not have any side effects. The macro <code class="calibre6"><span class="calibre7">BUILD_BUG_ON()</span></code> performs the same purpose, but at compile time. If the provided statement evaluates to true at compile time, the compilation aborts with an error.</p><div class="calibre_3"> </div>
<p class="calibre_2">A more critical error is signaled via <code class="calibre6"><span class="calibre7">panic()</span></code>. A call to <code class="calibre6"><span class="calibre7">panic()</span></code> prints an error message and then halts the kernel. Obviously, you want to use it only in the worst of situations:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">if (terrible_thing)<br class="calibre1"/>        panic("terrible_thing is %ld!\n", terrible_thing);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Sometimes, you just want a simple stack trace issued on the console to help you in debugging. In those cases, <code class="calibre6"><span class="calibre7">dump_stack()</span></code> is used. It simply dumps the contents of the registers and a function back trace to the console:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">if (!debug_check) {<br class="calibre1"/>        printk(KERN_DEBUG "provide some information...\n");<br class="calibre1"/>        dump_stack();<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1229748"> </div>
<h3 class="calibre_21"><span class="bold">Magic <code class="calibre18"><span class="calibre15">SysRq</span></code> Key</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">A possible lifesaver is the Magic <code class="calibre6"><span class="calibre7">SysRq</span></code> key, which is enabled via the <code class="calibre6"><span class="calibre7">CONFIG_MAGIC_SYSRQ</span></code> configure option. The <code class="calibre6"><span class="calibre7">SysRq</span></code> (system request) key is a standard key on most keyboards. On the i386 and PPC, it is accessible via Alt+PrintScreen. When this configure option is enabled, special combinations of keys enable you to communicate with the kernel regardless of what else it is doing. This enables you to perform some useful tasks in the face of a dying system.</p><div class="calibre_3"> </div>
<p class="calibre_2">In addition to the configure option, there is a sysctl to toggle this feature on and off. To turn it on:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">echo 1 &gt; /proc/sys/kernel/sysrq</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">From the console, you can hit <code class="calibre6"><span class="calibre7">SysRq-h</span></code> for a list of available options. <code class="calibre6"><span class="calibre7">SysRq-s</span></code> syncs dirty buffers to disk, <code class="calibre6"><span class="calibre7">SysRq-u</span></code> unmounts all filesystems, and <code class="calibre6"><span class="calibre7">SysRq-b</span></code> reboots the machine. Issuing these three key combinations in a row is a safer way to reboot a dying machine than simply hitting the machine reset switch.</p><div class="calibre_3"> </div>
<p class="calibre_2">If the machine is badly locked, it might not respond to any Magic <code class="calibre6"><span class="calibre7">SysRq</span></code> combinations, or it might fail to complete a given command. With luck, however, these options might save your data or aid in debugging. <a href="#filepos1231767">Table 18.2</a> is a listing of the supported <code class="calibre6"><span class="calibre7">SysRq</span></code> commands.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1231716"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1231767"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Table 18.2. Supporting <code class="calibre6"><span class="calibre15">SysRq</span></code> Commands</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00248.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The file <code class="calibre6"><span class="calibre7">Documentation/sysrq.txt</span></code> in the kernel source tree has more information. The actual implementation is in <code class="calibre6"><span class="calibre7">drivers/char/sysrq.c</span></code>. The Magic <code class="calibre6"><span class="calibre7">SysRq</span></code> Key is a vital tool for aiding in debugging or saving a dying system. Because it provides powerful capabilities to any user on the console, however, you should exercise caution on important machines. For your development machine, however, it is a great help.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1232654"> </div>
<h3 class="calibre_21"><span class="bold">The Saga of a Kernel Debugger</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Many kernel developers have long demanded an in-kernel debugger. Unfortunately, Linus does not want a debugger in his tree. He believes that debuggers lead to bad fixes by misinformed developers. No one can argue with his logic—a fix derived from real understanding of the code is certainly more likely to be correct. Nonetheless, plenty of kernel developers want an official in-kernel debugger. Because it is unlikely to happen anytime soon, a number of patches have arisen that add kernel-debugging support to the standard Linux kernel. Despite being external unofficial patches, these tools are quite well featured and powerful. Before you delve into these solutions, however, it’s a good idea to look at how much help the standard Linux debugger, <code class="calibre6"><span class="calibre7">gdb</span></code>, can give you.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1233653"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">gdb</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2">You can use the standard GNU debugger to glimpse inside a running kernel. Starting the debugger on the kernel is about the same as debugging a running process:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">gdb vmlinux /proc/kcore</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos1234129"></a>The <code class="calibre6"><span class="calibre7">vmlinux</span></code> file is the uncompressed kernel image stored in the root of the build directory, not the compressed <code class="calibre6"><span class="calibre7">zImage</span></code> or <code class="calibre6"><span class="calibre7">bzImage</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">The optional <code class="calibre6"><span class="calibre7">/proc/kcore</span></code> parameter acts as a core file, to let <code class="calibre6"><span class="calibre7">gdb</span></code> actually peek into the memory of the running kernel. You need to be root to read it.</p><div class="calibre_3"> </div>
<p class="calibre_2">You can issue just about any of the <code class="calibre6"><span class="calibre7">gdb</span></code> commands for reading information. For example, to print the value of a variable:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">p global_variable</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">To disassemble a function:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">disassemble function</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If you compile the kernel with the <code class="calibre6"><span class="calibre7">-g</span></code> flag (add <code class="calibre6"><span class="calibre7">-g</span></code> to the <code class="calibre6"><span class="calibre7">CFLAGS</span></code> variable in the kernel <code class="calibre6"><span class="calibre7">Makefile</span></code>), <code class="calibre6"><span class="calibre7">gdb</span></code> can provide much more information. For example, you can dump the contents of structures and follow pointers. You also get a much larger kernel, so do not routinely compile with debugging information included.</p><div class="calibre_3"> </div>
<p class="calibre_2">Unfortunately, this is about the limit of what <code class="calibre6"><span class="calibre7">gdb</span></code> can do. It cannot modify kernel data in any way. It is unable to single-step through kernel code or set breakpoints. The inability to modify kernel data structures is a large downside. Although it is undoubtedly useful for it to disassemble functions on occasion, it would be much more useful if it could modify data, too.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1236209"> </div>
<h4 class="calibre_27"><span class="calibre3"><code class="calibre6"><span class="calibre7">kgdb</span></code></span></h4><div class="calibre_24"> </div>
<p class="calibre_2"><code class="calibre6"><span class="calibre7">kgdb</span></code> is a patch that enables <code class="calibre6"><span class="calibre7">gdb</span></code> to fully debug the kernel remotely over a serial line. It requires two computers. The first runs a kernel patched with <code class="calibre6"><span class="calibre7">kgdb</span></code>. The second debugs the first over the serial line (a null modem cable connecting the two machines) using <code class="calibre6"><span class="calibre7">gdb</span></code>. With <code class="calibre6"><span class="calibre7">kgdb</span></code>, the entire feature set of <code class="calibre6"><span class="calibre7">gdb</span></code> is accessible: reading and writing any variables, settings breakpoints, setting watch points, single stepping, and so on! Special versions of <code class="calibre6"><span class="calibre7">kgdb</span></code> even enable function execution.</p><div class="calibre_3"> </div>
<p class="calibre_2">Setting up <code class="calibre6"><span class="calibre7">kgdb</span></code> and the serial line is a little tricky, but when complete, debugging is simple. The patch installs plenty of documentation in <code class="calibre6"><span class="calibre7">Documentation/</span></code>—check it out.</p><div class="calibre_3"> </div>
<p class="calibre_2">Different people maintain the <code class="calibre6"><span class="calibre7">kgdb</span></code> patch for various architectures and kernel releases. Searching online is your best bet for finding a patch for a given kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1237676"> </div>
<h3 class="calibre_21"><span class="bold">Poking and Probing the System</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">As you gain experience in kernel debugging, you gain little tricks to help you poke and probe the kernel for answers. Because kernel debugging can prove rather challenging, every little tip and trick helps. Let’s look at a couple.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1238095"> </div>
<h4 class="calibre_27"><span class="calibre3">Using UID as a Conditional</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">If the code you are developing is process-related, sometimes you can develop alternative implementations without breaking the existing code. This is helpful if you are rewriting an important system call and would like a fully functional system with which to debug it. <a id="filepos1238491"></a>For example, assume you are rewriting the <code class="calibre6"><span class="calibre7">fork()</span></code> algorithm to take advantage of an exciting new feature. Unless you get everything right on the first try, it would not be easy to debug the system: A nonfunctioning <code class="calibre6"><span class="calibre7">fork()</span></code> system call is certain to result in a nonfunctioning system. As always, there is hope.</p><div class="calibre_3"> </div>
<p class="calibre_2">Often, it is safe to keep the remaining algorithm in place and construct your replacement on the side. You can achieve this by using the user id (UID) as a conditional with which to decide which algorithm to use:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">if (current-&gt;uid != 7777) {<br class="calibre1"/>    /* old algorithm .. */<br class="calibre1"/>} else {<br class="calibre1"/>    /* new algorithm .. */<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">All users except UID 7777 will use the old algorithm. You can create a special user, with UID 7777, for testing the new algorithm. This makes it much easier to test critical process-related code.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1239682"> </div>
<h4 class="calibre_27"><span class="calibre3">Using Condition Variables</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">If the code in question is not in process context, or if you want a more global method of controlling the feature, you can use a condition variable. This approach is even simpler than using the UID. Simply create a global variable and use it as a conditional check in your code. If the variable is zero, you follow one code path. If it is nonzero, you follow another. The variable can be set via an interface you export or a poke from the debugger.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1240308"> </div>
<h4 class="calibre_27"><span class="calibre3">Using Statistics</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Sometimes you want to get a feel for how often a specific event occurs. Sometimes you want to compare multiple events and generate some ratios for comparison. You can do this easily by creating statistics and a mechanism to export their values.</p><div class="calibre_3"> </div>
<p class="calibre_2">For instance, say you want to look at the occurrence of <em class="calibre4">foo</em> and the occurrence of <em class="calibre4">bar</em>. In a file, ideally the one where these events occur, declare two global variables:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">unsigned long foo_stat = 0;<br class="calibre1"/>unsigned long bar_stat = 0;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">For each occurrence of these events, increment the appropriate variable. Then export the data however you feel fit. For example, you can create a file in <code class="calibre6"><span class="calibre7">/proc</span></code> with the values or write a system call. Alternatively, simply read them via a debugger.</p><div class="calibre_3"> </div>
<p class="calibre_2">Note that this approach is not particularly SMP-safe. Ideally, you would use atomic operations. For a trivial one-time debugging statistic, however, you normally do not need such protection.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1241695"> </div>
<h4 class="calibre_27"><span class="calibre3">Rate and Occurrence Limiting Your Debugging</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1241840"> </div>
<p class="calibre_2">Often, you want to stick some debugging checks (with some corresponding print statements) in an area to sniff out a problem. In the kernel, however, some functions are called many times per second. If you stick a call to <code class="calibre6"><span class="calibre7">printk()</span></code> in such a function, the system is overwhelmed with debugging output and quickly grows unusable.</p><div class="calibre_3"> </div>
<p class="calibre_2">Two relatively simple tricks exist to prevent this problem. The first is <em class="calibre4">rate limiting</em>, which is useful when you want to watch the progression of an event, but the event occurs rather often. To prevent a deluge of debugging output, you print your debug message (or do whatever you are doing) only every few seconds. For example</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00249.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">In this example, the debug message is printed at most every 2 seconds. This prevents any flood of information on the console, and the computer remains usable. You might need the rate limiting to be larger or smaller, depending on your needs.</p><div class="calibre_3"> </div>
<p class="calibre_2">If you are <em class="calibre4">only</em> using <code class="calibre6"><span class="calibre7">printk()</span></code>, you can use a special function to rate limit your <code class="calibre6"><span class="calibre7">printk()</span></code> calls:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">if (error &amp;&amp; printk_ratelimit())<br class="calibre1"/>        printk(KERN_DEBUG "error=%d\n", error);</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">printk_ratelimit()</span></code> function returns zero if rate limiting is in effect and nonzero otherwise. By default, the function allows only one message every 5 seconds but allows an initial burst of up to ten messages before that cap is enforced. These parameters are tunable via the <code class="calibre6"><span class="calibre7">printk_ratelimit</span></code> and <code class="calibre6"><span class="calibre7">printk_ratelimit_burst sysctl</span></code>, respectively.</p><div class="calibre_3"> </div>
<p class="calibre_2">Another sticky situation arises if you try to determine if a codepath is exercised in a particular way. Unlike the previous example, you do not want real-time notification. This is an especially sticky situation if it is of the sort where if it is triggered once, it is triggered a lot. The solution here is not to rate limit the debugging, but <em class="calibre4">occurrence limit</em> it:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">static unsigned long limit = 0;<br class="calibre1"/><br class="calibre1"/>if (limit &lt; 5) {<br class="calibre1"/>    limit++;<br class="calibre1"/>    printk(KERN_ERR "blah blah blah\n");<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">This example caps the debugging output to five. After five such messages, the conditional is always false.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos1244884"></a>In both examples, the variables should be <code class="calibre6"><span class="calibre7">static</span></code> and local to the function, as shown. This enables the variable’s values to persist across function calls.</p><div class="calibre_3"> </div>
<p class="calibre_2">Neither of these examples are SMP- or preempt-safe, although a quick switch to atomic operators makes them safe. For temporary debugging checks, you often need not be so fastidious.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1245362"> </div>
<h3 class="calibre_21"><span class="bold">Binary Searching to Find the Culprit Change</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">It is usually useful to know when a bug was introduced into the kernel source. If you know that a bug occurred in version 2.6.33, but not 2.4.29, you have a clear picture of the changes that occurred to cause the bug. The bug fix is often as simple as reverting or otherwise fixing the bad change.</p><div class="calibre_3"> </div>
<p class="calibre_2">Many times, however, you do not know what kernel version introduced the bug. You know that the bug is in the <em class="calibre4">current</em> kernel, but it seemed to have always been in the current kernel! With a little effort, you can find the offending change. With the change in hand, the bug fix is usually near.</p><div class="calibre_3"> </div>
<p class="calibre_2">To start, you need a reliably reproducible problem—preferably, a bug that you can verify immediately after boot. Next, you need a known-good kernel. You might already know this. For example, if you know a couple months back the kernel worked, grab a kernel from that period. If you are wrong, try an earlier release. It shouldn’t be too hard to find a kernel without the bug.</p><div class="calibre_3"> </div>
<p class="calibre_2">Next, you need a known-bad kernel. To make things easier, start with the earliest kernel you know to have the bug.</p><div class="calibre_3"> </div>
<p class="calibre_2">Now, you begin a binary search from the known-bad kernel down to the known-good kernel. Let’s look at an example. Assume the latest known-good kernel is 2.6.11 and the earliest known-bad is 2.6.20. Start by picking a kernel in the middle, such as 2.6.15. Test 2.6.15 for the bug. If 2.6.15 works, you know the problem began in a later kernel, so try a kernel in between 2.6.15 and 2.6.20—say, 2.6.17. On the other hand, if 2.6.15 does not work, you know the problem is in an earlier kernel, so you might try 2.6.13. Rinse and repeat.</p><div class="calibre_3"> </div>
<p class="calibre_2">Eventually you should narrow the problem down to two subsequently released kernels—one of which has the bug and one of which does not. You then have a clear picture of the changes that caused the bug. This approach beats looking at every kernel!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1247709"> </div>
<h3 class="calibre_21"><span class="bold">Binary Searching with Git</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The git source management tool provides a useful mechanism for performing binary searches. If you use git to control your copy of the Linux source tree, it can automate the binary search process. Moreover, the git tool performs the binary search at the <em class="calibre4">revision level</em>, actually pinpointing the specific commit that introduced the bug. Unlike many git-related tasks, binary searching with git is not hard. To start, you tell git you want to begin a binary search:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git bisect start</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos1248480"></a>You then provide git with the earliest broken revision:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git bisect bad &lt;revision&gt;</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If the latest version of the kernel is your known-earliest offender, you do not need to provide a revision:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git bisect bad</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">You then provide git with the latest working revision:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git bisect good v2.6.28</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Git then automatically checks out the Linux source tree bisecting the provided bad and good revisions. You then compile, run, and test that revision. If it works, you run:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git bisect good</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">If it does not work—that is, if the given kernel revision demonstrates the bug—you run</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git bisect bad</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">On each command, git again bisects the tree on a per-revision basis, returning the next bisection as needed. You repeat the process until there are no more bisections possible. Git then prints the offending revision number.</p><div class="calibre_3"> </div>
<p class="calibre_2">This can be a long process, but git does make it easy. If you think you know the source of the bug—say, it is clear in x86-specific boot code—you can instruct git to only bisect among commits touching a specified list of directories:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">$ git bisect start — arch/x86</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1250550"> </div>
<h3 class="calibre_21"><span class="bold">When All Else Fails: The Community</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Perhaps you have tried everything that you can think of. You have slaved over the keyboard for countless hours—indeed, perhaps countless days—and the solution still escapes you. If the bug is in the mainstream Linux kernel, you can always elicit the help of the other developers in the kernel community.</p><div class="calibre_3"> </div>
<p class="calibre_2">A brief, but complete, email sent to the kernel mailing list describing the bug and your findings might help aid in discovery of a solution. After all, no one likes bugs.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a href="index_split_029.html#filepos1300073">Chapter 20</a>, “Patches, Hacking, and the Community,” specifically addresses the community and its primary forum, the Linux Kernel Mailing List (LKML).</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1251512"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos1251625"> </div>
<p class="calibre_2">This chapter covered debugging the kernel, the process of determining <em class="calibre4">why</em> implementation diverges from intention. We looked at several techniques, from built-in kernel debug infrastructure to debuggers, from logging to binary searching with git. Because debugging the Linux kernel can be a significantly more difficult task than debugging a user-space application, the material in this chapter is crucial to anyone intending to actually write kernel code.</p><div class="calibre_3"> </div>
<p class="calibre_2">In the next chapter, we cover another general topic: portability in the Linux kernel. Onward!</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_78"></div>
</body></html>
