<?xml version="1.0" encoding="utf-8"?><html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/"><head>
<meta name="dcterms.conformsTo" content="PXE Basic 1.0"></meta>
<meta name="generator" content="PXE Tools version 1.39.109"></meta>
<!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.109, partial=false-->
<title>2.7 Socket Programming: Creating Network Applications</title><link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/sepia.css"></link><link rel="alternate stylesheet" type="text/css" title="night" href="../css/night.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/main.css"></link><link rel="stylesheet" type="text/css" title="day" href="../css/print.css"></link></head><body epub:type="bodymatter">
<section id="P7001011952000000000000000000E42" class="level1"><header><h1 class="title" id="P7001011952000000000000000009E72" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E72" epub:type="title"><span class="number">2.7</span> Socket Programming: Creating Network Applications</h1></header>
<p id="P7001011952000000000000000009E73" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E73">Now that we’ve looked at a number of important network applications, let’s explore how network application programs are actually created. Recall from <a class="xref" href="fileP7001011952000000000000000000974.xhtml#P7001011952000000000000000000974" data-foobar="7"><span class="label">Section</span> <span class="number">2.1</span></a> that a typical network application consists of a pair of programs—a client program and a server program—residing in two different end systems. When these two programs are executed, a client process and a server process are created, and these processes communicate with each other by reading from, and writing to, sockets. When creating a network application, the developer’s main task is therefore to write the code for both the client and server programs.</p>
<p id="P7001011952000000000000000009E74" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E74"><span class="pagebreak" title="158" id="P7001011952000000000000000000E46" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E46" epub:type="pagebreak" role="doc-pagebreak"></span>There are two types of network applications. One type is an implementation whose operation is specified in a protocol standard, such as an RFC or some other standards document; such an application is sometimes referred to as “open,” since the rules specifying its operation are known to all. For such an implementation, the client and server programs must conform to the rules dictated by the RFC. For example, the client program could be an implementation of the client side of the HTTP protocol, described in <a class="xref" href="fileP7001011952000000000000000000A27.xhtml#P7001011952000000000000000000A27" data-foobar="7"><span class="label">Section</span> <span class="number">2.2</span></a> and precisely defined in RFC 2616; similarly, the server program could be an implementation of the HTTP server protocol, also precisely defined in RFC 2616. If one developer writes code for the client program and another developer writes code for the server program, and both developers carefully follow the rules of the RFC, then the two programs will be able to interoperate. Indeed, many of today’s network applications involve communication between client and server programs that have been created by independent developers—for example, a Google Chrome browser communicating with an Apache Web server, or a BitTorrent client communicating with BitTorrent tracker.</p>
<p id="P7001011952000000000000000009E75" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E75">The other type of network application is a proprietary network application. In this case the client and server programs employ an application-layer protocol that has <i>not</i> been openly published in an RFC or elsewhere. A single developer (or development team) creates both the client and server programs, and the developer has complete control over what goes in the code. But because the code does not implement an open protocol, other independent developers will not be able to develop code that interoperates with the application.</p>
<p id="P7001011952000000000000000009E76" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E76">In this section, we’ll examine the key issues in developing a client-server application, and we’ll “get our hands dirty” by looking at code that implements a very simple client-server application. During the development phase, one of the first decisions the developer must make is whether the application is to run over TCP or over UDP. Recall that TCP is connection oriented and provides a reliable byte-stream channel through which data flows between two end systems. UDP is connectionless and sends independent packets of data from one end system to the other, without any guarantees about delivery. Recall also that when a client or server program implements a protocol defined by an RFC, it should use the well-known port number associated with the protocol; conversely, when developing a proprietary application, the developer must be careful to avoid using such well-known port numbers. (Port numbers were briefly discussed in <a class="xref" href="fileP7001011952000000000000000000974.xhtml#P7001011952000000000000000000974" data-foobar="7"><span class="label">Section</span> <span class="number">2.1</span></a>. They are covered in more detail in <a class="xref" href="fileP70010119520000000000000000010EC.xhtml#P70010119520000000000000000010EC" data-foobar="7"><span class="label">Chapter</span> <span class="number">3</span></a>.)</p>
<p id="P7001011952000000000000000009E77" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E77">We introduce UDP and TCP socket programming by way of a simple UDP application and a simple TCP application. We present the simple UDP and TCP applications in Python 3. We could have written the code in Java, C, or C++, but we chose Python mostly because Python clearly exposes the key socket concepts. With Python there are fewer lines of code, and each line can be explained to the novice programmer without difficulty. But there’s no need to be frightened if you are not familiar with Python. You should be able to easily follow the code if you have experience programming in Java, C, or C++.</p>
<p id="P7001011952000000000000000009E78" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E78"><span class="pagebreak" title="159" id="P7001011952000000000000000000E4B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E4B" epub:type="pagebreak" role="doc-pagebreak"></span>If you are interested in client-server programming with Java, you are encouraged to see the Companion Website for this textbook; in fact, you can find there all the examples in this section (and associated labs) in Java. For readers who are interested in client-server programming in C, there are several good references available <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P70010119520000000000000000038D6" data-foobar="7">[Donahoo 2001</a>; <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003C28" data-foobar="7">Stevens 1997</a>; <a class="biblioref" href="fileP70010119520000000000000000037E0.xhtml#P7001011952000000000000000003915" data-foobar="7">Frost 1994</a>; Kurose 1996]; our Python examples below have a similar look and feel to C.</p>
<section id="P7001011952000000000000000000E4C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E4C" class="level2"><header><h1 class="title" id="P7001011952000000000000000009E79" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E79" epub:type="title"><span class="number">2.7.1</span> Socket Programming with UDP</h1></header>
<p id="P7001011952000000000000000009E7A" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E7A">In this subsection, we’ll write simple client-server programs that use UDP; in the following section, we’ll write similar programs that use TCP.</p>
<p id="P7001011952000000000000000009E7B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E7B">Recall from <a class="xref" href="fileP7001011952000000000000000000974.xhtml#P7001011952000000000000000000974" data-foobar="7"><span class="label">Section</span> <span class="number">2.1</span></a> that processes running on different machines communicate with each other by sending messages into sockets. We said that each process is analogous to a house and the process’s socket is analogous to a door. The application resides on one side of the door in the house; the transport-layer protocol resides on the other side of the door in the outside world. The application developer has control of everything on the application-layer side of the socket; however, it has little control of the transport-layer side.</p>
<p id="P7001011952000000000000000009E7C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E7C">Now let’s take a closer look at the interaction between two communicating processes that use UDP sockets. Before the sending process can push a packet of data out the socket door, when using UDP, it must first attach a destination address to the packet. After the packet passes through the sender’s socket, the Internet will use this destination address to route the packet through the Internet to the socket in the receiving process. When the packet arrives at the receiving socket, the receiving process will retrieve the packet through the socket, and then inspect the packet’s contents and take appropriate action.</p>
<p id="P7001011952000000000000000009E7D" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E7D">So you may be now wondering, what goes into the destination address that is attached to the packet? As you might expect, the destination host’s IP address is part of the destination address. By including the destination IP address in the packet, the routers in the Internet will be able to route the packet through the Internet to the destination host. But because a host may be running many network application processes, each with one or more sockets, it is also necessary to identify the particular socket in the destination host. When a socket is created, an identifier, called a <b>port number</b>, is assigned to it. So, as you might expect, the packet’s destination address also includes the socket’s port number. In summary, the sending process attaches to the packet a destination address, which consists of the destination host’s IP address and the destination socket’s port number. Moreover, as we shall soon see, the sender’s source address—consisting of the IP address of the source host and the port number of the source socket—are also attached to the packet. However, attaching the source address to the packet is typically <i>not</i> done by the UDP application code; instead it is automatically done by the underlying operating system.</p>
<p id="P7001011952000000000000000009E7E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E7E"><span class="pagebreak" title="160" id="P7001011952000000000000000000E53" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E53" epub:type="pagebreak" role="doc-pagebreak"></span>We’ll use the following simple client-server application to demonstrate socket programming for both UDP and TCP:</p>
<ol id="P7001011952000000000000000009E7F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E7F">
<li id="P7001011952000000000000000009E80" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E80"><p id="P7001011952000000000000000009E81" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E81">The client reads a line of characters (data) from its keyboard and sends the data to the server.</p></li>
<li id="P7001011952000000000000000009E82" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E82"><p id="P7001011952000000000000000009E83" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E83">The server receives the data and converts the characters to uppercase.</p></li>
<li id="P7001011952000000000000000009E84" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E84"><p id="P7001011952000000000000000009E85" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E85">The server sends the modified data to the client.</p></li>
<li id="P7001011952000000000000000009E86" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E86"><p id="P7001011952000000000000000009E87" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E87">The client receives the modified data and displays the line on its screen.</p></li>
</ol>
<p class="continued" id="P7001011952000000000000000009E88" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E88"><a class="xref" href="#P7001011952000000000000000000E5F" data-foobar="1"><span class="label">Figure</span> <span class="number">2.27</span></a> highlights the main socket-related activity of the client and server that communicate over the UDP transport service.</p>
<p id="P7001011952000000000000000009E89" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E89">Now let’s get our hands dirty and take a look at the client-server program pair for a UDP implementation of this simple application. We also provide a detailed, line-by-line analysis after each program. We’ll begin with the UDP client, which will send a simple application-level message to the server. In order for</p>
<figure id="P7001011952000000000000000000E5F" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E5F">
<img alt="Illustration of a client-server application using UDP." height="571" width="673" aria-describedby="P7001011952000000000000000000E63" id="P7001011952000000000000000009E8A" data-uri="P7001011952000000000000000005539" src="../images/4055102027.png"></img>
<figcaption id="P7001011952000000000000000009E8B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E8B"><header><h1 class="title" id="P7001011952000000000000000009E8C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009E8C" epub:type="title"><span class="label">Figure </span><span class="number">2.27</span> The client-server application using UDP</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000000E63" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E63" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055102027.xhtml#la_4055102027"><span class="label">Description</span></a></div>
<p class="continued" id="P7001011952000000000000000009EA7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EA7"><span class="pagebreak" title="161" id="P7001011952000000000000000000E7F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E7F" epub:type="pagebreak" role="doc-pagebreak"></span>the server to be able to receive and reply to the client’s message, it must be ready and running—that is, it must be running as a process before the client sends its message.</p>
<p id="P7001011952000000000000000009EA8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EA8">The client program is called UDPClient.py, and the server program is called UDPServer.py. In order to emphasize the key issues, we intentionally provide code that is minimal. “Good code” would certainly have a few more auxiliary lines, in particular for handling error cases. For this application, we have arbitrarily chosen 12000 for the server port number.</p>
<section id="P7001011952000000000000000000E81" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E81" class="level3"><header><h1 class="title" id="P7001011952000000000000000009EA9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EA9" epub:type="title">UDPClient.py</h1></header>
<p id="P7001011952000000000000000009EAA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EAA">Here is the code for the client side of the application:</p>
<pre id="P7001011952000000000000000009EAB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EAB"><code id="P7001011952000000000000000009EAC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EAC">from socket import *
serverName = ’hostname’
serverPort = 12000
clientSocket = socket(AF_INET, SOCK_DGRAM)
message = raw_input(’Input lowercase sentence:’)
clientSocket.sendto(message.encode(),(serverName, serverPort))
modifiedMessage, serverAddress = clientSocket.recvfrom(2048)
print(modifiedMessage.decode())
clientSocket.close()</code></pre>
<p class="continued" id="P7001011952000000000000000009EAD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EAD">Now let’s take a look at the various lines of code in UDPClient.py.</p>
<pre id="P7001011952000000000000000009EAE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EAE"><code id="P7001011952000000000000000009EAF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EAF">from socket import *</code></pre>
<p id="P7001011952000000000000000009EB0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB0">The <code id="P7001011952000000000000000009EB1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB1">socket</code> module forms the basis of all network communications in Python. By including this line, we will be able to create sockets within our program.</p>
<pre id="P7001011952000000000000000009EB2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB2"><code id="P7001011952000000000000000009EB3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB3">serverName = ’hostname’
serverPort = 12000</code></pre>
<p class="continued" id="P7001011952000000000000000009EB4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB4">The first line sets the variable <code id="P7001011952000000000000000009EB5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB5">serverName</code> to the string ‘hostname’. Here, we provide a string containing either the IP address of the server (e.g., “128.138.32.126”) or the hostname of the server (e.g., “cis.poly.edu”). If we use the hostname, then a DNS lookup will automatically be performed to get the IP address.) The second line sets the integer variable <code id="P7001011952000000000000000009EB6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB6">serverPort</code> to 12000.</p>
<pre id="P7001011952000000000000000009EB7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB7"><code id="P7001011952000000000000000009EB8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB8">clientSocket = socket(AF_INET, SOCK_DGRAM)</code></pre>
<p class="continued" id="P7001011952000000000000000009EB9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EB9"><span class="pagebreak" title="162" id="P7001011952000000000000000000E93" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000E93" epub:type="pagebreak" role="doc-pagebreak"></span>This line creates the client’s socket, called <code id="P7001011952000000000000000009EBA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EBA">clientSocket</code>. The first parameter indicates the address family; in particular, <code id="P7001011952000000000000000009EBB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EBB">AF_INET</code> indicates that the underlying network is using IPv4. (Do not worry about this now—we will discuss IPv4 in <a class="xref" href="fileP70010119520000000000000000019C1.xhtml#P70010119520000000000000000019C1" data-foobar="7"><span class="label">Chapter</span> <span class="number">4</span></a>.) The second parameter indicates that the socket is of type <code id="P7001011952000000000000000009EBC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EBC">SOCK_DGRAM</code>, which means it is a UDP socket (rather than a TCP socket). Note that we are not specifying the port number of the client socket when we create it; we are instead letting the operating system do this for us. Now that the client process’s door has been created, we will want to create a message to send through the door.</p>
<pre id="P7001011952000000000000000009EBD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EBD"><code id="P7001011952000000000000000009EBE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EBE">message = raw_input(<i>’</i>Input lowercase sentence:<i>’</i>)</code></pre>
<p class="continued" id="P7001011952000000000000000009EBF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EBF"><code id="P7001011952000000000000000009EC0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC0">raw_input()</code> is a built-in function in Python. When this command is executed, the user at the client is prompted with the words “Input lowercase sentence:” The user then uses her keyboard to input a line, which is put into the variable <code id="P7001011952000000000000000009EC1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC1">message</code>. Now that we have a socket and a message, we will want to send the message through the socket to the destination host.</p>
<pre id="P7001011952000000000000000009EC2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC2"><code id="P7001011952000000000000000009EC3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC3">clientSocket.sendto(message.encode(),(serverName, serverPort))</code></pre>
<p class="continued" id="P7001011952000000000000000009EC4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC4">In the above line, we first convert the message from string type to byte type, as we need to send bytes into a socket; this is done with the <code id="P7001011952000000000000000009EC5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC5">encode()</code> method. The method <code id="P7001011952000000000000000009EC6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC6">sendto()</code> attaches the destination address (<code id="P7001011952000000000000000009EC7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC7">serverName, serverPort</code>) to the message and sends the resulting packet into the process’s socket, <code id="P7001011952000000000000000009EC8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC8">clientSocket</code>. (As mentioned earlier, the source address is also attached to the packet, although this is done automatically rather than explicitly by the code.) Sending a client-to-server message via a UDP socket is that simple! After sending the packet, the client waits to receive data from the server.</p>
<pre id="P7001011952000000000000000009EC9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EC9"><code id="P7001011952000000000000000009ECA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ECA">modifiedMessage, serverAddress = clientSocket.recvfrom(2048)</code></pre>
<p class="continued" id="P7001011952000000000000000009ECB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ECB">With the above line, when a packet arrives from the Internet at the client’s socket, the packet’s data is put into the variable <code id="P7001011952000000000000000009ECC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ECC">modifiedMessage</code> and the packet’s source address is put into the variable <code id="P7001011952000000000000000009ECD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ECD">serverAddress</code>. The variable <code id="P7001011952000000000000000009ECE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ECE">serverAddress</code> contains both the server’s IP address and the server’s port number. The program UDPClient doesn’t actually need this server address information, since it already knows the server address from the outset; but this line of Python provides the server address nevertheless. The method <code id="P7001011952000000000000000009ECF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ECF">recvfrom</code> also takes the buffer size 2048 as input. (This buffer size works for most purposes.)</p>
<pre id="P7001011952000000000000000009ED0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED0"><code id="P7001011952000000000000000009ED1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED1">print(modifiedMessage.decode())</code></pre>
<p class="continued" id="P7001011952000000000000000009ED2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED2"><span class="pagebreak" title="163" id="P7001011952000000000000000000EAD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000EAD" epub:type="pagebreak" role="doc-pagebreak"></span>This line prints out modifiedMessage on the user’s display, after converting the message from bytes to string. It should be the original line that the user typed, but now capitalized.</p>
<pre id="P7001011952000000000000000009ED3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED3"><code id="P7001011952000000000000000009ED4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED4">clientSocket.close()</code></pre>
<p class="continued" id="P7001011952000000000000000009ED5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED5">This line closes the socket. The process then terminates.</p>
</section>
<section id="P7001011952000000000000000000EB1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000EB1" class="level3"><header><h1 class="title" id="P7001011952000000000000000009ED6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED6" epub:type="title">UDPServer.py</h1></header>
<p id="P7001011952000000000000000009ED7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED7">Let’s now take a look at the server side of the application:</p>
<pre id="P7001011952000000000000000009ED8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED8"><code id="P7001011952000000000000000009ED9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009ED9">from socket import *
serverPort = 12000
serverSocket = socket(AF_INET, SOCK_DGRAM)
serverSocket.bind((’’, serverPort))
print(”The server is ready to receive”)
while True:
    message, clientAddress = serverSocket.recvfrom(2048)
    modifiedMessage = message.decode().upper()
    serverSocket.sendto(modifiedMessage.encode(), clientAddress)</code></pre>
<p class="continued" id="P7001011952000000000000000009EDA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EDA">Note that the beginning of UDPServer is similar to UDPClient. It also imports the socket module, also sets the integer variable <code id="P7001011952000000000000000009EDB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EDB">serverPort</code> to 12000, and also creates a socket of type <code id="P7001011952000000000000000009EDC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EDC">SOCK_DGRAM</code> (a UDP socket). The first line of code that is significantly different from UDPClient is:</p>
<pre id="P7001011952000000000000000009EDD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EDD"><code id="P7001011952000000000000000009EDE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EDE">serverSocket.bind((’’, serverPort))</code></pre>
<p class="continued" id="P7001011952000000000000000009EDF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EDF">The above line binds (that is, assigns) the port number 12000 to the server’s socket. Thus in UDPServer, the code (written by the application developer) is explicitly assigning a port number to the socket. In this manner, when anyone sends a packet to port 12000 at the IP address of the server, that packet will be directed to this socket. UDPServer then enters a while loop; the while loop will allow UDPServer to receive and process packets from clients indefinitely. In the while loop, UDPServer waits for a packet to arrive.</p>
<pre id="P7001011952000000000000000009EE0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE0"><code id="P7001011952000000000000000009EE1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE1">message, clientAddress = serverSocket.recvfrom(2048)</code></pre>
<p class="continued" id="P7001011952000000000000000009EE2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE2">This line of code is similar to what we saw in UDPClient. When a packet arrives at the server’s socket, the packet’s data is put into the variable <code id="P7001011952000000000000000009EE3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE3">message</code> and the <span class="pagebreak" title="164" id="P7001011952000000000000000000EC0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000EC0" epub:type="pagebreak" role="doc-pagebreak"></span>packet’s source address is put into the variable <code id="P7001011952000000000000000009EE4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE4">clientAddress</code>. The variable ­clientAddress contains both the client’s IP address and the client’s port number. Here, UDPServer <i>will</i> make use of this address information, as it provides a return address, similar to the return address with ordinary postal mail. With this source address information, the server now knows to where it should direct its reply.</p>
<pre id="P7001011952000000000000000009EE5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE5"><code id="P7001011952000000000000000009EE6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE6">modifiedMessage = message.decode().upper()</code></pre>
<p class="continued" id="P7001011952000000000000000009EE7" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE7">This line is the heart of our simple application. It takes the line sent by the client and, after converting the message to a string, uses the method <code id="P7001011952000000000000000009EE8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE8">upper()</code> to capitalize it.</p>
<pre id="P7001011952000000000000000009EE9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EE9"><code id="P7001011952000000000000000009EEA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EEA">serverSocket.sendto(modifiedMessage.encode(), clientAddress)</code></pre>
<p class="continued" id="P7001011952000000000000000009EEB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EEB">This last line attaches the client’s address (IP address and port number) to the capitalized message (after converting the string to bytes), and sends the resulting packet into the server’s socket. (As mentioned earlier, the server address is also attached to the packet, although this is done automatically rather than explicitly by the code.) The Internet will then deliver the packet to this client address. After the server sends the packet, it remains in the while loop, waiting for another UDP packet to arrive (from any client running on any host).</p>
<p id="P7001011952000000000000000009EEC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EEC">To test the pair of programs, you run UDPClient.py on one host and UDPServer.py on another host. Be sure to include the proper hostname or IP address of the server in UDPClient.py. Next, you execute UDPServer.py, the compiled server program, in the server host. This creates a process in the server that idles until it is contacted by some client. Then you execute UDPClient.py, the compiled client program, in the client. This creates a process in the client. Finally, to use the application at the client, you type a sentence followed by a carriage return.</p>
<p id="P7001011952000000000000000009EED" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EED">To develop your own UDP client-server application, you can begin by slightly modifying the client or server programs. For example, instead of converting all the letters to uppercase, the server could count the number of times the letter <i>s</i> appears and return this number. Or you can modify the client so that after receiving a capitalized sentence, the user can continue to send more sentences to the server.</p>
</section>
</section>
<section id="P7001011952000000000000000000ECB" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000ECB" class="level2"><header><h1 class="title" id="P7001011952000000000000000009EEE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EEE" epub:type="title"><span class="number">2.7.2</span> Socket Programming with TCP</h1></header>
<p id="P7001011952000000000000000009EEF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EEF">Unlike UDP, TCP is a connection-oriented protocol. This means that before the client and server can start to send data to each other, they first need to handshake and establish a TCP connection. One end of the TCP connection is attached to the client socket and the other end is attached to a server socket. When creating the TCP connection, we associate with it the client socket address (IP address and port number) and the server socket address (IP address and port number). With the TCP connection established, when one side wants to send data to the other side, it just drops the <span class="pagebreak" title="165" id="P7001011952000000000000000000ECE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000ECE" epub:type="pagebreak" role="doc-pagebreak"></span>data into the TCP connection via its socket. This is different from UDP, for which the server must attach a destination address to the packet before dropping it into the socket.</p>
<p id="P7001011952000000000000000009EF0" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF0">Now let’s take a closer look at the interaction of client and server programs in TCP. The client has the job of initiating contact with the server. In order for the server to be able to react to the client’s initial contact, the server has to be ready. This implies two things. First, as in the case of UDP, the TCP server must be running as a process before the client attempts to initiate contact. Second, the server program must have a special door—more precisely, a special socket—that welcomes some initial contact from a client process running on an arbitrary host. Using our house/door analogy for a process/socket, we will sometimes refer to the client’s initial contact as “knocking on the welcoming door.”</p>
<p id="P7001011952000000000000000009EF1" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF1">With the server process running, the client process can initiate a TCP connection to the server. This is done in the client program by creating a TCP socket. When the client creates its TCP socket, it specifies the address of the welcoming socket in the server, namely, the IP address of the server host and the port number of the socket. After creating its socket, the client initiates a three-way handshake and establishes a TCP connection with the server. The three-way handshake, which takes place within the transport layer, is completely invisible to the client and server programs.</p>
<p id="P7001011952000000000000000009EF2" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF2">During the three-way handshake, the client process knocks on the welcoming door of the server process. When the server “hears” the knocking, it creates a new door—more precisely, a <i>new</i> socket that is dedicated to that particular ­client. In our example below, the welcoming door is a TCP socket object that we call <code id="P7001011952000000000000000009EF3" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF3">­serverSocket</code>; the newly created socket dedicated to the client making the connection is called <code id="P7001011952000000000000000009EF4" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF4">connectionSocket</code>. Students who are encountering TCP sockets for the first time sometimes confuse the welcoming socket (which is the initial point of contact for all clients wanting to communicate with the server), and each newly created server-side connection socket that is subsequently created for communicating with each client.</p>
<p id="P7001011952000000000000000009EF5" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF5">From the application’s perspective, the client’s socket and the server’s connection socket are directly connected by a pipe. As shown in <a class="xref" href="#P7001011952000000000000000000ED7" data-foobar="1"><span class="label">Figure</span> <span class="number">2.28</span></a>, the client process can send arbitrary bytes into its socket, and TCP guarantees that the server process will receive (through the connection socket) each byte in the order sent. TCP thus provides a reliable service between the client and server processes. Furthermore, just as people can go in and out the same door, the client process not only sends bytes into but also receives bytes from its socket; similarly, the server process not only receives bytes from but also sends bytes into its connection socket.</p>
<p id="P7001011952000000000000000009EF6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF6">We use the same simple client-server application to demonstrate socket programming with TCP: The client sends one line of data to the server, the server capitalizes the line and sends it back to the client. <a class="xref" href="#P7001011952000000000000000000EE9" data-foobar="1"><span class="label">Figure</span> <span class="number">2.29</span></a> highlights the main socket-related activity of the client and server that communicate over the TCP transport service.<span class="pagebreak" title="166" id="P7001011952000000000000000000ED6" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000ED6" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000000ED7" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000ED7">
<img alt="Illustration of a client-server interaction in TCP." height="432" width="477" aria-describedby="P7001011952000000000000000000EDC" id="P7001011952000000000000000009EF7" data-uri="P700101195200000000000000000553A" src="../images/4055102028.png"></img>
<figcaption id="P7001011952000000000000000009EF8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF8"><header><h1 class="title" id="P7001011952000000000000000009EF9" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EF9" epub:type="title"><span class="label">Figure </span><span class="number">2.28</span> <code id="P7001011952000000000000000009EFA" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EFA">The TCPServer</code> process has two sockets</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000000EDC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000EDC" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055102028.xhtml#la_4055102028"><span class="label">Description</span></a></div>
<section id="P7001011952000000000000000000EDE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000EDE" class="level3"><header><h1 class="title" id="P7001011952000000000000000009EFC" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EFC" epub:type="title">TCPClient.py</h1></header>
<p id="P7001011952000000000000000009EFD" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EFD">Here is the code for the client side of the application:</p>
<pre id="P7001011952000000000000000009EFE" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EFE"><code id="P7001011952000000000000000009EFF" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009EFF">from socket import *
serverName = ’servername’
serverPort = 12000
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, serverPort))
sentence = raw_input(’Input lowercase sentence:’)
clientSocket.send(sentence.encode())
modifiedSentence = clientSocket.recv(1024)
print(’From Server: ’, modifiedSentence.decode())
clientSocket.close()</code></pre>
<p class="continued" id="P7001011952000000000000000009F00" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F00">Let’s now take a look at the various lines in the code that differ significantly from the UDP implementation. The first such line is the creation of the client socket.</p>
<pre id="P7001011952000000000000000009F01" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F01"><code id="P7001011952000000000000000009F02" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F02">clientSocket = socket(AF_INET, SOCK_STREAM)</code></pre>
<p class="continued" id="P7001011952000000000000000009F03" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F03">This line creates the client’s socket, called <code id="P7001011952000000000000000009F04" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F04">clientSocket</code>. The first parameter again indicates that the underlying network is using IPv4. The second parameter<span class="pagebreak" title="167" id="P7001011952000000000000000000EE8" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000EE8" epub:type="pagebreak" role="doc-pagebreak"></span></p>
<figure id="P7001011952000000000000000000EE9" class="figure" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000EE9">
<img alt="Illustration of client-server application using TCP." height="696" width="669" aria-describedby="P7001011952000000000000000000EED" id="P7001011952000000000000000009F05" data-uri="P700101195200000000000000000553B" src="../images/4055102029.png"></img>
<figcaption id="P7001011952000000000000000009F06" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F06"><header><h1 class="title" id="P7001011952000000000000000009F07" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F07" epub:type="title"><span class="label">Figure </span><span class="number">2.29</span> The client-server application using TCP</h1></header>

</figcaption>
</figure><div class="longdesc" id="P7001011952000000000000000000EED" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000EED" aria-hidden="false"><a class="xref" aria-hidden="false" href="../longalt/la_4055102029.xhtml#la_4055102029"><span class="label">Description</span></a></div>
<p class="continued" id="P7001011952000000000000000009F2C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F2C">indicates that the socket is of type <code id="P7001011952000000000000000009F2D" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F2D">SOCK_STREAM</code>, which means it is a TCP socket (rather than a UDP socket). Note that we are again not specifying the port number of the client socket when we create it; we are instead letting the operating system do this for us. Now the next line of code is very different from what we saw in UDPClient:</p>
<pre id="P7001011952000000000000000009F2E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F2E"><code id="P7001011952000000000000000009F2F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F2F">clientSocket.connect((serverName, serverPort))</code></pre>
<p class="continued" id="P7001011952000000000000000009F30" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F30">Recall that before the client can send data to the server (or vice versa) using a TCP socket, a TCP connection must first be established between the client and server. The <span class="pagebreak" title="168" id="P7001011952000000000000000000F17" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000F17" epub:type="pagebreak" role="doc-pagebreak"></span>above line initiates the TCP connection between the client and server. The parameter of the <code id="P7001011952000000000000000009F31" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F31">connect()</code> method is the address of the server side of the connection. After this line of code is executed, the three-way handshake is performed and a TCP connection is established between the client and server.</p>
<pre id="P7001011952000000000000000009F32" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F32"><code id="P7001011952000000000000000009F33" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F33">sentence = raw_input(’Input lowercase sentence:’)</code></pre>
<p class="continued" id="P7001011952000000000000000009F34" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F34">As with UDPClient, the above obtains a sentence from the user. The string <code id="P7001011952000000000000000009F35" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F35">sentence</code> continues to gather characters until the user ends the line by typing a carriage return. The next line of code is also very different from UDPClient:</p>
<pre id="P7001011952000000000000000009F36" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F36"><code id="P7001011952000000000000000009F37" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F37">clientSocket.send(sentence.encode())</code></pre>
<p class="continued" id="P7001011952000000000000000009F38" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F38">The above line sends the <code id="P7001011952000000000000000009F39" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F39">sentence</code> through the client’s socket and into the TCP connection. Note that the program does <i>not</i> explicitly create a packet and attach the destination address to the packet, as was the case with UDP sockets. Instead the client program simply drops the bytes in the string <code id="P7001011952000000000000000009F3A" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F3A">sentence</code> into the TCP connection. The client then waits to receive bytes from the server.</p>
<pre id="P7001011952000000000000000009F3B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F3B"><code id="P7001011952000000000000000009F3C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F3C">modifiedSentence = clientSocket.recv(2048)</code></pre>
<p class="continued" id="P7001011952000000000000000009F3D" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F3D">When characters arrive from the server, they get placed into the string <code id="P7001011952000000000000000009F3E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F3E">modifiedSentence</code>. Characters continue to accumulate in <code id="P7001011952000000000000000009F3F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F3F">modifiedSentence</code> until the line ends with a carriage return character. After printing the capitalized sentence, we close the client’s socket:</p>
<pre id="P7001011952000000000000000009F40" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F40"><code id="P7001011952000000000000000009F41" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F41">clientSocket.close()</code></pre>
<p class="continued" id="P7001011952000000000000000009F42" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F42">This last line closes the socket and, hence, closes the TCP connection between the client and the server. It causes TCP in the client to send a TCP message to TCP in the server (see <a class="xref" href="fileP7001011952000000000000000001442.xhtml#P7001011952000000000000000001442" data-foobar="7"><span class="label">Section</span> <span class="number">3.5</span></a>).</p>
</section>
<section id="P7001011952000000000000000000F2A" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000F2A" class="level3"><header><h1 class="title" id="P7001011952000000000000000009F43" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F43" epub:type="title">TCPServer.py</h1></header>
<p id="P7001011952000000000000000009F44" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F44">Now let’s take a look at the server program.</p>
<pre id="P7001011952000000000000000009F45" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F45"><code id="P7001011952000000000000000009F46" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F46">from socket import *
serverPort = 12000
serverSocket = socket(AF_INET, SOCK_STREAM)
serverSocket.bind((’’, serverPort))
serverSocket.listen(1)
print(’The server is ready to receive’)
<span class="pagebreak" title="169" id="P7001011952000000000000000000F2F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000F2F" epub:type="pagebreak" role="doc-pagebreak"></span>while True:
    connectionSocket, addr = serverSocket.accept()
    sentence = connectionSocket.recv(1024).decode()
    capitalizedSentence = sentence.upper()
    connectionSocket.send(capitalizedSentence.encode())
    connectionSocket.close()</code></pre>
<p class="continued" id="P7001011952000000000000000009F47" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F47">Let’s now take a look at the lines that differ significantly from UDPServer and TCPClient. As with TCPClient, the server creates a TCP socket with:</p>
<pre id="P7001011952000000000000000009F48" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F48"><code id="P7001011952000000000000000009F49" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F49">serverSocket=socket(AF_INET, SOCK_STREAM)</code></pre>
<p class="continued" id="P7001011952000000000000000009F4A" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F4A">Similar to UDPServer, we associate the server port number, <code id="P7001011952000000000000000009F4B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F4B">serverPort</code>, with this socket:</p>
<pre id="P7001011952000000000000000009F4C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F4C"><code id="P7001011952000000000000000009F4D" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F4D">serverSocket.bind((’’, serverPort))</code></pre>
<p class="continued" id="P7001011952000000000000000009F4E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F4E">But with TCP, <code id="P7001011952000000000000000009F4F" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F4F">serverSocket</code> will be our welcoming socket. After establishing this welcoming door, we will wait and listen for some client to knock on the door:</p>
<pre id="P7001011952000000000000000009F50" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F50"><code id="P7001011952000000000000000009F51" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F51">serverSocket.listen(1)</code></pre>
<p class="continued" id="P7001011952000000000000000009F52" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F52">This line has the server listen for TCP connection requests from the client. The parameter specifies the maximum number of queued connections (at least 1).</p>
<pre id="P7001011952000000000000000009F53" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F53"><code id="P7001011952000000000000000009F54" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F54">connectionSocket, addr = serverSocket.accept()</code></pre>
<p class="continued" id="P7001011952000000000000000009F55" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F55">When a client knocks on this door, the program invokes the <code id="P7001011952000000000000000009F56" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F56">accept()</code> method for serverSocket, which creates a new socket in the server, called <code id="P7001011952000000000000000009F57" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F57">­connectionSocket</code>, dedicated to this particular client. The client and server then complete the handshaking, creating a TCP connection between the client’s <code id="P7001011952000000000000000009F58" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F58">clientSocket</code> and the server’s <code id="P7001011952000000000000000009F59" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F59">connectionSocket</code>. With the TCP connection established, the client and server can now send bytes to each other over the connection. With TCP, all bytes sent from one side not are not only guaranteed to arrive at the other side but also guaranteed arrive in order.</p>
<pre id="P7001011952000000000000000009F5A" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F5A"><code id="P7001011952000000000000000009F5B" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F5B">connectionSocket.close()</code></pre>
<p class="continued" id="P7001011952000000000000000009F5C" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F5C">In this program, after sending the modified sentence to the client, we close the connection socket. But since <code id="P7001011952000000000000000009F5D" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F5D">serverSocket</code> remains open, another client can now knock on the door and send the server a sentence to modify.</p>
<p id="P7001011952000000000000000009F5E" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000009F5E"><span class="pagebreak" title="170" id="P7001011952000000000000000000F48" data-uri="M02_KURO4140_07_SE_C02.xhtml#P7001011952000000000000000000F48" epub:type="pagebreak" role="doc-pagebreak"></span>This completes our discussion of socket programming in TCP. You are encouraged to run the two programs in two separate hosts, and also to modify them to achieve slightly different goals. You should compare the UDP program pair with the TCP program pair and see how they differ. You should also do many of the socket programming assignments described at the ends of <a class="xref" href="fileP700101195200000000000000000096B.xhtml#P700101195200000000000000000096B" data-foobar="7"><span class="label">Chapter</span> <span class="number">2</span></a>, <a class="xref" href="fileP70010119520000000000000000019C1.xhtml#P70010119520000000000000000019C1" data-foobar="7"><span class="number">4</span></a>, and <a class="xref" href="fileP70010119520000000000000000033D7.xhtml#P70010119520000000000000000033D7" data-foobar="7"><span class="number">9</span></a>. Finally, we hope someday, after mastering these and more advanced socket programs, you will write your own popular network application, become very rich and famous, and remember the authors of this textbook!</p>
</section>
</section>
</section></body></html>