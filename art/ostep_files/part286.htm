<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>28.7 Building A Working Spin Lock</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part285.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part287.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">28.7 Building A Working Spin Lock</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">While the idea behind the example above is a good one, it is not possi- ble to implement without some support from the hardware. Fortunately, some systems provide an instruction to support the creation of simple locks based on this concept. This more powerful instruction has differ- ent names – on SPARC, it is the load/store unsigned byte instruction (<span class="s41">ldstub</span>), whereas on x86, it is the atomic exchange instruction (<span class="s41">xchg</span>)</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">– but basically does the same thing across platforms, and is usually gen- erally referred to as <b>test-and-set</b>. We define what the test-and-set instruc- tion does with the following C code snippet:</p><p class="s38" style="padding-top: 4pt;padding-left: 26pt;text-indent: 0pt;text-align: left;"><span class="s37">1    </span>int TestAndSet(int <span class="s39">*</span>ptr, int new) {</p><table style="border-collapse:collapse;margin-left:24.0608pt" cellspacing="0"><tr style="height:9pt"><td style="width:19pt"><p class="s135" style="padding-left: 2pt;text-indent: 0pt;text-align: left;">2</p></td><td style="width:25pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:181pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 73%;text-align: left;">int old = <span class="s136">*</span>ptr; // fetch old value at ptr</p></td></tr><tr style="height:8pt"><td style="width:19pt"><p class="s135" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">3</p></td><td style="width:25pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:181pt"><p class="s136" style="padding-left: 6pt;text-indent: 0pt;line-height: 71%;text-align: left;">*<span class="s42">ptr = new;  // store ’new’ into ptr</span></p></td></tr><tr style="height:8pt"><td style="width:19pt"><p class="s135" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">4</p></td><td style="width:25pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:181pt"><p class="s42" style="padding-left: 6pt;text-indent: 0pt;line-height: 6pt;text-align: left;">return old;  // return the old value</p></td></tr><tr style="height:8pt"><td style="width:19pt"><p class="s135" style="padding-left: 2pt;text-indent: 0pt;line-height: 6pt;text-align: left;">5</p></td><td style="width:25pt"><p class="s42" style="padding-left: 14pt;text-indent: 0pt;line-height: 7pt;text-align: left;">}</p></td><td style="width:181pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">What the test-and-set instruction does is as follows. It returns the old value pointed to by the <span class="s41">ptr</span>, and simultaneously updates said value to <span class="s41">new</span>. The key, of course, is that this sequence of operations is performed <b>atomically</b>. The reason it is called “test and set” is that it enables you to “test” the old value (which is what is returned) while simultaneously</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 5pt;padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>typedef struct <span class="s75">&nbsp;</span>lock_t {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2    <span class="s38">int flag;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">3  <span class="s38">} lock_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">4</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">5  </span>void init(lock_t <span class="s39">*</span>lock) {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;">6     <span class="s38">// 0 indicates that lock is available, 1 that it is held</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">7    <span class="s38">lock-&gt;flag = 0;</span></p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">8  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">9</p><p class="s38" style="padding-left: 51pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">10  </span>void lock(lock_t <span class="s39">*</span>lock) {</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;line-height: 7pt;text-align: left;">11    <span class="s38">while (TestAndSet(&amp;lock-&gt;flag, 1) == 1)</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">12       <span class="s38">; // spin-wait (do nothing)</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">13  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">14</p><p class="s38" style="padding-left: 51pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">15  </span>void unlock(lock_t <span class="s39">*</span>lock) {</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">16    <span class="s38">lock-&gt;flag = 0;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">17  <span class="s38">}</span></p><p style="padding-left: 108pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 28.2: <b>A Simple Spin Lock Using Test-and-set</b></p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">“setting” the memory location to a new value; as it turns out, this slightly more powerful instruction is enough to build a simple <b>spin lock</b>, as we now examine in Figure <span style=" color: #00AEEF;">28.2</span>.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 88%;text-align: justify;">Let’s make sure we understand why this works. Imagine first the case where a thread calls <span class="s41">lock() </span>and no other thread currently holds the lock; thus, <span class="s41">flag </span>should be 0. When the thread then calls <span class="s41">TestAndSet(flag, 1)</span>, the routine will return the old value of <span class="s41">flag</span>, which is 0; thus, the call- ing thread, which is <i>testing </i>the value of flag, will not get caught spinning in the while loop and will acquire the lock. The thread will also atomi- cally <i>set </i>the value to 1, thus indicating that the lock is now held. When the thread is finished with its critical section, it calls <span class="s41">unlock() </span>to set the flag back to zero.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">The second case we can imagine arises when one thread already has the lock held (i.e., <span class="s41">flag </span>is 1). In this case, this thread will call <span class="s41">lock() </span>and then call <span class="s41">TestAndSet(flag, 1) </span>as well. This time, <span class="s41">TestAndSet() </span>will return the old value at flag, which is 1 (because the lock is held), while simultaneously setting it to 1 again. As long as the lock is held by another thread, <span class="s41">TestAndSet() </span>will repeatedly return 1, and thus this thread will spin and spin until the lock is finally released. When the flag is finally set to 0 by some other thread, this thread will call <span class="s41">TestAndSet() </span>again, which will now return 0 while atomically setting the value to 1 and thus acquire the lock and enter the critical section.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: right;">By making both the <b>test </b>(of the old lock value) and <b>set </b>(of the new value) a single atomic operation, we ensure that only one thread acquires the lock. And that’s how to build a working mutual exclusion primitive!</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">You may also now understand why this type of lock is usually referred to as a <b>spin lock</b>. It is the simplest type of lock to build, and simply spins, using CPU cycles, until the lock becomes available. To work correctly on a single processor, it requires a <b>preemptive scheduler </b>(i.e., one that will interrupt a thread via a timer, in order to run a different thread, from time to time). Without preemption, spin locks don’t make much sense on a single CPU, as a thread spinning on a CPU will never relinquish it.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part285.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part287.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
