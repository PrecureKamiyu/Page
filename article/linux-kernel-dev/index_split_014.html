<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Linux Kernel Development, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos301917" style="height:0pt"></div><h2 class="calibre_4" id="calibre_pb_38"><span class="bold">5. System Calls</span></h2><div class="calibre_5"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos302074"> </div>
<p class="calibre_2">In any modern operating system, the kernel provides a set of interfaces by which processes running in user-space can interact with the system. These interfaces give applications controlled access to hardware, a mechanism with which to create new processes and communicate with existing ones, and the capability to request other operating system resources. The interfaces act as the messengers between applications and the kernel, with the applications issuing various requests and the kernel fulfilling them (or returning an error). The existence of these interfaces, and the fact that applications are not free to directly do whatever they want, is key to providing a stable system.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos302859"> </div>
<h3 class="calibre_21"><span class="bold">Communicating with the Kernel</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">System calls provide a layer between the hardware and user-space processes. This layer serves three primary purposes. First, it provides an abstracted hardware interface for user-space. When reading or writing from a file, for example, applications are not concerned with the type of disk, media, or even the type of filesystem on which the file resides. Second, system calls ensure system security and stability. With the kernel acting as a middleman between system resources and user-space, the kernel can arbitrate access based on permissions, users, and other criteria. For example, this arbitration prevents applications from incorrectly using hardware, stealing other processes’ resources, or otherwise doing harm to the system. Finally, a single common layer between user-space and the rest of the system allows for the virtualized system provided to processes, discussed in <a href="index_split_012.html#filepos167044">Chapter 3</a>, “Process Management.” If applications were free to access system resources without the kernel’s knowledge, it would be nearly impossible to implement multitasking and virtual memory, and certainly impossible to do so with stability and security. In Linux, system calls are the only means user-space has of interfacing with the kernel; they are the only legal entry point into the kernel other than exceptions and traps. Indeed, other interfaces, such as device files or <code class="calibre6"><span class="calibre7">/proc</span></code>, are ultimately accessed via system calls. Interestingly, Linux <a id="filepos304510"></a>implements far fewer system calls than most systems.<sup class="calibre8"><a id="filepos304567" href="#filepos304747">1</a></sup> This chapter addresses the role and implementation of system calls in Linux.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos304747" href="#filepos304567">1</a></sup>
<em class="calibre4">There are about 335 system calls are on x86. (Each architecture is allowed to define unique system calls.) Although not all operating systems publish their exact system calls, some operating systems are estimated to have more than one thousand. In the previous edition of this book, x86 had only 250 system calls.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos305172"> </div>
<h3 class="calibre_21"><span class="bold">APIs, POSIX, and the C Library</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">Typically, applications are programmed against an Application Programming Interface (API) implemented in user-space, not directly to system calls. This is important because no direct correlation is needed between the interfaces that applications make use of and the actual interface provided by the kernel. An API defines a set of programming interfaces used by applications. Those interfaces can be implemented as a system call, implemented through multiple system calls, or implemented without the use of system calls at all. The same API can exist on multiple systems and provide the same interface to applications while the implementation of the API itself can differ greatly from system to system. See <a href="#filepos306189">Figure 5.1</a> for an example of the relationship between a POSIX API, the C library, and system calls.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos306189"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 5.1. The relationship between applications, the C library, and the kernel with a call to <code class="calibre6"><span class="calibre15">printf()</span></code>.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00036.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">One of the more common application programming interfaces in the Unix world is based on the POSIX standard. Technically, POSIX is composed of a series of standards from the IEEE<sup class="calibre8"><a id="filepos306761" href="#filepos307009">2</a></sup> that aim to provide a portable operating system standard roughly based on Unix. Linux strives to be POSIX- and SUSv3-compliant where applicable.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos307009" href="#filepos306761">2</a></sup>
<em class="calibre4">IEEE (eye-triple-E) is the Institute of Electrical and Electronics Engineers. It is a nonprofit professional association involved in numerous technical areas and responsible for many important standards, such as POSIX. For more information, visit <a href="http://www.ieee.org">http://www.ieee.org</a>.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">POSIX is an excellent example of the relationship between APIs and system calls. On most Unix systems, the POSIX-defined API calls have a strong correlation to the system calls. Indeed, the POSIX standard was created to resemble the interfaces provided by earlier Unix systems. On the other hand, some systems that are rather un-Unix, such as Microsoft Windows, offer POSIX-compatible libraries.</p><div class="calibre_3"> </div>
<p class="calibre_2"><a id="filepos307868"></a>The system call interface in Linux, as with most Unix systems, is provided in part by the C library. The C library implements the main API on Unix systems, including the standard C library and the system call interface. The C library is used by all C programs and, because of C’s nature, is easily wrapped by other programming languages for use in their programs. The C library additionally provides the majority of the POSIX API.</p><div class="calibre_3"> </div>
<p class="calibre_2">From the application programmer’s point of view, system calls are irrelevant; all the programmer is concerned with is the API. Conversely, the kernel is concerned only with the system calls; what library calls and applications make use of the system calls is not of the kernel’s concern. Nonetheless, it is important for the kernel to keep track of the potential uses of a system call and keep the system call as general and flexible as possible.</p><div class="calibre_3"> </div>
<p class="calibre_2">A meme related to interfaces in Unix is “Provide mechanism, not policy.” In other words, Unix system calls exist to provide a specific function in an abstract sense. The manner in which the function is used is not any of the kernel’s business.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos309176"> </div>
<h3 class="calibre_21"><span class="bold">Syscalls</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">System calls (often called <em class="calibre4">syscalls</em> in Linux) are typically accessed via function calls defined in the C library. They can define zero, one, or more arguments (inputs) and might result in one or more side effects,<sup class="calibre8"><a id="filepos309514" href="#filepos310301">3</a></sup> for example writing to a file or copying some data into a provided pointer. System calls also provide a return value of type <code class="calibre6"><span class="calibre7">long</span></code><sup class="calibre8"><a id="filepos309731" href="#filepos310690">4</a></sup> that signifies success or error—usually, although not always, a negative return value denotes an error. A return value of zero is usually (but again not always) a sign of success. The C library, when a system call returns an error, writes a special error code into the global <code class="calibre6"><span class="calibre7">errno</span></code> variable. This variable can be translated into human-readable errors via library functions such as <code class="calibre6"><span class="calibre7">perror()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos310301" href="#filepos309514">3</a></sup>
<em class="calibre4">Note the “might” here. Although nearly all system calls have a side effect (that is, they result in some change of the system’s state), a few syscalls, such as</em>
<code class="calibre6"><span class="calibre7">getpid()</span></code>, <em class="calibre4">merely return some data from the kernel.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos310690" href="#filepos309731">4</a></sup>
<em class="calibre4">The use of type</em>
<code class="calibre6"><span class="calibre7">long</span></code>
<em class="calibre4">is for compatibility with 64-bit architectures.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, system calls have a defined behavior. For example, the system call <code class="calibre6"><span class="calibre7">getpid()</span></code> is defined to return an integer that is the current process’s PID. The implementation of this syscall in the kernel is simple:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">SYSCALL_DEFINE0(getpid)<br class="calibre1"/>{<br class="calibre1"/>        return task_tgid_vnr(current); // returns current-&gt;tgid<br class="calibre1"/>}</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Note that the definition says nothing of the implementation. The kernel must provide the intended behavior of the system call but is free to do so with whatever implementation <a id="filepos311642"></a>it wants as long as the result is correct. Of course, this system call is as simple as they come, and there are not too many other ways to implement it.<sup class="calibre8"><a id="filepos311799" href="#filepos311902">5</a></sup></p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos311902" href="#filepos311799">5</a></sup>
<em class="calibre4">You might be wondering</em> why does <code class="calibre6"><span class="calibre7">getpid()</span></code> return <code class="calibre6"><span class="calibre7">tgid</span></code>, the thread group ID? <em class="calibre4">In normal processes, the TGID is equal to the PID. With threads, the TGID is the same for all threads in a thread group. This enables the threads to call</em>
<code class="calibre6"><span class="calibre7">getpid()</span></code>
<em class="calibre4">and get the same PID.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"><code class="calibre6"><span class="calibre7">SYSCALL_DEFINE0</span></code> is simply a macro that defines a system call with no parameters (hence the <em class="calibre4">0</em>). The expanded code looks like this:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">asmlinkage long sys_getpid(void)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Let’s look at how system calls are defined. First, note the <code class="calibre6"><span class="calibre7">asmlinkage</span></code> modifier on the function definition. This is a directive to tell the compiler to look only on the stack for this function’s arguments. This is a required modifier for all system calls. Second, the function returns a <code class="calibre6"><span class="calibre7">long</span></code>. For compatibility between 32- and 64-bit systems, system calls defined to return an <code class="calibre6"><span class="calibre7">int</span></code> in user-space return a <code class="calibre6"><span class="calibre7">long</span></code> in the kernel. Third, note that the <code class="calibre6"><span class="calibre7">getpid()</span></code> system call is defined as <code class="calibre6"><span class="calibre7">sys_getpid()</span></code> in the kernel. This is the naming convention taken with all system calls in Linux: System call <code class="calibre6"><span class="calibre7">bar()</span></code> is implemented in the kernel as function <code class="calibre6"><span class="calibre7">sys_bar()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos313743"> </div>
<h4 class="calibre_27"><span class="calibre3">System Call Numbers</span></h4><div class="calibre_24"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos313864"> </div>
<p class="calibre_2">In Linux, each system call is assigned a <em class="calibre4">syscall number</em>. This is a unique number that is used to reference a specific system call. When a user-space process executes a system call, the syscall number identifies which syscall was executed; the process does not refer to the syscall by name.</p><div class="calibre_3"> </div>
<p class="calibre_2">The syscall number is important; when assigned, it cannot change, or compiled applications will break. Likewise, if a system call is removed, its system call number cannot be recycled, or previously compiled code would aim to invoke one system call but would in reality invoke another. Linux provides a “not implemented” system call, <code class="calibre6"><span class="calibre7">sys_ni_syscall()</span></code>, which does nothing except return <code class="calibre6"><span class="calibre7">-ENOSYS</span></code>, the error corresponding to an invalid system call. This function is used to “plug the hole” in the rare event that a syscall is removed or otherwise made unavailable.</p><div class="calibre_3"> </div>
<p class="calibre_2">The kernel keeps a list of all registered system calls in the system call table, stored in <code class="calibre6"><span class="calibre7">sys_call_table</span></code>. This table is architecture; on x86-64 it is defined in <code class="calibre6"><span class="calibre7">arch/i386/kernel/syscall_64.c</span></code>. This table assigns each valid syscall to a unique syscall number.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos315348"> </div>
<h4 class="calibre_27"><span class="calibre3">System Call Performance</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">System calls in Linux are faster than in many other operating systems. This is partly because of Linux’s fast context switch times; entering and exiting the kernel is a streamlined and simple affair. The other factor is the simplicity of the system call handler and the individual system calls themselves.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos315835"> </div>
<h3 class="calibre_21"><span class="bold">System Call Handler</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">It is not possible for user-space applications to execute kernel code directly. They cannot simply make a function call to a method existing in kernel-space because the kernel exists in a protected memory space. If applications could directly read and write to the kernel’s address space, system security and stability would be nonexistent.</p><div class="calibre_3"> </div>
<p class="calibre_2">Instead, user-space applications must somehow signal to the kernel that they want to execute a system call and have the system switch to kernel mode, where the system call can be executed in kernel-space by the kernel on behalf of the application.</p><div class="calibre_3"> </div>
<p class="calibre_2">The mechanism to signal the kernel is a software interrupt: Incur an exception, and the system will switch to kernel mode and execute the exception handler. The exception handler, in this case, is actually the system call handler. The defined software interrupt on x86 is interrupt number 128, which is incurred via the <code class="calibre6"><span class="calibre7">int $0x80</span></code> instruction. It triggers a switch to kernel mode and the execution of exception vector 128, which is the system call handler. The system call handler is the aptly named function <code class="calibre6"><span class="calibre7">system_call()</span></code>. It is architecture-dependent; on x86-64 it is implemented in assembly in <code class="calibre6"><span class="calibre7">entry_64.S</span></code>.<sup class="calibre8"><a id="filepos317369" href="#filepos317940">6</a></sup> Recently, x86 processors added a feature known as <em class="calibre4">sysenter</em>. This feature provides a faster, more specialized way of trapping into a kernel to execute a system call than using the <code class="calibre6"><span class="calibre7">int</span></code> interrupt instruction. Support for this feature was quickly added to the kernel. Regardless of how the system call handler is invoked, however, the important notion is that somehow user-space causes an exception or trap to enter the kernel.</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos317940" href="#filepos317369">6</a></sup>
<em class="calibre4">Much of the following description of the system call handler is based on the x86 version. They are all similar.</em></p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos318163"> </div>
<h4 class="calibre_27"><span class="calibre3">Denoting the Correct System Call</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Simply entering kernel-space alone is not sufficient because multiple system calls exist, all of which enter the kernel in the same manner. Thus, the system call number must be passed into the kernel. On x86, the syscall number is fed to the kernel via the <code class="calibre6"><span class="calibre7">eax</span></code> register. Before causing the trap into the kernel, user-space sticks in <code class="calibre6"><span class="calibre7">eax</span></code> the number corresponding to the desired system call. The system call handler then reads the value from <code class="calibre6"><span class="calibre7">eax</span></code>. Other architectures do something similar.</p><div class="calibre_3"> </div>
<p class="calibre_2">The <code class="calibre6"><span class="calibre7">system_call()</span></code> function checks the validity of the given system call number by comparing it to <code class="calibre6"><span class="calibre7">NR_syscalls</span></code>. If it is larger than or equal to <code class="calibre6"><span class="calibre7">NR_syscalls</span></code>, the function returns <code class="calibre6"><span class="calibre7">-ENOSYS</span></code>. Otherwise, the specified system call is invoked:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">call *sys_call_table(,%rax,8)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Because each element in the system call table is 64 bits (8 bytes), the kernel multiplies the given system call number by four to arrive at its location in the system call table. On x86-32, the code is similar, with the 8 replaced by 4. See <a href="#filepos319878">Figure 5.2</a>.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos319827"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos319878"> </div>
<p class="calibre_23"><span class="calibre9"><span class="calibre3">Figure 5.2. Invoking the system call handler and executing a system call.</span></span></p><div class="calibre_24"> </div>
<p class="calibre_23"><img alt="image" src="images/00037.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos320201"> </div>
<h4 class="calibre_27"><span class="calibre3">Parameter Passing</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">In addition to the system call number, most syscalls require that one or more parameters be passed to them. Somehow, user-space must relay the parameters to the kernel during the trap. The easiest way to do this is via the same means that the syscall number is passed: The parameters are stored in registers. On x86-32, the registers <code class="calibre6"><span class="calibre7">ebx</span></code>, <code class="calibre6"><span class="calibre7">ecx</span></code>, <code class="calibre6"><span class="calibre7">edx</span></code>, <code class="calibre6"><span class="calibre7">esi</span></code>, and <code class="calibre6"><span class="calibre7">edi</span></code> contain, in order, the first five arguments. In the unlikely case of six or more arguments, a single register is used to hold a pointer to user-space where all the parameters are stored.</p><div class="calibre_3"> </div>
<p class="calibre_2">The return value is sent to user-space also via register. On x86, it is written into the <code class="calibre6"><span class="calibre7">eax</span></code> register.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos321282"> </div>
<h3 class="calibre_21"><span class="bold">System Call Implementation</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">The actual implementation of a system call in Linux does not need to be concerned with the behavior of the system call handler. Thus, adding a new system call to Linux is relatively easy. The hard work lies in designing and implementing the system call; registering it with the kernel is simple. Let’s look at the steps involved in writing a new system call for Linux.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos321836"> </div>
<h4 class="calibre_27"><span class="calibre3">Implementing System Calls</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The first step in implementing a system call is defining its purpose. What will it do? The syscall should have exactly one purpose. Multiplexing syscalls (a single system call that does wildly different things depending on a flag argument) is discouraged in Linux. Look at <code class="calibre6"><span class="calibre7">ioctl()</span></code> as an example of what <em class="calibre4">not</em> to do.</p><div class="calibre_3"> </div>
<p class="calibre_2">What are the new system call’s arguments, return value, and error codes? The system call should have a clean and simple interface with the smallest number of arguments possible. The semantics and behavior of a system call are important; they must not change, because existing applications will come to rely on them. Be forward thinking; consider <a id="filepos322723"></a>how the function might change over time. Can new functionality be added to your system call or will any change require an entirely new function? Can you easily fix bugs without breaking backward compatibility? Many system calls provide a flag argument to address forward compatibility. The flag is not used to multiplex different behavior across a single system call—as mentioned, that is not acceptable—but to enable new functionality and options without breaking backward compatibility or needing to add a new system call.</p><div class="calibre_3"> </div>
<p class="calibre_2">Designing the interface with an eye toward the future is important. Are you needlessly limiting the function? Design the system call to be as general as possible. Do not assume its use today will be the same as its use tomorrow. The <em class="calibre4">purpose</em> of the system call will remain constant but its <em class="calibre4">uses</em> may change. Is the system call portable? Do not make assumptions about an architecture’s word size or endianness. <a href="index_split_028.html#filepos1252328">Chapter 19</a>, “Portability,” discusses these issues. Make sure you are not making poor assumptions that will break the system call in the future. Remember the Unix motto: “Provide mechanism, not policy.”</p><div class="calibre_3"> </div>
<p class="calibre_2">When you write a system call, you need to realize the need for portability and robustness, not just today but in the future. The basic Unix system calls have survived this test of time; most of them are just as useful and applicable today as they were 30 years ago!</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos324361"> </div>
<h4 class="calibre_27"><span class="calibre3">Verifying the Parameters</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">System calls must carefully verify all their parameters to ensure that they are valid and legal. The system call runs in kernel-space, and if the user can pass invalid input into the kernel without restraint, the system’s security and stability can suffer.</p><div class="calibre_3"> </div>
<p class="calibre_2">For example, file I/O syscalls must check whether the file descriptor is valid. Process-related functions must check whether the provided PID is valid. Every parameter must be checked to ensure it is not just valid and legal, but correct. Processes must not ask the kernel to access resources to which the process does not have access.</p><div class="calibre_3"> </div>
<p class="calibre_2">One of the most important checks is the validity of any pointers that the user provides. Imagine if a process could pass any pointer into the kernel, unchecked, with warts and all, even passing a pointer to which it did not have read access! Processes could then trick the kernel into copying data for which they did not have access permission, such as data belonging to another process or data mapped unreadable. Before following a pointer into user-space, the system must ensure that</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The pointer points to a region of memory in user-space. Processes must not be able to trick the kernel into reading data in kernel-space on their behalf.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• The pointer points to a region of memory in the process’s address space. The process must not be able to trick the kernel into reading someone else’s data.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• If reading, the memory is marked readable. If writing, the memory is marked writable. If executing, the memory is marked executable. The process must not be able to bypass memory access restrictions.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The kernel provides two methods for performing the requisite checks and the desired copy to and from user-space. Note kernel code must never blindly follow a pointer into user-space! One of these two methods must always be used.</p><div class="calibre_3"> </div>
<p class="calibre_2">For writing into user-space, the method <code class="calibre6"><span class="calibre7">copy_to_user()</span></code> is provided. It takes three parameters. The first is the destination memory address in the process’s address space. The second is the source pointer in kernel-space. Finally, the third argument is the size in bytes of the data to copy.</p><div class="calibre_3"> </div>
<p class="calibre_2">For reading from user-space, the method <code class="calibre6"><span class="calibre7">copy_from_user()</span></code> is analogous to <code class="calibre6"><span class="calibre7">copy_to_user()</span></code>. The function reads from the second parameter into the first parameter the number of bytes specified in the third parameter.</p><div class="calibre_3"> </div>
<p class="calibre_2">Both of these functions return the number of bytes they failed to copy on error. On success, they return zero. It is standard for the syscall to return <code class="calibre6"><span class="calibre7">-EFAULT</span></code> in the case of such an error.</p><div class="calibre_3"> </div>
<p class="calibre_2">Let’s consider an example system call that uses both <code class="calibre6"><span class="calibre7">copy_from_user()</span></code> and <code class="calibre6"><span class="calibre7">copy_to_user()</span></code>. This syscall, <code class="calibre6"><span class="calibre7">silly_copy()</span></code>, is utterly worthless; it copies data from its first parameter into its second. This is suboptimal in that it involves an intermediate and extraneous copy into kernel-space for no gain. But it helps illustrate the point.</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00038.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">Both <code class="calibre6"><span class="calibre7">copy_to_user()</span></code> and <code class="calibre6"><span class="calibre7">copy_from_user()</span></code> may block. This occurs, for example, if the page containing the user data is not in physical memory but is swapped to disk. In that case, the process sleeps until the page fault handler can bring the page from the swap file on disk into physical memory.</p><div class="calibre_3"> </div>
<p class="calibre_2">A final possible check is for valid permission. In older versions of Linux, it was standard for syscalls that require <em class="calibre4">root</em> privilege to use <code class="calibre6"><span class="calibre7">suser()</span></code>. This function merely checked whether a user was root; this is now removed and a finer-grained “capabilities” system is in place. The new system enables specific access checks on specific resources. A call to <code class="calibre6"><span class="calibre7">capable()</span></code> with a valid capabilities flag returns nonzero if the caller holds the specified capability and zero otherwise. For example, <code class="calibre6"><span class="calibre7">capable(CAP_SYS_NICE)</span></code> checks whether the caller has the ability to modify nice values of other processes. By default, the superuser possesses all capabilities and nonroot possesses none. For example, here is the <code class="calibre6"><span class="calibre7">reboot()</span></code> system call. Note how its first step is ensuring that the calling process has the <code class="calibre6"><span class="calibre7">CAP_SYS_REBOOT</span></code>. If that one conditional statement were removed, any process could reboot the system.</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00039.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_31"><img alt="image" src="images/00040.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"><a id="filepos330088"></a>See <code class="calibre6"><span class="calibre7">&lt;linux/capability.h&gt;</span></code> for a list of all capabilities and what rights they entail.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos330264"> </div>
<h3 class="calibre_21"><span class="bold">System Call Context</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">As discussed in <a href="index_split_012.html#filepos167044">Chapter 3</a>, the kernel is in process context during the execution of a system call. The <code class="calibre6"><span class="calibre7">current</span></code> pointer points to the current task, which is the process that issued the syscall.</p><div class="calibre_3"> </div>
<p class="calibre_2">In process context, the kernel is capable of sleeping (for example, if the system call blocks on a call or explicitly calls <code class="calibre6"><span class="calibre7">schedule()</span></code>) and is fully preemptible. These two points are important. First, the capability to sleep means that system calls can make use of the majority of the kernel’s functionality. As we will see in <a href="index_split_016.html#filepos426370">Chapter 7</a>, “Interrupts and <a id="filepos331119"></a>Interrupt Handlers,” the capability to sleep greatly simplifies kernel programming.<sup class="calibre8"><a id="filepos331213" href="#filepos331873">7</a></sup> The fact that process context is preemptible implies that, like user-space, the current task may be preempted by another task. Because the new task may then execute the same system call, care must be exercised to ensure that system calls are reentrant. Of course, this is the same concern that symmetrical multiprocessing introduces. Synchronizing reentrancy is covered in <a href="index_split_018.html#filepos575425">Chapter 9</a>, “An Introduction to Kernel Synchronization,” and <a href="index_split_019.html#filepos613760">Chapter 10</a>, “Kernel Synchronization Methods.”</p><div class="calibre_3"> </div>
<p class="calibre_2"><sup class="calibre8"><a id="filepos331873" href="#filepos331213">7</a></sup>
<em class="calibre4">Interrupt handlers cannot sleep and thus are much more limited in what they can do than system calls running in process context.</em></p><div class="calibre_3"> </div>
<p class="calibre_2">When the system call returns, control continues in <code class="calibre6"><span class="calibre7">system_call()</span></code>, which ultimately switches to user-space and continues the execution of the user process.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos332353"> </div>
<h4 class="calibre_27"><span class="calibre3">Final Steps in Binding a System Call</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">After the system call is written, it is trivial to register it as an official system call:</p><div class="calibre_3"> </div>
<ol class="calibre13">
<li value="1" class="calibre14">Add an entry to the end of the system call table. This needs to be done for each architecture that supports the system call (which, for most calls, is all the architectures). The position of the syscall in the table, starting at zero, is its system call number. For example, the tenth entry in the list is assigned syscall number nine.</li>
<li value="2" class="calibre14">For each supported architecture, define the syscall number in <code class="calibre6"><span class="calibre7">&lt;asm/unistd.h&gt;</span></code>.</li>
<li value="3" class="calibre14">Compile the syscall into the kernel image (as opposed to compiling as a module). This can be as simple as putting the system call in a relevant file in <code class="calibre6"><span class="calibre7">kernel/</span></code>, such as <code class="calibre6"><span class="calibre7">sys.c</span></code>, which is home to miscellaneous system calls.</li>
</ol>
<p class="calibre_2">Look at these steps in more detail with a fictional system call, <code class="calibre6"><span class="calibre7">foo()</span></code>. First, we want to add <code class="calibre6"><span class="calibre7">sys_foo()</span></code> to the system call table. For most architectures, the table is located in <code class="calibre6"><span class="calibre7">entry.S</span></code> and looks like this:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00041.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The new system call is then appended to the tail of this list:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">.long sys_foo</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Although it is not explicitly specified, the system call is then given the next subsequent syscall number—in this case, 338. For each architecture you want to support, the system call must be added to the architecture’s system call table. The system call does not need to receive the same syscall number under each architecture, as the system call number is part of the architecture’s unique ABI. Usually, you would want to make the system call available to each architecture. Note the convention of placing the number in a comment every five entries; this makes it easy to find out which syscall is assigned which number.</p><div class="calibre_3"> </div>
<p class="calibre_2">Next, the system call number is added to <code class="calibre6"><span class="calibre7">&lt;asm/unistd.h&gt;</span></code>, which currently looks somewhat like this:</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00042.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">The following is then added to the end of the list:</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">#define __NR_foo                338</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2"><a id="filepos335414"></a>Finally, the actual <code class="calibre6"><span class="calibre7">foo()</span></code> system call is implemented. Because the system call must be compiled into the core kernel image in all configurations, in this example we define it in <code class="calibre6"><span class="calibre7">kernel/sys.c</span></code>. You should put it wherever the function is most relevant; for example, if the function is related to scheduling, you could define it in <code class="calibre6"><span class="calibre7">kernel/sched.c</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00043.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2">That is it! Boot this kernel and user-space can invoke the <code class="calibre6"><span class="calibre7">foo()</span></code> system call.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos336163"> </div>
<h4 class="calibre_27"><span class="calibre3">Accessing the System Call from User-Space</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">Generally, the C library provides support for system calls. User applications can pull in function prototypes from the standard headers and link with the C library to use your system call (or the library routine that, in turn, uses your syscall call). If you just wrote the system call, however, it is doubtful that glibc already supports it!</p><div class="calibre_3"> </div>
<p class="calibre_2">Thankfully, Linux provides a set of macros for wrapping access to system calls. It sets up the register contents and issues the trap instructions. These macros are named <code class="calibre6"><span class="calibre7">_syscall</span></code><em class="calibre4"><code class="calibre6"><span class="calibre7">n</span></code></em><code class="calibre6"><span class="calibre7">()</span></code>, where <em class="calibre4"><code class="calibre6"><span class="calibre7">n</span></code></em> is between 0 and 6. The number corresponds to the number of parameters passed into the syscall because the macro needs to know how many parameters to expect and, consequently, push into registers. For example, consider the system call <code class="calibre6"><span class="calibre7">open()</span></code>, defined as</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">long open(const char *filename, int flags, int mode)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">The syscall macro to use this system call without explicit library support would be</p><div class="calibre_3"> </div>
<p class="calibre_28"><tt class="calibre6"><span class="calibre12">#define __NR_open 5<br class="calibre1"/>_syscall3(long, open, const char *, filename, int, flags, int, mode)</span></tt></p><div class="calibre_22"> </div>
<p class="calibre_2">Then, the application can simply call <code class="calibre6"><span class="calibre7">open()</span></code>.</p><div class="calibre_3"> </div>
<p class="calibre_2">For each macro, there are 2 + 2 × n parameters. The first parameter corresponds to the return type of the syscall. The second is the name of the system call. Next follows the type and name for each parameter in order of the system call. The <code class="calibre6"><span class="calibre7">__NR_open</span></code> define is in <code class="calibre6"><span class="calibre7">&lt;asm/unistd.h&gt;</span></code>; it is the system call number. The <code class="calibre6"><span class="calibre7">_syscall3</span></code> macro expands into a C function with inline assembly; the assembly performs the steps discussed in the previous section to push the system call number and parameters into the correct registers and issue <a id="filepos338645"></a>the software interrupt to trap into the kernel. Placing this macro in an application is all that is required to use the <code class="calibre6"><span class="calibre7">open()</span></code> system call.</p><div class="calibre_3"> </div>
<p class="calibre_2">Let’s write the macro to use our splendid new <code class="calibre6"><span class="calibre7">foo()</span></code> system call and then write some test code to show off our efforts.</p><div class="calibre_3"> </div>
<p class="calibre_31"><img alt="image" src="images/00044.jpg" class="calibre2"/></p><div class="calibre_7"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos339168"> </div>
<h4 class="calibre_27"><span class="calibre3">Why Not to Implement a System Call</span></h4><div class="calibre_24"> </div>
<p class="calibre_2">The previous sections have shown that it is easy to implement a new system call, but that in no way should encourage you to do so. Indeed, you should exercise caution and restraint in adding new syscalls. Often, much more viable alternatives to providing a new system call are available. Let’s look at the pros, cons, and alternatives.</p><div class="calibre_3"> </div>
<p class="calibre_2">The pros of implementing a new interface as a syscall are as follows:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• System calls are simple to implement and easy to use.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• System call performance on Linux is fast.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The cons:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• You need a syscall number, which needs to be officially assigned to you.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• After the system call is in a stable series kernel, it is written in stone. The interface cannot change without breaking user-space applications.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Each architecture needs to separately register the system call and support it.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• System calls are not easily used from scripts and cannot be accessed directly from the filesystem.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Because you need an assigned syscall number, it is hard to maintain and use a system call outside of the master kernel tree.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• For simple exchanges of information, a system call is overkill.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">The alternatives:</p><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Implement a device node and <code class="calibre6"><span class="calibre7">read()</span></code> and <code class="calibre6"><span class="calibre7">write()</span></code> to it. Use <code class="calibre6"><span class="calibre7">ioctl()</span></code> to manipulate specific settings or retrieve specific information.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Certain interfaces, such as semaphores, can be represented as file descriptors and manipulated as such.</p></blockquote><div class="calibre_3"> </div>
<blockquote class="calibre10"><p class="calibre_25">• Add the information as a file to the appropriate location in sysfs.</p></blockquote><div class="calibre_3"> </div>
<p class="calibre_2">For many interfaces, system calls <em class="calibre4">are</em> the correct answer. Linux, however, has tried to avoid simply adding a system call to support each new abstraction that comes along. The result has been an incredibly clean system call layer with few regrets or deprecations (interfaces no longer used or supported). The slow rate of addition of new system calls is a sign that Linux is a relatively stable and feature-complete operating system.</p><div class="calibre_3"> </div>
<p class="calibre_2"></p><div class="calibre_3" id="filepos342462"> </div>
<h3 class="calibre_21"><span class="bold">Conclusion</span></h3><div class="calibre_22"> </div>
<p class="calibre_2">In this chapter, we discussed what system calls are and how they relate to library calls and the application programming interface (API). We then looked at how the Linux kernel implements system calls and the chain of events required to execute a system call: trapping into the kernel, transmitting the syscall number and any arguments, executing the correct system call function, and returning to user-space with the syscall’s return value.</p><div class="calibre_3"> </div>
<p class="calibre_2">We then went over how to add system calls and provided a simple example of using a new system call from user-space. The whole process was quite easy! As the simplicity of adding a new system call demonstrates, the work is all in the syscall’s implementation. The rest of this book discusses concepts and kernel interfaces needed to write well-behaved, optimal, and safe system calls.</p><div class="calibre_3"> </div>
<p class="calibre_2">Finally, we wrapped up the chapter with a discussion on the pros and cons of implementing system calls and a brief list of the alternatives to adding new ones.</p><div class="calibre_3"> </div>  <div class="mbp_pagebreak" id="calibre_pb_39"></div>
</body></html>
