<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 14. File Systems</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Linux Programming Interface"/><link rel="prev" href="ch13.html" title="Chapter 13. File I/O Buffering"/><link rel="next" href="ch15.html" title="Chapter 15. File Attributes"/></head><body><section class="chapter" title="Chapter 14. File Systems" epub:type="chapter" id="file_systems"><div class="titlepage"><div><div><h2 class="title">Chapter 14. File Systems</h2></div></div></div><p>In <a class="xref" href="ch04.html" title="Chapter 4. File I/O: The Universal I/O Model">Chapter 4</a>, <a class="xref" href="ch05.html" title="Chapter 5. File I/O: Further Details">Chapter 5</a>, and <a class="xref" href="ch13.html" title="Chapter 13. File I/O Buffering">Chapter 13</a>, we looked at file I/O, with a particular
            focus on regular (i.e., disk) files. In this and the following chapters, we go into
            detail on a range of file-related topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>This chapter looks at file systems.</p></li><li class="listitem"><p><a class="xref" href="ch15.html" title="Chapter 15. File Attributes">Chapter 15</a> describes various attributes associated with
                    a file, including the timestamps, ownership, and permissions.</p></li><li class="listitem"><p><a class="xref" href="ch16.html" title="Chapter 16. Extended Attributes">Chapter 16</a> and 17 consider two new features of
                    Linux 2.6: extended attributes and access control lists (ACLs). Extended
                    attributes are a method of associating arbitrary metadata with a file. ACLs are
                    an extension of the traditional UNIX file permission model.</p></li><li class="listitem"><p><a class="xref" href="ch18.html" title="Chapter 18. Directories and Links">Chapter 18</a> looks at directories and
                    links.</p></li></ul></div><p>The majority of this chapter is concerned with file systems, which are organized
            collections of files and directories. We explain a range of file-system concepts,
            sometimes using the traditional Linux <span class="emphasis"><em>ext2</em></span> file system as a
            specific example. We also briefly describe some of the journaling file systems available
            on Linux.</p><p>We conclude the chapter with a discussion of the system calls used to mount and
            unmount a file system, and the library functions used to obtain information about
            mounted file systems.</p><div class="sect1" title="Device Special Files (Devices)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="device_special_files_open_parenthesis_de">Device Special Files (Devices)</h2></div></div></div><p>This chapter frequently mentions disk devices, so we start with a brief overview
                of the concept of a device file.<a id="IDX-CHP-14-1699" class="indexterm"/><a id="IDX-CHP-14-1700" class="indexterm"/><a id="IDX-CHP-14-1701" class="indexterm"/><a id="IDX-CHP-14-1702" class="indexterm"/><a id="IDX-CHP-14-1703" class="indexterm"/><a id="IDX-CHP-14-1704" class="indexterm"/><a id="IDX-CHP-14-1705" class="indexterm"/></p><p>A device special file corresponds to a device on the system. Within the kernel,
                each device type has a corresponding device driver, which handles all I/O requests
                for the device. A <span class="emphasis"><em>device driver</em></span> is a unit of kernel code that
                implements a set of operations that (normally) correspond to input and output
                actions on an associated piece of hardware. The API provided by device drivers is
                fixed, and includes operations corresponding to the system calls
                    <span class="emphasis"><em>open()</em></span>, <span class="emphasis"><em>close()</em></span>,
                    <span class="emphasis"><em>read()</em></span>, <span class="emphasis"><em>write()</em></span>,
                    <span class="emphasis"><em>mmap()</em></span>, and <span class="emphasis"><em>ioctl()</em></span>. The fact that
                each device driver provides a consistent interface, hiding the differences in
                operation of individual devices, allows for <span class="emphasis"><em>universality of I/O</em></span>
                    (<a class="xref" href="ch04.html#universality_of_i_solidus_o" title="Universality of I/O">Universality of I/O</a>).<a id="IDX-CHP-14-1706" class="indexterm"/></p><p>Some devices are real, such as mice, disks, and tape drives. Others are
                    <span class="emphasis"><em>virtual</em></span>, meaning that there is no corresponding hardware;
                rather, the kernel provides (via a device driver) an abstract device with an API
                that is the same as a real device.</p><p>Devices can be divided into two types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Character devices</em></span> handle data on a
                        character-by-character basis. Terminals and keyboards are examples of
                        character devices.</p></li><li class="listitem"><p><span class="emphasis"><em>Block devices</em></span> handle data a block at a time. The size
                        of a block depends on the type of device, but is typically some multiple of
                        512 bytes. Examples of block devices include disks and tape drives.</p></li></ul></div><p>Device files appear within the file system, just like other files, usually under
                the <code class="literal">/dev</code> directory. The superuser can create a
                device file using the <span class="emphasis"><em>mknod</em></span> command, and the same task can be
                performed in a privileged (<code class="literal">CAP_MKNOD</code>) program
                using the <span class="emphasis"><em>mknod()</em></span> system call.<a id="IDX-CHP-14-1707" class="indexterm"/><a id="IDX-CHP-14-1708" class="indexterm"/><a id="IDX-CHP-14-1709" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>We don’t describe the <span class="emphasis"><em>mknod()</em></span> (“make file-system i-node”)
                    system call in detail since its use is straightforward, and the only purpose for
                    which it is required nowadays is to create device files, which is not a common
                    application requirement. We can also use <span class="emphasis"><em>mknod()</em></span> to create
                    FIFOs (<a class="xref" href="ch44.html#fifos" title="FIFOs">FIFOs</a>), but the <span class="emphasis"><em>mkfifo()</em></span> function
                    is preferred for this task. Historically, some UNIX implementations also used
                        <span class="emphasis"><em>mknod()</em></span> for creating directories, but this use has now
                    been replaced by the <span class="emphasis"><em>mkdir()</em></span> system call. Nevertheless,
                    some UNIX implementations—but not Linux—preserve this capability in
                        <span class="emphasis"><em>mknod()</em></span> for backward compatibility. See the
                        <span class="emphasis"><em>mknod(2)</em></span> manual page for further details.</p></div><p>In earlier versions of Linux, <code class="literal">/dev</code> contained
                entries for all possible devices on the system, even if such devices weren’t
                actually connected to the system. This meant that <code class="literal">/dev</code> could contain literally thousands of unused entries, slowing the
                task of programs that needed to scan the contents of that directory, and making it
                impossible to use the contents of the directory as a means of discovering which
                devices were actually present on the system. In Linux 2.6, these problems are solved
                by the <span class="emphasis"><em>udev</em></span> program. The <span class="emphasis"><em>udev</em></span> program
                relies on the <span class="emphasis"><em>sysfs</em></span> file system, which exports information
                about devices and other kernel objects into user space via a pseudo-file system
                mounted under <code class="literal">/sys</code>.<a id="IDX-CHP-14-1710" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>[Kroah-Hartman, 2003] provides an overview of <span class="emphasis"><em>udev</em></span>, and
                    outlines the reasons it is considered superior to <span class="emphasis"><em>devfs</em></span>,
                    the Linux 2.4 solution to the same problems. Information about the
                        <span class="emphasis"><em>sysfs</em></span> file system can be found in the Linux 2.6 kernel
                    source file <code class="literal">Documentation/filesystems/sysfs.txt</code> and in [Mochel, 2005].</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="device_ids"/></div></div></div><div class="sect3" title="Device IDs"><div class="titlepage"><div><div><h4 class="title" id="device_ids-id1">Device IDs</h4></div></div></div><p>Each device file has a <span class="emphasis"><em>major ID number</em></span> and a
                            <span class="emphasis"><em>minor ID number</em></span>. The major ID identifies the
                        general class of device, and is used by the kernel to look up the
                        appropriate driver for this type of device. The minor ID uniquely identifies
                        a particular device within a general class. The major and minor IDs of a
                        device file are displayed by the <span class="emphasis"><em>ls -l</em></span>
                            command.<a id="IDX-CHP-14-1711" class="indexterm"/><a id="IDX-CHP-14-1712" class="indexterm"/><a id="IDX-CHP-14-1713" class="indexterm"/><a id="IDX-CHP-14-1714" class="indexterm"/><a id="IDX-CHP-14-1715" class="indexterm"/><a id="IDX-CHP-14-1716" class="indexterm"/></p><p>A device’s major and minor IDs are recorded in the i-node for the device
                        file. (We describe i-nodes in Section 14.4.) Each device driver registers
                        its association with a specific major device ID, and this association
                        provides the connection between the device special file and the device
                        driver. The name of the device file has no relevance when the kernel looks
                        for the device driver.</p><p>On Linux 2.4 and earlier, the total number of devices on the system is
                        limited by the fact that device major and minor IDs are each represented
                        using just 8 bits. The fact that major device IDs are fixed and centrally
                        assigned (by the Linux Assigned Names and Numbers Authority; see <a class="ulink" href="http://www.lanana.org/" target="_top">http://www.lanana.org/</a>) further exacerbates this limitation.
                        Linux 2.6 eases this limitation by using more bits to hold the major and
                        minor device IDs (respectively, 12 and 20 bits).</p></div></div></div><div class="sect1" title="Disks and Partitions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="disks_and_partitions">Disks and Partitions</h2></div></div></div><p>Regular files and directories typically reside on hard disk devices. (Files and
                directories may also exist on other devices, such as CD-ROMs, flash memory cards,
                and virtual disks, but for the present discussion, we are interested primarily in
                hard disk devices.) In the following sections, we look at how disks are organized
                and divided into partitions.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="disk_drives"/></div></div></div><div class="sect3" title="Disk drives"><div class="titlepage"><div><div><h4 class="title" id="disk_drives-id1">Disk drives</h4></div></div></div><p>A hard disk drive is a mechanical device consisting of one or more
                        platters that rotate at high speed (of the order of thousands of revolutions
                        per minute). Magnetically encoded information on the disk surface is
                        retrieved or modified by read/write heads that move radially across the
                        disk. Physically, information on the disk surface is located on a set of
                        concentric circles called <span class="emphasis"><em>tracks</em></span>. Tracks themselves are
                        divided into a number of <span class="emphasis"><em>sectors</em></span>, each of which
                        consists of a series of <span class="emphasis"><em>physical</em></span> blocks. Physical
                        blocks are typically 512 bytes (or some multiple thereof) in size, and
                        represent the smallest unit of information that the drive can read or
                            write.<a id="IDX-CHP-14-1717" class="indexterm"/></p><p>Although modern disks are fast, reading and writing information on the
                        disk still takes significant time. The disk head must first move to the
                        appropriate track (seek time), then the drive must wait until the
                        appropriate sector rotates under the head (rotational latency), and finally
                        the required blocks must be transferred (transfer time). The total time
                        required to carry out such an operation is typically of the order of
                        milliseconds. By comparison, modern CPUs are capable of executing millions
                        of instructions in this time.</p></div><div class="sect3" title="Disk partitions"><div class="titlepage"><div><div><h4 class="title" id="disk_partitions">Disk partitions</h4></div></div></div><p>Each disk is divided into one or more (nonoverlapping)
                            <span class="emphasis"><em>partitions</em></span>. Each partition is treated by the kernel
                        as a separate device residing under the <code class="literal">/dev</code> directory.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The system administrator determines the number, type, and size of
                            partitions on a disk using the <span class="emphasis"><em>fdisk</em></span> command. The
                            command <span class="emphasis"><em>fdisk -l</em></span> lists all partitions on a disk.
                            The Linux-specific <code class="literal">/proc/partitions</code>
                            file lists the major and minor device numbers, size, and name of each
                            disk partition on the system.<a id="IDX-CHP-14-1718" class="indexterm"/><a id="IDX-CHP-14-1719" class="indexterm"/><a id="IDX-CHP-14-1720" class="indexterm"/></p></div><p>A disk partition may hold any type of information, but usually contains
                        one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>a <span class="emphasis"><em>file system</em></span> holding regular files and
                                directories, as described in <a class="xref" href="ch14.html#file_systems-id1" title="File Systems">File Systems</a>;<a id="IDX-CHP-14-1721" class="indexterm"/></p></li><li class="listitem"><p>a <span class="emphasis"><em>data area</em></span> accessed as a raw-mode device, as
                                described in <a class="xref" href="ch13.html#bypassing_the_buffer_cache_colon_direct" title="Bypassing the Buffer Cache: Direct I/O">Bypassing the Buffer Cache: Direct I/O</a> (some database management systems use this technique); or</p></li><li class="listitem"><p>a <span class="emphasis"><em>swap area</em></span> used by the kernel for memory
                                    management.<a id="IDX-CHP-14-1722" class="indexterm"/></p></li></ul></div><p>A swap area is created using the <span class="emphasis"><em>mkswap(8)</em></span> command. A
                        privileged (<code class="literal">CAP_SYS_ADMIN</code>) process can
                        use the <span class="emphasis"><em>swapon()</em></span> system call to notify the kernel that
                        a disk partition is to be used as a swap area. The
                            <span class="emphasis"><em>swapoff()</em></span> system call performs the converse
                        function, telling the kernel to cease using a disk partition as a swap area.
                        These system calls are not standardized in SUSv3, but they exist on many
                        UNIX implementations. See the <span class="emphasis"><em>swapon(2)</em></span>, and
                            <span class="emphasis"><em>swapon(8)</em></span> manual pages for additional
                            information.<a id="IDX-CHP-14-1723" class="indexterm"/><a id="IDX-CHP-14-1724" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The Linux-specific <code class="literal">/proc/swaps</code> file
                            can be used to display information about the currently enabled swap
                            areas on the system. This information includes the size of each swap
                            area and the amount of the area that is in use.<a id="IDX-CHP-14-1725" class="indexterm"/></p></div></div></div></div><div class="sect1" title="File Systems"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="file_systems-id1">File Systems</h2></div></div></div><p>A file system is an organized collection of regular files and directories. A file
                system is created using the <span class="emphasis"><em>mkfs</em></span> command.<a id="IDX-CHP-14-1726" class="indexterm"/><a id="IDX-CHP-14-1727" class="indexterm"/><a id="IDX-CHP-14-1728" class="indexterm"/><a id="IDX-CHP-14-1729" class="indexterm"/><a id="IDX-CHP-14-1730" class="indexterm"/></p><p>One of the strengths of Linux is that it supports a wide variety of file systems,
                including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>the traditional <span class="emphasis"><em>ext2</em></span> file system;</p></li><li class="listitem"><p>various native UNIX file systems such as the Minix, System V, and BSD file
                        systems;</p></li><li class="listitem"><p>Microsoft’s FAT, FAT32, and NTFS file systems;</p></li><li class="listitem"><p>the ISO 9660 CD-ROM file system;</p></li><li class="listitem"><p>Apple Macintosh’s HFS;</p></li><li class="listitem"><p>a range of network file systems, including Sun’s widely used NFS
                        (information about the Linux implementation of NFS is available at <a class="ulink" href="http://nfs.sourceforge.net/" target="_top">http://nfs.sourceforge.net/</a>), IBM and Microsoft’s SMB, Novell’s
                        NCP, and the Coda file system developed at Carnegie Mellon University;
                        and</p></li><li class="listitem"><p>a range of journaling file systems, including <span class="emphasis"><em>ext3</em></span>,
                            <span class="emphasis"><em>ext4</em></span>, <span class="emphasis"><em>Reiserfs</em></span>,
                            <span class="emphasis"><em>JFS</em></span>, <span class="emphasis"><em>XFS</em></span>, and
                            <span class="emphasis"><em>Btrfs</em></span>.</p></li></ul></div><p>The file-system types currently known by the kernel can be viewed in the
                Linux-specific <code class="literal">/proc/filesystems</code> file.<a id="IDX-CHP-14-1731" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Linux 2.6.14 added the <span class="emphasis"><em>Filesystem in Userspace</em></span> (FUSE)
                    facility. This mechanism adds hooks to the kernel that allow a file system to be
                    completely implemented via a user-space program, without needing to patch or
                    recompile the kernel. For further details, see <a class="ulink" href="http://fuse.sourceforge.net/" target="_top">http://fuse.sourceforge.net/</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="the_ext2_file_system"/></div></div></div><div class="sect3" title="The ext2 file system"><div class="titlepage"><div><div><h4 class="title" id="the_ext2_file_system-id1">The <span class="emphasis"><em>ext2</em></span> file system</h4></div></div></div><p>For many years, the most widely used file system on Linux was
                            <span class="emphasis"><em>ext2</em></span>, the <span class="emphasis"><em>Second Extended File
                            System</em></span>, which is the successor to the original Linux file
                        system, <span class="emphasis"><em>ext</em></span>. In more recent times, the use of
                            <span class="emphasis"><em>ext2</em></span> has declined in favor of various journaling
                        file systems. Sometimes, it is useful to describe generic file-system
                        concepts in terms of a specific file-system implementation, and for this
                        purpose, we use <span class="emphasis"><em>ext2</em></span> as an example at various points
                        later in this chapter.<a id="IDX-CHP-14-1733" class="indexterm"/><a id="IDX-CHP-14-1734" class="indexterm"/><a id="IDX-CHP-14-1735" class="indexterm"/><a id="IDX-CHP-14-1736" class="indexterm"/><a id="IDX-CHP-14-1737" class="indexterm"/><a id="IDX-CHP-14-1738" class="indexterm"/><a id="IDX-CHP-14-1739" class="indexterm"/><a id="IDX-CHP-14-1740" class="indexterm"/><a id="IDX-CHP-14-1732" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>ext2</em></span> file system was written by Remy Card.
                            The source code for <span class="emphasis"><em>ext2</em></span> is small (around 5000
                            lines of C) and forms the model for several other file-system
                            implementations. The <span class="emphasis"><em>ext2</em></span> home page is <a class="ulink" href="http://e2fsprogs.sourceforge.net/ext2.html" target="_top">http://e2fsprogs.sourceforge.net/ext2.html</a>. This web site
                            includes a good overview paper describing the implementation of
                                <span class="emphasis"><em>ext2</em></span>. <span class="emphasis"><em>The Linux Kernel</em></span>, an
                            online book by David Rusling available at <a class="ulink" href="http://www.tldp.org/" target="_top">http://www.tldp.org/</a>, also describes
                                <span class="emphasis"><em>ext2</em></span>.</p></div></div><div class="sect3" title="File-system structure"><div class="titlepage"><div><div><h4 class="title" id="file-system_structure">File-system structure</h4></div></div></div><p>The basic unit for allocating space in a file system is a
                            <span class="emphasis"><em>logical</em></span> block, which is some multiple of contiguous
                        physical blocks on the disk device on which the file system resides. For
                        example, the logical block size on <span class="emphasis"><em>ext2</em></span> is 1024, 2048,
                        or 4096 bytes. (The logical block size is specified as an argument of the
                            <span class="emphasis"><em>mkfs(8)</em></span> command used to build the file
                            system.)<a id="IDX-CHP-14-1741" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>A privileged (<code class="literal">CAP_SYS_RAWIO</code>)
                            program can use the <code class="literal">FIBMAP</code>
                            <span class="emphasis"><em>ioctl()</em></span> operation to determine the physical
                            location of a specified block of a file. The third argument of the call
                            is a value-result integer. Before the call, this argument should be set
                            to a logical block number (the first logical block is number 0); after
                            the call, it is set to the number of the starting physical block where
                            that logical block is stored.</p></div><p><a class="xref" href="ch14.html#layout_of_disk_partitions_and_a_file_sys" title="Figure 14-1. Layout of disk partitions and a file system">Figure 14-1</a> shows the
                        relationship between disk partitions and file systems, and shows the parts
                        of a (generic) file system.</p><div class="figure"><a id="layout_of_disk_partitions_and_a_file_sys"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject14_d1e32054"/><img src="figs/web/14-1_FS-file-systems-scale90.png.jpg" alt="Layout of disk partitions and a file system"/></div></div><div class="figure-title">Figure 14-1. Layout of disk partitions and a file system</div></div><p>A file system contains the following parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Boot block</em></span>: This is always the first block in
                                a file system. The boot block is not used by the file system;
                                rather, it contains information used to boot the operating system.
                                Although only one boot block is needed by the operating system, all
                                file systems have a boot block (most of which are unused).<a id="IDX-CHP-14-1742" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Superblock</em></span>: This is a single block,
                                immediately following the boot block, which contains parameter
                                information about the file system, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>the size of the i-node table;<a id="IDX-CHP-14-1743" class="indexterm"/></p></li><li class="listitem"><p>the size of logical blocks in this file system; and</p></li><li class="listitem"><p>the size of the file system in logical blocks.</p></li></ul></div><p>Different file systems residing on the same physical device can be
                                of different types and sizes, and have different parameter settings
                                (e.g., block size). This is one of the reasons for splitting a disk
                                into multiple partitions.</p></li><li class="listitem"><p><span class="emphasis"><em>I-node table</em></span>: Each file or directory in the
                                file system has a unique entry in the i-node table. This entry
                                records various information about the file. I-nodes are discussed in
                                greater detail in the next section. The i-node table is sometimes
                                also called the <span class="emphasis"><em>i-list</em></span>.<a id="IDX-CHP-14-1744" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Data blocks</em></span>: The great majority of space in a
                                file system is used for the blocks of data that form the files and
                                directories residing in the file system.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In the specific case of the <span class="emphasis"><em>ext2</em></span> file
                                    system, the picture is somewhat more complex than described in
                                    the main text. After the initial boot block, the file system is
                                    broken into a set of equal-sized <span class="emphasis"><em>block
                                        groups</em></span>. Each block group contains a copy of the
                                    superblock, parameter information about the block group, and
                                    then the i-node table and data blocks for this block group. By
                                    attempting to store all of the blocks of a file within the same
                                    block group, the <span class="emphasis"><em>ext2</em></span> file system aims to
                                    reduce seek time when sequentially accessing a file. For further
                                    information, see the Linux source code file <code class="literal">Documentation/filesystems/ext2.txt</code>, the source code
                                    of the <span class="emphasis"><em>dumpe2fs</em></span> program that comes as part
                                    of the <span class="emphasis"><em>e2fsprogs</em></span> package, and [Bovet
                                    &amp; Cesati, 2005].<a id="IDX-CHP-14-1745" class="indexterm"/></p></div></li></ul></div></div></div></div><div class="sect1" title="I-nodes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="i-nodes">I-nodes</h2></div></div></div><p>A file system’s i-node table contains one i-node (short for <span class="emphasis"><em>index
                    node</em></span>) for each file residing in the file system. I-nodes are
                identified numerically by their sequential location in the i-node table. The
                    <span class="emphasis"><em>i-node number</em></span> (or simply <span class="emphasis"><em>i-number</em></span>) of
                a file is the first field displayed by the <span class="emphasis"><em>ls -li</em></span> command. The
                information maintained in an i-node includes the following:<a id="IDX-CHP-14-1746" class="indexterm"/><a id="IDX-CHP-14-1747" class="indexterm"/><a id="IDX-CHP-14-1748" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>File type (e.g., regular file, directory, symbolic link, character
                            device).<a id="IDX-CHP-14-1749" class="indexterm"/></p></li><li class="listitem"><p>Owner (also referred to as the user ID or UID) for the file.</p></li><li class="listitem"><p>Group (also referred to as the group ID or GID) for the file.</p></li><li class="listitem"><p>Access permissions for three categories of user:
                            <span class="emphasis"><em>owner</em></span> (sometimes referred to as
                            <span class="emphasis"><em>user</em></span>), <span class="emphasis"><em>group</em></span>, and
                            <span class="emphasis"><em>other</em></span> (the rest of the world). <a class="xref" href="ch15.html#file_permissions" title="File Permissions">File Permissions</a> provides further details.</p></li><li class="listitem"><p>Three timestamps: time of last access to the file (shown by <span class="emphasis"><em>ls
                            -lu</em></span>), time of last modification of the file (the default time
                        shown by <span class="emphasis"><em>ls -l</em></span>), and time of last status change (last
                        change to i-node information, shown by <span class="emphasis"><em>ls -lc</em></span>). As on
                        other UNIX implementations, it is notable that most Linux file systems don’t
                        record the creation time of a file.</p></li><li class="listitem"><p>Number of hard links to the file.</p></li><li class="listitem"><p>Size of the file in bytes.</p></li><li class="listitem"><p>Number of blocks actually allocated to the file, measured in units of
                        512-byte blocks. There may not be a simple correspondence between this
                        number and the size of the file in bytes, since a file can contain holes
                            (<a class="xref" href="ch04.html#changing_the_file_offset_colon_lseek_ope" title="Changing the File Offset: lseek()">Changing the File Offset: <span class="emphasis"><em>lseek()</em></span></a>), and thus
                        require fewer allocated blocks than would be expected according to its
                        nominal size in bytes.</p></li><li class="listitem"><p>Pointers to the data blocks of the file.</p></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="i-nodes_and_data_block_pointers_in"/></div></div></div><div class="sect3" title="I-nodes and data block pointers in ext2"><div class="titlepage"><div><div><h4 class="title" id="i-nodes_and_data_block_pointers_in-id1">I-nodes and data block pointers in <span class="emphasis"><em>ext2</em></span></h4></div></div></div><p>Like most UNIX file systems, the <span class="emphasis"><em>ext2</em></span> file system
                        doesn’t store the data blocks of a file contiguously or even in sequential
                        order (though it does attempt to store them close to one another). To locate
                        the file data blocks, the kernel maintains a set of pointers in the i-node.
                        The system used for doing this on the <span class="emphasis"><em>ext2</em></span> file system
                        is shown in <a class="xref" href="ch14.html#structure_of_file_blocks_for_a_file_in_a" title="Figure 14-2. Structure of file blocks for a file in an ext2 file system">Figure 14-2</a>.<a id="IDX-CHP-14-1750" class="indexterm"/><a id="IDX-CHP-14-1751" class="indexterm"/><a id="IDX-CHP-14-1752" class="indexterm"/><a id="IDX-CHP-14-1753" class="indexterm"/><a id="IDX-CHP-14-1754" class="indexterm"/><a id="IDX-CHP-14-1755" class="indexterm"/><a id="IDX-CHP-14-1756" class="indexterm"/><a id="IDX-CHP-14-1757" class="indexterm"/><a id="IDX-CHP-14-1758" class="indexterm"/><a id="IDX-CHP-14-1759" class="indexterm"/><a id="IDX-CHP-14-1760" class="indexterm"/><a id="IDX-CHP-14-1761" class="indexterm"/><a id="IDX-CHP-14-1762" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Removing the need to store the blocks of a file contiguously allows
                            the file system to use space in an efficient way. In particular, it
                            reduces the incidence of <span class="emphasis"><em>fragmentation</em></span> of free disk
                            space—the wastage created by the existence of numerous pieces of
                            noncontiguous free space, all of which are too small to use. Put
                            conversely, we could say that the advantage of efficiently using the
                            free disk space is paid for by fragmenting files in the filled disk
                            space.</p></div><p>Under <span class="emphasis"><em>ext2</em></span>, each i-node contains 15 pointers. The
                        first 12 of these pointers (numbered 0 to 11 in <a class="xref" href="ch14.html#structure_of_file_blocks_for_a_file_in_a" title="Figure 14-2. Structure of file blocks for a file in an ext2 file system">Figure 14-2</a>) point to the
                        location in the file system of the first 12 blocks of the file. The next
                        pointer is a <span class="emphasis"><em>pointer to a block of pointers</em></span> that give
                        the locations of the thirteenth and subsequent data blocks of the file. The
                        number of pointers in this block depends on the block size of the file
                        system. Each pointer requires 4 bytes, so there may be from 256 pointers
                        (for a 1024-byte block size) to 1024 pointers (for a 4096-byte block size).
                        This allows for quite large files. For even larger files, the fourteenth
                        pointer (numbered 13 in the diagram) is a <span class="emphasis"><em>double indirect
                            pointer</em></span>—it points to blocks of pointers that in turn point to
                        blocks of pointers that in turn point to data blocks of the file. And should
                        the need for a truly enormous file arise, there is a further level of
                        indirection: the last pointer in the i-node is a <span class="emphasis"><em>triple-indirect
                            pointer</em></span>.</p><p>This seemingly complex system is designed to satisfy a number of
                        requirements. To begin with, it allows the i-node structure to be a fixed
                        size, while at the same time allowing for files of an arbitrary size.
                        Additionally, it allows the file system to store the blocks of a file
                        noncontiguously, while also allowing the data to be accessed randomly via
                            <span class="emphasis"><em>lseek()</em></span>; the kernel just needs to calculate which
                        pointer(s) to follow. Finally, for small files, which form the overwhelming
                        majority of files on most systems, this scheme allows the file data blocks
                        to be accessed rapidly via the direct pointers of the i-node.<a id="IDX-CHP-14-1763" class="indexterm"/></p><div class="figure"><a id="structure_of_file_blocks_for_a_file_in_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject14_d1e32331"/><img src="figs/web/14-2_FS-file-blocks.png.jpg" alt="Structure of file blocks for a file in an ext2 file system"/></div></div><div class="figure-title">Figure 14-2. Structure of file blocks for a file in an <span class="emphasis"><em>ext2</em></span>
                            file system</div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>As an example, the author measured one system containing somewhat more
                            than 150,000 files. Just over 30% of the files were less than 1000 bytes
                            in size, and 80% occupied 10,000 bytes or less. Assuming a 1024-byte
                            block size, all of the latter files could be referenced using just the
                            12 direct pointers, which can refer to blocks containing a total of
                            12,288 bytes. Using a 4096-byte block size, this limit rises to 49,152
                            bytes (95% of the files on the system fell under that limit).</p></div><p>This design also allows for enormous file sizes; for a block size of 4096
                        bytes, the theoretical largest file size is slightly more than
                        1024*1024*1024*4096, or approximately 4 terabytes (4096 GB). (We say
                            <span class="emphasis"><em>slightly more</em></span> because of the blocks pointed to by
                        the direct, indirect, and double indirect pointers. These are insignificant
                        compared to the range that can be pointed to by the triple indirect
                        pointer.)</p><p>One other benefit conferred by this design is that files can have holes,
                        as described in Section 4.7. Rather than allocate blocks of null bytes for
                        the holes in a file, the file system can just mark (with the value 0)
                        appropriate pointers in the i-node and in the indirect pointer blocks to
                        indicate that they don’t refer to actual disk blocks.<a id="IDX-CHP-14-1764" class="indexterm"/></p></div></div></div><div class="sect1" title="The Virtual File System (VFS)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_virtual_file_system_open_parenthesis">The Virtual File System (VFS)</h2></div></div></div><p>Each of the file systems available on Linux differs in the details of its
                implementation. Such differences include, for example, the way in which the blocks
                of a file are allocated and the manner in which directories are organized. If every
                program that worked with files needed to understand the specific details of each
                file system, the task of writing programs that worked with all of the different file
                systems would be nearly impossible. The <span class="emphasis"><em>virtual file system</em></span>
                (VFS, sometimes also referred to as the <span class="emphasis"><em>virtual file switch</em></span>) is
                a kernel feature that resolves this problem by creating an abstraction layer for
                file-system operations (see <a class="xref" href="ch14.html#the_virtual_file_system" title="Figure 14-3. The virtual file system">Figure 14-3</a>). The ideas
                behind the VFS are straightforward:<a id="IDX-CHP-14-1765" class="indexterm"/><a id="IDX-CHP-14-1766" class="indexterm"/><a id="IDX-CHP-14-1767" class="indexterm"/><a id="IDX-CHP-14-1768" class="indexterm"/><a id="IDX-CHP-14-1769" class="indexterm"/><a id="IDX-CHP-14-1770" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The VFS defines a generic interface for file-system operations. All
                        programs that work with files specify their operations in terms of this
                        generic interface.</p></li><li class="listitem"><p>Each file system provides an implementation for the VFS interface.</p></li></ul></div><p>Under this scheme, programs need to understand only the VFS interface and can
                ignore details of individual file-system implementations.</p><p>The VFS interface includes operations corresponding to all of the usual system
                calls for working with file systems and directories, such as
                    <span class="emphasis"><em>open()</em></span>, <span class="emphasis"><em>read()</em></span>,
                    <span class="emphasis"><em>write()</em></span>, <span class="emphasis"><em>lseek()</em></span>,
                    <span class="emphasis"><em>close()</em></span>, <span class="emphasis"><em>truncate()</em></span>,
                    <span class="emphasis"><em>stat()</em></span>, <span class="emphasis"><em>mount()</em></span>,
                    <span class="emphasis"><em>umount()</em></span>, <span class="emphasis"><em>mmap()</em></span>,
                    <span class="emphasis"><em>mkdir()</em></span>, <span class="emphasis"><em>link()</em></span>,
                    <span class="emphasis"><em>unlink()</em></span>, <span class="emphasis"><em>symlink()</em></span>, and
                    <span class="emphasis"><em>rename()</em></span>.</p><p>The VFS abstraction layer is closely modeled on the traditional UNIX file-system
                model. Naturally, some file systems—especially non-UNIX file systems—don’t support
                all of the VFS operations (e.g., Microsoft’s VFAT doesn’t support the notion of
                symbolic links, created using <span class="emphasis"><em>symlink()</em></span>). In such cases, the
                underlying file system passes an error code back to the VFS layer indicating the
                lack of support, and the VFS in turn passes this error code back to the
                application.</p><div class="figure"><a id="the_virtual_file_system"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject14_d1e32455"/><img src="figs/web/14-3_FS-VFS-scale90.png.jpg" alt="The virtual file system"/></div></div><div class="figure-title">Figure 14-3. The virtual file system</div></div></div><div class="sect1" title="Journaling File Systems"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="journaling_file_systems">Journaling File Systems</h2></div></div></div><p>The <span class="emphasis"><em>ext2</em></span> file system is a good example of a traditional UNIX
                file system, and suffers from a classic limitation of such file systems: after a
                system crash, a file-system consistency check (<span class="emphasis"><em>fsck</em></span>) must be
                performed on reboot in order to ensure the integrity of the file system. This is
                necessary because, at the time of the system crash, a file update may have been only
                partially completed, and the file-system metadata (directory entries, i-node
                information, and file data block pointers) may be in an inconsistent state, so that
                the file system might be further damaged if these inconsistencies are not repaired.
                A file-system consistency check ensures the consistency of the file-system metadata.
                Where possible, repairs are performed; otherwise, information that is not
                retrievable (possibly including file data) is discarded.<a id="IDX-CHP-14-1771" class="indexterm"/><a id="IDX-CHP-14-1772" class="indexterm"/></p><p>The problem is that a consistency check requires examining the entire file system.
                On a small file system, this may take anything from several seconds to a few
                minutes. On a large file system, this may require several hours, which is a serious
                problem for systems that must maintain high availability (e.g., network
                servers).</p><p>Journaling file systems eliminate the need for lengthy file-system consistency
                checks after a system crash. A journaling file system logs (journals) all metadata
                updates to a special on-disk journal file before they are actually carried out. The
                updates are logged in groups of related metadata updates
                    (<span class="emphasis"><em>transactions</em></span>). In the event of a system crash in the
                middle of a transaction, on system reboot, the log can be used to rapidly redo any
                incomplete updates and bring the file system back to a consistent state. (To borrow
                database parlance, we can say that a journaling file system ensures that file
                metadata transactions are always <span class="emphasis"><em>committed</em></span> as a complete unit.)
                Even very large journaling file systems can typically be available within seconds
                after a system crash, making them very attractive for systems with high-availability
                    requirements.<a id="IDX-CHP-14-1773" class="indexterm"/></p><p>The most notable disadvantage of journaling is that it adds time to file updates,
                though good design can make this overhead low.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some journaling file systems ensure only the consistency of file metadata.
                    Because they don’t log file data, data may still be lost in the event of a
                    crash. The <span class="emphasis"><em>ext3</em></span>, <span class="emphasis"><em>ext4</em></span>, and
                        <span class="emphasis"><em>Reiserfs</em></span> file systems provide options for logging data
                    updates, but, depending on the workload, this may result in lower file I/O
                    performance.</p></div><p>The journaling file systems available for Linux include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Reiserfs</em></span> was the first of the journaling file systems
                        to be integrated into the kernel (in version 2.4.1).
                            <span class="emphasis"><em>Reiserfs</em></span> provides a feature called <span class="emphasis"><em>tail
                            packing</em></span> (or <span class="emphasis"><em>tail merging</em></span>): small files
                        (and the final fragment of larger files) are packed into the same disk
                        blocks as the file metadata. Because many systems have (and some
                        applications create) large numbers of small files, this can save a
                        significant amount of disk space.<a id="IDX-CHP-14-1774" class="indexterm"/></p></li><li class="listitem"><p>The <span class="emphasis"><em>ext3</em></span> file system was a result of a project to add
                        journaling to <span class="emphasis"><em>ext2</em></span> with minimal impact. The migration
                        path from <span class="emphasis"><em>ext2</em></span> to <span class="emphasis"><em>ext3</em></span> is very
                        easy (no backup and restore are required), and it is possible to migrate in
                        the reverse direction as well. The <span class="emphasis"><em>ext3</em></span> file system was
                        integrated into the kernel in version 2.4.15.<a id="IDX-CHP-14-1775" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>JFS</em></span> was developed at IBM. It was integrated into the
                        2.4.20 kernel.</p></li><li class="listitem"><p><span class="emphasis"><em>XFS</em></span> (<a class="ulink" href="http://oss.sgi.com/projects/xfs/" target="_top">http://oss.sgi.com/projects/xfs/</a>)
                        was originally developed by Silicon Graphics (SGI) in the early 1990s for
                        Irix, its proprietary UNIX implementation. In 2001, <span class="emphasis"><em>XFS</em></span>
                        was ported to Linux and made available as a free software project.
                            <span class="emphasis"><em>XFS</em></span> was integrated into the 2.4.24 kernel.</p></li></ul></div><p>Support for the various file systems is enabled using kernel options that are set
                under the <span class="emphasis"><em>File systems</em></span> menu when configuring the kernel.</p><p>At the time of writing, work is in progress on two other file systems that provide
                journaling and a range of other advanced features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>ext4</em></span> file system (<a class="ulink" href="http://ext4.wiki.kernel.org/" target="_top">http://ext4.wiki.kernel.org/</a>) is the successor to
                            <span class="emphasis"><em>ext3</em></span>. The first pieces of the implementation were
                        added in kernel 2.6.19, and various features were added in later kernel
                        versions. Among the planned (or already implemented) features for
                            <span class="emphasis"><em>ext4</em></span> are extents (reservation of contiguous blocks
                        of storage) and other allocation features that aim to reduce file
                        fragmentation, online file-system defragmentation, faster file-system
                        checking, and support for nanosecond timestamps.<a id="IDX-CHP-14-1776" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>Btrfs</em></span> (B-tree FS, usually pronounced “butter FS”;
                            <a class="ulink" href="http://btrfs.wiki.kernel.org/" target="_top">http://btrfs.wiki.kernel.org/</a>) is a new file system
                        designed from the ground up to provide a range of modern features, including
                        extents, writable snapshots (which provide functionality equivalent to
                        metadata and data journaling), checksums on data and metadata, online
                        file-system checking, online file-system defragmentation, space-efficient
                        packing of small files, and space-efficient indexed directories. It was
                        integrated into the kernel in version 2.6.29.</p></li></ul></div></div><div class="sect1" title="Single Directory Hierarchy and Mount Points"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="single_directory_hierarchy_and_mount_poi">Single Directory Hierarchy and Mount Points</h2></div></div></div><p>On Linux, as on other UNIX systems, all files from all file systems reside under a
                single directory tree. At the base of this tree is the root directory, <code class="literal">/</code> (slash). Other file systems are
                    <span class="emphasis"><em>mounted</em></span> under the root directory and appear as subtrees
                within the overall hierarchy. The superuser uses a command of the following form to
                mount a file system:<a id="IDX-CHP-14-1777" class="indexterm"/><a id="IDX-CHP-14-1778" class="indexterm"/><a id="IDX-CHP-14-1779" class="indexterm"/><a id="IDX-CHP-14-1780" class="indexterm"/><a id="IDX-CHP-14-1781" class="indexterm"/><a id="IDX-CHP-14-1782" class="indexterm"/></p><a id="I_programlisting14_d1e32644"/><pre class="programlisting">$ <strong class="userinput"><code>mount</code></strong> <strong class="userinput"><code><em class="replaceable"><code>device directory</code></em></code></strong></pre><p>This command attaches the file system on the named <span class="emphasis"><em>device</em></span>
                into the directory hierarchy at the specified <span class="emphasis"><em>directory</em></span>—the
                file system’s <span class="emphasis"><em>mount point</em></span>. It is possible to change the
                location at which a file system is mounted—the file system is unmounted using the
                    <span class="emphasis"><em>umount</em></span> command, and then mounted once more at a different
                    point.<a id="IDX-CHP-14-1783" class="indexterm"/><a id="IDX-CHP-14-1784" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>With Linux 2.4.19 and later, things became more complicated. The kernel now
                    supports per-process <span class="emphasis"><em>mount namespaces</em></span>. This means that each
                    process potentially has its own set of file-system mount points, and thus may
                    see a different single directory hierarchy from other processes. We explain this
                    point further when we describe the <code class="literal">CLONE_NEWNS</code> flag in <a class="xref" href="ch28.html#example_program-id39" title="Example program">Example program</a>.</p></div><p>To list the currently mounted file systems, we can use the command
                    <span class="emphasis"><em>mount</em></span>, with no arguments, as in the following example
                (whose output has been somewhat abridged):</p><a id="I_programlisting14_d1e32690"/><pre class="programlisting">$ <strong class="userinput"><code>mount</code></strong>
/dev/sda6 on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,mode=0620,gid=5)
/dev/sda8 on /home type ext3 (rw,acl,user_xattr)
/dev/sda1 on /windows/C type vfat (rw,noexec,nosuid,nodev)
/dev/sda9 on /home/mtk/test type reiserfs (rw)</pre><p><a class="xref" href="ch14.html#example_directory_hierarchy_showing_file" title="Figure 14-4. Example directory hierarchy showing file-system mount points">Figure 14-4</a> shows a partial
                directory and file structure for the system on which the above
                    <span class="emphasis"><em>mount</em></span> command was performed. This diagram shows how the
                mount points map onto the directory hierarchy.</p><div class="figure"><a id="example_directory_hierarchy_showing_file"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject14_d1e32704"/><img src="figs/web/14-4_FS-mount.png.jpg" alt="Example directory hierarchy showing file-system mount points"/></div></div><div class="figure-title">Figure 14-4. Example directory hierarchy showing file-system mount points</div></div></div><div class="sect1" title="Mounting and Unmounting File Systems"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="mounting_and_unmounting_file_systems">Mounting and Unmounting File Systems</h2></div></div></div><p>The <span class="emphasis"><em>mount()</em></span> and <span class="emphasis"><em>umount()</em></span> system calls
                allow a privileged (<code class="literal">CAP_SYS_ADMIN</code>) process to
                mount and unmount file systems. Most UNIX implementations provide versions of these
                system calls. However, they are not standardized by SUSv3, and their operation
                varies both across UNIX implementations and across file systems.<a id="IDX-CHP-14-1785" class="indexterm"/><a id="IDX-CHP-14-1786" class="indexterm"/><a id="IDX-CHP-14-1787" class="indexterm"/></p><p>Before looking at these system calls, it is useful to know about three files that
                contain information about the file systems that are currently mounted or can be
                mounted:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A list of the currently mounted file systems can be read from the
                        Linux-specific <code class="literal">/proc/mounts</code> virtual file.
                            <code class="literal">/proc/mounts</code> is an interface to
                        kernel data structures, so it always contains accurate information about
                        mounted file systems.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>With the arrival of the per-process mount namespace feature mentioned
                            earlier, each process now has a <code class="literal">/proc/</code><span class="emphasis"><em>PID</em></span><code class="literal">/mounts</code> file that lists the mount points constituting its
                            mount namespace, and <code class="literal">/proc/mounts</code> is
                            just a symbolic link to /<code class="literal">proc/self/mounts</code>.<a id="IDX-CHP-14-1788" class="indexterm"/><a id="IDX-CHP-14-1789" class="indexterm"/><a id="IDX-CHP-14-1790" class="indexterm"/></p></div></li><li class="listitem"><p>The <span class="emphasis"><em>mount(8)</em></span> and <span class="emphasis"><em>umount(8)</em></span>
                        commands automatically maintain the file <code class="literal">/etc/mtab</code>, which contains information that is similar to that
                        in <code class="literal">/proc/mounts</code>, but slightly more
                        detailed. In particular, <code class="literal">/etc/mtab</code>
                        includes file system–specific options given to
                        <span class="emphasis"><em>mount(8)</em></span>, which are not shown in <code class="literal">/proc/mounts</code>. However, because the
                            <span class="emphasis"><em>mount()</em></span> and <span class="emphasis"><em>umount()</em></span> system
                        calls don’t update <code class="literal">/etc/mtab</code>, this file
                        may be inaccurate if some application that mounts or unmounts devices fails
                        to update it.</p></li><li class="listitem"><p>The <code class="literal">/etc/fstab</code> file, maintained
                        manually by the system administrator, contains descriptions of all of the
                        available file systems on a system, and is used by the
                            <span class="emphasis"><em>mount(8)</em></span>, <span class="emphasis"><em>umount(8)</em></span>, and
                            <span class="emphasis"><em>fsck(8)</em></span> commands.<a id="IDX-CHP-14-1791" class="indexterm"/></p></li></ul></div><p>The <code class="literal">/proc/mounts</code>, <code class="literal">/etc/mtab</code>, and <code class="literal">/etc/fstab</code> files
                share a common format, described in the <span class="emphasis"><em>fstab(5)</em></span> manual page.
                Here is an example of a line from the <code class="literal">/proc/mounts</code> file:<a id="IDX-CHP-14-1792" class="indexterm"/></p><a id="I_programlisting14_d1e32865"/><pre class="programlisting">/dev/sda9 /boot ext3 rw 0 0</pre><p>This line contains six fields:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The name of the mounted device.</p></li><li class="listitem"><p>The mount point for the device.<a id="IDX-CHP-14-1793" class="indexterm"/></p></li><li class="listitem"><p>The file-system type.</p></li><li class="listitem"><p>Mount flags. In the above example, <span class="emphasis"><em>rw</em></span> indicates that
                        the file system was mounted read-write.</p></li><li class="listitem"><p>A number used to control the operation of file-system backups by
                            <span class="emphasis"><em>dump(8)</em></span>. This field and the next are used only in
                        the <code class="literal">/etc/fstab</code> file; for <code class="literal">/proc/mounts</code> and /<code class="literal">etc/mtab</code>, these fields are always 0.</p></li><li class="listitem"><p>A number used to control the order in which <span class="emphasis"><em>fsck(8)</em></span>
                        checks file systems at system boot time.</p></li></ol></div><p>The <span class="emphasis"><em>getfsent(3)</em></span> and <span class="emphasis"><em>getmntent(3)</em></span> manual
                pages document functions that can be used to read records from these files.</p><div class="sect2" title="Mounting a File System: mount()"><div class="titlepage"><div><div><h3 class="title" id="mounting_a_file_system_colon_mount_open">Mounting a File System: <span class="emphasis"><em>mount()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>mount()</em></span> system call mounts the file system contained
                    on the device specified by <span class="emphasis"><em>source</em></span> under the directory (the
                        <span class="emphasis"><em>mount point</em></span>) specified by
                        <span class="emphasis"><em>target</em></span>.<a id="IDX-CHP-14-1794" class="indexterm"/><a id="IDX-CHP-14-1795" class="indexterm"/><a id="IDX-CHP-14-1796" class="indexterm"/><a id="IDX-CHP-14-1797" class="indexterm"/><a id="IDX-CHP-14-1798" class="indexterm"/><a id="IDX-CHP-14-1799" class="indexterm"/><a id="IDX-CHP-14-1800" class="indexterm"/><a id="IDX-CHP-14-1801" class="indexterm"/><a id="IDX-CHP-14-1802" class="indexterm"/><a id="IDX-CHP-14-1803" class="indexterm"/><a id="IDX-CHP-14-1804" class="indexterm"/><a id="IDX-CHP-14-1805" class="indexterm"/><a id="IDX-CHP-14-1806" class="indexterm"/><a id="IDX-CHP-14-1807" class="indexterm"/><a id="IDX-CHP-14-1808" class="indexterm"/><a id="IDX-CHP-14-1809" class="indexterm"/><a id="IDX-CHP-14-1810" class="indexterm"/><a id="IDX-CHP-14-1811" class="indexterm"/><a id="IDX-CHP-14-1812" class="indexterm"/><a id="IDX-CHP-14-1813" class="indexterm"/><a id="IDX-CHP-14-1814" class="indexterm"/><a id="IDX-CHP-14-1815" class="indexterm"/><a id="IDX-CHP-14-1816" class="indexterm"/><a id="IDX-CHP-14-1817" class="indexterm"/><a id="IDX-CHP-14-1818" class="indexterm"/><a id="IDX-CHP-14-1819" class="indexterm"/><a id="IDX-CHP-14-1820" class="indexterm"/><a id="IDX-CHP-14-1821" class="indexterm"/><a id="IDX-CHP-14-1822" class="indexterm"/><a id="IDX-CHP-14-1823" class="indexterm"/><a id="IDX-CHP-14-1824" class="indexterm"/><a id="IDX-CHP-14-1825" class="indexterm"/><a id="IDX-CHP-14-1826" class="indexterm"/><a id="IDX-CHP-14-1827" class="indexterm"/><a id="IDX-CHP-14-1828" class="indexterm"/><a id="IDX-CHP-14-1829" class="indexterm"/><a id="IDX-CHP-14-1830" class="indexterm"/><a id="IDX-CHP-14-1831" class="indexterm"/><a id="IDX-CHP-14-1832" class="indexterm"/><a id="IDX-CHP-14-1833" class="indexterm"/><a id="IDX-CHP-14-1834" class="indexterm"/><a id="IDX-CHP-14-1835" class="indexterm"/><a id="IDX-CHP-14-1836" class="indexterm"/></p><a id="I_programlisting14_d1e33143"/><pre class="programlisting">#include &lt;sys/mount.h&gt;

int <strong class="userinput"><code>mount</code></strong>(const char *<span class="emphasis"><em>source</em></span>, const char *<span class="emphasis"><em>target</em></span>, const char *<span class="emphasis"><em>fstype</em></span>,
          unsigned long <span class="emphasis"><em>mountflags</em></span>, const void *<span class="emphasis"><em>data</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The names <span class="emphasis"><em>source</em></span> and <span class="emphasis"><em>target</em></span> are used
                    for the first two arguments because <span class="emphasis"><em>mount()</em></span> can perform
                    other tasks than mounting a disk file system under a directory.<a id="IDX-CHP-14-1837" class="indexterm"/></p><p>The <span class="emphasis"><em>fstype</em></span> argument is a string identifying the type of
                    file system contained on the device, such as <span class="emphasis"><em>ext4</em></span> or
                        <span class="emphasis"><em>btrfs</em></span>.</p><p>The <span class="emphasis"><em>mountflags</em></span> argument is a bit mask constructed by
                    ORing (<code class="literal">|</code>) zero or more of the flags shown in
                        <a class="xref" href="ch14.html#mountflags_values_for_mount_open_parenth" title="Table 14-1. mountflags values for mount()">Table 14-1</a>, which are
                    described in more detail below.</p><p>The final <span class="emphasis"><em>mount()</em></span> argument, <span class="emphasis"><em>data</em></span>, is
                    a pointer to a buffer of information whose interpretation depends on the file
                    system. For most file-system types, this argument is a string consisting of
                    comma-separated option settings. A full list of these options can be found in
                    the <span class="emphasis"><em>mount(8)</em></span> manual page (or the documentation for the file
                    system concerned, if it is not described in
                    <span class="emphasis"><em>mount(8)</em></span>).</p><div class="table"><a id="mountflags_values_for_mount_open_parenth"/><div class="table-title">Table 14-1. mountflags <code class="literal">values for</code> mount()</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>Flag</p>
                                </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                                    <p>Purpose</p>
                                </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_BIND</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Create a bind mount (since Linux 2.4)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_DIRSYNC</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Make directory updates synchronous (since Linux
                                        2.6)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_MANDLOCK</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Permit mandatory locking of files</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_MOVE</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Atomically move mount point to new location</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_NOATIME</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Don’t update last access time for files<a id="IDX-CHP-14-1838" class="indexterm"/></p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_NODEV</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Don’t allow access to devices</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_NODIRATIME</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Don’t update last access time for directories</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_NOEXEC</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Don’t allow programs to be executed</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_NOSUID</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Disable set-user-ID and set-group-ID programs</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_RDONLY</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Read-only mount; files can’t be created or modified</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_REC</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Recursive mount (since Linux 2.6.20)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_RELATIME</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Update last access time only if older than last
                                        modification time or last status change time (since Linux
                                        2.4.11)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_REMOUNT</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Remount with new <span class="emphasis"><em>mountflags</em></span> and
                                            <span class="emphasis"><em>data</em></span></p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_STRICTATIME</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                                    <p>Always update last access time (since Linux 2.6.30)</p>
                                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                                    <p>
                                        <code class="literal">MS_SYNCHRONOUS</code>
                                    </p>
                                </td><td style="text-align: left; vertical-align: top; ">
                                    <p>Make all file and directory updates synchronous</p>
                                </td></tr></tbody></table></div></div><p>The <span class="emphasis"><em>mountflags</em></span> argument is a bit mask of flags that
                    modify the operation of <span class="emphasis"><em>mount()</em></span>. Zero or more of the
                    following flags can be specified in <span class="emphasis"><em>mountflags</em></span>:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">MS_BIND</code> (since Linux 2.4)</span></dt><dd><p>Create a bind mount. We describe this feature in <a class="xref" href="ch14.html#bind_mounts" title="Bind Mounts">Bind Mounts</a>. If this flag is specified, then the
                                    <span class="emphasis"><em>fstype</em></span>, <span class="emphasis"><em>mountflags</em></span>,
                                and <span class="emphasis"><em>data</em></span> arguments are ignored.</p></dd><dt><span class="term"><code class="literal">MS_DIRSYNC</code> (since Linux 2.6)</span></dt><dd><p>Make directory updates synchronous. This is similar to the effect
                                of the <span class="emphasis"><em>open()</em></span>
                                <code class="literal">O_SYNC</code> flag (<a class="xref" href="ch13.html#controlling_kernel_buffering_of_file_i_s" title="Controlling Kernel Buffering of File I/O">Controlling Kernel Buffering of File I/O</a>), but
                                applies only to directory updates. The <code class="literal">MS_SYNCHRONOUS</code> flag described below provides a
                                superset of the functionality of <code class="literal">MS_DIRSYNC</code>, ensuring that both file and directory
                                updates are performed synchronously. The <code class="literal">MS_DIRSYNC</code> flag allows an application to ensure that
                                directory updates (e.g., <span class="emphasis"><em>open(pathname,
                                    O_CREAT)</em></span>, <span class="emphasis"><em>rename()</em></span>,
                                    <span class="emphasis"><em>link()</em></span>, <span class="emphasis"><em>unlink()</em></span>,
                                    <span class="emphasis"><em>symlink()</em></span>, and
                                <span class="emphasis"><em>mkdir()</em></span>) are synchronized without incurring the
                                expense of synchronizing all file updates. The <code class="literal">FS_DIRSYNC_FL</code> flag (<a class="xref" href="ch15.html#i-node_flags_open_parenthesis_ext2_exten" title="I-node Flags (ext2 Extended File Attributes)">I-node Flags (<span class="emphasis"><em>ext2</em></span> Extended File Attributes)</a>) serves a
                                similar purpose to <code class="literal">MS_DIRSYNC</code>,
                                with the difference that <code class="literal">FS_DIRSYNC_FL</code> can be applied to individual
                                directories. In addition, on Linux, calling
                                    <span class="emphasis"><em>fsync()</em></span> on a file descriptor that refers to
                                a directory provides a means of synchronizing directory updates on a
                                per-directory basis. (This Linux-specific
                                    <span class="emphasis"><em>fsync()</em></span> behavior is not specified in
                                    SUSv3.)<a id="IDX-CHP-14-1839" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">MS_MANDLOCK</code>
                        </span></dt><dd><p>Permit mandatory record locking on files in this file system. We
                                describe record locking in <a class="xref" href="ch55.html" title="Chapter 55. File Locking">Chapter 55</a>.<a id="IDX-CHP-14-1840" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">MS_MOVE</code>
                        </span></dt><dd><p>Atomically move the existing mount point specified by
                                    <span class="emphasis"><em>source</em></span> to the new location specified by
                                    <span class="emphasis"><em>target</em></span>. This corresponds to the
                                    <span class="emphasis"><em>—move</em></span> option to
                                    <span class="emphasis"><em>mount(8)</em></span>. This is equivalent to unmounting
                                the subtree and then remounting at a different location, except that
                                there is no point in time when the subtree is unmounted. The
                                    <span class="emphasis"><em>source</em></span> argument should be a string
                                specified as a <span class="emphasis"><em>target</em></span> in a previous
                                    <span class="emphasis"><em>mount()</em></span> call. When this flag is specified,
                                the <span class="emphasis"><em>fstype</em></span>, <span class="emphasis"><em>mountflags</em></span>,
                                and <span class="emphasis"><em>data</em></span> arguments are ignored.</p></dd><dt><span class="term">
                            <code class="literal">MS_NOATIME</code>
                        </span></dt><dd><p>Don’t update the last access time for files in this file system.
                                The purpose of this flag, as well as the <code class="literal">MS_NODIRATIME</code> flag described below, is to eliminate
                                the extra disk access required to update the file i-node each time a
                                file is accessed. In some applications, maintaining this timestamp
                                is not critical, and avoiding doing so can significantly improve
                                performance. The <code class="literal">MS_NOATIME</code> flag
                                serves a similar purpose to the <code class="literal">FS_NOATIME_FL</code> flag (<a class="xref" href="ch15.html#i-node_flags_open_parenthesis_ext2_exten" title="I-node Flags (ext2 Extended File Attributes)">I-node Flags (<span class="emphasis"><em>ext2</em></span> Extended File Attributes)</a>), with the
                                difference that <code class="literal">FS_NOATIME_FL</code> can
                                be applied to single files. Linux also provides similar
                                functionality via the <code class="literal">O_NOATIME</code>
                                <span class="emphasis"><em>open()</em></span> flag, which selects this behavior for
                                individual open files (<a class="xref" href="ch04.html#file_descriptor_number_returned_by-id1" title="File descriptor number returned by open()">File descriptor number returned by <span class="emphasis"><em>open()</em></span></a>).<a id="IDX-CHP-14-1841" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">MS_NODEV</code>
                        </span></dt><dd><p>Don’t allow access to block and character devices on this file
                                system. This is a security feature designed to prevent users from
                                doing things such as inserting a removable disk containing device
                                special files that would allow arbitrary access to the
                                system.</p></dd><dt><span class="term">
                            <code class="literal">MS_NODIRATIME</code>
                        </span></dt><dd><p>Don’t update the last access time for directories on this file
                                system. (This flag provides a subset of the functionality of
                                    <code class="literal">MS_NOATIME</code>, which prevents
                                updates to the last access time for all file types.)<a id="IDX-CHP-14-1842" class="indexterm"/></p></dd><dt><span class="term">
                            <code class="literal">MS_NOEXEC</code>
                        </span></dt><dd><p>Don’t allow programs (or scripts) to be executed from this file
                                system. This is useful if the file system contains non-Linux
                                executables.</p></dd><dt><span class="term">
                            <code class="literal">MS_NOSUID</code>
                        </span></dt><dd><p>Disable set-user-ID and set-group-ID programs on this file system.
                                This is a security feature to prevent users from running set-user-ID
                                and set-group-ID programs from removable devices.</p></dd><dt><span class="term">
                            <code class="literal">MS_RDONLY</code>
                        </span></dt><dd><p>Mount the file system read-only, so that no new files can be
                                created and no existing files can be modified.</p></dd><dt><span class="term"><code class="literal">MS_REC</code> (since Linux 2.4.11)</span></dt><dd><p>This flag is used in conjunction with other flags (e.g., <code class="literal">MS_BIND</code>) to recursively apply the
                                mount action to all of the mounts in a subtree.</p></dd><dt><span class="term"><code class="literal">MS_RELATIME</code> (since Linux
                            2.6.20)</span></dt><dd><p>Update the last access timestamp for files on this file system
                                only if the current setting of this timestamp is less than or equal
                                to either the last modification or the last status change timestamp.
                                This provides some of the performance benefits of <code class="literal">MS_NOATIME</code>, but is useful for programs
                                that need to know if a file has been read since it was last updated.
                                Since Linux 2.6.30, the behavior provided by <code class="literal">MS_RELATIME</code> is the default (unless the
                                    <code class="literal">MS_NOATIME</code> flag is
                                specified), and the <code class="literal">MS_STRICTATIME</code> flag is required to obtain classical
                                behavior. In addition, since Linux 2.6.30, the last access timestamp
                                is always updated if its current value is more than 24 hours in the
                                past, even if the current value is more recent than the last
                                modification and last status change timestamps. (This is useful for
                                certain system programs that monitor directories to see whether
                                files have recently been accessed.)</p></dd><dt><span class="term">
                            <code class="literal">MS_REMOUNT</code>
                        </span></dt><dd><p>Alter the <span class="emphasis"><em>mountflags</em></span> and
                                    <span class="emphasis"><em>data</em></span> for a file system that is already
                                mounted (e.g., to make a read-only file system writable). When using
                                this flag, the <span class="emphasis"><em>source</em></span> and
                                    <span class="emphasis"><em>target</em></span> arguments should be the same as for
                                the original <span class="emphasis"><em>mount()</em></span> call, and the
                                    <span class="emphasis"><em>fstype</em></span> argument is ignored. This flag
                                avoids the need to unmount and remount the disk, which may not be
                                possible in some cases. For example, we can’t unmount a file system
                                if any process has files open on, or its current working directory
                                located within, the file system (this will always be true of the
                                root file system). Another example of where we need to use <code class="literal">MS_REMOUNT</code> is with
                                    <span class="emphasis"><em>tmpfs</em></span> (memory-based) file systems (<a class="xref" href="ch14.html#a_virtual_memory_file_system_colon_tmpfs" title="A Virtual Memory File System: tmpfs">A Virtual Memory File System: <span class="emphasis"><em>tmpfs</em></span></a>), which
                                can’t be unmounted without losing their contents. Not all
                                    <span class="emphasis"><em>mountflags</em></span> are modifiable; see the
                                    <span class="emphasis"><em>mount(2)</em></span> manual page for details.</p></dd><dt><span class="term"><code class="literal">MS_STRICTATIME</code> (since Linux
                            2.6.30)</span></dt><dd><p>Always update the last access timestamp when files on this file
                                system are accessed. This was the default behavior before Linux
                                2.6.30. If <code class="literal">MS_STRICTATIME</code> is
                                specified, then <code class="literal">MS_NOATIME</code> and
                                    <code class="literal">MS_RELATIME</code> are ignored if
                                they are also specified in <span class="emphasis"><em>mountflags</em></span>.</p></dd><dt><span class="term">
                            <code class="literal">MS_SYNCHRONOUS</code>
                        </span></dt><dd><p>Make all file and directory updates on this file system
                                synchronous. (In the case of files, this is as though files were
                                always opened with the <span class="emphasis"><em>open()</em></span>
                                <code class="literal">O_SYNC</code> flag.)</p></dd></dl></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Starting with kernel 2.6.15, Linux provides four new mount flags to
                        support the notion of <span class="emphasis"><em>shared subtrees</em></span>. The new flags
                        are <code class="literal">MS_PRIVATE</code>, <code class="literal">MS_SHARED</code>, <code class="literal">MS_SLAVE</code>, and
                            <code class="literal">MS_UNBINDABLE</code>. (These flags can be
                        used in conjunction with <code class="literal">MS_REC</code> to
                        propagate their effects to all of the submounts under a mount subtree.)
                        Shared subtrees are designed for use with certain advanced file-system
                        features, such as per-process mount namespaces (see the description of
                            <code class="literal">CLONE_NEWNS</code> in <a class="xref" href="ch28.html#example_program-id39" title="Example program">Example program</a>), and the <span class="emphasis"><em>Filesystem in
                            Userspace</em></span> (FUSE) facility. The shared subtree facility
                        permits file-system mounts to be propagated between mount namespaces in a
                        controlled fashion. Details on shared subtrees can be found in the kernel
                        source code file <code class="literal">Documentation/filesystems/sharedsubtree.txt</code> and [Viro
                        &amp; Pai, 2006].<a id="IDX-CHP-14-1843" class="indexterm"/></p></div><div class="sect3" title="Example program"><div class="titlepage"><div><div><h4 class="title" id="example_program-id12">Example program</h4></div></div></div><p>The program in <a class="xref" href="ch14.html#using_mount_open_parenthesis_close_paren" title="Example 14-1. Using mount()">Example 14-1</a>
                        provides a command-level interface to the <span class="emphasis"><em>mount(2)</em></span>
                        system call. In effect, it is a crude version of the
                            <span class="emphasis"><em>mount(8)</em></span> command. The following shell session log
                        demonstrates the use of this program. We begin by creating a directory to be
                        used as a mount point and mounting a file system:<a id="IDX-CHP-14-1844" class="indexterm"/><a id="IDX-CHP-14-1845" class="indexterm"/><a id="IDX-CHP-14-1846" class="indexterm"/><a id="IDX-CHP-14-1847" class="indexterm"/><a id="IDX-CHP-14-1848" class="indexterm"/><a id="IDX-CHP-14-1849" class="indexterm"/><a id="IDX-CHP-14-1850" class="indexterm"/><a id="IDX-CHP-14-1851" class="indexterm"/><a id="IDX-CHP-14-1852" class="indexterm"/><a id="IDX-CHP-14-1853" class="indexterm"/><a id="IDX-CHP-14-1854" class="indexterm"/><a id="IDX-CHP-14-1855" class="indexterm"/><a id="IDX-CHP-14-1856" class="indexterm"/><a id="IDX-CHP-14-1857" class="indexterm"/><a id="IDX-CHP-14-1858" class="indexterm"/><a id="IDX-CHP-14-1859" class="indexterm"/></p><a id="I_programlisting14_d1e33823"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>                                    <em class="lineannotation"><span class="lineannotation">Need privilege to mount a file system</span></em>
Password:
# <strong class="userinput"><code>mkdir /testfs</code></strong>
# <strong class="userinput"><code>./t_mount -t ext2 -o bsdgroups /dev/sda12 /testfs</code></strong>
# <strong class="userinput"><code>cat /proc/mounts | grep sda12</code></strong>         <em class="lineannotation"><span class="lineannotation">Verify the setup</span></em>
/dev/sda12 /testfs ext3 rw 0 0          <em class="lineannotation"><span class="lineannotation">Doesn't show bsdgroups</span></em>
# <strong class="userinput"><code>grep sda12 /etc/mtab</code></strong></pre><p>We find that the preceding <span class="emphasis"><em>grep</em></span> command produces no
                        output because our program doesn’t update <code class="literal">/etc/mtab</code>. We continue, remounting the file system
                        read-only:</p><a id="I_programlisting14_d1e33857"/><pre class="programlisting"># <strong class="userinput"><code>./t_mount -f Rr /dev/sda12 /testfs</code></strong>
# <strong class="userinput"><code>cat /proc/mounts | grep sda12</code></strong>         <em class="lineannotation"><span class="lineannotation">Verify change</span></em>
/dev/sda12 /testfs ext3 ro 0 0</pre><p>The string <span class="emphasis"><em>ro</em></span> in the line displayed from <code class="literal">/proc/mounts</code> indicates that this is a
                        read-only mount.</p><p>Finally, we move the mount point to a new location within the directory
                        hierarchy:</p><a id="I_programlisting14_d1e33878"/><pre class="programlisting"># <strong class="userinput"><code>mkdir /demo</code></strong>
# <strong class="userinput"><code>./t_mount -f m /testfs /demo</code></strong>
# <strong class="userinput"><code>cat /proc/mounts | grep sda12</code></strong>         <em class="lineannotation"><span class="lineannotation">Verify change</span></em>
/dev/sda12 /demo ext3 ro 0</pre><div class="example"><a id="using_mount_open_parenthesis_close_paren"/><div class="example-title">Example 14-1. Using <span class="emphasis"><em>mount()</em></span></div><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>filesys/t_mount.c</code></strong>
#include &lt;sys/mount.h&gt;
#include "tlpi_hdr.h"

static void
usageError(const char *progName, const char *msg)
{
    if (msg != NULL)
        fprintf(stderr, "%s", msg);

    fprintf(stderr, "Usage: %s [options] source target\n\n", progName);
    fprintf(stderr, "Available options:\n");
#define fpe(str) fprintf(stderr, "    " str)    /* Shorter! */
    fpe("-t fstype        [e.g., 'ext2' or 'reiserfs']\n");
    fpe("-o data          [file system-dependent options,\n");
    fpe("                 e.g., 'bsdgroups' for ext2]\n");
    fpe("-f mountflags    can include any of:\n");
#define fpe2(str) fprintf(stderr, "            " str)
    fpe2("b - MS_BIND         create a bind mount\n");
    fpe2("d - MS_DIRSYNC      synchronous directory updates\n");
    fpe2("l - MS_MANDLOCK     permit mandatory locking\n");
    fpe2("m - MS_MOVE         atomically move subtree\n");
    fpe2("A - MS_NOATIME      don't update atime (last access time)\n");
    fpe2("V - MS_NODEV        don't permit device access\n");
    fpe2("D - MS_NODIRATIME   don't update atime on directories\n");
    fpe2("E - MS_NOEXEC       don't allow executables\n");
    fpe2("S - MS_NOSUID       disable set-user/group-ID programs\n");
    fpe2("r - MS_RDONLY       read-only mount\n");
    fpe2("c - MS_REC          recursive mount\n");
    fpe2("R - MS_REMOUNT      remount\n");
    fpe2("s - MS_SYNCHRONOUS  make writes synchronous\n");
    exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
    unsigned long flags;
    char *data, *fstype;
    int j, opt;

    flags = 0;
    data = NULL;
    fstype = NULL;

    while ((opt = getopt(argc, argv, "o:t:f:")) != -1) {
        switch (opt) {
        case 'o':
            data = optarg;
            break;

        case 't':
            fstype = optarg;
            break;

        case 'f':
            for (j = 0; j &lt; strlen(optarg); j++) {
                switch (optarg[j]) {
                case 'b': flags |= MS_BIND;             break;
                case 'd': flags |= MS_DIRSYNC;          break;
                case 'l': flags |= MS_MANDLOCK;         break;
                case 'm': flags |= MS_MOVE;             break;
                case 'A': flags |= MS_NOATIME;          break;
                case 'V': flags |= MS_NODEV;            break;
                case 'D': flags |= MS_NODIRATIME;       break;
                case 'E': flags |= MS_NOEXEC;           break;
                case 'S': flags |= MS_NOSUID;           break;
                case 'r': flags |= MS_RDONLY;           break;
                case 'c': flags |= MS_REC;              break;
                case 'R': flags |= MS_REMOUNT;          break;
                case 's': flags |= MS_SYNCHRONOUS;      break;
                default:  usageError(argv[0], NULL);
                }
            }
            break;

        default:
            usageError(argv[0], NULL);
        }
    }

    if (argc != optind + 2)
        usageError(argv[0], "Wrong number of arguments\n");

    if (mount(argv[optind], argv[optind + 1], fstype, flags, data) == -1)
        errExit("mount");

    exit(EXIT_SUCCESS);
}
      <strong class="userinput"><code>filesys/t_mount.c</code></strong></pre></div></div></div></div><div class="sect2" title="Unmounting a File System: umount() and umount2()"><div class="titlepage"><div><div><h3 class="title" id="unmounting_a_file_system_colon_umount_op">Unmounting a File System: <span class="emphasis"><em>umount()</em></span> and
                        <span class="emphasis"><em>umount2()</em></span></h3></div></div></div><p>The <span class="emphasis"><em>umount()</em></span> system call unmounts a mounted file
                        system.<a id="IDX-CHP-14-1861" class="indexterm"/><a id="IDX-CHP-14-1862" class="indexterm"/><a id="IDX-CHP-14-1863" class="indexterm"/><a id="IDX-CHP-14-1860" class="indexterm"/></p><a id="I_programlisting14_d1e33939"/><pre class="programlisting">#include &lt;sys/mount.h&gt;

int <strong class="userinput"><code>umount</code></strong>(const char *<span class="emphasis"><em>target</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>The <span class="emphasis"><em>target</em></span> argument specifies the mount point of the file
                    system to be unmounted.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On Linux 2.2 and earlier, the file system can be identified in two ways:
                        by the mount point or by the name of the device containing the file system.
                        Since kernel 2.4, Linux doesn’t allow the latter possibility, because a
                        single file system can now be mounted at multiple locations, so that
                        specifying a file system for <span class="emphasis"><em>target</em></span> would be ambiguous.
                        We explain this point in further detail in <a class="xref" href="ch14.html#mounting_a_file_system_at_multiple_mount" title="Mounting a File System at Multiple Mount Points">Mounting a File System at Multiple Mount Points</a>.</p></div><p>It is not possible to unmount a file system that is <span class="emphasis"><em>busy</em></span>;
                    that is, if there are open files on the file system, or a process’s current
                    working directory is somewhere in the file system. Calling
                        <span class="emphasis"><em>umount()</em></span> on a busy file system yields the error
                        <code class="literal">EBUSY</code>.<a id="IDX-CHP-14-1864" class="indexterm"/><a id="IDX-CHP-14-1865" class="indexterm"/></p><p>The <span class="emphasis"><em>umount2()</em></span> system call is an extended version of
                        <span class="emphasis"><em>umount()</em></span>. It allows finer control over the unmount
                    operation via the <span class="emphasis"><em>flags</em></span> argument.<a id="IDX-CHP-14-1866" class="indexterm"/></p><a id="I_programlisting14_d1e33997"/><pre class="programlisting">#include &lt;sys/mount.h&gt;

int <strong class="userinput"><code>umount2</code></strong>(const char *<span class="emphasis"><em>target</em></span>, int <span class="emphasis"><em>flags</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Returns 0 on success, or -1 on error</p></div><p>This <span class="emphasis"><em>flags</em></span> bit-mask argument consists of zero or more of
                    the following values ORed together:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">MNT_DETACH</code> (since Linux
                            2.4.11)</span></dt><dd><p>Perform a <span class="emphasis"><em>lazy</em></span> unmount. The mount point is
                                marked so that no process can make new accesses to it, but processes
                                that are already using it can continue to do so. The file system is
                                actually unmounted when all processes cease using the mount.</p></dd><dt><span class="term"><code class="literal">MNT_EXPIRE</code> (since Linux
                            2.6.8)</span></dt><dd><p>Mark the mount point as <span class="emphasis"><em>expired</em></span>. If an
                                initial <span class="emphasis"><em>umount2()</em></span> call is made specifying this
                                flag, and the mount point is not busy, then the call fails with the
                                error <code class="literal">EAGAIN</code>, but the mount point
                                is marked to expire. (If the mount point is busy, then the call
                                fails with the error <code class="literal">EBUSY</code>, and
                                the mount point is not marked to expire.) A mount point remains
                                expired as long as no process subsequently makes use of it. A second
                                    <span class="emphasis"><em>umount2()</em></span> call specifying <code class="literal">MNT_EXPIRE</code> will unmount an expired
                                mount point. This provides a mechanism to unmount a file system that
                                hasn’t been used for some period of time. This flag can’t be
                                specified with <code class="literal">MNT_DETACH</code> or
                                    <code class="literal">MNT_FORCE</code>.</p></dd><dt><span class="term">
                            <code class="literal">MNT_FORCE</code>
                        </span></dt><dd><p>Force an unmount even if the device is busy (NFS mounts only).
                                Employing this option can cause data loss.</p></dd><dt><span class="term"><code class="literal">UMOUNT_NOFOLLOW</code> (since Linux
                            2.6.34)</span></dt><dd><p>Don’t dereference <span class="emphasis"><em>target</em></span> if it is a symbolic
                                link. This flag is designed for use in certain
                                    set-user-ID-<span class="emphasis"><em>root</em></span> programs that allow
                                unprivileged users to perform unmounts, in order to avoid the
                                security problems that could occur if <span class="emphasis"><em>target</em></span> is
                                a symbolic link that is changed to point to a different
                                location.</p></dd></dl></div></div></div><div class="sect1" title="Advanced Mount Features"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="advanced_mount_features">Advanced Mount Features</h2></div></div></div><p>We now look at a number of more advanced features that can be employed when
                mounting file systems. We demonstrate the use of most of these features using the
                    <span class="emphasis"><em>mount(8)</em></span> command. The same effects can also be accomplished
                from a program via calls to <span class="emphasis"><em>mount(2)</em></span>.</p><div class="sect2" title="Mounting a File System at Multiple Mount Points"><div class="titlepage"><div><div><h3 class="title" id="mounting_a_file_system_at_multiple_mount">Mounting a File System at Multiple Mount Points</h3></div></div></div><p>In kernel versions before 2.4, a file system could be mounted only on a single
                    mount point. From kernel 2.4 onward, a file system can be mounted at multiple
                    locations within the file system. Because each of the mount points shows the
                    same subtree, changes made via one mount point are visible through the other(s),
                    as demonstrated by the following shell session:<a id="IDX-CHP-14-1867" class="indexterm"/><a id="IDX-CHP-14-1868" class="indexterm"/></p><a id="I_programlisting14_d1e34114"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>                                  <em class="lineannotation"><span class="lineannotation">Privilege is required to use mount(8)</span></em>
Password:
# <strong class="userinput"><code>mkdir /testfs</code></strong>                       <em class="lineannotation"><span class="lineannotation">Create two directories for mount points</span></em>
# <strong class="userinput"><code>mkdir /demo</code></strong>
# <strong class="userinput"><code>mount /dev/sda12 /testfs</code></strong>            <em class="lineannotation"><span class="lineannotation">Mount file system at one mount point</span></em>
# <strong class="userinput"><code>mount /dev/sda12 /demo</code></strong>              <em class="lineannotation"><span class="lineannotation">Mount file system at second mount point</span></em>
# <strong class="userinput"><code>mount | grep sda12</code></strong>                  <em class="lineannotation"><span class="lineannotation">Verify the setup</span></em>
/dev/sda12 on /testfs type ext3 (rw)
/dev/sda12 on /demo type ext3 (rw)
# <strong class="userinput"><code>touch /testfs/myfile</code></strong>                <em class="lineannotation"><span class="lineannotation">Make a change via first mount point</span></em>
# <strong class="userinput"><code>ls /demo</code></strong>                            <em class="lineannotation"><span class="lineannotation">View files at second mount point</span></em>
lost+found  myfile</pre><p>The output of the <span class="emphasis"><em>ls</em></span> command shows that the change made
                    via the first mount point (<code class="literal">/testfs</code>) was
                    visible via the second mount point (<code class="literal">/demo</code>).</p><p>We present one example of why it is useful to mount a file system at multiple
                    points when we describe bind mounts in <a class="xref" href="ch14.html#bind_mounts" title="Bind Mounts">Bind Mounts</a>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>It is because a device can be mounted at multiple points that the
                            <span class="emphasis"><em>umount()</em></span> system call can’t take a device as its
                        argument in Linux 2.4 and later.</p></div></div><div class="sect2" title="Stacking Multiple Mounts on the Same Mount Point"><div class="titlepage"><div><div><h3 class="title" id="stacking_multiple_mounts_on_the_same_mou">Stacking Multiple Mounts on the Same Mount Point</h3></div></div></div><p>In kernel versions before 2.4, a mount point could be used only once. Since
                    kernel 2.4, Linux allows multiple mounts to be stacked on a single mount point.
                    Each new mount hides the directory subtree previously visible at that mount
                    point. When the mount at the top of the stack is unmounted, the previously
                    hidden mount becomes visible once more, as demonstrated by the following shell
                    session:</p><a id="I_programlisting14_d1e34189"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>                                  <em class="lineannotation"><span class="lineannotation">Privilege is required to use mount(8)</span></em>
Password:
# <strong class="userinput"><code>mount /dev/sda12 /testfs</code></strong>            <em class="lineannotation"><span class="lineannotation">Create first mount on</span></em> /testfs
# <strong class="userinput"><code>touch /testfs/myfile</code></strong>                <em class="lineannotation"><span class="lineannotation">Make a file in this subtree</span></em>
# <strong class="userinput"><code>mount /dev/sda13 /testfs</code></strong>            <em class="lineannotation"><span class="lineannotation">Stack a second mount on</span></em> /testfs
# <strong class="userinput"><code>mount | grep testfs</code></strong>                 <em class="lineannotation"><span class="lineannotation">Verify the setup</span></em>
/dev/sda12 on /testfs type ext3 (rw)
/dev/sda13 on /testfs type reiserfs (rw)
# <strong class="userinput"><code>touch /testfs/newfile</code></strong>               <em class="lineannotation"><span class="lineannotation">Create a file in this subtree</span></em>
# <strong class="userinput"><code>ls /testfs</code></strong>                          <em class="lineannotation"><span class="lineannotation">View files in this subtree</span></em>
newfile
# <strong class="userinput"><code>umount /testfs</code></strong>                      <em class="lineannotation"><span class="lineannotation">Pop a mount from the stack</span></em>
# <strong class="userinput"><code>mount | grep testfs</code></strong>
/dev/sda12 on /testfs type ext3 (rw)
  <em class="lineannotation"><span class="lineannotation">Now only one mount on</span></em> /testfs
# <strong class="userinput"><code>ls /testfs</code></strong>                          <em class="lineannotation"><span class="lineannotation">Previous mount is now visible</span></em>
lost+found  myfile</pre><p>One use of mount stacking is to stack a new mount on an existing mount point
                    that is busy. Processes that hold file descriptors open, that are
                        <span class="emphasis"><em>chroot()</em></span>-jailed, or that have current working
                    directories within the old mount point continue to operate under that mount, but
                    processes making new accesses to the mount point use the new mount. Combined
                    with a <code class="literal">MNT_DETACH</code> unmount, this can provide a
                    smooth migration off a file system without needing to take the system into
                    single-user mode. We’ll see another example of how stacking mounts is useful
                    when we discuss the <span class="emphasis"><em>tmpfs</em></span> file system in <a class="xref" href="ch14.html#a_virtual_memory_file_system_colon_tmpfs" title="A Virtual Memory File System: tmpfs">A Virtual Memory File System: <span class="emphasis"><em>tmpfs</em></span></a>.</p></div><div class="sect2" title="Mount Flags That Are Per-Mount Options"><div class="titlepage"><div><div><h3 class="title" id="mount_flags_that_are_per-mount_options">Mount Flags That Are Per-Mount Options</h3></div></div></div><p>In kernel versions before 2.4, there was a one-to-one correspondence between
                    file systems and mount points. Because this no longer holds in Linux 2.4 and
                    later, some of the <span class="emphasis"><em>mountflags</em></span> values described in <a class="xref" href="ch14.html#mounting_a_file_system_colon_mount_open" title="Mounting a File System: mount()">Mounting a File System: <span class="emphasis"><em>mount()</em></span></a> can be set on a
                    per-mount basis. These flags are <code class="literal">MS_NOATIME</code>
                    (since Linux 2.6.16), <code class="literal">MS_NODEV</code>, <code class="literal">MS_NODIRATIME</code> (since Linux 2.6.16), <code class="literal">MS_NOEXEC</code>, <code class="literal">MS_NOSUID</code>, <code class="literal">MS_RDONLY</code> (since
                    Linux 2.6.26), and <code class="literal">MS_RELATIME</code>. The following
                    shell session demonstrates this effect for the <code class="literal">MS_NOEXEC</code> flag:<a id="IDX-CHP-14-1869" class="indexterm"/><a id="IDX-CHP-14-1870" class="indexterm"/><a id="IDX-CHP-14-1871" class="indexterm"/><a id="IDX-CHP-14-1872" class="indexterm"/><a id="IDX-CHP-14-1873" class="indexterm"/><a id="IDX-CHP-14-1874" class="indexterm"/><a id="IDX-CHP-14-1875" class="indexterm"/><a id="IDX-CHP-14-1876" class="indexterm"/><a id="IDX-CHP-14-1877" class="indexterm"/></p><a id="I_programlisting14_d1e34348"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>
Password:
# <strong class="userinput"><code>mount /dev/sda12 /testfs</code></strong>
# <strong class="userinput"><code>mount -o noexec /dev/sda12 /demo</code></strong>
# <strong class="userinput"><code>cat /proc/mounts | grep sda12</code></strong>
/dev/sda12 /testfs ext3 rw 0 0
/dev/sda12 /demo ext3 rw,noexec 0 0
# <strong class="userinput"><code>cp /bin/echo /testfs</code></strong>
# <strong class="userinput"><code>/testfs/echo "Art is something which is well done"</code></strong>
Art is something which is well done
# <strong class="userinput"><code>/demo/echo "Art is something which is well done"</code></strong>
bash: /demo/echo: Permission denied</pre></div><div class="sect2" title="Bind Mounts"><div class="titlepage"><div><div><h3 class="title" id="bind_mounts">Bind Mounts</h3></div></div></div><p>Starting with kernel 2.4, Linux permits the creation of bind mounts. A
                        <span class="emphasis"><em>bind mount</em></span> (created using the
                        <span class="emphasis"><em>mount()</em></span>
                    <code class="literal">MS_BIND</code> flag) allows a directory or a file to
                    be mounted at some other location in the file-system hierarchy. This results in
                    the directory or file being visible in both locations. A bind mount is somewhat
                    like a hard link, but differs in two respects:<a id="IDX-CHP-14-1878" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A bind mount can cross file-system mount points (and even
                                <span class="emphasis"><em>chroot</em></span> jails).</p></li><li class="listitem"><p>It is possible to make a bind mount for a directory.</p></li></ul></div><p>We can create a bind mount from the shell using the <span class="emphasis"><em>—bind</em></span>
                    option to <span class="emphasis"><em>mount(8)</em></span>, as shown in the following
                    examples.</p><p>In the first example, we bind mount a directory at another location and show
                    that files created in one directory are visible at the other location:</p><a id="I_programlisting14_d1e34409"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>                            <em class="lineannotation"><span class="lineannotation">Privilege is required to use mount(8)</span></em>
Password:
# <strong class="userinput"><code>pwd</code></strong>
/testfs
# <strong class="userinput"><code>mkdir d1</code></strong>                      <em class="lineannotation"><span class="lineannotation">Create directory to be bound at another location</span></em>
# <strong class="userinput"><code>touch d1/x</code></strong>                    <em class="lineannotation"><span class="lineannotation">Create file in the directory</span></em>
# <strong class="userinput"><code>mkdir d2</code></strong>                      <em class="lineannotation"><span class="lineannotation">Create mount point to which</span></em> d1 <em class="lineannotation"><span class="lineannotation">will be bound</span></em>
# <strong class="userinput"><code>mount --bind d1 d2</code></strong>            <em class="lineannotation"><span class="lineannotation">Create bind mount:</span></em> d1 <em class="lineannotation"><span class="lineannotation">visible via</span></em> d2
# <strong class="userinput"><code>ls d2</code></strong>                         <em class="lineannotation"><span class="lineannotation">Verify that we can see contents of</span></em> d1 <em class="lineannotation"><span class="lineannotation">via</span></em> d2
x
# <strong class="userinput"><code>touch d2/y</code></strong>                    <em class="lineannotation"><span class="lineannotation">Create second file in directory</span></em> d2
# <strong class="userinput"><code>ls d1</code></strong>                         <em class="lineannotation"><span class="lineannotation">Verify that this change is visible via</span></em> d1
x  y</pre><p>In the second example, we bind mount a file at another location and
                    demonstrate that changes to the file via one mount are visible via the other
                    mount:</p><a id="I_programlisting14_d1e34476"/><pre class="programlisting"># <strong class="userinput"><code>cat &gt; f1</code></strong>                      <em class="lineannotation"><span class="lineannotation">Create file to be bound to another location</span></em>
<strong class="userinput"><code>Chance is always powerful. Let your hook be always cast.</code></strong>
<em class="lineannotation"><span class="lineannotation">Type Control-D</span></em>
# <strong class="userinput"><code>touch f2</code></strong>                      <em class="lineannotation"><span class="lineannotation">This is the new mount point</span></em>
# <strong class="userinput"><code>mount --bind f1 f2</code></strong>            <em class="lineannotation"><span class="lineannotation">Bind</span></em> f1 <em class="lineannotation"><span class="lineannotation">as</span></em> f2
# <strong class="userinput"><code>mount | egrep '(d1|f1)'</code></strong>       <em class="lineannotation"><span class="lineannotation">See how mount points look</span></em>
/testfs/d1 on /testfs/d2 type none (rw,bind)
/testfs/f1 on /testfs/f2 type none (rw,bind)
# <strong class="userinput"><code>cat &gt;&gt; f2</code></strong>                     <em class="lineannotation"><span class="lineannotation">Change</span></em> f2
<strong class="userinput"><code>In the pool where you least expect it, will be a fish.</code></strong>
# <strong class="userinput"><code>cat f1</code></strong>                        <em class="lineannotation"><span class="lineannotation">The change is visible via original file</span></em> f1
Chance is always powerful. Let your hook be always cast.
In the pool where you least expect it, will be a fish.
# <strong class="userinput"><code>rm f2</code></strong>                         <em class="lineannotation"><span class="lineannotation">Can't do this because it is a mount point</span></em>
rm: cannot unlink `f2': Device or resource busy
# <strong class="userinput"><code>umount f2</code></strong>                     <em class="lineannotation"><span class="lineannotation">So unmount</span></em>
# <strong class="userinput"><code>rm f2</code></strong>                         <em class="lineannotation"><span class="lineannotation">Now we can remove</span></em> f2</pre><p>One example of when we might use a bind mount is in the creation of a
                        <span class="emphasis"><em>chroot</em></span> jail (<a class="xref" href="ch18.html#changing_the_root_directory_of_a_process" title="Changing the Root Directory of a Process: chroot()">Changing the Root Directory of a Process: <span class="emphasis"><em>chroot()</em></span></a>). Rather than
                    replicating various standard directories (such as <code class="literal">/lib</code>) in the jail, we can simply create bind mounts for these
                    directories (possibly mounted read-only) within the jail.<a id="IDX-CHP-14-1879" class="indexterm"/></p></div><div class="sect2" title="Recursive Bind Mounts"><div class="titlepage"><div><div><h3 class="title" id="recursive_bind_mounts">Recursive Bind Mounts</h3></div></div></div><p>By default, if we create a bind mount for a directory using <code class="literal">MS_BIND</code>, then only that directory is mounted at
                    the new location; if there are any submounts under the source directory, they
                    are not replicated under the mount <span class="emphasis"><em>target</em></span>. Linux 2.4.11
                    added the <code class="literal">MS_REC</code> flag, which can be ORed with
                        <code class="literal">MS_BIND</code> as part of the
                        <span class="emphasis"><em>flags</em></span> argument to <span class="emphasis"><em>mount()</em></span> so that
                    submounts <span class="emphasis"><em>are</em></span> replicated under the mount target. This is
                    referred to as a <span class="emphasis"><em>recursive bind mount</em></span>. The
                        <span class="emphasis"><em>mount(8)</em></span> command provides the
                        <span class="emphasis"><em>—rbind</em></span> option to achieve the same effect from the
                    shell, as shown in the following shell session.<a id="IDX-CHP-14-1880" class="indexterm"/><a id="IDX-CHP-14-1881" class="indexterm"/></p><p>We begin by creating a directory tree (<code class="literal">src1</code>) mounted under <code class="literal">top</code>. This tree
                    includes a submount (<code class="literal">src2</code>) at <code class="literal">top/sub</code>.</p><a id="I_programlisting14_d1e34621"/><pre class="programlisting">$ <strong class="userinput"><code>su</code></strong>
Password:
# <strong class="userinput"><code>mkdir top</code></strong>                     <em class="lineannotation"><span class="lineannotation">This is our top-level mount point</span></em>
# <strong class="userinput"><code>mkdir src1</code></strong>                    <em class="lineannotation"><span class="lineannotation">We'll mount this under</span></em> top
# <strong class="userinput"><code>touch src1/aaa</code></strong>
# <strong class="userinput"><code>mount --bind src1 top</code></strong>         <em class="lineannotation"><span class="lineannotation">Create a normal bind mount</span></em>
# <strong class="userinput"><code>mkdir top/sub</code></strong>                 <em class="lineannotation"><span class="lineannotation">Create directory for a submount under</span></em> top
# <strong class="userinput"><code>mkdir src2</code></strong>                    <em class="lineannotation"><span class="lineannotation">We'll mount this under</span></em> top/sub
# <strong class="userinput"><code>touch src2/bbb</code></strong>
# <strong class="userinput"><code>mount --bind src2 top/sub</code></strong>     <em class="lineannotation"><span class="lineannotation">Create a normal bind mount</span></em>
# <strong class="userinput"><code>find top</code></strong>                      <em class="lineannotation"><span class="lineannotation">Verify contents under</span></em> top <em class="lineannotation"><span class="lineannotation">mount tree</span></em>
top
top/aaa
top/sub                         <em class="lineannotation"><span class="lineannotation">This is the submount</span></em>
top/sub/bbb</pre><p>Now we create another bind mount (<code class="literal">dir1</code>)
                    using <code class="literal">top</code> as the source. Since this new mount
                    is nonrecursive, the submount is not replicated.</p><a id="I_programlisting14_d1e34691"/><pre class="programlisting"># <strong class="userinput"><code>mkdir dir1</code></strong>
# <strong class="userinput"><code>mount --bind top dir1</code></strong>         <em class="lineannotation"><span class="lineannotation">Here we use a normal bind mount</span></em>
# <strong class="userinput"><code>find dir1</code></strong>
dir1
dir1/aaa
dir1/sub</pre><p>The absence of <code class="literal">dir1/sub/bbb</code> in the output
                    of <span class="emphasis"><em>find</em></span> shows that the submount <code class="literal">top/sub</code> was not replicated.</p><p>Now we create a recursive bind mount (<code class="literal">dir2</code>)
                    using <code class="literal">top</code> as the source.</p><a id="I_programlisting14_d1e34724"/><pre class="programlisting"># <strong class="userinput"><code>mkdir dir2</code></strong>
# <strong class="userinput"><code>mount --rbind top dir2</code></strong>
# <strong class="userinput"><code>find dir2</code></strong>
dir2
dir2/aaa
dir2/sub
dir2/sub/bbb</pre><p>The presence of <code class="literal">dir2/sub/bbb</code> in the output
                    of <span class="emphasis"><em>find</em></span> shows that the submount <code class="literal">top/sub</code> was replicated.</p></div></div><div class="sect1" title="A Virtual Memory File System: tmpfs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="a_virtual_memory_file_system_colon_tmpfs">A Virtual Memory File System: <span class="emphasis"><em>tmpfs</em></span></h2></div></div></div><p>All of the file systems we have described so far in this chapter reside on disks.
                However, Linux also supports the notion of <span class="emphasis"><em>virtual file systems</em></span>
                that reside in memory. To applications, these look just like any other file
                system—the same operations (<span class="emphasis"><em>open()</em></span>,
                <span class="emphasis"><em>read()</em></span>, <span class="emphasis"><em>write()</em></span>,
                    <span class="emphasis"><em>link()</em></span>, <span class="emphasis"><em>mkdir()</em></span>, and so on) can be
                applied to files and directories in such file systems. There is, however, one
                important difference: file operations are much faster, since no disk access is
                    involved.<a id="IDX-CHP-14-1882" class="indexterm"/></p><p>Various memory-based file systems have been developed for Linux. The most
                sophisticated of these to date is the <span class="emphasis"><em>tmpfs</em></span> file system, which
                first appeared in Linux 2.4. The <span class="emphasis"><em>tmpfs</em></span> file system differs from
                other memory-based file systems in that it is a <span class="emphasis"><em>virtual</em></span> memory
                file system. This means that <span class="emphasis"><em>tmpfs</em></span> uses not only RAM, but also
                the swap space, if RAM is exhausted. (Although the <span class="emphasis"><em>tmpfs</em></span> file
                system described here is Linux-specific, most UNIX implementations provide some form
                of memory-based file system.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>tmpfs</em></span> file system is an optional Linux kernel
                    component that is configured via the <code class="literal">CONFIG_TMPFS</code> option.</p></div><p>To create a <span class="emphasis"><em>tmpfs</em></span> file system, we use a command of the
                following form:</p><a id="I_programlisting14_d1e34808"/><pre class="programlisting"># <strong class="userinput"><code>mount -t tmpfs</code></strong> <strong class="userinput"><code><em class="replaceable"><code>source target</code></em></code></strong></pre><p>The <span class="emphasis"><em>source</em></span> can be any name; its only significance is that it
                appears in <code class="literal">/proc/mounts</code> and is displayed by the
                    <span class="emphasis"><em>mount</em></span> and <span class="emphasis"><em>df</em></span> commands. As usual,
                    <span class="emphasis"><em>target</em></span> is the mount point for the file system. Note that it
                is not necessary to use <span class="emphasis"><em>mkfs</em></span> to create a file system first,
                because the kernel automatically builds a file system as part of the
                    <span class="emphasis"><em>mount()</em></span> system call.</p><p>As an example of the use of <span class="emphasis"><em>tmpfs</em></span>, we could employ mount
                stacking (so that we don’t need to care if <code class="literal">/tmp</code>
                is already in use) and create a <span class="emphasis"><em>tmpfs</em></span> file system mounted on
                    <code class="literal">/tmp</code> as follows:</p><a id="I_programlisting14_d1e34854"/><pre class="programlisting"># <strong class="userinput"><code>mount -t tmpfs newtmp /tmp</code></strong>
# <strong class="userinput"><code>cat /proc/mounts | grep tmp</code></strong>
newtmp /tmp tmpfs rw 0 0</pre><p>A command such as the above (or an equivalent entry in <code class="literal">/etc/fstab</code>) is sometimes used to improve the performance of
                applications (e.g., compilers) that make heavy use of the <code class="literal">/tmp</code> directory for creating temporary files.</p><p>By default, a <span class="emphasis"><em>tmpfs</em></span> file system is permitted to grow to half
                the size of RAM, but the <span class="emphasis"><em>size=nbytes mount</em></span> option can be used
                to set a different ceiling for the file-system size, either when the file system is
                created or during a later remount. (A <span class="emphasis"><em>tmpfs</em></span> file system
                consumes only as much memory and swap space as is currently required for the files
                it holds.)</p><p>If we unmount a <span class="emphasis"><em>tmpfs</em></span> file system, or the system crashes,
                then all data in the file system is lost; hence the name
                <span class="emphasis"><em>tmpfs</em></span>.</p><p>Aside from use by user applications, <span class="emphasis"><em>tmpfs</em></span> file systems also
                serve two special purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An invisible <span class="emphasis"><em>tmpfs</em></span> file system, mounted internally by
                        the kernel, is used for implementing System V shared memory (<a class="xref" href="ch48.html" title="Chapter 48. System V Shared Memory">Chapter 48</a>) and shared anonymous memory mappings
                            (<a class="xref" href="ch49.html" title="Chapter 49. Memory Mappings">Chapter 49</a>).</p></li><li class="listitem"><p>A <span class="emphasis"><em>tmpfs</em></span> file system mounted at <code class="literal">/dev/shm</code> is used for the
                            <span class="emphasis"><em>glibc</em></span> implementation of POSIX shared memory and
                        POSIX semaphores.<a id="IDX-CHP-14-1883" class="indexterm"/></p></li></ul></div></div><div class="sect1" title="Obtaining Information About a File System: statvfs()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="obtaining_information_about_a_file_syste">Obtaining Information About a File System: <span class="emphasis"><em>statvfs()</em></span></h2></div></div></div><p>The <span class="emphasis"><em>statvfs()</em></span> and <span class="emphasis"><em>fstatvfs()</em></span> library
                functions obtain information about a mounted file system.<a id="IDX-CHP-14-1885" class="indexterm"/><a id="IDX-CHP-14-1886" class="indexterm"/><a id="IDX-CHP-14-1887" class="indexterm"/><a id="IDX-CHP-14-1888" class="indexterm"/><a id="IDX-CHP-14-1889" class="indexterm"/><a id="IDX-CHP-14-1890" class="indexterm"/><a id="IDX-CHP-14-1891" class="indexterm"/><a id="IDX-CHP-14-1884" class="indexterm"/><a id="IDX-CHP-14-1892" class="indexterm"/></p><a id="I_programlisting14_d1e34983"/><pre class="programlisting">#include &lt;sys/statvfs.h&gt;

int <strong class="userinput"><code>statvfs</code></strong>(const char *<span class="emphasis"><em>pathname</em></span>, struct statvfs *<span class="emphasis"><em>statvfsbuf</em></span>);
int <strong class="userinput"><code>fstatvfs</code></strong>(int <span class="emphasis"><em>fd</em></span>, struct statvfs *<span class="emphasis"><em>statvfsbuf</em></span>);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Both return 0 on success, or -1 on error</p></div><p>The only difference between these two functions is in how the file system is
                identified. For <span class="emphasis"><em>statvfs()</em></span>, we use <span class="emphasis"><em>pathname</em></span>
                to specify the name of any file in the file system. For
                    <span class="emphasis"><em>fstatvfs()</em></span>, we specify an open file descriptor,
                    <span class="emphasis"><em>fd</em></span>, referring to any file in the file system. Both
                functions return a <span class="emphasis"><em>statvfs</em></span> structure containing information
                about the file system in the buffer pointed to by <span class="emphasis"><em>statvfsbuf</em></span>.
                This structure has the following form:<a id="IDX-CHP-14-1893" class="indexterm"/></p><a id="I_programlisting14_d1e35033"/><pre class="programlisting">struct statvfs {
    unsigned long f_bsize;     /* File-system block size (in bytes) */
    unsigned long f_frsize;    /* Fundamental file-system block size
                                  (in bytes) */
    fsblkcnt_t    f_blocks;    /* Total number of blocks in file
                                  system (in units of 'f_frsize') */
    fsblkcnt_t    f_bfree;     /* Total number of free blocks */
    fsblkcnt_t    f_bavail;    /* Number of free blocks available to
                                  unprivileged process */
    fsfilcnt_t    f_files;     /* Total number of i-nodes */
    fsfilcnt_t    f_ffree;     /* Total number of free i-nodes */
    fsfilcnt_t    f_favail;    /* Number of i-nodes available to unprivileged
                                  process (set to 'f_ffree' on Linux) */
    unsigned long f_fsid;      /* File-system ID */
    unsigned long f_flag;      /* Mount flags */
    unsigned long f_namemax;   /* Maximum length of filenames on
                                  this file system */
};</pre><p>The purpose of most of the fields in the <span class="emphasis"><em>statvfs</em></span> structure is
                made clear in the comments above. We note a few further points regarding some
                fields:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>fsblkcnt_t</em></span> and <span class="emphasis"><em>fsfilcnt_t</em></span>
                        data types are integer types specified by SUSv3.</p></li><li class="listitem"><p>For most Linux file systems, the values of <span class="emphasis"><em>f_bsize</em></span>
                        and <span class="emphasis"><em>f_frsize</em></span> are the same. However, some file systems
                        support the notion of block fragments, which can be used to allocate a
                        smaller unit of storage at the end of the file if a full block is not
                        required. This avoids the waste of space that would otherwise occur if a
                        full block was allocated. On such file systems,
                            <span class="emphasis"><em>f_frsize</em></span> is the size of a fragment, and
                            <span class="emphasis"><em>f_bsize</em></span> is the size of a whole block. (The notion
                        of fragments in UNIX file systems first appeared in the early 1980s with the
                        4.2BSD Fast File System, described in [McKusick et al., 1984].)</p></li><li class="listitem"><p>Many native UNIX and Linux file systems support the notion of reserving a
                        certain portion of the blocks of a file system for the superuser, so that if
                        the file system fills up, the superuser can still log in to the system and
                        do some work to resolve the problem. If there are reserved blocks in the
                        file system, then the difference in values of the
                            <span class="emphasis"><em>f_bfree</em></span> and <span class="emphasis"><em>f_bavail</em></span> fields in
                        the <span class="emphasis"><em>statvfs</em></span> structure tells us how many blocks are
                        reserved.</p></li><li class="listitem"><p>The <span class="emphasis"><em>f_flag</em></span> field is a bit mask of the flags used to
                        mount the file system; that is, it contains information similar to the
                            <span class="emphasis"><em>mountflags</em></span> argument given to
                            <span class="emphasis"><em>mount(2)</em></span>. However, the constants used for the bits
                        in this field have names starting with <code class="literal">ST_</code> instead of the <code class="literal">MS_</code>
                        used for <span class="emphasis"><em>mountflags</em></span>. SUSv3 requires only the <code class="literal">ST_RDONLY</code> and <code class="literal">ST_NOSUID</code> constants, but the <span class="emphasis"><em>glibc</em></span>
                        implementation supports a full range of constants with names corresponding
                        to the <code class="literal">MS_*</code> constants described for the
                            <span class="emphasis"><em>mount() mountflags</em></span> argument.</p></li><li class="listitem"><p>The <span class="emphasis"><em>f_fsid</em></span> field is used on some UNIX implementations
                        to return a unique identifier for the file system—for example, a value based
                        on the identifier of the device on which the file system resides. For most
                        Linux file systems, this field contains 0.</p></li></ul></div><p>SUSv3 specifies both <span class="emphasis"><em>statvfs()</em></span> and
                    <span class="emphasis"><em>fstatvfs()</em></span>. On Linux (as on several other UNIX
                implementations), these functions are layered on top of the quite similar
                    <span class="emphasis"><em>statfs()</em></span> and <span class="emphasis"><em>fstatfs()</em></span> system calls.
                (Some UNIX implementations provide a <span class="emphasis"><em>statfs()</em></span> system call, but
                don’t provide <span class="emphasis"><em>statvfs()</em></span>.) The principal differences (aside from
                some differently named fields) are as follows<a id="IDX-CHP-14-1894" class="indexterm"/><a id="IDX-CHP-14-1895" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em>statvfs()</em></span> and <span class="emphasis"><em>fstatvfs()</em></span>
                        functions return the <span class="emphasis"><em>f_flag</em></span> field, giving information
                        about the file-system mount flags. (The <span class="emphasis"><em>glibc</em></span>
                        implementation obtains this information by scanning <code class="literal">/proc/mounts</code> or <code class="literal">/etc/mtab</code>.)</p></li><li class="listitem"><p>The <span class="emphasis"><em>statfs()</em></span> and <span class="emphasis"><em>fstatfs()</em></span>
                        system calls return the field <span class="emphasis"><em>f_type</em></span>, giving the type
                        of the file system (e.g., the value <code class="literal">0xef53</code> indicates that this is an <span class="emphasis"><em>ext2</em></span>
                        file system).</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>The <code class="literal">filesys</code> subdirectory in the source code
                    distribution for this book contains two files, <code class="literal">t_statvfs.c</code> and <code class="literal">t_statfs.c</code>,
                    demonstrating the use of <span class="emphasis"><em>statvfs()</em></span> and
                        <span class="emphasis"><em>statfs()</em></span>.<a id="IDX-CHP-14-1896" class="indexterm"/><a id="IDX-CHP-14-1897" class="indexterm"/></p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id13">Summary</h2></div></div></div><p>Devices are represented by entries in the <code class="literal">/dev</code>
                directory. Each device has a corresponding device driver, which implements a
                standard set of operations, including those corresponding to the
                    <span class="emphasis"><em>open()</em></span>, <span class="emphasis"><em>read()</em></span>,
                    <span class="emphasis"><em>write()</em></span>, and <span class="emphasis"><em>close()</em></span> system calls. A
                device may be real, meaning that there is a corresponding hardware device, or
                virtual, meaning that no hardware device exists, but the kernel nevertheless
                provides a device driver that implements an API that is the same as a real
                    device.<a id="IDX-CHP-14-1898" class="indexterm"/></p><p>A hard disk is divided into one or more partitions, each of which may contain a
                file system. A file system is an organized collection of regular files and
                directories. Linux implements a wide variety of file systems, including the
                traditional <span class="emphasis"><em>ext2</em></span> file system. The <span class="emphasis"><em>ext2</em></span>
                file system is conceptually similar to early UNIX file systems, consisting of a boot
                block, a superblock, an i-node table, and a data area containing file data blocks.
                Each file has an entry in the file system’s i-node table. This entry contains
                various information about the file, including its type, size, link count, ownership,
                permissions, timestamps, and pointers to the file’s data blocks.</p><p>Linux provides a range of journaling file systems, including
                    <span class="emphasis"><em>Reiserfs</em></span>, <span class="emphasis"><em>ext3</em></span>,
                    <span class="emphasis"><em>ext4</em></span>, <span class="emphasis"><em>XFS</em></span>, <span class="emphasis"><em>JFS</em></span>,
                and <span class="emphasis"><em>Btrfs</em></span>. A journaling file system records metadata updates
                (and optionally on some file systems, data updates) to a log file before the actual
                file updates are performed. This means that in the event of a system crash, the log
                file can be replayed to quickly restore the file system to a consistent state. The
                key benefit of journaling file systems is that they avoid the lengthy file-system
                consistency checks required by conventional UNIX file systems after a system
                crash.</p><p>All file systems on a Linux system are mounted under a single directory tree, with
                the directory <code class="literal">/</code> at its root. The location at
                which a file system is mounted in the directory tree is called its mount
                point.</p><p>A privileged process can mount and unmount a file system using the
                    <span class="emphasis"><em>mount()</em></span> and <span class="emphasis"><em>umount()</em></span> system calls.
                Information about a mounted file system can be retrieved using
                    <span class="emphasis"><em>statvfs()</em></span>.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title" id="further_information-id13"/></div></div></div><div class="sect3" title="Further information"><div class="titlepage"><div><div><h4 class="title" id="further_information-id14">Further information</h4></div></div></div><p>For detailed information about devices and device drivers, see [Bovet
                        &amp; Cesati, 2005] and especially [Corbet et al., 2005]. Some useful
                        information about devices can be found in the kernel source file <code class="literal">Documentation/devices.txt</code>.<a id="IDX-CHP-14-1899" class="indexterm"/><a id="IDX-CHP-14-1900" class="indexterm"/><a id="IDX-CHP-14-1901" class="indexterm"/><a id="IDX-CHP-14-1902" class="indexterm"/><a id="IDX-CHP-14-1903" class="indexterm"/><a id="IDX-CHP-14-1904" class="indexterm"/><a id="IDX-CHP-14-1905" class="indexterm"/></p><p>Several books provide further information about file systems. [Tanenbaum,
                        2007] is a general introduction to file-system structures and
                        implementation. [Bach, 1986] provides an introduction to the implementation
                        of UNIX file systems, oriented primarily toward System V. [Vahalia, 1996]
                        and [Goodheart &amp; Cox, 1994] also describe the System V file-system
                        implementation. [Love, 2010] and [Bovet &amp; Cesati, 2005] describe the
                        Linux VFS implementation.</p><p>Documentation on various file systems can be found in the kernel source
                        subdirectory <code class="literal">Documentation/filesystems</code>.
                        Individual web sites can be found describing most of the file-system
                        implementations available on Linux.</p></div></div></div><div class="sect1" title="Exercise"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="exercise-id3">Exercise</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Write a program that measures the time required to create and then remove
                        a large number of 1-byte files from a single directory. The program should
                        create files with names of the form <code class="literal">xNNNNNN</code>, where <code class="literal">NNNNNN</code> is
                        replaced by a random six-digit number. The files should be created in the
                        random order in which their names are generated, and then deleted in
                        increasing numerical order (i.e., an order that is different from that in
                        which they were created). The number of files (<span class="emphasis"><em>NF</em></span>) and
                        the directory in which they are to be created should be specifiable on the
                        command line. Measure the times required for different values of
                            <span class="emphasis"><em>NF</em></span> (e.g., in the range from 1000 to 20,000) and for
                        different file systems (e.g., <span class="emphasis"><em>ext2</em></span>,
                            <span class="emphasis"><em>ext3</em></span>, and <span class="emphasis"><em>XFS</em></span>). What patterns
                        do you observe on each file system as <span class="emphasis"><em>NF</em></span> increases? How
                        do the various file systems compare? Do the results change if the files are
                        created in increasing numerical order (<code class="literal">x000001</code>, <code class="literal">x000001</code>, <code class="literal">x0000002</code>, and so on) and then deleted in the
                        same order? If so, what do you think the reason(s) might be? Again, do the
                        results vary across file-system types?</p></li></ol></div></div></section></body></html>
