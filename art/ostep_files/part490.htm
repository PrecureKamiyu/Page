<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>43.12 Crash Recovery And The Log</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part489.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part491.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">43.12 Crash Recovery And The Log</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One final problem: what happens if the system crashes while LFS is writing to disk? As you may recall in the previous chapter about jour- naling, crashes during updates are tricky for file systems, and thus some-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 68pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">thing LFS must consider as well.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">During normal operation, LFS buffers writes in a segment, and then (when the segment is full, or when some amount of time has elapsed), writes the segment to disk. LFS organizes these writes in a <b>log</b>, i.e., the checkpoint region points to a head and tail segment, and each segment points to the next segment to be written. LFS also periodically updates the checkpoint region. Crashes could clearly happen during either of these operations (write to a segment, write to the CR). So how does LFS handle crashes during writes to these structures?</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let’s cover the second case first. To ensure that the CR update happens atomically, LFS actually keeps two CRs, one at either end of the disk, and writes to them alternately. LFS also implements a careful protocol when updating the CR with the latest pointers to the inode map and other infor- mation; specifically, it first writes out a header (with timestamp), then the body of the CR, and then finally one last block (also with a timestamp). If the system crashes during a CR update, LFS can detect this by seeing an inconsistent pair of timestamps. LFS will always choose to use the most recent CR that has consistent timestamps, and thus consistent update of the CR is achieved.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Let’s now address the first case. Because LFS writes the CR every 30 seconds or so, the last consistent snapshot of the file system may be quite old. Thus, upon reboot, LFS can easily recover by simply reading in the checkpoint region, the imap pieces it points to, and subsequent files and directories; however, the last many seconds of updates would be lost.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">To improve upon this, LFS tries to rebuild many of those segments through a technique known as <b>roll forward </b>in the database community. The basic idea is to start with the last checkpoint region, find the end of the log (which is included in the CR), and then use that to read through the next segments and see if there are any valid updates within it. If there are, LFS updates the file system accordingly and thus recovers much of the data and metadata written since the last checkpoint. See Rosenblum’s award-winning dissertation for details [R92].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part489.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part491.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
