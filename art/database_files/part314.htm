<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>17.4  Transaction Atomicity and Durability</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part313.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part315.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">17.4  <span style=" color: #00AEEF;">Transaction Atomicity and Durability</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">As we noted earlier, a transaction may not always complete its execution successfully. Such a transaction is termed <span class="s63">aborted</span>. If we are to ensure the atomicity property, an aborted transaction must have no eﬀect on the state of the database. Thus, any changes that the aborted transaction made to the database must be undone. Once the changes caused by an aborted transaction have been undone, we say that the transaction has been <span class="s63">rolled back</span>. It is part of the responsibility of the recovery scheme to manage trans- action aborts. This is done typically by maintaining a <span class="s63">log</span>. Each database modiﬁcation made by a transaction is ﬁrst recorded in the log. We record the identiﬁer of the trans- action performing the modiﬁcation, the identiﬁer of the data item being modiﬁed, and both the old value (prior to modiﬁcation) and the new value (after modiﬁcation) of the data item. Only then is the database itself modiﬁed. Maintaining a log provides the possibility of redoing a modiﬁcation to ensure atomicity and durability as well as the possibility of undoing a modiﬁcation to ensure atomicity in case of a failure during transaction execution. Details of log-based recovery are discussed in Chapter 19.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">A transaction that completes its execution successfully is said to be <span class="s63">committed</span>. A committed transaction that has performed updates transforms the database into a new consistent state, which must persist even if there is a system failure.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Once a transaction has committed, we cannot undo its eﬀects by aborting it. The only way to undo the eﬀects of a committed transaction is to execute a <span class="s63">compensating transaction</span>. For instance, if a transaction added $20 to an account, the compensating transaction would subtract $20 from the account. However, it is not always possible to create such a compensating transaction. Therefore, the responsibility of writing and ex- ecuting a compensating transaction is left to the user and is not handled by the database system.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We need to be more precise about what we mean by <i>successful completion </i>of a transaction. We therefore establish a simple abstract transaction model. A transaction must be in one of the following states:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s63">Active</span><span class="p">, the initial state; the transaction stays in this state while it is executing.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s63">Partially committed</span><span class="p">, after the ﬁnal statement has been executed.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s63">Failed</span><span class="p">, after the discovery that normal execution can no longer proceed.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: left;">• <span class="s63">Aborted</span><span class="p">, after the transaction has been rolled back and the database has been restored to its state prior to the start of the transaction.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s63">Committed</span><span class="p">, after successful completion.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The state diagram corresponding to a transaction appears in Figure 17.1. We say that a transaction has committed only if it has entered the committed state. Similarly, we say that a transaction has aborted only if it has entered the aborted state. A trans- action is said to have <span class="s63">terminated </span>if it has either committed or aborted.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A transaction starts in the active state. When it ﬁnishes its ﬁnal statement, it enters the partially committed state. At this point, the transaction has completed its execution, but it is still possible that it may have to be aborted, since the actual output may still be temporarily residing in main memory, and thus a hardware failure may preclude its successful completion.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The database system then writes out enough information to disk that, even in the event of a failure, the updates performed by the transaction can be re-created when the system restarts after the failure. When the last of this information is written out, the transaction enters the committed state.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">As mentioned earlier, we assume for now that failures do not result in loss of data on disk. Chapter 19 discusses techniques to deal with loss of data on disk.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">A transaction enters the failed state after the system determines that the transac- tion can no longer proceed with its normal execution (e.g., because of hardware or logical errors). Such a transaction must be rolled back. Then, it enters the aborted state. At this point, the system has two options:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="263" height="180" alt="image" src="Image_2975.png"/></span></p><p class="s119" style="text-indent: 4pt;line-height: 108%;text-align: left;">partially committed</p><p style="text-indent: 0pt;text-align: left;"/><p class="s119" style="text-indent: 0pt;line-height: 8pt;text-align: left;">committed</p><p style="text-indent: 0pt;text-align: left;"/><p class="s119" style="text-indent: 0pt;line-height: 8pt;text-align: left;">active</p><p style="text-indent: 0pt;text-align: left;"/><p class="s119" style="text-indent: 0pt;line-height: 8pt;text-align: left;">failed</p><p style="text-indent: 0pt;text-align: left;"/><p class="s119" style="text-indent: 0pt;line-height: 8pt;text-align: left;">aborted</p><p style="text-indent: 0pt;text-align: left;"/><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 17.1 <span class="s74">State diagram of a transaction.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><a name="bookmark371">• </a><span class="s40">It can </span><span class="s63">restart </span><span class="p">the transaction, but only if the transaction was aborted as a result of some hardware or software error that was not created through the internal logic of the transaction. A restarted transaction is considered to be a new transaction.</span><a name="bookmark413">&zwnj;</a></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">It can </span><span class="s63">kill </span><span class="p">the transaction. It usually does so because of some internal logical error that can be corrected only by rewriting the application program, or because the input was bad, or because the desired data were not found in the database.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We must be cautious when dealing with <span class="s63">observable external writes</span>, such as writes to a user’s screen, or sending email. Once such a write has occurred, it cannot be erased, since it may have been seen external to the database system. Most systems allow such writes to take place only after the transaction has entered the committed state. One way to implement such a scheme is for the database system to store any value associated with such external writes temporarily in a special relation in the database, and to perform the actual writes only after the transaction enters the committed state. If the system should fail after the transaction has entered the committed state, but before it could complete the external writes, the database system will carry out the external writes (using the data in non-volatile storage) when the system is restarted.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Handling external writes can be more complicated in some situations. For example, suppose the external action is that of dispensing cash at an automated teller machine, and the system fails just before the cash is actually dispensed (we assume that cash can be dispensed atomically). It makes no sense to dispense cash when the system is restarted, since the user may have left the machine. In such a case a compensating trans- action, such as depositing the cash back into the user’s account, needs to be executed when the system is restarted.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">As another example, consider a user making a booking over the web. It is possi- ble that the database system or the application server crashes just after the booking transaction commits. It is also possible that the network connection to the user is lost just after the booking transaction commits. In either case, even though the transaction has committed, the external write has not taken place. To handle such situations, the application must be designed such that when the user connects to the web application again, she will be able to see whether her transaction had succeeded or not.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">For certain applications, it may be desirable to allow active transactions to display data to users, particularly for long-duration transactions that run for minutes or hours. Unfortunately, we cannot allow such output of observable data unless we are willing to compromise transaction atomicity.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part313.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part315.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
