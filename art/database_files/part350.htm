<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.4  Recovery Algorithm</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part349.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part351.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 10pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">19.4  <span style=" color: #00AEEF;">Recovery Algorithm</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Until now, in discussing recovery, we have identiﬁed transactions that need to be re- done and those that need to be undone, but we have not given a precise algorithm for performing these actions. We are now ready to present the full <span class="s63">recovery algorithm </span>using log records for recovery from transaction failure and a combination of the most recent checkpoint and log records to recover from a system crash.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The recovery algorithm described in this section requires that a data item that has been updated by an uncommitted transaction cannot be modiﬁed by any other transaction, until the ﬁrst transaction has either committed or aborted. Recall that this restriction was discussed in Section 19.3.3.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">19.4.1 Transaction Rollback</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">First consider transaction rollback during normal operation (i.e., not during recovery from a system crash). Rollback of a transaction <i>T</i><span class="s97">i </span>is performed as follows:</p><p style="padding-top: 11pt;padding-left: 97pt;text-indent: 0pt;line-height: 12pt;text-align: justify;"><span class="s63">1. </span>The log is scanned backward, and for each log record of <i>T</i><span class="s145">i </span>of the form</p><p class="s13" style="padding-left: 113pt;text-indent: 0pt;line-height: 19pt;text-align: justify;"><span class="s83">&lt;</span>T<span class="s97">i</span><span class="p">, </span>X<span class="s97">j </span><span class="p">, </span>V<span class="s130">1</span><span class="s94">, </span>V<span class="s130">2</span><span class="s83">&gt; </span><span class="p">that is found:</span></p><p class="s13" style="padding-top: 1pt;padding-left: 123pt;text-indent: 0pt;text-align: justify;"><span class="p">a. The value </span>V<span class="s130">1 </span><span class="s94">is written to data item </span>X<span class="s97">j </span><span class="p">, and</span></p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;line-height: 77%;text-align: justify;">b. A special redo-only log record <span class="s83">&lt;</span><i>T</i><span class="s145">i</span>, <i>X</i><span class="s145">j </span>, <i>V</i><span class="s98">1</span><span class="s83">&gt; </span>is written to the log, where <i>V</i><span class="s98">1</span> is the value being restored to data item <i>X</i><span class="s97">j </span>during the rollback. These log records are sometimes called <span class="s63">compensation log records</span>. Such records</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">do not need undo information, since we never need to undo such an undo operation. We shall explain later how they are used.</p><p class="s83" style="padding-top: 9pt;padding-left: 113pt;text-indent: -17pt;line-height: 60%;text-align: left;"><span class="s63">2. </span><span class="p">Once the log record </span>&lt;<span class="s13">T</span><span class="s145">i </span><span class="s49">start</span>&gt; <span class="p">is found, the backward scan is stopped, and a log record </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt; <span class="p">is written to the log.</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 17pt;text-align: justify;">Observe that every update action performed by the transaction or on behalf of the transaction, including actions taken to restore data items to their old value, have now been recorded in the log. In Section 19.4.2 we shall see why this is a good idea.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">19.4.2 Recovery After a System Crash</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">Recovery actions, when the database system is restarted after a crash, take place in two phases:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span>In the <span class="s63">redo phase</span>, the system replays updates of <i>all </i>transactions by scanning the log forward from the last checkpoint. The log records that are replayed include log records for transactions that were rolled back before system crash, and those that had not committed when the system crash occurred.</p><p style="padding-left: 145pt;text-indent: 13pt;text-align: justify;">This phase also determines all transactions that were incomplete at the time of the crash, and must therefore be rolled back. Such incomplete transactions would either have been active at the time of the checkpoint, and thus would appear in the transaction list in the checkpoint record, or would have started later; further, such</p><p class="s83" style="padding-left: 145pt;text-indent: 0pt;line-height: 16pt;text-align: justify;"><span class="p">incomplete transactions would have neither a </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt; <span class="p">nor a </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">commit</span>&gt;</p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">record in the log.</p><p style="padding-left: 159pt;text-indent: 0pt;text-align: justify;">The speciﬁc steps taken while scanning the log are as follows:</p><p style="padding-top: 7pt;padding-left: 155pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">a. The list of transactions to be rolled back, undo-list, is initially set to the list</p><p class="s13" style="padding-left: 171pt;text-indent: 0pt;line-height: 19pt;text-align: justify;">L <span class="p">in the </span><span class="s83">&lt;</span><span class="s49">checkpoint </span>L<span class="s83">&gt; </span><span class="p">log record.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 170pt;text-indent: -16pt;line-height: 65%;text-align: justify;"><span class="p">b. Whenever a normal log record of the form </span><span class="s83">&lt;</span>T<span class="s97">i</span><span class="p">, </span>X<span class="s97">j </span><span class="p">, </span>V<span class="s130">1</span><span class="s94">, </span>V<span class="s130">2</span><span class="s83">&gt;</span><span class="p">, or a redo- only log record of the form </span><span class="s83">&lt;</span>T<span class="s145">i</span><span class="p">, </span>X<span class="s145">j </span><span class="p">, </span>V<span class="s98">2</span><span class="s83">&gt; </span><span class="p">is encountered, the operation is redone; that is, the value </span>V<span class="s98">2</span><span class="p"> is written to data item </span>X<span class="s145">j </span><span class="p">.</span></p><p style="padding-top: 6pt;padding-left: 170pt;text-indent: -15pt;line-height: 70%;text-align: justify;">c. Whenever a log record of the form <span class="s83">&lt;</span><i>T</i><span class="s97">i </span><span class="s49">start</span><span class="s83">&gt; </span>is found, <i>T</i><span class="s97">i </span>is added to undo-list.</p><p class="s83" style="padding-top: 4pt;padding-left: 154pt;text-indent: 0pt;line-height: 19pt;text-align: justify;"><span class="p">d. Whenever a log record of the form </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">abort</span>&gt; <span class="p">or </span>&lt;<span class="s13">T</span><span class="s97">i </span><span class="s49">commit</span>&gt; <span class="p">is found,</span></p><p class="s13" style="padding-left: 170pt;text-indent: 0pt;line-height: 73%;text-align: justify;">T<span class="s97">i </span><span class="p">is removed from undo-list.</span></p><p style="padding-top: 5pt;padding-left: 145pt;text-indent: 0pt;text-align: justify;">At the end of the redo phase, undo-list contains the list of all transactions that are incomplete, that is, they neither committed nor completed rollback before the crash.</p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span class="p">In the </span>undo phase<span class="p">, the system rolls back all transactions in the undo-list. It per- forms rollback by scanning the log backward from the end.</span></p><p style="padding-top: 7pt;padding-left: 171pt;text-indent: -15pt;text-align: justify;">a. Whenever it ﬁnds a log record belonging to a transaction in the undo-list, it performs undo actions just as if the log record had been found during the rollback of a failed transaction.</p><p style="padding-top: 7pt;padding-left: 170pt;text-indent: -16pt;line-height: 65%;text-align: justify;">b. When the system ﬁnds a <span class="s83">&lt;</span><i>T</i><span class="s145">i </span><span class="s49">start</span><span class="s83">&gt; </span>log record for a transaction <i>T</i><span class="s145">i </span>in undo- list, it writes a <span class="s83">&lt;</span><i>T</i><span class="s145">i </span><span class="s49">abort</span><span class="s83">&gt; </span>log record to the log and removes <i>T</i><span class="s145">i </span>from undo- list.</p><p class="s83" style="padding-top: 9pt;padding-left: 170pt;text-indent: -15pt;line-height: 76%;text-align: justify;"><span class="p">c. The undo phase terminates once undo-list becomes empty, that is, the sys- tem has found </span>&lt;<span class="s13">T</span><span class="s145">i </span><span class="s49">start</span>&gt; <span class="p">log records for all transactions that were initially in undo-list.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 113pt;text-indent: 0pt;text-align: left;">After the undo phase of recovery terminates, normal transaction processing can resume.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Observe that the redo phase replays every log record since the most recent check- point record. In other words, this phase of restart recovery repeats all the update actions that were executed after the checkpoint, and whose log records reached the stable log. The actions include actions of incomplete transactions and the actions carried out to roll back failed transactions. The actions are repeated in the same order in which they were originally carried out; hence, this process is called <span class="s63">repeating history</span>. Although it may appear wasteful, repeating history even for failed transactions simpliﬁes recovery schemes.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Figure 19.5 shows an example of actions logged during normal operation and ac- tions performed during failure recovery. In the log shown in the ﬁgure, transaction <i>T</i><span class="s98">1</span> had committed, and transaction <i>T</i><span class="s98">0</span> had been completely rolled back, before the system crashed. Observe how the value of data item <i>B </i>is restored during the rollback of <i>T</i><span class="s98">0</span>. Observe also the checkpoint record, with the list of active transactions containing <i>T</i><span class="s98">0</span> and <i>T</i><span class="s93">1</span><span class="s94">.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">When recovering from a crash, in the redo phase, the system performs a redo of</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 94%;text-align: justify;"><span class="p">all operations after the last checkpoint record. In this phase, the list undo-list initially contains </span>T<span class="s130">0 </span><span class="s94">and </span>T<span class="s130">1</span><span class="s94">; </span>T<span class="s130">1 </span><span class="s94">is removed ﬁrst when its commit log record is found, while </span>T<span class="s130">2 </span><span class="s94">is added when its start log record is found. Transaction </span>T<span class="s98">0</span><span class="p"> is removed from undo-list</span></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">when its abort log record is found, leaving only <i>T</i><span class="s98">2</span> in undo-list. The undo phase scans the log backwards from the end, and when it ﬁnds a log record of <i>T</i><span class="s98">2</span> updating <i>A</i>, the old value of <i>A </i>is restored, and a redo-only log record is written to the log. When the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s449" style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">older</p><p class="s275" style="padding-top: 9pt;padding-left: 15pt;text-indent: 0pt;text-align: left;">Beginning of log</p><p style="text-indent: 0pt;text-align: left;"><span><img width="104" height="203" alt="image" src="Image_3062.png"/></span></p><p class="s450" style="padding-top: 1pt;padding-left: 15pt;text-indent: 0pt;text-align: left;"><span class="s449">&lt;</span>T<span class="s451">0</span> <span class="s449">start&gt;</span></p><p class="s449" style="padding-top: 1pt;padding-left: 15pt;text-indent: 0pt;line-height: 2pt;text-align: left;">&lt;<i>T</i><i>0</i>, <i>B</i>, 2000, 2050&gt;</p><p class="s449" style="padding-top: 6pt;padding-left: 62pt;text-indent: 0pt;text-align: center;">Start log records found for all transactions in</p><p class="s450" style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;line-height: 9pt;text-align: right;"><span class="s449">&lt;</span>T<span class="s451">1</span> <span class="s449">start&gt;</span></p><p class="s450" style="padding-top: 8pt;padding-left: 79pt;text-indent: 0pt;line-height: 9pt;text-align: left;">T<span class="s451">0</span> <span class="s449">rollback</span></p><p class="s449" style="padding-left: 52pt;text-indent: 0pt;line-height: 10pt;text-align: left;">undo list</p><p class="s275" style="padding-top: 4pt;padding-left: 35pt;text-indent: 0pt;line-height: 2pt;text-align: left;">Redo Pass</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s275" style="padding-left: 104pt;text-indent: -3pt;text-align: left;">End of log at crash!</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s449" style="padding-left: 88pt;text-indent: 2pt;line-height: 106%;text-align: left;">Log records added during</p><p class="s449" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;checkpoint {<i>T</i><i>0</i>, <i>T</i><i>1</i>}&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>1</i>, C, 700, 600&gt;</p><p class="s450" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s449">&lt;</span>T<span class="s451">1</span> <span class="s449">commit&gt;</span></p><p class="s450" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s449">&lt;</span>T<span class="s451">2</span> <span class="s449">start&gt;</span></p><p class="s449" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>2</i>, A, 500, 400&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;<i>T</i><i>0</i>, B, 2000&gt;</p><p class="s450" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s449">&lt;</span>T<span class="s451">0</span> <span class="s449">abort&gt;</span></p><p class="s449" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 10pt;text-align: left;">&lt;<i>T</i><i>2</i>, A, 500&gt;</p><p class="s449" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;text-align: center;">(during normal operation) begins</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s450" style="padding-left: 44pt;text-indent: -3pt;line-height: 87%;text-align: left;">T<span class="s451">0</span> <span class="s449">rollback complete</span></p><p class="s450" style="padding-top: 8pt;padding-left: 65pt;text-indent: 0pt;line-height: 106%;text-align: center;">T<span class="s451">2</span> <span class="s449">is incomplete at crash</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s449" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">Undo list: <i>T</i><span class="s452">2  </span><b>Undo Pass</b></p><p class="s449" style="padding-left: 97pt;text-indent: 0pt;text-align: left;">recovery</p><p class="s449" style="padding-top: 9pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">newer</p><p class="s450" style="padding-left: 14pt;text-indent: 0pt;text-align: left;"><span class="s449">&lt;</span>T<span class="s451">2</span> <span class="s449">abort&gt;</span></p><p class="s450" style="padding-left: 63pt;text-indent: 0pt;line-height: 106%;text-align: center;">T<span class="s451">2</span> <span class="s449">rolled back in undo pass</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="317" height="242" alt="image" src="Image_3063.png"/></span></p><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 19.5 <span class="s74">Example of logged actions and actions during recovery.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">start record for <i>T</i><span class="s98">2</span> is found, an <span class="s49">abort </span>record is added for <i>T</i><span class="s98">2</span>. Since undo-list contains no more transactions, the undo phase terminates, completing recovery.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 119pt;text-indent: 0pt;text-align: left;">19.4.3 Optimizing Commit Processing</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">Committing a transaction requires that its log records have been forced to disk. If a sep- arate log ﬂush is done for each transaction, each commit incurs a signiﬁcant log write overhead. The rate of transaction commit can be increased using the <span class="s63">group-commit </span>technique. With this technique, instead of attempting to force the log as soon as a transaction completes, the system waits until several transactions have completed, or a certain period of time has passed since a transaction completed execution. It then commits the group of transactions that are waiting, together. Blocks written to the log on stable storage would contain records of several transactions. By careful choice of group size and maximum waiting time, the system can ensure that blocks are full when they are written to stable storage without making transactions wait excessively. This technique results, on average, in fewer output operations per committed transaction.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If logging is done to hard disk, writing a block of data can take about 5 to 10 milliseconds. As a result, without group commit, at most 100 to 200 transactions can be committed per second. If records of 10 transactions ﬁt in a disk block, group commit will allow 1000 to 2000 transactions to be committed per second.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">If logging is done to ﬂash, writing a block can take about 100 microseconds, allow- ing 10,000 transactions to be committed per second without group commit. If records of 10 transactions ﬁt in a disk block, group commit will allow 100,000 transactions to be committed per second on ﬂash. A further beneﬁt of group commit with ﬂash is that it minimizes the number of times the same page is written, which in turn minimizes the number of erase operations, which can be expensive. (Recall that ﬂash storage systems remap logical pages to a pre-erased physical page, avoiding delay at the time a page is written, but the erase operation must be performed eventually as part of garbage collection of old versions of pages.)</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Although group commit reduces the overhead imposed by logging, it results in a slight delay in commit of transactions that perform updates. When the rate of commits is low, the delay may not be worth the beneﬁt, but with high rates of transaction commit, the overall delay in commit is actually reduced by using group commit.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">In addition to optimizations done at the database, programmers can also take some steps to improve transaction commit performance. For example, consider an applica- tion that loads data into a database. If the application performs each insert as a separate transaction, the number of inserts that can be performed per second is limited by the number of blocks writes that can be performed per second. If the application waits for one insert to ﬁnish before starting the next one, group commit does not oﬀer any bene- ﬁts and in fact may slow the system down. However, in such a case, performance can be signiﬁcantly improved by performing a batch of inserts as a single transaction. The log records corresponding to multiple inserts are then written together in one page. The number of inserts that can be performed per second then increases correspondingly.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part349.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part351.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
