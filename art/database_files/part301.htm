<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>16.6  Advanced Topics in Query Optimization</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part300.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part302.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">16.6  <span style=" color: #00AEEF;">Advanced Topics in Query Optimization</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">There are a number of opportunities for optimizing queries, beyond those we have seen so far. We examine a few of these in this section.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">16.6.1 Top-<span class="s420">K </span>Optimization</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Many queries fetch results sorted on some attributes, and require only the top <i>K </i>re- sults for some <i>K</i>. Sometimes the bound <i>K </i>is speciﬁed explicitly. For example, some databases support a <b>limit </b><i>K </i>clause which results in only the top <i>K </i>results being re- turned by the query. Other databases support alternative ways of specifying similar limits. In other cases, the query may not specify such a limit, but the optimizer may allow a hint to be speciﬁed, indicating that only the top <i>K </i>results of the query are likely to be retrieved, even if the query generates more results.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When <i>K </i>is small, a query optimization plan that generates the entire set of re- sults, then sorts and generates the top <i>K</i>, is very ineﬃcient since it discards most of the intermediate results that it computes. Several techniques have been proposed to optimize such <i>top-K queries</i>. One approach is to use pipelined plans that can generate the results in sorted order. Another approach is to estimate what is the highest value on the sorted attributes that will appear in the top-<i>K </i>output, and introduce selection predicates that eliminate larger values. If extra tuples beyond the top-<i>K </i>are generated they are discarded, and if too few tuples are generated then the selection condition is changed and the query is re-executed. See the bibliographical notes for references to work on top-<i>K </i>optimization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">16.6.2 Join Minimization</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2953.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2954.png"/></span></p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">When queries are generated through views, sometimes more relations are joined than are needed for computation of the query. For example, a view <i>v </i>may include the join of <i>instructor </i>and <i>department</i>, but a use of the view <i>v </i>may use only attributes from <i>instruc- tor</i>. The join attribute <i>dept name </i>of <i>instructor </i>is a foreign key referencing <i>department</i>. Assuming that <i>instructor</i>.<i>dept name </i>has been declared <b>not null</b>, the join with <i>department </i>can be dropped, with no impact on the query. For under the above assumption, the join with <i>department </i>does not eliminate any tuples from <i>instructor</i>, nor does it result in extra copies of any <i>instructor </i>tuple.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Dropping a relation from a join as above is an example of join minimization. In fact, join minimization can be performed in other situations as well. See the bibliographical notes for references on join minimization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">16.6.3 Optimization of Updates</p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Update queries often involve subqueries in the <b>set </b>and <b>where </b>clauses, which must also be taken into account in optimizing the update. Updates that involve a selection on the updated column (e.g., give a 10 percent salary raise to all employees whose salary is <span class="s86">≥</span></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">$100,000) must be handled carefully. If the update is done while the selection is being</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">evaluated by an index scan, an updated tuple may be reinserted in the index ahead of the scan and seen again by the scan; the same employee tuple may then get incorrectly updated multiple times (an inﬁnite number of times, in this case). A similar problem also arises with updates involving subqueries whose result is aﬀected by the update.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">The problem of an update aﬀecting the execution of a query associated with the up- date is known as the <span class="s63">Halloween problem </span>(named so because it was ﬁrst recognized on a Halloween day, at <span class="s44">IBM</span>). The problem can be avoided by executing the queries deﬁning the update ﬁrst, creating a list of aﬀected tuples, and updating the tuples and indices as the last step. However, breaking up the execution plan in such a fashion increases the execution cost. Update plans can be optimized by checking if the Halloween problem can occur, and if it cannot occur, updates can be performed while the query is being processed, reducing the update overheads. For example, the Halloween problem can- not occur if the update does not aﬀect index attributes. Even if it does, if the updates decrease the value while the index is scanned in increasing order, updated tuples will not be encountered again during the scan. In such cases, the index can be updated even while the query is being executed, reducing the overall cost.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Update queries that result in a large number of updates can also be optimized by collecting the updates as a batch and then applying the batch of updates separately to each aﬀected index. When applying the batch of updates to an index, the batch is ﬁrst sorted in the index order for that index; such sorting can greatly reduce the amount of random <span class="s44">I/O </span>required for updating indices.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Such optimizations of updates are implemented in most database systems. See the bibliographical notes for references to such optimization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;text-align: left;">16.6.4 Multiquery Optimization and Shared Scans</p><p style="padding-top: 6pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">When a batch of queries are submitted together, a query optimizer can potentially exploit common subexpressions between the diﬀerent queries, evaluating them once and reusing them where required. Complex queries may in fact have subexpressions repeated in diﬀerent parts of the query, which can be similarly exploited to reduce query evaluation cost. Such optimization is known as <span class="s63">multiquery optimization</span>.</p><p class="s63" style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Common subexpression elimination <span class="p">optimizes subexpressions shared by diﬀerent expressions in a program by computing and storing the result and reusing it wherever the subexpression occurs. Common subexpression elimination is a standard optimiza- tion applied on arithmetic expressions by programming-language compilers. Exploiting common subexpressions among evaluation plans chosen for each of a batch of queries is just as useful in database query evaluation, and is implemented by some databases. However, multiquery optimization can do even better in some cases: A query typically has more than one evaluation plan, and a judiciously chosen set of query evaluation plans for the queries may provide for a greater sharing and lesser cost than that aﬀorded by choosing the lowest cost evaluation plan for each query. More details on multiquery optimization may be found in references cited in the bibliographical notes.</span></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Sharing of relation scans between queries is another limited form of multiquery op- timization that is implemented in some databases. The <span class="s63">shared-scan </span>optimization works as follows: Instead of reading the relation repeatedly from disk, once for each query that needs to scan a relation, data are read once from disk, and pipelined to each of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">the queries. The shared-scan optimization is particularly useful when multiple queries perform a scan on a single large relation (typically a “fact table”).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">16.6.5 Parametric Query Optimization</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Plan caching, which we saw in Section 16.4.3, is used as a heuristic in many databases. Recall that with plan caching, if a query is invoked with some constants, the plan cho- sen by the optimizer is cached and reused if the query is submitted again, even if the constants in the query are diﬀerent. For example, suppose a query takes a department name as a parameter and retrieves all courses of the department. With plan caching, a plan chosen when the query is executed for the ﬁrst time, say for the Music department, is reused if the query is executed for any other department.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Such reuse of plans by plan caching is reasonable if the optimal query plan is not signiﬁcantly aﬀected by the exact value of the constants in the query. However, if the plan is aﬀected by the value of the constants, parametric query optimization is an alternative.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="1" alt="image" src="Image_2955.png"/></span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">In <span class="s63">parametric query optimization</span>, a query is optimized without being provided spe- ciﬁc values for its parameters — for example, <i>dept name </i>in the preceding example. The optimizer then outputs several plans, each optimal for a diﬀerent parameter value. A plan would be output by the optimizer only if it is optimal for some possible value of the parameters. The set of alternative plans output by the optimizer are stored. When a query is submitted with speciﬁc values for its parameters, instead of performing a full optimization, the cheapest plan from the set of alternative plans computed earlier is used. Finding the cheapest such plan usually takes much less time than reoptimization. See the bibliographical notes for references on parametric query optimization.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">16.6.6 Adaptive Query Processing</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">As we noted earlier, query optimization is based on estimates that are at best approxi- mations. Thus, it is possible at times for the optimizer to choose a plan that turns out to perform very badly. Adaptive operators that choose the speciﬁc operator at execu- tion time provide a partial solution to this problem. For example, <span class="s44">SQL S</span>erver supports an adaptive join algorithm that checks the size of its outer input, and chooses either nested loops join, or hash join depending on the size of the outer input.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Many systems also include the ability to monitor the behavior of a plan during query execution, and adapt the plan accordingly. For example, suppose the statistics collected by the system during early stages of the plan’s execution (or the execution of subparts of the plan) are found to diﬀer substantially from the optimizers estimates to such an extent that it is clear that the chosen plan is suboptimal. Then an adaptive system may abort the execution, choose a new query execution plan using the statis- tics collected during the initial execution, and restart execution using the new plan; the statistics collected during the execution of the old plan ensure the old plan is not selected again. Further, the system must avoid repeated aborts and restarts; ideally, the system should ensure that the overall cost of query evaluation is close to that with the</p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;"><a name="bookmark342">16.7 </a><span style=" color: #00AEEF;">Summary  </span><span class="s164">787</span><a name="bookmark362">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">plan that would be chosen if the optimizer had exact statistics. The speciﬁc criteria and mechanisms for such adaptive query processing are complex, and are referenced in the bibliographic notes available online.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part300.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part302.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
