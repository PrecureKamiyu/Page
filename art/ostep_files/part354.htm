<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>33.2 An Important API: select() (or poll())</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part353.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part355.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">33.2 An Important API: <span class="s51">select() </span>(or <span class="s51">poll()</span>)</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">With that basic event loop in mind, we next must address the question of how to receive events. In most systems, a basic API is available, via either the <span class="s41">select() </span>or <span class="s41">poll() </span>system calls.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">What these interfaces enable a program to do is simple: check whether there is any incoming I/O that should be attended to. For example, imag- ine that a network application (such as a web server) wishes to check whether any network packets have arrived, in order to service them. These system calls let you do exactly that.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">Take <span class="s41">select() </span>for example. The manual page (on Mac OS X) de- scribes the API in this manner:</p><p class="s38" style="padding-top: 7pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">int select(int nfds,</p><p class="s38" style="padding-left: 114pt;text-indent: 0pt;line-height: 89%;text-align: left;">fd_set <span class="s39">*</span>restrict readfds, fd_set <span class="s39">*</span>restrict writefds, fd_set <span class="s39">*</span>restrict errorfds,</p><p class="s38" style="padding-left: 114pt;text-indent: 0pt;line-height: 85%;text-align: left;">struct timeval <span class="s39">*</span>restrict timeout);</p><p style="padding-top: 6pt;padding-left: 68pt;text-indent: 12pt;line-height: 92%;text-align: justify;">The actual description from the man page: <i>select() examines the I/O de- scriptor sets whose addresses are passed in readfds, writefds, and errorfds to see if some of their descriptors are ready for reading, are ready for writing, or have</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;line-height: 11pt;text-align: center;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>B<span class="s45">LOCKING VS</span>. N<span class="s45">ON</span>-<span class="s45">BLOCKING </span>I<span class="s45">NTERFACES</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Blocking (or <b>synchronous</b>) interfaces do all of their work before returning to the caller; non-blocking (or <b>asynchronous</b>) interfaces begin some work but return immediately, thus letting whatever work that needs to be done get done in the background.</p><p style="padding-top: 2pt;padding-left: 9pt;text-indent: 0pt;line-height: 90%;text-align: justify;">The usual culprit in blocking calls is I/O of some kind. For example, if a call must read from disk in order to complete, it might block, waiting for the I/O request that has been sent to the disk to return.</p><p style="padding-top: 2pt;padding-left: 9pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Non-blocking interfaces can be used in any style of programming (e.g., with threads), but are essential in the event-based approach, as a call that blocks will halt all progress.</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s6" style="padding-left: 41pt;text-indent: 0pt;line-height: 92%;text-align: justify;">an exceptional condition pending, respectively. The first nfds descriptors are checked in each set, i.e., the descriptors from 0 through nfds-1 in the descriptor sets are examined. On return, select() replaces the given descriptor sets with subsets consisting of those descriptors that are ready for the requested operation. select() returns the total number of ready descriptors in all the sets.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">A couple of points about <span class="s41">select()</span>. First, note that it lets you check whether descriptors can be <i>read </i>from as well as <i>written </i>to; the former lets a server determine that a new packet has arrived and is in need of processing, whereas the latter lets the service know when it is OK to reply (i.e., the outbound queue is not full).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Second, note the timeout argument. One common usage here is to set the timeout to NULL, which causes <span class="s41">select() </span>to block indefinitely, until some descriptor is ready. However, more robust servers will usually specify some kind of timeout; one common technique is to set the timeout to zero, and thus use the call to <span class="s41">select() </span>to return immediately.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">The <span class="s41">poll() </span>system call is quite similar. See its manual page, or Stevens and Rago [SR05], for details.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Either way, these basic primitives give us a way to build a non-blocking event loop, which simply checks for incoming packets, reads from sockets with messages upon them, and replies as needed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part353.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part355.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
