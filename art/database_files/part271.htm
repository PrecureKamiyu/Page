<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>14.11  Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part270.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part272.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">14.11  <span style=" color: #00AEEF;">Summary</span></p><p class="s39" style="padding-top: 9pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Many queries reference only a small proportion of the records in a ﬁle. To reduce the overhead in searching for these records, we can construct </span><span class="s13">indices </span><span class="p">for the ﬁles that store the database.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">There are two types of indices that we can use: dense indices and sparse indices. Dense indices contain entries for every search-key value, whereas sparse indices contain entries only for some search-key values.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">If the sort order of a search key matches the sort order of a relation, an index on the search key is called a </span>clustering index<span class="p">. The other indices are called </span>nonclustering <span class="p">or </span>secondary indices<span class="p">. Secondary indices improve the performance of queries that use search keys other than the search key of the clustering index. However, they impose an overhead on modiﬁcation of the database.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Index-sequential ﬁles are one of the oldest index schemes used in database systems. To permit fast retrieval of records in search-key order, records are stored sequen- tially, and out-of-order records are chained together. To allow fast random access, we use an index structure.</span></p><p style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">The primary disadvantage of the index-sequential ﬁle organization is that perfor- mance degrades as the ﬁle grows. To overcome this deﬁciency, we can use a B</span><span class="s181">+</span>-<i>tree index</i>.</p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">A B</span><span class="s181">+</span>-tree index takes the form of a <i>balanced </i>tree, in which every path from the root of the tree to a leaf of the tree is of the same length. The height of a B<span class="s181">+</span>- tree is proportional to the logarithm to the base <i>N </i>of the number of records in the relation, where each nonleaf node stores <i>N </i>pointers; the value of <i>N </i>is often around 50 or 100. B<span class="s181">+</span>-trees are much shorter than other balanced binary-tree structures such as <span class="s44">AVL </span>trees, and therefore require fewer disk accesses to locate records.</p><p style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">Lookup on B</span><span class="s181">+</span>-trees is straightforward and eﬃcient. Insertion and deletion, how- ever, are somewhat more complicated, but still eﬃcient. The number of operations required for lookup, insertion, and deletion on B<span class="s181">+</span>-trees is proportional to the log- arithm to the base <i>N </i>of the number of records in the relation, where each nonleaf node stores <i>N </i>pointers.</p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">We can use B</span><span class="s181">+</span><span class="p">-trees for indexing a ﬁle containing records, as well as to organize records into a ﬁle.</span></p><p class="s181" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">B-tree indices are similar to B</span>+<span class="p">-tree indices. The primary advantage of a B-tree is that the B-tree eliminates the redundant storage of search-key values. The major disadvantages are overall complexity and reduced fanout for a given node size. System designers almost universally prefer B</span>+<span class="p">-tree indices over B-tree indices in practice.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Hashing is a widely used technique for building indices in main memory as well as in disk-based systems.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Ordered indices such as B</span><span class="s181">+</span><span class="p">-trees can be used for selections based on equality con- ditions involving single attributes. When multiple attributes are involved in a selec- tion condition, we can intersect record identiﬁers retrieved from multiple indices.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">The basic B</span><span class="s181">+</span><span class="p">-tree structure is not ideal for applications that need to support a very large number of random writes/inserts per second. Several alternative index structures have been proposed to handle workloads with a high write/insert rate, including the log-structured merge tree and the buﬀer tree.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Bitmap indices provide a very compact representation for indexing attributes with very few distinct values. Intersection operations are extremely fast on bitmaps, making them ideal for supporting queries on multiple attributes.</span></p><p class="s181" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s40">R-trees are a multidimensional extension of B-trees; with variants such as R</span>+<span class="p">-trees and R</span>∗<span class="p">-trees, they have proved popular in spatial databases. Index structures that partition space in a regular fashion, such as quadtrees, help in processing spatial join queries.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">There are a number of techniques for indexing temporal data, including the use of spatial index and the interval B</span><span class="s181">+</span><span class="p">-tree specialized index.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part270.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part272.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
