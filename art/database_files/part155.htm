<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>7.4   Functional-Dependency Theory</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part154.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part156.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark137">7.4   </a><span style=" color: #00AEEF;">Functional-Dependency Theory</span><a name="bookmark165">&zwnj;</a></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We have seen in our examples that it is useful to be able to reason systematically about functional dependencies as part of a process of testing schemas for <span class="s44">BCNF </span>or <span class="s44">3NF</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.4.1 Closure of a Set of Functional Dependencies</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">We shall see that, given a set <i>F </i>of functional dependencies on a schema, we can prove that certain other functional dependencies also hold on the schema. We say that such functional dependencies are “logically implied” by <i>F </i>. When testing for normal forms, it is not suﬃcient to consider the given set of functional dependencies; rather, we need to consider <i>all </i>functional dependencies that hold on the schema.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">More formally, given a relation schema <i>r</i>(<i>R</i>), a functional dependency <i>f </i>on <i>R </i>is <span class="s63">log- ically implied </span>by a set of functional dependencies <i>F </i>on <i>R </i>if every instance of a relation <i>r</i>(<i>R</i>) that satisﬁes <i>F </i>also satisﬁes <i>f </i>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Suppose we are given a relation schema <i>r</i>(<i>A</i>, <i>B</i>, <i>C</i>, <i>G</i>, <i>H </i>, <i>I </i>) and the set of functional dependencies:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 256pt;text-indent: 0pt;line-height: 77%;text-align: left;">A <span class="s86">→ </span>B A <span class="s86">→ </span>C</p><p class="s13" style="padding-left: 256pt;text-indent: 0pt;line-height: 76%;text-align: left;">CG <span class="s86">→ </span>H CG <span class="s86">→ </span>I</p><p class="s13" style="padding-left: 256pt;text-indent: 0pt;line-height: 14pt;text-align: left;">B <span class="s86">→ </span>H</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">The functional dependency:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 260pt;text-indent: 0pt;text-align: left;">A <span class="s86">→ </span>H</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 88%;text-align: justify;"><span class="p">is logically implied. That is, we can show that, whenever a relation instance satisﬁes our given set of functional dependencies, </span>A <span class="s86">→ </span>H <span class="p">must also be satisﬁed by that relation instance. Suppose that </span>t<span class="s98">1</span><span class="p"> and </span>t<span class="s98">2</span><span class="p"> are tuples such that:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 63pt;text-indent: 0pt;text-align: center;">t<span class="s98">1</span><span class="p">[</span>A<span class="p">] </span><span class="s15">= </span>t<span class="s98">2</span><span class="p">[</span>A<span class="p">]</span></p><p class="s13" style="padding-top: 13pt;padding-left: 88pt;text-indent: 0pt;line-height: 86%;text-align: justify;"><span class="p">Since we are given that </span>A <span class="s86">→ </span>B<span class="p">, it follows from the deﬁnition of functional dependency that:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 63pt;text-indent: 0pt;text-align: center;">t<span class="s98">1</span><span class="p">[</span>B<span class="p">] </span><span class="s15">= </span>t<span class="s98">2</span><span class="p">[</span>B<span class="p">]</span></p><p class="s13" style="padding-top: 13pt;padding-left: 88pt;text-indent: 0pt;line-height: 86%;text-align: left;"><span class="p">Then, since we are given that </span>B <span class="s86">→ </span>H <span class="p">, it follows from the deﬁnition of functional de- pendency that:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 63pt;text-indent: 0pt;text-align: center;">t<span class="s98">1</span><span class="p">[</span>H <span class="p">] </span><span class="s15">= </span>t<span class="s98">2</span><span class="p">[</span>H <span class="p">]</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 7pt;padding-left: 119pt;text-indent: 0pt;line-height: 80%;text-align: justify;"><span class="p">Therefore, we have shown that, whenever </span>t<span class="s93">1 </span><span class="s94">and </span>t<span class="s93">2 </span><span class="s94">are tuples such that </span>t<span class="s93">1</span><span class="s94">[</span>A<span class="p">] </span><span class="s15">= </span>t<span class="s93">2</span><span class="s94">[</span>A<span class="p">], it must be that </span>t<span class="s98">1</span><span class="p">[</span>H <span class="p">] </span><span class="s15">= </span>t<span class="s98">2</span><span class="p">[</span>H <span class="p">]. But that is exactly the deﬁnition of </span>A <span class="s86">→ </span>H <span class="p">.</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 12pt;text-align: right;">Let <i>F </i>be a set of functional dependencies. The <span class="s63">closure </span>of <i>F </i>, denoted by <i>F </i><span class="s181">+</span>, is the</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 94%;text-align: right;">set of all functional dependencies logically implied by <i>F </i>. Given <i>F </i>, we can compute <i>F </i><span class="s181">+</span><span class="s15"> </span>directly from the formal deﬁnition of functional dependency. If <i>F </i>were large, this pro- cess would be lengthy and diﬃcult. Such a computation of <i>F </i><span class="s181">+</span><span class="s15"> </span>requires arguments of the type just used to show that <i>A </i><span class="s86">→ </span><i>H </i>is in the closure of our example set of dependencies. <span class="s63">Axioms</span>, or rules of inference, provide a simpler technique for reasoning about func-</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">tional dependencies. In the rules that follow, we use Greek letters (<span class="s15">α</span>, <span class="s15">β</span>, <span class="s15">γ</span>, <span class="s15">… </span>) for sets of attributes and uppercase Roman letters from the beginning of the alphabet for indi- vidual attributes. We use <span class="s15">αβ </span>to denote <span class="s15">α ∪ β</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We can use the following three rules to ﬁnd logically implied functional dependen- cies. By applying these rules <i>repeatedly</i>, we can ﬁnd all of <i>F </i><span class="s181">+</span>, given <i>F </i>. This collection of rules is called <span class="s63">Armstrong’s axioms </span>in honor of the person who ﬁrst proposed it.</p><p class="s15" style="padding-top: 9pt;padding-left: 123pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><span class="s39">• </span><span class="s46">Reflexivity rule</span><span class="p">. If </span>α <span class="p">is a set of attributes and </span>β <span class="s83">⊆ </span>α<span class="p">, then </span>α <span class="s86">→ </span>β <span class="p">holds.</span></p><p class="s15" style="padding-left: 123pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s39">• </span><span class="s46">Augmentation rule</span><span class="p">. If </span>α <span class="s86">→ </span>β <span class="p">holds and </span>γ <span class="p">is a set of attributes, then </span>γα <span class="s86">→ </span>γβ</p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 12pt;text-align: left;">holds.</p><p class="s15" style="padding-top: 3pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s46">Transitivity rule</span><span class="p">. If </span>α <span class="s86">→ </span>β <span class="p">holds and </span>β <span class="s86">→ </span>γ <span class="p">holds, then </span>α <span class="s86">→ </span>γ <span class="p">holds.</span></p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Armstrong’s axioms are <span class="s63">sound</span>, because they do not generate any incorrect func- tional dependencies. They are <span class="s63">complete</span>, because, for a given set <i>F </i>of functional de- pendencies, they allow us to generate all <i>F </i><span class="s181">+</span>. The Further Reading section provides references for proofs of soundness and completeness.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Although Armstrong’s axioms are complete, it is tiresome to use them directly for the computation of <i>F </i><span class="s181">+</span>. To simplify matters further, we list additional rules. It is possible to use Armstrong’s axioms to prove that these rules are sound (see Practice Exercise 7.4, Practice Exercise 7.5, and Exercise 7.27).</p><p class="s15" style="padding-top: 9pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s46">Union rule</span><span class="p">. If </span>α <span class="s86">→ </span>β <span class="p">holds and </span>α <span class="s86">→ </span>γ <span class="p">holds, then </span>α <span class="s86">→ </span>βγ <span class="p">holds.</span></p><p class="s15" style="padding-top: 1pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s46">Decomposition rule</span><span class="p">. If </span>α <span class="s86">→ </span>βγ <span class="p">holds, then </span>α <span class="s86">→ </span>β <span class="p">holds and </span>α <span class="s86">→ </span>γ <span class="p">holds.</span></p><p class="s15" style="padding-top: 1pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s46">Pseudotransitivity rule</span><span class="p">. If </span>α <span class="s86">→ </span>β <span class="p">holds and </span>γβ <span class="s86">→ </span>δ <span class="p">holds, then </span>αγ <span class="s86">→ </span>δ <span class="p">holds.</span></p><p class="s13" style="padding-top: 11pt;padding-left: 119pt;text-indent: 17pt;line-height: 87%;text-align: justify;"><span class="p">Let us apply our rules to the example of schema </span>R <span class="s15">= </span><span class="p">(</span>A<span class="p">, </span>B<span class="p">, </span>C<span class="p">, </span>G<span class="p">, </span>H <span class="p">, </span>I <span class="p">) and the set </span>F <span class="p">of functional dependencies </span><span class="s15">{</span>A <span class="s86">→ </span>B<span class="p">, </span>A <span class="s86">→ </span>C<span class="p">, </span>CG <span class="s86">→ </span>H <span class="p">, </span>CG <span class="s86">→ </span>I <span class="p">, </span>B <span class="s86">→ </span>H <span class="s15">}</span><span class="p">. We list several members of </span>F <span class="s181">+</span><span class="s15"> </span><span class="p">here:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 139pt;text-indent: -16pt;line-height: 81%;text-align: justify;"><span class="s39">• </span>A <span class="s86">→ </span>H <span class="p">. Since </span>A <span class="s86">→ </span>B <span class="p">and </span>B <span class="s86">→ </span>H <span class="p">hold, we apply the transitivity rule. Observe that it was much easier to use Armstrong’s axioms to show that </span>A <span class="s86">→ </span>H <span class="p">holds than it was to argue directly from the deﬁnitions, as we did earlier in this section.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;text-align: justify;"><span class="s39">• </span>CG <span class="s86">→ </span>HI <span class="p">. Since </span>CG <span class="s86">→ </span>H <span class="p">and </span>CG <span class="s86">→ </span>I <span class="p">, the union rule implies that </span>CG <span class="s86">→ </span>HI <span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_1980.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 6pt;padding-left: 134pt;text-indent: 0pt;text-align: left;">F <span class="s181">+</span><span class="s15"> </span><span class="p">= </span>F</p><p style="padding-left: 134pt;text-indent: 0pt;text-align: left;">apply the reﬂexivity rule /* Generates all trivial dependencies */</p><p class="s46" style="padding-left: 134pt;text-indent: 0pt;text-align: left;">repeat</p><p style="padding-left: 155pt;text-indent: 0pt;text-align: left;"><b>for each </b>functional dependency <i>f </i>in <i>F </i><span class="s181">+</span></p><p style="padding-left: 177pt;text-indent: 0pt;text-align: left;">apply the augmentation rule on <i>f</i></p><p style="padding-left: 177pt;text-indent: 0pt;text-align: left;">add the resulting functional dependencies to <i>F </i><span class="s181">+</span></p><p class="s13" style="padding-left: 62pt;text-indent: 0pt;line-height: 14pt;text-align: center;"><b>for each </b><span class="p">pair of functional dependencies </span>f<span class="s130">1 </span><span class="s94">and </span>f<span class="s130">2 </span><span class="s94">in </span>F <span class="s181">+</span></p><p class="s13" style="padding-left: 62pt;text-indent: 0pt;line-height: 13pt;text-align: center;"><b>if </b>f<span class="s93">1 </span><span class="s94">and </span>f<span class="s93">2 </span><span class="s94">can be combined using transitivity</span></p><p style="padding-left: 84pt;text-indent: 0pt;line-height: 12pt;text-align: center;">add the resulting functional dependency to <i>F </i><span class="s181">+</span></p><p class="s46" style="padding-left: 28pt;text-indent: 0pt;text-align: center;">until <i>F </i><span class="s181">+</span><span class="s15"> </span><span class="p">does not change any further</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_1981.png"/></span></p><p class="s74" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: center;"><span class="s73">Figure 7.7 </span>A procedure to compute <span class="s190">F</span><span class="s237">+</span>.</p><p class="s13" style="padding-top: 10pt;padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s39">• </span>AG <span class="s86">→ </span>I <span class="p">. Since </span>A <span class="s86">→ </span>C <span class="p">and </span>CG <span class="s86">→ </span>I <span class="p">, the pseudotransitivity rule implies that</span></p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">AG <span class="s86">→ </span>I <span class="p">holds.</span></p><p class="s13" style="padding-left: 107pt;text-indent: 15pt;line-height: 76%;text-align: justify;"><span class="p">Another way of ﬁnding that </span>AG <span class="s86">→ </span>I <span class="p">holds is as follows: We use the augmen- tation rule on </span>A <span class="s86">→ </span>C <span class="p">to infer </span>AG <span class="s86">→ </span>CG<span class="p">. Applying the transitivity rule to this dependency and </span>CG <span class="s86">→ </span>I <span class="p">, we infer </span>AG <span class="s86">→ </span>I <span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Figure 7.7 shows a procedure that demonstrates formally how to use Armstrong’s axioms to compute <i>F </i><span class="s181">+</span>. In this procedure, when a functional dependency is added to <i>F </i><span class="s181">+</span>, it may be already present, and in that case there is no change to <i>F </i><span class="s181">+</span>. We shall see an alternative way of computing <i>F </i><span class="s181">+</span><span class="s15"> </span>in Section 7.4.2.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The left-hand and right-hand sides of a functional dependency are both subsets of <i>R</i>. Since a set of size <i>n </i>has 2<i>n</i><i> </i>subsets, there are a total of 2<i>n</i><i> </i><span class="s15">× </span>2<i>n</i><i> </i><span class="s15">= </span>2<span class="s76">2</span><i>n</i><i> </i>possible functional dependencies, where <i>n </i>is the number of attributes in <i>R</i>. Each iteration of the repeat loop of the procedure, except the last iteration, adds at least one functional dependency to <i>F </i><span class="s181">+</span>. Thus, the procedure is guaranteed to terminate, though it may be very lengthy.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.4.2 Closure of Attribute Sets</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;line-height: 85%;text-align: justify;">We say that an attribute <i>B </i>is <span class="s63">functionally determined </span>by <span class="s15">α </span>if <span class="s15">α </span><span class="s86">→ </span><i>B</i>. To test whether a set <span class="s15">α </span>is a superkey, we must devise an algorithm for computing the set of attributes</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">functionally determined by <span class="s15">α</span>. One way of doing this is to compute <i>F </i><span class="s181">+</span>, take all func- tional dependencies with <span class="s15">α </span>as the left-hand side, and take the union of the right-hand sides of all such dependencies. However, doing so can be expensive, since <i>F </i><span class="s181">+</span><span class="s15"> </span>can be large.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">An eﬃcient algorithm for computing the set of attributes functionally determined by <span class="s15">α </span>is useful not only for testing whether <span class="s15">α </span>is a superkey, but also for several other tasks, as we shall see later in this section.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;">Let <span class="s15">α </span>be a set of attributes. We call the set of all attributes functionally determined by <span class="s15">α </span>under a set <i>F </i>of functional dependencies the closure of <span class="s15">α </span>under <i>F </i>; we denote it by <span class="s15">α</span><span class="s239">+</span>. Figure 7.8 shows an algorithm, written in pseudocode, to compute <span class="s15">α</span><span class="s239">+</span>. The input is a set <i>F </i>of functional dependencies and the set <span class="s15">α </span>of attributes. The output is stored in the variable <i>result</i>.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">To illustrate how the algorithm works, we shall use it to compute (<i>AG</i>)<span class="s181">+</span><span class="s15"> </span>with the functional dependencies deﬁned in Section 7.4.1. We start with <i>result </i><span class="s15">= </span><i>AG</i>. The ﬁrst time that we execute the <b>repeat </b>loop to test each functional dependency, we ﬁnd that:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 139pt;text-indent: -16pt;line-height: 72%;text-align: left;"><span class="s39">• </span>A <span class="s86">→ </span>B <span class="p">causes us to include </span>B <span class="p">in </span>result<span class="p">. To see this fact, we observe that </span>A <span class="s86">→ </span>B <span class="p">is in </span>F <span class="p">, </span>A <span class="s83">⊆ </span>result <span class="p">(which is </span>AG<span class="p">), so </span>result <span class="p">:</span><span class="s15">= </span>result <span class="s15">∪</span>B<span class="p">.</span></p><p class="s13" style="padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span>A <span class="s86">→ </span>C <span class="p">causes </span>result <span class="p">to become </span>ABCG<span class="p">.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span>CG <span class="s86">→ </span>H <span class="p">causes </span>result <span class="p">to become </span>ABCGH <span class="p">.</span></p><p class="s13" style="padding-top: 1pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span>CG <span class="s86">→ </span>I <span class="p">causes </span>result <span class="p">to become </span>ABCGHI <span class="p">.</span></p><p style="padding-top: 10pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">The second time that we execute the <b>repeat </b>loop, no new attributes are added to <i>result</i>, and the algorithm terminates.</p><p class="s15" style="padding-top: 2pt;padding-left: 119pt;text-indent: 17pt;line-height: 79%;text-align: justify;"><span class="p">Let us see why the algorithm of Figure 7.8 is correct. The ﬁrst step is correct be- cause </span>α <span class="s86">→ </span>α <span class="p">always holds (by the reﬂexivity rule). We claim that, for any subset </span>β <span class="p">of </span><span class="s13">result</span><span class="p">, </span>α <span class="s86">→ </span>β<span class="p">. Since we start the </span><span class="s46">repeat </span><span class="p">loop with </span>α <span class="s86">→ </span><span class="s13">result </span><span class="p">being true, we can add </span>γ <span class="p">to </span><span class="s13">result </span><span class="p">only if </span>β <span class="s83">⊆ </span><span class="s13">result </span><span class="p">and </span>β <span class="s86">→ </span>γ<span class="p">. But then </span><span class="s13">result </span><span class="s86">→ </span>β <span class="p">by the reﬂexivity rule, so </span>α <span class="s86">→ </span>β</p><p class="s15" style="padding-left: 119pt;text-indent: 0pt;line-height: 9pt;text-align: justify;"><span class="p">by transitivity. Another application of transitivity shows that </span>α <span class="s86">→ </span>γ <span class="p">(using </span>α <span class="s86">→ </span>β <span class="p">and</span></p><p class="s15" style="padding-left: 119pt;text-indent: 0pt;line-height: 86%;text-align: justify;">β <span class="s86">→ </span>γ<span class="p">). The union rule implies that </span>α <span class="s86">→ </span><span class="s13">result </span>∪ γ<span class="p">, so </span>α <span class="p">functionally determines any new result generated in the </span><span class="s46">repeat </span><span class="p">loop. Thus, any attribute returned by the algorithm</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">is in <span class="s15">α</span><span class="s239">+</span>.</p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 92%;text-align: justify;">It is easy to see that the algorithm ﬁnds all of <span class="s15">α</span><span class="s239">+</span>. Consider an attribute <i>A </i>in <span class="s15">α</span><span class="s239">+ </span>that is not yet in <i>result </i>at any point during the execution. There must be a way to prove that <i>result </i><span class="s86">→ </span><i>A </i>using the axioms. Either <i>result </i><span class="s86">→ </span><i>A </i>is in <i>F </i>itself (making the proof trivial and ensuring <i>A </i>is added to <i>result</i>) or there must a proof step using transitivity to show</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_1982.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 197pt;text-indent: 0pt;text-align: left;"><i>result </i>:<span class="s15">= α</span>;</p><p class="s46" style="padding-left: 197pt;text-indent: 0pt;line-height: 12pt;text-align: left;">repeat</p><p class="s46" style="padding-left: 231pt;text-indent: -11pt;line-height: 86%;text-align: left;">for each <span class="p">functional dependency </span><span class="s15">β </span><span class="s86">→ </span><span class="s15">γ </span>in <i>F </i>do begin</p><p class="s13" style="padding-left: 246pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><b>if </b><span class="s15">β </span><span class="s83">⊆ </span>result <b>then </b>result <span class="p">:</span><span class="s15">= </span>result <span class="s15">∪ γ</span><span class="p">;</span></p><p class="s46" style="padding-left: 78pt;text-indent: 0pt;line-height: 12pt;text-align: center;">end</p><p style="padding-left: 32pt;text-indent: 0pt;text-align: center;"><b>until </b>(<i>result </i>does not change)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_1983.png"/></span></p><p class="s74" style="padding-top: 8pt;padding-left: 161pt;text-indent: 0pt;text-align: left;"><span class="s73">Figure 7.8 </span>An algorithm to compute <span class="s112">α</span><span class="s240">+</span>, the closure of <span class="s112">α </span>under <span class="s91">F </span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;line-height: 81%;text-align: justify;"><span class="p">for some attribute </span>B <span class="p">that </span>result <span class="s86">→ </span>B<span class="p">. If it happens that </span>A <span class="s15">= </span>B<span class="p">, then we have shown that </span>A <span class="p">is added to </span>result<span class="p">. If not, </span>B <span class="s86">≠ </span>A <span class="p">is added. Then repeating this argument, we see that </span>A <span class="p">must eventually be added to </span>result<span class="p">.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">It turns out that, in the worst case, this algorithm may take an amount of time quadratic in the size of <i>F </i>. There is a faster (although slightly more complex) algorithm that runs in time linear in the size of <i>F </i>; that algorithm is presented as part of Practice Exercise 7.8.</p><p style="padding-left: 106pt;text-indent: 0pt;text-align: justify;">There are several uses of the attribute closure algorithm:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="padding-left: 91pt;text-indent: 0pt;line-height: 15pt;text-align: left;"><span class="s39">• </span><span class="s40">To test if </span>α <span class="p">is a superkey, we compute </span>α<span class="s239">+ </span><span class="p">and check if </span>α<span class="s239">+ </span><span class="p">contains all attributes in</span></p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;line-height: 13pt;text-align: left;">R<span class="p">.</span></p><p class="s15" style="padding-top: 7pt;padding-left: 107pt;text-indent: -16pt;line-height: 71%;text-align: justify;"><span class="s39">• </span><span class="s40">We can check if a functional dependency </span>α <span class="s86">→ </span>β <span class="p">holds (or, in other words, is in </span><span class="s13">F </span><span class="s181">+</span><span class="p">), by checking if </span>β <span class="s83">⊆ </span>α<span class="s239">+</span><span class="p">. That is, we compute </span>α<span class="s239">+ </span><span class="p">by using attribute closure, and then check if it contains </span>β<span class="p">. This test is particularly useful, as we shall see later in</span></p><p style="padding-left: 107pt;text-indent: 0pt;text-align: justify;">this chapter.</p><p class="s13" style="padding-top: 3pt;padding-left: 91pt;text-indent: 0pt;line-height: 17pt;text-align: left;"><span class="s39">• </span><span class="s40">It gives us an alternative way to compute </span>F <span class="s181">+</span><span class="p">: For each </span><span class="s15">γ </span><span class="s83">⊆ </span>R<span class="p">, we ﬁnd the closure</span></p><p class="s15" style="padding-left: 107pt;text-indent: 0pt;line-height: 17pt;text-align: left;">γ<span class="s239">+</span><span class="p">, and for each </span><span class="s13">S </span><span class="s83">⊆ </span>γ<span class="s239">+</span><span class="p">, we output a functional dependency </span>γ <span class="s86">→ </span><span class="s13">S</span><span class="p">.</span></p><p class="s68" style="padding-top: 13pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">7.4.3 Canonical Cover</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Suppose that we have a set of functional dependencies <i>F </i>on a relation schema. When- ever a user performs an update on the relation, the database system must ensure that the update does not violate any functional dependencies, that is, all the functional de- pendencies in <i>F </i>are satisﬁed in the new database state.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">The system must roll back the update if it violates any functional dependencies in the set <i>F </i>.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">We can reduce the eﬀort spent in checking for violations by testing a simpliﬁed set of functional dependencies that has the same closure as the given set. Any database that satisﬁes the simpliﬁed set of functional dependencies also satisﬁes the original set, and vice versa, since the two sets have the same closure. However, the simpliﬁed set is easier to test. We shall see how the simpliﬁed set can be constructed in a moment. First, we need some deﬁnitions.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">An attribute of a functional dependency is said to be <b>extraneous </b>if we can remove it without changing the closure of the set of functional dependencies.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 107pt;text-indent: -16pt;line-height: 83%;text-align: justify;"><span class="s39">• </span><span class="s40">Removing an attribute from the left side of a functional dependency could make it a stronger constraint. For example, if we have </span>AB <span class="s86">→ </span>C <span class="p">and remove </span>B<span class="p">, we get the possibly stronger result </span>A <span class="s86">→ </span>C<span class="p">. It may be stronger because </span>A <span class="s86">→ </span>C <span class="p">logically implies </span>AB <span class="s86">→ </span>C<span class="p">, but </span>AB <span class="s86">→ </span>C <span class="p">does not, on its own, logically imply </span>A <span class="s86">→ </span>C<span class="p">. But, depending on what our set </span>F <span class="p">of functional dependencies happens to be, we may be able to remove </span>B <span class="p">from </span>AB <span class="s86">→ </span>C <span class="p">safely. For example, suppose that the set</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 139pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">F <span class="s15">= {</span>AB <span class="s86">→ </span>C<span class="p">, </span>A <span class="s86">→ </span>D<span class="p">, </span>D <span class="s86">→ </span>C<span class="s15">}</span><span class="p">. Then we can show that </span>F <span class="p">logically implies</span></p><p class="s13" style="padding-left: 139pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">A <span class="s86">→ </span>C<span class="p">, making </span>B <span class="p">extraneous in </span>AB <span class="s86">→ </span>C<span class="p">.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;line-height: 78%;text-align: justify;"><span class="s39">• </span><span class="s40">Removing an attribute from the right side of a functional dependency could make it a weaker constraint. For example, if we have </span>AB <span class="s86">→ </span>CD <span class="p">and remove </span>C<span class="p">, we get the possibly weaker result </span>AB <span class="s86">→ </span>D<span class="p">. It may be weaker because using just </span>AB <span class="s86">→ </span>D<span class="p">, we can no longer infer </span>AB <span class="s86">→ </span>C<span class="p">. But, depending on what our set </span>F <span class="p">of functional dependencies happens to be, we may be able to remove </span>C <span class="p">from </span>AB <span class="s86">→ </span>CD <span class="p">safely. For example, suppose that </span>F <span class="s15">= {</span>AB <span class="s86">→ </span>CD<span class="p">, </span>A <span class="s86">→ </span>C<span class="s15">}</span><span class="p">. Then we can show that even after replacing </span>AB <span class="s86">→ </span>CD <span class="p">by </span>AB <span class="s86">→ </span>D<span class="p">, we can still infer </span>AB <span class="s86">→ </span>C <span class="p">and thus </span>AB <span class="s86">→ </span>CD<span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;line-height: 89%;text-align: left;">The formal deﬁnition of <span class="s63">extraneous attributes </span>is as follows: Consider a set <i>F </i>of functional dependencies and the functional dependency <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>in <i>F </i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 139pt;text-indent: -16pt;line-height: 86%;text-align: justify;"><span class="s39">• </span><b>Removal from the left side: </b>Attribute <i>A </i>is extraneous in <span class="s15">α </span>if <i>A </i><span class="s15">∈ α </span>and <i>F </i>logically implies (<i>F </i><span class="s15">− {α </span><span class="s86">→ </span><span class="s15">β}</span>) <span class="s15">∪ {</span>(<span class="s15">α − </span><i>A</i>) <span class="s86">→ </span><span class="s15">β}</span>.</p><p style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;line-height: 86%;text-align: justify;"><span class="s39">• </span><b>Removal from the right side: </b>Attribute <i>A </i>is extraneous in <span class="s15">β </span>if <i>A </i><span class="s15">∈ β </span>and the set of functional dependencies (<i>F </i><span class="s15">− </span><span class="s95">{</span><span class="s15">α </span><span class="s86">→ </span><span class="s15">β</span><span class="s95">}</span>) <span class="s15">∪ {α </span><span class="s86">→ </span>(<span class="s15">β − </span><i>A</i>)<span class="s15">} </span>logically implies <i>F </i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: left;">Beware of the direction of the implications when using the deﬁnition of extraneous attributes: If you reverse the statement, the implication will <i>always </i>hold. That is, (<i>F </i><span class="s15">−</span></p><p class="s15" style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 77%;text-align: left;">{α <span class="s86">→ </span>β}<span class="p">) </span>∪ {<span class="p">(</span>α − <span class="s13">A</span><span class="p">) </span><span class="s86">→ </span>β} <span class="p">always logically implies </span><span class="s13">F </span><span class="p">, and also </span><span class="s13">F </span><span class="p">always logically implies (</span><span class="s13">F </span>− <span class="s95">{</span>α <span class="s86">→ </span>β<span class="s95">}</span><span class="p">) </span>∪ {α <span class="s86">→ </span><span class="p">(</span>β − <span class="s13">A</span><span class="p">)</span>}<span class="p">.</span></p><p style="padding-left: 137pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Here is how we can test eﬃciently if an attribute is extraneous. Let <i>R </i>be the relation</p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 0pt;line-height: 90%;text-align: left;">schema, and let <i>F </i>be the given set of functional dependencies that hold on <i>R</i>. Consider an attribute <i>A </i>in a dependency <span class="s15">α </span><span class="s86">→ </span><span class="s15">β</span>.</p><p class="s13" style="padding-top: 13pt;padding-left: 123pt;text-indent: 0pt;text-align: left;"><span class="s39">• </span><span class="s40">If </span>A <span class="s15">∈ β</span><span class="p">, to check if </span>A <span class="p">is extraneous, consider the set</span></p><p class="s15" style="padding-top: 3pt;padding-left: 26pt;text-indent: 0pt;text-align: center;"><span class="s13">F </span><span class="s181">′</span> = <span class="p">(</span><span class="s13">F </span>− <span class="s95">{</span>α <span class="s86">→ </span>β<span class="s95">}</span><span class="p">) </span>∪ {α <span class="s86">→ </span><span class="p">(</span>β − <span class="s13">A</span><span class="p">)</span>}</p><p style="padding-top: 2pt;padding-left: 139pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">and check if <span class="s15">α </span><span class="s86">→ </span><i>A </i>can be inferred from <i>F </i><span class="s181">′</span>. To do so, compute <span class="s15">α</span><span class="s239">+ </span>(the closure of</p><p style="padding-left: 139pt;text-indent: 0pt;line-height: 12pt;text-align: justify;"><span class="s15">α</span>) under <i>F </i><span class="s181">′</span>; if <span class="s15">α</span><span class="s239">+ </span>includes <i>A</i>, then <i>A </i>is extraneous in <span class="s15">β</span>.</p><p style="padding-top: 5pt;padding-left: 139pt;text-indent: -16pt;line-height: 90%;text-align: justify;"><span class="s39">• </span><span class="s40">If </span><i>A </i><span class="s15">∈ α</span>, to check if <i>A </i>is extraneous, let <span class="s15">γ = α − {</span><i>A</i><span class="s15">}</span>, and check if <span class="s15">γ </span><span class="s86">→ </span><span class="s15">β </span>can be inferred from <i>F </i>. To do so, compute <span class="s15">γ</span><span class="s239">+ </span>(the closure of <span class="s15">γ</span>) under <i>F </i>; if <span class="s15">γ</span><span class="s239">+ </span>includes all attributes in <span class="s15">β</span>, then <i>A </i>is extraneous in <span class="s15">α</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 119pt;text-indent: 17pt;line-height: 79%;text-align: justify;"><span class="p">For example, suppose </span>F <span class="p">contains </span>AB <span class="s86">→ </span>CD<span class="p">, </span>A <span class="s86">→ </span>E<span class="p">, and </span>E <span class="s86">→ </span>C<span class="p">. To check if </span>C <span class="p">is extraneous in </span>AB <span class="s86">→ </span>CD<span class="p">, we compute the attribute closure of </span>AB <span class="p">under </span>F <span class="s181">′</span><span class="s15"> = {</span>AB <span class="s86">→ </span>D<span class="p">, </span>A <span class="s86">→ </span>E<span class="p">, </span>E <span class="s86">→ </span>C<span class="s15">}</span><span class="p">. The closure is </span>ABCDE<span class="p">, which includes </span>CD<span class="p">, so we infer that </span>C <span class="p">is extraneous.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 5pt;padding-left: 106pt;text-indent: 0pt;line-height: 14pt;text-align: left;">F<span class="s145">c </span><span class="s15">= </span>F</p><p class="s46" style="padding-left: 106pt;text-indent: 0pt;line-height: 12pt;text-align: left;">repeat</p><p style="padding-left: 128pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Use the union rule to replace any dependencies in <i>F</i><span class="s145">c </span>of the form</p><p class="s15" style="padding-left: 149pt;text-indent: 0pt;line-height: 13pt;text-align: left;">α<span class="s98">1</span><span class="p"> </span><span class="s86">→ </span>β<span class="s98">1</span><span class="p"> and </span>α<span class="s98">1</span><span class="p"> </span><span class="s86">→ </span>β<span class="s98">2</span><span class="p"> with </span>α<span class="s98">1</span><span class="p"> </span><span class="s86">→ </span>β<span class="s98">1</span><span class="p"> </span>β<span class="s98">2</span><span class="p">.</span></p><p style="padding-left: 149pt;text-indent: -21pt;line-height: 85%;text-align: left;">Find a functional dependency <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>in <i>F</i><span class="s97">c </span>with an extraneous attribute either in <span class="s15">α </span>or in <span class="s15">β</span>.</p><p style="padding-top: 2pt;padding-left: 128pt;text-indent: 21pt;line-height: 78%;text-align: left;">/* Note: the test for extraneous attributes is done using <i>F</i><span class="s97">c</span>, not <i>F </i>*/ If an extraneous attribute is found, delete it from <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>in <i>F</i><span class="s145">c</span>.</p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><b>until </b>(<i>F</i><span class="s145">c </span>does not change)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_1984.png"/></span></p><p class="s73" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 7.9 <span class="s74">Computing canonical cover.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Having deﬁned the concept of extraneous attributes, we can explain how we can construct a simpliﬁed set of functional dependencies equivalent to a given set of func- tional dependencies.</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 87%;text-align: justify;">A <span class="s63">canonical cover </span><i>F</i><span class="s97">c </span>for <i>F </i>is a set of dependencies such that <i>F </i>logically implies all dependencies in <i>F</i><span class="s97">c</span>, and <i>F</i><span class="s97">c </span>logically implies all dependencies in <i>F </i>. Furthermore, <i>F</i><span class="s97">c </span>must have the following properties:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 91pt;text-indent: 0pt;text-align: left;">• <span class="s40">No functional dependency in </span><span class="s13">F</span><span class="s145">c </span><span class="p">contains an extraneous attribute.</span></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;line-height: 78%;text-align: left;"><span class="s39">• </span><span class="s40">Each left side of a functional dependency in </span><i>F</i><span class="s97">c </span>is unique. That is, there are no two dependencies <span class="s15">α</span><span class="s98">1</span> <span class="s86">→ </span><span class="s15">β</span><span class="s98">1</span> and <span class="s15">α</span><span class="s98">2</span> <span class="s86">→ </span><span class="s15">β</span><span class="s98">2</span> in <i>F</i><span class="s97">c </span>such that <span class="s15">α</span><span class="s98">1</span> <span class="s15">= α</span><span class="s98">2</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 93%;text-align: justify;">A canonical cover for a set of functional dependencies <i>F </i>can be computed as de- scribed in Figure 7.9. It is important to note that when checking if an attribute is extra- neous, the check uses the dependencies in the current value of <i>F</i><span class="s145">c</span>, and <b>not </b>the depen- dencies in <i>F </i>. If a functional dependency contains only one attribute in its right-hand side, for example <i>A </i><span class="s86">→ </span><i>C</i>, and that attribute is found to be extraneous, we would get a functional dependency with an empty right-hand side. Such functional dependencies</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">should be deleted.</p><p style="padding-top: 1pt;padding-left: 88pt;text-indent: 17pt;line-height: 92%;text-align: justify;">Since the algorithm permits a choice of any extraneous attribute, it is possible that there may be several possible canonical covers for a given <i>F </i>. Any such <i>F</i><span class="s145">c </span>is equally acceptable. Any canonical cover of <i>F </i>, <i>F</i><span class="s145">c</span>, can be shown to have the same closure as <i>F </i>; hence, testing whether <i>F</i><span class="s97">c </span>is satisﬁed is equivalent to testing whether <i>F </i>is satisﬁed. However, <i>F</i><span class="s97">c </span>is minimal in a certain sense— it does not contain extraneous attributes,</p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">and it combines functional dependencies with the same left side. It is cheaper to test</p><p class="s13" style="padding-left: 88pt;text-indent: 0pt;line-height: 14pt;text-align: justify;">F<span class="s97">c </span><span class="p">than it is to test </span>F <span class="p">itself.</span></p><p style="padding-left: 106pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">We now consider an example. Assume we are given the following set <i>F </i>of functional</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">dependencies on schema (<i>A</i>, <i>B</i>, <i>C</i>):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 2pt;padding-left: 289pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">A <span class="s86">→ </span>BC</p><p class="s13" style="padding-left: 289pt;text-indent: 0pt;line-height: 77%;text-align: justify;">B <span class="s86">→ </span>C A <span class="s86">→ </span>B AB <span class="s86">→ </span>C</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">Let us compute a canonical cover for <i>F </i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">There are two functional dependencies with the same set of attributes on the left side of the arrow:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 299pt;text-indent: 0pt;line-height: 15pt;text-align: left;">A <span class="s86">→ </span>BC</p><p class="s13" style="padding-left: 299pt;text-indent: 0pt;line-height: 15pt;text-align: left;">A <span class="s86">→ </span>B</p><p class="s13" style="padding-top: 10pt;padding-left: 139pt;text-indent: 0pt;text-align: justify;"><span class="p">We combine these functional dependencies into </span>A <span class="s86">→ </span>BC<span class="p">.</span></p><p class="s13" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;line-height: 81%;text-align: justify;"><span class="s39">• </span>A <span class="p">is extraneous in </span>AB <span class="s86">→ </span>C <span class="p">because </span>F <span class="p">logically implies (</span>F <span class="s15">− {</span>AB <span class="s86">→ </span>C<span class="s15">}</span><span class="p">) </span><span class="s15">∪ {</span>B <span class="s86">→ </span>C<span class="s15">}</span><span class="p">. This assertion is true because </span>B <span class="s86">→ </span>C <span class="p">is already in our set of functional depen- dencies.</span></p><p class="s13" style="padding-top: 4pt;padding-left: 123pt;text-indent: 0pt;line-height: 16pt;text-align: justify;"><span class="s39">• </span>C <span class="p">is extraneous in </span>A <span class="s86">→ </span>BC<span class="p">, since </span>A <span class="s86">→ </span>BC <span class="p">is logically implied by </span>A <span class="s86">→ </span>B <span class="p">and </span>B <span class="s86">→</span></p><p class="s13" style="padding-left: 139pt;text-indent: 0pt;line-height: 12pt;text-align: left;">C<span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">Thus, our canonical cover is:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 292pt;text-indent: 0pt;line-height: 76%;text-align: justify;">A <span class="s86">→ </span>B B <span class="s86">→ </span>C</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Given a set <i>F </i>of functional dependencies, it may be that an entire functional de- pendency in the set is extraneous, in the sense that dropping it does not change the closure of <i>F </i>. We can show that a canonical cover <i>F</i><span class="s145">c </span>of <i>F </i>contains no such extraneous functional dependency. Suppose that, to the contrary, there were such an extraneous functional dependency in <i>F</i><span class="s97">c</span>. The right-side attributes of the dependency would then</p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">be extraneous, which is not possible by the deﬁnition of canonical covers.</p><p class="s13" style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 84%;text-align: justify;"><span class="p">As we noted earlier, a canonical cover might not be unique. For instance, consider the set of functional dependencies </span>F <span class="s15">= {</span>A <span class="s86">→ </span>BC<span class="p">, </span>B <span class="s86">→ </span>AC<span class="p">, and </span>C <span class="s86">→ </span>AB<span class="s15">}</span><span class="p">. If we apply the test for extraneous attributes to </span>A <span class="s86">→ </span>BC<span class="p">, we ﬁnd that both </span>B <span class="p">and </span>C <span class="p">are extraneous under </span>F <span class="p">. However, it is incorrect to delete both! The algorithm for ﬁnding the canonical</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">cover picks one of the two and deletes it. Then,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 145pt;text-indent: -16pt;line-height: 79%;text-align: justify;"><span class="s63">1. </span><span class="p">If </span>C <span class="p">is deleted, we get the set </span>F <span class="s181">′</span><span class="s15"> = {</span>A <span class="s86">→ </span>B<span class="p">, </span>B <span class="s86">→ </span>AC<span class="p">, and </span>C <span class="s86">→ </span>AB<span class="s15">}</span><span class="p">. Now, </span>B <span class="p">is not extraneous on the right side of </span>A <span class="s86">→ </span>B <span class="p">under </span>F <span class="s181">′</span><span class="p">. Continuing the algorithm, we ﬁnd </span>A <span class="p">and </span>B <span class="p">are extraneous in the right side of </span>C <span class="s86">→ </span>AB<span class="p">, leading to two choices of canonical cover:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 191pt;text-indent: 0pt;text-align: left;">compute <i>F </i><span class="s181">+</span>;</p><p style="padding-top: 1pt;padding-left: 203pt;text-indent: -12pt;line-height: 90%;text-align: left;"><b>for each </b>schema <i>R</i><span class="s145">i </span>in <i>D </i><b>do begin</b></p><p style="padding-left: 218pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><i>F</i><span class="s145">i </span>: <span class="s15">= </span>the restriction of <i>F </i><span class="s181">+</span><span class="s15"> </span>to <i>R</i><span class="s145">i</span>;</p><p class="s46" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: center;">end</p><p class="s15" style="padding-left: 19pt;text-indent: 0pt;text-align: center;"><span class="s13">F </span><span class="s181">′</span> <span class="p">:</span>= ∅ </p><p class="s46" style="padding-top: 1pt;padding-left: 203pt;text-indent: -12pt;line-height: 87%;text-align: left;">for each <span class="p">restriction </span><i>F</i><span class="s97">i </span>do begin</p><p class="s13" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: center;">F <span class="s181">′</span><span class="s15"> = </span>F <span class="s181">′</span><span class="s15"> ∪ </span>F<span class="s97">i</span></p><p class="s46" style="padding-left: 203pt;text-indent: 0pt;line-height: 12pt;text-align: left;">end</p><p style="padding-left: 191pt;text-indent: 0pt;text-align: left;">compute <i>F </i><span class="s181">′+</span>;</p><p style="padding-left: 191pt;text-indent: 0pt;text-align: left;"><b>if </b>(<i>F </i><span class="s181">′+</span><span class="s15"> = </span><i>F </i><span class="s181">+</span>) <b>then </b>return (true)</p><p class="s46" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">else <span class="p">return (false);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="494" height="1" alt="image" src="Image_1985.png"/></span></p><p class="s73" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 7.10 <span class="s74">Testing for dependency preservation.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 217pt;text-indent: 0pt;line-height: 77%;text-align: left;">F<span class="s97">c </span><span class="s15">= {</span>A <span class="s86">→ </span>B<span class="p">, </span>B <span class="s86">→ </span>C<span class="p">, </span>C <span class="s86">→ </span>A<span class="s15">} </span>F<span class="s97">c </span><span class="s15">= {</span>A <span class="s86">→ </span>B<span class="p">, </span>B <span class="s86">→ </span>AC<span class="p">, </span>C <span class="s86">→ </span>B<span class="s15">}</span><span class="p">.</span></p><p class="s13" style="padding-top: 11pt;padding-left: 113pt;text-indent: -17pt;line-height: 93%;text-align: justify;"><span class="s63">2. </span><span class="p">If </span>B <span class="p">is deleted, we get the set </span><span class="s15">{</span>A <span class="s86">→ </span>C<span class="p">, </span>B <span class="s86">→ </span>AC<span class="p">, and </span>C <span class="s86">→ </span>AB<span class="s15">}</span><span class="p">. This case is symmetrical to the previous case, leading to two more choices of canonical cover:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 6pt;padding-left: 207pt;text-indent: 0pt;line-height: 77%;text-align: left;">F<span class="s145">c </span><span class="s15">= {</span>A <span class="s86">→ </span>C<span class="p">, </span>C <span class="s86">→ </span>B<span class="p">, and </span>B <span class="s86">→ </span>A<span class="s15">} </span>F<span class="s145">c </span><span class="s15">= {</span>A <span class="s86">→ </span>C<span class="p">, </span>B <span class="s86">→ </span>C<span class="p">, and </span>C <span class="s86">→ </span>AB<span class="s15">}</span><span class="p">.</span></p><p style="padding-top: 12pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">As an exercise, can you ﬁnd one more canonical cover for <i>F </i>?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">7.4.4 Dependency Preservation</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">Using the theory of functional dependencies, there is a way to describe dependency preservation that is simpler than the ad hoc approach we used in Section 7.3.1.2.</p><p style="padding-left: 88pt;text-indent: 17pt;line-height: 92%;text-align: justify;">Let <i>F </i>be a set of functional dependencies on a schema <i>R</i>, and let <i>R</i><span class="s98">1</span>, <i>R</i><span class="s98">2</span>, <span class="s15">… </span>, <i>R</i><span class="s145">n </span>be a decomposition of <i>R</i>. The <span class="s63">restriction of </span><span class="s92">F </span><span class="s63">to </span><span class="s92">R</span><span class="s241">i </span>is the set <i>F</i><span class="s145">i </span>of all functional dependencies in <i>F </i><span class="s181">+</span><span class="s15"> </span>that include <i>only </i>attributes of <i>R</i><span class="s145">i</span>. Since all functional dependencies in a restriction involve attributes of only one relation schema, it is possible to test such a dependency for satisfaction by checking only one relation.</p><p class="s13" style="padding-top: 2pt;padding-left: 88pt;text-indent: 17pt;line-height: 84%;text-align: justify;"><span class="p">Note that the deﬁnition of restriction uses all dependencies in </span>F <span class="s181">+</span><span class="p">, not just those in </span>F <span class="p">. For instance, suppose </span>F <span class="s15">= {</span>A <span class="s86">→ </span>B<span class="p">, </span>B <span class="s86">→ </span>C<span class="s15">}</span><span class="p">, and we have a decomposition into </span>AC <span class="p">and </span>AB<span class="p">. The restriction of </span>F <span class="p">to </span>AC <span class="p">includes </span>A <span class="s86">→ </span>C<span class="p">, since </span>A <span class="s86">→ </span>C <span class="p">is in </span>F <span class="s181">+</span><span class="p">, even though it is not in </span>F <span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 7pt;padding-left: 119pt;text-indent: 17pt;line-height: 85%;text-align: justify;"><span class="p">The set of restrictions </span>F<span class="s98">1</span><span class="p">, </span>F<span class="s98">2</span><span class="p">, </span><span class="s15">… </span><span class="p">, </span>F<span class="s145">n </span><span class="p">is the set of dependencies that can be checked eﬃciently. We now must ask whether testing only the restrictions is suﬃcient. Let </span>F <span class="s181">′</span><span class="s15"> = </span>F<span class="s130">1 </span><span class="s15">∪ </span>F<span class="s130">2 </span><span class="s15">∪ </span><span class="s86">⋯ </span><span class="s15">∪ </span>F<span class="s97">n</span><span class="p">. </span>F <span class="s181">′</span><span class="s15"> </span><span class="p">is a set of functional dependencies on schema </span>R<span class="p">, but, in general, </span>F <span class="s181">′</span><span class="s15"> </span><span class="s86">≠ </span>F <span class="p">. However, even if </span>F <span class="s181">′</span><span class="s15"> </span><span class="s86">≠ </span>F <span class="p">, it may be that </span>F <span class="s181">′+</span><span class="s15"> = </span>F <span class="s181">+</span><span class="p">. If the latter is true, then every dependency in </span>F <span class="p">is logically implied by </span>F <span class="s181">′</span><span class="p">, and, if we verify that </span>F <span class="s181">′</span><span class="s15"> </span><span class="p">is satisﬁed,</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">we have veriﬁed that <i>F </i>is satisﬁed. We say that a decomposition having the property</p><p class="s13" style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">F <span class="s181">′+</span><span class="s15"> = </span>F <span class="s181">+</span><span class="s15"> </span><span class="p">is a </span><span class="s63">dependency-preserving decomposition</span><span class="p">.</span></p><p style="padding-top: 1pt;padding-left: 119pt;text-indent: 17pt;line-height: 92%;text-align: justify;">Figure 7.10 shows an algorithm for testing dependency preservation. The input is a set <i>D </i><span class="s15">= </span><span class="s95">{</span><i>R</i><span class="s98">1</span>, <i>R</i><span class="s98">2</span>, <span class="s15">… </span>, <i>R</i><span class="s97">n</span><span class="s95">} </span>of decomposed relation schemas, and a set <i>F </i>of functional dependencies. This algorithm is expensive since it requires computation of <i>F </i><span class="s181">+</span>. Instead</p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">of applying the algorithm of Figure 7.10, we consider two alternatives.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">First, note that if each member of <i>F </i>can be tested on one of the relations of the decomposition, then the decomposition is dependency preserving. This is an easy way to show dependency preservation; however, it does not always work. There are cases where, even though the decomposition is dependency preserving, there is a dependency in <i>F </i>that cannot be tested in any one relation in the decomposition. Thus, this alter- native test can be used only as a suﬃcient condition that is easy to check; if it fails we cannot conclude that the decomposition is not dependency preserving; instead we will have to apply the general test.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">We now give a second alternative test for dependency preservation that avoids computing <i>F </i><span class="s181">+</span>. We explain the intuition behind the test after presenting the test. The test applies the following procedure to each <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>in <i>F </i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 224pt;text-indent: 0pt;text-align: left;">result <span class="p">= </span><span class="s15">α</span></p><p class="s46" style="padding-left: 224pt;text-indent: 0pt;text-align: left;">repeat</p><p class="s46" style="padding-left: 245pt;text-indent: 0pt;line-height: 14pt;text-align: left;">for each <i>R</i><span class="s97">i </span><span class="p">in the decomposition</span></p><p class="s13" style="padding-left: 266pt;text-indent: 0pt;line-height: 86%;text-align: left;">t <span class="p">= (</span>result <span class="s15">∩ </span>R<span class="s97">i</span><span class="p">)</span><span class="s181">+</span><span class="s15"> ∩ </span>R<span class="s97">i </span>result <span class="p">= </span>result <span class="s15">∪ </span>t</p><p style="padding-left: 224pt;text-indent: 0pt;text-align: left;"><b>until </b>(<i>result </i>does not change)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;line-height: 92%;text-align: justify;">The attribute closure here is under the set of functional dependencies <i>F </i>. If <i>result </i>con- tains all attributes in <span class="s15">β</span>, then the functional dependency <span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>is preserved. The de- composition is dependency preserving if and only if the procedure shows that all the dependencies in <i>F </i>are preserved.</p><p style="padding-left: 137pt;text-indent: 0pt;text-align: justify;">The two key ideas behind the preceding test are as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 139pt;text-indent: -16pt;line-height: 92%;text-align: justify;"><span class="s39">• </span><span class="s40">The ﬁrst idea is to test each functional dependency </span><span class="s15">α </span><span class="s86">→ </span><span class="s15">β </span>in <i>F </i>to see if it is preserved in <i>F </i><span class="s181">′</span><span class="s15"> </span>(where <i>F </i><span class="s181">′</span><span class="s15"> </span>is as deﬁned in Figure 7.10). To do so, we compute the closure of <span class="s15">α </span>under <i>F </i><span class="s181">′</span>; the dependency is preserved exactly when the closure</p><p style="padding-left: 139pt;text-indent: 0pt;text-align: justify;">includes <span class="s15">β</span>. The decomposition is dependency preserving if (and only if) all the dependencies in <i>F </i>are found to be preserved.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><a name="bookmark138"><span class="s39">• </span></a><span class="s40">The second idea is to use a modiﬁed form of the attribute-closure algorithm to compute closure under </span>F <span class="s181">′</span><span class="p">, without actually ﬁrst computing </span>F <span class="s181">′</span><span class="p">. We wish to avoid computing </span>F <span class="s181">′</span><span class="s15"> </span><span class="p">since computing it is quite expensive. Note that </span>F <span class="s181">′</span><span class="s15"> </span><span class="p">is the union of all </span>F<span class="s97">i</span><span class="p">, where </span>F<span class="s97">i </span><span class="p">is the restriction of </span>F <span class="p">on </span>R<span class="s97">i</span><span class="p">. The algorithm computes the attribute</span><a name="bookmark166">&zwnj;</a></p><p class="s13" style="padding-left: 107pt;text-indent: 0pt;line-height: 78%;text-align: justify;"><span class="p">closure of (</span>result <span class="s15">∩ </span>R<span class="s97">i</span><span class="p">) with respect to </span>F <span class="p">, intersects the closure with </span>R<span class="s97">i</span><span class="p">, and adds the</span></p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">resultant set of attributes to <i>result</i>; this sequence of steps is equivalent to computing</p><p style="padding-left: 107pt;text-indent: 0pt;line-height: 89%;text-align: justify;">the closure of <i>result </i>under <i>F</i><span class="s145">i</span>. Repeating this step for each <i>i </i>inside the while loop gives the closure of <i>result </i>under <i>F </i><span class="s181">′</span>.</p><p class="s15" style="padding-top: 2pt;padding-left: 107pt;text-indent: 9pt;line-height: 76%;text-align: justify;"><span class="p">To understand why this modiﬁed attribute-closure approach works correctly, we note that for any </span>γ <span class="s83">⊆ </span><span class="s13">R</span><span class="s97">i</span><span class="p">, </span>γ <span class="s86">→ </span>γ<span class="s239">+ </span><span class="p">is a functional dependency in </span><span class="s13">F </span><span class="s181">+</span><span class="p">, and </span>γ <span class="s86">→ </span>γ<span class="s239">+ </span>∩<span class="s13">R</span><span class="s97">i </span><span class="p">is a functional dependency that is in </span><span class="s13">F</span><span class="s97">i</span><span class="p">, the restriction of </span><span class="s13">F </span><span class="s181">+</span> <span class="p">to </span><span class="s13">R</span><span class="s97">i</span><span class="p">. Conversely, if </span>γ <span class="s86">→ </span>δ <span class="p">were in </span><span class="s13">F</span><span class="s97">i</span><span class="p">, then </span>δ <span class="p">would be a subset of </span>γ<span class="s239">+ </span>∩ <span class="s13">R</span><span class="s97">i</span><span class="p">.</span></p><p style="padding-top: 11pt;padding-left: 88pt;text-indent: 17pt;text-align: left;">This test takes polynomial time, instead of the exponential time required to com- pute <i>F </i><span class="s181">+</span>.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part154.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part156.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
