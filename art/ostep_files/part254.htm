<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Page Clustering</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part253.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part255.htm">下一个 &gt;</a></p><p class="s32" style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Page Clustering</p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 89%;text-align: justify;">Another optimization used in VMS also helps overcome the small page size in VMS. Specifically, with such small pages, disk I/O during swap- ping could be highly inefficient, as disks do better with large transfers. To make swapping I/O more efficient, VMS adds a number of optimiza- tions, but most important is <b>clustering</b>. With clustering, VMS groups large batches of pages together from the global dirty list, and writes them to disk in one fell swoop (thus making them clean). Clustering is used in most modern systems, as the freedom to place pages anywhere within swap space lets the OS group pages, perform fewer and bigger writes, and thus improve performance.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 6pt;padding-left: 75pt;text-indent: 0pt;line-height: 11pt;text-align: left;"><span class="p">A</span><span class="s7">SIDE</span><span class="p">: </span>E<span class="s45">MULATING </span>R<span class="s45">EFERENCE </span>B<span class="s45">ITS</span></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">As it turns out, you don’t need a hardware reference bit in order to get some notion of which pages are in use in a system. In fact, in the early 1980’s, Babaoglu and Joy showed that protection bits on the VAX can be used to emulate reference bits [BJ81]. The basic idea: if you want to gain some understanding of which pages are actively being used in a system, mark all of the pages in the page table as inaccessible (but keep around the information as to which pages are really accessible by the process, perhaps in the “reserved OS field” portion of the page table entry). When a process accesses a page, it will generate a trap into the OS; the OS will then check if the page really should be accessible, and if so, revert the page to its normal protections (e.g., read-only, or read-write). At the time of a replacement, the OS can check which pages remain marked inacces- sible, and thus get an idea of which pages have not been recently used.</p><p style="padding-top: 2pt;padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The key to this “emulation” of reference bits is reducing overhead while still obtaining a good idea of page usage. The OS must not be too aggres- sive in marking pages inaccessible, or overhead would be too high. The OS also must not be too passive in such marking, or all pages will end up referenced; the OS will again have no good idea which page to evict.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part253.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part255.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
