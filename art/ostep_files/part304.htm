<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>29.3 Concurrent Queues</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part303.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part305.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">29.3 Concurrent Queues</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">As you know by now, there is always a standard method to make a concurrent data structure: add a big lock. For a queue, we’ll skip that approach, assuming you can figure it out.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Instead, we’ll take a look at a slightly more concurrent queue designed by Michael and Scott [MS98]. The data structures and code used for this queue are found in Figure <span style=" color: #00AEEF;">29.8 </span>on the following page.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">If you study this code carefully, you’ll notice that there are two locks, one for the head of the queue, and one for the tail. The goal of these two locks is to enable concurrency of enqueue and dequeue operations. In the common case, the enqueue routine will only access the tail lock, and dequeue only the head lock.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">One trick used by the Michael and Scott is to add a dummy node (allo- cated in the queue initialization code); this dummy enables the separation of head and tail operations. Study the code, or better yet, type it in, run it, and measure it, to understand how it works deeply.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">Queues are commonly used in multi-threaded applications. However, the type of queue used here (with just locks) often does not completely meet the needs of such programs. A more fully developed bounded queue, that enables a thread to wait if the queue is either empty or overly full, is the subject of our intense study in the next chapter on condition variables. Watch for it!</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s38" style="padding-top: 5pt;padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">1  </span>typedef struct <span class="s75">&nbsp;</span>node_t {</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;text-align: left;">2     <span class="s38">int       value;</span></p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">3     </span>struct <span class="s75">&nbsp; </span>node_t  <span class="s39">*</span>next;</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">4  <span class="s38">} node_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">5</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;text-align: left;"><span class="s37">6  </span>typedef struct <span class="s75">&nbsp;</span>queue_t {</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">7     </span>node_t     <span class="s39">*</span>head;</p><p class="s38" style="padding-left: 54pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">8     </span>node_t     <span class="s39">*</span>tail;</p><p class="s37" style="padding-left: 54pt;text-indent: 0pt;line-height: 7pt;text-align: left;">9     <span class="s38">pthread_mutex_t  headLock;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">10     <span class="s38">pthread_mutex_t  tailLock;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">11  <span class="s38">} queue_t;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">12</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">13  </span>void Queue_Init(queue_t <span class="s39">*</span>q) {</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 85%;text-align: left;"><span class="s37">14    </span>node_t <span class="s39">*</span>tmp = malloc(sizeof(node_t));</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">15    <span class="s38">tmp-&gt;next = NULL;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">16    <span class="s38">q-&gt;head = q-&gt;tail = tmp;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">17    <span class="s38">pthread_mutex_init(&amp;q-&gt;headLock, NULL);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">18    <span class="s38">pthread_mutex_init(&amp;q-&gt;tailLock, NULL);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">19  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">20</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">21  </span>void Queue_Enqueue(queue_t <span class="s39">*</span>q, int value) {</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 83%;text-align: left;"><span class="s37">22    </span>node_t <span class="s39">*</span>tmp = malloc(sizeof(node_t));</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;line-height: 7pt;text-align: left;">23    <span class="s38">assert(tmp != NULL);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">24    <span class="s38">tmp-&gt;value = value;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">25    <span class="s38">tmp-&gt;next = NULL;</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">26</p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">27    <span class="s38">pthread_mutex_lock(&amp;q-&gt;tailLock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">28    <span class="s38">q-&gt;tail-&gt;next = tmp;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">29    <span class="s38">q-&gt;tail = tmp;</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">30    <span class="s38">pthread_mutex_unlock(&amp;q-&gt;tailLock);</span></p><p class="s37" style="padding-left: 52pt;text-indent: 0pt;text-align: left;">31  <span class="s38">}</span></p><p class="s37" style="padding-top: 1pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">32</p><p class="s38" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s37">33  </span>int Queue_Dequeue(queue_t <span class="s39">*</span>q, int <span class="s39">*</span>value) {</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;line-height: 8pt;text-align: left;">34    <span class="s38">pthread_mutex_lock(&amp;q-&gt;headLock);</span></p><p class="s38" style="padding-left: 51pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><span class="s37">35    </span>node_t <span class="s39">*</span>tmp = q-&gt;head;</p><p class="s38" style="padding-left: 51pt;text-indent: 0pt;line-height: 85%;text-align: left;"><span class="s37">36    </span>node_t <span class="s39">*</span>newHead = tmp-&gt;next;</p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;line-height: 7pt;text-align: left;">37    <span class="s38">if (newHead == NULL) {</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">38       <span class="s38">pthread_mutex_unlock(&amp;q-&gt;headLock);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">39       <span class="s38">return -1; // queue was empty</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">40    <span class="s38">}</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;line-height: 9pt;text-align: left;">41    <span class="s39">*</span><span class="s38">value = newHead-&gt;value;</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;line-height: 8pt;text-align: left;">42    <span class="s38">q-&gt;head = newHead;</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">43    <span class="s38">pthread_mutex_unlock(&amp;q-&gt;headLock);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">44    <span class="s38">free(tmp);</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">45    <span class="s38">return 0;</span></p><p class="s37" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">46  <span class="s38">}</span></p><p style="padding-left: 112pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Figure 29.8: <b>Michael and Scott Concurrent Queue</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part303.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part305.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
