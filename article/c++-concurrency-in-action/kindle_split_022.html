<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mbp="Kindle">
  <head>
    <title>C++ Concurrency in Action, Second Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="part" id="app01">Appendix A. <a id="app01__title" class="calibre3"></a>Brief reference for some C++11 language features
      </h2>
      
      
      
      <p class="noind"><a id="iddle1854" class="calibre4"></a><a id="iddle1874" class="calibre4"></a>The new C++ Standard brings more than just concurrency support; there are a host of other language features and new libraries
         as well. In this appendix I give a brief overview of the new language features that are used in the Thread Library and the
         rest of the book. Aside from <kbd class="calibre17">thread_local</kbd> (which is covered in <a href="#app01lev1sec8" class="calibre4">section A.8</a>), none of them are directly related to concurrency, though they are important and/or useful for multithreaded code. I’ve
         limited this list to those that are either necessary (such as rvalue references) or serve to make the code simpler or easier
         to understand. Code that uses these features may be difficult to understand at first because of lack of familiarity, but as
         you become familiar with them, they should generally make code easier to understand. As the use of C++11 becomes more widespread,
         code making use of these features will become more common.
      </p>
      
      <p class="noind">Without further ado, let’s start by looking at <i class="calibre6">rvalue references</i>, which are used extensively by the Thread Library to facilitate the transfer of ownership (of threads, locks, or whatever)
         between objects.
      </p>
      
      
      <h3 id="app01lev1sec1" class="chapter"><a id="app01lev1sec1__title" class="calibre3"></a>A.1. Rvalue references
      </h3>
      
      <p class="noind">If you’ve been doing C++ programming for any time, you’ll be familiar with references; C++ references allow you to create
         a new name for an existing object. All accesses and modifications done through the new reference affect the original; for
         example:
      </p>
      
      <pre id="PLd0e38649" class="calibre5">int var=42;
int&amp; ref=var;         <b class="calibre24"><i class="calibre6">1</i></b>
ref=99;
assert(var==99);      <b class="calibre24"><i class="calibre6">2</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1573" class="calibre4"></a><a id="iddle1628" class="calibre4"></a><a id="iddle1856" class="calibre4"></a><a id="iddle1876" class="calibre4"></a><a id="iddle2407" class="calibre4"></a><b class="calibre24"><i class="calibre6">1</i> Create a reference to var.</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Original updated because of assignment to reference</b></li>
         
      </ul>
      
      <p class="noind">The only references that existed prior to C++11 are <i class="calibre6">lvalue references</i>—references to lvalues. The term <i class="calibre6">lvalue</i> comes from C and refers to things that can be on the left side of an assignment expression, named objects, objects allocated
         on the stack or heap, or members of other objects, all things with a defined storage location. The term <i class="calibre6">rvalue</i> also comes from C and refers to things that can occur only on the right side of an assignment expression—literals and temporaries,
         for example. Lvalue references can only be bound to lvalues, not rvalues. You can’t write
      </p>
      
      <pre id="PLd0e38726" class="calibre5">int&amp; i=42;    <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Won’t compile</b></li>
         
      </ul>
      
      <p class="noind">for example, because <kbd class="calibre17">42</kbd> is an rvalue. OK, that’s not quite true; you’ve always been able to bind an rvalue to a <kbd class="calibre17">const</kbd> lvalue reference:
      </p>
      
      <pre id="PLd0e38754" class="calibre5">int const&amp; i=42;</pre>
      
      <p class="noind">But this is a deliberate exception on the part of the standard, introduced before we had rvalue references in order to allow
         you to pass temporaries to functions taking references. This allows implicit conversions, so you can write things like this:
      </p>
      
      <pre id="PLd0e38763" class="calibre5">void print(std::string const&amp; s);
print("hello");                     <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Create temporary std::string object</b></li>
         
      </ul>
      
      <p class="noind">The C++11 Standard introduced <i class="calibre6">rvalue references</i>, which bind <i class="calibre6">only</i> to rvalues, not to lvalues, and are declared with two ampersands rather than one:
      </p>
      
      <pre id="PLd0e38791" class="calibre5">int&amp;&amp; i=42;
int j=42;
int&amp;&amp; k=j;      <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Won’t compile</b></li>
         
      </ul>
      
      <p class="noind">You can use function overloading to determine whether function parameters are lvalues or rvalues by having one overload take
         an lvalue reference and another take an rvalue reference. This is the cornerstone of <i class="calibre6">move semantics</i>.
      </p>
      
      
      <h4 id="app01lev2sec1" class="calibre23">A.1.1. <a id="app01lev2sec1__title" class="calibre4"></a>Move semantics
      </h4>
      
      <p class="noind">Rvalues are typically temporary and so can be freely modified; if you know that your function parameter is an rvalue, you
         can use it as temporary storage, or “steal” its contents without affecting program correctness. This means that rather than
         <i class="calibre6">copying</i> the contents of an rvalue parameter, you can <i class="calibre6">move</i> the contents. For large dynamic structures, <a id="iddle1216" class="calibre4"></a>this saves a lot of memory allocation and provides a lot of scope for optimization. Consider a function that takes an <kbd class="calibre17">std::vector&lt;int&gt;</kbd> as a parameter and needs to have an internal copy for modification, without touching the original. The old way of doing this
         would be to take the parameter as a <kbd class="calibre17">const</kbd> lvalue reference and make the copy internally:
      </p>
      
      <pre id="PLd0e38843" class="calibre5">void process_copy(std::vector&lt;int&gt; const&amp; vec_)
{
     std::vector&lt;int&gt; vec(vec_);
     vec.push_back(42);
}</pre>
      
      <p class="noind">This allows the function to take both lvalues and rvalues but forces the copy in every case. If you overload the function
         with a version that takes an rvalue reference, you can avoid the copy in the rvalue case, because you know you can freely
         modify the original:
      </p>
      
      <pre id="PLd0e38852" class="calibre5">void process_copy(std::vector&lt;int&gt; &amp;&amp; vec)
{
     vec.push_back(42);
}</pre>
      
      <p class="noind">Now, if the function in question is the constructor of your class, you can pilfer the innards of the rvalue and use them for
         your new instance. Consider the class in the following listing. In the default constructor it allocates a large chunk of memory,
         which is freed in the destructor.
      </p>
      
      
      
      <h5 class="notetitle" id="app01ex01">Listing A.1. <a id="app01ex01__title" class="calibre4"></a>A class with a move constructor
      </h5>
      <pre id="PLd0e38864" class="calibre5">class X
{
private:
    int* data;
public:
    X():
        data(new int[1000000])
    {}
    ~X()
    {
        delete [] data;
    }
    X(const X&amp; other):           <b class="calibre24"><i class="calibre6">1</i></b>
        data(new int[1000000])
    {
        std::copy(other.data,other.data+1000000,data);
    }
    X(X&amp;&amp; other):                <b class="calibre24"><i class="calibre6">2</i></b>
        data(other.data)
    {
        other.data=nullptr;
    }
};</pre>
      
      <p class="noind">The <i class="calibre6">copy constructor</i> <b class="calibre24"><i class="calibre6">1</i></b> is defined as you might expect: allocate a new block of memory and copy the data across. But you also have a new constructor
         that takes the old value by rvalue reference <b class="calibre24"><i class="calibre6">2</i></b>. This is the <i class="calibre6">move constructor</i>. In this case you copy the <i class="calibre6">pointer to</i> the data and leave the <kbd class="calibre17">other</kbd> instance with a null pointer, saving yourself a huge chunk of memory and time when creating variables from rvalues.
      </p>
      
      <p class="noind">For class <kbd class="calibre17">X</kbd> the move constructor is an optimization, but in some cases it makes sense to provide a move constructor even when it doesn’t
         make sense to provide a copy constructor. For example, the whole point of <kbd class="calibre17">std::unique_ptr&lt;&gt;</kbd> is that each non-null instance is the one and only pointer to its object, so a copy constructor makes no sense. But a move
         constructor allows ownership of the pointer to be transferred between instances and permits <kbd class="calibre17">std::unique_ptr&lt;&gt;</kbd> to be used as a function return value—the pointer is <i class="calibre6">moved</i> rather than <i class="calibre6">copied</i>.
      </p>
      
      <p class="noind">If you want to explicitly move from a named object that you know you’ll no longer use, you can cast it to an rvalue either
         by using <kbd class="calibre17">static_cast&lt;X&amp;&amp;&gt;</kbd> or by calling <kbd class="calibre17">std::move()</kbd>:
      </p>
      
      <pre id="PLd0e38929" class="calibre5">X x1;
X x2=std::move(x1);
X x3=static_cast&lt;X&amp;&amp;&gt;(x2);</pre>
      
      <p class="noind">This can be beneficial when you want to move the parameter value into a local or member variable without copying, because
         although an rvalue reference parameter can bind to rvalues, within the function it is treated as an lvalue:
      </p>
      
      <pre id="PLd0e38938" class="calibre5">void do_stuff(X&amp;&amp; x_)
{
    X a(x_);                 <b class="calibre24"><i class="calibre6">1</i></b>
    X b(std::move(x_));      <b class="calibre24"><i class="calibre6">2</i></b>
}
do_stuff(X());               <b class="calibre24"><i class="calibre6">3</i></b>
X x;
do_stuff(x);                 <b class="calibre24"><i class="calibre6">4</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Copies</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Moves</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">3</i> OK; rvalue binds to rvalue reference</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">4</i> Error; lvalue can’t bind to rvalue reference</b></li>
         
      </ul>
      
      <p class="noind">Move semantics are used extensively in the Thread Library, both where copies make no semantic sense but resources can be transferred,
         and as an optimization to avoid expensive copies where the source is going to be destroyed anyway. You saw an example of this
         in <a href="kindle_split_012.html#ch02lev1sec2" class="calibre4">section 2.2</a> where you used <kbd class="calibre17">std::move()</kbd> to transfer an <kbd class="calibre17">std::unique_ptr&lt;&gt;</kbd> instance into a newly constructed thread, and then again in <a href="kindle_split_012.html#ch02lev1sec3" class="calibre4">section 2.3</a> where we looked at transferring the ownership of threads between <kbd class="calibre17">std::thread</kbd> instances.
      </p>
      
      <p class="noind"><kbd class="calibre17">std::thread</kbd>, <kbd class="calibre17">std::unique_lock&lt;&gt;</kbd>, <kbd class="calibre17">std::future&lt;&gt;</kbd>, <kbd class="calibre17">std::promise&lt;&gt;</kbd>, and <kbd class="calibre17">std:: packaged_task&lt;&gt;</kbd> can’t be copied, but they all have move constructors to allow the associated resource to be transferred between instances
         and support their use as <a id="iddle1397" class="calibre4"></a><a id="iddle1400" class="calibre4"></a><a id="iddle1855" class="calibre4"></a><a id="iddle1875" class="calibre4"></a><a id="iddle2460" class="calibre4"></a>function return values. <kbd class="calibre17">std::string</kbd> and <kbd class="calibre17">std::vector&lt;&gt;</kbd> both can be copied as always, but they also have move constructors and move-assignment operators to avoid copying large quantities
         of data from an rvalue.
      </p>
      
      <p class="noind">The C++ Standard Library never does anything with an object that has been explicitly moved into another object, except destroy
         it or assign <i class="calibre6">to</i> it (either with a copy or, more likely, a move). But it’s good practice to ensure that the invariant of the class encompasses
         the moved-from state. An <kbd class="calibre17">std::thread</kbd> instance that has been used as the source of a move is equivalent to a default-constructed <kbd class="calibre17">std::thread</kbd> instance, for example, and an instance of <kbd class="calibre17">std::string</kbd> that has been used as the source of a move will still have a valid state, although no guarantees are made as to what that
         state is (in terms of how long the string is or what characters it contains).
      </p>
      
      
      
      <h4 id="app01lev2sec2" class="calibre23">A.1.2. <a id="app01lev2sec2__title" class="calibre4"></a>Rvalue references and function templates
      </h4>
      
      <p class="noind">There’s a final nuance when you use rvalue references for parameters to a function template: if the function parameter is
         an rvalue reference to a template parameter, automatic template argument type deduction deduces the type to be an lvalue reference
         if an lvalue is supplied or a plain unadorned type if an rvalue is supplied. That’s a bit of a mouthful, so let’s look at
         an example. Consider the following function:
      </p>
      
      <pre id="PLd0e39097" class="calibre5">template&lt;typename T&gt;
void foo(T&amp;&amp; t)
{}</pre>
      
      <p class="noind">If you call it with an rvalue as follows, then <kbd class="calibre17">T</kbd> is deduced to be the type of the value:
      </p>
      
      <pre id="PLd0e39109" class="calibre5">foo(42);              <b class="calibre24"><i class="calibre6">1</i></b>
foo(3.14159);         <b class="calibre24"><i class="calibre6">2</i></b>
foo(std::string());   <b class="calibre24"><i class="calibre6">3</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Calls foo&lt;int&gt;(42)</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Calls foo&lt;double&gt;(3.14159)</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">3</i> Calls foo&lt;std::string&gt;(std::string())</b></li>
         
      </ul>
      
      <p class="noind">But if you call <kbd class="calibre17">foo</kbd> with an lvalue, <kbd class="calibre17">T</kbd> is deduced to be an lvalue reference:
      </p>
      
      <pre id="PLd0e39159" class="calibre5">int i=42;
foo(i);       <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Calls foo&lt;int&amp;&gt;(i)</b></li>
         
      </ul>
      
      <p class="noind">Because the function parameter is declared as <kbd class="calibre17">T&amp;&amp;</kbd>, this is therefore a reference to a reference, which is treated as the original reference type. The signature of <kbd class="calibre17">foo&lt;int&amp;&gt;()</kbd> is
      </p>
      
      <pre id="PLd0e39187" class="calibre5">void foo&lt;int&amp;&gt;(int&amp; t);</pre>
      
      <p class="noind">This allows a single function template to accept both lvalue and rvalue parameters and is used by the <kbd class="calibre17">std::thread</kbd> constructor (<a href="kindle_split_012.html#ch02lev1sec1" class="calibre4">sections 2.1</a> and <a href="kindle_split_012.html#ch02lev1sec2" class="calibre4">2.2</a>) so that the supplied <a id="iddle1683" class="calibre4"></a>callable object can be moved into internal storage rather than copied if the parameter is an rvalue.
      </p>
      
      
      
      
      <h3 id="app01lev1sec2" class="chapter"><a id="app01lev1sec2__title" class="calibre3"></a>A.2. Deleted functions
      </h3>
      
      <p class="noind">Sometimes it doesn’t make sense to allow a class to be copied. <kbd class="calibre17">std::mutex</kbd> is a prime example of this—what would it mean if you did copy a mutex? <kbd class="calibre17">std::unique_lock&lt;&gt;</kbd> is another—an instance is the one and only owner of the lock it holds. To truly copy it would mean that the copy also held
         the lock, which doesn’t make sense. Moving ownership between instances, as described in <a href="#app01lev2sec2" class="calibre4">section A.1.2</a>, makes sense, but that’s not copying. I’m sure you’ve seen other examples.
      </p>
      
      <p class="noind">The standard idiom for preventing copies of a class used to be declaring the copy constructor and copy assignment operator
         private and then not providing an implementation. This would cause a compile error if any code outside the class in question
         tried to copy an instance and a link-time error (due to lack of an implementation) if any of the class’s member functions
         or friends tried to copy an instance:
      </p>
      
      <pre id="PLd0e39235" class="calibre5">class no_copies
{
public:
    no_copies(){}
private:
    no_copies(no_copies const&amp;);               <b class="calibre24"><i class="calibre6">1</i></b>
    no_copies&amp; operator=(no_copies const&amp;);    <b class="calibre24"><i class="calibre6">1</i></b>
};
no_copies a;
no_copies b(a);                                <b class="calibre24"><i class="calibre6">2</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> No implementation</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Won’t compile</b></li>
         
      </ul>
      
      <p class="noind">With C++11, the committee realized that this was a common idiom but also realized that it’s a bit of a hack. The committee
         therefore provided a more general mechanism that can be applied in other cases too: you can declare a function as <i class="calibre6">deleted</i> by adding <kbd class="calibre17">= delete</kbd> to the function declaration. <kbd class="calibre17">no_copies</kbd> can be written as
      </p>
      
      <pre id="PLd0e39281" class="calibre5">class no_copies
{
public:
    no_copies(){}
    no_copies(no_copies const&amp;) = delete;
    no_copies&amp; operator=(no_copies const&amp;) = delete;
};</pre>
      
      <p class="noind">This is much more descriptive than the original code and clearly expresses the intent. It also allows the compiler to give
         more descriptive error messages and moves the error from link time to compile time if you try to perform the copy within a
         member function of your class.
      </p>
      
      <p class="noind"><a id="iddle1295" class="calibre4"></a><a id="iddle1399" class="calibre4"></a><a id="iddle1800" class="calibre4"></a><a id="iddle1810" class="calibre4"></a><a id="iddle1814" class="calibre4"></a><a id="iddle2192" class="calibre4"></a>If, in addition to deleting the copy constructor and copy-assignment operator, you also explicitly write a move constructor
         and move-assignment operator, your class becomes move-only, the same as <kbd class="calibre17">std::thread</kbd> and <kbd class="calibre17">std::unique_lock&lt;&gt;</kbd>. The following listing shows an example of this move-only type.
      </p>
      
      
      
      <h5 class="notetitle" id="app01ex02">Listing A.2. <a id="app01ex02__title" class="calibre4"></a>A simple move-only type
      </h5>
      <pre id="PLd0e39336" class="calibre5">class move_only
{
    std::unique_ptr&lt;my_class&gt; data;
public:
    move_only(const move_only&amp;) = delete;
    move_only(move_only&amp;&amp; other):
        data(std::move(other.data))
    {}
    move_only&amp; operator=(const move_only&amp;) = delete;
    move_only&amp; operator=(move_only&amp;&amp; other)
    {
        data=std::move(other.data);
        return *this;
    }
};
move_only m1;
move_only m2(m1);               <b class="calibre24"><i class="calibre6">1</i></b>
move_only m3(std::move(m1));    <b class="calibre24"><i class="calibre6">2</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Error; copy constructor is declared deleted</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> OK; move constructor found</b></li>
         
      </ul>
      
      <p class="noind">Move-only objects can be passed as function parameters and returned from functions, but if you want to move from an lvalue,
         you always have to be explicit and use <kbd class="calibre17">std::move()</kbd> or a <kbd class="calibre17">static_cast&lt;T&amp;&amp;&gt;</kbd>.
      </p>
      
      <p class="noind">You can apply the <kbd class="calibre17">= delete</kbd> specifier to any function, not just copy constructors and assignment operators. This makes it clear that the function isn’t
         available. It does a bit more than that too, though; a deleted function participates in overload resolution in the normal
         way and only causes a compilation error if it’s selected. This can be used to remove specific overloads. For example, if your
         function takes a <kbd class="calibre17">short</kbd> parameter, you can prevent the narrowing of <kbd class="calibre17">int</kbd> values by writing an overload that takes an <kbd class="calibre17">int</kbd> and declaring it deleted:
      </p>
      
      <pre id="PLd0e39390" class="calibre5">void foo(short);
void foo(int) = delete;</pre>
      
      <p class="noind">Any attempts to call <kbd class="calibre17">foo</kbd> with an <kbd class="calibre17">int</kbd> will now be met with a compilation error, and the caller will have to explicitly cast supplied values to <kbd class="calibre17">short</kbd>:
      </p>
      
      <pre id="PLd0e39408" class="calibre5">foo(42);            <b class="calibre24"><i class="calibre6">1</i></b>
foo((short)42);     <b class="calibre24"><i class="calibre6">2</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Error; int overload declared deleted</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> OK</b></li>
         
      </ul>
      
      
      
      
      <h3 id="app01lev1sec3" class="chapter"><a id="app01lev1sec3__title" class="calibre3"></a>A.3. Defaulted functions
      </h3>
      
      <p class="noind"><a id="iddle1202" class="calibre4"></a>Whereas deleted functions allow you to explicitly declare that a function isn’t implemented, <i class="calibre6">defaulted</i> functions are the opposite extreme: they allow you to specify that the compiler should write the function for you, with its
         “default” implementation. You can only do this for functions that the compiler can autogenerate anyway: default constructors,
         destructors, copy constructors, move constructors, copy-assignment operators, and move-assignment operators.
      </p>
      
      <p class="noind">Why would you want to do that? There are several reasons why you might:</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">In order to change the accessibility of the function</i>—By default, the compiler-generated functions are <kbd class="calibre17">public</kbd>. If you want to make them <kbd class="calibre17">protected</kbd> or even <kbd class="calibre17">private</kbd>, you must write them yourself. By declaring them as defaulted, you can get the compiler to write the function <i class="calibre6">and</i> change the access level.
         </li>
         
         <li class="calibre22"><i class="calibre6">As documentation</i>—If the compiler-generated version is sufficient, it might be worth explicitly declaring it as such so that when you or someone
            else looks at the code later, it’s clear that this was intended.
         </li>
         
         <li class="calibre22"><i class="calibre6">In order to force the compiler to generate the function when it would not otherwise have done so</i>—This is typically done with default constructors, which are only normally compiler-generated if there are no user-defined
            constructors. If you need to define a custom copy constructor (for example), you can still get a compiler-generated default
            constructor by declaring it as defaulted.
         </li>
         
         <li class="calibre22"><i class="calibre6">In order to make a destructor virtual while leaving it as compiler-generated.</i></li>
         
         <li class="calibre22"><i class="calibre6">To force a particular declaration of the copy constructor, such as having it take the source parameter by a non-</i><kbd class="calibre17">const</kbd> <i class="calibre6">reference rather than by a</i> <kbd class="calibre17">const</kbd> <i class="calibre6">reference.</i></li>
         
         <li class="calibre22"><i class="calibre6">To take advantage of the special properties of the compiler-generated function, which are lost if you provide an implementation</i>—More on this in a moment.
         </li>
         
      </ul>
      
      <p class="noind">Just as deleted functions are declared by following the declaration with <kbd class="calibre17">= delete</kbd>, defaulted functions are declared by following the declaration by <kbd class="calibre17">= default</kbd>; for example:
      </p>
      
      <pre id="PLd0e39532" class="calibre5">class Y
{
private:
    Y() = default;                        <b class="calibre24"><i class="calibre6">1</i></b>
public:
    Y(Y&amp;) = default;                      <b class="calibre24"><i class="calibre6">2</i></b>
    T&amp; operator=(const Y&amp;) = default;     <b class="calibre24"><i class="calibre6">3</i></b>
protected:
    virtual ~Y() = default;               <b class="calibre24"><i class="calibre6">4</i></b>
};</pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Change access</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Take a non-const reference</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">3</i> Declare as defaulted for documentation</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">4</i> Change access and add virtual</b></li>
         
      </ul>
      
      <p class="noind">I mentioned previously that compiler-generated functions can have special properties that you can’t get from a user-defined
         version. The biggest difference is that a compiler-generated function can be <i class="calibre6">trivial</i>. This has a few consequences, including the following:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">Objects with trivial copy constructors, trivial copy assignment operators, and trivial destructors can be copied with <kbd class="calibre17">memcpy</kbd> or <kbd class="calibre17">memmove</kbd>.
         </li>
         
         <li class="calibre22">Literal types used for <kbd class="calibre17">constexpr</kbd> functions (see <a href="#app01lev1sec4" class="calibre4">section A.4</a>) must have a trivial constructor, copy constructor, and destructor.
         </li>
         
         <li class="calibre22">Classes with a trivial default constructor, copy constructor, copy assignment operator, and destructor can be used in a union
            with a user-defined constructor and destructor.
         </li>
         
         <li class="calibre22">Classes with trivial copy assignment operators can be used with the <kbd class="calibre17">std::atomic&lt;&gt;</kbd> class template (see <a href="kindle_split_015.html#ch05lev2sec9" class="calibre4">section 5.2.6</a>) in order to provide a value of that type with atomic operations.
         </li>
         
      </ul>
      
      <p class="noind">Just declaring the function as <kbd class="calibre17">= default</kbd> doesn’t make it trivial—it will only be trivial if the class also supports all the other criteria for the corresponding function
         to be trivial—but explicitly writing the function in user code does <i class="calibre6">prevent</i> it from being trivial.
      </p>
      
      <p class="noind">The second difference between classes with compiler-generated functions and user-supplied equivalents is that a class with
         no user-supplied constructors can be an <i class="calibre6">aggregate</i> and thus can be initialized with an aggregate initializer:
      </p>
      
      <pre id="PLd0e39644" class="calibre5">struct aggregate
{
    aggregate() = default;
    aggregate(aggregate const&amp;) = default;
    int a;
    double b;
};
aggregate x={42,3.141};</pre>
      
      <p class="noind">In this case, <kbd class="calibre17">x.a</kbd> is initialized to <kbd class="calibre17">42</kbd> and <kbd class="calibre17">x.b</kbd> is initialized to <kbd class="calibre17">3.141</kbd>.
      </p>
      
      <p class="noind">The third difference between a compiler-generated function and a user-supplied equivalent is quite esoteric and applies only
         to the default constructor and only to the default constructor of classes that meet certain criteria. Consider the following
         class:
      </p>
      
      <pre id="PLd0e39668" class="calibre5">struct X
{
    int a;
};</pre>
      
      <p class="noind">If you create an instance of class <kbd class="calibre17">X</kbd> without an initializer, the contained <kbd class="calibre17">int</kbd> (<kbd class="calibre17">a</kbd>) is <i class="calibre6">default initialized</i>. If the object has static storage duration, it’s initialized to zero; otherwise, it has an indeterminate value that can potentially
         cause undefined behavior if it’s accessed before being assigned a new value:
      </p>
      
      <pre id="PLd0e39689" class="calibre5">X x1;        <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> x1.a has an indeterminate value.</b></li>
         
      </ul>
      
      <p class="noind"><a id="iddle1201" class="calibre4"></a>If, on the other hand, you initialize your instance of <kbd class="calibre17">X</kbd> by explicitly invoking the default constructor, then <kbd class="calibre17">a</kbd> is initialized to zero:
      </p>
      
      <pre id="PLd0e39723" class="calibre5">X x2=X();      <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> x2.a==0</b></li>
         
      </ul>
      
      <p class="noind">This bizarre property also extends to base classes and members. If your class has a compiler-generated default constructor
         and any of your data members and base classes also have a compiler-generated default constructor, data members of those bases
         and members that are built-in types are also either left with an indeterminate value or initialized to zero, depending on
         whether or not the outer class has its default constructor explicitly invoked.
      </p>
      
      <p class="noind">Although this rule is confusing and potentially error-prone, it does have its uses, and if you write the default constructor
         yourself, you lose this property; either data members like <kbd class="calibre17">a</kbd> are always initialized (because you specify a value or explicitly default construct) or always uninitialized (because you
         don’t):
      </p>
      
      <pre id="PLd0e39751" class="calibre5">X::X():a(){}      <b class="calibre24"><i class="calibre6">1</i></b>
X::X():a(42){}    <b class="calibre24"><i class="calibre6">2</i></b>
X::X(){}          <b class="calibre24"><i class="calibre6">3</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> a==0 always.</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> a==42 always.</b></li>
         
      </ul>
      
      <p class="noind">If you omit the initialization of <kbd class="calibre17">a</kbd> from the constructor of <kbd class="calibre17">X</kbd> as in the third example <b class="calibre24"><i class="calibre6">3</i></b>, then <kbd class="calibre17">a</kbd> is left uninitialized for nonstatic instances of <kbd class="calibre17">X</kbd> and initialized to zero for instances of <kbd class="calibre17">X</kbd> with static storage duration.
      </p>
      
      <p class="noind">Under normal circumstances, if you write any other constructor manually, the compiler will no longer generate the default
         constructor for you, so if you want one you have to write it, which means you lose this bizarre initialization property. But
         by explicitly declaring the constructor as defaulted, you can force the compiler to generate the default constructor for you,
         and this property is retained:
      </p>
      
      <pre id="PLd0e39810" class="calibre5">X::X() = default;     <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Default initialization rules for a apply</b></li>
         
      </ul>
      
      <p class="noind">This property is used for the atomic types (see <a href="kindle_split_015.html#ch05lev1sec2" class="calibre4">section 5.2</a>), which have their default constructor explicitly defaulted. Their initial value is always undefined unless either (a) they
         have static storage duration (and thus are statically initialized to zero), (b) you explicitly invoke the default constructor
         to request zero initialization, or (c) you explicitly specify a value. Note that in the case of the atomic types, the constructor
         for initialization with a value is declared <kbd class="calibre17">constexpr</kbd> (see <a href="#app01lev1sec4" class="calibre4">section A.4</a>) in order to allow static initialization.
      </p>
      
      
      
      
      <h3 id="app01lev1sec4" class="chapter"><a id="app01lev1sec4__title" class="calibre3"></a>A.4. constexpr functions
      </h3>
      
      <p class="noind"><a id="iddle1206" class="calibre4"></a>Integer literals such as <kbd class="calibre17">42</kbd> are <i class="calibre6">constant expressions</i>, as are simple arithmetic expressions such as <kbd class="calibre17">23*2-4</kbd>. You can even use <kbd class="calibre17">const</kbd> variables of integral type that are themselves initialized with constant expressions as part of a new constant expression:
      </p>
      
      <pre id="PLd0e39869" class="calibre5">const int i=23;
const int two_i=i*2;
const int four=4;
const int forty_two=two_i-four;</pre>
      
      <p class="noind">Aside from using constant expressions to create variables that can be used in other constant expressions, there are a few
         things you can <i class="calibre6">only</i> do with constant expressions:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">Specify the bounds of an array:
            
            
            <div class="calibre15"></div><pre class="calibre5">int bounds=99;
int array[bounds];        <b class="calibre24"><i class="calibre6">1</i></b>
const int bounds2=99;
int array2[bounds2];      <b class="calibre24"><i class="calibre6">2</i></b></pre>
            
            <p class="calibre19"></p>
            <ul class="calibre30">
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Error bounds is not a constant expression</b></li>
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> OK, bounds2 is a constant expression.</b></li>
               
            </ul>
         </li>
         
         <li class="calibre22">Specify the value of a nontype template parameter:
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;unsigned size&gt;
struct test
{};
test&lt;bounds&gt; ia;        <b class="calibre24"><i class="calibre6">1</i></b>
test&lt;bounds2&gt; ia2;      <b class="calibre24"><i class="calibre6">2</i></b></pre>
            
            <p class="calibre19"></p>
            <ul class="calibre30">
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Error bounds is not a constant expression</b></li>
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> OK, bounds2 is a constant expression.</b></li>
               
            </ul>
         </li>
         
         <li class="calibre22">Provide an initializer for a <kbd class="calibre17">static const</kbd> class data member of integral type in the class definition:
            
            
            <div class="calibre15"></div><pre class="calibre5">class X
{
    static const int the_answer=forty_two;
};</pre>
            </li>
         
         <li class="calibre22">Provide an initializer for a built-in type or aggregate that can be used for static initialization:
            
            
            <div class="calibre15"></div><pre class="calibre5">struct my_aggregate
{
    int a;
    int b;
};
static my_aggregate ma1={forty_two,123};     <b class="calibre24"><i class="calibre6">1</i></b>
int dummy=257;
static my_aggregate ma2={dummy,dummy};       <b class="calibre24"><i class="calibre6">2</i></b></pre>
            
            <p class="calibre19"></p>
            <ul class="calibre30">
               
               <li class="calibre22"><a id="iddle1205" class="calibre4"></a><a id="iddle2607" class="calibre4"></a><b class="calibre24"><i class="calibre6">1</i> Static initialization</b></li>
               
               <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Dynamic initialization</b></li>
               
            </ul>
         </li>
         
         <li class="calibre22">Static initialization like this can be used to avoid order-of-initialization problems and race conditions.</li>
         
      </ul>
      
      <p class="noind">None of this is new—you could do all that with the 1998 edition of the C++ Standard. But with the C++11 Standard what constitutes
         a <i class="calibre6">constant expression</i> has been extended with the introduction of the <kbd class="calibre17">constexpr</kbd> keyword. The C++14 and C++17 standards extend the <kbd class="calibre17">constexpr</kbd> facility further; a full primer is beyond the scope of this appendix.
      </p>
      
      <p class="noind">The <kbd class="calibre17">constexpr</kbd> keyword is primarily a function modifier. If the parameter and return type of a function meet certain requirements and the
         body is sufficiently simple, a function can be declared <kbd class="calibre17">constexpr</kbd>, in which case it can be used in constant expressions; for example:
      </p>
      
      <pre id="PLd0e40039" class="calibre5">constexpr int square(int x)
{
    return x*x;
}
int array[square(5)];</pre>
      
      <p class="noind">In this case, <kbd class="calibre17">array</kbd> will have 25 entries, because <kbd class="calibre17">square</kbd> is declared <kbd class="calibre17">constexpr</kbd>. Just because the function <i class="calibre6">can</i> be used in a constant expression doesn’t mean that all uses are automatically constant expressions:
      </p>
      
      <pre id="PLd0e40060" class="calibre5">int dummy=4;
int array[square(dummy)];     <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Error, dummy is not a constant expression</b></li>
         
      </ul>
      
      <p class="noind">In this example, <kbd class="calibre17">dummy</kbd> is not a constant expression <b class="calibre24"><i class="calibre6">1</i></b>, so <kbd class="calibre17">square(dummy)</kbd> isn’t either—it’s a normal function call—and thus can’t be used to specify the bounds of <kbd class="calibre17">array</kbd>.
      </p>
      
      
      <h4 id="app01lev2sec3" class="calibre23">A.4.1. <a id="app01lev2sec3__title" class="calibre4"></a>constexpr and user-defined types
      </h4>
      
      <p class="noind">Up to now, all the examples have been with built-in types such as <kbd class="calibre17">int</kbd>. But the new C++ Standard allows constant expressions to be of any type that satisfies the requirements for a <i class="calibre6">literal type</i>. For a class type to be classified as a literal type, the following must all be true:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">It must have a trivial copy constructor.</li>
         
         <li class="calibre22">It must have a trivial destructor.</li>
         
         <li class="calibre22">All non-<kbd class="calibre17">static</kbd> data members and base classes must be trivial types.
         </li>
         
         <li class="calibre22">It must have either a trivial default constructor or a <kbd class="calibre17">constexpr</kbd> constructor other than the copy constructor.
         </li>
         
      </ul>
      
      <p class="noind">We’ll look at <kbd class="calibre17">constexpr</kbd> constructors shortly. For now, we’ll focus on classes with a trivial default constructor, such as class <kbd class="calibre17">CX</kbd> in the following listing.
      </p>
      
      
      
      <h5 class="notetitle" id="app01ex03">Listing A.3. <a id="app01ex03__title" class="calibre4"></a>A class with a trivial default constructor
      </h5>
      <pre id="PLd0e40147" class="calibre5">class CX
{
private:
    int a;
    int b;
public:
    CX() = default;       <b class="calibre24"><i class="calibre6">1</i></b>
    CX(int a_, int b_):   <b class="calibre24"><i class="calibre6">2</i></b>
        a(a_),b(b_)
    {}
    int get_a() const
    {
        return a;
    }
    int get_b() const
    {
        return b;
    }
    int foo() const
    {
        return a+b;
    }
};</pre>
      
      <p class="noind">Note that we’ve explicitly declared the default constructor <b class="calibre24"><i class="calibre6">1</i></b> as <i class="calibre6">defaulted</i> (see <a href="#app01lev1sec3" class="calibre4">section A.3</a>) in order to preserve it as trivial in the face of the user-defined constructor <b class="calibre24"><i class="calibre6">2</i></b>. This type therefore fits all the qualifications for being a literal type, and you can use it in constant expressions. You
         can, for example, provide a <kbd class="calibre17">constexpr</kbd> function that creates new instances:
      </p>
      
      <pre id="PLd0e40181" class="calibre5">constexpr CX create_cx()
{
    return CX();
}</pre>
      
      <p class="noind">You can also create a simple <kbd class="calibre17">constexpr</kbd> function that copies its parameter:
      </p>
      
      <pre id="PLd0e40193" class="calibre5">constexpr CX clone(CX val)
{
    return val;
}</pre>
      
      <p class="noind">But that’s about all you can do in C++11—a <kbd class="calibre17">constexpr</kbd> function can only call other <kbd class="calibre17">constexpr</kbd> functions. In C++14, this restriction is lifted, and you can do almost anything in a <kbd class="calibre17">constexpr</kbd> function, provided it doesn’t modify any objects with non-local <a id="iddle1200" class="calibre4"></a><a id="iddle1203" class="calibre4"></a><a id="iddle1207" class="calibre4"></a><a id="iddle1466" class="calibre4"></a><a id="iddle1705" class="calibre4"></a>scope. What you <i class="calibre6">can</i> do, even in C++11, is apply <kbd class="calibre17">constexpr</kbd> to the member functions and constructor of <kbd class="calibre17">CX</kbd>:
      </p>
      
      <pre id="PLd0e40256" class="calibre5">class CX
{
private:
    int a;
    int b;
public:
    CX() = default;
    constexpr CX(int a_, int b_):
        a(a_),b(b_)
    {}
    constexpr int get_a() const    <b class="calibre24"><i class="calibre6">1</i></b>
    {
        return a;
    }
    constexpr int get_b()          <b class="calibre24"><i class="calibre6">2</i></b>
    {
        return b;
    }
    constexpr int foo()
    {
        return a+b;
    }
};</pre>
      
      <p class="noind">In C++11, the <kbd class="calibre17">const</kbd> qualification on <kbd class="calibre17">get_a()</kbd> <b class="calibre24"><i class="calibre6">1</i></b> is now superfluous, because it’s implied by the use of <kbd class="calibre17">constexpr</kbd>, and <kbd class="calibre17">get_b()</kbd> is thus <kbd class="calibre17">const</kbd> even though the <kbd class="calibre17">const</kbd> qualification is omitted <b class="calibre24"><i class="calibre6">2</i></b>. In C++14, this is changed (due to the extended capabilities of <kbd class="calibre17">constexpr</kbd> functions), so <kbd class="calibre17">get_b()</kbd> is no longer implicitly <kbd class="calibre17">const</kbd>. This now allows more complex <kbd class="calibre17">constexpr</kbd> functions such as the following:
      </p>
      
      <pre id="PLd0e40311" class="calibre5">constexpr CX make_cx(int a)
{
    return CX(a,1);
}
constexpr CX half_double(CX old)
{
    return CX(old.get_a()/2,old.get_b()*2);
}
constexpr int foo_squared(CX val)
{
    return square(val.foo());
}
int array[foo_squared(half_double(make_cx(10)))];     <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> 49 elements</b></li>
         
      </ul>
      
      <p class="noind">Interesting though this is, it’s a lot of effort to go to if all you get is a fancy way of computing some array bounds or
         an integral constant. The key benefit of constant expressions and <kbd class="calibre17">constexpr</kbd> functions involving user-defined types is that objects of a literal <a id="iddle1204" class="calibre4"></a><a id="iddle1816" class="calibre4"></a><a id="iddle1868" class="calibre4"></a><a id="iddle2459" class="calibre4"></a>type initialized with a constant expression are statically initialized, and so their initialization is free from race conditions
         and initialization order issues:
      </p>
      
      <pre id="PLd0e40364" class="calibre5">CX si=half_double(CX(42,19));     <b class="calibre24"><i class="calibre6">1</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Statically initialized</b></li>
         
      </ul>
      
      <p class="noind">This covers constructors too. If the constructor is declared <kbd class="calibre17">constexpr</kbd> and the constructor parameters are constant expressions, the initialization is <i class="calibre6">constant initialization</i> and happens as part of the static initialization phase. This is one of the most important changes in C++11 as far as concurrency
         goes: by allowing user-defined constructors that can still undergo static initialization, you can avoid any race conditions
         over their initialization, because they’re guaranteed to be initialized before any code is run.
      </p>
      
      <p class="noind">This is particularly relevant for things like <kbd class="calibre17">std::mutex</kbd> (see <a href="kindle_split_013.html#ch03lev2sec3" class="calibre4">section 3.2.1</a>) or <kbd class="calibre17">std::atomic&lt;&gt;</kbd> (see <a href="kindle_split_015.html#ch05lev2sec9" class="calibre4">section 5.2.6</a>) where you might want to use a global instance to synchronize access to other variables and avoid race conditions in <i class="calibre6">that</i> access. This wouldn’t be possible if the constructor of the mutex was subject to race conditions, so the default constructor
         of <kbd class="calibre17">std::mutex</kbd> is declared <kbd class="calibre17">constexpr</kbd> to ensure that mutex initialization is always done as part of the static initialization phase.
      </p>
      
      
      
      <h4 id="app01lev2sec4" class="calibre23">A.4.2. <a id="app01lev2sec4__title" class="calibre4"></a>constexpr objects
      </h4>
      
      <p class="noind">So far, we’ve looked at <kbd class="calibre17">constexpr</kbd> as applied to functions. <kbd class="calibre17">constexpr</kbd> can also be applied to objects. This is primarily for diagnostic purposes; it verifies that the object is initialized with
         a constant expression, <kbd class="calibre17">constexpr</kbd> constructor, or aggregate initializer made of constant expressions. It also declares the object as <kbd class="calibre17">const</kbd>:
      </p>
      
      <pre id="PLd0e40437" class="calibre5">constexpr int i=45;                 <b class="calibre24"><i class="calibre6">1</i></b>
constexpr std::string s("hello");   <b class="calibre24"><i class="calibre6">2</i></b>
int foo();
constexpr int j=foo();              <b class="calibre24"><i class="calibre6">3</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> OK</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Error; std::string isn’t a literal type</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">3</i> Error; foo() isn’t declared constexpr</b></li>
         
      </ul>
      
      
      
      <h4 id="app01lev2sec5" class="calibre23">A.4.3. <a id="app01lev2sec5__title" class="calibre4"></a>constexpr function requirements
      </h4>
      
      <p class="noind">In order to declare a function as <kbd class="calibre17">constexpr</kbd> it must meet a few requirements; if it doesn’t meet these requirements, declaring it <kbd class="calibre17">constexpr</kbd> is a compilation error. In C++11, the requirements for a <kbd class="calibre17">constexpr</kbd> function were as follows:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">All parameters must be of a literal type.</li>
         
         <li class="calibre22">The return type must be a literal type.</li>
         
         <li class="calibre22">The function body must consist of a single <kbd class="calibre17">return</kbd> statement.
         </li>
         
         <li class="calibre22">The expression in the <kbd class="calibre17">return</kbd> statement must qualify as a constant expression.
         </li>
         
         <li class="calibre22">Any constructor or conversion operator used to construct the return value from the expression must be <kbd class="calibre17">constexpr</kbd>.
         </li>
         
      </ul>
      
      <p class="noind"><a id="iddle1505" class="calibre4"></a><a id="iddle2100" class="calibre4"></a>This is straightforward; you must be able to inline the function into a constant expression and it will still be a constant
         expression, and you must not modify anything. <kbd class="calibre17">constexpr</kbd> functions are <i class="calibre6">pure functions</i> with no side effects.
      </p>
      
      <p class="noind">In C++14, the requirements were slackened quite considerably. Though the overall idea of a pure function with no side effects
         is preserved, the body is allowed to contain considerably more:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">Multiple return statements are allowed.</li>
         
         <li class="calibre22">Objects created within the function can be modified.</li>
         
         <li class="calibre22">Loops, conditionals, and switch statements are allowed.</li>
         
      </ul>
      
      <p class="noind">For <kbd class="calibre17">constexpr</kbd> class member functions there are additional requirements:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><kbd class="calibre17">constexpr</kbd> member functions can’t be virtual.
         </li>
         
         <li class="calibre22">The class for which the function is a member must be a literal type.</li>
         
      </ul>
      
      <p class="noind">The rules are different for <kbd class="calibre17">constexpr</kbd> constructors:
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22">The constructor body must be empty for a C++11 compiler; for a C++14 or later compiler it must satisfy the requirements for
            a <kbd class="calibre17">constexpr</kbd> function.
         </li>
         
         <li class="calibre22">Every base class must be initialized.</li>
         
         <li class="calibre22">Every non-<kbd class="calibre17">static</kbd> data member must be initialized.
         </li>
         
         <li class="calibre22">Any expressions used in the member initialization list must qualify as constant expressions.</li>
         
         <li class="calibre22">The constructors chosen for the initialization of the data members and base classes must be <kbd class="calibre17">constexpr</kbd> constructors.
         </li>
         
         <li class="calibre22">Any constructor or conversion operator used to construct the data members and base classes from their corresponding initialization
            expression must be <kbd class="calibre17">constexpr</kbd>.
         </li>
         
      </ul>
      
      <p class="noind">This is the same set of rules as for functions, except that there’s no return value, so no <kbd class="calibre17">return</kbd> statement. Instead, the constructor initializes all the bases and data members in the member initialization list. Trivial
         copy constructors are implicitly <kbd class="calibre17">constexpr</kbd>.
      </p>
      
      
      
      <h4 id="app01lev2sec6" class="calibre23">A.4.4. <a id="app01lev2sec6__title" class="calibre4"></a>constexpr and templates
      </h4>
      
      <p class="noind">When <kbd class="calibre17">constexpr</kbd> is applied to a function template, or to a member function of a class template, it’s ignored if the parameters and return
         types of a particular instantiation of the template aren’t literal types. This allows you to write function templates that
         are <kbd class="calibre17">constexpr</kbd> if the type of the template parameters is appropriate and just plain <kbd class="calibre17">inline</kbd> functions otherwise, for example:
      </p>
      
      <pre id="PLd0e40660" class="calibre5">template&lt;typename T&gt;
constexpr T sum(T a,T b)
{
    return a+b;
}
constexpr int i=sum(3,42);         <b class="calibre24"><i class="calibre6">1</i></b>
std::string s=
    sum(std::string("hello"),
        std::string(" world"));    <b class="calibre24"><i class="calibre6">2</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> OK; sum&lt;int&gt; is constexpr.</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> OK, but sum&lt;std::string&gt; isn’t constexpr.</b></li>
         
      </ul>
      
      <p class="noind">The function must satisfy all the other requirements for a <kbd class="calibre17">constexpr</kbd> function. You can’t declare a function with multiple statements <kbd class="calibre17">constexpr</kbd> just because it’s a function template; that’s still a compilation error.
      </p>
      
      
      
      
      <h3 id="app01lev1sec5" class="chapter"><a id="app01lev1sec5__title" class="calibre3"></a>A.5. Lambda functions
      </h3>
      
      <p class="noind">Lambda functions are one of the most exciting features of the C++11 Standard, because they have the potential to greatly simplify
         code and eliminate much of the boilerplate associated with writing callable objects. The C++11 lambda function syntax allows
         a function to be defined at the point where it’s needed in another expression. This works well for things like predicates
         provided to the wait functions of <kbd class="calibre17">std:: condition_variable</kbd> (as in the example in <a href="kindle_split_014.html#ch04lev2sec1" class="calibre4">section 4.1.1</a>), because it allows the semantics to be quickly expressed in terms of the accessible variables rather than capturing the
         necessary state in the member variables of a class with a function call operator.
      </p>
      
      <p class="noind">At its simplest, a <i class="calibre6">lambda expression</i> defines a self-contained function that takes no parameters and relies only on global variables and functions. It doesn’t
         even have to return a value. This lambda expression is a series of statements enclosed in brackets, prefixed with square brackets
         (the <i class="calibre6">lambda introducer</i>):
      </p>
      
      <pre id="PLd0e40727" class="calibre5">[]{                     <b class="calibre24"><i class="calibre6">1</i></b>
    do_stuff();
    do_more_stuff();
}();                    <b class="calibre24"><i class="calibre6">2</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> Start the lambda expression with [].</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Finish the lambda, and call it.</b></li>
         
      </ul>
      
      <p class="noind">In this example, the lambda expression is called by following it with parentheses, but this is unusual. For one thing, if
         you’re going to call it directly, you could usually do away with the lambda and write the statements directly in the source.
         It’s more common to pass it as a parameter to a function template that takes a callable object as one of its parameters, in
         which case it likely needs to take parameters or return a value or both. If you need to take parameters, you can do this by
         following the lambda introducer with a parameter list like for a normal function. For example, the following code writes all
         the elements of the vector to <kbd class="calibre17">std::cout</kbd> separated by newlines:
      </p>
      
      <pre id="PLd0e40763" class="calibre5">std::vector&lt;int&gt; data=make_data();
std::for_each(data.begin(),data.end(),[](int i){std::cout&lt;&lt;i&lt;&lt;"\n";});</pre>
      
      <p class="noind">Return values are almost as easy. If your lambda function body consists of a single <kbd class="calibre17">return</kbd> statement, the return type of the lambda is the type of the expression being <a id="iddle1576" class="calibre4"></a><a id="iddle2613" class="calibre4"></a>returned. For example, you might use a simple lambda like this to wait for a flag to be set with <kbd class="calibre17">std::condition_variable</kbd> (see <a href="kindle_split_014.html#ch04lev2sec1" class="calibre4">section 4.1.1</a>), as in the following listing.
      </p>
      
      
      
      <h5 class="notetitle" id="app01ex04">Listing A.4. <a id="app01ex04__title" class="calibre4"></a>A simple lambda with a deduced return type
      </h5>
      <pre id="PLd0e40799" class="calibre5">std::condition_variable cond;
bool data_ready;
std::mutex m;
void wait_for_data()
{
    std::unique_lock&lt;std::mutex&gt; lk(m);
    cond.wait(lk,[]{return data_ready;});    <b class="calibre24"><i class="calibre6">1</i></b>
}</pre>
      
      <p class="noind">The return type of the lambda passed to <kbd class="calibre17">cond.wait()</kbd> <b class="calibre24"><i class="calibre6">1</i></b> is deduced from the type of <kbd class="calibre17">data_ready</kbd> and is thus <kbd class="calibre17">bool</kbd>. Whenever the condition variable wakes from waiting, it then calls the lambda with the mutex locked and only returns from
         the call to <kbd class="calibre17">wait()</kbd> once <kbd class="calibre17">data_ready</kbd> is <kbd class="calibre17">true</kbd>.
      </p>
      
      <p class="noind">What if you can’t write your lambda body as a single <kbd class="calibre17">return</kbd> statement? In that case you have to specify the return type explicitly. You can do this even if your body is a single <kbd class="calibre17">return</kbd> statement, but you <i class="calibre6">have</i> to do it if your lambda body is more complex. The return type is specified by following the lambda parameter list with an
         arrow (<kbd class="calibre17">-&gt;</kbd>) and the return type. If your lambda doesn’t take any parameters, you must still include the (empty) parameter list in order
         to specify the return value explicitly. Your condition variable predicate can be written
      </p>
      
      <pre id="PLd0e40849" class="calibre5">cond.wait(lk,[]()-&gt;bool{return data_ready;});</pre>
      
      <p class="noind">By specifying the return type, you can expand the lambda to log messages or do some more complex processing:</p>
      
      <pre id="PLd0e40858" class="calibre5">cond.wait(lk,[]()-&gt;bool{
    if(data_ready)
    {
        std::cout&lt;&lt;"Data ready"&lt;&lt;std::endl;
        return true;
    }
    else
    {
        std::cout&lt;&lt;"Data not ready, resuming wait"&lt;&lt;std::endl;
        return false;
    }
});</pre>
      
      <p class="noind">Although simple lambdas like this are powerful and can simplify code quite a lot, the real power of lambdas comes when they
         capture local variables.
      </p>
      
      
      
      <h4 id="app01lev2sec7" class="calibre23">A.5.1. <a id="app01lev2sec7__title" class="calibre4"></a>Lambda functions that reference local variables
      </h4>
      
      <p class="noind">Lambda functions with a <i class="calibre6">lambda introducer</i> of <kbd class="calibre17">[]</kbd> can’t reference any local variables from the containing scope; they can only use global variables and anything passed in
         as a parameter. If you want to access a local variable, you need to <i class="calibre6">capture</i> it. The simplest way to do this is to capture the entire set of variables within the local scope by using a lambda introducer
         of <kbd class="calibre17">[=]</kbd>. That’s all there is to it—your lambda can now access <i class="calibre6">copies</i> of the local variables at the time the lambda was created.
      </p>
      
      <p class="noind">To see this in action, consider the following simple function:</p>
      
      <pre id="PLd0e40895" class="calibre5">std::function&lt;int(int)&gt; make_offseter(int offset)
{
   return [=](int j){return offset+j;};
}</pre>
      
      <p class="noind">Every call to <kbd class="calibre17">make_offseter</kbd> returns a new lambda function object through the <kbd class="calibre17">std::function&lt;&gt;</kbd> function wrapper. This returned function adds the supplied offset to any parameter supplied. For example,
      </p>
      
      <pre id="PLd0e40910" class="calibre5">int main()
{
    std::function&lt;int(int)&gt; offset_42=make_offseter(42);
    std::function&lt;int(int)&gt; offset_123=make_offseter(123);
    std::cout&lt;&lt;offset_42(12)&lt;&lt;","&lt;&lt;offset_123(12)&lt;&lt;std::endl;
    std::cout&lt;&lt;offset_42(12)&lt;&lt;","&lt;&lt;offset_123(12)&lt;&lt;std::endl;
}</pre>
      
      <p class="noind">will write out <kbd class="calibre17">54,135</kbd> twice because the function returned from the first call to <kbd class="calibre17">make_offseter</kbd> always adds 42 to the supplied argument, whereas the function returned from the second call to <kbd class="calibre17">make_offseter</kbd> always adds 123 to the supplied argument.
      </p>
      
      <p class="noind">This is the safest form of local variable capture; everything is copied, so you can return the lambda and call it outside
         the scope of the original function. It’s not the only choice though; you can choose to capture everything by reference instead.
         In this case it’s undefined behavior to call the lambda once the variables it references have been destroyed by exiting the
         function or block scope to which they belong, just as it’s undefined behavior to reference a variable that has already been
         destroyed in any other circumstance.
      </p>
      
      <p class="noind">A lambda function that captures all the local variables by reference is introduced using <kbd class="calibre17">[&amp;]</kbd>, as in the following example:
      </p>
      
      <pre id="PLd0e40937" class="calibre5">int main()
{
    int offset=42;                                                    <b class="calibre24"><i class="calibre6">1</i></b>
    std::function&lt;int(int)&gt; offset_a=[&amp;](int j){return offset+j;};    <b class="calibre24"><i class="calibre6">2</i></b>
    offset=123;                                                       <b class="calibre24"><i class="calibre6">3</i></b>
    std::function&lt;int(int)&gt; offset_b=[&amp;](int j){return offset+j;};    <b class="calibre24"><i class="calibre6">4</i></b>
    std::cout&lt;&lt;offset_a(12)&lt;&lt;","&lt;&lt;offset_b(12)&lt;&lt;std::endl;            <b class="calibre24"><i class="calibre6">5</i></b>
    offset=99;                                                        <b class="calibre24"><i class="calibre6">6</i></b>
    std::cout&lt;&lt;offset_a(12)&lt;&lt;","&lt;&lt;offset_b(12)&lt;&lt;std::endl;            <b class="calibre24"><i class="calibre6">7</i></b>
}</pre>
      
      <p class="noind"><a id="iddle1421" class="calibre4"></a><a id="iddle1422" class="calibre4"></a>Whereas in the <kbd class="calibre17">make_offseter</kbd> function from the previous example you used the <kbd class="calibre17">[=]</kbd> lambda introducer to capture a copy of the offset, the <kbd class="calibre17">offset_a</kbd> function in this example uses the <kbd class="calibre17">[&amp;]</kbd> lambda introducer to capture <kbd class="calibre17">offset</kbd> by reference <b class="calibre24"><i class="calibre6">2</i></b>. It doesn’t matter that the initial value of <kbd class="calibre17">offset</kbd> is 42 <b class="calibre24"><i class="calibre6">1</i></b>; the result of calling <kbd class="calibre17">offset_a(12)</kbd> will always depend on the current value of <kbd class="calibre17">offset</kbd>. Even though the value of <kbd class="calibre17">offset</kbd> is then changed to 123 <b class="calibre24"><i class="calibre6">3</i></b>, before you produce the second (identical) lambda function, <kbd class="calibre17">offset_b</kbd> <b class="calibre24"><i class="calibre6">4</i></b>, this second lambda again captures by reference, so the result depends on the current value of <kbd class="calibre17">offset</kbd>.
      </p>
      
      <p class="noind">Now, when you print the first line of output <b class="calibre24"><i class="calibre6">5</i></b>, <kbd class="calibre17">offset</kbd> is still 123, so the output is <kbd class="calibre17">135,135</kbd>. But at the second line of output <b class="calibre24"><i class="calibre6">7</i></b>, <kbd class="calibre17">offset</kbd> has been changed to 99 <b class="calibre24"><i class="calibre6">6</i></b>, so this time the output is <kbd class="calibre17">111,111</kbd>. Both <kbd class="calibre17">offset_a</kbd> and <kbd class="calibre17">offset_b</kbd> add the current value of <kbd class="calibre17">offset</kbd> (99) to the supplied argument (12).
      </p>
      
      <p class="noind">Now, C++ being C++, you’re not stuck with these all-or-nothing options; you can choose to capture some variables by copy and
         some by reference, and you can choose to capture only those variables you have explicitly chosen by tweaking the lambda introducer.
         If you want to <i class="calibre6">copy</i> all the used variables except for one or two, you can use the <kbd class="calibre17">[=]</kbd> form of the lambda introducer but follow the equals sign with a list of variables to capture by reference preceded with ampersands.
         The following example will print <kbd class="calibre17">1239</kbd>, because <kbd class="calibre17">i</kbd> is copied into the lambda, but <kbd class="calibre17">j</kbd> and <kbd class="calibre17">k</kbd> are captured by reference:
      </p>
      
      <pre id="PLd0e41091" class="calibre5">int main()
{
    int i=1234,j=5678,k=9;
    std::function&lt;int()&gt; f=[=,&amp;j,&amp;k]{return i+j+k;};
    i=1;
    j=2;
    k=3;
    std::cout&lt;&lt;f()&lt;&lt;std::endl;
}</pre>
      
      <p class="noind">Alternatively, you can capture by reference by default but capture a specific subset of variables by copying. In this case,
         you use the <kbd class="calibre17">[&amp;]</kbd> form of the lambda introducer but follow the ampersand with a list of variables to capture by copy. The following example
         prints <kbd class="calibre17">5688</kbd> because <kbd class="calibre17">i</kbd> is captured by reference, but <kbd class="calibre17">j</kbd> and <kbd class="calibre17">k</kbd> are copied:
      </p>
      
      <pre id="PLd0e41115" class="calibre5">int main()
{
    int i=1234,j=5678,k=9;
    std::function&lt;int()&gt; f=[&amp;,j,k]{return i+j+k;};
    i=1;
    j=2;
    k=3;
    std::cout&lt;&lt;f()&lt;&lt;std::endl;
}</pre>
      
      <p class="noind">If you only want to capture the named variables, then you can omit the leading <kbd class="calibre17">=</kbd> or <kbd class="calibre17">&amp;</kbd> and just list the variables to be captured, prefixing them with an ampersand to capture <a id="iddle1799" class="calibre4"></a><a id="iddle2461" class="calibre4"></a><a id="iddle2616" class="calibre4"></a>by reference rather than copy. The following code will print <kbd class="calibre17">5682</kbd> because <kbd class="calibre17">i</kbd> and <kbd class="calibre17">k</kbd> are captured by reference, but <kbd class="calibre17">j</kbd> is copied:
      </p>
      
      <pre id="PLd0e41162" class="calibre5">int main()
{
    int i=1234,j=5678,k=9;
    std::function&lt;int()&gt; f=[&amp;i,j,&amp;k]{return i+j+k;};
    i=1;
    j=2;
    k=3;
    std::cout&lt;&lt;f()&lt;&lt;std::endl;
}</pre>
      
      <p class="noind">This final variant allows you to ensure that only the intended variables are being captured, because any reference to a local
         variable not in the capture list will cause a compilation error. If you choose this option, you have to be careful when accessing
         class members if the function containing the lambda is a member function. Class members can’t be captured directly; if you
         want to access class members from your lambda, you have to capture the <kbd class="calibre17">this</kbd> pointer by adding it to the capture list. In the following example, the lambda captures <kbd class="calibre17">this</kbd> to allow access to the <kbd class="calibre17">some_data</kbd> class member:
      </p>
      
      <pre id="PLd0e41180" class="calibre5">struct X
{
    int some_data;
    void foo(std::vector&lt;int&gt;&amp; vec)
    {
        std::for_each(vec.begin(),vec.end(),
            [this](int&amp; i){i+=some_data;});
    }
};</pre>
      
      <p class="noind">In the context of concurrency, lambdas are most useful as predicates for <kbd class="calibre17">std::condition_variable::wait()</kbd> (<a href="kindle_split_014.html#ch04lev2sec1" class="calibre4">section 4.1.1</a>) and with <kbd class="calibre17">std::packaged_task&lt;&gt;</kbd> (<a href="kindle_split_014.html#ch04lev2sec3" class="calibre4">section 4.2.1</a>) or thread pools for packaging small tasks. They can also be passed to the <kbd class="calibre17">std::thread</kbd> constructor as a thread function (<a href="kindle_split_012.html#ch02lev2sec1" class="calibre4">section 2.1.1</a>) and as the function when using parallel algorithms such as <kbd class="calibre17">parallel_for_each()</kbd> (from <a href="kindle_split_018.html#ch08lev2sec15" class="calibre4">section 8.5.1</a>).
      </p>
      
      <p class="noind">Since C++14, lambdas can also be <i class="calibre6">generic lamdas</i>, where the parameter types are declared as <kbd class="calibre17">auto</kbd> rather than a specified type. In this case, the function call operator is implicitly a template, and the type of the parameter
         is deduced from the supplied argument when the lambda is invoked; for example:
      </p>
      
      <pre id="PLd0e41222" class="calibre5">auto f=[](auto x){ std::cout&lt;&lt;"x="&lt;&lt;x&lt;&lt;std::endl;};
f(42); // x is of type int; outputs "x=42"
f("hello"); // x is of type const char*; outputs "x=hello"</pre>
      
      <p class="noind">C++14 also adds the concept of <i class="calibre6">generalized captures</i>, so you can capture the results of expressions, rather than a direct copy of or reference to a local variable. Most commonly
         this can be used to capture move-only types by moving them, rather than having to capture by reference; for example:
      </p>
      
      
      <pre id="PLd0e41236" class="calibre5">std::future&lt;int&gt; spawn_async_task(){
    std::promise&lt;int&gt; p;
    auto f=p.get_future();
    std::thread t([p=std::move(p)](){ p.set_value(find_the_answer());});
    t.detach();
    return f;
}</pre>
      
      <p class="noind"><a id="iddle1019" class="calibre4"></a><a id="iddle1738" class="calibre4"></a><a id="iddle1771" class="calibre4"></a>Here, the promise is moved into the lambda by the <kbd class="calibre17">p=std::move(p)</kbd> generalized capture, so it is safe to detach the thread, without the worry of a dangling reference to a local variable that
         has been destroyed. After the construction of the lambda, the original <kbd class="calibre17">p</kbd> is now in a moved-from state, which is why you had to get the future beforehand.
      </p>
      
      
      
      
      <h3 id="app01lev1sec6" class="chapter"><a id="app01lev1sec6__title" class="calibre3"></a>A.6. Variadic templates
      </h3>
      
      <p class="noind">Variadic templates are templates with a variable number of parameters. Just as you’ve always been able to have variadic functions,
         such as <kbd class="calibre17">printf</kbd>, that take a variable number of parameters, you can now have variadic templates that have a variable number of <i class="calibre6">template</i> parameters. Variadic templates are used throughout the C++ Thread Library. For example, the <kbd class="calibre17">std::thread</kbd> constructor for starting a thread (<a href="kindle_split_012.html#ch02lev2sec1" class="calibre4">section 2.1.1</a>) is a variadic function template, and <kbd class="calibre17">std::packaged_task&lt;&gt;</kbd> (<a href="kindle_split_014.html#ch04lev2sec4" class="calibre4">section 4.2.2</a>) is a variadic class template. From a user’s point of view, it’s enough to know that the template takes an unbounded number
         of parameters, but if you want to write this template, or if you’re interested in how it all works, you need to know the details.
      </p>
      
      <p class="noind">Just as variadic functions are declared with an ellipsis (<kbd class="calibre17">...</kbd>) in the function parameter list, variadic templates are declared with an ellipsis in the template parameter list:
      </p>
      
      <pre id="PLd0e41301" class="calibre5">template&lt;typename ... ParameterPack&gt;
class my_template
{};</pre>
      
      <p class="noind">You can use variadic templates for a partial specialization of a template too, even if the primary template isn’t variadic.
         For example, the primary template for <kbd class="calibre17">std::packaged_task&lt;&gt;</kbd> (<a href="kindle_split_014.html#ch04lev2sec3" class="calibre4">section 4.2.1</a>) is a simple template with a single template parameter:
      </p>
      
      <pre id="PLd0e41316" class="calibre5">template&lt;typename FunctionType&gt;
class packaged_task;</pre>
      
      <p class="noind">But this primary template is never defined anywhere; it’s a placeholder for the partial specialization:</p>
      
      <pre id="PLd0e41325" class="calibre5">template&lt;typename ReturnType,typename ... Args&gt;
class packaged_task&lt;ReturnType(Args...)&gt;;</pre>
      
      <p class="noind">It’s this partial specialization that contains the real definition of the class; you saw in <a href="kindle_split_014.html#ch04" class="calibre4">chapter 4</a> that you can write <kbd class="calibre17">std::packaged_task&lt;int(std::string,double)&gt;</kbd> to declare a task that takes an <kbd class="calibre17">std::string</kbd> and a <kbd class="calibre17">double</kbd> as parameters when you call it and that provides the result through an <kbd class="calibre17">std::future&lt;int&gt;</kbd>.
      </p>
      
      <p class="noind">This declaration shows two additional features of variadic templates. The first feature is relatively simple: you can have
         normal template parameters (such as <kbd class="calibre17">ReturnType</kbd>) as well as variadic ones (<kbd class="calibre17">Args</kbd>) in the same declaration. The second feature demonstrated is the use of <kbd class="calibre17">Args...</kbd> in the template argument list of the specialization to show that the types that make up <kbd class="calibre17">Args</kbd> when the template is instantiated are to be listed here. Because this is a partial specialization, it works as a pattern
         match; the types that occur in this context in the instantiation are captured as <kbd class="calibre17">Args</kbd>. The variadic parameter <kbd class="calibre17">Args</kbd> is called a <i class="calibre6">parameter pack</i>, and the use of <kbd class="calibre17">Args...</kbd> is called a <i class="calibre6">pack expansion</i>.
      </p>
      
      <p class="noind">Like with variadic functions, the variadic part may be an empty list or may have many entries. For example, with <kbd class="calibre17">std::packaged_task&lt;my_class()&gt;</kbd> the <kbd class="calibre17">ReturnType</kbd> parameter is <kbd class="calibre17">my_class</kbd>, and the <kbd class="calibre17">Args</kbd> parameter pack is empty, whereas with <kbd class="calibre17">std::packaged_task&lt;void(int,double,my_class&amp;,std::string*)&gt;</kbd> the <kbd class="calibre17">ReturnType</kbd> is <kbd class="calibre17">void</kbd>, and <kbd class="calibre17">Args</kbd> is the list <kbd class="calibre17">int</kbd>, <kbd class="calibre17">double</kbd>, <kbd class="calibre17">my_class&amp;</kbd>, <kbd class="calibre17">std::string*</kbd>.
      </p>
      
      
      <h4 id="app01lev2sec8" class="calibre23">A.6.1. <a id="app01lev2sec8__title" class="calibre4"></a>Expanding the parameter pack
      </h4>
      
      <p class="noind">The power of variadic templates comes from what you can do with that pack expansion: you aren’t limited to expanding the list
         of types as is. First off, you can use a pack expansion directly anywhere a list of types is required, such as in the argument
         list for another template:
      </p>
      
      <pre id="PLd0e41427" class="calibre5">template&lt;typename ... Params&gt;
struct dummy
{
    std::tuple&lt;Params...&gt; data;
};</pre>
      
      <p class="noind">In this case the single member variable <kbd class="calibre17">data</kbd> is an instantiation of <kbd class="calibre17">std::tuple&lt;&gt;</kbd> containing all the types specified, so <kbd class="calibre17">dummy&lt;int,double,char&gt;</kbd> has a member of type <kbd class="calibre17">std::tuple&lt;int,double,char&gt;</kbd>. You can combine pack expansions with normal types:
      </p>
      
      <pre id="PLd0e41448" class="calibre5">template&lt;typename ... Params&gt;
struct dummy2
{
    std::tuple&lt;std::string,Params...&gt; data;
};</pre>
      
      <p class="noind">This time, the tuple has an additional (first) member of type <kbd class="calibre17">std::string</kbd>. The nifty part is that you can create a pattern with the pack expansion, which is then copied for each element in the expansion.
         You do this by putting the <kbd class="calibre17">...</kbd> that marks the pack expansion at the end of the pattern. For example, rather than just creating a tuple of the elements supplied
         in your parameter pack, you can create a tuple of pointers to the elements or even a tuple of <kbd class="calibre17">std::unique_ptr&lt;&gt;</kbd> to your elements:
      </p>
      
      <pre id="PLd0e41466" class="calibre5">template&lt;typename ... Params&gt;
struct dummy3
{
    std::tuple&lt;Params* ...&gt; pointers;
    std::tuple&lt;std::unique_ptr&lt;Params&gt; ...&gt; unique_pointers;
};</pre>
      
      <p class="noind"><a id="iddle1020" class="calibre4"></a><a id="iddle1924" class="calibre4"></a><a id="iddle2612" class="calibre4"></a>The type expression can be as complex as you like, provided the parameter pack occurs in the type expression, and provided
         the expression is followed by the <kbd class="calibre17">...</kbd> that marks the expansion. When the parameter pack is expanded, for each entry in the pack that type is substituted into the
         type expression to generate the corresponding entry in the resulting list. If your parameter pack <kbd class="calibre17">Params</kbd> contains the types <kbd class="calibre17">int,int,char</kbd>, then the expansion of <kbd class="calibre17">std::tuple&lt;std::pair&lt;std::unique_ptr&lt;Params&gt;,double&gt; ... &gt;</kbd> is <kbd class="calibre17">std::tuple&lt;std::pair&lt;std::unique_ptr&lt;int&gt;,double&gt;, std::pair&lt;std::unique_ptr&lt;int&gt;,double&gt;, std::pair&lt;std::unique_ptr&lt;char&gt;,double&gt;
            &gt;</kbd>. If the pack expansion is used as a template argument list, that template doesn’t have to have variadic parameters, but if
         it doesn’t, the size of the pack must exactly match the number of template parameters required:
      </p>
      
      <pre id="PLd0e41510" class="calibre5">template&lt;typename ... Types&gt;
struct dummy4
{
    std::pair&lt;Types...&gt; data;
};
dummy4&lt;int,char&gt; a;             <b class="calibre24"><i class="calibre6">1</i></b>
dummy4&lt;int&gt; b;                  <b class="calibre24"><i class="calibre6">2</i></b>
dummy4&lt;int,int,int&gt; c;          <b class="calibre24"><i class="calibre6">3</i></b></pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> OK, data is std::pair&lt;int,char&gt;.</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> Error; no second type.</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">3</i> Error; too many types.</b></li>
         
      </ul>
      
      <p class="noind">The second thing you can do with a pack expansion is use it to declare a list of function parameters:</p>
      
      <pre id="PLd0e41554" class="calibre5">template&lt;typename ... Args&gt;
void foo(Args ... args);</pre>
      
      <p class="noind">This creates a new parameter pack, <kbd class="calibre17">args</kbd>, which is a list of the function parameters rather than a list of types, which you can expand with <kbd class="calibre17">...</kbd> as before. Now, you can use a pattern with the pack expansion for declaring the function parameters, just as you can use
         a pattern when you expand the pack elsewhere. For example, this is used by the <kbd class="calibre17">std::thread</kbd> constructor to take all the function arguments by rvalue reference (see <a href="#app01lev1sec1" class="calibre4">section A.1</a>):
      </p>
      
      <pre id="PLd0e41575" class="calibre5">template&lt;typename CallableType,typename ... Args&gt;
thread::thread(CallableType&amp;&amp; func,Args&amp;&amp; ... args);</pre>
      
      <p class="noind">The function parameter pack can then be used to call another function, by specifying the pack expansion in the argument list
         of the called function. As with the type expansions, you can use a pattern for each expression in the resulting argument list.
         For example, one common idiom with rvalue references is to use <kbd class="calibre17">std::forward&lt;&gt;</kbd> to preserve the rvalue-ness of the supplied function arguments:
      </p>
      
      <pre id="PLd0e41589" class="calibre5">template&lt;typename ... ArgTypes&gt;
void bar(ArgTypes&amp;&amp; ... args)
{
    foo(std::forward&lt;ArgTypes&gt;(args)...);
}</pre>
      
      <p class="noind">Note that in this case, the pack expansion contains both the type pack <kbd class="calibre17">ArgTypes</kbd> and the function parameter pack <kbd class="calibre17">args</kbd>, and the ellipsis follows the whole expression. If you call <kbd class="calibre17">bar</kbd> like this,
      </p>
      
      <pre id="PLd0e41607" class="calibre5">int i;
bar(i,3.141,std::string("hello "));</pre>
      
      <p class="noind">then the expansion becomes</p>
      
      <pre id="PLd0e41616" class="calibre5">template&lt;&gt;
void bar&lt;int&amp;,double,std::string&gt;(
    int&amp; args_1,
    double&amp;&amp; args_2,
    std::string&amp;&amp; args_3)
{
    foo(std::forward&lt;int&amp;&gt;(args_1),
        std::forward&lt;double&gt;(args_2),
        std::forward&lt;std::string&gt;(args_3));
}</pre>
      
      <p class="noind">which correctly passes the first argument on to <kbd class="calibre17">foo</kbd> as an lvalue reference, while passing the others as rvalue references.
      </p>
      
      <p class="noind">The final thing you can do with a parameter pack is find its size with the <kbd class="calibre17">sizeof...</kbd> operator. This is quite simple: <kbd class="calibre17">sizeof...(p)</kbd> is the number of elements in the parameter pack <kbd class="calibre17">p</kbd>. It doesn’t matter whether this is a type parameter pack or a function argument parameter pack; the result is the same. This
         is probably the only case where you can use a parameter pack and not follow it with an ellipsis; the ellipsis is already part
         of the <kbd class="calibre17">sizeof...</kbd> operator. The following function returns the number of arguments supplied to it:
      </p>
      
      <pre id="PLd0e41643" class="calibre5">template&lt;typename ... Args&gt;
unsigned count_args(Args ... args)
{
    return sizeof... (Args);
}</pre>
      
      <p class="noind">As with the normal <kbd class="calibre17">sizeof</kbd> operator, the result of <kbd class="calibre17">sizeof...</kbd> is a constant expression, so it can be used for specifying array bounds and so forth.
      </p>
      
      
      
      
      
      <h3 id="app01lev1sec7" class="chapter"><a id="app01lev1sec7__title" class="calibre3"></a>A.7. Automatically deducing the type of a variable
      </h3>
      
      <p class="noind"><a id="iddle2341" class="calibre4"></a><a id="iddle2482" class="calibre4"></a><a id="iddle2496" class="calibre4"></a><a id="iddle2614" class="calibre4"></a>C++ is a statically typed language: the type of every variable is known at compile time. Not only that, but as a programmer
         you have to specify the type of each variable. In some cases this can lead to quite unwieldy names; for example:
      </p>
      
      <pre id="PLd0e41693" class="calibre5">std::map&lt;std::string,std::unique_ptr&lt;some_data&gt;&gt; m;
std::map&lt;std::string,std::unique_ptr&lt;some_data&gt;&gt;::iterator
    iter=m.find("my key");</pre>
      
      <p class="noind">Traditionally, the solution has been to use <kbd class="calibre17">typedef</kbd>s to reduce the length of a type identifier and potentially eliminate problems due to inconsistent types. This still works
         in C++11, but there’s now a new way: if a variable is initialized in its declaration from a value of the same type, then you
         can specify the type as <kbd class="calibre17">auto</kbd>. In this case, the compiler will automatically deduce the type of the variable to be the same as the initializer. The iterator
         example can be written as
      </p>
      
      <pre id="PLd0e41708" class="calibre5">auto iter=m.find("my key");</pre>
      
      <p class="noind">Now, you’re not restricted to plain <kbd class="calibre17">auto</kbd>; you can embellish it to declare <kbd class="calibre17">const</kbd> variables or pointer or reference variables too. Here are a few variable declarations using <kbd class="calibre17">auto</kbd> and the corresponding type of the variable:
      </p>
      
      <pre id="PLd0e41726" class="calibre5">auto i=42;        // int
auto&amp; j=i;        // int&amp;
auto const k=i;   // int const
auto* const p=&amp;i; // int * const</pre>
      
      <p class="noind">The rules for deducing the type of the variable are based on the rules for the only other place in the language where types
         are deduced: parameters of function templates. In a declaration of the form
      </p>
      
      <pre id="PLd0e41735" class="calibre5">some-type-expression-involving-auto var=some-expression;</pre>
      
      <p class="noind">the type of <kbd class="calibre17">var</kbd> is the same as the type deduced for the parameter of a function template declared with the same type expression, except replacing
         <kbd class="calibre17">auto</kbd> with the name of a template type parameter:
      </p>
      
      <pre id="PLd0e41750" class="calibre5">template&lt;typename T&gt;
void f(type-expression var);
f(some-expression);</pre>
      
      <p class="noind">This means that array types decay to pointers, and references are dropped unless the type expression explicitly declares the
         variable as a reference; for example:
      </p>
      
      <pre id="PLd0e41759" class="calibre5">int some_array[45];
auto p=some_array;   // int*
int&amp; r=*p;
auto x=r;            // int
auto&amp; y=r;           // int&amp;</pre>
      
      <p class="noind"><a id="iddle1108" class="calibre4"></a><a id="iddle2173" class="calibre4"></a><a id="iddle2272" class="calibre4"></a>This can greatly simplify the declaration of variables, particularly where the full type identifier is long or possibly not
         even known (for example, the type of the result of a function call in a template).
      </p>
      
      
      
      <h3 id="app01lev1sec8" class="chapter"><a id="app01lev1sec8__title" class="calibre3"></a>A.8. Thread-local variables
      </h3>
      
      <p class="noind">Thread-local variables allow you to have a separate instance of a variable for each thread in your program. You mark a variable
         as being thread-local by declaring it with the <kbd class="calibre17">thread_local</kbd> keyword. Variables at namespace scope, static data members of classes, and local variables can be declared thread-local,
         and are said to have <i class="calibre6">thread storage duration</i>:
      </p>
      
      <pre id="PLd0e41804" class="calibre5">thread_local int x;                        <b class="calibre24"><i class="calibre6">1</i></b>
class X
{
    static thread_local std::string s;     <b class="calibre24"><i class="calibre6">2</i></b>
};
static thread_local std::string X::s;      <b class="calibre24"><i class="calibre6">3</i></b>
void foo()
{
    thread_local std::vector&lt;int&gt; v;       <b class="calibre24"><i class="calibre6">4</i></b>
}</pre>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">1</i> A thread-local variable at namespace scope</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">2</i> A thread-local static class data member</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">3</i> The definition of X::s is required.</b></li>
         
         <li class="calibre22"><b class="calibre24"><i class="calibre6">4</i> A thread-local local variable</b></li>
         
      </ul>
      
      <p class="noind">Thread-local variables at namespace scope and thread-local static class data members are constructed before the first use
         of a thread-local variable from the same translation unit, but it isn’t specified <i class="calibre6">how much</i> before. Some implementations may construct thread-local variables when the thread is started; others may construct them immediately
         before their first use on each thread, and others may construct them at other times, or in some combination depending on their
         usage context. Indeed, if none of the thread-local variables from a given translation unit is used, there’s no guarantee that
         they will be constructed at all. This allows for the dynamic loading of modules containing thread-local variables—these variables
         can be constructed on a given thread the first time that thread references a thread-local variable from the dynamically-loaded
         module.
      </p>
      
      <p class="noind">Thread-local variables declared inside a function are initialized the first time the flow of control passes through their
         declaration on a given thread. If the function is not called by a given thread, any thread-local variables declared in that
         function are not constructed. This is the same as the behavior for local static variables, except it applies separately to
         each thread.
      </p>
      
      <p class="noind">Thread-local variables share other properties with static variables—they’re zero-initialized prior to any further initialization
         (such as dynamic initialization), and if the construction of a thread-local variable throws an exception, <kbd class="calibre17">std::terminate()</kbd> is called to abort the application.
      </p>
      
      <p class="noind">The destructors for all thread-local variables that have been constructed on a given thread are run when the thread function
         returns, in the reverse order of construction. Because the order of initialization is unspecified, it’s important to ensure
         that there are no interdependencies between the destructors of these variables. If the destructor of a thread-local variable
         exits with an exception, <kbd class="calibre17">std::terminate()</kbd> is called, as for construction.
      </p>
      
      <p class="noind">Thread-local variables are also destroyed for a thread if that thread calls <kbd class="calibre17">std::exit()</kbd> or returns from <kbd class="calibre17">main()</kbd> (which is equivalent to calling <kbd class="calibre17">std::exit()</kbd> with the return value of <kbd class="calibre17">main()</kbd>). If any other threads are still running when the application exits, the destructors of thread-local variables on those threads
         are not called.
      </p>
      
      <p class="noind">Though thread-local variables have a different address on each thread, you can still obtain a normal pointer to this variable.
         The pointer then references the object in the thread that took the address, and can be used to allow other threads to access
         that object. It’s undefined behavior to access an object after it’s been destroyed (as always), so if you pass a pointer to
         a thread-local variable to another thread, you need to ensure it’s not dereferenced once the owning thread has finished.
      </p>
      
      
      
      <h3 id="app01lev1sec9" class="chapter"><a id="app01lev1sec9__title" class="calibre3"></a>A.9. Class Template Argument Deduction
      </h3>
      
      <p class="noind">C++17 extends the idea of automatically deducing types to template parameters: if you are declaring an object of a templated
         type, then in many cases the type of the template parameters can be deduced from the object initializer.
      </p>
      
      <p class="noind">Specifically, if an object is declared with the name of a class template, without specifying a template argument list, then
         constructors specified in the class template are used to deduce the template arguments from the object’s initializer, as per
         the normal type deduction rules for function templates.
      </p>
      
      <p class="noind">For example, <kbd class="calibre17">std::lock_guard</kbd> takes a single template parameter, which is the type of the mutex. The constructor also takes a single parameter, which is
         a reference to that type. If you declare an object to be of type <kbd class="calibre17">std::lock_guard</kbd>, then the type parameter can be deduced from the type of the supplied mutex:
      </p>
      
      <pre id="PLd0e41919" class="calibre5">std::mutex m;
std::lock_guard guard(m); // deduces std::lock_guard&lt;std::mutex&gt;</pre>
      
      <p class="noind">The same applies to <kbd class="calibre17">std::scoped_lock</kbd>, except that it has multiple template parameters, which can be deduced from multiple mutex arguments:
      </p>
      
      <pre id="PLd0e41931" class="calibre5">std::mutex m1;
std::shared_mutex m2;
std::scoped_lock guard(m1,m2);
// deduces std::scoped_lock&lt;std::mutex,std::shared_mutex&gt;</pre>
      
      <p class="noind">For those templates where the constructors would lead to the wrong types being deduced, the template author can write explicit
         deduction guides to ensure the correct types are deduced. But these are beyond the scope of this book.
      </p>
      
      
      
      <h3 id="app01lev1sec10" class="chapter"><a id="app01lev1sec10__title" class="calibre3"></a>Summary
      </h3>
      
      <p class="noind">This appendix has only scratched the surface of the new language features introduced with the C++11 Standard, because we’ve
         only looked at those features that actively affect the usage of the Thread Library. Other new language features include static
         assertions, strongly typed enumerations, delegating constructors, Unicode support, template aliases, and a new uniform initialization
         sequence, along with a host of smaller changes. Describing all the new features in detail is outside the scope of this book;
         it would probably require a book in itself. There are also a considerable number of changes added with C++14 and C++17, but
         again these are outside the scope of this book. The best overview of the entire set of changes to the standard at the time
         of writing is probably the documentation at cppreference.com,<sup class="calibre18">[<a href="#app01fn01" class="calibre4">1</a>]</sup> as well as Bjarne Stroustrup’s C++11 FAQ,<sup class="calibre18">[<a href="#app01fn02" class="calibre4">2</a>]</sup> though popular C++ reference books will be revised to cover it in due course.
      </p>
      <blockquote class="smaller">
         <p class="calibre19"><sup class="calibre20"><a id="app01fn01" class="calibre4">1</a></sup> 
            </p><div class="calibre15"><a href="http://www.cppreference.com" class="calibre4">http://www.cppreference.com</a></div>
         <p class="calibre19"></p>
      </blockquote>
      <blockquote class="smaller">
         <p class="calibre19"><sup class="calibre20"><a id="app01fn02" class="calibre4">2</a></sup> 
            </p><div class="calibre15"><a href="http://www.research.att.com/~bs/C++0xFAQ.html" class="calibre4">http://www.research.att.com/~bs/C++0xFAQ.html</a></div>
         <p class="calibre19"></p>
      </blockquote>
      
      <p class="noind">Hopefully the brief introduction to the new features covered in this appendix has provided enough depth to show how they relate
         to the Thread Library and to enable you to write and understand multithreaded code that uses these new features. Although
         this appendix should provide enough depth for simple uses of the features covered, this is still only a brief introduction
         and not a complete reference or tutorial for the use of these features. If you intend to make extensive use of them, I recommend
         acquiring a reference or tutorial in order to gain the most benefit from them.
      </p>
      
      
      </body></html>
