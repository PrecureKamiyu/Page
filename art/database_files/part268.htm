<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>14.8  Write-Optimized Index Structures</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part267.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part269.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 72pt;text-indent: 0pt;text-align: left;">14.8  <span style=" color: #00AEEF;">Write-Optimized Index Structures</span></p><p style="padding-top: 11pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">One of the drawbacks of the B<span class="s181">+</span>-tree index structure is that performance can be quite poor with random writes. Consider an index that is too large to ﬁt in memory; since the bulk of the space is at the leaf level, and memory sizes are quite large these days, we assume for simplicity that higher levels of the index ﬁt in memory.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Now suppose writes or inserts are done in an order that does not match the sort order of the index. Then, each write/insert is likely to touch a diﬀerent leaf node; if the number of leaf nodes is signiﬁcantly larger than the buﬀer size, most of these leaf ac- cesses would require a random read operation, as well asa subsequent write operation</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">to write the updated leaf page back to disk. On a system with a magnetic disk, with a 10-millisecond access time, the index would support not more than 100 writes/inserts per second per disk; and this is an optimistic estimate, assuming that the seek takes the bulk of the time, and the head has not moved between the read and the write of a leaf page. On a system with ﬂash based <span class="s44">SSD</span>s, random <span class="s44">I/O </span>is much faster, but a page write still has a signiﬁcant cost since it (eventually) requires a page erase, which is an expensive operation. Thus, the basic B<span class="s181">+</span>-tree structure is not ideal for applications that need to support a very large number of random writes/inserts per second.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Several alternative index structures have been proposed to handle workloads with a high write/insert rate. The <span class="s63">log-structured merge tree </span>or <span class="s44">LSM </span>tree and its variants are write-optimized index structures that have seen very signiﬁcant adoption. The buﬀer tree is an alternative approach, which can be used with a variety of search tree struc- tures. We outline these structures in the rest of this section.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">14.8.1 LSM Trees</p><p style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;line-height: 93%;text-align: justify;">An <span class="s44">LSM </span>tree consists of several B<span class="s181">+</span>-trees, starting with an in-memory tree, called <i>L</i><span class="s98">0</span>, and on-disk trees <i>L</i><span class="s98">1</span>, <i>L</i><span class="s98">2</span>, <span class="s15">… </span>, <i>L</i><span class="s97">k </span>for some <i>k</i>, where <i>k </i>is called the level. Figure 14.26 depicts the structure of an <span class="s44">LSM </span>tree for <i>k </i><span class="s15">= </span>3.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">An index lookup is performed by using separate lookup operations on each of the trees <i>L</i><span class="s98">0</span>, <span class="s15">… </span>, <i>L</i><span class="s145">k</span>, and merging the results of the lookups. (We assume for now that there are only inserts, and no updates or deletes; index lookups in the presence of updates/deletes are more complicated and are discussed later.)</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When a record is ﬁrst inserted into an <span class="s44">LSM </span>tree, it is inserted into the in-memory B<span class="s181">+</span>-tree structure <i>L</i><span class="s98">0</span>. A fairly large amount of memory space is allocated for this tree. The tree grows as more inserts are processed, until it ﬁlls the memory allocated to it. At this point, we need to move data from the in-memory structure to a B<span class="s181">+</span>-tree on disk.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="240" height="34" alt="image" src="Image_2723.png"/></span></p><p class="s109" style="text-indent: 0pt;line-height: 8pt;text-align: left;">L<span class="s358">0</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s119" style="text-indent: 0pt;line-height: 8pt;text-align: left;">Memory</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="29" alt="image" src="Image_2724.png"/></span></p><p class="s109" style="padding-top: 5pt;padding-left: 45pt;text-indent: 0pt;text-align: center;">L<span class="s358">1</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="47" height="48" alt="image" src="Image_2725.png"/></span></p><p class="s119" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">Disk</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s109" style="padding-left: 46pt;text-indent: 0pt;text-align: center;">L<span class="s358">2</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="69" height="73" alt="image" src="Image_2726.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s109" style="padding-top: 7pt;text-indent: 0pt;text-align: left;">L<span class="s358">3</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s73" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: center;">Figure 14.26 <span class="s74">Log-structured merge tree with three levels.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-top: 4pt;padding-left: 119pt;text-indent: 17pt;text-align: justify;"><span class="p">If tree </span>L<span class="s98">1</span><span class="p"> is empty, the entire in-memory tree </span>L<span class="s98">0</span><span class="p"> is written to disk to create the initial tree </span>L<span class="s98">1</span><span class="p">. However, if </span>L<span class="s98">1</span><span class="p"> is not empty, the leaf level of </span>L<span class="s98">0</span><span class="p"> is scanned in increasing key order, and entries are merged with the leaf level entries of </span>L<span class="s98">1</span><span class="p"> (also scanned in increasing key order). The merged entries are used to create a new B</span><span class="s181">+</span><span class="p">-tree, using the bottom-up build process. The new tree with the merged entries then replaces the old </span>L<span class="s93">1</span><span class="s94">. In either case, after entries of </span>L<span class="s93">0 </span><span class="s94">have been moved to </span>L<span class="s93">1</span><span class="s94">, all entries in </span>L<span class="s93">0 </span><span class="s94">as well</span></p><p style="padding-left: 119pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">as the old <i>L</i><span class="s98">1</span>, if it existed, are deleted. Inserts can then be made to the now empty <i>L</i><span class="s98">0</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">in-memory.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Note that all entries in the leaf level of the old <i>L</i><span class="s98">1</span> tree, including those in leaf nodes that do not have any updates, are copied to the new tree instead of performing updates on the existing <i>L</i><span class="s98">1</span> tree node. This gives the following beneﬁts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: -16pt;text-align: justify;"><span class="s63">1. </span>The leaves of the new tree are sequentially located, avoiding random <span class="s44">I/O </span>during subsequent merges.</p><p class="s63" style="padding-top: 6pt;padding-left: 145pt;text-indent: -17pt;text-align: justify;">2. <span class="p">The leaves are full, avoiding the overhead of partially occupied leaves that can occur with page splits.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">There is, however, a cost to using the <span class="s44">LSM </span>structure as described above: the entire contents of the tree are copied each time a set of entries from <i>L</i><span class="s98">0</span> are copied into <i>L</i><span class="s98">1</span>. One of two techniques is used to reduce this cost:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 145pt;text-indent: -16pt;line-height: 94%;text-align: justify;"><span class="s63">1. </span><span class="p">Multiple levels are used, with level </span>L<span class="s97">i</span><span class="s136">+</span><span class="s130">1 </span><span class="s94">trees having a maximum size that is </span>k <span class="p">times the maximum size of level </span>L<span class="s97">i </span><span class="p">trees. Thus, each record is written at most </span>k <span class="p">times at a particular level. The number of levels is proportional </span><span class="s15">log</span><span class="s123">k</span><span class="p">(</span>I <span class="s15">∕</span>M <span class="p">) where </span>I <span class="p">is the number of entries and </span>M <span class="p">is the number of entries that ﬁt in the in-memory tree </span>L<span class="s98">0</span><span class="p">.</span></p><p style="padding-top: 5pt;padding-left: 145pt;text-indent: -17pt;line-height: 13pt;text-align: justify;"><span class="s63">2. </span>Each level (other than <i>L</i><span class="s98">0</span>) can have up to some number <i>b </i>of trees, instead of just 1 tree. When an <i>L</i><span class="s98">0</span> tree is written to disk, a new <i>L</i><span class="s98">1</span> tree is created instead of merging it with an existing <i>L</i><span class="s98">1</span> tree. When there are <i>b </i>such <i>L</i><span class="s98">1</span> trees, they are merged into a single new <i>L</i><span class="s98">2</span> tree. Similarly, when there are <i>b </i>trees at level <i>L</i><span class="s97">i </span>they are merged into a new <i>L</i><span class="s145">i</span><span class="s171">+</span><span class="s93">1 </span><span class="s94">tree.</span></p><p style="padding-left: 145pt;text-indent: 15pt;text-align: justify;">This variant of the <span class="s44">LSM </span>tree is called a <span class="s63">stepped-merge index</span>. The stepped- merge index decreases the insert cost signiﬁcantly compared to having only one tree per level, but it can result in an increase in query cost, since multiple trees may need to be searched. Bitmap-based structures called <i>Bloom filters</i>, described in Section 24.1, are used to reduce the number of lookups by eﬃciently detecting that a search key is not present in a particular tree. Bloom ﬁlters occupy very little space, but they are quite eﬀective at reducing query cost.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;">Details of all these variants of <span class="s44">LSM </span>trees can be found in Section 24.2.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">So far we have only described inserts and lookups. Deletes are handled in an in- teresting manner. Instead of directly ﬁnding an index entry and deleting it, deletion</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">results in insertion of a new <span class="s63">deletion entry </span>that indicates which index entry is to be deleted. The process of inserting a deletion entry is identical to the process of inserting a normal index entry.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">However, lookups have to carry out an extra step. As mentioned earlier, lookups retrieve entries from all the trees and merge them in sorted order of key value. If there is a deletion entry for some entry, both of them would have the same key value. Thus, a lookup would ﬁnd both the deletion entry and the original entry for that key, which is to be deleted. If a deletion entry is found, the to-be-deleted entry is ﬁltered out and not returned as part of the lookup result.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">When trees are merged, if one of the trees contains an entry, and the other had a matching deletion entry, the entries get matched up during the merge (both would have the same key), and are both discarded.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Updates are handled in a manner similar to deletes, by inserting an update entry. Lookups need to match update entries with the original entries and return the latest value. The update is actually applied during a merge, when one tree has an entry and another has its matching update entry; the merge process would ﬁnd a record and an update record with the same key, apply the update, and discard the update entry.</p><p class="s42" style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">LSM <span class="s43">trees were initially designed to reduce the write and seek overheads of mag- netic disks. Flash based </span>SSD<span class="s43">s have a relatively low overhead for random </span>I/O <span class="s43">operations since they do not require seek, and thus the beneﬁt of avoiding random </span>I/O <span class="s43">that </span>LSM <span class="s43">tree variants provide is not particularly important with </span>SSD<span class="s43">s.</span></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">However, recall that ﬂash memory does not allow in-place update, and writing even a single byte to a page requires the whole page to be rewritten to a new physical location; the original location of the page needs to be erased eventually, which is a relatively expensive operation. The reduction in number of writes using <span class="s44">LSM </span>tree variants, as compared to traditional B<span class="s181">+</span>-trees, can provide substantial performance beneﬁts when <span class="s44">LSM </span>trees are used with <span class="s44">SSD</span>s.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: right;">A variant of the <span class="s44">LSM </span>tree similar to the stepped-merge index, with multiple trees in each layer, was used in Google’s BigTable system, as well as in Apache HBase, the open source clone of BigTable. These systems are built on top of distributed ﬁle systems that allow appends to ﬁles but do not support updates to existing data. The fact that <span class="s44">LSM </span>trees do not perform in-place update made <span class="s44">LSM </span>trees a very good ﬁt for these systems. Subsequently, a large number of BigData storage systems such as Apache Cas- sandra, Apache AsterixDB, and MongoDB added support for <span class="s44">LSM </span>trees, with most implementing versions with multiple trees in each layer. <span class="s44">LSM </span>trees are also supported in MySQL (using the MyRocks storage engine) and in the embedded database systems</p><p style="padding-left: 88pt;text-indent: 0pt;text-align: justify;">SQLite4 and LevelDB.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-top: 7pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">14.8.2 Buffer Tree</p><p style="padding-top: 6pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;">The buﬀer tree is an alternative to the log-structured merge tree approach. The key idea behind the <span class="s63">buﬀer tree </span>is to associate a buﬀer with each internal node of a B<span class="s181">+</span>-tree,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="233" height="39" alt="image" src="Image_2727.png"/></span></p><p class="s42" style="padding-top: 2pt;padding-left: 73pt;text-indent: 0pt;text-align: center;">Buﬀer</p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 3pt;text-indent: 0pt;line-height: 74%;text-align: left;">p<span class="s359">6</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 2pt;text-indent: 0pt;line-height: 13pt;text-align: left;">k <span class="s93">5</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 4pt;text-indent: 0pt;line-height: 74%;text-align: left;">p<span class="s359">5</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 2pt;text-indent: 0pt;line-height: 13pt;text-align: left;">k <span class="s93">4</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 5pt;text-indent: 0pt;line-height: 74%;text-align: left;">p<span class="s359">4</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 2pt;text-indent: 0pt;line-height: 13pt;text-align: left;">k <span class="s93">3</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 4pt;text-indent: 0pt;line-height: 74%;text-align: left;">p<span class="s359">3</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 3pt;text-indent: 0pt;line-height: 13pt;text-align: left;">k <span class="s93">2</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 4pt;text-indent: 0pt;line-height: 74%;text-align: left;">p<span class="s359">2</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 3pt;text-indent: 0pt;line-height: 13pt;text-align: left;">k <span class="s93">1</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s69" style="padding-left: 3pt;text-indent: 0pt;line-height: 74%;text-align: left;">p<span class="s359">1</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s42" style="padding-left: 84pt;text-indent: 0pt;text-align: center;">Internal node</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s73" style="padding-top: 4pt;padding-left: 174pt;text-indent: 0pt;text-align: left;">Figure 14.27 <span class="s74">Structure of an internal node of a buffer tree.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: justify;">including the root node; this is depicted pictorially in Figure 14.27. We ﬁrst outline how inserts and lookups are handled, and subsequently we outline how deletes and updates are handled.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">When an index record is inserted into the buﬀer tree, instead of traversing the tree to the leaf, the index record is inserted into the buﬀer of the root. If the buﬀer becomes full, each index record in the buﬀer is pushed one level down the tree to the appropriate child node. If the child node is an internal node, the index record is added to the child node’s buﬀer; if that buﬀer is full, all records in that buﬀer are similarly pushed down. All records in a buﬀer are sorted on the search key before being pushed down. If the child node is a leaf node, index records are inserted into the leaf in the usual manner. If the insert results in an overfull leaf node, the node is split in the usual B<span class="s181">+</span>-tree manner, with the split potentially propagating to parent nodes. Splitting of an overfull internal node is done in the usual way, with the additional step of also splitting the buﬀer; the buﬀer entries are partitioned between the two split nodes based on their key values.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Lookups are done by traversing the B<span class="s181">+</span>-tree structure in the usual way, to ﬁnd leaves that contain records matching the lookup key. But there is one additional step: at each internal node traversed by a lookup, the node’s buﬀer must be examined to see if there are any records matching the lookup key. Range lookups are done as in a normal B<span class="s181">+</span>- tree, but they must also examine the buﬀers of all internal nodes above any of the leaf nodes that are accessed.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Suppose the buﬀer at an internal node holds <i>k </i>times as many records as there are child nodes. Then, on average, <i>k </i>records would be pushed down at a time to each child (regardless of whether the child is an internal node or a leaf node). Sorting of records before they are pushed ensures that all these records are pushed down consecutively. The beneﬁt of the buﬀer-tree approach for inserts is that the cost of accessing the child node from storage, and of writing the updated node back, is amortized (divided), on average, between <i>k </i>records. With suﬃciently large <i>k</i>, the savings can be quite signiﬁcant compared to inserts in a regular B<span class="s181">+</span>-tree.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Deletes and updates can be processed in a manner similar to <span class="s44">LSM </span>trees, using deletion entries or update entries. Alternatively, deletes and updates could be processed using the normal B<span class="s181">+</span>-tree algorithms, at the risk of a higher <span class="s44">I/O </span>cost per delete/update as compared to the cost when using deletion/update entries.</p><p style="padding-left: 119pt;text-indent: 17pt;text-align: justify;">Buﬀer trees provide better worst-case complexity bounds on the number of <span class="s44">I/O </span>operations than do <span class="s44">LSM </span>tree variants. In terms of read cost, buﬀer trees are signiﬁcantly faster than <span class="s44">LSM </span>trees. However, write operations on buﬀer trees involve random <span class="s44">I/O</span>,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 88pt;text-indent: 0pt;text-align: justify;"><a name="bookmark284">requiring more seeks, in contrast to sequential </a><span class="s44">I/O </span>operations with <span class="s44">LSM </span>tree variants. For magnetic disk storage, the high cost of seeks results in buﬀer trees performing worse than <span class="s44">LSM </span>trees on write-intensive workloads. <span class="s44">LSM </span>trees have thus found greater acceptance for write-intensive workloads with data stored on magnetic disk. However, since random <span class="s44">I/O </span>operations are very eﬃcient on <span class="s44">SSD</span>s, and buﬀer trees tend to perform fewer write operations overall compared to <span class="s44">LSM </span>trees, buﬀer trees can provide better write performance on <span class="s44">SSD</span>s. Several index structures designed for ﬂash storage make use of the buﬀer concept introduced by buﬀer trees.<a name="bookmark317">&zwnj;</a></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Another beneﬁt of buﬀer trees is that the key idea of associating buﬀers with inter- nal nodes, to reduce the number of writes, can be used with any type of tree-structured index. For example, buﬀering has been used as a way of supporting bulk loading of spa- tial indices such as R-trees (which we study in Section 14.10.1), as well as other types of indices, for which sorting and bottom-up construction are not applicable.</p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">Buﬀer trees have been implemented as part of the <span class="s63">Generalized Search Tree </span>(<span class="s63">GiST</span>) index structure in <span class="s44">P</span>ostgre<span class="s44">SQL</span>. The GiST index allows user-deﬁned code to be executed to implement search, update, and split operations on nodes and has been used to im- plement R-trees and other spatial index structures.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part267.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part269.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
