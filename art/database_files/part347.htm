<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.1   Failure Classification</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part346.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part348.htm">下一个 &gt;</a></p><p class="s65" style="padding-top: 9pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">19.1   <span style=" color: #00AEEF;">Failure Classification</span></p><p style="padding-top: 12pt;padding-left: 119pt;text-indent: 0pt;text-align: justify;">There are various types of failure that may occur in a system, each of which needs to be dealt with in a diﬀerent manner. In this chapter, we shall consider only the following types of failure:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: left;">• <span class="s63">Transaction failure</span><span class="p">. There are two types of errors that may cause a transaction to fail:</span></p><p class="s50" style="padding-top: 9pt;padding-left: 153pt;text-indent: -8pt;line-height: 77%;text-align: left;">° <span class="s63">Logical error</span><span class="p">. The transaction can no longer continue with its normal execution because of some internal condition, such as bad input, data not found, overﬂow,</span></p><p style="padding-left: 153pt;text-indent: 0pt;text-align: left;">or resource limit exceeded.</p><p class="s50" style="padding-top: 8pt;padding-left: 153pt;text-indent: -8pt;line-height: 76%;text-align: left;">° <span class="s63">System error</span><span class="p">. The system has entered an undesirable state (e.g., deadlock), as a result of which a transaction cannot continue with its normal execution. The</span></p><p style="padding-left: 153pt;text-indent: 0pt;text-align: left;">transaction, however, can be reexecuted at a later time.</p><p class="s20" style="padding-top: 8pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">907</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><a name="bookmark396">• </a><span class="s63">System crash</span><span class="p">. There is a hardware malfunction, or a bug in the database software or the operating system, that causes the loss of the content of volatile storage and brings transaction processing to a halt. The content of non-volatile storage remains intact and is not corrupted.</span><a name="bookmark436">&zwnj;</a></p><p style="padding-left: 107pt;text-indent: 14pt;text-align: justify;">The assumption that hardware errors and bugs in the software bring the system to a halt, but do not corrupt the non-volatile storage contents, is known as the <span class="s63">fail-stop assumption</span>. Well-designed systems have numerous internal checks, at the hardware and the software level, that bring the system to a halt when there is an error. Hence, the fail-stop assumption is a reasonable one.</p><p style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span><span class="s63">Disk failure</span>. A disk block loses its content as a result of either a head crash or fail- ure during a data-transfer operation. Copies of the data on other disks, or archival backups on tertiary media, such as <span class="s44">DVD </span>or tapes, are used to recover from the failure.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 17pt;text-align: justify;">To determine how the system should recover from failures, we need to identify the failure modes of those devices used for storing data. Next, we must consider how these failure modes aﬀect the contents of the database. We can then propose algorithms to ensure database consistency and transaction atomicity despite failures. These algo- rithms, known as recovery algorithms, have two parts:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s63" style="padding-left: 113pt;text-indent: -16pt;text-align: justify;">1. <span class="p">Actions taken during normal transaction processing to ensure that enough infor- mation exists to allow recovery from failures.</span></p><p class="s63" style="padding-top: 6pt;padding-left: 113pt;text-indent: -17pt;text-align: justify;">2. <span class="p">Actions taken after a failure to recover the database contents to a state that en- sures database consistency, transaction atomicity, and durability.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part346.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part348.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
