<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.11  Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part356.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part358.htm">下一个 &gt;</a></p><p class="s65" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">19.11  <span style=" color: #00AEEF;">Summary</span></p><p class="s39" style="padding-top: 9pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">A computer system, like any other mechanical or electrical device, is subject to failure. There are a variety of causes of such failure, including disk crash, power failure, and software errors. In each of these cases, information concerning the database system is lost.</span></p><p class="s66" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">19.11 <span style=" color: #00AEEF;">Summary  </span><span class="s164">949</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">In addition to system failures, transactions may also fail for various reasons, such as violation of integrity constraints or deadlocks.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">An integral part of a database system is a recovery scheme that is responsible for the detection of failures and for the restoration of the database to a state that existed before the occurrence of the failure.</span></p><p class="s40" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>The various types of storage in a computer are volatile storage, non-volatile storage, and stable storage. Data in volatile storage, such as in <span class="s41">RAM</span>, are lost when the computer crashes. Data in non-volatile storage, such as disk, are not lost when the computer crashes but may occasionally be lost because of failures such as disk crashes. Data in stable storage are never lost.</p><p class="s40" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>Stable storage that must be accessible online is approximated with mirrored disks, or other forms of <span class="s41">RAID</span>, which provide redundant data storage. Oﬄine, or archival, stable storage may consist of multiple tape copies of data stored in a physically secure location.</p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">In case of failure, the state of the database system may no longer be consistent; that is, it may not reﬂect a state of the world that the database is supposed to capture. To preserve consistency, we require that each transaction be atomic. It is the responsibility of the recovery scheme to ensure the atomicity and durability property.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">In log-based schemes, all updates are recorded on a log, which must be kept in stable storage. A transaction is considered to have committed when its last log record, which is the </span><span class="s49">commit </span><span class="p">log record for the transaction, has been output to stable storage.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Log records contain old values and new values for all updated data items. The new values are used in case the updates need to be redone after a system crash. The old values are used to roll back the updates of the transaction if the transaction aborts during normal operation, as well as to roll back the updates of the transaction in case the system crashed before the transaction committed.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">In the deferred-modiﬁcations scheme, during the execution of a transaction, all the </span><span class="s49">write </span><span class="p">operations are deferred until the transaction has been committed, at which time the system uses the information on the log associated with the transaction in executing the deferred writes. With deferred modiﬁcation, log records do not need to contain old values of updated data items.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">To reduce the overhead of searching the log and redoing transactions, we can use checkpointing techniques.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 139pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Modern recovery algorithms are based on the concept of repeating history, whereby all actions taken during normal operation (since the last completed check- point) are replayed during the redo pass of recovery. Repeating history restores</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 107pt;text-indent: 0pt;text-align: justify;">the system state to what it was at the time the last log record was output to sta- ble storage before the system crashed. Undo is then performed from this state by executing an undo pass that processes log records of incomplete transactions in reverse order.</p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Undo of an incomplete transaction writes out special redo-only log records and an </span><span class="s49">abort </span><span class="p">log record. After that, the transaction can be considered to have completed, and it will not be undone again.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Transaction processing is based on a storage model in which main memory holds a log buﬀer, a database buﬀer, and a system buﬀer. The system buﬀer holds pages of system object code and local work areas of transactions.</span></p><p class="s39" style="padding-top: 4pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Eﬃcient implementation of a recovery scheme requires that the number of writes to the database and to stable storage be minimized. Log records may be kept in volatile log buﬀer initially, but they must be written to stable storage when one of the following conditions occurs:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s83" style="padding-left: 122pt;text-indent: -8pt;line-height: 70%;text-align: left;"><span class="s50">° </span><span class="s51">Before the </span>&lt;<span class="s13">T</span><span class="s145">i </span><span class="s49">commit</span>&gt; <span class="p">log record may be output to stable storage, all log records pertaining to transaction </span><span class="s13">T</span><span class="s145">i </span><span class="p">must have been output to stable storage.</span></p><p class="s50" style="padding-top: 7pt;padding-left: 122pt;text-indent: -8pt;line-height: 77%;text-align: left;">° <span class="s51">Before a block of data in main memory is output to the database (in non-volatile storage), all log records pertaining to data in that block must have been output</span></p><p style="padding-left: 122pt;text-indent: 0pt;text-align: left;">to stable storage.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s39" style="padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Remote backup systems provide a high degree of availability, allowing transaction processing to continue even if the primary site is destroyed by a ﬁre, ﬂood, or earthquake. Data and log records from a primary site are continually backed up to a remote backup site. If the primary site fails, the remote backup site takes over transaction processing, after executing certain recovery actions.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">Modern recovery techniques support high-concurrency locking techniques, such as those used for B</span><span class="s181">+</span><span class="p">-tree concurrency control. These techniques allow early re- lease of lower-level locks obtained by operations such as inserts or deletes, which allows other such operations to be performed by other transactions. After lower- level locks are released, physical undo is not possible, and instead logical undo, such as a deletion to undo an insertion, is required. Transactions retain higher- level locks that ensure that concurrent transactions cannot perform actions that could make logical undo of an operation impossible.</span></p><p class="s39" style="padding-top: 3pt;padding-left: 107pt;text-indent: -16pt;text-align: justify;">• <span class="s40">To recover from failures that result in the loss of non-volatile storage, we must dump the entire contents of the database onto stable storage periodically—say, once per day. If a failure occurs that results in the loss of physical database blocks, we use the most recent dump in restoring the database to a previous consistent state. Once this restoration has been accomplished, we use the log to bring the database system to the most recent consistent state.</span></p><p class="s64" style="padding-top: 3pt;padding-left: 119pt;text-indent: 0pt;text-align: right;">Review Terms  <span class="s164">951</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-left: 139pt;text-indent: -16pt;text-align: justify;"><span class="s39">• </span>The <span class="s41">ARIES </span>recovery scheme is a state-of-the-art scheme that supports a number of features to provide greater concurrency, reduce logging overheads, and minimize recovery time. It is also based on repeating history, and it allows logical undo operations. The scheme ﬂushes pages on a continuous basis and does not need to ﬂush all pages at the time of a checkpoint. It uses log sequence numbers (LSNs) to implement a variety of optimizations that reduce the time taken for recovery.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part356.htm">&lt; 上一个</a><span> | </span><a href="../database.html">内容</a><span> | </span><a href="part358.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
