<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mbp="Kindle">
  <head>
    <title>C++ Concurrency in Action, Second Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h5 class="notetitle" id="app04lev3sec237"><a id="app04lev3sec237__title" class="calibre4"></a>std::unique_lock default constructor
      </h5>
      
      <p class="noind"><a id="iddle2385" class="calibre4"></a><a id="iddle2389" class="calibre4"></a><a id="iddle2390" class="calibre4"></a>Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance with no associated mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">unique_lock() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that has no associated mutex.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;mutex()==NULL, this-&gt;owns_lock()==false.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec238"><a id="app04lev3sec238__title" class="calibre4"></a>std::unique_lock locking constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that locks the supplied mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">explicit unique_lock(mutex_type&amp; m);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.lock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">m.lock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==true, this-&gt;mutex()==&amp;m.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec239"><a id="app04lev3sec239__title" class="calibre4"></a>std::unique_lock lock-adopting constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that owns the lock on the supplied mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">unique_lock(mutex_type&amp; m,std::adopt_lock_t);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must own a lock on <kbd class="calibre17">m</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that references the supplied mutex and takes ownership of the lock on <kbd class="calibre17">m</kbd> held by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==true, this-&gt;mutex()==&amp;m.</pre>
            </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec240"><a id="app04lev3sec240__title" class="calibre4"></a>std::unique_lock deferred-lock constructor
      </h5>
      
      <p class="noind"><a id="iddle1308" class="calibre4"></a><a id="iddle2386" class="calibre4"></a><a id="iddle2394" class="calibre4"></a><a id="iddle2395" class="calibre4"></a><a id="iddle2588" class="calibre4"></a>Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that doesn’t own the lock on the supplied mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">unique_lock(mutex_type&amp; m,std::defer_lock_t) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that references the supplied mutex.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==false, this-&gt;mutex()==&amp;m.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec241"><a id="app04lev3sec241__title" class="calibre4"></a>std::unique_lock try-to-lock constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance associated with the supplied mutex and tries to acquire a lock on that mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">unique_lock(mutex_type&amp; m,std::try_to_lock_t);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::unique_lock</kbd> must meet the <kbd class="calibre17">Lockable</kbd> requirements.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.try_lock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns the result of the <kbd class="calibre17">m.try_lock()</kbd> call, <kbd class="calibre17">this-&gt;mutex()==&amp;m</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec242"><a id="app04lev3sec242__title" class="calibre4"></a>std::unique_lock try-to-lock constructor with a duration timeout
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance associated with the supplied mutex and tries to acquire a lock on that mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
unique_lock(
    mutex_type&amp; m,
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::unique_lock</kbd> must meet the <kbd class="calibre17">Timed-Lockable</kbd> requirements.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.try_lock_for(relative_time)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2391" class="calibre4"></a><a id="iddle2396" class="calibre4"></a><a id="iddle2567" class="calibre4"></a><a id="iddle2590" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns the result of the <kbd class="calibre17">m.try_lock_for()</kbd> call, <kbd class="calibre17">this-&gt;mutex() ==&amp;m</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec243"><a id="app04lev3sec243__title" class="calibre4"></a>std::unique_lock try-to-lock constructor with a time_point timeout
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance associated with the supplied mutex and tries to acquire a lock on that mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
unique_lock(
    mutex_type&amp; m,
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::unique_lock</kbd> must meet the <kbd class="calibre17">Timed-Lockable</kbd> requirements.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.try_lock_until(absolute_time)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns the result of the <kbd class="calibre17">m.try_lock_until()</kbd> call, <kbd class="calibre17">this-&gt; mutex()==&amp;m</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec244"><a id="app04lev3sec244__title" class="calibre4"></a>std::unique_lock move-constructor
      </h5>
      
      <p class="noind">Transfers ownership of a lock from one <kbd class="calibre17">std::unique_lock</kbd> object to a newly-created <kbd class="calibre17">std::unique_lock</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">unique_lock(unique_lock&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::unique_lock</kbd> instance. If <kbd class="calibre17">other</kbd> owned a lock on a mutex prior to the constructor invocation, that lock is now owned by the newly created <kbd class="calibre17">std::unique_lock</kbd> object.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            For a newly constructed <kbd class="calibre17">std::unique_lock</kbd> object, <kbd class="calibre17">x</kbd>, <kbd class="calibre17">x.mutex()</kbd> is equal to the value of <kbd class="calibre17">other.mutex()</kbd> prior to the constructor invocation, and <kbd class="calibre17">x.owns_lock()</kbd> is equal to the value of <kbd class="calibre17">other.owns_lock()</kbd> prior to the constructor invocation. <kbd class="calibre17">other.mutex() ==NULL</kbd>, <kbd class="calibre17">other.owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note53">Note</h5>
      
      
      
      <p class="noindclose"><a id="iddle2387" class="calibre4"></a><a id="iddle2392" class="calibre4"></a><a id="iddle2401" class="calibre4"></a><kbd class="calibre17">std::unique_lock</kbd> objects are not <kbd class="calibre17">CopyConstructible</kbd>, so there’s no copy constructor, only this move constructor.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec245"><a id="app04lev3sec245__title" class="calibre4"></a>std::unique_lock move-assignment operator
      </h5>
      
      <p class="noind">Transfers ownership of a lock from one <kbd class="calibre17">std::unique_lock</kbd> object to another <kbd class="calibre17">std:: unique_lock</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">unique_lock&amp; operator=(unique_lock&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns <kbd class="calibre17">true</kbd> prior to the call, calls <kbd class="calibre17">this-&gt;unlock()</kbd>. If <kbd class="calibre17">other</kbd> owned a lock on a mutex prior to the assignment, that lock is now owned by <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;mutex()</kbd> is equal to the value of <kbd class="calibre17">other.mutex()</kbd> prior to the assignment, and <kbd class="calibre17">this-&gt;owns_lock()</kbd> is equal to the value of <kbd class="calibre17">other.owns_lock()</kbd> prior to the assignment. <kbd class="calibre17">other.mutex()==NULL</kbd>, <kbd class="calibre17">other.owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note54">Note</h5>
      
      
      <p class="noindclose"><kbd class="calibre17">std::unique_lock</kbd> objects are not <kbd class="calibre17">CopyAssignable</kbd>, so there’s no copy-assignment operator, only this move-assignment operator.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec246"><a id="app04lev3sec246__title" class="calibre4"></a>std::unique_lock destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::unique_lock</kbd> instance and unlocks the corresponding mutex if it’s owned by the destroyed instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~unique_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns <kbd class="calibre17">true</kbd>, calls <kbd class="calibre17">this-&gt;mutex()-&gt;unlock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec247"><a id="app04lev3sec247__title" class="calibre4"></a>std::unique_lock::swap member function
      </h5>
      
      <p class="noind">Exchanges ownership of their associated <kbd class="calibre17">unique_locks</kbd> of execution between two <kbd class="calibre17">std::unique_lock</kbd> objects.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void swap(unique_lock&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">other</kbd> owns a lock on a mutex prior to the call, that lock is now owned by <kbd class="calibre17">*this</kbd>. If <kbd class="calibre17">*this</kbd> owns a lock on a mutex prior to the call, that lock is now owned by <kbd class="calibre17">other</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;mutex()</kbd> is equal to the value of <kbd class="calibre17">other.mutex()</kbd> prior to the call. <kbd class="calibre17">other.mutex()</kbd> is equal to the value of <kbd class="calibre17">this-&gt;mutex()</kbd> prior to the call. <kbd class="calibre17">this-&gt;owns_lock()</kbd> <a id="iddle1691" class="calibre4"></a><a id="iddle2393" class="calibre4"></a><a id="iddle2402" class="calibre4"></a><a id="iddle2426" class="calibre4"></a>is equal to the value of <kbd class="calibre17">other.owns_lock()</kbd> prior to the call. <kbd class="calibre17">other.owns_lock()</kbd> is equal to the value of <kbd class="calibre17">this-&gt;owns_lock()</kbd> prior to the call.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec248"><a id="app04lev3sec248__title" class="calibre4"></a>swap nonmember function for std::unique_lock
      </h5>
      
      <p class="noind">Exchanges ownership of their associated mutex locks between two <kbd class="calibre17">std::unique_lock</kbd> objects.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void swap(unique_lock&amp; lhs,unique_lock&amp; rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">lhs.swap(rhs)</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec249"><a id="app04lev3sec249__title" class="calibre4"></a>std::unique_lock::lock member function
      </h5>
      
      <p class="noind">Acquires a lock on the mutex associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;mutex()!=NULL, this-&gt;owns_lock()==false.</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;lock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;lock()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt;mutex()==NULL</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::resource_deadlock_would_occur</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==true</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==true.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec250"><a id="app04lev3sec250__title" class="calibre4"></a>std::unique_lock::try_lock member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on the mutex associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::unique_lock</kbd> must meet the <kbd class="calibre17">Lockable</kbd> requirements. <kbd class="calibre17">this-&gt;mutex()!=NULL</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2404" class="calibre4"></a><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the call to <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt;mutex()==NULL</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::resource_deadlock_would_occur</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==true</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            If the function returns <kbd class="calibre17">true</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==true</kbd>, otherwise <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec251"><a id="app04lev3sec251__title" class="calibre4"></a>std::unique_lock::unlock member function
      </h5>
      
      <p class="noind">Releases a lock on the mutex associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;mutex()!=NULL, this-&gt;owns_lock()==true.</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;unlock()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;unlock()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==false</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==false.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec252"><a id="app04lev3sec252__title" class="calibre4"></a>std::unique_lock::try_lock_for member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on the mutex associated with <kbd class="calibre17">*this</kbd> within the time specified.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep, typename Period&gt;
bool try_lock_for(
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::unique_lock</kbd> must meet the <kbd class="calibre17">TimedLockable</kbd> requirements. <kbd class="calibre17">this-&gt;mutex()!=NULL</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_for(relative_time)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the call to <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_for()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_for()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt;mutex()== NULL</kbd>. <kbd class="calibre17">std::system_error</kbd> <a id="iddle2398" class="calibre4"></a><a id="iddle2403" class="calibre4"></a>with an error code of <kbd class="calibre17">std::errc::resource_deadlock_would_occur</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==true</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            If the function returns <kbd class="calibre17">true</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==true</kbd>, otherwise <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec253"><a id="app04lev3sec253__title" class="calibre4"></a>std::unique_lock::try_lock_until member function
      </h5>
      
      <p class="noind">Attempts to acquire a lock on the mutex associated with <kbd class="calibre17">*this</kbd> within the time specified.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock, typename Duration&gt;
bool try_lock_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::unique_lock</kbd> must meet the <kbd class="calibre17">Timed-Lockable</kbd> requirements. <kbd class="calibre17">this-&gt;mutex()!=NULL</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_until(absolute_time)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the call to <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_until()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_until()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt; mutex()== NULL</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::resource_deadlock_would_occur</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==true</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postcondition</i>
            If the function returns <kbd class="calibre17">true</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==true</kbd>, otherwise <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec254"><a id="app04lev3sec254__title" class="calibre4"></a>std::unique_lock::operator bool member function
      </h5>
      
      <p class="noind">Checks whether or not <kbd class="calibre17">*this</kbd> owns a lock on a mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">explicit operator bool() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock().</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note55">Note</h5>
      
      
      <p class="noindclose">This is an <kbd class="calibre17">explicit</kbd> conversion operator, so it’s only implicitly called in contexts where the result is used as a Boolean and not where the result
         would be treated as an integer value of 0 or 1.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec255"><a id="app04lev3sec255__title" class="calibre4"></a>std::unique_lock::owns_lock member function
      </h5>
      
      <p class="noind"><a id="iddle1656" class="calibre4"></a><a id="iddle2286" class="calibre4"></a><a id="iddle2397" class="calibre4"></a><a id="iddle2399" class="calibre4"></a><a id="iddle2400" class="calibre4"></a>Checks whether or not <kbd class="calibre17">*this</kbd> owns a lock on a mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool owns_lock() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if <kbd class="calibre17">*this</kbd> owns a lock on a mutex, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec256"><a id="app04lev3sec256__title" class="calibre4"></a>std::unique_lock::mutex member function
      </h5>
      
      <p class="noind">Returns the mutex associated with <kbd class="calibre17">*this</kbd> if any.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">mutex_type* mutex() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            A pointer to the mutex associated with <kbd class="calibre17">*this</kbd> if any, <kbd class="calibre17">NULL</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec257"><a id="app04lev3sec257__title" class="calibre4"></a>std::unique_lock::release member function
      </h5>
      
      <p class="noind">Returns the mutex associated with <kbd class="calibre17">*this</kbd> if any, and releases that association.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">mutex_type* release() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Breaks the association of the mutex with <kbd class="calibre17">*this</kbd> without unlocking any locks held.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            A pointer to the mutex associated with <kbd class="calibre17">*this</kbd> prior to the call if any, <kbd class="calibre17">NULL</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;mutex()==NULL, this-&gt;owns_lock()==false.</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note56">Note</h5>
      
      
      <p class="noindclose">If <kbd class="calibre17">this-&gt;owns_lock()</kbd> would have returned <kbd class="calibre17">true</kbd> prior to the call, the caller would now be responsible for unlocking the mutex.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      
      <h4 id="app04lev2sec32" class="calibre23">D.5.10. <a id="app04lev2sec32__title" class="calibre4"></a>std::shared_lock class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::shared_lock</kbd> class template provides an equivalent to <kbd class="calibre17">std::unique_lock</kbd>, except that it acquires a shared lock rather than an exclusive lock. The type of mutex being locked is specified by the
         template parameter <kbd class="calibre17">Mutex</kbd>, which must meet the <kbd class="calibre17">SharedLockable</kbd> requirements. In general, the specified mutex is locked in the constructor and unlocked in the destructor, although additional
         constructors and member functions are provided to allow other possibilities. This provides a means of locking a mutex for
         a block of code and ensuring that the mutex is unlocked when the block is left, whether that’s by running off the end, by
         the use of a control flow statement such as <kbd class="calibre17">break</kbd> or <kbd class="calibre17">return</kbd>, or by throwing an exception. All instantiations of <kbd class="calibre17">std::shared_lock</kbd> are suitable for use with the <kbd class="calibre17">Lockable</kbd> parameter for the <kbd class="calibre17">std:: condition_variable_any</kbd> wait functions.
      </p>
      
      <p class="noind">Every <kbd class="calibre17">std::shared_lock&lt;Mutex&gt;</kbd> meets the <kbd class="calibre17">Lockable</kbd> requirements. If, in addition, the supplied <kbd class="calibre17">Mutex</kbd> type meets the <kbd class="calibre17">SharedTimedLockable</kbd> requirements, then <kbd class="calibre17">std::shared_lock&lt;Mutex&gt;</kbd> also meets the <kbd class="calibre17">TimedLockable</kbd> requirements.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::shared_lock</kbd> are <kbd class="calibre17">MoveConstructible</kbd> and <kbd class="calibre17">MoveAssignable</kbd> but not <kbd class="calibre17">CopyConstructible</kbd> or <kbd class="calibre17">CopyAssignable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class Mutex&gt;
class shared_lock
{
public:
    typedef Mutex mutex_type;

    shared_lock() noexcept;
    explicit shared_lock(mutex_type&amp; m);
    shared_lock(mutex_type&amp; m, adopt_lock_t);
    shared_lock(mutex_type&amp; m, defer_lock_t) noexcept;
    shared_lock(mutex_type&amp; m, try_to_lock_t);

    template&lt;typename Clock,typename Duration&gt;
    shared_lock(
        mutex_type&amp; m,
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);

    template&lt;typename Rep,typename Period&gt;
    shared_lock(
        mutex_type&amp; m,
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);

    ~shared_lock();

    shared_lock(shared_lock const&amp; ) = delete;
    shared_lock&amp; operator=(shared_lock const&amp; ) = delete;

    shared_lock(shared_lock&amp;&amp; );
    shared_lock&amp; operator=(shared_lock&amp;&amp; );

    void swap(shared_lock&amp; other) noexcept;

    void lock();
    bool try_lock();
    template&lt;typename Rep, typename Period&gt;
    bool try_lock_for(
        std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);
    template&lt;typename Clock, typename Duration&gt;
    bool try_lock_until(
        std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);
    void unlock();

    explicit operator bool() const noexcept;
    bool owns_lock() const noexcept;
    Mutex* mutex() const noexcept;
    Mutex* release() noexcept;
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec258"><a id="app04lev3sec258__title" class="calibre4"></a>std::shared_lock default constructor
      </h5>
      
      <p class="noind"><a id="iddle2287" class="calibre4"></a><a id="iddle2288" class="calibre4"></a><a id="iddle2290" class="calibre4"></a><a id="iddle2291" class="calibre4"></a>Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance with no associated mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_lock() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that has no associated mutex.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;mutex()==NULL, this-&gt;owns_lock()==false.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec259"><a id="app04lev3sec259__title" class="calibre4"></a>std::shared_lock locking constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that acquires a shared lock on the supplied mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">explicit shared_lock(mutex_type&amp; m);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.lock_shared()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">m.lock_shared()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==true, this-&gt;mutex()==&amp;m.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec260"><a id="app04lev3sec260__title" class="calibre4"></a>std::shared_lock lock-adopting constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that owns the lock on the supplied mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_lock(mutex_type&amp; m,std::adopt_lock_t);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The calling thread must own a shared lock on <kbd class="calibre17">m</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that references the supplied mutex and takes ownership of the shared lock on <kbd class="calibre17">m</kbd> held by the calling thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==true, this-&gt;mutex()==&amp;m.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec261"><a id="app04lev3sec261__title" class="calibre4"></a>std::shared_lock deferred-lock constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that doesn’t own the lock on the supplied mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1307" class="calibre4"></a><a id="iddle2295" class="calibre4"></a><a id="iddle2589" class="calibre4"></a><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_lock(mutex_type&amp; m,std::defer_lock_t) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that references the supplied mutex.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==false, this-&gt;mutex()==&amp;m.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec262"><a id="app04lev3sec262__title" class="calibre4"></a>std::shared_lock try-to-lock constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance associated with the supplied mutex and tries to acquire a shared lock on that mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_lock(mutex_type&amp; m,std::try_to_lock_t);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::shared_lock</kbd> must meet the <kbd class="calibre17">Lockable</kbd> requirements.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.try_lock_shared()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns the result of the <kbd class="calibre17">m.try_lock_shared()</kbd> call, <kbd class="calibre17">this-&gt; mutex()==&amp;m</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec263"><a id="app04lev3sec263__title" class="calibre4"></a>std::shared_lock try-to-lock constructor with a duration timeout
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance associated with the supplied mutex and tries to acquire a shared lock on that mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
shared_lock(
    mutex_type&amp; m,
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::shared_lock</kbd> must meet the <kbd class="calibre17">SharedTimedLockable</kbd> requirements.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.try_lock_shared_for(relative_time)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2292" class="calibre4"></a><a id="iddle2296" class="calibre4"></a><a id="iddle2566" class="calibre4"></a><a id="iddle2591" class="calibre4"></a><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns the result of the <kbd class="calibre17">m.try_lock_shared_for()</kbd> call, <kbd class="calibre17">this-&gt; mutex()==&amp;m</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec264"><a id="app04lev3sec264__title" class="calibre4"></a>std::shared_lock try-to-lock constructor with a time_point timeout
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance associated with the supplied mutex and tries to acquire a shared lock on that mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
shared_lock(
    mutex_type&amp; m,
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::shared_lock</kbd> must meet the <kbd class="calibre17">SharedTimedLockable</kbd> requirements.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance that references the supplied mutex. Calls <kbd class="calibre17">m.try_lock_shared_until(absolute_time)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns the result of the <kbd class="calibre17">m.try_lock_shared_until()</kbd> call, <kbd class="calibre17">this -&gt;mutex()==&amp;m</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec265"><a id="app04lev3sec265__title" class="calibre4"></a>std::shared_lock move-constructor
      </h5>
      
      <p class="noind">Transfers ownership of a shared lock from one <kbd class="calibre17">std::shared_lock</kbd> object to a newly created <kbd class="calibre17">std::shared_lock</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_lock(shared_lock&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::shared_lock</kbd> instance. If <kbd class="calibre17">other</kbd> owned a shared lock on a mutex prior to the constructor invocation, that lock is now owned by the newly created <kbd class="calibre17">std::shared_lock</kbd> object.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            For a newly-constructed <kbd class="calibre17">std::shared_lock</kbd> object, <kbd class="calibre17">x</kbd>, <kbd class="calibre17">x.mutex()</kbd> is equal to the value of <kbd class="calibre17">other.mutex()</kbd> prior to the constructor invocation, and <kbd class="calibre17">x.owns_lock()</kbd> is equal to the value of <kbd class="calibre17">other.owns_lock()</kbd> prior to the constructor invocation. <kbd class="calibre17">other.mutex() ==NULL</kbd>, <kbd class="calibre17">other.owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note57">Note</h5>
      
      
      <p class="noindclose"><kbd class="calibre17">std::shared_lock</kbd> objects are <i class="calibre6">not</i> <kbd class="calibre17">CopyConstructible</kbd>, so there’s no copy constructor, only this move constructor.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec266"><a id="app04lev3sec266__title" class="calibre4"></a>std::shared_lock move-assignment operator
      </h5>
      
      <p class="noind"><a id="iddle2289" class="calibre4"></a><a id="iddle2293" class="calibre4"></a><a id="iddle2302" class="calibre4"></a>Transfers ownership of a shared lock from one <kbd class="calibre17">std::shared_lock</kbd> object to another <kbd class="calibre17">std::shared_lock</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">shared_lock&amp; operator=(shared_lock&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns <kbd class="calibre17">true</kbd> prior to the call, calls <kbd class="calibre17">this-&gt;unlock()</kbd>. If <kbd class="calibre17">other</kbd> owned a shared lock on a mutex prior to the assignment, that lock is now owned by <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;mutex()</kbd> is equal to the value of <kbd class="calibre17">other.mutex()</kbd> prior to the assignment, and <kbd class="calibre17">this-&gt;owns_lock()</kbd> is equal to the value of <kbd class="calibre17">other.owns_lock()</kbd> prior to the assignment. <kbd class="calibre17">other.mutex()==NULL</kbd>, <kbd class="calibre17">other.owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note58">Note</h5>
      
      
      <p class="noindclose"><kbd class="calibre17">std::shared_lock</kbd> objects are not <kbd class="calibre17">CopyAssignable</kbd>, so there’s no copy-assignment operator, only this move-assignment operator.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec267"><a id="app04lev3sec267__title" class="calibre4"></a>std::shared_lock destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::shared_lock</kbd> instance and unlocks the corresponding mutex if it’s owned by the destroyed instance.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~shared_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">this-&gt;owns_lock()</kbd> returns <kbd class="calibre17">true</kbd>, calls <kbd class="calibre17">this-&gt;mutex()-&gt;unlock_shared()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec268"><a id="app04lev3sec268__title" class="calibre4"></a>std::shared_lock::swap member function
      </h5>
      
      <p class="noind">Exchanges ownership of their associated <kbd class="calibre17">shared_locks</kbd> of execution between two <kbd class="calibre17">std::shared_lock</kbd> objects.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void swap(shared_lock&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">other</kbd> owns a lock on a mutex prior to the call, that lock is now owned by <kbd class="calibre17">*this</kbd>. If <kbd class="calibre17">*this</kbd> owns a lock on a mutex prior to the call, that lock is now owned by <kbd class="calibre17">other</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;mutex()</kbd> is equal to the value of <kbd class="calibre17">other.mutex()</kbd> prior to the call. <kbd class="calibre17">other.mutex()</kbd> is equal to the value of <kbd class="calibre17">this-&gt;mutex()</kbd> prior to the call. <kbd class="calibre17">this-&gt;owns_lock()</kbd> is equal to the value of <kbd class="calibre17">other.owns_lock()</kbd> prior to the call. <kbd class="calibre17">other.owns_lock()</kbd> is equal to the value of <kbd class="calibre17">this-&gt;owns_lock()</kbd> prior to the call.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1689" class="calibre4"></a><a id="iddle2294" class="calibre4"></a><a id="iddle2297" class="calibre4"></a><a id="iddle2303" class="calibre4"></a><a id="iddle2424" class="calibre4"></a><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec269"><a id="app04lev3sec269__title" class="calibre4"></a>swap nonmember function for std::shared_lock
      </h5>
      
      <p class="noind">Exchanges ownership of their associated mutex locks between two <kbd class="calibre17">std::shared_lock</kbd> objects.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void swap(shared_lock&amp; lhs,shared_lock&amp; rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">lhs.swap(rhs)</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec270"><a id="app04lev3sec270__title" class="calibre4"></a>std::shared_lock::lock member function
      </h5>
      
      <p class="noind">Acquires a shared lock on the mutex associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;mutex()!=NULL, this-&gt;owns_lock()==false.</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;lock_shared()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;lock_shared()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt;mutex() ==NULL</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::resource_deadlock_would_occur</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==true</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==true.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec271"><a id="app04lev3sec271__title" class="calibre4"></a>std::shared_lock::try_lock member function
      </h5>
      
      <p class="noind">Attempts to acquire a shared lock on the mutex associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool try_lock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::shared_lock</kbd> must meet the <kbd class="calibre17">Lockable</kbd> requirements. <kbd class="calibre17">this-&gt;mutex()!=NULL</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the call to <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2304" class="calibre4"></a><a id="iddle2306" class="calibre4"></a><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt;mutex()== NULL</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::resource_deadlock_would_occur</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==true</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            If the function returns <kbd class="calibre17">true</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==true</kbd>, otherwise <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec272"><a id="app04lev3sec272__title" class="calibre4"></a>std::shared_lock::unlock member function
      </h5>
      
      <p class="noind">Releases a shared lock on the mutex associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void unlock();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;mutex()!=NULL, this-&gt;owns_lock()==true.</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;unlock_shared()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;unlock_shared()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt;owns_lock() == false</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock()==false.</pre>
            </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec273"><a id="app04lev3sec273__title" class="calibre4"></a>std::shared_lock::try_lock_for member function
      </h5>
      
      <p class="noind">Attempts to acquire a shared lock on the mutex associated with <kbd class="calibre17">*this</kbd> within the time specified.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep, typename Period&gt;
bool try_lock_for(
    std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::shared_lock</kbd> must meet the <kbd class="calibre17">SharedTimedLockable</kbd> requirements. <kbd class="calibre17">this-&gt;mutex()!=NULL</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared_for(relative_time)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the call to <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared_for()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared_for()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt; mutex()==NULL</kbd>. <kbd class="calibre17">std::system_error</kbd> <a id="iddle2299" class="calibre4"></a><a id="iddle2305" class="calibre4"></a>with an error code of <kbd class="calibre17">std::errc::resource_deadlock_would_occur</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==true</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            If the function returns <kbd class="calibre17">true</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==true</kbd>, otherwise <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec274"><a id="app04lev3sec274__title" class="calibre4"></a>std::shared_lock::try_lock_until member function
      </h5>
      
      <p class="noind">Attempts to acquire a shared lock on the mutex associated with <kbd class="calibre17">*this</kbd> within the time specified.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock, typename Duration&gt;
bool try_lock_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The <kbd class="calibre17">Mutex</kbd> type used to instantiate <kbd class="calibre17">std::shared_lock</kbd> must meet the <kbd class="calibre17">SharedTimedLockable</kbd> requirements. <kbd class="calibre17">this-&gt;mutex()!=NULL</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Calls <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared_until(absolute_time)</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the call to <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared_until()</kbd> returned <kbd class="calibre17">true</kbd>, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by <kbd class="calibre17">this-&gt;mutex()-&gt;try_lock_shared_until()</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::operation_not_permitted</kbd> if <kbd class="calibre17">this-&gt; mutex()==NULL</kbd>. <kbd class="calibre17">std::system_error</kbd> with an error code of <kbd class="calibre17">std::errc::resource_deadlock_would_occur</kbd> if <kbd class="calibre17">this-&gt;owns_lock()==true</kbd> on entry.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postcondition</i>
            If the function returns <kbd class="calibre17">true</kbd>, <kbd class="calibre17">this-&gt;owns_lock()==true</kbd>, otherwise <kbd class="calibre17">this-&gt;owns_lock()==false</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec275"><a id="app04lev3sec275__title" class="calibre4"></a>std::shared_lock::operator bool member function
      </h5>
      
      <p class="noind">Checks whether or not <kbd class="calibre17">*this</kbd> owns a shared lock on a mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">explicit operator bool() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;owns_lock().</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note59">Note</h5>
      
      
      <p class="noindclose">This is an <kbd class="calibre17">explicit</kbd> conversion operator, so it’s only implicitly called in contexts where the result is used as a Boolean and not where the result
         would be treated as an integer value of 0 or 1.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec276"><a id="app04lev3sec276__title" class="calibre4"></a>std::shared_lock::owns_lock member function
      </h5>
      
      <p class="noind"><a id="iddle2298" class="calibre4"></a><a id="iddle2300" class="calibre4"></a><a id="iddle2301" class="calibre4"></a>Checks whether or not <kbd class="calibre17">*this</kbd> owns a shared lock on a mutex.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool owns_lock() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if <kbd class="calibre17">*this</kbd> owns a shared lock on a mutex, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec277"><a id="app04lev3sec277__title" class="calibre4"></a>std::shared_lock::mutex member function
      </h5>
      
      <p class="noind">Returns the mutex associated with <kbd class="calibre17">*this</kbd> if any.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">mutex_type* mutex() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            A pointer to the mutex associated with <kbd class="calibre17">*this</kbd> if any, <kbd class="calibre17">NULL</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec278"><a id="app04lev3sec278__title" class="calibre4"></a>std::shared_lock::release member function
      </h5>
      
      <p class="noind">Returns the mutex associated with <kbd class="calibre17">*this</kbd> if any, and releases that association.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">mutex_type* release() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Breaks the association of the mutex with <kbd class="calibre17">*this</kbd> without unlocking any locks held.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            A pointer to the mutex associated with <kbd class="calibre17">*this</kbd> prior to the call if any, <kbd class="calibre17">NULL</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;mutex()==NULL, this-&gt;owns_lock()==false.</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note60">Note</h5>
      
      
      <p class="noindclose">If <kbd class="calibre17">this-&gt;owns_lock()</kbd> would have returned <kbd class="calibre17">true</kbd> prior to the call, the caller would now be responsible for unlocking the mutex.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      
      
      <h4 id="app04lev2sec33" class="calibre23">D.5.11. <a id="app04lev2sec33__title" class="calibre4"></a>std::lock function template
      </h4>
      
      <p class="noind"><a id="iddle1649" class="calibre4"></a><a id="iddle1660" class="calibre4"></a><a id="iddle2170" class="calibre4"></a><a id="iddle2383" class="calibre4"></a>The <kbd class="calibre17">std::lock</kbd> function template provides a means of locking more than one mutex at the same time, without risk of deadlock resulting from
         inconsistent lock orders.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename LockableType1,typename... LockableType2&gt;
void lock(LockableType1&amp; m1,LockableType2&amp; m2...);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The types of the supplied lockable objects, <kbd class="calibre17">LockableType1</kbd>, <kbd class="calibre17">LockableType2</kbd>, ..., shall conform to the <kbd class="calibre17">Lockable</kbd> requirements.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Acquires a lock on each of the supplied lockable objects, <kbd class="calibre17">m1</kbd>, <kbd class="calibre17">m2</kbd>, ..., by an unspecified sequence of calls to the <kbd class="calibre17">lock()</kbd>, <kbd class="calibre17">try_lock()</kbd>, and <kbd class="calibre17">unlock()</kbd> members of those types that avoid deadlock.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            The current thread owns a lock on each of the supplied lockable objects.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Any exceptions thrown by the calls to <kbd class="calibre17">lock()</kbd>, <kbd class="calibre17">try_lock()</kbd>, and <kbd class="calibre17">unlock()</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note61">Note</h5>
      
      
      <p class="noindclose">If an exception propagates out of the call to <kbd class="calibre17">std::lock</kbd>, then <kbd class="calibre17">unlock()</kbd> shall have been called for any of the objects <kbd class="calibre17">m1</kbd>, <kbd class="calibre17">m2</kbd>, ... for which a lock has been acquired in the function by a call to <kbd class="calibre17">lock()</kbd> or <kbd class="calibre17">try_lock()</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h4 id="app04lev2sec34" class="calibre23">D.5.12. <a id="app04lev2sec34__title" class="calibre4"></a>std::try_lock function template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::try_lock</kbd> function template allows you to try to lock a set of lockable objects in one go, so either they are all locked or none are
         locked.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename LockableType1,typename... LockableType2&gt;
int try_lock(LockableType1&amp; m1,LockableType2&amp; m2...);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The types of the supplied lockable objects, <kbd class="calibre17">LockableType1</kbd>, <kbd class="calibre17">LockableType2</kbd>, ..., shall conform to the <kbd class="calibre17">Lockable</kbd> requirements.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Tries to acquires a lock on each of the supplied lockable objects, <kbd class="calibre17">m1</kbd>, <kbd class="calibre17">m2</kbd>, ..., by calling <kbd class="calibre17">try_lock()</kbd> on each in turn. If a call to <kbd class="calibre17">try_lock()</kbd> returns <kbd class="calibre17">false</kbd> or throws an exception, locks already acquired are released by calling <kbd class="calibre17">unlock()</kbd> on the corresponding lockable object.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">-1</kbd> if all locks were acquired (each call to <kbd class="calibre17">try_lock()</kbd> returned <kbd class="calibre17">true</kbd>), otherwise the zero-based index of the object for which the call to <kbd class="calibre17">try_lock()</kbd> returned <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            If the function returns <kbd class="calibre17">-1</kbd>, the current thread owns a lock on each of the supplied lockable objects. Otherwise, any locks acquired by this call have
            been released.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1648" class="calibre4"></a><a id="iddle1652" class="calibre4"></a><a id="iddle2035" class="calibre4"></a><a id="iddle2201" class="calibre4"></a><a id="iddle2202" class="calibre4"></a><i class="calibre6">Throws</i>
            Any exceptions thrown by the calls to <kbd class="calibre17">try_lock()</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note62">Note</h5>
      
      
      <p class="noindclose">If an exception propagates out of the call to <kbd class="calibre17">std::try_lock</kbd>, then <kbd class="calibre17">unlock()</kbd> shall have been called for any of the objects, <kbd class="calibre17">m1</kbd>, <kbd class="calibre17">m2</kbd>, ..., for which a lock has been acquired in the function by a call to <kbd class="calibre17">try_lock()</kbd>.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h4 id="app04lev2sec35" class="calibre23">D.5.13. <a id="app04lev2sec35__title" class="calibre4"></a>std::once_flag class
      </h4>
      
      <p class="noind">Instances of <kbd class="calibre17">std::once_flag</kbd> are used with <kbd class="calibre17">std::call_once</kbd> to ensure that a particular function is called exactly once, even if multiple threads invoke the call concurrently.
      </p>
      
      <p class="noind">Instances of <kbd class="calibre17">std::once_flag</kbd> are not <kbd class="calibre17">CopyConstructible</kbd>, <kbd class="calibre17">CopyAssignable</kbd>, <kbd class="calibre17">MoveConstructible</kbd>, or <kbd class="calibre17">MoveAssignable</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">struct once_flag
{
    constexpr once_flag() noexcept;

    once_flag(once_flag const&amp; ) = delete;
    once_flag&amp; operator=(once_flag const&amp; ) = delete;
};</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec279"><a id="app04lev3sec279__title" class="calibre4"></a>std::once_flag default constructor
      </h5>
      
      <p class="noind">The <kbd class="calibre17">std::once_flag</kbd> default constructor creates a new <kbd class="calibre17">std::once_flag</kbd> instance in a state, which indicates that the associated function hasn’t been called.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">constexpr once_flag() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs a new <kbd class="calibre17">std::once_flag</kbd> instance in a state, which indicates that the associated function hasn’t been called. Because this is a <kbd class="calibre17">constexpr</kbd> constructor, an instance with static storage duration is constructed as part of the static initialization phase, which avoids
            race conditions and order-of-initialization problems.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec36" class="calibre23">D.5.14. <a id="app04lev2sec36__title" class="calibre4"></a>std::call_once function template
      </h4>
      
      <p class="noind"><kbd class="calibre17">std::call_once</kbd> is used with an instance of <kbd class="calibre17">std::once_flag</kbd> to ensure that a particular function is called exactly once, even if multiple threads invoke the call concurrently.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Callable,typename... Args&gt;
void call_once(std::once_flag&amp; flag,Callable func,Args args...);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            The expression <kbd class="calibre17">INVOKE(func,args)</kbd> is valid for the supplied values of <kbd class="calibre17">func</kbd> and <kbd class="calibre17">args</kbd>. <kbd class="calibre17">Callable</kbd> and every member of <kbd class="calibre17">Args</kbd> are <kbd class="calibre17">MoveConstructible</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Invocations of <kbd class="calibre17">std::call_once</kbd> on the same <kbd class="calibre17">std::once_flag</kbd> object are serialized. If there has been no prior effective <kbd class="calibre17">std::call_once</kbd> invocation on the same <a id="iddle1093" class="calibre4"></a><a id="iddle1843" class="calibre4"></a><kbd class="calibre17">std::once_flag</kbd> object, the argument <kbd class="calibre17">func</kbd> (or a copy thereof) is called as-if by <kbd class="calibre17">INVOKE(func,args)</kbd>, and the invocation of <kbd class="calibre17">std::call_once</kbd> is effective if and only if the invocation of <kbd class="calibre17">func</kbd> returns without throwing an exception. If an exception is thrown, the exception is propagated to the caller. If there has
            been a prior effective <kbd class="calibre17">std::call_once</kbd> on the same <kbd class="calibre17">std::once_flag</kbd> object, the invocation of <kbd class="calibre17">std:: call_once</kbd> returns without invoking <kbd class="calibre17">func</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            The completion of an effective <kbd class="calibre17">std::call_once</kbd> invocation on an <kbd class="calibre17">std::once_flag</kbd> object happens-before all subsequent <kbd class="calibre17">std::call_once</kbd> invocations on the same <kbd class="calibre17">std::once_flag</kbd> object.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> when the effects can’t be achieved or for any exception propagated from the invocation of <kbd class="calibre17">func</kbd>.
         </li>
         
      </ul>
      
      
      
      
      <h3 id="app04lev1sec6" class="chapter"><a id="app04lev1sec6__title" class="calibre3"></a>D.6. &lt;ratio&gt; header
      </h3>
      
      <p class="noind">The <kbd class="calibre17">&lt;ratio&gt;</kbd> header provides support for compile-time rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Header contents</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">namespace std
{
    template&lt;intmax_t N,intmax_t D=1&gt;
    class ratio;

    // ratio arithmetic
    template &lt;class R1, class R2&gt;
    using ratio_add = <i class="calibre6">see description</i>;

    template &lt;class R1, class R2&gt;
    using ratio_subtract = <i class="calibre6">see description</i>;

    template &lt;class R1, class R2&gt;
    using ratio_multiply = <i class="calibre6">see description</i>;

    template &lt;class R1, class R2&gt;
    using ratio_divide = <i class="calibre6">see description</i>;

    // ratio comparison
    template &lt;class R1, class R2&gt;
    struct ratio_equal;

    template &lt;class R1, class R2&gt;
    struct ratio_not_equal;

    template &lt;class R1, class R2&gt;
    struct ratio_less;

    template &lt;class R1, class R2&gt;
    struct ratio_less_equal;

    template &lt;class R1, class R2&gt;
    struct ratio_greater;

    template &lt;class R1, class R2&gt;
    struct ratio_greater_equal;

    typedef ratio&lt;1, 1000000000000000000&gt; atto;
    typedef ratio&lt;1, 1000000000000000&gt; femto;
    typedef ratio&lt;1, 1000000000000&gt; pico;
    typedef ratio&lt;1, 1000000000&gt; nano;
    typedef ratio&lt;1, 1000000&gt; micro;
    typedef ratio&lt;1, 1000&gt; milli;
    typedef ratio&lt;1, 100&gt; centi;
    typedef ratio&lt;1, 10&gt; deci;
    typedef ratio&lt;10, 1&gt; deca;
    typedef ratio&lt;100, 1&gt; hecto;
    typedef ratio&lt;1000, 1&gt; kilo;
    typedef ratio&lt;1000000, 1&gt; mega;
    typedef ratio&lt;1000000000, 1&gt; giga;
    typedef ratio&lt;1000000000000, 1&gt; tera;
    typedef ratio&lt;1000000000000000, 1&gt; peta;
    typedef ratio&lt;1000000000000000000, 1&gt; exa;
}</pre>
            </li>
         
      </ul>
      
      
      <h4 id="app04lev2sec37" class="calibre23">D.6.1. <a id="app04lev2sec37__title" class="calibre4"></a>std::ratio class template
      </h4>
      
      <p class="noind"><a id="iddle2236" class="calibre4"></a>The <kbd class="calibre17">std::ratio</kbd> class template provides a mechanism for compile-time arithmetic involving rational values such as one half (<kbd class="calibre17">std::ratio&lt;1,2&gt;</kbd>), two thirds (<kbd class="calibre17">std:: ratio&lt;2,3&gt;</kbd>), or fifteen forty-thirds (<kbd class="calibre17">std::ratio&lt;15,43&gt;</kbd>). It’s used within the C++ Standard Library for specifying the period for instantiating the <kbd class="calibre17">std::chrono::duration</kbd> class template.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;intmax_t N, intmax_t D = 1&gt;
class ratio
{
public:
    typedef ratio&lt;num, den&gt; type;
    static constexpr intmax_t num= <i class="calibre6">see below</i>;
    static constexpr intmax_t den= <i class="calibre6">see below</i>;
};</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Requirements</i>
            <kbd class="calibre17">D</kbd> may not be zero.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Description</i>
            <kbd class="calibre17">num</kbd> and <kbd class="calibre17">den</kbd> are the numerator and denominator of the fraction <kbd class="calibre17">N/D</kbd> reduced to lowest terms. <kbd class="calibre17">den</kbd> is always positive. If <kbd class="calibre17">N</kbd> and <kbd class="calibre17">D</kbd> are the same sign, <kbd class="calibre17">num</kbd> is positive; otherwise <kbd class="calibre17">num</kbd> is negative.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">ratio&lt;4,6&gt;::num == 2
ratio&lt;4,6&gt;::den == 3
ratio&lt;4,-6&gt;::num == -2
ratio&lt;4,-6&gt;::den == 3</pre>
            </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec38" class="calibre23">D.6.2. <a id="app04lev2sec38__title" class="calibre4"></a>std::ratio_add template alias
      </h4>
      
      <p class="noind"><a id="iddle2237" class="calibre4"></a><a id="iddle2246" class="calibre4"></a>The <kbd class="calibre17">std::ratio_add</kbd> template alias provides a mechanism for adding two <kbd class="calibre17">std::ratio</kbd> values at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
using ratio_add = std::ratio&lt;<i class="calibre6">see below</i>&gt;;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            <kbd class="calibre17">ratio_add&lt;R1,R2&gt;</kbd> is defined as an alias for an instantiation of <kbd class="calibre17">std::ratio</kbd> that represents the sum of the fractions represented by <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> if that sum can be calculated without overflow. If the calculation of the result overflows, the program is ill-formed. In
            the absence of arithmetic overflow, <kbd class="calibre17">std::ratio_add&lt;R1,R2&gt;</kbd> shall have the same <kbd class="calibre17">num</kbd> and <kbd class="calibre17">den</kbd> values as <kbd class="calibre17">std::ratio&lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::ratio_add&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,5&gt; &gt;::num == 11
std::ratio_add&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,5&gt; &gt;::den == 15

std::ratio_add&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;7,6&gt; &gt;::num == 3
std::ratio_add&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;7,6&gt; &gt;::den == 2</pre>
            </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec39" class="calibre23">D.6.3. <a id="app04lev2sec39__title" class="calibre4"></a>std::ratio_subtract template alias
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::ratio_subtract</kbd> template alias provides a mechanism for subtracting two <kbd class="calibre17">std::ratio</kbd> values at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
using ratio_subtract = std::ratio&lt;<i class="calibre6">see below</i>&gt;;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            <kbd class="calibre17">ratio_subtract&lt;R1,R2&gt;</kbd> is defined as an alias for an instantiation of <kbd class="calibre17">std::ratio</kbd> that represents the difference of the fractions represented by <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> if that difference can be calculated without overflow. If the calculation of the result overflows, the program is ill-formed.
            In the absence of arithmetic overflow, <kbd class="calibre17">std::ratio_subtract&lt;R1,R2&gt;</kbd> shall have the same <kbd class="calibre17">num</kbd> and <kbd class="calibre17">den</kbd> values as <kbd class="calibre17">std::ratio&lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::ratio_subtract&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;1,5&gt; &gt;::num == 2
std::ratio_subtract&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;1,5&gt; &gt;::den == 15

std::ratio_subtract&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;7,6&gt; &gt;::num == -5
std::ratio_subtract&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;7,6&gt; &gt;::den == 6</pre>
            </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec40" class="calibre23">D.6.4. <a id="app04lev2sec40__title" class="calibre4"></a>std::ratio_multiply template alias
      </h4>
      
      <p class="noind"><a id="iddle2238" class="calibre4"></a><a id="iddle2244" class="calibre4"></a>The <kbd class="calibre17">std::ratio_multiply</kbd> template alias provides a mechanism for multiplying two <kbd class="calibre17">std::ratio</kbd> values at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
using ratio_multiply = std::ratio&lt;<i class="calibre6">see below</i>&gt;;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            <kbd class="calibre17">ratio_multiply&lt;R1,R2&gt;</kbd> is defined as an alias for an instantiation of <kbd class="calibre17">std::ratio</kbd> that represents the product of the fractions represented by <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> if that product can be calculated without overflow. If the calculation of the result overflows, the program is ill-formed.
            In the absence of arithmetic overflow, <kbd class="calibre17">std::ratio_multiply &lt;R1,R2&gt;</kbd> shall have the same <kbd class="calibre17">num</kbd> and <kbd class="calibre17">den</kbd> values as <kbd class="calibre17">std::ratio&lt;R1::num * R2::num, R1::den * R2::den&gt;</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::ratio_multiply&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,5&gt; &gt;::num == 2
std::ratio_multiply&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,5&gt; &gt;::den == 15

std::ratio_multiply&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;15,7&gt; &gt;::num == 5
std::ratio_multiply&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;15,7&gt; &gt;::den == 7</pre>
            </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec41" class="calibre23">D.6.5. <a id="app04lev2sec41__title" class="calibre4"></a>std::ratio_divide template alias
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::ratio_divide</kbd> template alias provides a mechanism for dividing two <kbd class="calibre17">std:: ratio</kbd> values at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
using ratio_divide = std::ratio&lt;<i class="calibre6">see below</i>&gt;;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            <kbd class="calibre17">ratio_divide&lt;R1,R2&gt;</kbd> is defined as an alias for an instantiation of <kbd class="calibre17">std::ratio</kbd> that represents the result of dividing the fractions represented by <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> if that result can be calculated without overflow. If the calculation overflows, the program is ill-formed. In the absence
            of arithmetic overflow, <kbd class="calibre17">std::ratio_divide&lt;R1,R2&gt;</kbd> shall have the same <kbd class="calibre17">num</kbd> and <kbd class="calibre17">den</kbd> values as <kbd class="calibre17">std::ratio&lt;R1::num * R2::den, R1::den * R2::num&gt;</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::ratio_divide&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,5&gt; &gt;::num == 5
std::ratio_divide&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,5&gt; &gt;::den == 6

std::ratio_divide&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;15,7&gt; &gt;::num == 7
std::ratio_divide&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;15,7&gt; &gt;::den == 45</pre>
            </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec42" class="calibre23">D.6.6. <a id="app04lev2sec42__title" class="calibre4"></a>std::ratio_equal class template
      </h4>
      
      <p class="noind"><a id="iddle2239" class="calibre4"></a><a id="iddle2242" class="calibre4"></a><a id="iddle2245" class="calibre4"></a>The <kbd class="calibre17">std::ratio_equal</kbd> class template provides a mechanism for comparing two <kbd class="calibre17">std:: ratio</kbd> values for equality at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
class ratio_equal:
    public std::integral_constant&lt;
        bool,(R1::num == R2::num) &amp;&amp; (R1::den == R2::den)&gt;
{};</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::ratio_equal&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,6&gt; &gt;::value == true
std::ratio_equal&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;1,6&gt; &gt;::value == false
std::ratio_equal&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,3&gt; &gt;::value == false
std::ratio_equal&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;1,3&gt; &gt;::value == true</pre>
            </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec43" class="calibre23">D.6.7. <a id="app04lev2sec43__title" class="calibre4"></a>std::ratio_not_equal class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::ratio_not_equal</kbd> class template provides a mechanism for comparing two <kbd class="calibre17">std::ratio</kbd> values for inequality at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
class ratio_not_equal:
    public std::integral_constant&lt;bool,!ratio_equal&lt;R1,R2&gt;::value&gt;
{};</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::ratio_not_equal&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,6&gt; &gt;::value == false
std::ratio_not_equal&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;1,6&gt; &gt;::value == true
std::ratio_not_equal&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,3&gt; &gt;::value == true
std::ratio_not_equal&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;1,3&gt; &gt;::value == false</pre>
            </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec44" class="calibre23">D.6.8. <a id="app04lev2sec44__title" class="calibre4"></a>std::ratio_less class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::ratio_less</kbd> class template provides a mechanism for comparing two <kbd class="calibre17">std:: ratio</kbd> values at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
class ratio_less:
    public std::integral_constant&lt;bool,<i class="calibre6">see below</i>&gt;
{};</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2240" class="calibre4"></a><a id="iddle2241" class="calibre4"></a><a id="iddle2243" class="calibre4"></a><i class="calibre6">Effects</i>
            <kbd class="calibre17">std::ratio_less&lt;R1,R2&gt;</kbd> derives from <kbd class="calibre17">std::integral_constant&lt;bool, value &gt;</kbd>, where <kbd class="calibre17">value</kbd> is <kbd class="calibre17">(R1::num * R2::den) &lt; (R2::num * R1::den)</kbd>. Where possible, implementations shall use a method of calculating the result that avoids overflow. If overflow occurs, the
            program is ill-formed.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Examples</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">std::ratio_less&lt;std::ratio&lt;1,3&gt;, std::ratio&lt;2,6&gt; &gt;::value == false
std::ratio_less&lt;std::ratio&lt;1,6&gt;, std::ratio&lt;1,3&gt; &gt;::value == true
std::ratio_less&lt;
    std::ratio&lt;999999999,1000000000&gt;,
    std::ratio&lt;1000000001,1000000000&gt; &gt;::value == true
std::ratio_less&lt;
    std::ratio&lt;1000000001,1000000000&gt;,
    std::ratio&lt;999999999,1000000000&gt; &gt;::value == false</pre>
            </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec45" class="calibre23">D.6.9. <a id="app04lev2sec45__title" class="calibre4"></a>std::ratio_greater class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::ratio_greater</kbd> class template provides a mechanism for comparing two <kbd class="calibre17">std::ratio</kbd> values at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
class ratio_greater:
    public std::integral_constant&lt;bool,ratio_less&lt;R2,R1&gt;::value&gt;
{};</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec46" class="calibre23">D.6.10. <a id="app04lev2sec46__title" class="calibre4"></a>std::ratio_less_equal class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::ratio_less_equal</kbd> class template provides a mechanism for comparing two <kbd class="calibre17">std::ratio</kbd> values at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
class ratio_less_equal:
    public std::integral_constant&lt;bool,!ratio_less&lt;R2,R1&gt;::value&gt;
{};</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      
      
      <h4 id="app04lev2sec47" class="calibre23">D.6.11. <a id="app04lev2sec47__title" class="calibre4"></a>std::ratio_greater_equal class template
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::ratio_greater_equal</kbd> class template provides a mechanism for comparing two <kbd class="calibre17">std::ratio</kbd> values at compile time, using rational arithmetic.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template &lt;class R1, class R2&gt;
class ratio_greater_equal:
    public std::integral_constant&lt;bool,!ratio_less&lt;R1,R2&gt;::value&gt;
{};</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1094" class="calibre4"></a><a id="iddle2346" class="calibre4"></a><a id="iddle2483" class="calibre4"></a><a id="iddle2485" class="calibre4"></a><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">R1</kbd> and <kbd class="calibre17">R2</kbd> must be instantiations of the <kbd class="calibre17">std::ratio</kbd> class template.
         </li>
         
      </ul>
      
      
      
      
      <h3 id="app04lev1sec7" class="chapter"><a id="app04lev1sec7__title" class="calibre3"></a>D.7. &lt;thread&gt; header
      </h3>
      
      <p class="noind">The <kbd class="calibre17">&lt;thread&gt;</kbd> header provides facilities for managing and identifying threads and provides functions for making the current thread sleep.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Header contents</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">namespace std
{
    class thread;

    namespace this_thread
    {
        thread::id get_id() noexcept;

        void yield() noexcept;

        template&lt;typename Rep,typename Period&gt;
        void sleep_for(
            std::chrono::duration&lt;Rep,Period&gt; sleep_duration);

        template&lt;typename Clock,typename Duration&gt;
        void sleep_until(
            std::chrono::time_point&lt;Clock,Duration&gt; wake_time);
    }
}</pre>
            </li>
         
      </ul>
      
      
      <h4 id="app04lev2sec48" class="calibre23">D.7.1. <a id="app04lev2sec48__title" class="calibre4"></a>std::thread class
      </h4>
      
      <p class="noind">The <kbd class="calibre17">std::thread</kbd> class is used to manage a thread of execution. It provides a means of starting a new thread of execution and waiting for
         the completion of a thread of execution. It also provides a means for identifying and provides other functions for managing
         threads of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class thread
{
public:
    // Types
    class id;
    typedef <i class="calibre6">implementation-defined</i> native_handle_type; // optional

    // Construction and Destruction
    thread() noexcept;

    ~thread();

    template&lt;typename Callable,typename Args...&gt;
    explicit thread(Callable&amp;&amp; func,Args&amp;&amp;... args);

    // Copying and Moving
    thread(thread const&amp; other) = delete;
    thread(thread&amp;&amp; other) noexcept;

    thread&amp; operator=(thread const&amp; other) = delete;
    thread&amp; operator=(thread&amp;&amp; other) noexcept;

    void swap(thread&amp; other) noexcept;

    void join();
    void detach();
    bool joinable() const noexcept;

    id get_id() const noexcept;

    native_handle_type native_handle();

    static unsigned hardware_concurrency() noexcept;
};

void swap(thread&amp; lhs,thread&amp; rhs);</pre>
            </li>
         
      </ul>
      
      
      <h5 class="notetitle" id="app04lev3sec280"><a id="app04lev3sec280__title" class="calibre4"></a>std::thread::id class
      </h5>
      
      <p class="noind"><a id="iddle1218" class="calibre4"></a><a id="iddle1220" class="calibre4"></a><a id="iddle2361" class="calibre4"></a><a id="iddle2362" class="calibre4"></a>An instance of <kbd class="calibre17">std::thread::id</kbd> identifies a particular thread of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Class definition</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">class thread::id
{
public:
    id() noexcept;
};

bool operator==(thread::id x, thread::id y) noexcept;
bool operator!=(thread::id x, thread::id y) noexcept;
bool operator&lt;(thread::id x, thread::id y) noexcept;
bool operator&lt;=(thread::id x, thread::id y) noexcept;
bool operator&gt;(thread::id x, thread::id y) noexcept;
bool operator&gt;=(thread::id x, thread::id y) noexcept;

template&lt;typename charT, typename traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, thread::id id);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Notes</i>
            The <kbd class="calibre17">std::thread::id</kbd> value that identifies a particular thread of execution shall be distinct from the value of a default-constructed <kbd class="calibre17">std::thread::id</kbd> instance and from any value that represents another thread of execution.
            The <kbd class="calibre17">std::thread::id</kbd> values for particular threads aren’t predictable and may vary between executions of the same program.
            <kbd class="calibre17">std::thread::id</kbd> is <kbd class="calibre17">CopyConstructible</kbd> and <kbd class="calibre17">CopyAssignable</kbd>, so instances of <kbd class="calibre17">std::thread::id</kbd> may be freely copied and assigned.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec281"><a id="app04lev3sec281__title" class="calibre4"></a>std::thread::id default constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::thread::id</kbd> object that doesn’t represent any thread of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">id() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::thread::id</kbd> instance that has the singular <i class="calibre6">not any thread</i> value.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note63">Note</h5>
      
      
      
      <p class="noindclose"><a id="iddle2363" class="calibre4"></a><a id="iddle2366" class="calibre4"></a><a id="iddle2367" class="calibre4"></a>All default-constructed <kbd class="calibre17">std::thread::id</kbd> instances store the same value.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec282"><a id="app04lev3sec282__title" class="calibre4"></a>std::thread::id equality comparison operator
      </h5>
      
      <p class="noind">Compares two instances of <kbd class="calibre17">std::thread::id</kbd> to see if they represent the same thread of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool operator==(std::thread::id lhs,std::thread::id rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if both <kbd class="calibre17">lhs</kbd> and <kbd class="calibre17">rhs</kbd> represent the same thread of execution or both have the singular <i class="calibre6">not any thread</i> value. <kbd class="calibre17">false</kbd> if <kbd class="calibre17">lhs</kbd> and <kbd class="calibre17">rhs</kbd> represent different threads of execution or one represents a thread of execution and the other has the singular <i class="calibre6">not any thread</i> value.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec283"><a id="app04lev3sec283__title" class="calibre4"></a>std::thread::id inequality comparison operator
      </h5>
      
      <p class="noind">Compares two instances of <kbd class="calibre17">std::thread::id</kbd> to see if they represent different threads of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool operator!=(std::thread::id lhs,std::thread::id rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">!(lhs==rhs)</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec284"><a id="app04lev3sec284__title" class="calibre4"></a>std::thread::id less-than comparison operator
      </h5>
      
      <p class="noind">Compares two instances of <kbd class="calibre17">std::thread::id</kbd> to see if one lies before the other in the total ordering of thread ID values.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool operator&lt;(std::thread::id lhs,std::thread::id rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if the value of <kbd class="calibre17">lhs</kbd> occurs before the value of <kbd class="calibre17">rhs</kbd> in the total ordering of thread ID values. If <kbd class="calibre17">lhs!=rhs</kbd>, exactly one of <kbd class="calibre17">lhs&lt;rhs</kbd> or <kbd class="calibre17">rhs&lt;lhs</kbd> returns <kbd class="calibre17">true</kbd> and the other returns <kbd class="calibre17">false</kbd>. If <kbd class="calibre17">lhs==rhs</kbd>, <kbd class="calibre17">lhs&lt;rhs</kbd> and <kbd class="calibre17">rhs&lt;lhs</kbd> both return <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note64">Note</h5>
      
      
      <p class="noindclose">The singular <i class="calibre6">not any thread</i> value held by a default-constructed <kbd class="calibre17">std:: thread::id</kbd> instance compares less than any <kbd class="calibre17">std::thread::id</kbd> instance that represents a thread of execution. If two instances of <kbd class="calibre17">std::thread::id</kbd> are equal, neither is less than the other. Any set of distinct <kbd class="calibre17">std::thread::id</kbd> values forms a total order, which is consistent throughout an execution of a program. This order may vary between executions
         of the same program.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec285"><a id="app04lev3sec285__title" class="calibre4"></a>std::thread::id less-than or equal comparison operator
      </h5>
      
      <p class="noind"><a id="iddle2364" class="calibre4"></a><a id="iddle2365" class="calibre4"></a><a id="iddle2368" class="calibre4"></a><a id="iddle2369" class="calibre4"></a>Compares two instances of <kbd class="calibre17">std::thread::id</kbd> to see if one lies before the other in the total ordering of thread ID values or is equal to it.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool operator&lt;=(std::thread::id lhs,std::thread::id rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">!(rhs&lt;lhs)</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec286"><a id="app04lev3sec286__title" class="calibre4"></a>std::thread::id greater-than comparison operator
      </h5>
      
      <p class="noind">Compares two instances of <kbd class="calibre17">std::thread::id</kbd> to see if one lies after the other in the total ordering of thread ID values.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool operator&gt;(std::thread::id lhs,std::thread::id rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">rhs&lt;lhs</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec287"><a id="app04lev3sec287__title" class="calibre4"></a>std::thread::id greater-than or equal comparison operator
      </h5>
      
      <p class="noind">Compares two instances of <kbd class="calibre17">std::thread::id</kbd> to see if one lies after the other in the total ordering of thread ID values or is equal to it.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool operator&gt;=(std::thread::id lhs,std::thread::id rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">!(lhs&lt;rhs)</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec288"><a id="app04lev3sec288__title" class="calibre4"></a>std::thread::id stream insertion operator
      </h5>
      
      <p class="noind">Writes a string representation of the <kbd class="calibre17">std::thread::id</kbd> value into the specified stream.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename charT, typename traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, thread::id id);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Inserts a string representation of the <kbd class="calibre17">std::thread::id</kbd> value into the specified stream.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">out</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note65">Note</h5>
      
      
      
      <p class="noindclose"><a id="iddle1630" class="calibre4"></a><a id="iddle2347" class="calibre4"></a><a id="iddle2348" class="calibre4"></a><a id="iddle2372" class="calibre4"></a><a id="iddle2373" class="calibre4"></a>The format of the string representation isn’t specified. Instances of <kbd class="calibre17">std::thread::id</kbd> that compare equal have the same representation, and instances that aren’t equal have distinct representations.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec289"><a id="app04lev3sec289__title" class="calibre4"></a>std::thread::native_handle_type typedef
      </h5>
      
      <p class="noind"><kbd class="calibre17">native_handle_type</kbd> is a typedef to a type that can be used with platform-specific APIs.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">typedef <i class="calibre6">implementation-defined</i> native_handle_type;</pre>
            </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note66">Note</h5>
      
      
      <p class="noindclose">This typedef is <i class="calibre6">optional</i>. If present, the implementation should provide a type that’s suitable for use with native platform-specific APIs.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec290"><a id="app04lev3sec290__title" class="calibre4"></a>std::thread::native_handle member function
      </h5>
      
      <p class="noind">Returns a value of type <kbd class="calibre17">native_handle_type</kbd> that represents the thread of execution associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">native_handle_type native_handle();</pre>
            </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note67">Note</h5>
      
      
      <p class="noindclose">This function is optional. If present, the value returned should be suitable for use with the native platform-specific APIs.</p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec291"><a id="app04lev3sec291__title" class="calibre4"></a>std::thread default constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::thread</kbd> object without an associated thread of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">thread() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::thread</kbd> instance that has no associated thread of execution.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            For a newly constructed <kbd class="calibre17">std::thread</kbd> object, <kbd class="calibre17">x</kbd>, <kbd class="calibre17">x.get_id()==id()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec292"><a id="app04lev3sec292__title" class="calibre4"></a>std::thread constructor
      </h5>
      
      <p class="noind">Constructs an <kbd class="calibre17">std::thread</kbd> object associated with a new thread of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Callable,typename Args...&gt;
explicit thread(Callable&amp;&amp; func,Args&amp;&amp;... args);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">func</kbd> and each element of <kbd class="calibre17">args</kbd> must be <kbd class="calibre17">MoveConstructible</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::thread</kbd> instance and associates it with a newly created thread of execution. Copies or moves <kbd class="calibre17">func</kbd> and each element of <kbd class="calibre17">args</kbd> into internal storage that persists for the lifetime of the new thread of execution. Performs <kbd class="calibre17">INVOKE (copy-of-func,copy-of-args)</kbd> on the new thread of execution.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1221" class="calibre4"></a><a id="iddle2349" class="calibre4"></a><a id="iddle2350" class="calibre4"></a><a id="iddle2351" class="calibre4"></a><i class="calibre6">Postconditions</i>
            For a newly constructed <kbd class="calibre17">std::thread</kbd> object, <kbd class="calibre17">x</kbd>, <kbd class="calibre17">x.get_id()!=id()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            An exception of type <kbd class="calibre17">std::system_error</kbd> if unable to start the new thread. Any exception thrown by copying <kbd class="calibre17">func</kbd> or <kbd class="calibre17">args</kbd> into internal storage.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            The invocation of the constructor happens-before the execution of the supplied function on the newly created thread of execution.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec293"><a id="app04lev3sec293__title" class="calibre4"></a>std::thread move-constructor
      </h5>
      
      <p class="noind">Transfers ownership of a thread of execution from one <kbd class="calibre17">std::thread</kbd> object to a newly created <kbd class="calibre17">std::thread</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">thread(thread&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Constructs an <kbd class="calibre17">std::thread</kbd> instance. If <kbd class="calibre17">other</kbd> has an associated thread of execution prior to the constructor invocation, that thread of execution is now associated with
            the newly created <kbd class="calibre17">std::thread</kbd> object. Otherwise, the newly created <kbd class="calibre17">std::thread</kbd> object has no associated thread of execution.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            For a newly constructed <kbd class="calibre17">std::thread</kbd> object, <kbd class="calibre17">x</kbd>, <kbd class="calibre17">x.get_id()</kbd> is equal to the value of <kbd class="calibre17">other.get_id()</kbd> prior to the constructor invocation. <kbd class="calibre17">other.get_id()==id()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note68">Note</h5>
      
      
      <p class="noindclose"><kbd class="calibre17">std::thread</kbd> objects are not <kbd class="calibre17">CopyConstructible</kbd>, so there’s no copy constructor, only this move constructor.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec294"><a id="app04lev3sec294__title" class="calibre4"></a>std::thread destructor
      </h5>
      
      <p class="noind">Destroys an <kbd class="calibre17">std::thread</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">~thread();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Destroys <kbd class="calibre17">*this</kbd>. If <kbd class="calibre17">*this</kbd> has an associated thread of execution (<kbd class="calibre17">this-&gt;joinable()</kbd> would return <kbd class="calibre17">true</kbd>), calls <kbd class="calibre17">std::terminate()</kbd> to abort the program.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec295"><a id="app04lev3sec295__title" class="calibre4"></a>std::thread move-assignment operator
      </h5>
      
      <p class="noind">Transfers ownership of a thread of execution from one <kbd class="calibre17">std::thread</kbd> object to another <kbd class="calibre17">std::thread</kbd> object.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">thread&amp; operator=(thread&amp;&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1690" class="calibre4"></a><a id="iddle2352" class="calibre4"></a><a id="iddle2371" class="calibre4"></a><a id="iddle2374" class="calibre4"></a><a id="iddle2425" class="calibre4"></a><i class="calibre6">Effects</i>
            If <kbd class="calibre17">this-&gt;joinable()</kbd> returns <kbd class="calibre17">true</kbd> prior to the call, calls <kbd class="calibre17">std::terminate()</kbd> to abort the program. If <kbd class="calibre17">other</kbd> has an associated thread of execution prior to the assignment, that thread of execution is now associated with <kbd class="calibre17">*this</kbd>. Otherwise <kbd class="calibre17">*this</kbd> has no associated thread of execution.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;get_id()</kbd> is equal to the value of <kbd class="calibre17">other.get_id()</kbd> prior to the call. <kbd class="calibre17">other.get_id()==id()</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note69">Note</h5>
      
      
      <p class="noindclose"><kbd class="calibre17">std::thread</kbd> objects are not <kbd class="calibre17">CopyAssignable</kbd>, so there’s no copy-assignment operator, only this move-assignment operator.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      
      
      <h5 class="notetitle" id="app04lev3sec296"><a id="app04lev3sec296__title" class="calibre4"></a>std::thread::swap member function
      </h5>
      
      <p class="noind">Exchanges ownership of their associated threads of execution between two <kbd class="calibre17">std:: thread</kbd> objects.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void swap(thread&amp; other) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            If <kbd class="calibre17">other</kbd> has an associated thread of execution prior to the call, that thread of execution is now associated with <kbd class="calibre17">*this</kbd>. Otherwise <kbd class="calibre17">*this</kbd> has no associated thread of execution. If <kbd class="calibre17">*this</kbd> has an associated thread of execution prior to the call, that thread of execution is now associated with <kbd class="calibre17">other</kbd>. Otherwise <kbd class="calibre17">other</kbd> has no associated thread of execution.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;get_id()</kbd> is equal to the value of <kbd class="calibre17">other.get_id()</kbd> prior to the call. <kbd class="calibre17">other.get_id()</kbd> is equal to the value of <kbd class="calibre17">this-&gt;get_id()</kbd> prior to the call.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec297"><a id="app04lev3sec297__title" class="calibre4"></a>swap nonmember function for std::threads
      </h5>
      
      <p class="noind">Exchanges ownership of their associated threads of execution between two <kbd class="calibre17">std:: thread</kbd> objects.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void swap(thread&amp; lhs,thread&amp; rhs) noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">lhs.swap(rhs)</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec298"><a id="app04lev3sec298__title" class="calibre4"></a>std::thread::joinable member function
      </h5>
      
      <p class="noind">Queries whether or not <kbd class="calibre17">*this</kbd> has an associated thread of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle2353" class="calibre4"></a><a id="iddle2370" class="calibre4"></a><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">bool joinable() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            <kbd class="calibre17">true</kbd> if <kbd class="calibre17">*this</kbd> has an associated thread of execution, <kbd class="calibre17">false</kbd> otherwise.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec299"><a id="app04lev3sec299__title" class="calibre4"></a>std::thread::join member function
      </h5>
      
      <p class="noind">Waits for the thread of execution associated with <kbd class="calibre17">*this</kbd> to finish.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void join();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;joinable()</kbd> would return <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until the thread of execution associated with <kbd class="calibre17">*this</kbd> has finished.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            <kbd class="calibre17">this-&gt;get_id()==id()</kbd>. The thread of execution associated with <kbd class="calibre17">*this</kbd> prior to the call has finished.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Synchronization</i>
            The completion of the thread of execution associated with <kbd class="calibre17">*this</kbd> prior to the call happens-before the call to <kbd class="calibre17">join()</kbd> returns.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved or <kbd class="calibre17">this-&gt;joinable()</kbd> returns <kbd class="calibre17">false</kbd>.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec300"><a id="app04lev3sec300__title" class="calibre4"></a>std::thread::detach member function
      </h5>
      
      <p class="noind">Detaches the thread of execution associated with <kbd class="calibre17">*this</kbd> to finish.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void detach();</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Preconditions</i>
            <kbd class="calibre17">this-&gt;joinable()</kbd> returns <kbd class="calibre17">true</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Detaches the thread of execution associated with <kbd class="calibre17">*this</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Postconditions</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">this-&gt;get_id()==id(), this-&gt;joinable()==false</pre>
            
            The thread of execution associated with <kbd class="calibre17">*this</kbd> prior to the call is detached and no longer has an associated <kbd class="calibre17">std::thread</kbd> object.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            <kbd class="calibre17">std::system_error</kbd> if the effects can’t be achieved or <kbd class="calibre17">this-&gt;joinable()</kbd> returns <kbd class="calibre17">false</kbd> on invocation.
         </li>
         
      </ul>
      
      
      
      
      <h5 class="notetitle" id="app04lev3sec301"><a id="app04lev3sec301__title" class="calibre4"></a>std::thread::get_id member function
      </h5>
      
      <p class="noind"><a id="iddle1676" class="calibre4"></a><a id="iddle2342" class="calibre4"></a><a id="iddle2345" class="calibre4"></a><a id="iddle2354" class="calibre4"></a><a id="iddle2360" class="calibre4"></a><a id="iddle2484" class="calibre4"></a>Returns a value of type <kbd class="calibre17">std::thread::id</kbd> that identifies the thread of execution associated with <kbd class="calibre17">*this</kbd>.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">thread::id get_id() const noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            If <kbd class="calibre17">*this</kbd> has an associated thread of execution, returns an instance of <kbd class="calibre17">std:: thread::id</kbd> that identifies that thread. Otherwise returns a default-constructed <kbd class="calibre17">std::thread::id</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec302"><a id="app04lev3sec302__title" class="calibre4"></a>std::thread::hardware_concurrency static member function
      </h5>
      
      <p class="noind">Returns a hint as to the number of threads that can run concurrently on the current hardware.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">unsigned hardware_concurrency() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            The number of threads that can run concurrently on the current hardware. This may be the number of processors in the system,
            for example. Where this information is not available or well-defined, this function returns <kbd class="calibre17">0</kbd>.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      <h4 id="app04lev2sec49" class="calibre23">D.7.2. <a id="app04lev2sec49__title" class="calibre4"></a>Namespace this_thread
      </h4>
      
      <p class="noind">The functions in the <kbd class="calibre17">std::this_thread</kbd> namespace operate on the calling thread.
      </p>
      
      
      <h5 class="notetitle" id="app04lev3sec303"><a id="app04lev3sec303__title" class="calibre4"></a>std::this_thread::get_id nonmember function
      </h5>
      
      <p class="noind">Returns a value of type <kbd class="calibre17">std::thread::id</kbd> that identifies the current thread of execution.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">thread::id get_id() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Returns</i>
            An instance of <kbd class="calibre17">std::thread::id</kbd> that identifies the current thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec304"><a id="app04lev3sec304__title" class="calibre4"></a>std::this_thread::yield nonmember function
      </h5>
      
      <p class="noind">Used to inform the library that the thread that invoked the function doesn’t need to run at the point of the call. Commonly
         used in tight loops to avoid consuming excessive CPU time.
      </p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">void yield() noexcept;</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><a id="iddle1002" class="calibre4"></a><a id="iddle2343" class="calibre4"></a><a id="iddle2344" class="calibre4"></a><i class="calibre6">Effects</i>
            Provides the library an opportunity to schedule something else in place of the current thread.
         </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec305"><a id="app04lev3sec305__title" class="calibre4"></a>std::this_thread::sleep_for nonmember function
      </h5>
      
      <p class="noind">Suspends execution of the current thread for the specified duration.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Rep,typename Period&gt;
void sleep_for(std::chrono::duration&lt;Rep,Period&gt; const&amp; relative_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until the specified <kbd class="calibre17">relative_time</kbd> has elapsed.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note70">Note</h5>
      
      
      <p class="noindclose">The thread may be blocked for longer than the specified duration. Where possible, the elapsed time is determined by a steady
         clock.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      <h5 class="notetitle" id="app04lev3sec306"><a id="app04lev3sec306__title" class="calibre4"></a>std::this_thread::sleep_until nonmember function
      </h5>
      
      <p class="noind">Suspends execution of the current thread until the specified time point has been reached.</p>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Declaration</i>
            
            
            <div class="calibre15"></div><pre class="calibre5">template&lt;typename Clock,typename Duration&gt;
void sleep_until(
    std::chrono::time_point&lt;Clock,Duration&gt; const&amp; absolute_time);</pre>
            </li>
         
      </ul>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Effects</i>
            Blocks the current thread until the specified <kbd class="calibre17">absolute_time</kbd> has been reached for the specified <kbd class="calibre17">Clock</kbd>.
         </li>
         
      </ul>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      <h5 class="notetitle" id="app04note71">Note</h5>
      
      
      <p class="noindclose">There’s no guarantee as to how long the calling thread will be blocked for, only that <kbd class="calibre17">Clock::now()</kbd> returned a time equal to or later than <kbd class="calibre17">absolute_time</kbd> at the point at which the thread became unblocked.
      </p>
      
      <table cellspacing="5" width="100%" border="1" class="calibre7">
         <colgroup class="calibre28">
            <col width="550" class="calibre9"/>
         </colgroup>
         <tbody class="calibre10">
            <tr class="calibre11">
               <td class="calibre29"/>
            </tr>
         </tbody>
      </table>
      
      <p class="calibre19"></p>
      <ul class="calibre21">
         
         <li class="calibre22"><i class="calibre6">Throws</i>
            Nothing.
         </li>
         
      </ul>
      
      
      
      
      </body></html>
