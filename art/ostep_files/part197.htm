<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.7 A Real TLB Entry</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part196.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part198.htm">下一个 &gt;</a></p><p class="s40" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">19.7 A Real TLB Entry</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 11pt;line-height: 90%;text-align: justify;">Finally, let’s briefly look at a real TLB. This example is from the MIPS R4000 [H93], a modern system that uses software-managed TLBs. All 64 bits of this TLB entry can be seen in Figure <span style=" color: #00AEEF;">19.4</span>.</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 91%;text-align: justify;">The MIPS R4000 supports a 32-bit address space with 4KB pages. Thus, we would expect a 20-bit VPN and 12-bit offset in our typical virtual ad- dress. However, as you can see in the TLB, there are only 19 bits for the VPN; as it turns out, user addresses will only come from half the address space (the rest reserved for the kernel) and hence only 19 bits of VPN are needed. The VPN translates to up to a 24-bit physical frame number (PFN), and hence can support systems with up to 64GB of (physical) main memory (<span class="s44">2</span><span class="s101">24</span><span class="s64"> </span>4KB pages).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 90%;text-align: justify;">There are a few other interesting bits in the MIPS TLB. We see a <i>global </i>bit (G), which is used for pages that are globally-shared among processes. Thus, if the global bit is set, the ASID is ignored. We also see the 8-bit <i>ASID</i>, which the OS can use to distinguish between address spaces (as described above). One question for you: what should the OS do if there are more than 256 (<span class="s44">2</span><span class="s101">8</span>) processes running at a time? Finally, we see 3 <i>Coherence </i>(C) bits, which determine how a page is cached by the hardware (a bit beyond the scope of these notes); a <i>dirty </i>bit which is marked when the page has been written to (we’ll see the use of this later); a <i>valid </i>bit which tells the hardware if there is a valid translation present in the entry. There is also a <i>page mask </i>field (not shown), which supports multiple page sizes; we’ll see later why having larger pages might be useful. Finally, some of the 64 bits are unused (shaded gray in the diagram).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 89%;text-align: justify;">MIPS TLBs usually have 32 or 64 of these entries, most of which are used by user processes as they run. However, a few are reserved for the OS. A <i>wired </i>register can be set by the OS to tell the hardware how many slots of the TLB to reserve for the OS; the OS uses these reserved map- pings for code and data that it wants to access during critical times, where a TLB miss would be problematic (e.g., in the TLB miss handler).</p><p style="padding-left: 41pt;text-indent: 11pt;line-height: 88%;text-align: justify;">Because the MIPS TLB is software managed, there needs to be instruc- tions to update the TLB. The MIPS provides four such instructions: <span class="s41">TLBP</span>, which probes the TLB to see if a particular translation is in there; <span class="s41">TLBR</span>, which reads the contents of a TLB entry into registers; <span class="s41">TLBWI</span>, which re- places a specific TLB entry; and <span class="s41">TLBWR</span>, which replaces a random TLB entry. The OS uses these instructions to manage the TLB’s contents. It is of course critical that these instructions are <b>privileged</b>; imagine what a user process could do if it could modify the contents of the TLB (hint: just about anything, including take over the machine, run its own malicious “OS”, or even make the Sun disappear).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 54pt;text-indent: 0pt;line-height: 11pt;text-align: left;">T<span class="s7">IP</span>: RAM I<span class="s7">SN</span>’<span class="s7">T </span>A<span class="s7">LWAYS </span>RAM (C<span class="s7">ULLER</span>’<span class="s7">S </span>L<span class="s7">AW</span>)</p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 89%;text-align: justify;">The term <b>random-access memory</b>, or <b>RAM</b>, implies that you can access any part of RAM just as quickly as another. While it is generally good to think of RAM in this way, because of hardware/OS features such as the TLB, accessing a particular page of memory may be costly, particularly if that page isn’t currently mapped by your TLB. Thus, it is always good to remember the implementation tip: <b>RAM isn’t always RAM</b>. Sometimes randomly accessing your address space, particular if the number of pages accessed exceeds the TLB coverage, can lead to severe performance penal- ties. Because one of our advisors, David Culler, used to always point to the TLB as the source of many performance problems, we name this law in his honor: <b>Culler’s Law</b>.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"/><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part196.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part198.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
