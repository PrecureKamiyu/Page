<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>3</title>
    
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <div class="tocheadb">
    <h1 class="tochead" id="heading_id_2"><a id="pgfId-998529"></a><a id="pgfId-998541"></a>3 Treaps: Using randomization to balance binary search trees</h1>
  </div>

  <p class="co-summary-head"><a id="pgfId-1014580"></a>This chapter covers</p>

  <ul class="calibre19">
    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1014612"></a>Solving the problem of indexing data according to multiple criteria</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1014613"></a>Understanding the treap data structure</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1014614"></a>Keeping a binary search tree balanced</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1014615"></a>Using treaps to implement balanced binary search trees (BST)</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1014616"></a>Working with Randomized Treaps (RT)</li>

    <li class="co-summary-bullet"><a class="calibre14" id="pgfId-1014601"></a>Comparing plain BSTs and RTs</li>
  </ul>

  <p class="body"><a id="pgfId-998666"></a>In chapter 2 we saw how it is possible to store elements and retrieve them based on their priorities by using heaps, and how we can improve over binary heaps by using a larger branching factor.</p>

  <p class="body"><a id="pgfId-998679"></a>Priority queues are especially useful when we need to consume elements in a certain order from a dynamically changing list (such as the list of tasks to run on a CPU), so that at any time we can get the next element (according to a certain criterion), remove it from the list, and (usually) stop worrying about fixing anything for the other elements. The difference with a sorted list is that we only go through elements in a priority queue once, and the elements already removed from the list won’t matter for the ordering anymore.</p>

  <p class="body"><a id="pgfId-998705"></a>Instead, if we need to keep track of the ordering of elements and to possibly go through them more than once (such as a list of objects to render on a web page), priority queues might not be the best choice. Moreover, there are other kinds of operations that we might need to perform; for example, efficiently retrieving the minimum or maximum element of our collection, accessing the <code class="fm-code-in-text">i</code>-th element (without removing all elements before it), or finding the predecessor or successor of an element in our ordering.</p>

  <p class="body"><a id="pgfId-998741"></a>In appendix C we discuss how trees are the best compromise when we care about all these operations, in addition to insertion and removal. If a tree is balanced, we can perform any of these actions in logarithmic time.</p>

  <p class="body"><a id="pgfId-998756"></a>The issue is that trees in general and binary trees in particular are not guaranteed to be balanced. Figure 3.1 shows how, depending on the order of insertion, we might have very balanced or very skewed trees.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F1.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1030829"></a>Figure 3.1 All possible layouts for BSTs of size 3. The layout depends on the order in which elements are inserted. Notice how two of the sequences produce identical layouts: for <code class="fm-code-in-text">[2, 1, 3]</code> and <code class="fm-code-in-text">[2, 3, 1]</code> we get the same final result.</p>

  <p class="body"><a id="pgfId-998802"></a>In this chapter, we are going to explore a way to use heaps’ properties to be (reasonably) sure we have balanced binary trees.</p>

  <p class="body"><a id="pgfId-998820"></a>To explain how this works we will introduce <i class="calibre17">treaps</i>, a hybrid between trees and heaps; however, we are going to take a different approach to treaps that is somewhat unusual in the literature on this data structure.</p>

  <p class="body"><a id="pgfId-998840"></a>But first, as always, let’s start by introducing a problem that we would like to solve.</p>

  <h2 class="fm-head" id="heading_id_3"><a id="pgfId-998849"></a>3.1 Problem: Multi-indexing</h2>

  <p class="body"><a id="pgfId-998863"></a>Your <a id="marker-999129"></a><a id="marker-999133"></a>family runs a small grocery shop, and you’d like to help your parents keep up with the inventory. To impress your family and show everyone those computer science classes are worth the effort, you embark on the task of designing a digital inventory management tool, an archive for stock keeping, with two requirements:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-998883"></a>Be able to (efficiently) search products by name so you can update the stock.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-998898"></a>Get, at any time, the product with the lowest items in stock, so that you are able to plan your next order.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-998910"></a>Of course, you could just buy an off-the-shelf spreadsheet, but where would the fun be in that? Moreover, would anybody be really impressed with that? So, here we go, designing an in-memory data structure that can be queried according to two different criteria.</p>

  <p class="body"><a id="pgfId-998921"></a>Clearly, real-world scenarios are more complex than this.You can imagine that each product requires a different time to be shipped to you, that some products are ordered from the same vendors (and therefore you might want to group them in the same order to save on shipment costs), that a product’s price may and will vary with time (so you can choose the cheapest brand for, say, brakes or suspensions), and even that some products might be unavailable sometimes.</p>

  <p class="body"><a id="pgfId-998936"></a>All this complexity, however, can be captured in a heuristic function, a score that is computed keeping in mind all the nuances of your business. Conceptually, you can handle that score in the same exact way as the simple inventory count, so you can keep things simple in our example and just use that.</p>

  <p class="body"><a id="pgfId-998953"></a>One way to handle these requirements could be by using two different data structures: one for efficient search by name, for instance a hash table, and a priority queue to get the item which most urgently needs to be resupplied.</p>

  <p class="body"><a id="pgfId-998962"></a>We will see in chapter 7 that sometimes combining two data structures for a goal is the best choice. This is not the time yet; for now you need to keep in mind the issues in coordinating two such containers, and also that you will likely need more than twice the memory.</p>

  <p class="body"><a id="pgfId-998977"></a>Both considerations are kind of worrying; wouldn’t it be nice if there was a single data structure that could handle both aspects natively and efficiently?</p>

  <h3 class="fm-head2" id="heading_id_4"><a id="pgfId-998988"></a>3.1.1 The gist of the solution</h3>

  <p class="body"><a id="pgfId-999004"></a>Let’s be clear about what we are seeking here: it’s not just a matter of optimizing all the operations on a container, like we discuss in appendix C. Here each bit of data, each entry in the container, is made of two separate parts, and both can be “measured” in some way. There are the names of each product, which can be sorted alphabetically, and the number of items we have in stock, that’s also associated with each product: quantities that can be compared to each other to determine which products are scarcer and most urgent to resupply.</p>

  <p class="body"><a id="pgfId-999025"></a>Now, if we sort the list of entries according to one criterion—for example, the name—we need to scan the whole list to find a given value for the other criterion, in this case the quantity in stock.</p>

  <p class="body"><a id="pgfId-999034"></a>And if we use a min-heap with the scarcer products at its top, then (as we learned in chapter 2) we will also need linear time to scan the whole heap looking for a product to update.</p>

  <p class="body"><a id="pgfId-999045"></a>Long story short, none of the basic data structures we describe in appendix C, nor a priority queue, can single-handedly solve our <a id="marker-999137"></a><a id="marker-999141"></a>problem.</p>

  <h2 class="fm-head" id="heading_id_5"><a id="pgfId-999057"></a>3.2 Solution: Description and API</h2>

  <p class="body"><a id="pgfId-999069"></a>Now <a id="marker-999145"></a>that we have an idea of what our ideal container should do (but we still don’t know how it should do it), we can define an <a id="id_Hlk55647410"></a>abstract data structure<a id="marker-999149"></a> (<i class="calibre17">ADT</i> ) with the appropriate API. As long as our implementations will abide by this API, we can use any of them seamlessly in an application, or as part of a more complex algorithm, without having to worry about breaking anything (see table 3.1).</p>

  <p class="fm-table-caption"><a id="pgfId-1015293"></a>Table 3.1 API and contract for <code class="fm-code-in-text">SortedPriorityQueue</code></p>

  <table border="1" class="contenttable" width="100%">
    <tr class="calibre8">
      <th class="fm-contenttable" colspan="2" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1015297"></a>Abstract data structure: <code class="fm-code-in-text">SortedPriorityQueue</code></p>
      </th>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015301"></a>API</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <pre class="programlisting">class SortedPriorityQueue {
  top() <span class="cambria">→</span> element
  peek() <span class="cambria">→</span> element
  insert(element, priority)
  remove(element)
  update(element, newPriority)
  contains(element)
  min()
  max()
}</pre>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015305"></a>Contract with client</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015307"></a>Entries are kept sorted by element (aka key), but at any time the <code class="fm-code-in-text2">top</code>() and <code class="fm-code-in-text2">peek</code>() methods can return the element with the highest priority.</p>
      </td>
    </tr>
  </table>

  <p class="body"><a id="pgfId-999154"></a>To that end, we can imagine an extension of priority queues that also keeps its elements sorted. In the rest of the chapter, we will use the term key to refer to elements, and associate a priority to each element.</p>

  <p class="body"><a id="pgfId-999353"></a>With respect to the <code class="fm-code-in-text">PriorityQueue</code><a id="marker-1004127"></a> ADT that we introduced in chapter 2, this <code class="fm-code-in-text">SortedPriorityQueue</code> class<a id="marker-1004131"></a> has a few new methods: a search method to find a given key in the container and two methods returning the minimum and maximum key stored.</p>

  <p class="body"><a id="pgfId-999369"></a>If you look at appendix C, you can see that these three operations are usually implemented by many basic data structures, such as linked lists, arrays, or trees (some of them in linear time and others with better performance, offering logarithmic methods).</p>

  <p class="body"><a id="pgfId-999384"></a>Thus, we can think about our <code class="fm-code-in-text">SortedPriorityQueue</code><a id="marker-1004135"></a> as a melting pot between two different containers, integrating both data structures’ characteristics and providing methods from both of them. For instance, it could be thought of as a fusion between heaps and linked lists, <a id="marker-1004139"></a>or . . .</p>

  <h2 class="fm-head" id="heading_id_6"><a id="pgfId-999403"></a>3.3 Treap</h2>

  <p class="body"><a id="pgfId-999415"></a>. . . between a tree and a heap!</p>

  <p class="body"><a id="pgfId-999426"></a>Treap<a href="#pgfId-1008220"><sup class="footnotenumber">1</sup></a> is just the <i class="calibre17">portmanteau<a href="#pgfId-1008242"><sup class="footnotenumber">2</sup></a></i> of tree and heap. Binary search trees, in fact, offer the best average performance across all standard operations: <code class="fm-code-in-text">insert</code><a id="marker-1004143"></a>, <code class="fm-code-in-text">remove</code><a id="marker-1004147"></a><code class="fm-code-in-text">,</code> and <code class="fm-code-in-text">search</code><a id="marker-1004151"></a> (and also <code class="fm-code-in-text">min</code><a id="marker-1004155"></a> and <code class="fm-code-in-text">max</code><a id="marker-1004159"></a>).</p>

  <p class="body"><a id="pgfId-999460"></a>Heaps, on the other hand, allow us to efficiently keep track of priorities using a tree-like structure. Since binary heaps are also binary trees, the two structures seem compatible; we only need to find a way to make them co-exist in the same structure, and we could get the best of both.</p>

  <p class="body"><a id="pgfId-999475"></a>It’s easier said than done, however! If we have a set of unidimensional data, we can’t enforce <i class="calibre17">BST</i><a id="marker-1004163"></a>’s and heap’s invariants at the same time:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-999488"></a>Either we add a “horizontal” constraint (given a node <code class="fm-code-in-text">N</code>, with two children <code class="fm-code-in-text">L</code>, its left child, and <code class="fm-code-in-text">R</code>, its right child, then all keys in the left subtree—rooted at <code class="fm-code-in-text">L</code>—must be smaller than <code class="fm-code-in-text">N</code>’s key, and all keys in the right subtree—rooted at <code class="fm-code-in-text">R</code>—must be larger than <code class="fm-code-in-text">N</code>’s key).</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-999523"></a>Or we add a “vertical” constraint: the key in the root of any subtree must be the smallest of the subtree.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-999539"></a>Anyway, we are in luck, because each of our entries has two values: its name and the stock inventory. The idea, therefore, is to enforce BST’s constraints on the names, and heap’s constraint on the quantities, obtaining something like figure 3.2.</p>

  <p class="body"><a id="pgfId-999550"></a>In this example, product names are treated as the keys of a binary search tree, so they define a total ordering (from left to right in the figure).</p>

  <p class="body"><a id="pgfId-999559"></a>The inventory quantities, instead, are treated as priorities of a heap, so they define a partial ordering from top to bottom. For priorities, like all heaps, we have a partial ordering, meaning that only nodes on the same path from root to leaves are ordered with respect to their priority. In figure 3.2 you can see that children nodes always have a higher stock count than their parents, but there is no ordering between siblings.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F2.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1030879"></a>Figure 3.2 An example of a treap, with strings as BST keys and integers as heap priorities. Note that the heap, in this case, is a min-heap, so smaller numbers go on top. For a few links close to the root, we also show the range of keys that can be hosted in the tree’s branch rooted at the node they point to.</p>

  <p class="body"><a id="pgfId-999598"></a>This kind of tree offers an easy way to query entries by key (by the product names, in the example). While we can’t easily run a query on priorities, we can efficiently locate the element with the highest priority.<a href="#pgfId-1008262"><sup class="footnotenumber">3</sup></a> It will always be at the root of the tree!</p>

  <p class="body"><a id="pgfId-999618"></a>Extracting the top element however . . . it’s going to be more complicated than with heaps! We can’t just replace it with a heap’s leaf and push it down, because we need to take into account the BST’s constraints as well.</p>

  <p class="body"><a id="pgfId-999630"></a>Likewise, when we insert (or delete) a node, we can’t just use the simple BST algorithm. If we just search for the position that the new key would hold in the tree and add it as a leaf, as shown in figure 3.3, the BST constraint will still be abided by, but the new node’s priority might violate the heap’s invariants.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F3.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1030916"></a>Figure 3.3 An example of the insertion of a node in a treap, based on the keys ordering only. The priority of the new node, however, violates the heap constraints.</p>

  <p class="body"><a id="pgfId-999670"></a>Listing 3.1 introduces a possible implementation for the treap’s main structure. We will use an auxiliary class to model the tree’s nodes, and this will be instrumental in our implementation. You might have noticed we are using explicit links to the node’s children, differently from what we did with heaps in chapter 2. We’ll go back to discussing this choice in more detail in section 3.3.2.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015369"></a>Listing 3.1 Class <code class="fm-code-in-text">Treap</code></p>
  <pre class="programlisting"><b class="calibre21">class</b> Node
  key
  <b class="calibre21">#type</b> double
  priority
  
  <b class="calibre21">#type</b> Node
  left
  <b class="calibre21">#type</b> Node
  right
  <b class="calibre21">#type</b> Node
  parent
 
  <b class="calibre21">function</b> Node(key, priority)                    <span class="fm-combinumeral">❶</span>
    (<b class="calibre21">this</b>.key, <b class="calibre21">this</b>.priority) ← (key, priority)
    <b class="calibre21">this</b>.left ← <b class="calibre21">null</b>
    <b class="calibre21">this</b>.right ← <b class="calibre21">null</b>
    <b class="calibre21">this</b>.parent ← <b class="calibre21">null</b>
 
  <b class="calibre21">function</b> setLeft(node)                          <span class="fm-combinumeral">❷</span>
    <b class="calibre21">this</b>.left ← node
    <b class="calibre21">if</b> node != <b class="calibre21">null then</b>
      node.parent ← <b class="calibre21">this</b>
 
<b class="calibre21">class</b> Treap
  <b class="calibre21">#type</b> Node
  root
 
  <b class="calibre21">function</b> Treap()
    root ← <b class="calibre21">null</b></pre>

  <p class="fm-code-annotation"><a id="pgfId-1029579"></a><span class="fm-combinumeral">❶</span> The constructor for the class <code class="fm-code-in-text2">Node</code> sets the key and priority to the arguments and <code class="fm-code-in-text2">null</code> for all links.</p>

  <p class="fm-code-annotation"><a id="pgfId-1029600"></a><span class="fm-combinumeral">❷</span> Updates the left child of a <code class="fm-code-in-text2">Node</code><a id="marker-1029604"></a>. This also takes care of updating the parent reference for the children. Method <code class="fm-code-in-text2">setRight</code><a id="marker-1029606"></a>, not shown for the sake of space, works symmetrically.</p>

  <p class="body"><a id="pgfId-1000059"></a>In this implementation, the <code class="fm-code-in-text">Treap</code> class<a id="marker-1004175"></a> is mostly a wrapper for the root of the actual tree; each node of the tree holds two attributes for a <code class="fm-code-in-text">key</code> (that can be of any type, as long as there is a total ordering defined on the possible values) and a <code class="fm-code-in-text">priority</code>, that we’ll assume to be a double precision number in this case. (An integer or any type with a total ordering could work too, but we’ll see in the next section that a double works better.)</p>

  <p class="body"><a id="pgfId-1000082"></a>Moreover, nodes will hold pointers (or references) to two children, left and right, and their parent.</p>

  <p class="body"><a id="pgfId-1000091"></a>The constructor for a node will just set the key and priority attributes from its arguments, and initialize left and right pointers to <code class="fm-code-in-text">null</code>, effectively creating a leaf. The two branches can then be set after construction, or, alternatively, an overloaded version of the constructor also taking the two children can be provided.</p>

  <h3 class="fm-head2" id="heading_id_7"><a id="pgfId-1000108"></a>3.3.1 Rotations</h3>

  <p class="body"><a id="pgfId-1000120"></a>How <a id="marker-1004179"></a><a id="marker-1004183"></a>do we get out of the impasse? There is one operation on binary search trees that can help us: rotations. Figure 3.4 illustrates how rotations can heal (or break!) the constraints on a treap. Rotations are common operations on many versions of BSTs, such as red-black trees or 2-3 trees.<a href="#pgfId-1008278"><sup class="footnotenumber">4</sup></a></p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F4.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1030960"></a>Figure 3.4 Left and right rotations illustrated on an example. The treap on the left violates heap’s invariants, and a right rotation on the node marked as <code class="fm-code-in-text">X</code> can fix it. Conversely, if we apply a left rotation to the node marked with <code class="fm-code-in-text">Y</code> in the heap on the right, the result will break heap’s constraints. Notice how right rotation is always applied to left children, and left rotation to right children.</p>

  <p class="body"><a id="pgfId-1000165"></a>A rotation, in a binary search tree, is a transformation whose goal is inverting the parent-child relation between two nodes of the tree, <code class="fm-code-in-text">Y</code> and <code class="fm-code-in-text">X</code> in figure 3.4. We want the child node to become the parent node and vice versa, but we can’t just swap those two nodes: otherwise, in the general case where the keys of the two nodes are different, we would end up violating the ordering of keys.</p>

  <p class="body"><a id="pgfId-1000190"></a>Instead, what we need to do is remove the whole subtree rooted at the parent, replace it with the (smaller) subtree rooted at the child, and then find a way to plug back in the removed nodes in this new subtree.</p>

  <p class="body"><a id="pgfId-1000201"></a>How are we going to do that? As you can see in figure 3.4, first we need to distinguish two cases, depending on whether the child node is a left or a right child. The two cases are symmetrical, so we’ll mainly focus on the former.</p>

  <p class="body"><a id="pgfId-1000210"></a>Listings 3.2 and 3.3 show the pseudocode for right and left rotations, explicating the details of the operations we described a few lines prior. Figure 3.5 illustrates the steps needed for right rotations, where the child node <code class="fm-code-in-text">X</code>, the pivot of the rotation, is the left child of its parent <code class="fm-code-in-text">Y</code>.</p>

  <p class="body"><a id="pgfId-1000227"></a>We need to remove <code class="fm-code-in-text">Y</code> from the tree, update <code class="fm-code-in-text">Y</code>’s parent <code class="fm-code-in-text">P</code> (lines #4–11), replacing <code class="fm-code-in-text">Y</code> with node <code class="fm-code-in-text">X</code> as its child (either left or right, see lines #8-#11); at this point, <code class="fm-code-in-text">Y</code> is disconnected from the tree, and with <code class="fm-code-in-text">Y</code> its whole right subtree.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015397"></a><a id="id_Hlk20930425"></a>Listing 3.2 Right rotation</p>
  <pre class="programlisting"><b class="calibre21">function</b> rightRotate(treap, x)          <span class="fm-combinumeral">❶</span>
  <b class="calibre21">if</b> x == null or isRoot(x) <b class="calibre21">then</b>        <span class="fm-combinumeral">❷</span>
    <b class="calibre21">throw</b>
  y ← x.parent                          <span class="fm-combinumeral">❸</span>
  <b class="calibre21">throw-if</b> y.left != x                  <span class="fm-combinumeral">❹</span>
  p  ← y.parent                         <span class="fm-combinumeral">❺</span>
  <b class="calibre21">if</b> p != <b class="calibre21">null then</b>                     <span class="fm-combinumeral">❻</span>
    <b class="calibre21">if</b> p.left == y <b class="calibre21">then</b>                 <span class="fm-combinumeral">❼</span>
      p.setLeft(x)                      <span class="fm-combinumeral">❽</span>
    <b class="calibre21">else</b>
      p.setRight(x)
  <b class="calibre21">else</b>                                  <span class="fm-combinumeral">❾</span>
    treap.root ← x
  y.setLeft(x.right)                    <span class="fm-combinumeral">❿</span>
  x.setRight(y)                         <span class="fm-combinumeral">⓫</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1028796"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">rightRotate</code><a id="marker-1028800"></a> takes a <code class="fm-code-in-text2">Treap</code><a id="marker-1028801"></a> node <code class="fm-code-in-text2">x</code> and performs a right rotation. It returns nothing, but it has side effects on the treap.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028819"></a><span class="fm-combinumeral">❷</span> Checks if <code class="fm-code-in-text2">x</code> is <code class="fm-code-in-text2">null</code> or the root of the tree. If it is, there is an error. Arguably, we can just return instead of throwing, but swallowing exceptions is usually not a good idea. Method <code class="fm-code-in-text2">isRoot</code><a id="marker-1028824"></a> is left to the reader to implement. (It’s easy, since the root is the only node in a tree without a parent.)</p>

  <p class="fm-code-annotation"><a id="pgfId-1028840"></a><span class="fm-combinumeral">❸</span> Uses a convenience variable for <code class="fm-code-in-text2">x</code>’s parent. Since <code class="fm-code-in-text2">x</code> is not the root of the tree, <code class="fm-code-in-text2">y</code> won’t be <code class="fm-code-in-text2">null</code> (so, no need for an extra check).</p>

  <p class="fm-code-annotation"><a id="pgfId-1028862"></a><span class="fm-combinumeral">❹</span> We can only perform a right rotation on a left child; so if <code class="fm-code-in-text2">x</code> is <code class="fm-code-in-text2">y</code>’s right child, there is an error.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028879"></a><span class="fm-combinumeral">❺</span> Uses a convenience variable for <code class="fm-code-in-text2">y</code>’s parent</p>

  <p class="fm-code-annotation"><a id="pgfId-1028896"></a><span class="fm-combinumeral">❻</span> This time we don’t know if <code class="fm-code-in-text2">p</code> is <code class="fm-code-in-text2">null</code> or not, so we need to check.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028913"></a><span class="fm-combinumeral">❼</span> Once we know <code class="fm-code-in-text2">p</code> is not <code class="fm-code-in-text2">null</code>, we still don’t know if <code class="fm-code-in-text2">y</code> is its left or right child.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028930"></a><span class="fm-combinumeral">❽</span> If there is a parent for <code class="fm-code-in-text2">y</code>, we need to update it, replacing <code class="fm-code-in-text2">y</code> with <code class="fm-code-in-text2">x</code>. Methods <code class="fm-code-in-text2">setLeft</code><a id="marker-1028935"></a> and <code class="fm-code-in-text2">setRight</code><a id="marker-1028936"></a> take care of updating all the links, as shown in listing 3.1.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028949"></a><span class="fm-combinumeral">❾</span> If, instead, <code class="fm-code-in-text2">p</code> is <code class="fm-code-in-text2">null</code>, it means that <code class="fm-code-in-text2">y</code> was the treap’s root, so we need to update the tree, making <code class="fm-code-in-text2">x</code> its new root.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028966"></a><span class="fm-combinumeral">❿</span> Now that a reference to <code class="fm-code-in-text2">x</code> is stored (either as <code class="fm-code-in-text2">p</code>’s child or as the new root), we can update <code class="fm-code-in-text2">y</code>’s left subtree, that will now point to <code class="fm-code-in-text2">x</code>’s former right subtree.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028983"></a><span class="fm-combinumeral">⓫</span> Finally, we reconnect <code class="fm-code-in-text2">y</code> to the tree by setting it as <code class="fm-code-in-text2">x</code>’s new right child.</p>

  <p class="body"><a id="pgfId-1000679"></a><code class="fm-code-in-text">Y</code>’s left subtree, instead, is empty because we disconnected <code class="fm-code-in-text">X</code> and moved it. We can then move <code class="fm-code-in-text">X</code>’s right subtree and assign it to <code class="fm-code-in-text">Y</code>’s left child (line #14), as shown in the lower-left section of figure 3.5. This certainly doesn’t violate the key ordering, because (assuming there was no violation <i class="calibre17">before</i> the rotation) <code class="fm-code-in-text">key[Y]&gt;=key[Y.left]</code> and <code class="fm-code-in-text">key[Y]&gt;=key[Y.left.right]</code>. In other words, since <code class="fm-code-in-text">X</code> was the left child of node <code class="fm-code-in-text">Y</code>, then the right subtree of node <code class="fm-code-in-text">X</code> is still in <code class="fm-code-in-text">Y</code>’s left subtree, and all keys in a node’s left subtree are smaller, or at most equal, to the node’s own key. You can also use figure 3.2 as a reference.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F5.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031008"></a>Figure 3.5 The algorithm for performing a right rotation on a BST illustrated</p>

  <p class="body"><a id="pgfId-1000749"></a>All that’s left to do now is reconnect <code class="fm-code-in-text">Y</code> to the main tree: we can assign it to <code class="fm-code-in-text">X</code>’s right child (line #15), and we won’t have any violation. In fact, we already know that <code class="fm-code-in-text">Y</code> (and its right sub-tree) have larger keys than <code class="fm-code-in-text">X</code>’s, and for what concerns <code class="fm-code-in-text">Y</code>’s left subtree, it was constructed using the former right subtree of <code class="fm-code-in-text">X</code>, and by definition all those keys too are larger than <code class="fm-code-in-text">X</code>’s.</p>

  <p class="body"><a id="pgfId-1000780"></a>We saw how to perform a rotation. It’s nothing fancy; it’s just about updating a few links in the tree. The only mystery at this point might be, why is it called a rotation?</p>

  <p class="body"><a id="pgfId-1000799"></a>Figure 3.6 tries to answer this question, interpreting the steps we saw in listing 3.2 and figure 3.5 from a different point of view. Let me remark that this is just an informal way to illustrate how a rotation works. When you are going to implement this method, you’d better refer to listing 3.2 and figure 3.5.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015426"></a>Listing 3.3 Left rotation</p>
  <pre class="programlisting"><b class="calibre21">function</b> lefttRotate(treap, x)      <span class="fm-combinumeral">❶</span>
  <b class="calibre21">if</b> x == null or isRoot(x) <b class="calibre21">then</b>    <span class="fm-combinumeral">❷</span>
    <b class="calibre21">throw</b>
  y ← x.parent                      <span class="fm-combinumeral">❸</span>
  <b class="calibre21">throw-if</b> y.right != x             <span class="fm-combinumeral">❹</span>
  p ← y.parent                      <span class="fm-combinumeral">❺</span>
  <b class="calibre21">if</b> p != <b class="calibre21">null then</b>                 <span class="fm-combinumeral">❻</span>
    <b class="calibre21">if</b> p.left == y <b class="calibre21">then</b>             <span class="fm-combinumeral">❼</span>
      p.setLeft(x)                  <span class="fm-combinumeral">❽</span>
    <b class="calibre21">else</b>
      p.setRight(x)
  <b class="calibre21">else</b>                              <span class="fm-combinumeral">❾</span>
    treap.root ← x
  y.setRight(x.left)                <span class="fm-combinumeral">❿</span>
  x.setLeft(y)                      <span class="fm-combinumeral">⓫</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1028072"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">leftRotate</code><a id="marker-1028083"></a> takes a <code class="fm-code-in-text2">Treap</code><a id="marker-1028084"></a> node <code class="fm-code-in-text2">x</code> and performs a left rotation. It returns nothing but it has side effects on the treap.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028102"></a><span class="fm-combinumeral">❷</span> Checks if <code class="fm-code-in-text2">x</code> is <code class="fm-code-in-text2">null</code> or the root of the tree. If so, there is an error.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028122"></a><span class="fm-combinumeral">❸</span> Uses a convenience variable for <code class="fm-code-in-text2">x</code>’s parent. Since <code class="fm-code-in-text2">x</code> is not the root of the tree, <code class="fm-code-in-text2">y</code> won’t be <code class="fm-code-in-text2">null</code>.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028139"></a><span class="fm-combinumeral">❹</span> We can only perform a left rotation on a right child. If <code class="fm-code-in-text2">x</code> is <code class="fm-code-in-text2">y</code>’s left child, there is an error.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028156"></a><span class="fm-combinumeral">❺</span> Uses a convenience variable for <code class="fm-code-in-text2">y</code>’s parent</p>

  <p class="fm-code-annotation"><a id="pgfId-1028173"></a><span class="fm-combinumeral">❻</span> We don’t know if <code class="fm-code-in-text2">p</code> is <code class="fm-code-in-text2">null</code> or not, so we need to check.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028190"></a><span class="fm-combinumeral">❼</span> Once we know <code class="fm-code-in-text2">p</code> is not <code class="fm-code-in-text2">null</code>, we still don’t know if <code class="fm-code-in-text2">y</code> is its left or right child.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028207"></a><span class="fm-combinumeral">❽</span> If there is a parent for <code class="fm-code-in-text2">y</code>, we need to update it, replacing <code class="fm-code-in-text2">y</code> with <code class="fm-code-in-text2">x</code>. Methods <code class="fm-code-in-text2">setLeft</code><a id="marker-1028212"></a> and <code class="fm-code-in-text2">setRight</code><a id="marker-1028213"></a> take care of updating all the links, as shown in listing 3.1.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028226"></a><span class="fm-combinumeral">❾</span> If, instead, <code class="fm-code-in-text2">p</code> is <code class="fm-code-in-text2">null</code>, it means that <code class="fm-code-in-text2">y</code> was the treap’s root, so we need to update the tree making <code class="fm-code-in-text2">x</code> its new root.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028243"></a><span class="fm-combinumeral">❿</span> Now that a reference to <code class="fm-code-in-text2">x</code> is stored (either as <code class="fm-code-in-text2">p</code>’s child or as the new root), we can update <code class="fm-code-in-text2">y</code>’s right subtree to point to <code class="fm-code-in-text2">x</code>’s former left subtree.</p>

  <p class="fm-code-annotation"><a id="pgfId-1028260"></a><span class="fm-combinumeral">⓫</span> Finally, we reconnect <code class="fm-code-in-text2">y</code> to the tree by setting it as <code class="fm-code-in-text2">x</code>’s new left child.</p>

  <p class="body"><a id="pgfId-1001225"></a>First, let’s assume we call rotate on node <code class="fm-code-in-text">X</code>, and node <code class="fm-code-in-text">Y</code> is <code class="fm-code-in-text">X</code>’s parent. Once again, we analyze right rotation, so <code class="fm-code-in-text">X</code> is a left child of <code class="fm-code-in-text">Y</code>.</p>

  <p class="body"><a id="pgfId-1001248"></a>If we consider the subtree rooted at <code class="fm-code-in-text">Y</code>, we can visually “rotate” it clockwise (hence “right rotation”), pivoting on node <code class="fm-code-in-text">X</code>, until <code class="fm-code-in-text">X</code> looks like the root of this tree; hence, all other nodes appear to be below <code class="fm-code-in-text">X</code>, as shown in figure 3.6.</p>

  <p class="body"><a id="pgfId-1001291"></a>The result should look something like the top-right quadrant of figure 3.6. Of course, in order for this to be a valid BST rooted at node <code class="fm-code-in-text">X</code>, we need to make a few changes. For instance, there seems to be an edge from a child to its parent, from <code class="fm-code-in-text">Y</code> to <code class="fm-code-in-text">X:</code> but that’s not allowed in trees, so we need to revert the direction of the edge. If we just did that, though, <code class="fm-code-in-text">X</code> would end up with three children, and that’s also not allowed in a binary tree; to fix it, we can transfer the link between <code class="fm-code-in-text">X</code> and its right child to <code class="fm-code-in-text">Y</code>. Both changes are shown in the bottom-left portion of figure 3.6.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F6.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031061"></a>Figure 3.6 A more intuitive interpretation of the <code class="fm-code-in-text">rightRotate</code><a id="marker-1031060"></a> operation that helps explain its name and also helps with memorizing its steps</p>

  <p class="body"><a id="pgfId-1001329"></a>At this point, the subtree is structurally fixed, and as a last step we can just enhance its visual representation to make it also look a little better.</p>

  <p class="body"><a id="pgfId-1001338"></a>You can imagine the tree structure like some kind of bolt and strings dangling structure, and then the whole operation can be described as grabbing the tree by node <code class="fm-code-in-text">X</code> and letting all the other nodes dangle from it, with the caveat that we need to also move <code class="fm-code-in-text">X</code>’s right child to node <code class="fm-code-in-text">Y</code>.</p>

  <p class="body"><a id="pgfId-1001355"></a>Before closing the discussion on rotations, it’s important to note that rotations always preserve BST constraints, but they do <i class="calibre17">not</i> preserve heap’s invariants. Rotations, in fact, can be used to fix broken treaps, but if applied to a valid tree, they will break the priority constraints on the node to which they are <a id="marker-1004227"></a><a id="marker-1004231"></a>applied.</p>

  <h3 class="fm-head2" id="heading_id_8"><a id="pgfId-1001376"></a>3.3.2 A few design questions</h3>

  <p class="body"><a id="pgfId-1001395"></a>Treaps <a id="marker-1004235"></a>are heaps, which in turn are special trees with a dual array representation. As we saw in chapter 2, we can implement a heap using an array, a more space-efficient representation that also exploits locality of reference.</p>

  <p class="body"><a id="pgfId-1001412"></a>Can we also implement a treap using an array? I encourage you to take a minute and think about this question, before moving on and reading the answer. What would be the pros and cons of using an array versus a tree, and what could be the pain points of using a tree?</p>

  <p class="body"><a id="pgfId-1001431"></a>The issue with the array representation is that it’s not particularly flexible. It works well if we only swap random elements and remove/add only from the array’s tail; if, instead, we need to move elements around, it’s a disaster! For instance, even inserting a new element in the middle of the array causes all the elements after it to be moved, for an average <code class="fm-code-in-text">O(n)</code> swaps (see figure 3.7).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F7.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031106"></a>Figure 3.7 When a new element is inserted in an ordered array, all the elements larger than the new one must be shifted one position toward the tail of the array (provided there is still room). This means that if the array has <code class="fm-code-in-text">n</code> elements and the new value will be stored at index <code class="fm-code-in-text">k</code> (that is, it will be the <code class="fm-code-in-text">(k+1)</code>-th element in the array), then <code class="fm-code-in-text">n-k</code> assignments will be needed to complete the insertion.</p>

  <p class="body"><a id="pgfId-1001482"></a>The key point with heaps is that they are complete, balanced, and left-aligned trees, which is possible because heaps don’t keep a total ordering on keys, so we can add and remove elements from the tail of the array, and then bubble up/push down a single element of the heap to reinstate the heap’s properties (see chapter 2).</p>

  <p class="body"><a id="pgfId-1001493"></a>Treaps, on the other hand, are also binary search trees, which do keep a total ordering on keys. That’s why we need rotations when we insert or delete new elements from a treap. As we described in section 3.2.1, a rotation implies moving a whole subtree from the right subtree of a node <code class="fm-code-in-text">X</code> to the left subtree of its parent <code class="fm-code-in-text">Y</code> (or vice versa). As you can imagine, this is the kind of operation that is easily performed in constant time when using pointers on a tree’s nodes, but it can become excruciatingly painful on arrays (like, linear-time painful).</p>

  <p class="body"><a id="pgfId-1001515"></a>And that’s why the array representation is not used for treaps (or for BSTs).</p>

  <p class="body"><a id="pgfId-1001524"></a>Another design question you might ask (and also <i class="calibre17">should</i> ask) before getting on with the implementation concerns the branching factor for the heap. We saw in chapter 2 that heaps can have branching factors other than 2, and in section 2.10 we also saw that a heap with a branching factor of 4 or higher sensibly outperforms a binary heap (at least in our example application). Can we also implement a treap with a generic branching factor greater than 2?</p>

  <p class="body"><a id="pgfId-1001552"></a>Unfortunately, it’s not that simple. First and foremost, we are using binary search trees, so a tree with a branching factor of 2: if the heap’s branching factor didn’t match the BST’s, it would be a mess!</p>

  <p class="body"><a id="pgfId-1001571"></a>Then you might suggest using ternary search trees, or their generalization; however, that would make the rotation operations much more complicated, which means the code of the implementation would become terribly complicated and unclean (which likely also means slower!). Moreover, we would have a harder time keeping the tree balanced, unless we use something like a 2-3 tree, but that’s already guaranteed to be a balanced <a id="marker-1004239"></a>tree in the first place.</p>

  <h3 class="fm-head2" id="heading_id_9"><a id="pgfId-1001592"></a>3.3.3 Implementing search</h3>

  <p class="body"><a id="pgfId-1001606"></a>Now <a id="marker-1004243"></a>that we have a better idea of how a treap is going to be represented in memory and how rotations work, we can move to the implementation of the main API’s methods. You can also find a Java implementation of treaps in the book’s <span class="fm-hyperlink">repo</span> on GitHub.<a href="#pgfId-1008293"><sup class="footnotenumber">5</sup></a></p>

  <p class="body"><a id="pgfId-1001621"></a>We can start from the search method that’s the easiest to describe. In fact, it’s just the plain search method implemented in binary search trees: we traverse the tree from the root until we find the key we are looking for or reach a leaf without find-ing it.</p>

  <p class="body"><a id="pgfId-1001636"></a>As with plain BSTs, we only traverse one branch of each subtree, going left or right depending on how the target key compares to the current node’s key.</p>

  <p class="body"><a id="pgfId-1001646"></a>Listing 3.4 shows the implementation of the internal method taking a node as input and traversing its subtree; this version uses recursion (a technique described in appendix E). It’s worth repeating that although recursion often results in cleaner code when applied to iterative data structures such as trees, recursive methods can cause stack overflow if the depth of the recursion is significant. In this particular case, some programming languages’ compilers will be able to apply tail call optimization and transform recursion into an explicit loop, while translating the code into machine language.<a href="#pgfId-1008309"><sup class="footnotenumber">6</sup></a> Generally, however, it might be worth considering directly writing the explicit loop equivalent even in the higher level language, especially if you are not sure about your compiler support for tail recursion optimization, or the conditions where it can be applied.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015454"></a>Listing 3.4 Method <code class="fm-code-in-text">search</code></p>
  <pre class="programlisting"><b class="calibre21">function</b> search(node, targetKey)              <span class="fm-combinumeral">❶</span>
  <b class="calibre21">if</b> node == <b class="calibre21">null then</b>                        <span class="fm-combinumeral">❷</span>
    <b class="calibre21">return null</b>
  <b class="calibre21">if</b> node.key == targetKey <b class="calibre21">then</b>               <span class="fm-combinumeral">❸</span>
    <b class="calibre21">return</b> node
  <b class="calibre21">elsif</b> targetKey &lt; node.key <b class="calibre21">then</b>             <span class="fm-combinumeral">❹</span>
    <b class="calibre21">return</b> search(node.left, targetKey)       <span class="fm-combinumeral">❺</span>
  <b class="calibre21">else</b>
    <b class="calibre21">return</b> search(node.right, targetKey)      <span class="fm-combinumeral">❻</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1027703"></a><span class="fm-combinumeral">❶</span> Method search takes a treap’s node and the key to search. It returns the node holding the key, if found; otherwise <code class="fm-code-in-text2">null</code>.</p>

  <p class="fm-code-annotation"><a id="pgfId-1027724"></a><span class="fm-combinumeral">❷</span> If this node is <code class="fm-code-in-text2">null</code>, returns <code class="fm-code-in-text2">null</code> to indicate the key wasn’t found.</p>

  <p class="fm-code-annotation"><a id="pgfId-1027744"></a><span class="fm-combinumeral">❸</span> If the node’s key matches the target key, we have found our target: just return current node.</p>

  <p class="fm-code-annotation"><a id="pgfId-1027761"></a><span class="fm-combinumeral">❹</span> Checks how the target key compares to the current node’s</p>

  <p class="fm-code-annotation"><a id="pgfId-1027778"></a><span class="fm-combinumeral">❺</span> If it’s smaller than current node’s key, we need to traverse the left branch.</p>

  <p class="fm-code-annotation"><a id="pgfId-1027795"></a><span class="fm-combinumeral">❻</span> Otherwise, the target key can only be stored in the right branch, and we need to traverse it.</p>

  <p class="body"><a id="pgfId-1001883"></a>The API method <code class="fm-code-in-text">contains</code><a id="marker-1004247"></a> for the <code class="fm-code-in-text">Treap</code> class<a id="marker-1004251"></a> just calls method search on the root and returns <code class="fm-code-in-text">false</code><a id="marker-1004255"></a> or <code class="fm-code-in-text">true</code><a id="marker-1004259"></a> depending on whether the result is <code class="fm-code-in-text">null</code> or <a id="marker-1004263"></a>not.</p>

  <h3 class="fm-head2" id="heading_id_10"><a id="pgfId-1001909"></a>3.3.4 Insert</h3>

  <p class="body"><a id="pgfId-1001921"></a>While <a id="marker-1004267"></a>searching a key in a treap is relatively easy, inserting a new entry is a completely different story. As we mentioned in section 3.3.1, using BST insertion won’t work in the general case, because while the new entry’s key would end up in the right place in the tree, its priority might violate the heap’s invariants, being larger than its parent (figure 3.8).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F8.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031148"></a>Figure 3.8 First steps of inserting a new entry. We search the new entry’s key to spot the right place to add a new leaf in the tree. Now we must check if the new node violates the heap’s invariants. Unfortunately, in this example it does, so we need to correct the situation by performing a left rotation (shown in figure 3.9).</p>

  <p class="body"><a id="pgfId-1001967"></a>There is no reason to despair, though! We have a way to fix the heap’s invariants, and we have actually already seen the solution: performing a rotation on the node violating the priority constraints.</p>

  <p class="body"><a id="pgfId-1001978"></a>At a high level, the <code class="fm-code-in-text">insert</code> method has just two steps: insert the new node as a leaf, and then check if its priority is higher than its parent. If that’s the case, we need to bubble the new node up, but we can’t just swap it with its parent, like we would in a heap.</p>

  <p class="body"><a id="pgfId-1001993"></a>Using figure 3.6 as a reference, we need to take the subtree rooted in the new node’s parent and then rotate it so that the new node becomes the root of this subtree (because it’s certainly going to be the node with the highest priority).</p>

  <p class="body"><a id="pgfId-1002007"></a>Listing 3.5 describes the pseudocode for the insertion method, while figures 3.8 and 3.9 illustrate an example of inserting a new entry to add “Beer” to the inventory with 20 units in stock.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015490"></a>Listing 3.5 Method <code class="fm-code-in-text">Node::insert</code></p>
  <pre class="programlisting"><b class="calibre21">function</b> insert(treap, key, priority)                    <span class="fm-combinumeral">❶</span>
  node ← treap.root                                      <span class="fm-combinumeral">❷</span>
  parent ← <b class="calibre21">null</b>
  newNode ← <b class="calibre21">new</b> Node(key, priority)                      <span class="fm-combinumeral">❸</span>
  <b class="calibre21">while</b> node != <b class="calibre21">null do</b>                                  <span class="fm-combinumeral">❹</span>
    parent ← node                                        <span class="fm-combinumeral">❺</span>
    <b class="calibre21">if</b> node.key &lt;= key <b class="calibre21">then</b>                              <span class="fm-combinumeral">❻</span>
      node ← node.left 
    <b class="calibre21">else</b>                                                 <span class="fm-combinumeral">❼</span>
      node ← node.right
  <b class="calibre21">if</b> parent == <b class="calibre21">null then</b>                                 <span class="fm-combinumeral">❽</span>
    treap.root ← newNode                                 <span class="fm-combinumeral">❾</span>
    <b class="calibre21">return</b>
  <b class="calibre21">elsif</b> key &lt;= parent.key <b class="calibre21">then</b>                           <span class="fm-combinumeral">❿</span>
    parent.left ← newNode                                
  <b class="calibre21">else</b>         
    parent.right ← newNode                                
  newNode.parent ← parent                                <span class="fm-combinumeral">⓫</span>
  <b class="calibre21">while</b> newNode.parent != <b class="calibre21">null</b>
      <b class="calibre21">and</b> newNode.priority &lt; newNode.parent.priority do  <span class="fm-combinumeral">⓬</span>
    <b class="calibre21">if</b> newNode == newNode.parent.left <b class="calibre21">then</b>               <span class="fm-combinumeral">⓭</span>
      rightRotate(newNode)
    <b class="calibre21">else</b>
      leftRotate(newNode)                                <span class="fm-combinumeral">⓮</span>
  <b class="calibre21">if</b> newNode.parent == <b class="calibre21">null then</b>                         <span class="fm-combinumeral">⓯</span>
    treap.root ← newNode</pre>

  <p class="fm-code-annotation"><a id="pgfId-1026620"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">insert</code><a id="marker-1026624"></a> takes a treap instance, the key and the priority to insert; the method doesn’t return anything but it has side effects. Duplicates are allowed (added to a node’s left subtree).</p>

  <p class="fm-code-annotation"><a id="pgfId-1026642"></a><span class="fm-combinumeral">❷</span> Initializes two temporary variables, for current node (initially the treap’s root) and its parent.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026662"></a><span class="fm-combinumeral">❸</span> Creates a new node for the key and priority passed (just out of convenience, we create it in a single place).</p>

  <p class="fm-code-annotation"><a id="pgfId-1026679"></a><span class="fm-combinumeral">❹</span> Traverses the tree until it gets to a <code class="fm-code-in-text2">null</code> node (when this happens, <code class="fm-code-in-text2">parent</code> will point to a leaf).</p>

  <p class="fm-code-annotation"><a id="pgfId-1026696"></a><span class="fm-combinumeral">❺</span> Updates <code class="fm-code-in-text2">parent</code>, since current node is not <code class="fm-code-in-text2">null</code></p>

  <p class="fm-code-annotation"><a id="pgfId-1026713"></a><span class="fm-combinumeral">❻</span> Checks how the new key compares to current node’s key; if it’s not larger, we take the left branch.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026730"></a><span class="fm-combinumeral">❼</span> Otherwise, we go right.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026747"></a><span class="fm-combinumeral">❽</span> Now we are outside the while loop, so <code class="fm-code-in-text2">node==null</code>, but we also need to check that <code class="fm-code-in-text2">parent</code> is not <code class="fm-code-in-text2">null</code>. It will be <code class="fm-code-in-text2">null</code> only if the root of the tree is itself <code class="fm-code-in-text2">null</code>; that is, if the tree is empty.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026764"></a><span class="fm-combinumeral">❾</span> If the treap was empty, we never entered the <code class="fm-code-in-text2">while</code> loop, and we just need to create a new root. Once that’s assigned to the treap’s internal field, we are finished.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026791"></a><span class="fm-combinumeral">❿</span> We need to check if we should add the new key as the left or right child of <code class="fm-code-in-text2">parent</code>.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026808"></a><span class="fm-combinumeral">⓫</span> Either way, we need to set the correct parent link for the newly added node.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026825"></a><span class="fm-combinumeral">⓬</span> Now we need to check heap’s invariants. Until they are reinstated or we get to the root, we need to bubble up current node.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026842"></a><span class="fm-combinumeral">⓭</span> If this node is a left child, then we need to use <code class="fm-code-in-text2">rightRotate</code><a id="marker-1026847"></a>.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026860"></a><span class="fm-combinumeral">⓮</span> Otherwise, we will rotate <code class="fm-code-in-text2">newNode</code><a id="marker-1026864"></a> left.</p>

  <p class="fm-code-annotation"><a id="pgfId-1026878"></a><span class="fm-combinumeral">⓯</span> In case at the end of the cycle <code class="fm-code-in-text2">newNode</code> bubbled up to the root, we need to update the root property<a id="marker-1026883"></a> of the treap.</p>

  <p class="body"><a id="pgfId-1002593"></a>First, we need to find the right place to insert the new entry in our existing inventory. This is done with a traversal of the tree, exactly like what happens with search, only keeping track of the parent of the current node in order to be able to add the new leaf. Notice that we implemented this traversal using an explicit loop here, instead of recursion, to show to our readers how this approach works.</p>

  <p class="body"><a id="pgfId-1002616"></a>As we can see in the top half of figure 3.8, the first step is traversing the tree to search the right spot where we can add the new node as a leaf. We go left when we traverse “Flour” and “Butter,” then right at “Bacon” (lines #5–10 of listing 3.5).</p>

  <p class="body"><a id="pgfId-1002629"></a>Notice that for brevity we used a contracted naming notation in the figure. The newly added node, corresponding to variable <code class="fm-code-in-text">newNode</code> in listing 3.5, is denoted as <code class="fm-code-in-text">X</code> in the figures, and its parent with <code class="fm-code-in-text">P</code>.</p>

  <p class="body"><a id="pgfId-1002648"></a>At this point, when we exit the while loop, the temporary variable <code class="fm-code-in-text">parent</code> points to the node with key “Bacon”; therefore the conditions at lines #11 and #14 are false, and we add the new node as a right child of <code class="fm-code-in-text">parent</code>, as shown in the bottom half of fig-ure 3.8.</p>

  <p class="body"><a id="pgfId-1002661"></a>Looking at the example, we can also notice how the new node has a higher priority (a lower number of units in stock) than its parent; therefore, we enter the loop at line #19, and perform a left rotation. After the first iteration of the loop and the left rotation, the “Beer” node still has higher priority than its new parent, “Butter,” as shown in the top half of figure 3.9. Therefore, we enter a second iteration of the loop, this time performing a right rotation, because node <code class="fm-code-in-text">X</code> is now a left child of <code class="fm-code-in-text">P</code>.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F9.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031200"></a>Figure 3.9 Insertion (continued). To fix the heap’s invariants, we needed to perform a right rotation on the treap at the end of figure 3.8. This action bubbles up the new node one level, and the result is shown at the top of this figure. The heap’s invariants are still violated, so we need to perform a further rotation (left, this time).</p>

  <p class="body"><a id="pgfId-1002680"></a>Since now (bottom half of figure 3.9) no invariant is violated anymore, we can exit the loop. And since the new node wasn’t bubbled up all the way to the root, the check at line #24 fails, and we don’t need to do anything else.</p>

  <p class="body"><a id="pgfId-1002727"></a>What’s the running time for insert? Adding a new leaf requires <code class="fm-code-in-text">O(h)</code>, because we need to traverse the tree from its root to a leaf. Then we can bubble up the new node at most to the root, and at each rotation we move the node one level up, so we can perform at most <code class="fm-code-in-text">h</code> rotations. Each rotation requires a constant number of pointers to be updated, so that bubbling up the new node and the whole method finally requires <code class="fm-code-in-text">O(h)</code> <a id="marker-1004287"></a><a id="marker-1004291"></a>steps.</p>

  <h3 class="fm-head2" id="heading_id_11"><a id="pgfId-1002756"></a>3.3.5 Delete</h3>

  <p class="body"><a id="pgfId-1002768"></a>Deleting <a id="marker-1004295"></a>a key from a treap is a conceptually simpler operation, although it requires a completely different approach with respect to BSTs. In binary search trees, we replace the removed node with its successor (or predecessor), but this approach wouldn’t work in treaps, because this replacement could have a smaller priority than its new children, and in that case, it would need to be pushed down. Moreover, in the general case for BSTs, the successor of a node is not a leaf, and so it needs to be recursively removed.</p>

  <p class="body"><a id="pgfId-1002779"></a>A simpler approach consists of preemptively pushing down the node to be removed, all the way until it reaches a leaf. As a leaf, it can then be disconnected from the tree without any effect.</p>

  <p class="body"><a id="pgfId-1002794"></a>Conceptually, it’s like assigning the lowest possible priority to the node to be removed, and fixing the heap’s invariants by pushing down the node. The operation won’t stop until the node with an infinite (negative) priority reaches a leaf.</p>

  <p class="body"><a id="pgfId-1002811"></a>This is illustrated in figure 3.10 and described in listing 3.6.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015518"></a>Listing 3.6 Method <code class="fm-code-in-text">Treap::remove</code></p>
  <pre class="programlisting"><b class="calibre21">function</b> remove(treap, key)                                  <span class="fm-combinumeral">❶</span>
  node ← search(treap.root, key)                            <span class="fm-combinumeral">❷</span>
  <b class="calibre21">if</b> node == <b class="calibre21">null then</b>                                       <span class="fm-combinumeral">❸</span>
    <b class="calibre21">return false</b>
  <b class="calibre21">if</b> isRoot(node) and isLeaf(node) <b class="calibre21">then</b>                      <span class="fm-combinumeral">❹</span>
    treap.root ← <b class="calibre21">null</b>
    <b class="calibre21">return true</b>
  <b class="calibre21">while</b> not isLeaf(node) <b class="calibre21">do</b>                                  <span class="fm-combinumeral">❺</span>
    <b class="calibre21">if</b> node.left != null 
        <b class="calibre21">and</b> (node.right==null 
          <b class="calibre21">or</b> node.left.priority &gt; node.right.priority) <b class="calibre21">then</b>  <span class="fm-combinumeral">❻</span>
      rotateRight(node.left)                                 <span class="fm-combinumeral">❼</span>
    <b class="calibre21">else</b>
      rotateLeft(node.right)                                 <span class="fm-combinumeral">❽</span>
    <b class="calibre21">if</b> isRoot(node.parent) <b class="calibre21">then</b>                              <span class="fm-combinumeral">❾</span>
      treap.root ← node.parent      
  <b class="calibre21">if</b> node.parent.left == node <b class="calibre21">then</b>                           <span class="fm-combinumeral">❿</span>
   node.parent.left ← <b class="calibre21">null</b>
  <b class="calibre21">else</b>
   node.parent.right ← <b class="calibre21">null</b>
  <b class="calibre21">return true</b>                                                <span class="fm-combinumeral">⓫</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1025715"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">remove</code><a id="marker-1025755"></a> takes a treap instance and the key to be removed. The method returns <code class="fm-code-in-text2">true</code> if the key was removed, or <code class="fm-code-in-text2">false</code> if it couldn’t be found. It also has side effects on the treap passed as argument.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025769"></a><span class="fm-combinumeral">❷</span> Searches for the key in the treap</p>

  <p class="fm-code-annotation"><a id="pgfId-1025791"></a><span class="fm-combinumeral">❸</span> If search<a id="marker-1025795"></a> returned <code class="fm-code-in-text2">null</code>, then there is no such key stored, and hence it can’t be deleted.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025813"></a><span class="fm-combinumeral">❹</span> If the treap only contained one node, then removing it will just leave an empty tree. We can check that by either testing if the treap’s size is <code class="fm-code-in-text2">1</code>, or equivalently if <code class="fm-code-in-text2">node</code> is both a leaf and the root.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025830"></a><span class="fm-combinumeral">❺</span> Otherwise, we need to push down this node all the way to the leaves level.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025847"></a><span class="fm-combinumeral">❻</span> Checks which of <code class="fm-code-in-text2">node</code>’s<a id="marker-1025851"></a> two children should replace it. It will have at least one child (because it’s not a leaf), and if it has both children, we will need to choose the one with the highest priority (that is, lowest value, in our example, because we are implementing a min-treap).</p>

  <p class="fm-code-annotation"><a id="pgfId-1025865"></a><span class="fm-combinumeral">❼</span> If we chose the left child, we need a right rotation.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025882"></a><span class="fm-combinumeral">❽</span> Otherwise, we need a left rotation.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025899"></a><span class="fm-combinumeral">❾</span> We have to be careful in case <code class="fm-code-in-text2">node</code> was the root. If that’s the case, we need to update treap’s property. This check can be true only on the first iteration of the cycle, so it might make sense, if performance is crucial, to break the cycle down and handle the first iteration separately.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025916"></a><span class="fm-combinumeral">❿</span> After exiting the <code class="fm-code-in-text2">while</code> loop, <code class="fm-code-in-text2">node</code> is now a leaf, and certainly not the root anymore. We can just disconnect it by nulling the pointer from its parent.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025933"></a><span class="fm-combinumeral">⓫</span> Returns <code class="fm-code-in-text2">true</code><a id="marker-1025937"></a>, because the key was removed</p>

  <p class="body"><a id="pgfId-1003256"></a>In listing 3.6, in particular, we see why it was useful to have method <code class="fm-code-in-text">search</code> return the node where the key was found. We can reuse it now to write the <code class="fm-code-in-text">remove</code> method, whose first step is indeed searching the key to remove and then, if it was found, this method will take over from the node that needs to be pushed down.</p>

  <p class="body"><a id="pgfId-1003308"></a>Special care, as always, needs to be paid to be sure we remove the root.</p>

  <p class="body"><a id="pgfId-1003321"></a>Let’s follow how the algorithm works using our example. Suppose we want to remove “Butter” from our inventory (for instance, because we won’t sell it anymore or we sold all of it).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F10.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031257"></a>Figure 3.10 Deleting the key <code class="fm-code-in-text">Butter</code> from our example treap. The first step is finding the node holding the key to remove. Then, we set its priority to the lowest possible priority and push it down to a leaf. To do so, we need to find out which one of its children has the highest priority and rotate it. Finally, once the node reaches a leaf, we can just unplug it from the tree without violating any invariant.</p>

  <p class="body"><a id="pgfId-1003342"></a>The first step, shown in figure 3.10 (A), is searching for the key <code class="fm-code-in-text">“Butter”</code> in the tree (line #2 in listing 3.6). Once we find the node (that’s obviously not <code class="fm-code-in-text">null</code>, line #3), as usual marked with <code class="fm-code-in-text">X</code> in the figures, we verify that it’s neither the root nor a leaf (hence, the check at line #5 returns <code class="fm-code-in-text">false</code>), so we can enter the <code class="fm-code-in-text">while</code> loop at line #8.</p>

  <p class="body"><a id="pgfId-1003367"></a>At line #9, we choose <code class="fm-code-in-text">X</code>’s left child, denoted with <code class="fm-code-in-text">L</code> in the figure, as its highest-priority child, so we perform a right rotation (line #10), which produces the tree shown in fig-ure 3.10 (B).</p>

  <p class="body"><a id="pgfId-1003380"></a>Here in the figure we changed the priority of the node being pushed down to +∞,<a href="#pgfId-1008324"><sup class="footnotenumber">7</sup></a> but in the code we don’t actually need to do that; we can just push down the node without checking priorities, until it becomes a leaf.</p>

  <p class="body"><a id="pgfId-1003396"></a>At this point <code class="fm-code-in-text">X</code> is not yet a leaf, although it just has one child, its (also former) right child <code class="fm-code-in-text">R</code>; therefore, we will enter another iteration of the <code class="fm-code-in-text">while</code> loop, and this time perform a left rotation, producing the tree shown in figure 3.10 (C). One more left rotation, and <code class="fm-code-in-text">X</code> finally becomes a leaf.</p>

  <p class="body"><a id="pgfId-1003415"></a>At this point we exit the <code class="fm-code-in-text">while</code> loop, and at line #15 we are sure that <code class="fm-code-in-text">node</code><a id="marker-1004315"></a> is not the root (otherwise, we would have caught this case at line #5), so it will have a non-null parent. We still need to disconnect the node from the tree by removing the pointer from its parent, and to do so we need to check whether it was a left or right child.</p>

  <p class="body"><a id="pgfId-1003433"></a>Once the right link has been set to <code class="fm-code-in-text">null</code>, we are done and the key was successfully removed.</p>

  <p class="body"><a id="pgfId-1003444"></a>If we compare this method with the plain BST’s version, the positive aspect is that we don’t have to call <code class="fm-code-in-text">remove</code><a id="marker-1004319"></a> recursively on the successor (or predecessor) of the node that will be removed. We just perform one removal, although possibly with several rotations. And that’s actually one negative aspect: if we delete a node close to the root, we will need to push it down for several layers until it reaches a leaf.</p>

  <p class="body"><a id="pgfId-1003473"></a>The worst-case running time for the <code class="fm-code-in-text">remove</code><a id="marker-1004323"></a> algorithm is, in other words, <code class="fm-code-in-text">O(h)</code>, where <code class="fm-code-in-text">h</code> is the height of the treap. As a consequence, it becomes particularly important, as you can imagine, that the height of the tree is kept as small as possible.</p>

  <p class="body"><a id="pgfId-1003499"></a>As you can see from our examples, using the treap for storing both keys and meaningful priorities might tend to produce an unbalanced tree, and removing a node might make the tree even more unbalanced, because of the many rotations starting from an already bad <a id="marker-1004327"></a>situation.</p>

  <h3 class="fm-head2" id="heading_id_12"><a id="pgfId-1003510"></a>3.3.6 Top, peek, and update</h3>

  <p class="body"><a id="pgfId-1003526"></a>The <a id="marker-1004331"></a><a id="marker-1004335"></a><a id="marker-1004339"></a><a id="marker-1004343"></a>remaining methods in class <code class="fm-code-in-text">Treap’s</code><a id="marker-1004347"></a> API are easier to implement. Method <code class="fm-code-in-text">peek</code><a id="marker-1004351"></a> is trivial to implement; it’s exactly the same as for regular heaps, the only difference being in how we access the heap’s root.</p>

  <p class="body"><a id="pgfId-1003546"></a>If we also need to implement method <code class="fm-code-in-text">top</code><a id="marker-1004355"></a>, to make sure our treap can seamlessly replace a heap, we can leverage the <code class="fm-code-in-text">remove</code> method and write almost a one-liner, as shown in listing 3.7.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015546"></a>Listing 3.7 Method <code class="fm-code-in-text">Treap::top</code></p>
  <pre class="programlisting"><b class="calibre21">function</b> top(treap)              <span class="fm-combinumeral">❶</span>
  <b class="calibre21">throw-if</b> treap.root == <b class="calibre21">null</b>    <span class="fm-combinumeral">❷</span>
  key ← treap.root.key           <span class="fm-combinumeral">❸</span>
  remove(treap, key)             <span class="fm-combinumeral">❹</span>
  <b class="calibre21">return</b> key                     <span class="fm-combinumeral">❺</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1025421"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">top</code> takes a treap instance and returns its top-priority element, unless the treap is empty.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025442"></a><span class="fm-combinumeral">❷</span> If the treap was empty, we need to throw an error.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025459"></a><span class="fm-combinumeral">❸</span> Stores the key at the <code class="fm-code-in-text2">root</code> of the treap</p>

  <p class="fm-code-annotation"><a id="pgfId-1025476"></a><span class="fm-combinumeral">❹</span> Removes the top key from the treap</p>

  <p class="fm-code-annotation"><a id="pgfId-1025493"></a><span class="fm-combinumeral">❺</span> Returns the key</p>

  <p class="body"><a id="pgfId-1003695"></a>Besides validating the treap’s status, checking that it’s not empty, we just need to retrieve the key stored in the root and then remove it from the treap.</p>

  <p class="body"><a id="pgfId-1003704"></a>Similarly, if we need to update the priority associated with a key, we can follow the same logic as for plain heaps, bubbling up the updated node (when increasing priority, or pushing down, when we lower priority). The only difference is that instead of just swapping nodes we need to perform rotations to move the updated node. Implementation of this method is left as an exercise (or you can check it out on the <a id="marker-1004359"></a><a id="marker-1004363"></a><a id="marker-1004367"></a><a id="marker-1004371"></a><a id="marker-1004375"></a>book’s <span class="fm-hyperlink">repo</span>).</p>

  <h3 class="fm-head2" id="heading_id_13"><a id="pgfId-1003725"></a>3.3.7 Min, max</h3>

  <p class="body"><a id="pgfId-1003737"></a>The <a id="marker-1004379"></a><a id="marker-1004383"></a>last methods left to implement in our API are <code class="fm-code-in-text">min</code><a id="marker-1004387"></a> and <code class="fm-code-in-text">max</code><a id="marker-1004391"></a>, returning the minimum and maximum key stored in the treap.</p>

  <p class="body"><a id="pgfId-1003755"></a>These keys are stored respectively in the left-most and right-most nodes of the tree. Be careful, though; these nodes are not necessarily going to be leaves, as shown in figure 3.11.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F11.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031302"></a>Figure 3.11 How to find minimum and maximum keys in a treap (or, in general, in a binary search tree): the minimum is stored in the left-most node, and the maximum in the right-most node. Notice how these nodes aren’t necessarily tree leaves.</p>

  <p class="body"><a id="pgfId-1003786"></a>Listing 3.8 shows a possible implementation of method <code class="fm-code-in-text">min</code><a id="marker-1004395"></a>. Exactly as in BSTs, we just traverse the tree, always taking the left branch until we reach a node whose left child is <code class="fm-code-in-text">null</code>. Method <code class="fm-code-in-text">max</code><a id="marker-1004399"></a> is symmetric; you just need to replace <code class="fm-code-in-text">node.left</code><a id="marker-1004403"></a> with <a id="marker-1004407"></a><a id="marker-1004411"></a><code class="fm-code-in-text">node.right</code><a id="marker-1004415"></a>.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015574"></a>Listing 3.8 Method <code class="fm-code-in-text">Treap::min</code></p>
  <pre class="programlisting"><b class="calibre21">function</b> min(treap)               <span class="fm-combinumeral">❶</span>
  <b class="calibre21">throw-if</b> treap.root == <b class="calibre21">null</b>     <span class="fm-combinumeral">❷</span>
  node ← treap.root               <span class="fm-combinumeral">❸</span>
  <b class="calibre21">while</b> node.left != <b class="calibre21">null do</b>      <span class="fm-combinumeral">❹</span>
    node ← node.left 
  <b class="calibre21">return</b> node.key                 <span class="fm-combinumeral">❺</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1025127"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">min</code><a id="marker-1025131"></a> takes a treap instance and returns its top-priority element, unless the treap is empty.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025149"></a><span class="fm-combinumeral">❷</span> If the treap was empty, we need to throw an error (it would have no min, obviously).</p>

  <p class="fm-code-annotation"><a id="pgfId-1025166"></a><span class="fm-combinumeral">❸</span> Initializes the temporary variable <code class="fm-code-in-text2">node</code> with the tree’s root (not <code class="fm-code-in-text2">null</code>, because of the check at line 2)</p>

  <p class="fm-code-annotation"><a id="pgfId-1025183"></a><span class="fm-combinumeral">❹</span> Until we reach the left-most node, keep traversing the left branch.</p>

  <p class="fm-code-annotation"><a id="pgfId-1025200"></a><span class="fm-combinumeral">❺</span> Returns the node’s key</p>

  <h3 class="fm-head2" id="heading_id_14"><a id="pgfId-1003966"></a>3.3.8 Performance recap</h3>

  <p class="body"><a id="pgfId-1003980"></a>This concludes our discussion on the implementation of treaps. In the next sections, we’ll discuss applications of treaps and analyze them in more detail.</p>

  <p class="body"><a id="pgfId-1003993"></a>For now, let’s recap the running time of the treap’s methods, shown in table 3.2. Notice that</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1004008"></a>All operations only depend on the height of the tree, rather than on the number of elements. Of course, in the worst case, <code class="fm-code-in-text">O(h)=O(n)</code> for skewed trees.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1004025"></a>We omitted the space analysis, because all these methods only require constant extra space.</p>
    </li>
  </ul>

  <p class="fm-table-caption"><a id="pgfId-1015664"></a>Table 3.2 Operations provided by treaps, and their cost for a tree with <code class="fm-code-in-text">n</code> keys and height <code class="fm-code-in-text">h</code></p>

  <table border="1" class="contenttable" width="100%">
    <tr class="calibre8">
      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1015670"></a>Operation</p>
      </th>

      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1015672"></a>Running time</p>
      </th>

      <th class="fm-contenttable" colspan="1" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1015674"></a>Worst case</p>
      </th>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015676"></a><code class="fm-code-in-text2">Insert</code><a id="marker-1015717"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015678"></a><code class="fm-code-in-text2">O(h)</code></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015680"></a><code class="fm-code-in-text2">O(n)</code></p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015682"></a><code class="fm-code-in-text2">Top</code><a id="marker-1015718"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015684"></a><code class="fm-code-in-text2">O(h)</code></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015686"></a><code class="fm-code-in-text2">O(n)</code></p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015688"></a><code class="fm-code-in-text2">Remove</code><a id="marker-1015719"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015690"></a><code class="fm-code-in-text2">O(h)</code></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015692"></a><code class="fm-code-in-text2">O(n)</code></p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015694"></a><code class="fm-code-in-text2">Peek</code><a id="marker-1015720"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015696"></a><code class="fm-code-in-text2">O(1)</code></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015698"></a><code class="fm-code-in-text2">O(1)</code></p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015700"></a><code class="fm-code-in-text2">Contains</code><a id="marker-1015721"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015702"></a><code class="fm-code-in-text2">O(h)</code></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015704"></a><code class="fm-code-in-text2">O(n)</code></p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015706"></a><code class="fm-code-in-text2">UpdatePriority</code><a id="marker-1015722"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015708"></a><code class="fm-code-in-text2">O(h)</code></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015710"></a><code class="fm-code-in-text2">O(n)</code></p>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015712"></a><code class="fm-code-in-text2">Min/Max</code><a id="marker-1015723"></a></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015714"></a><code class="fm-code-in-text2">O(h)</code></p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1015716"></a><code class="fm-code-in-text2">O(n)</code></p>
      </td>
    </tr>
  </table>

  <h2 class="fm-head" id="heading_id_15"><a id="pgfId-1004426"></a>3.4 Applications: Randomized treaps</h2>

  <p class="body"><a id="pgfId-1004733"></a>So, <a id="marker-1005179"></a><a id="marker-1005183"></a>we are now able to implement our inventory, keep track of the products in stock, and extract the ones closest to running out of stock. That would certainly impress everyone at the next family reunion!</p>

  <p class="body"><a id="pgfId-1004749"></a>Hopefully, our example helped you understand how treaps work, but . . . I have a confession to make: treaps are not really used as a way to index multidimensional data.</p>

  <p class="body"><a id="pgfId-1004763"></a>We’ll see in the next chapters, and in particular in chapter 7, when we talk about cache, that there are better ways to address problems equivalent to the example we presented in this chapter.</p>

  <p class="body"><a id="pgfId-1004772"></a>Let me be clear: using treaps as both trees and heaps is possible, perfectly legal, and can even offer decent performance, under certain conditions, although in the general case we have seen that keeping data organized by both criteria will likely produce an unbalanced tree (which means linear-time operations).</p>

  <p class="body"><a id="pgfId-1004781"></a>But that’s not why treaps were invented, nor is it the main way they are used today. In the end, the point is that there are better ways to index multidimensional data and better ways to use treaps. Instead, we’ll see that we can use treaps as a building block to implement a different, and efficient, data structure.</p>

  <h3 class="fm-head2" id="heading_id_16"><a id="pgfId-1004811"></a>3.4.1 Balanced trees</h3>

  <p class="body"><a id="pgfId-1004825"></a>One <a id="marker-1005187"></a><a id="marker-1005191"></a>aspect that we stressed is that unbalanced treaps tend to have long paths, whose length can be, in the worst-case scenario, in the order of <code class="fm-code-in-text">O(n)</code> nodes.</p>

  <p class="body"><a id="pgfId-1004840"></a>Conversely, when discussing heaps, we saw that balanced trees, like heaps, have logarithmic height, making all operations particularly convenient to run.</p>

  <p class="body"><a id="pgfId-1004849"></a>With heaps, however, the catch is that we trade the benefit of balanced trees in exchange for restricting to a limited set of operations. We can’t efficiently search a heap for an element’s key, or retrieve the maximum or minimum key,<a href="#pgfId-1008342"><sup class="footnotenumber">8</sup></a> or delete or update a random element (without knowing beforehand its position in the heap) in sublinear running time.</p>

  <p class="body"><a id="pgfId-1004874"></a>Nevertheless, there are, in algorithm literature, many other examples of balanced trees, data structures that guarantee that the height of the tree will be logarithmic, even in the worst case. Some examples that we mentioned in section 3.2 are 2-3 trees<a href="#pgfId-1008356"><sup class="footnotenumber">9</sup></a> (shown in figure 3.12) and red-black trees<a href="#pgfId-1008372"><sup class="footnotenumber">10</sup></a> (figure 3.13).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F12.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031355"></a>Figure 3.12 A 2-3 tree containing the keys we used in our grocery store example. Nodes in 2-3 trees can contain one or two keys, sorted ascendingly, and respectively 2 or 3 links. Besides left and right children, 3-nodes also have a middle child. All keys <code class="fm-code-in-text">K</code> in the subtree pointed to by a middle link must obey this condition: <code class="fm-code-in-text">K<sub class="subscript1">1</sub> &gt; K &gt;= K<sub class="subscript1">2</sub></code>, where <code class="fm-code-in-text">K<sub class="subscript1">1</sub></code> and <code class="fm-code-in-text">K<sub class="subscript1">2</sub></code> are the first and second key, respectively, of the 3-node. 2-3 trees are guaranteed to be balanced by the way insertion is performed: keys are added to the leaves, and when a leaf grows to three elements, it’s split and the middle element is bubbled up to the parent node (which is also possibly recursively split). It is guaranteed that the height of a 2-3 tree with <code class="fm-code-in-text">n</code> keys is between <code class="fm-code-in-text">log<sub class="subscript1">2</sub>(n)</code> and <code class="fm-code-in-text">log<sub class="subscript1">3</sub>(n)</code>.</p>

  <p class="body"><a id="pgfId-1004887"></a>The algorithms to maintain the constraints for these trees, however, tend to be quite complicated, so much so that many textbooks on algorithms, for instance, omit the <code class="fm-code-in-text">delete</code> method<a id="marker-1005195"></a> altogether.</p>

  <p class="body"><a id="pgfId-1004964"></a>Turns out, quite surprisingly, that we can use treaps, which seems quite unbalanced, to obtain tendentially balanced<a href="#pgfId-1008391"><sup class="footnotenumber">11</sup></a> binary search trees using a set of easier and cleaner algorithms (in comparison to red-black trees and the like).</p>

  <p class="body"><a id="pgfId-1004979"></a>As we saw in the introduction to this chapter, plain BSTs also suffer this same problem, having their structure depend on the order in which elements are inserted.</p>

  <p class="body"><a id="pgfId-1004992"></a>And if we go back to the last section, we saw treaps can be skewed if the particular combination of keys and priorities, and the order in which elements are inserted, is particularly unlucky, because rotations can cause the tree to get even more unbalanced (see figure 3.9).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F13.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031397"></a>Figure 3.13 Red-black containing the same keys of our example. Red-black trees are one of the simplest implementations of 2-3 trees. A red-black BST is like a regular BST, except that the links between nodes can be of two different kinds: red links (dashed lines), and black links (solid lines). Red links connect keys that, in the corresponding 2-3 tree, would belong to the same 3-node. Black links, instead, would be the actual links of a 2-3 tree. There are two constraints: (1) No node has two red links connected to it (either in- or out-going); this encodes the fact that in a 2-3 tree there are only 2-nodes and 3-nodes. (2) All paths from the root to a leaf have the same number of black links. Equivalently, nodes can be marked as red or black. Here, we used red (shaded) and white (unshaded) for clarity. There can’t be two consecutive red nodes in any path. Together, these constraints guarantee that the longest possible path in a red-black BST, alternating red and black links, can at most be twice as long as the shortest possible path in the tree, containing only black links. In turn, this guarantees that the height of the tree is logarithmic. These invariants are maintained by appropriately using rotations, after insertions and deletions.</p>

  <p class="body"><a id="pgfId-1005001"></a>So here is the idea: we can use rotations to rebalance the tree. If we strip priorities from their meaning (in our example, forget about the units in stock for each product), we can, in theory, update the priority value of each node so that fixing the heap’s invariants will produce a more balanced tree.</p>

  <p class="body"><a id="pgfId-1005068"></a>Figure 3.14 illustrates the process. The right branch of the tree is not balanced, and by updating the second-to-last-level node, we can force a right rotation that will bring it up one level, rebalancing its subtree, and in this simple example, the whole tree.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F14.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031501"></a>Figure 3.14 Rebalancing a treap by carefully updating its priorities. If we change the priority of the node with key “Milk” to a value smaller than its parent (but larger than the root, in this case), we can fix the heap invariants with a right rotation. Incidentally, by doing so we will get a perfectly balanced tree.</p>

  <p class="body"><a id="pgfId-1005110"></a><a id="Current"></a>We need to be clear now: By discarding the meaning of the priority field, we are implementing something different than what we had in section 3.3. In particular, this new data structure will no longer adhere to the priority queue public interface, and it will not offer any <code class="fm-code-in-text">top</code><a id="marker-1031485"></a> or <code class="fm-code-in-text">peek</code> method<a id="marker-1031486"></a>. Instead, it will just be a binary search tree that <i class="calibre17">internally</i> uses the concepts we developed for treaps to maintain its structure balanced. Table 3.3 shows the methods and contract for BSTs. The data structure we are about to introduce will adhere to this <a id="marker-1031487"></a><a id="marker-1031488"></a>API.</p>

  <p class="fm-table-caption"><a id="pgfId-1031550"></a>Table 3.3 API and Contract for BinarySearchTree (BST)</p>

  <table border="1" class="contenttable" width="100%">
    <tr class="calibre8">
      <th class="fm-contenttable" colspan="2" rowspan="1">
        <p class="fm-table-head"><a id="pgfId-1031554"></a>Abstract data structure: Binary search tree</p>
      </th>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1031558"></a>API</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <pre class="programlisting">class BST {
  insert(element)
  remove(element)
  contains(element)
  min()
  max()
}</pre>
      </td>
    </tr>

    <tr class="calibre8">
      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1031568"></a>Contract with client</p>
      </td>

      <td class="fm-contenttable1" colspan="1" rowspan="1">
        <p class="fm-table-body"><a id="pgfId-1031570"></a>Entries are kept sorted by element (aka key).</p>
      </td>
    </tr>
  </table>

  <h3 class="fm-head2" id="heading_id_17"><a id="pgfId-1005214"></a>3.4.2 Introducing randomization</h3>

  <p class="body"><a id="pgfId-1005376"></a>If <a id="marker-1008025"></a><a id="marker-1008029"></a>getting better results using simpler algorithms sounds too good to be true to you . . . well, you might be partially right, meaning that there is a price to pay for simplicity.</p>

  <p class="body"><a id="pgfId-1005391"></a>Updating priorities to keep the tree balanced seemed easy on our small example, but doing it systematically on a large tree becomes difficult and expensive.</p>

  <p class="body"><a id="pgfId-1005400"></a>Difficult because it becomes like solving a puzzle: every time we rotate an internal node, we potentially cause lower levels in the subtrees pushed down to become more unbalanced, so it’s not trivial to come up with the right order of rotations to obtain the best possible tree structure.</p>

  <p class="body"><a id="pgfId-1005412"></a>Expensive, because we need to keep track of the height of each subtree, and because coming up with a sequence of rotations requires extra work.</p>

  <p class="body"><a id="pgfId-1005421"></a>In the previous section, we used the term <i class="calibre17">tendentially balanced</i> to describe the result we can get. This has probably already revealed a key point to the eyes of the most observant readers: we are talking about introducing a randomized element in our data structures.</p>

  <p class="body"><a id="pgfId-1005440"></a>Randomness will be a constant factor in this first part of the book. We’ll see several data structures leveraging it, including Bloom filters. To help all readers be comfortable with the topic, we prepared a short introduction to randomized algorithms in appendix F; feel free to take a look before delving into this section.</p>

  <p class="body"><a id="pgfId-1005458"></a>In the original work by Aragon and Raimund, treaps were introduced as a means to obtain “randomized balanced search trees.” They used the same idea we described in section 3.4.1, leveraging priorities to force a balanced tree structure, but they avoided all the complexity of manually setting these values by using a uniform random numbers generator to choose the values for the nodes’ priorities.</p>

  <p class="body"><a id="pgfId-1005482"></a>Figure 3.15 shows a more balanced version of the tree produced at the end of figure 3.9, by replacing those priorities with randomly generated real numbers. It’s also possible to use random integers for priorities, but using real numbers reduces the possibility of ties and improves the final result.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F15.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031603"></a>Figure 3.15 An example of a Randomized Treap<a id="marker-1031602"></a> (RT) for the keys in the treap shown in figure 3.9 (after inserting the key <code class="fm-code-in-text">“Beer”</code>). Priorities are random numbers between 0 and 1. This is just one possible structure for the keys, corresponding to one random choice of the priorities.</p>

  <p class="body"><a id="pgfId-1005519"></a>We will see in section 3.5 that, if the priorities are drawn from a uniform distribution, the expected height of the tree is logarithmic in the number of nodes.</p>

  <p class="body"><a id="pgfId-1005528"></a>The best part is that we have already written almost all the code needed to implement this new data structure. We can internally use a treap (listing 3.9) and all its API methods will just be wrappers for treap’s methods, except for <code class="fm-code-in-text">insert</code><a id="marker-1008037"></a>; that’s the only one for which we need to write an extra line of code.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015852"></a>Listing 3.9 Class <code class="fm-code-in-text">RandomizedTreap</code></p>
  <pre class="programlisting">class RandomizedTreap
  <b class="calibre21">#type</b> Treap
  treap
  
  <b class="calibre21">#type</b> RandomNumberGenerator
  randomGenerator
 
  <b class="calibre21">function</b> RandomizedTreap()
    <b class="calibre21">this</b>.treap ← <b class="calibre21">new</b> Treap</pre>

  <p class="body"><a id="pgfId-1005652"></a>As it’s shown in listing 3.10, all we need to do is generate a random priority when we insert a new key in our Randomized Treap.</p>

  <p class="body"><a id="pgfId-1005663"></a>You can find a Java implementation for RTs on the book’s <span class="fm-hyperlink">repo</span> on <a id="marker-1029834"></a><a id="marker-1029835"></a>GitHub.<a href="#pgfId-1008406"><sup class="footnotenumber">12</sup></a></p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015880"></a>Listing 3.10 Method <code class="fm-code-in-text">RandomizedTreap::insert</code></p>
  <pre class="programlisting"><b class="calibre21">function</b> insert(key)                                            <span class="fm-combinumeral">❶</span>
  <b class="calibre21">return this</b>.treap.insert(key, <b class="calibre21">this</b>.randomGenerator.next())    <span class="fm-combinumeral">❷</span></pre>

  <p class="fm-code-annotation"><a id="pgfId-1024949"></a><span class="fm-combinumeral">❶</span> Method <code class="fm-code-in-text2">insert</code><a id="marker-1024953"></a> takes the key to insert into the tree. It doesn’t return anything but has side effects on the tree.</p>

  <p class="fm-code-annotation"><a id="pgfId-1024967"></a><span class="fm-combinumeral">❷</span> We insert a new entry in the treap: the key will be the method’s argument, while the priority will be a random real number.</p>

  <h3 class="fm-head2" id="heading_id_18"><a id="pgfId-1005753"></a>3.4.3 Applications of Randomized Treaps</h3>

  <p class="body"><a id="pgfId-1005765"></a>As <a id="marker-1008053"></a><a id="marker-1008057"></a>we saw in the last section, Randomized Treaps are the main application for treaps. Now the question is, what are the most common applications for Randomized Treaps?</p>

  <p class="body"><a id="pgfId-1005787"></a>In general, we can use a Randomized Treap everywhere we would use a BST. In particular, they are indicated for situations where we need a balanced tree, but we are fine with having guarantees on the average case only, not on the worst case.</p>

  <p class="body"><a id="pgfId-1005806"></a>Another aspect to consider is that, as always when randomization and “average case” bounds are involved, the guarantees are more likely to hold when the number of entries is larger, while for smaller trees, it’s easier to obtain skewed structures. (For small trees, however, the performance difference between slightly skewed and balanced trees will also be less relevant, obviously.)</p>

  <p class="body"><a id="pgfId-1005821"></a>BSTs, in turn, are often used to implement dictionaries and sets. We will see more about these structures in chapter 4.</p>

  <p class="body"><a id="pgfId-1005834"></a>Other examples include keeping data read from a stream sorted, counting the number of elements smaller (larger) than any given element of a dynamic set, and in general all applications where we need to keep a dynamic set of elements in sorted order, while supporting fast search, insertion, and removal.</p>

  <p class="body"><a id="pgfId-1005846"></a>Practical examples of real-world code using BSTs are, for instance, managing a set of <a id="id_Hlk55716720"></a>virtual memory areas (VMAs<a id="marker-1008061"></a>) in operating system kernels and keeping track of packet IP verification IDs. For the latter, a hash table would be faster, but it would also be vulnerable to worst-case input attacks, where an attacker could send packets from IPs hashing to the same value: this would degenerate the hash table into an unsorted list (if concatenation<a href="#pgfId-1008420"><sup class="footnotenumber">13</sup></a> is used), transforming the hash table in a bottleneck and possibly slowing down packet resolution or the <a id="marker-1008065"></a><a id="marker-1008069"></a>whole <a id="marker-1008073"></a><a id="marker-1008077"></a>kernel.</p>

  <h2 class="fm-head" id="heading_id_19"><a id="pgfId-1005875"></a>3.5 Performance analysis and profiling</h2>

  <p class="body"><a id="pgfId-1005891"></a>As <a id="marker-1008081"></a><a id="marker-1008085"></a>we saw in section 3.3, all API methods on Randomized Treaps require time proportional to the height of a tree. As we know (see the introduction to this chapter and appendix C), in the worst case the height of a binary tree can be linear in the number of elements and, in fact, one of the problems with BSTs is that there are specific sequences of insertions that will certainly cause a tree to be skewed. This issue makes binary search trees particularly vulnerable to attacks when used as dictionaries, because all an attacker needs to degrade the data structure’s performance is to send an ordered sequence, which will cause the tree to degenerate into a linked list, having a single path from the root to a leaf containing all the elements.</p>

  <p class="body"><a id="pgfId-1005919"></a>Randomized Treaps offer a two-fold improvement. First and foremost, introducing randomness in the assignment of priorities prevents<a href="#pgfId-1008436"><sup class="footnotenumber">14</sup></a> attackers from being able to exploit known sequences. But also, as we promised in section 3.4, it will give us on average a more balanced tree than plain binary search trees.</p>

  <p class="body"><a id="pgfId-1005943"></a>What does “on average” mean? And how much of an improvement can we get? There are two ways to answer these questions. From a theoretical point of view, we can analyze the expected height of a Randomized Treap, and mathematically prove that, on average, the height will be logarithmic.</p>

  <p class="body"><a id="pgfId-1005967"></a>But also, from a practical angle, we can just run a simulation to verify that what we expect is true and compare the height of a BST versus a Randomized Treap with the same elements.</p>

  <h3 class="fm-head2" id="heading_id_20"><a id="pgfId-1005978"></a>3.5.1 Theory: Expected height</h3>

  <p class="body"><a id="pgfId-1005992"></a>To <a id="marker-1008089"></a><a id="marker-1008093"></a>analyze the expected height of a random data structure, we need to introduce some concepts about statistics.</p>

  <p class="body"><a id="pgfId-1006006"></a>First and foremost, we will need to use the concept of expected value for a <i class="calibre17">random variable</i> <code class="fm-code-in-text">V</code>. We can informally define it as the mean value (not the most likely value) that variable will assume over a large set of occurrences.</p>

  <p class="body"><a id="pgfId-1006024"></a>More formally, if <code class="fm-code-in-text">V</code> can assume values in a finite, countable set <code class="fm-code-in-text">{v<sub class="subscript1">1</sub>, v<sub class="subscript1">2</sub>, . . . v<sub class="subscript1">M</sub>}</code>, each with probability <code class="fm-code-in-text">{p<sub class="subscript1">1</sub>, p<sub class="subscript1">2</sub>,</code> . . . <code class="fm-code-in-text">, p<sub class="subscript1">M</sub>}</code>, if we define the expected value of <code class="fm-code-in-text">V</code> as</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F_EQ1.png"/></p>

  <p class="body"><a id="pgfId-1006068"></a>For our Randomized Treap, we will define a random variable <code class="fm-code-in-text">D<sub class="subscript1">k</sub></code> for the depth of a given node <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code>, where the index <code class="fm-code-in-text">k <span class="cambria">ϵ</span> {0, . . . n-1}</code> denotes the index of the node’s key in the sorted set: <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code> has the <code class="fm-code-in-text">k</code>-th smallest key in the tree.</p>

  <p class="body"><a id="pgfId-1006094"></a>In simple terms, <code class="fm-code-in-text">D<sub class="subscript1">k</sub></code> counts how many ancestors there are for the node holding the <code class="fm-code-in-text">k</code>-th smallest key, <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code>. Yet another way to see this number is the following: How many nodes are in the path from the tree’s root to <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code>?</p>

  <p class="body"><a id="pgfId-1006117"></a>Formally:</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F_EQ2.png"/></p>

  <p class="body"><a id="pgfId-1006135"></a>We can denote the event “<code class="fm-code-in-text">A<sub class="subscript1">i</sub></code> is an ancestor of <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code>” with the indicator (a binary variable) <code class="fm-code-in-text">A<sub class="subscript1">k</sub><sup class="superscript1">i</sup></code>: this way, given any pairs of nodes <code class="fm-code-in-text">A<sub class="subscript1">i</sub></code> and <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code>, <code class="fm-code-in-text">A<sub class="subscript1">k</sub><sup class="superscript1">i</sup> == 1</code> means that <code class="fm-code-in-text">A<sub class="subscript1">i</sub></code> is in the path between <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code> and the root, while <code class="fm-code-in-text">A<sub class="subscript1">k</sub><sup class="superscript1">i</sup> == 0</code> means that either they are in different branches or, at most, <code class="fm-code-in-text">A<sub class="subscript1">i</sub></code> is a descendent of <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code>.</p>

  <p class="body"><a id="pgfId-1006183"></a>Then the expected value for <code class="fm-code-in-text">D<sub class="subscript1">k</sub></code> becomes</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F_EQ3.png"/></p>

  <p class="body"><a id="pgfId-1006226"></a>To compute the probability <code class="fm-code-in-text">P(Aki)</code>, we need to introduce a new variable, and a lemma (an intermediate result).</p>

  <p class="body"><a id="pgfId-1006240"></a>We define <code class="fm-code-in-text">N(i,k) = N(k,i) = {N<sub class="subscript1">i</sub>, N<sub class="subscript1">i+1</sub>, . . . N<sub class="subscript1">k-1</sub>, N<sub class="subscript1">k</sub>}</code> as the subset of treap nodes whose keys are between the <code class="fm-code-in-text">i</code>-th and <code class="fm-code-in-text">k</code>-th smallest<a href="#pgfId-1008451"><sup class="footnotenumber">15</sup></a> of the whole tree.</p>

  <p class="body"><a id="pgfId-1006271"></a>Obviously, <code class="fm-code-in-text">N(0,n-1) = N(n-1,0)</code> contains all the nodes in the treap. Figure 3.16 shows a few examples of these subsets to help you visualize them.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F16.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031645"></a>Figure 3.16 A few examples of the subsets of nodes <code class="fm-code-in-text">N(i,k)</code> defined in this section.</p>

  <p class="body"><a id="pgfId-1006312"></a>Notice that the successor and predecessor of any node <code class="fm-code-in-text">N</code> are always on a path between <code class="fm-code-in-text">N</code> and the root, or <code class="fm-code-in-text">N</code> and a leaf. In other words, to find the predecessor—or successor—of a node, you only need to look either in the subtree rooted at <code class="fm-code-in-text">N,</code> where this node will be the left-most, or right-most for successors, or in the path between <code class="fm-code-in-text">N</code> and the root.</p>

  <p class="body"><a id="pgfId-1006341"></a>It can be proved that the following lemma holds:</p>

  <p class="fm-quote"><a class="calibre14" id="pgfId-1006350"></a><i class="calibre15">For all</i> <code class="fm-code-in-text">i<span class="cambria">≠</span>k, 0</code><span class="cambria">≤</span><code class="fm-code-in-text">i,k</code><span class="cambria">≤</span><code class="fm-code-in-text">n-1, N<sub class="subscript1">i</sub></code> <i class="calibre15">is an ancestor of</i> <code class="fm-code-in-text">N<sub class="subscript1">k</sub></code> <i class="calibre15">if and only if</i> <code class="fm-code-in-text">N<sub class="subscript1">i</sub></code> <i class="calibre15">has the smallest priority among all nodes in</i> <code class="fm-code-in-text">N(i,k)</code>.</p>

  <p class="body"><a id="pgfId-1006372"></a>We will not prove this lemma here. If you’d like to take the challenge, it can be easily proven by induction.</p>

  <p class="body"><a id="pgfId-1006385"></a>So, armed with the lemma, we can compute the probability that the node with the <code class="fm-code-in-text">i</code>-th smallest key becomes an ancestor of the node with the <code class="fm-code-in-text">k</code>-th smallest key. Since we assume that the priorities are drawn from a uniform continuous set, as with all real numbers between 0 and 1, if each node in a subset of nodes is equally likely to hold the smallest priority.</p>

  <p class="body"><a id="pgfId-1006404"></a>Therefore, for each <code class="fm-code-in-text">i<span class="cambria">≠</span>k</code> we can write the probability of <code class="fm-code-in-text">i</code> being an ancestor of <code class="fm-code-in-text">k</code> as</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F_EQ4.png"/></p>

  <p class="body"><a id="pgfId-1006428"></a>while for <code class="fm-code-in-text">i=k</code>, instead, the probability is simply 0 (a node can’t be its own ancestor).</p>

  <p class="body"><a id="pgfId-1006439"></a>Replacing these values in the formula for the expected value of <code class="fm-code-in-text">D<sub class="subscript1">k</sub></code>, we get</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F_EQ5.png"/></p>

  <p class="body"><a id="pgfId-1006460"></a>The middle term of the sum obviously evaluates to <code class="fm-code-in-text">0</code>, while for the first term of the sum, we notice that when <code class="fm-code-in-text">i=0</code>, the denominator becomes equal to <code class="fm-code-in-text">k-1</code>, and it diminishes of <code class="fm-code-in-text">1</code> unit as <code class="fm-code-in-text">i</code> increases until, for <code class="fm-code-in-text">i=k-1</code>, it becomes equal to <code class="fm-code-in-text">2</code>.</p>

  <p class="body"><a id="pgfId-1006484"></a>Similar considerations can be made for the last term of the formula, giving us:</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F_EQ6.png"/></p>

  <p class="body"><a id="pgfId-1006502"></a>The two summations in the previous formula are, in fact, both partial sums of the harmonic series, denoted as <code class="fm-code-in-text">Hn; Hn&lt;ln(n)</code>, where <code class="fm-code-in-text">ln</code> is the natural logarithm. We finally obtain</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F_EQ7.png"/></p>

  <p class="body"><a id="pgfId-1006534"></a>This result guarantees that, over a large number of attempts, the mean value for the height of a Randomized Treap is <code class="fm-code-in-text">O(log(n))</code>, logarithmic in the number of keys stored (independently of the order keys are added or removed, and on the distribution of <a id="marker-1008097"></a><a id="marker-1008101"></a>keys).</p>

  <h3 class="fm-head2" id="heading_id_21"><a id="pgfId-1006551"></a>3.5.2 Profiling height</h3>

  <p class="body"><a id="pgfId-1006565"></a>You <a id="marker-1023486"></a><a id="marker-1023487"></a>could object that it’s just a guarantee on the average among several attempts. What if we get really unlucky on a crucial run? To get better insight into the actual performance of this data structure, we can run a little profiling, just like we did in section 2.10 for d-heaps. This time, we’ll use a profiling tool for Java, <span class="fm-hyperlink">JProfiler</span>.<a href="#pgfId-1008480"><sup class="footnotenumber">16</sup></a></p>

  <p class="body"><a id="pgfId-1006605"></a>We could even omit using a profiling tool, because our tests are going to compare an implementation of a plain BST versus a Randomized Treap, and after performing the same sequence of operations on two instances of those two containers, they’ll check how the heights of the two trees compare.</p>

  <p class="body"><a id="pgfId-1006618"></a>This measure will give us the gist of the asymptotic improvement of balanced trees over BSTs, because, as we discussed, operations on binary trees (balanced or not) require a number of steps proportional to the height of the tree.</p>

  <p class="body"><a id="pgfId-1006627"></a>We also know, however, that asymptotic analysis discards the constant coefficients, hiding the code complexity that usually comes with more advanced algorithms; therefore, having an indication of the actual running time will provide more thorough information that can help us choose the best implementation for our applications.</p>

  <p class="body"><a id="pgfId-1006638"></a>In the tests that you can find on the book’s GitHub <span class="fm-hyperlink">repo</span>,<span class="fm-hyperlink"><a href="#pgfId-1022722"><sup class="footnotenumber">17</sup></a></span> we try three different scenarios:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1006649"></a>We create large trees of increasing (random) size, whose keys are random integers, with an initial sequence of insertions, followed by random removals and insertions (with a rate of 1:1).</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1006661"></a>We proceed similarly to the previous step, but the possible key values are limited to a small subset (for instance, just 0 . . . 100, forcing several duplicates in the tree).</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1006679"></a>We insert an ordered sequence of numbers into the trees.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1006691"></a>The results of the first test we ran are shown in figure 3.17. You can see that the height of both trees is growing logarithmically. At first this seems rather discouraging, as there seems to be no improvement given by using Randomized Treaps over plain BSTs.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F17.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031687"></a>Figure 3.17 The height of a Randomized Treap versus a BST. On both data structures the same operations were performed, and the keys are random integers. Notice that the <code class="fm-code-in-text">y</code> axis uses a logarithmic scale.</p>

  <p class="body"><a id="pgfId-1006705"></a>We need, however, to make a couple of considerations.</p>

  <p class="body"><a id="pgfId-1006714"></a>First, let’s clarify the rules of the game: given a target size for the tree, <code class="fm-code-in-text">n</code>, if we add (to both containers) the same <code class="fm-code-in-text">n</code> integers, chosen at random, without any limit. After these insertions, we perform another <code class="fm-code-in-text">n</code> operations. Each of them can remove an existing key (randomly chosen) or add a new random integer to it. Obviously, we repeat this test for growing sizes.</p>

  <p class="body"><a id="pgfId-1006764"></a>We used an efficient implementation of BSTs (you can find it on the book’s <span class="fm-hyperlink">repo<a href="#pgfId-1022818"><sup class="footnotenumber">18</sup></a></span>) that limits the skewing effect of removing elements.<a href="#pgfId-1008494"><sup class="footnotenumber">19</sup></a> This expedient already improves the balance of BSTs and reduces the gap with balanced trees.</p>

  <p class="body"><a id="pgfId-1006784"></a>Finally, there is one consideration to make. In our experiment, we add completely random keys since the range of values is so large compared to the number of elements in the container. The expected number of duplicates is negligible, and we can assume that all sequences of keys to insert will be drawn with the same probability. In this scenario, it’s unlikely that an adversarial sequence, causing the height to be super-logarithmic, will be chosen (the chances are beyond slim already for <code class="fm-code-in-text">n ~= 100</code>).</p>

  <p class="body"><a id="pgfId-1006810"></a>Basically, we are using the same concept of Randomized Treaps, moving the randomness into the generator of the sequences of keys to insert; unfortunately, however, we don’t always get to choose the data to add to our containers!</p>

  <p class="body"><a id="pgfId-1006821"></a>And so, in order to verify this hypothesis, we can run a different experiment, reducing the influence of the random generator by limiting the set of possible keys. The results of limiting the keys to values in the range 0 . . . 1000 are shown in figure 3.18. Now we can immediately notice a difference between the two data structures: the BST grows linearly, with a slope of approximately 10-3, while the Randomized Treap still shows logarithmic height.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F18.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031739"></a>Figure 3.18 The height of a Randomized Treap versus a BST, when possible keys are randomly extracted from the set of integers between 0 and 1000. The charts show the same data, on the left with linear scale and on the right using logarithmic scale for heights.</p>

  <p class="body"><a id="pgfId-1006866"></a>There are two reasons for this difference:</p>

  <ul class="calibre19">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre14" id="pgfId-1006875"></a>Having a high duplicates rate (larger and larger as <code class="fm-code-in-text">n</code> is growing) produces sequences of insertions with longer streaks of sorted data.</p>
    </li>

    <li class="fm-list-numbered-last">
      <p class="list"><a class="calibre14" id="pgfId-1006892"></a>BSTs are naturally left-leaning when duplicates are allowed. As you can also see in listing 3.5, we need to break ties when inserting new keys, and we decided to go left every time we find a duplicate. Unfortunately, in this case we need a deterministic decision. We can’t use the same workaround as for deletions, and so when input sequences contain a large number of duplicates, as in this test, BSTs become tangibly skewed.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1006920"></a>This is already a nice result for treaps, because real-world inputs can easily contain several duplicates in many applications.</p>

  <p class="body"><a id="pgfId-1006931"></a>But what about those applications that don’t allow duplicates? Are we safe from adversarial sequences in those situations? Truth to be told, we haven’t clarified how important the role of ordering is. What better way to do it than trying the worst possible case—a totally ordered sequence? Figure 3.19 shows the results for this test. Here we stripped out all randomness and just added to the containers all integers from <code class="fm-code-in-text">0</code> to <code class="fm-code-in-text">n-1</code>, no calls to remove performed.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F19.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031784"></a>Figure 3.19 The height of a Randomized Treap versus a BST, after inserting the sequence <code class="fm-code-in-text">0, 1, . . . , n-1</code>. The charts show the same data, on the left with linear scale and on the right using logarithmic scale for heights.</p>

  <p class="body"><a id="pgfId-1006989"></a>As expected, for BSTs the height is always not just linear in the number of nodes, but equal to the number of nodes (this time the slope is exactly 1), because the tree degenerates to a linked list, as expected.</p>

  <p class="body"><a id="pgfId-1007000"></a>Randomized Treaps, instead, keep performing well with logarithmic height, just like for the other tests, even in the most unfavorable case.</p>

  <p class="body"><a id="pgfId-1007013"></a>We can then conclude that if the parameter to improve is the height of the tree, Randomized Treaps do have an advantage in comparison to BSTs, and it is true that they keep a logarithmic height in all situations; therefore, their performance is comparable to more complex data structures such as red-black <a id="marker-1008113"></a><a id="marker-1008117"></a>trees.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title"><a class="calibre14" id="pgfId-1031824"></a>Dangers of recursion</p>

    <p class="fm-sidebar-text"><a id="pgfId-1031825"></a>The degeneration of BSTs in this test caused the recursive implementation of the <code class="fm-code-in-text2">add</code> method<a id="marker-1031826"></a>, provided on our repo, to crash with a stack overflow<a href="#pgfId-1008518"><sup class="footnotenumber1">20</sup></a> for <code class="fm-code-in-text2">n~=15K</code> elements.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1031827"></a>This should remind you, once again, how important it is to be careful when writing recursive methods and, at the same time, how important it is to use the right data structure. In theory, while treaps could also cause stack overflows, since their height is logarithmic, we would need to add <code class="fm-code-in-text2">~2<sup class="superscript">15000</sup> = 10<sup class="superscript">5000</sup></code> elements to cause a stack overflow (which is way more than it’s possible to allocate on any computer’s RAM anyway, so it’s unlikely you’ll ever get a crash from a recursive treap).</p>
  </div>

  <h3 class="fm-head2" id="heading_id_22"><a id="pgfId-1007102"></a>3.5.3 Profiling running time</h3>

  <p class="body"><a id="pgfId-1007118"></a>The <a id="marker-1008125"></a><a id="marker-1008129"></a>height of the tree, however, is not the only criteria we are interested in. We want to know if there is a catch, and what’s the price we have to pay in terms of running time and memory usage (figure 3.20).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F20.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031860"></a>Figure 3.20 Profiling CPU usage when inserting/removing random unbounded integers in a BST and Randomized Treap</p>

  <p class="body"><a id="pgfId-1007161"></a>To find out this, we run a proper profiling of the first test (with unbounded integers as keys, so with low or no duplicates) using JProfiler and recording the CPU time. The profiling used the implementations of BSTs and Randomized Treaps provided in the book’s repo. It’s worth noting that this profiling only gives us information on the implementations we examine, but we could get different results on optimized or differently designed software.</p>

  <p class="body"><a id="pgfId-1007188"></a>The results for our profiling run are shown in figure 3.20, where we can see that for insertion (method <code class="fm-code-in-text">add</code><a id="marker-1008133"></a>) the cumulative running time spent for <code class="fm-code-in-text">Randomized-Treap</code><a id="marker-1008137"></a> is almost twice as much as for <code class="fm-code-in-text">BST::add</code>; for method <code class="fm-code-in-text">remove</code><a id="marker-1008141"></a><code class="fm-code-in-text">;</code> instead, the ratio becomes 3.5 times.</p>

  <p class="body"><a id="pgfId-1007210"></a>From this first test, it seems that we pay a high price, in the general case, for the overhead due to the greater complexity of Randomized Treaps. This result is somehow expected, because when the height of the trees is approximately the same, the code for treaps is substantially more complex than for BSTs.</p>

  <p class="body"><a id="pgfId-1007225"></a>Should we just throw away our <code class="fm-code-in-text">RandomizedTreap</code> class<a id="marker-1008145"></a>? Well, not so fast. Let’s see what happens when we profile the second test case introduced in section 3.5.2, the one where we still add random integers to the containers, but limited to the range [0, 1000].</p>

  <p class="body"><a id="pgfId-1007238"></a>In the previous section, we saw that, in this case, BST’s height grows linearly, while for Randomized Treaps we still have a logarithmic growth.</p>

  <p class="body"><a id="pgfId-1007251"></a>Figure 3.21 shows the result of this profiling. We can immediately see that the situation has radically changed, and BSTs perform tremendously worse now. So much worse that <code class="fm-code-in-text">BST::add</code> takes 8-fold the running time of <code class="fm-code-in-text">RandomizedTreap::add</code>. For the method <code class="fm-code-in-text">remove</code><a id="marker-1008149"></a> the ratio is even worse; we are talking about almost a 15-fold speed-up using Randomized Treaps—that’s exactly the situation where we would want to use our new, fancy, balanced data structure!</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F21.png"/></p>

  <p class="fm-figure-caption">Figure 3.21 Profiling CPU usage when inserting/removing random integers between 0 and 1000 in a BST and Randomized Treap</p>

  <p class="body"><a id="pgfId-1007304"></a>For the sake of completeness, let’s also take a look at the worst-case scenario for BSTs. Figure 3.22 shows the profiling of the last test case introduced in section 3.5.2, where we insert an ordered sequence in our containers. In this case, I believe that the results don’t even need to be commented, because we are talking about thousands of seconds versus microseconds (we had to test on a smaller set because BSTs performance was so degraded as to be unbearably slow).</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F22.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031905"></a>Figure 3.22 Profiling CPU usage when adding ordered sequences to a BST and Randomized Treap</p>

  <p class="body"><a id="pgfId-1007346"></a>All things considered, these results would suggest that if we are not sure about how uniform and duplicates-free the data we have to hold are, we should consider using Randomized Treaps. Instead, if we are sure the data will have lots of duplicates or possibly be close to sorted, then we definitely want to avoid using plain BSTs and resort to a balanced <a id="marker-1008153"></a><a id="marker-1008157"></a>tree.</p>

  <h3 class="fm-head2" id="heading_id_23"><a id="pgfId-1007374"></a>3.5.4 Profiling memory usage</h3>

  <p class="body"><a id="pgfId-1007390"></a>So <a id="marker-1008161"></a><a id="marker-1008165"></a>much for CPU usage, you might say, but what about memory usage? Because maybe Randomized Treaps are faster in some situations, but they require so much space that you won’t be able to store them in memory for large datasets.</p>

  <p class="body"><a id="pgfId-1007410"></a>First, we make a consideration: memory usage will be approximately the same for all the test cases we have introduced in the previous sections (when comparing containers of the same size, of course). This is because the number of nodes in both trees won’t change with their height; these trees do not support compression, and balanced and skewed trees will always need <code class="fm-code-in-text">n</code> nodes to store <code class="fm-code-in-text">n</code> keys.</p>

  <p class="body"><a id="pgfId-1007423"></a>Once we have established that, we can therefore be happy by profiling memory allocation for the most generic case, where the two trees are both approximately balanced. Figure 3.23 shows the cumulative memory allocated for the whole test for instances of the two classes.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F23.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031950"></a>Figure 3.23 Cumulative memory allocation for <code class="fm-code-in-text">BST</code> and <code class="fm-code-in-text">RandomizedTreap</code>, in the most generic case, with random insertions and removals</p>

  <p class="body"><a id="pgfId-1007456"></a>We can see that <code class="fm-code-in-text">RandomizedTreap</code><a id="marker-1008169"></a> requires slightly more than twice the memory of <code class="fm-code-in-text">BST</code><a id="marker-1008173"></a>. This is obviously not ideal, but is to be expected, considering that each node of a treap will hold a key (an <code class="fm-code-in-text">Integer</code>, in this test), plus a <code class="fm-code-in-text">Double</code> for the priority.</p>

  <p class="body"><a id="pgfId-1007479"></a>If we try a different kind of data for the keys—for instance, <code class="fm-code-in-text">String</code>—we can see that the difference becomes much smaller, as shown in figure 3.24. It’s just a ratio of 1.25 when storing strings between four and ten characters as keys.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F24.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1031994"></a>Figure 3.24 Cumulative memory allocation for <code class="fm-code-in-text">BST</code><a id="marker-1031992"></a> and <code class="fm-code-in-text">RandomizedTreap</code><a id="marker-1031993"></a> when storing strings between 4 and 10 characters.</p>

  <h3 class="fm-head2" id="heading_id_24"><a id="pgfId-1007518"></a>3.5.5 Conclusions</h3>

  <p class="body"><a id="pgfId-1007530"></a>The analysis of the comparative performance and height of BSTs and Randomized Treaps suggests that, while the latter requires slightly more memory and can be slower in the generic case, when we don’t have any guarantee on the uniform distribution of keys or on the order of the operations, using BSTs carries a far greater risk of becoming a bottleneck.</p>

  <p class="body"><a id="pgfId-1007543"></a>If you remember, when we introduced data structures in chapter 1 we made it clear: knowing the right data structure to use is more about avoiding the wrong choices than finding the perfect data structure. This is exactly the same case. We (as developers) need to be aware of the situations where we need to use a balanced tree to avoid attacks or just degraded performance.</p>

  <p class="body"><a id="pgfId-1007562"></a>It’s worth reiterating that the first part of the analysis, focusing on the height of the trees, has general value<a href="#pgfId-1008534"><sup class="footnotenumber">21</sup></a> and is independent of the programming language used. The analysis of running time and memory usage, instead, only has value for this implementation, programming language, design choices, and so on. All these aspects can, in theory, be optimized for your application’s specific requirements.</p>

  <p class="body"><a id="pgfId-1007584"></a>My advice, as always, is to carefully analyze requirements, understand what’s critical in your software and where you need certain guarantees about time and memory, and then test and profile the critical sections. Avoid wasting time on non-critical sections; usually you’ll find that the Pareto principle holds for software, and you can get an 80% performance gain by optimizing 20% of your code. Although the exact ratio may vary, the overall principle that you can get a significant improvement by optimizing the most critical parts of your application will likely hold.</p>

  <p class="body"><a id="pgfId-1007605"></a>Try to get a balance between clean code, time used to develop it, and efficiency. “Premature optimization is the root of all evil,” as stated by Donald Knuth,<a href="#pgfId-1008548"><sup class="footnotenumber">22</sup></a> because trying to optimize all of your code will likely distract your team from finding the critical issues, and produce less-clean, less-readable, and less-maintainable code.</p>

  <p class="body"><a id="pgfId-1007624"></a>Always make sure to try to write clean code first, and then optimize the bottlenecks and the critical sections, especially those on which you have a service-level agreement, with requirements about time/memory used.</p>

  <p class="body"><a id="pgfId-1007643"></a>To give you a concrete example, the Java implementation we provide on the book’s repo makes heavy use of the <code class="fm-code-in-text">Optional</code> class<a id="marker-1008185"></a> (to avoid using <code class="fm-code-in-text">null</code>, and provide a nicer interface and a better way to handle unsuccessful searches/operations), and consequently also a lot of lambda functions.</p>

  <p class="body"><a id="pgfId-1007658"></a>If we profile in more detail the memory usage, disabling the filter on the package (to speed-up profiling, you usually want to avoid recording standard libraries, etc.), the final result is quite surprising, as we can see in figure 3.25.</p>

  <p class="fm-figure"><img alt="" class="calibre23" src="../Images/ch03_F25.png"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1032036"></a>Figure 3.25 Memory allocation by class for our test, without any filtering on the package</p>

  <p class="body"><a id="pgfId-1007692"></a>You can see that most space is used by instances of <code class="fm-code-in-text">Optional</code><a id="marker-1008189"></a> and lambdas (implicitly created in <code class="fm-code-in-text">Optional::map</code><a id="marker-1008193"></a><code class="fm-code-in-text">,</code> etc.).</p>

  <p class="body"><a id="pgfId-1007711"></a>A complementary example for performance could be supporting multi-threading. If your application does not involve (ever) sharing these containers among different threads, you can avoid making your implementation thread-safe and save the overhead needed to create and <a id="marker-1008197"></a><a id="marker-1008201"></a>synchronize <a id="marker-1008205"></a><a id="marker-1008209"></a>locks.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title"><a class="calibre14" id="pgfId-1032076"></a>Clean or optimized code?</p>

    <p class="fm-sidebar-text"><a id="pgfId-1032077"></a>If performance and memory usage are critical for your application, you will probably want to write a different, optimized version of this code where these fancy language features are not used. You will also likely want to avoid using recursion and write explicit loops instead.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1032078"></a>But if low-level optimization is not critical, you might prefer sticking with cleaner and more maintainable code, using better interfaces and APIs, because in the long run having readable code will make your life (and the job of future team members) much easier.</p>
  </div>

  <h2 class="fm-head" id="heading_id_25"><a id="pgfId-1007786"></a>Summary</h2>

  <ul class="calibre19">
    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1007798"></a>Binary search trees offer good performance on all the typical container’s methods, but only if they’re kept balanced. Depending on the order of insertion of its keys, however, a BST can become skewed.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1007816"></a>The edge case is when an ordered sequence is added to a BST, that will then contain a single path of length <code class="fm-code-in-text">n</code>, de facto degenerating in a linked list.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1007832"></a>Treaps are a hybrid between BSTs and heaps, abiding by BST’s invariants for keys, and heap’s invariants for priorities.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1007845"></a>If we randomly assign priorities, drawing them from a uniform continuous set (such as, but not limited to, all real numbers between 0 and 1), we can mathematically guarantee that for large enough values of <code class="fm-code-in-text">n</code>, the tree will store <code class="fm-code-in-text">n</code> elements and maintain a height not greater than <code class="fm-code-in-text">2*log(n)</code>.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1007866"></a>Besides the theoretical guarantees, it’s possible to verify (as we did with Java implementations) that Randomized Treaps will keep a logarithmic height even in the worst-case scenarios for BSTs.</p>
    </li>

    <li class="fm-list-numbered1">
      <p class="list"><a class="calibre14" id="pgfId-1007882"></a>Moreover, the performance in term of CPU running time and memory usage is comparable for both data structures in the general case, and much better for Randomized Treaps in the edge cases where BSTs <a class="calibre14" id="marker-1008213"></a>struggle.</p>
    </li>
  </ul>
  <hr class="calibre22"/>

  <p class="fm-footnote"><sup class="footnotenumber">1.</sup> <a id="pgfId-1008220"></a>Treaps were introduced in the paper “Randomized search trees,” by Cecilia R. Aragon and Raimund C. Seidel, 30th Annual Symposium on Foundations of Computer Science. IEEE, 1989. Although the title of the paper might be misleading, we will see later in this chapter how treaps are related to randomized search trees.</p>

  <p class="fm-footnote"><sup class="footnotenumber">2.</sup> <a id="pgfId-1008242"></a>A portmanteau is a blend of two or more words, where parts of each word are combined into a new word.</p>

  <p class="fm-footnote"><sup class="footnotenumber">3.</sup> <a id="pgfId-1008262"></a>As we discussed in chapter 2, “higher priority” is an abstraction that can mean lower or higher values, depending on the type of heap we are using. Here we are dealing with a min-heap, and higher priority means “lower inventory count,” so smaller values go to the top. The code also assumes we are implementing a min-heap.</p>

  <p class="fm-footnote"><sup class="footnotenumber">4.</sup> <a id="pgfId-1008278"></a>Red-black and 2-3 trees are fancy versions of balanced BSTs. We’ll talk more about them in a few sections.</p>

  <p class="fm-footnote"><sup class="footnotenumber">5.</sup> <a id="pgfId-1008293"></a>See <span class="fm-hyperlink"><a href="https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction#treap">https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction#treap</a></span>.</p>

  <p class="fm-footnote"><sup class="footnotenumber">6.</sup> <a id="pgfId-1008309"></a>You can read more about the issue with stack overflow and tail call optimization in appendix E.</p>

  <p class="fm-footnote"><sup class="footnotenumber">7.</sup> <a id="pgfId-1008324"></a>In our example, the lowest priority corresponds to the highest availability in stock, and so +∞ is the highest possible value for the units in stock.</p>

  <p class="fm-footnote"><sup class="footnotenumber">8.</sup> <a id="pgfId-1008342"></a>Remember that in a heap, elements are partially ordered by priority, but not ordered at all by key. We can get the element with the highest priority, but to get the smallest (or largest) key, we need to check all elements.</p>

  <p class="fm-footnote"><sup class="footnotenumber">9.</sup> <a id="pgfId-1008356"></a>Aho, Alfred V., and John E. Hopcroft. <i class="calibre17">The design and analysis of computer algorithms</i>. Pearson Education India, 1974.</p>

  <p class="fm-footnote"><sup class="footnotenumber">10.</sup> <a id="pgfId-1008372"></a>Guibas, Leo J., and Robert Sedgewick. “A dichromatic framework for balanced trees.<span class="fm-hyperlink">”</span> 19th Annual Symposium on Foundations of Computer Science (sfcs 1978). IEEE, 1978.</p>

  <p class="fm-footnote"><sup class="footnotenumber">11.</sup> <a id="pgfId-1008391"></a>Meant as balanced, with a high probability.</p>

  <p class="fm-footnote"><sup class="footnotenumber">12.</sup> <a id="pgfId-1008406"></a>See <span class="fm-hyperlink"><a href="https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction#treap">https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction#treap</a></span>.</p>

  <p class="fm-footnote"><sup class="footnotenumber">13.</sup> <a id="pgfId-1008420"></a>See appendix C for a recap on hashing.</p>

  <p class="fm-footnote"><sup class="footnotenumber">14.</sup> <a id="pgfId-1008436"></a>It goes without saying that this holds if the pseudo-random generators are implemented properly and within the limits caused by the fact that a classic computer can’t offer true randomness. Either way, we make the attackers’ job a little harder.</p>

  <p class="fm-footnote"><sup class="footnotenumber">15.</sup> <a id="pgfId-1008451"></a>Assuming <code class="fm-code-in-text1">i &lt; k</code>; otherwise, if <code class="fm-code-in-text1">i &gt; k</code>, we refer the subset <code class="fm-code-in-text1">{Nk, Nk+1, ... Ni-1, Ni}</code>.</p>

  <p class="fm-footnote"><sup class="footnotenumber">16.</sup> <a id="pgfId-1008480"></a>JProfiler is a commercial tool. You can find open-source alternatives that will also get the job done.</p>

  <p class="fm-footnote"><sup class="footnotenumber">17.</sup> <a id="pgfId-1022722"></a><span class="fm-hyperlink"><a href="https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction/blob/master/Java/tests/org/mlarocca/containers/treap/RandomizedTreapProfiling.java">https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction/blob/master/Java/tests/org/mlarocca/containers/treap/RandomizedTreapProfiling.java</a></span>.</p>

  <p class="fm-footnote"><sup class="footnotenumber">18.</sup> <a id="pgfId-1022818"></a><span class="fm-hyperlink"><a href="https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction/blob/master/Java/src/org/mlarocca/containers/tree/BST.java">https://github.com/mlarocca/AlgorithmsAndDataStructuresInAction/blob/master/Java/src/org/mlarocca/ containers/tree/BST.java</a></span>.</p>

  <p class="fm-footnote"><sup class="footnotenumber">19.</sup> <a id="pgfId-1008494"></a>The standard implementation of the <code class="fm-code-in-text1">remove</code> method<a id="marker-1008513"></a> in BSTs, when the node <code class="fm-code-in-text1">N</code> to remove has both children, uses the node’s successor to replace the key to delete (and then recursively delete this successor). Over a long number of removals, this causes the tree to become skewed, left-leaning. A solution to mitigate this effect is randomly deciding, with a 50% probability, to use the predecessor of a key instead of its successor.</p>

  <p class="fm-footnote"><sup class="footnotenumber">20.</sup> <a id="pgfId-1008518"></a>Stack overflow, its relation with recursion, and how to avoid such crashes is explained in appendix E.</p>

  <p class="fm-footnote"><sup class="footnotenumber">21.</sup> <a id="pgfId-1008534"></a>Assuming the algorithms are implemented verbatim, it’s also not dependent on the specific implementation.</p>

  <p class="fm-footnote"><sup class="footnotenumber">22.</sup> <a id="pgfId-1008548"></a>“The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times. Premature optimization is the root of all evil (or at least most of it) in programming.” Knuth, Donald Ervin. <i class="calibre17">The art of computer programming</i>. Pearson Education, 1997.</p>
</body>
</html>
