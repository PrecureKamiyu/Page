<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>19.8 Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part197.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part199.htm">下一个 &gt;</a></p><p class="s40" style="padding-top: 5pt;padding-left: 38pt;text-indent: 0pt;text-align: left;">19.8 Summary</p><p style="padding-top: 7pt;padding-left: 68pt;text-indent: 12pt;line-height: 90%;text-align: left;">We have seen how hardware can help us make address translation faster. By providing a small, dedicated on-chip TLB as an address-translation cache, most memory references will hopefully be handled <i>without </i>having</p><p style="padding-left: 68pt;text-indent: 0pt;line-height: 89%;text-align: justify;">to access the page table in main memory. Thus, in the common case, the performance of the program will be almost as if memory isn’t being virtualized at all, an excellent achievement for an operating system, and certainly essential to the use of paging in modern systems.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">However, TLBs do not make the world rosy for every program that exists. In particular, if the number of pages a program accesses in a short period of time exceeds the number of pages that fit into the TLB, the pro- gram will generate a large number of TLB misses, and thus run quite a bit more slowly. We refer to this phenomenon as exceeding the <b>TLB cov- erage</b>, and it can be quite a problem for certain programs. One solution, as we’ll discuss in the next chapter, is to include support for larger page sizes; by mapping key data structures into regions of the program’s ad- dress space that are mapped by larger pages, the effective coverage of the TLB can be increased. Support for large pages is often exploited by pro- grams such as a <b>database management system </b>(a <b>DBMS</b>), which have certain data structures that are both large and randomly-accessed.</p><p style="padding-left: 68pt;text-indent: 12pt;line-height: 89%;text-align: justify;">One other TLB issue worth mentioning: TLB access can easily be- come a bottleneck in the CPU pipeline, in particular with what is called a <b>physically-indexed cache</b>. With such a cache, address translation has to take place <i>before </i>the cache is accessed, which can slow things down quite a bit. Because of this potential problem, people have looked into all sorts of clever ways to access caches with <i>virtual </i>addresses, thus avoiding the expensive step of translation in the case of a cache hit. Such a <b>virtually- indexed cache </b>solves some performance problems, but introduces new issues into hardware design as well. See Wiggins’s fine survey for more details [W03].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part197.htm">&lt; 上一个</a><span> | </span><a href="../ostep.html">内容</a><span> | </span><a href="part199.htm">下一个 &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
