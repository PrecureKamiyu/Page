<?xml version='1.0' encoding='utf-8'?>
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" epub:prefix="index: http://www.index.com/">
  <head>
    <meta name="dcterms.conformsTo" content="PXE Basic 1.0"/>
    <meta name="generator" content="PXE Tools version 1.39.52"/>
    <!--Created by pxe.pl for standard version PXE Basic 1.0,data-profile-product=standard by PXE Tools 1.39.52, partial=false-->
    <title>7.10 Dynamic Linking with Shared Libraries</title>
    <link rel="alternate stylesheet" type="text/css" title="night" href="../css/theme/night.css"/>
    <link rel="alternate stylesheet" type="text/css" title="sepia" href="../css/theme/sepia.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body epub:type="bodymatter" class="calibre pcalibre pcalibre1">
<section id="P70004970270000000000000000063A5" class="pcalibre halftitlepage pcalibre1"><header class="calibre1 pcalibre pcalibre1"><h1 class="pcalibre title pcalibre1" id="P7000497027000000000000000044B5C" data-uri="chapter07.xhtml#P7000497027000000000000000044B5C" epub:type="title"><span class="pcalibre label pcalibre1">7.10 </span>Dynamic Linking with Shared Libraries</h1></header>
<p id="P7000497027000000000000000044B5D" data-uri="chapter07.xhtml#P7000497027000000000000000044B5D" class="pcalibre1 pcalibre calibre2">The static libraries that we studied in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006160.xhtml#P70004970270000000000000000061DE"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">7.6.2</span></a> address many of the issues associated with making large collections of related functions available to application programs. However, static libraries still have some significant disadvantages. Static libraries, like all software, need to be maintained and updated periodically. If application programmers want to use the most recent version of a library, they must somehow become aware that the library has changed and then explicitly relink their programs against the updated library.</p>
<p id="P7000497027000000000000000044B5E" data-uri="chapter07.xhtml#P7000497027000000000000000044B5E" class="pcalibre1 pcalibre calibre2">Another issue is that almost every C program uses standard I/O functions such as <code id="P7000497027000000000000000044B5F" data-uri="chapter07.xhtml#P7000497027000000000000000044B5F" class="pcalibre1 calibre8 pcalibre">printf</code> and <code id="P7000497027000000000000000044B60" data-uri="chapter07.xhtml#P7000497027000000000000000044B60" class="pcalibre1 calibre8 pcalibre">scanf</code>. At run time, the code for these functions is duplicated in the text segment of each running process. On a typical system that is running hundreds of processes, this can be a significant waste of scarce memory system resources. (An interesting property of memory is that it is <i class="calibre5 pcalibre pcalibre1">always</i> a scarce resource, regardless</p>
<aside class="sidebar pcalibre5 pcalibre" id="P70004970270000000000000000063AB" data-uri="chapter07.xhtml#P70004970270000000000000000063AB"><header class="pcalibre halftitlepage pcalibre1"><h1 class="pcalibre1 title2 pcalibre" id="P7000497027000000000000000044B61" data-uri="chapter07.xhtml#P7000497027000000000000000044B61" epub:type="title"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000063AD" title="699" data-uri="chapter07.xhtml#P70004970270000000000000000063AD" epub:type="pagebreak"></span><span class="pcalibre label1 pcalibre1">Aside </span>How do loaders really work?</h1></header>
<p id="P7000497027000000000000000044B62" data-uri="chapter07.xhtml#P7000497027000000000000000044B62" class="calibre13 pcalibre pcalibre1">Our description of loading is conceptually correct but intentionally not entirely accurate. To understand how loading really works, you must understand the concepts of <i class="calibre5 pcalibre pcalibre1">processes</i>, <i class="calibre5 pcalibre pcalibre1">virtual memory</i>, and <i class="calibre5 pcalibre pcalibre1">memory mapping</i>, which we haven't discussed yet. As we encounter these concepts later in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP700049702700000000000000000666E.xhtml#P700049702700000000000000000666E"><span class="pcalibre label pcalibre1">Chapters </span><span class="pcalibre label pcalibre1">8</span></a> and <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre label pcalibre1">9</span></a>, we will revisit loading and gradually reveal the mystery to you.</p>
<p id="P7000497027000000000000000044B63" data-uri="chapter07.xhtml#P7000497027000000000000000044B63" class="pcalibre calibre3 pcalibre1">For the impatient reader, here is a preview of how loading really works: Each program in a Linux system runs in the context of a process with its own virtual address space. When the shell runs a program, the parent shell process forks a child process that is a duplicate of the parent. The child process invokes the loader via the <code id="P7000497027000000000000000044B64" data-uri="chapter07.xhtml#P7000497027000000000000000044B64" class="pcalibre1 calibre8 pcalibre">execve</code> system call. The loader deletes the child's existing virtual memory segments and creates a new set of code, data, heap, and stack segments. The new stack and heap segments are initialized to zero. The new code and data segments are initialized to the contents of the executable file by mapping pages in the virtual address space to page-size chunks of the executable file. Finally, the loader jumps to the <code id="P7000497027000000000000000044B65" data-uri="chapter07.xhtml#P7000497027000000000000000044B65" class="pcalibre1 calibre8 pcalibre">_start</code> address, which eventually calls the application's <code id="P7000497027000000000000000044B66" data-uri="chapter07.xhtml#P7000497027000000000000000044B66" class="pcalibre1 calibre8 pcalibre">main</code> routine. Aside from some header information, there is no copying of data from disk to memory during loading. The copying is deferred until the CPU references a mapped virtual page, at which point the operating system automatically transfers the page from disk to memory using its paging mechanism.</p>
</aside>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044B67" data-uri="chapter07.xhtml#P7000497027000000000000000044B67">of how much there is in a system. Disk space and kitchen trash cans share this same property.)</p>
<p id="P7000497027000000000000000044B68" data-uri="chapter07.xhtml#P7000497027000000000000000044B68" class="pcalibre1 pcalibre calibre2"><i class="calibre5 pcalibre pcalibre1">Shared libraries</i> are modern innovations that address the disadvantages of static libraries. A shared library is an object module that, at either run time or load time, can be loaded at an arbitrary memory address and linked with a program in memory. This process is known as <i class="calibre5 pcalibre pcalibre1">dynamic linking</i> and is performed by a program called a <i class="calibre5 pcalibre pcalibre1">dynamic linker</i>. Shared libraries are also referred to as <i class="calibre5 pcalibre pcalibre1">shared objects</i>, and on Linux systems they are indicated by the <code id="P7000497027000000000000000044B69" data-uri="chapter07.xhtml#P7000497027000000000000000044B69" class="pcalibre1 calibre8 pcalibre">.so</code> suffix. Microsoft operating systems make heavy use of shared libraries, which they refer to as DLLs (dynamic link libraries).</p>
<p id="P7000497027000000000000000044B6A" data-uri="chapter07.xhtml#P7000497027000000000000000044B6A" class="pcalibre1 pcalibre calibre2">Shared libraries are "shared" in two different ways. First, in any given file system, there is exactly one <code id="P7000497027000000000000000044B6B" data-uri="chapter07.xhtml#P7000497027000000000000000044B6B" class="pcalibre1 calibre8 pcalibre">.so</code> file for a particular library. The code and data in this <code id="P7000497027000000000000000044B6C" data-uri="chapter07.xhtml#P7000497027000000000000000044B6C" class="pcalibre1 calibre8 pcalibre">.so</code> file are shared by all of the executable object files that reference the library, as opposed to the contents of static libraries, which are copied and embedded in the executables that reference them. Second, a single copy of the <code id="P7000497027000000000000000044B6D" data-uri="chapter07.xhtml#P7000497027000000000000000044B6D" class="pcalibre1 calibre8 pcalibre">.text</code> section of a shared library in memory can be shared by different running processes. We will explore this in more detail when we study virtual memory in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006FF7.xhtml#P7000497027000000000000000006FF7"><span class="pcalibre label pcalibre1">Chapter </span><span class="pcalibre label pcalibre1">9</span></a>.</p>
<p id="P7000497027000000000000000044B6E" data-uri="chapter07.xhtml#P7000497027000000000000000044B6E" class="pcalibre1 pcalibre calibre2"><a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="#P70004970270000000000000000063C1"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">7.16</span></a> summarizes the dynamic linking process for the example program in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006160.xhtml#P700049702700000000000000000621E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">7.7</span></a>. To build a shared library <code id="P7000497027000000000000000044B6F" data-uri="chapter07.xhtml#P7000497027000000000000000044B6F" class="pcalibre1 calibre8 pcalibre">libvector.so</code> of our example vector routines in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006160.xhtml#P70004970270000000000000000061F7"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">7.6</span></a>, we invoke the compiler driver with some special directives to the compiler and linker:</p>
<pre id="P7000497027000000000000000044B70" data-uri="chapter07.xhtml#P7000497027000000000000000044B70" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044B71" data-uri="chapter07.xhtml#P7000497027000000000000000044B71" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -shared -fpic -o libvector.so addvec.c multvec.c</i></code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044B72" data-uri="chapter07.xhtml#P7000497027000000000000000044B72">The <code id="P7000497027000000000000000044B73" data-uri="chapter07.xhtml#P7000497027000000000000000044B73" class="pcalibre1 calibre8 pcalibre">-fpic</code> flag directs the compiler to generate <i class="calibre5 pcalibre pcalibre1">position-independent code</i> (more on this in the next section). The <code id="P7000497027000000000000000044B74" data-uri="chapter07.xhtml#P7000497027000000000000000044B74" class="pcalibre1 calibre8 pcalibre">-shared</code> flag directs the linker to create a shared</p>
<figure class="pcalibre5 figure pcalibre" id="P70004970270000000000000000063C1" data-uri="chapter07.xhtml#P70004970270000000000000000063C1">
<span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000063C2" title="700" data-uri="chapter07.xhtml#P70004970270000000000000000063C2" epub:type="pagebreak"></span>
<img alt="A diagram illustrates dynamic linking with shared libraries." id="P7000497027000000000000000044B75" data-uri="P700049702700000000000000000B75D" src="../images/p700-1.png" class="calibre235 pcalibre pcalibre1"/>
<figcaption id="P7000497027000000000000000044B76" data-uri="chapter07.xhtml#P7000497027000000000000000044B76" class="calibre11 pcalibre pcalibre1"><header class="pcalibre halftitlepage pcalibre1"><h1 class="title3 pcalibre pcalibre1" id="P7000497027000000000000000044B77" data-uri="chapter07.xhtml#P7000497027000000000000000044B77" epub:type="title"><span class="pcalibre1 label2 pcalibre">Figure </span><span class="number pcalibre pcalibre1">7.16 </span>Dynamic linking with shared libraries.</h1></header>
<details class="longdesc pcalibre pcalibre1" id="P7000497027000000000000000024E8C" data-uri="chapter07.xhtml#P7000497027000000000000000024E8C">
<summary class="pcalibre6 pcalibre1 pcalibre calibre30"><span class="number pcalibre pcalibre1">Description</span></summary>
<p id="P7000497027000000000000000044B78" data-uri="chapter07.xhtml#P7000497027000000000000000044B78" class="pcalibre1 pcalibre calibre2">A diagram flows from top to bottom as follows:</p>
<ul id="P7000497027000000000000000044B79" data-uri="chapter07.xhtml#P7000497027000000000000000044B79" class="pcalibre calibre31 pcalibre1">
<li id="P7000497027000000000000000044B7A" data-uri="chapter07.xhtml#P7000497027000000000000000044B7A" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B7B" data-uri="chapter07.xhtml#P7000497027000000000000000044B7B" class="pcalibre calibre3 pcalibre1">Main2. C and vector.h</p></li>
<li id="P7000497027000000000000000044B7C" data-uri="chapter07.xhtml#P7000497027000000000000000044B7C" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B7D" data-uri="chapter07.xhtml#P7000497027000000000000000044B7D" class="pcalibre calibre3 pcalibre1">Translators (cpp, cc1, as)</p></li>
<li id="P7000497027000000000000000044B7E" data-uri="chapter07.xhtml#P7000497027000000000000000044B7E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B7F" data-uri="chapter07.xhtml#P7000497027000000000000000044B7F" class="pcalibre calibre3 pcalibre1">Relocatable object file main2.0 and relocation and symbol table info libc.s0, libvector.so</p></li>
<li id="P7000497027000000000000000044B80" data-uri="chapter07.xhtml#P7000497027000000000000000044B80" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B81" data-uri="chapter07.xhtml#P7000497027000000000000000044B81" class="pcalibre calibre3 pcalibre1">Linker (ld)</p></li>
<li id="P7000497027000000000000000044B82" data-uri="chapter07.xhtml#P7000497027000000000000000044B82" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B83" data-uri="chapter07.xhtml#P7000497027000000000000000044B83" class="pcalibre calibre3 pcalibre1">Partially linked executable object file prog21</p></li>
<li id="P7000497027000000000000000044B84" data-uri="chapter07.xhtml#P7000497027000000000000000044B84" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B85" data-uri="chapter07.xhtml#P7000497027000000000000000044B85" class="pcalibre calibre3 pcalibre1">Loader (execve)</p></li>
<li id="P7000497027000000000000000044B86" data-uri="chapter07.xhtml#P7000497027000000000000000044B86" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B87" data-uri="chapter07.xhtml#P7000497027000000000000000044B87" class="pcalibre calibre3 pcalibre1">Fully linked executable in memory Dynamic linker (ld-linux.so); code and data from libc.so, libvector.so.</p></li>
</ul>
</details>

</figcaption>
</figure>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044B88" data-uri="chapter07.xhtml#P7000497027000000000000000044B88">object file. Once we have created the library, we would then link it into our example program in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006160.xhtml#P700049702700000000000000000621E"><span class="pcalibre label pcalibre1">Figure </span><span class="pcalibre label pcalibre1">7.7</span></a>:</p>
<pre id="P7000497027000000000000000044B89" data-uri="chapter07.xhtml#P7000497027000000000000000044B89" class="calibre9 pcalibre pcalibre1"><code id="P7000497027000000000000000044B8A" data-uri="chapter07.xhtml#P7000497027000000000000000044B8A" class="calibre10 pcalibre pcalibre1">linux&gt; <i class="calibre5 pcalibre pcalibre1">gcc -o prog2l main2.c ./libvector.so</i></code></pre>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044B8B" data-uri="chapter07.xhtml#P7000497027000000000000000044B8B">This creates an executable object file <code id="P7000497027000000000000000044B8C" data-uri="chapter07.xhtml#P7000497027000000000000000044B8C" class="pcalibre1 calibre8 pcalibre">prog2l</code> in a form that can be linked with <code id="P7000497027000000000000000044B8D" data-uri="chapter07.xhtml#P7000497027000000000000000044B8D" class="pcalibre1 calibre8 pcalibre">libvector.so</code> at run time. The basic idea is to do some of the linking statically when the executable file is created, and then complete the linking process dynamically when the program is loaded. It is important to realize that none of the code or data sections from <code id="P7000497027000000000000000044B8E" data-uri="chapter07.xhtml#P7000497027000000000000000044B8E" class="pcalibre1 calibre8 pcalibre">libvector.so</code> are actually copied into the executable <code id="P7000497027000000000000000044B8F" data-uri="chapter07.xhtml#P7000497027000000000000000044B8F" class="pcalibre1 calibre8 pcalibre">prog2l</code> at this point. Instead, the linker copies some relocation and symbol table information that will allow references to code and data in <code id="P7000497027000000000000000044B90" data-uri="chapter07.xhtml#P7000497027000000000000000044B90" class="pcalibre1 calibre8 pcalibre">libvector.so</code> to be resolved at load time.</p>
<p id="P7000497027000000000000000044B91" data-uri="chapter07.xhtml#P7000497027000000000000000044B91" class="pcalibre1 pcalibre calibre2">When the loader loads and runs the executable <code id="P7000497027000000000000000044B92" data-uri="chapter07.xhtml#P7000497027000000000000000044B92" class="pcalibre1 calibre8 pcalibre">prog2l</code>, it loads the partially linked executable <code id="P7000497027000000000000000044B93" data-uri="chapter07.xhtml#P7000497027000000000000000044B93" class="pcalibre1 calibre8 pcalibre">prog2l</code>, using the techniques discussed in <a class="pcalibre xref1 pcalibre4 pcalibre2 pcalibre3 pcalibre1" href="fileP7000497027000000000000000006385.xhtml#P7000497027000000000000000006385"><span class="pcalibre label pcalibre1">Section </span><span class="pcalibre label pcalibre1">7.9</span></a>. Next, it notices that <code id="P7000497027000000000000000044B94" data-uri="chapter07.xhtml#P7000497027000000000000000044B94" class="pcalibre1 calibre8 pcalibre">prog2l</code> contains a <code id="P7000497027000000000000000044B95" data-uri="chapter07.xhtml#P7000497027000000000000000044B95" class="pcalibre1 calibre8 pcalibre">.interp</code> section, which contains the path name of the dynamic linker, which is itself a shared object (e.g., <code id="P7000497027000000000000000044B96" data-uri="chapter07.xhtml#P7000497027000000000000000044B96" class="pcalibre1 calibre8 pcalibre">ld-linux.so</code> on Linux systems). Instead of passing control to the application, as it would normally do, the loader loads and runs the dynamic linker. The dynamic linker then finishes the linking task by performing the following relocations:</p>
<ul id="P7000497027000000000000000044B97" data-uri="chapter07.xhtml#P7000497027000000000000000044B97" class="calibre28 pcalibre pcalibre1">
<li id="P7000497027000000000000000044B98" data-uri="chapter07.xhtml#P7000497027000000000000000044B98" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B99" data-uri="chapter07.xhtml#P7000497027000000000000000044B99" class="pcalibre calibre3 pcalibre1">Relocating the text and data of <code id="P7000497027000000000000000044B9A" data-uri="chapter07.xhtml#P7000497027000000000000000044B9A" class="pcalibre1 calibre8 pcalibre">libc.so</code> into some memory segment</p></li>
<li id="P7000497027000000000000000044B9B" data-uri="chapter07.xhtml#P7000497027000000000000000044B9B" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B9C" data-uri="chapter07.xhtml#P7000497027000000000000000044B9C" class="pcalibre calibre3 pcalibre1">Relocating the text and data of <code id="P7000497027000000000000000044B9D" data-uri="chapter07.xhtml#P7000497027000000000000000044B9D" class="pcalibre1 calibre8 pcalibre">libvector.so</code> into another memory segment</p></li>
<li id="P7000497027000000000000000044B9E" data-uri="chapter07.xhtml#P7000497027000000000000000044B9E" class="calibre12 pcalibre pcalibre1"><p id="P7000497027000000000000000044B9F" data-uri="chapter07.xhtml#P7000497027000000000000000044B9F" class="pcalibre calibre3 pcalibre1">Relocating any references in <code id="P7000497027000000000000000044BA0" data-uri="chapter07.xhtml#P7000497027000000000000000044BA0" class="pcalibre1 calibre8 pcalibre">prog2l</code> to symbols defined by <code id="P7000497027000000000000000044BA1" data-uri="chapter07.xhtml#P7000497027000000000000000044BA1" class="pcalibre1 calibre8 pcalibre">libc.so</code> and <code id="P7000497027000000000000000044BA2" data-uri="chapter07.xhtml#P7000497027000000000000000044BA2" class="pcalibre1 calibre8 pcalibre">libvector.so</code></p></li>
</ul>
<p class="pcalibre1 pcalibre calibre2" id="P7000497027000000000000000044BA3" data-uri="chapter07.xhtml#P7000497027000000000000000044BA3"><span class="pcalibre pagebreak pcalibre1" id="P70004970270000000000000000063E2" title="701" data-uri="chapter07.xhtml#P70004970270000000000000000063E2" epub:type="pagebreak"></span>Finally, the dynamic linker passes control to the application. From this point on, the locations of the shared libraries are fixed and do not change during execution of the program.</p>
</section></body></html>
